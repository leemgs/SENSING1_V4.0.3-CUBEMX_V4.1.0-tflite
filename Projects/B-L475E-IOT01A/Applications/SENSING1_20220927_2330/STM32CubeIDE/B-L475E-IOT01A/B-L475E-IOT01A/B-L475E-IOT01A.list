
B-L475E-IOT01A.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .isr_vector   00000188  08004000  08004000  00004000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         00029150  08004190  08004190  00004190  2**4
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .rodata       0002aef0  0802d2e0  0802d2e0  0002d2e0  2**3
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .ARM          00000008  080581d0  080581d0  000581d0  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .init_array   00000004  080581d8  080581d8  000581d8  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  5 .fini_array   00000004  080581dc  080581dc  000581dc  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  6 .data         000021f0  20000000  080581e0  00060000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  7 .bss          00012de0  200021f0  0805a3d0  000621f0  2**3
                  ALLOC
  8 ._user_heap_stack 00001800  20014fd0  0805a3d0  00064fd0  2**0
                  ALLOC
  9 .ARM.attributes 00000034  00000000  00000000  000621f0  2**0
                  CONTENTS, READONLY
 10 .debug_info   000a7865  00000000  00000000  00062224  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 11 .debug_abbrev 000130b3  00000000  00000000  00109a89  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 12 .debug_loc    0007b6f5  00000000  00000000  0011cb3c  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 13 .debug_aranges 00004ad0  00000000  00000000  00198238  2**3
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 14 .debug_ranges 0000ea88  00000000  00000000  0019cd08  2**3
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 15 .debug_macro  00047771  00000000  00000000  001ab790  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 16 .debug_line   000addf7  00000000  00000000  001f2f01  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 17 .debug_str    0015013a  00000000  00000000  002a0cf8  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 18 .comment      00005482  00000000  00000000  003f0e32  2**0
                  CONTENTS, READONLY
 19 .iar.rtmodel  000001c1  00000000  00000000  003f62b4  2**0
                  CONTENTS, READONLY
 20 .iar_vfe_header 00000020  00000000  00000000  003f6478  2**2
                  CONTENTS, READONLY
 21 .debug_frame  00016820  00000000  00000000  003f6498  2**2
                  CONTENTS, READONLY, DEBUGGING, OCTETS

Disassembly of section .text:

08004190 <__do_global_dtors_aux>:
 8004190:	b510      	push	{r4, lr}
 8004192:	4c05      	ldr	r4, [pc, #20]	; (80041a8 <__do_global_dtors_aux+0x18>)
 8004194:	7823      	ldrb	r3, [r4, #0]
 8004196:	b933      	cbnz	r3, 80041a6 <__do_global_dtors_aux+0x16>
 8004198:	4b04      	ldr	r3, [pc, #16]	; (80041ac <__do_global_dtors_aux+0x1c>)
 800419a:	b113      	cbz	r3, 80041a2 <__do_global_dtors_aux+0x12>
 800419c:	4804      	ldr	r0, [pc, #16]	; (80041b0 <__do_global_dtors_aux+0x20>)
 800419e:	f3af 8000 	nop.w
 80041a2:	2301      	movs	r3, #1
 80041a4:	7023      	strb	r3, [r4, #0]
 80041a6:	bd10      	pop	{r4, pc}
 80041a8:	200021f0 	.word	0x200021f0
 80041ac:	00000000 	.word	0x00000000
 80041b0:	0802d2c4 	.word	0x0802d2c4

080041b4 <frame_dummy>:
 80041b4:	b508      	push	{r3, lr}
 80041b6:	4b03      	ldr	r3, [pc, #12]	; (80041c4 <frame_dummy+0x10>)
 80041b8:	b11b      	cbz	r3, 80041c2 <frame_dummy+0xe>
 80041ba:	4903      	ldr	r1, [pc, #12]	; (80041c8 <frame_dummy+0x14>)
 80041bc:	4803      	ldr	r0, [pc, #12]	; (80041cc <frame_dummy+0x18>)
 80041be:	f3af 8000 	nop.w
 80041c2:	bd08      	pop	{r3, pc}
 80041c4:	00000000 	.word	0x00000000
 80041c8:	200021f4 	.word	0x200021f4
 80041cc:	0802d2c4 	.word	0x0802d2c4

080041d0 <_ai_platform_get_io_buffers_info>:
 80041d0:	e92d 4ff2 	stmdb	sp!, {r1, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80041d4:	2500      	movs	r5, #0
 80041d6:	46aa      	mov	sl, r5
 80041d8:	b082      	sub	sp, #8
 80041da:	4607      	mov	r7, r0
 80041dc:	46ab      	mov	fp, r5
 80041de:	46d0      	mov	r8, sl
 80041e0:	46d1      	mov	r9, sl
 80041e2:	e028      	b.n	8004236 <_ai_platform_get_io_buffers_info+0x66>
 80041e4:	2000      	movs	r0, #0
 80041e6:	e01c      	b.n	8004222 <_ai_platform_get_io_buffers_info+0x52>
 80041e8:	f850 400a 	ldr.w	r4, [r0, sl]
 80041ec:	b364      	cbz	r4, 8004248 <_ai_platform_get_io_buffers_info+0x78>
 80041ee:	68b8      	ldr	r0, [r7, #8]
 80041f0:	6841      	ldr	r1, [r0, #4]
 80041f2:	6880      	ldr	r0, [r0, #8]
 80041f4:	4440      	add	r0, r8
 80041f6:	eb01 0609 	add.w	r6, r1, r9
 80041fa:	9000      	str	r0, [sp, #0]
 80041fc:	69a1      	ldr	r1, [r4, #24]
 80041fe:	6808      	ldr	r0, [r1, #0]
 8004200:	f005 fdcc 	bl	8009d9c <ai_array_to_buffer_fmt>
 8004204:	6030      	str	r0, [r6, #0]
 8004206:	2101      	movs	r1, #1
 8004208:	80b1      	strh	r1, [r6, #4]
 800420a:	68e0      	ldr	r0, [r4, #12]
 800420c:	68c1      	ldr	r1, [r0, #12]
 800420e:	80f1      	strh	r1, [r6, #6]
 8004210:	6882      	ldr	r2, [r0, #8]
 8004212:	8132      	strh	r2, [r6, #8]
 8004214:	6840      	ldr	r0, [r0, #4]
 8004216:	60f0      	str	r0, [r6, #12]
 8004218:	69a1      	ldr	r1, [r4, #24]
 800421a:	688a      	ldr	r2, [r1, #8]
 800421c:	6132      	str	r2, [r6, #16]
 800421e:	9800      	ldr	r0, [sp, #0]
 8004220:	b9e0      	cbnz	r0, 800425c <_ai_platform_get_io_buffers_info+0x8c>
 8004222:	6170      	str	r0, [r6, #20]
 8004224:	1c6d      	adds	r5, r5, #1
 8004226:	f10b 0b01 	add.w	fp, fp, #1
 800422a:	f109 0918 	add.w	r9, r9, #24
 800422e:	f108 0808 	add.w	r8, r8, #8
 8004232:	f10a 0a04 	add.w	sl, sl, #4
 8004236:	2f00      	cmp	r7, #0
 8004238:	bf14      	ite	ne
 800423a:	8838      	ldrhne	r0, [r7, #0]
 800423c:	2000      	moveq	r0, #0
 800423e:	4583      	cmp	fp, r0
 8004240:	d202      	bcs.n	8004248 <_ai_platform_get_io_buffers_info+0x78>
 8004242:	6878      	ldr	r0, [r7, #4]
 8004244:	2800      	cmp	r0, #0
 8004246:	d1cf      	bne.n	80041e8 <_ai_platform_get_io_buffers_info+0x18>
 8004248:	b2a8      	uxth	r0, r5
 800424a:	b118      	cbz	r0, 8004254 <_ai_platform_get_io_buffers_info+0x84>
 800424c:	68b9      	ldr	r1, [r7, #8]
 800424e:	9802      	ldr	r0, [sp, #8]
 8004250:	684a      	ldr	r2, [r1, #4]
 8004252:	6002      	str	r2, [r0, #0]
 8004254:	b2a8      	uxth	r0, r5
 8004256:	b003      	add	sp, #12
 8004258:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800425c:	9900      	ldr	r1, [sp, #0]
 800425e:	2000      	movs	r0, #0
 8004260:	6008      	str	r0, [r1, #0]
 8004262:	9a00      	ldr	r2, [sp, #0]
 8004264:	6820      	ldr	r0, [r4, #0]
 8004266:	6050      	str	r0, [r2, #4]
 8004268:	2800      	cmp	r0, #0
 800426a:	bf1c      	itt	ne
 800426c:	8840      	ldrhne	r0, [r0, #2]
 800426e:	2800      	cmpne	r0, #0
 8004270:	d0b8      	beq.n	80041e4 <_ai_platform_get_io_buffers_info+0x14>
 8004272:	9800      	ldr	r0, [sp, #0]
 8004274:	2101      	movs	r1, #1
 8004276:	6001      	str	r1, [r0, #0]
 8004278:	9800      	ldr	r0, [sp, #0]
 800427a:	e7d2      	b.n	8004222 <_ai_platform_get_io_buffers_info+0x52>

0800427c <_platform_network_state_setup>:
 800427c:	b430      	push	{r4, r5}
 800427e:	68d3      	ldr	r3, [r2, #12]
 8004280:	6955      	ldr	r5, [r2, #20]
 8004282:	68dc      	ldr	r4, [r3, #12]
 8004284:	68eb      	ldr	r3, [r5, #12]
 8004286:	435c      	muls	r4, r3
 8004288:	6084      	str	r4, [r0, #8]
 800428a:	888d      	ldrh	r5, [r1, #4]
 800428c:	436c      	muls	r4, r5
 800428e:	60c4      	str	r4, [r0, #12]
 8004290:	6909      	ldr	r1, [r1, #16]
 8004292:	68c3      	ldr	r3, [r0, #12]
 8004294:	6041      	str	r1, [r0, #4]
 8004296:	4419      	add	r1, r3
 8004298:	6001      	str	r1, [r0, #0]
 800429a:	6992      	ldr	r2, [r2, #24]
 800429c:	6814      	ldr	r4, [r2, #0]
 800429e:	00a1      	lsls	r1, r4, #2
 80042a0:	d407      	bmi.n	80042b2 <_platform_network_state_setup+0x36>
 80042a2:	6894      	ldr	r4, [r2, #8]
 80042a4:	68d1      	ldr	r1, [r2, #12]
 80042a6:	6843      	ldr	r3, [r0, #4]
 80042a8:	1a64      	subs	r4, r4, r1
 80042aa:	1919      	adds	r1, r3, r4
 80042ac:	6091      	str	r1, [r2, #8]
 80042ae:	6840      	ldr	r0, [r0, #4]
 80042b0:	60d0      	str	r0, [r2, #12]
 80042b2:	bc30      	pop	{r4, r5}
 80042b4:	4770      	bx	lr

080042b6 <ai_platform_runtime_get_revision>:
 80042b6:	f8df 0814 	ldr.w	r0, [pc, #2068]	; 8004acc <.text_18>
 80042ba:	6801      	ldr	r1, [r0, #0]
 80042bc:	0849      	lsrs	r1, r1, #1
 80042be:	0049      	lsls	r1, r1, #1
 80042c0:	6001      	str	r1, [r0, #0]
 80042c2:	2001      	movs	r0, #1
 80042c4:	f8df 1808 	ldr.w	r1, [pc, #2056]	; 8004ad0 <.text_19>
 80042c8:	6088      	str	r0, [r1, #8]
 80042ca:	6888      	ldr	r0, [r1, #8]
 80042cc:	2800      	cmp	r0, #0
 80042ce:	d1fc      	bne.n	80042ca <ai_platform_runtime_get_revision+0x14>
 80042d0:	f8df 2800 	ldr.w	r2, [pc, #2048]	; 8004ad4 <.text_20>
 80042d4:	600a      	str	r2, [r1, #0]
 80042d6:	6808      	ldr	r0, [r1, #0]
 80042d8:	f8df 17fc 	ldr.w	r1, [pc, #2044]	; 8004ad8 <.text_21>
 80042dc:	4288      	cmp	r0, r1
 80042de:	d000      	beq.n	80042e2 <ai_platform_runtime_get_revision+0x2c>
 80042e0:	e7fe      	b.n	80042e0 <ai_platform_runtime_get_revision+0x2a>
 80042e2:	a0ad      	add	r0, pc, #692	; (adr r0, 8004598 <.text_13>)
 80042e4:	4770      	bx	lr

080042e6 <ai_platform_runtime_get_version>:
 80042e6:	f8df 07e4 	ldr.w	r0, [pc, #2020]	; 8004acc <.text_18>
 80042ea:	6801      	ldr	r1, [r0, #0]
 80042ec:	0849      	lsrs	r1, r1, #1
 80042ee:	0049      	lsls	r1, r1, #1
 80042f0:	6001      	str	r1, [r0, #0]
 80042f2:	2001      	movs	r0, #1
 80042f4:	f8df 17d8 	ldr.w	r1, [pc, #2008]	; 8004ad0 <.text_19>
 80042f8:	6088      	str	r0, [r1, #8]
 80042fa:	6888      	ldr	r0, [r1, #8]
 80042fc:	2800      	cmp	r0, #0
 80042fe:	d1fc      	bne.n	80042fa <ai_platform_runtime_get_version+0x14>
 8004300:	f8df 27d0 	ldr.w	r2, [pc, #2000]	; 8004ad4 <.text_20>
 8004304:	600a      	str	r2, [r1, #0]
 8004306:	6808      	ldr	r0, [r1, #0]
 8004308:	f8df 17cc 	ldr.w	r1, [pc, #1996]	; 8004ad8 <.text_21>
 800430c:	4288      	cmp	r0, r1
 800430e:	d000      	beq.n	8004312 <ai_platform_runtime_get_version+0x2c>
 8004310:	e7fe      	b.n	8004310 <ai_platform_runtime_get_version+0x2a>
 8004312:	f20f 72d0 	addw	r2, pc, #2000	; 0x7d0
 8004316:	6810      	ldr	r0, [r2, #0]
 8004318:	4770      	bx	lr

0800431a <ai_platform_api_get_version>:
 800431a:	f8df 07b0 	ldr.w	r0, [pc, #1968]	; 8004acc <.text_18>
 800431e:	6801      	ldr	r1, [r0, #0]
 8004320:	0849      	lsrs	r1, r1, #1
 8004322:	0049      	lsls	r1, r1, #1
 8004324:	6001      	str	r1, [r0, #0]
 8004326:	2001      	movs	r0, #1
 8004328:	f8df 17a4 	ldr.w	r1, [pc, #1956]	; 8004ad0 <.text_19>
 800432c:	6088      	str	r0, [r1, #8]
 800432e:	6888      	ldr	r0, [r1, #8]
 8004330:	2800      	cmp	r0, #0
 8004332:	d1fc      	bne.n	800432e <ai_platform_api_get_version+0x14>
 8004334:	f8df 279c 	ldr.w	r2, [pc, #1948]	; 8004ad4 <.text_20>
 8004338:	600a      	str	r2, [r1, #0]
 800433a:	6808      	ldr	r0, [r1, #0]
 800433c:	f8df 1798 	ldr.w	r1, [pc, #1944]	; 8004ad8 <.text_21>
 8004340:	4288      	cmp	r0, r1
 8004342:	d000      	beq.n	8004346 <ai_platform_api_get_version+0x2c>
 8004344:	e7fe      	b.n	8004344 <ai_platform_api_get_version+0x2a>
 8004346:	f20f 72a0 	addw	r2, pc, #1952	; 0x7a0
 800434a:	6810      	ldr	r0, [r2, #0]
 800434c:	4770      	bx	lr

0800434e <ai_platform_interface_api_get_version>:
 800434e:	f8df 077c 	ldr.w	r0, [pc, #1916]	; 8004acc <.text_18>
 8004352:	6801      	ldr	r1, [r0, #0]
 8004354:	0849      	lsrs	r1, r1, #1
 8004356:	0049      	lsls	r1, r1, #1
 8004358:	6001      	str	r1, [r0, #0]
 800435a:	2001      	movs	r0, #1
 800435c:	f8df 1770 	ldr.w	r1, [pc, #1904]	; 8004ad0 <.text_19>
 8004360:	6088      	str	r0, [r1, #8]
 8004362:	6888      	ldr	r0, [r1, #8]
 8004364:	2800      	cmp	r0, #0
 8004366:	d1fc      	bne.n	8004362 <ai_platform_interface_api_get_version+0x14>
 8004368:	f8df 2768 	ldr.w	r2, [pc, #1896]	; 8004ad4 <.text_20>
 800436c:	600a      	str	r2, [r1, #0]
 800436e:	6808      	ldr	r0, [r1, #0]
 8004370:	f8df 1764 	ldr.w	r1, [pc, #1892]	; 8004ad8 <.text_21>
 8004374:	4288      	cmp	r0, r1
 8004376:	d000      	beq.n	800437a <ai_platform_interface_api_get_version+0x2c>
 8004378:	e7fe      	b.n	8004378 <ai_platform_interface_api_get_version+0x2a>
 800437a:	f20f 7270 	addw	r2, pc, #1904	; 0x770
 800437e:	6810      	ldr	r0, [r2, #0]
 8004380:	4770      	bx	lr

08004382 <ai_platform_context_acquire>:
 8004382:	b120      	cbz	r0, 800438e <ai_platform_context_acquire+0xc>
 8004384:	6801      	ldr	r1, [r0, #0]
 8004386:	f8df 2754 	ldr.w	r2, [pc, #1876]	; 8004adc <.text_22>
 800438a:	4291      	cmp	r1, r2
 800438c:	d000      	beq.n	8004390 <ai_platform_context_acquire+0xe>
 800438e:	2000      	movs	r0, #0
 8004390:	f8df 1738 	ldr.w	r1, [pc, #1848]	; 8004acc <.text_18>
 8004394:	680a      	ldr	r2, [r1, #0]
 8004396:	0852      	lsrs	r2, r2, #1
 8004398:	0052      	lsls	r2, r2, #1
 800439a:	600a      	str	r2, [r1, #0]
 800439c:	2101      	movs	r1, #1
 800439e:	f8df 2730 	ldr.w	r2, [pc, #1840]	; 8004ad0 <.text_19>
 80043a2:	6091      	str	r1, [r2, #8]
 80043a4:	6891      	ldr	r1, [r2, #8]
 80043a6:	2900      	cmp	r1, #0
 80043a8:	d1fc      	bne.n	80043a4 <ai_platform_context_acquire+0x22>
 80043aa:	f8df 3728 	ldr.w	r3, [pc, #1832]	; 8004ad4 <.text_20>
 80043ae:	6013      	str	r3, [r2, #0]
 80043b0:	6811      	ldr	r1, [r2, #0]
 80043b2:	f8df 2724 	ldr.w	r2, [pc, #1828]	; 8004ad8 <.text_21>
 80043b6:	4291      	cmp	r1, r2
 80043b8:	d000      	beq.n	80043bc <ai_platform_context_acquire+0x3a>
 80043ba:	e7fe      	b.n	80043ba <ai_platform_context_acquire+0x38>
 80043bc:	4770      	bx	lr

080043be <ai_platform_context_release>:
 80043be:	f8df 171c 	ldr.w	r1, [pc, #1820]	; 8004adc <.text_22>
 80043c2:	6001      	str	r1, [r0, #0]
 80043c4:	4770      	bx	lr

080043c6 <ai_platform_network_get_error>:
 80043c6:	b120      	cbz	r0, 80043d2 <ai_platform_network_get_error+0xc>
 80043c8:	6801      	ldr	r1, [r0, #0]
 80043ca:	f8df 2710 	ldr.w	r2, [pc, #1808]	; 8004adc <.text_22>
 80043ce:	4291      	cmp	r1, r2
 80043d0:	d000      	beq.n	80043d4 <ai_platform_network_get_error+0xe>
 80043d2:	2000      	movs	r0, #0
 80043d4:	f8df 16f4 	ldr.w	r1, [pc, #1780]	; 8004acc <.text_18>
 80043d8:	680a      	ldr	r2, [r1, #0]
 80043da:	0852      	lsrs	r2, r2, #1
 80043dc:	0052      	lsls	r2, r2, #1
 80043de:	600a      	str	r2, [r1, #0]
 80043e0:	2101      	movs	r1, #1
 80043e2:	f8df 26ec 	ldr.w	r2, [pc, #1772]	; 8004ad0 <.text_19>
 80043e6:	6091      	str	r1, [r2, #8]
 80043e8:	6891      	ldr	r1, [r2, #8]
 80043ea:	2900      	cmp	r1, #0
 80043ec:	d1fc      	bne.n	80043e8 <ai_platform_network_get_error+0x22>
 80043ee:	f8df 36e4 	ldr.w	r3, [pc, #1764]	; 8004ad4 <.text_20>
 80043f2:	6013      	str	r3, [r2, #0]
 80043f4:	6811      	ldr	r1, [r2, #0]
 80043f6:	f8df 26e0 	ldr.w	r2, [pc, #1760]	; 8004ad8 <.text_21>
 80043fa:	4291      	cmp	r1, r2
 80043fc:	d000      	beq.n	8004400 <ai_platform_network_get_error+0x3a>
 80043fe:	e7fe      	b.n	80043fe <ai_platform_network_get_error+0x38>
 8004400:	2800      	cmp	r0, #0
 8004402:	bf1c      	itt	ne
 8004404:	3010      	addne	r0, #16
 8004406:	f000 bb83 	bne.w	8004b10 <core_get_error>
 800440a:	f20f 60f4 	addw	r0, pc, #1780	; 0x6f4
 800440e:	6800      	ldr	r0, [r0, #0]
 8004410:	4770      	bx	lr

08004412 <ai_platform_network_set_error>:
 8004412:	2800      	cmp	r0, #0
 8004414:	bf1c      	itt	ne
 8004416:	3010      	addne	r0, #16
 8004418:	f000 bb7f 	bne.w	8004b1a <core_set_error>
 800441c:	4770      	bx	lr

0800441e <ai_platform_api_get_network_report>:
 800441e:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8004422:	ea5f 0900 	movs.w	r9, r0
 8004426:	b081      	sub	sp, #4
 8004428:	460c      	mov	r4, r1
 800442a:	d005      	beq.n	8004438 <ai_platform_api_get_network_report+0x1a>
 800442c:	f8d9 0000 	ldr.w	r0, [r9]
 8004430:	f8df 16a8 	ldr.w	r1, [pc, #1704]	; 8004adc <.text_22>
 8004434:	4288      	cmp	r0, r1
 8004436:	d001      	beq.n	800443c <ai_platform_api_get_network_report+0x1e>
 8004438:	f04f 0900 	mov.w	r9, #0
 800443c:	f8df 568c 	ldr.w	r5, [pc, #1676]	; 8004acc <.text_18>
 8004440:	f8df 668c 	ldr.w	r6, [pc, #1676]	; 8004ad0 <.text_19>
 8004444:	6828      	ldr	r0, [r5, #0]
 8004446:	0840      	lsrs	r0, r0, #1
 8004448:	0040      	lsls	r0, r0, #1
 800444a:	6028      	str	r0, [r5, #0]
 800444c:	2101      	movs	r1, #1
 800444e:	60b1      	str	r1, [r6, #8]
 8004450:	68b0      	ldr	r0, [r6, #8]
 8004452:	2800      	cmp	r0, #0
 8004454:	d1fc      	bne.n	8004450 <ai_platform_api_get_network_report+0x32>
 8004456:	f8df 767c 	ldr.w	r7, [pc, #1660]	; 8004ad4 <.text_20>
 800445a:	f8df 867c 	ldr.w	r8, [pc, #1660]	; 8004ad8 <.text_21>
 800445e:	6037      	str	r7, [r6, #0]
 8004460:	6830      	ldr	r0, [r6, #0]
 8004462:	4540      	cmp	r0, r8
 8004464:	d000      	beq.n	8004468 <ai_platform_api_get_network_report+0x4a>
 8004466:	e7fe      	b.n	8004466 <ai_platform_api_get_network_report+0x48>
 8004468:	f1b9 0f00 	cmp.w	r9, #0
 800446c:	bf18      	it	ne
 800446e:	2c00      	cmpne	r4, #0
 8004470:	d034      	beq.n	80044dc <ai_platform_api_get_network_report+0xbe>
 8004472:	2000      	movs	r0, #0
 8004474:	66e0      	str	r0, [r4, #108]	; 0x6c
 8004476:	f8d9 2050 	ldr.w	r2, [r9, #80]	; 0x50
 800447a:	b152      	cbz	r2, 8004492 <ai_platform_api_get_network_report+0x74>
 800447c:	e000      	b.n	8004480 <ai_platform_api_get_network_report+0x62>
 800447e:	4602      	mov	r2, r0
 8004480:	6ee1      	ldr	r1, [r4, #108]	; 0x6c
 8004482:	1c49      	adds	r1, r1, #1
 8004484:	66e1      	str	r1, [r4, #108]	; 0x6c
 8004486:	68d0      	ldr	r0, [r2, #12]
 8004488:	4282      	cmp	r2, r0
 800448a:	bf18      	it	ne
 800448c:	2800      	cmpne	r0, #0
 800448e:	d1f6      	bne.n	800447e <ai_platform_api_get_network_report+0x60>
 8004490:	b911      	cbnz	r1, 8004498 <ai_platform_api_get_network_report+0x7a>
 8004492:	2218      	movs	r2, #24
 8004494:	2111      	movs	r1, #17
 8004496:	e01d      	b.n	80044d4 <ai_platform_api_get_network_report+0xb6>
 8004498:	f8b9 0048 	ldrh.w	r0, [r9, #72]	; 0x48
 800449c:	b108      	cbz	r0, 80044a2 <ai_platform_api_get_network_report+0x84>
 800449e:	f8d9 004c 	ldr.w	r0, [r9, #76]	; 0x4c
 80044a2:	f104 0134 	add.w	r1, r4, #52	; 0x34
 80044a6:	f7ff fe93 	bl	80041d0 <_ai_platform_get_io_buffers_info>
 80044aa:	8620      	strh	r0, [r4, #48]	; 0x30
 80044ac:	b910      	cbnz	r0, 80044b4 <ai_platform_api_get_network_report+0x96>
 80044ae:	2218      	movs	r2, #24
 80044b0:	2112      	movs	r1, #18
 80044b2:	e00f      	b.n	80044d4 <ai_platform_api_get_network_report+0xb6>
 80044b4:	f8b9 0048 	ldrh.w	r0, [r9, #72]	; 0x48
 80044b8:	2802      	cmp	r0, #2
 80044ba:	bfa6      	itte	ge
 80044bc:	f8d9 004c 	ldrge.w	r0, [r9, #76]	; 0x4c
 80044c0:	300c      	addge	r0, #12
 80044c2:	2000      	movlt	r0, #0
 80044c4:	f104 0138 	add.w	r1, r4, #56	; 0x38
 80044c8:	f7ff fe82 	bl	80041d0 <_ai_platform_get_io_buffers_info>
 80044cc:	8660      	strh	r0, [r4, #50]	; 0x32
 80044ce:	b948      	cbnz	r0, 80044e4 <ai_platform_api_get_network_report+0xc6>
 80044d0:	2218      	movs	r2, #24
 80044d2:	2113      	movs	r1, #19
 80044d4:	f109 0010 	add.w	r0, r9, #16
 80044d8:	f000 fb1f 	bl	8004b1a <core_set_error>
 80044dc:	2000      	movs	r0, #0
 80044de:	b001      	add	sp, #4
 80044e0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80044e4:	f8d9 0004 	ldr.w	r0, [r9, #4]
 80044e8:	6720      	str	r0, [r4, #112]	; 0x70
 80044ea:	f109 0230 	add.w	r2, r9, #48	; 0x30
 80044ee:	e892 5c09 	ldmia.w	r2, {r0, r3, sl, fp, ip, lr}
 80044f2:	f104 013c 	add.w	r1, r4, #60	; 0x3c
 80044f6:	f109 0918 	add.w	r9, r9, #24
 80044fa:	e881 5c09 	stmia.w	r1, {r0, r3, sl, fp, ip, lr}
 80044fe:	e899 540e 	ldmia.w	r9, {r1, r2, r3, sl, ip, lr}
 8004502:	f104 0054 	add.w	r0, r4, #84	; 0x54
 8004506:	e880 540e 	stmia.w	r0, {r1, r2, r3, sl, ip, lr}
 800450a:	6828      	ldr	r0, [r5, #0]
 800450c:	0840      	lsrs	r0, r0, #1
 800450e:	0040      	lsls	r0, r0, #1
 8004510:	6028      	str	r0, [r5, #0]
 8004512:	2301      	movs	r3, #1
 8004514:	60b3      	str	r3, [r6, #8]
 8004516:	68b0      	ldr	r0, [r6, #8]
 8004518:	2800      	cmp	r0, #0
 800451a:	d1fc      	bne.n	8004516 <ai_platform_api_get_network_report+0xf8>
 800451c:	6037      	str	r7, [r6, #0]
 800451e:	6831      	ldr	r1, [r6, #0]
 8004520:	4541      	cmp	r1, r8
 8004522:	d000      	beq.n	8004526 <ai_platform_api_get_network_report+0x108>
 8004524:	e7fe      	b.n	8004524 <ai_platform_api_get_network_report+0x106>
 8004526:	a01c      	add	r0, pc, #112	; (adr r0, 8004598 <.text_13>)
 8004528:	6120      	str	r0, [r4, #16]
 800452a:	6829      	ldr	r1, [r5, #0]
 800452c:	0849      	lsrs	r1, r1, #1
 800452e:	0049      	lsls	r1, r1, #1
 8004530:	6029      	str	r1, [r5, #0]
 8004532:	60b3      	str	r3, [r6, #8]
 8004534:	68b0      	ldr	r0, [r6, #8]
 8004536:	2800      	cmp	r0, #0
 8004538:	d1fc      	bne.n	8004534 <ai_platform_api_get_network_report+0x116>
 800453a:	6037      	str	r7, [r6, #0]
 800453c:	6831      	ldr	r1, [r6, #0]
 800453e:	4541      	cmp	r1, r8
 8004540:	d000      	beq.n	8004544 <ai_platform_api_get_network_report+0x126>
 8004542:	e7fe      	b.n	8004542 <ai_platform_api_get_network_report+0x124>
 8004544:	f20f 509c 	addw	r0, pc, #1436	; 0x59c
 8004548:	6802      	ldr	r2, [r0, #0]
 800454a:	6162      	str	r2, [r4, #20]
 800454c:	6829      	ldr	r1, [r5, #0]
 800454e:	0849      	lsrs	r1, r1, #1
 8004550:	0049      	lsls	r1, r1, #1
 8004552:	6029      	str	r1, [r5, #0]
 8004554:	60b3      	str	r3, [r6, #8]
 8004556:	68b0      	ldr	r0, [r6, #8]
 8004558:	2800      	cmp	r0, #0
 800455a:	d1fc      	bne.n	8004556 <ai_platform_api_get_network_report+0x138>
 800455c:	6037      	str	r7, [r6, #0]
 800455e:	6831      	ldr	r1, [r6, #0]
 8004560:	4541      	cmp	r1, r8
 8004562:	d000      	beq.n	8004566 <ai_platform_api_get_network_report+0x148>
 8004564:	e7fe      	b.n	8004564 <ai_platform_api_get_network_report+0x146>
 8004566:	f20f 5080 	addw	r0, pc, #1408	; 0x580
 800456a:	6802      	ldr	r2, [r0, #0]
 800456c:	6262      	str	r2, [r4, #36]	; 0x24
 800456e:	6829      	ldr	r1, [r5, #0]
 8004570:	0849      	lsrs	r1, r1, #1
 8004572:	0049      	lsls	r1, r1, #1
 8004574:	6029      	str	r1, [r5, #0]
 8004576:	60b3      	str	r3, [r6, #8]
 8004578:	68b0      	ldr	r0, [r6, #8]
 800457a:	2800      	cmp	r0, #0
 800457c:	d1fc      	bne.n	8004578 <ai_platform_api_get_network_report+0x15a>
 800457e:	6037      	str	r7, [r6, #0]
 8004580:	6831      	ldr	r1, [r6, #0]
 8004582:	4541      	cmp	r1, r8
 8004584:	d000      	beq.n	8004588 <ai_platform_api_get_network_report+0x16a>
 8004586:	e7fe      	b.n	8004586 <ai_platform_api_get_network_report+0x168>
 8004588:	f20f 5060 	addw	r0, pc, #1376	; 0x560
 800458c:	6802      	ldr	r2, [r0, #0]
 800458e:	62a2      	str	r2, [r4, #40]	; 0x28
 8004590:	2001      	movs	r0, #1
 8004592:	b001      	add	sp, #4
 8004594:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

08004598 <.text_13>:
 8004598:	00000000 	.word	0x00000000

0800459c <ai_platform_network_create>:
 800459c:	b570      	push	{r4, r5, r6, lr}
 800459e:	9d04      	ldr	r5, [sp, #16]
 80045a0:	4604      	mov	r4, r0
 80045a2:	9805      	ldr	r0, [sp, #20]
 80045a4:	b2db      	uxtb	r3, r3
 80045a6:	042d      	lsls	r5, r5, #16
 80045a8:	ea45 6503 	orr.w	r5, r5, r3, lsl #24
 80045ac:	ea45 2500 	orr.w	r5, r5, r0, lsl #8
 80045b0:	f20f 5050 	addw	r0, pc, #1360	; 0x550
 80045b4:	6806      	ldr	r6, [r0, #0]
 80045b6:	f8df 0514 	ldr.w	r0, [pc, #1300]	; 8004acc <.text_18>
 80045ba:	6801      	ldr	r1, [r0, #0]
 80045bc:	0849      	lsrs	r1, r1, #1
 80045be:	0049      	lsls	r1, r1, #1
 80045c0:	6001      	str	r1, [r0, #0]
 80045c2:	2001      	movs	r0, #1
 80045c4:	f8df 1508 	ldr.w	r1, [pc, #1288]	; 8004ad0 <.text_19>
 80045c8:	6088      	str	r0, [r1, #8]
 80045ca:	6888      	ldr	r0, [r1, #8]
 80045cc:	2800      	cmp	r0, #0
 80045ce:	d1fc      	bne.n	80045ca <ai_platform_network_create+0x2e>
 80045d0:	f8df 3500 	ldr.w	r3, [pc, #1280]	; 8004ad4 <.text_20>
 80045d4:	600b      	str	r3, [r1, #0]
 80045d6:	6808      	ldr	r0, [r1, #0]
 80045d8:	f8df 14fc 	ldr.w	r1, [pc, #1276]	; 8004ad8 <.text_21>
 80045dc:	4288      	cmp	r0, r1
 80045de:	d000      	beq.n	80045e2 <ai_platform_network_create+0x46>
 80045e0:	e7fe      	b.n	80045e0 <ai_platform_network_create+0x44>
 80045e2:	b91c      	cbnz	r4, 80045ec <ai_platform_network_create+0x50>
 80045e4:	f20f 5020 	addw	r0, pc, #1312	; 0x520
 80045e8:	6800      	ldr	r0, [r0, #0]
 80045ea:	bd70      	pop	{r4, r5, r6, pc}
 80045ec:	f8df 14ec 	ldr.w	r1, [pc, #1260]	; 8004adc <.text_22>
 80045f0:	6011      	str	r1, [r2, #0]
 80045f2:	6022      	str	r2, [r4, #0]
 80045f4:	f000 fa8a 	bl	8004b0c <core_init>
 80045f8:	b910      	cbnz	r0, 8004600 <ai_platform_network_create+0x64>
 80045fa:	f20f 40f4 	addw	r0, pc, #1268	; 0x4f4
 80045fe:	e00d      	b.n	800461c <ai_platform_network_create+0x80>
 8004600:	f8df 14dc 	ldr.w	r1, [pc, #1244]	; 8004ae0 <.text_23>
 8004604:	428d      	cmp	r5, r1
 8004606:	bf28      	it	cs
 8004608:	f20f 40e8 	addwcs	r0, pc, #1256	; 0x4e8
 800460c:	d206      	bcs.n	800461c <ai_platform_network_create+0x80>
 800460e:	f20f 40e8 	addw	r0, pc, #1256	; 0x4e8
 8004612:	f000 fa97 	bl	8004b44 <ai_check_custom_types>
 8004616:	b920      	cbnz	r0, 8004622 <ai_platform_network_create+0x86>
 8004618:	f20f 40e0 	addw	r0, pc, #1248	; 0x4e0
 800461c:	6806      	ldr	r6, [r0, #0]
 800461e:	2100      	movs	r1, #0
 8004620:	6021      	str	r1, [r4, #0]
 8004622:	4630      	mov	r0, r6
 8004624:	bd70      	pop	{r4, r5, r6, pc}

08004626 <ai_platform_network_destroy>:
 8004626:	b130      	cbz	r0, 8004636 <ai_platform_network_destroy+0x10>
 8004628:	6801      	ldr	r1, [r0, #0]
 800462a:	f8df 24b0 	ldr.w	r2, [pc, #1200]	; 8004adc <.text_22>
 800462e:	4291      	cmp	r1, r2
 8004630:	bf08      	it	eq
 8004632:	4602      	moveq	r2, r0
 8004634:	d000      	beq.n	8004638 <ai_platform_network_destroy+0x12>
 8004636:	2200      	movs	r2, #0
 8004638:	f8df 1490 	ldr.w	r1, [pc, #1168]	; 8004acc <.text_18>
 800463c:	680b      	ldr	r3, [r1, #0]
 800463e:	085b      	lsrs	r3, r3, #1
 8004640:	005b      	lsls	r3, r3, #1
 8004642:	600b      	str	r3, [r1, #0]
 8004644:	2101      	movs	r1, #1
 8004646:	f8df 3488 	ldr.w	r3, [pc, #1160]	; 8004ad0 <.text_19>
 800464a:	6099      	str	r1, [r3, #8]
 800464c:	6899      	ldr	r1, [r3, #8]
 800464e:	2900      	cmp	r1, #0
 8004650:	d1fc      	bne.n	800464c <ai_platform_network_destroy+0x26>
 8004652:	f8df c480 	ldr.w	ip, [pc, #1152]	; 8004ad4 <.text_20>
 8004656:	f8c3 c000 	str.w	ip, [r3]
 800465a:	6819      	ldr	r1, [r3, #0]
 800465c:	f8df 3478 	ldr.w	r3, [pc, #1144]	; 8004ad8 <.text_21>
 8004660:	4299      	cmp	r1, r3
 8004662:	d000      	beq.n	8004666 <ai_platform_network_destroy+0x40>
 8004664:	e7fe      	b.n	8004664 <ai_platform_network_destroy+0x3e>
 8004666:	b102      	cbz	r2, 800466a <ai_platform_network_destroy+0x44>
 8004668:	2000      	movs	r0, #0
 800466a:	4770      	bx	lr

0800466c <ai_platform_network_init>:
 800466c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8004670:	b081      	sub	sp, #4
 8004672:	460a      	mov	r2, r1
 8004674:	b120      	cbz	r0, 8004680 <ai_platform_network_init+0x14>
 8004676:	6801      	ldr	r1, [r0, #0]
 8004678:	f8df 3460 	ldr.w	r3, [pc, #1120]	; 8004adc <.text_22>
 800467c:	4299      	cmp	r1, r3
 800467e:	d000      	beq.n	8004682 <ai_platform_network_init+0x16>
 8004680:	2000      	movs	r0, #0
 8004682:	f8df 1448 	ldr.w	r1, [pc, #1096]	; 8004acc <.text_18>
 8004686:	680b      	ldr	r3, [r1, #0]
 8004688:	085b      	lsrs	r3, r3, #1
 800468a:	005b      	lsls	r3, r3, #1
 800468c:	600b      	str	r3, [r1, #0]
 800468e:	2101      	movs	r1, #1
 8004690:	f8df 343c 	ldr.w	r3, [pc, #1084]	; 8004ad0 <.text_19>
 8004694:	6099      	str	r1, [r3, #8]
 8004696:	6899      	ldr	r1, [r3, #8]
 8004698:	2900      	cmp	r1, #0
 800469a:	d1fc      	bne.n	8004696 <ai_platform_network_init+0x2a>
 800469c:	f8df 4434 	ldr.w	r4, [pc, #1076]	; 8004ad4 <.text_20>
 80046a0:	601c      	str	r4, [r3, #0]
 80046a2:	6819      	ldr	r1, [r3, #0]
 80046a4:	f8df 3430 	ldr.w	r3, [pc, #1072]	; 8004ad8 <.text_21>
 80046a8:	4299      	cmp	r1, r3
 80046aa:	d000      	beq.n	80046ae <ai_platform_network_init+0x42>
 80046ac:	e7fe      	b.n	80046ac <ai_platform_network_init+0x40>
 80046ae:	2800      	cmp	r0, #0
 80046b0:	d035      	beq.n	800471e <ai_platform_network_init+0xb2>
 80046b2:	b90a      	cbnz	r2, 80046b8 <ai_platform_network_init+0x4c>
 80046b4:	2211      	movs	r2, #17
 80046b6:	e012      	b.n	80046de <ai_platform_network_init+0x72>
 80046b8:	6913      	ldr	r3, [r2, #16]
 80046ba:	6a91      	ldr	r1, [r2, #40]	; 0x28
 80046bc:	b939      	cbnz	r1, 80046ce <ai_platform_network_init+0x62>
 80046be:	8c11      	ldrh	r1, [r2, #32]
 80046c0:	8bd5      	ldrh	r5, [r2, #30]
 80046c2:	6a54      	ldr	r4, [r2, #36]	; 0x24
 80046c4:	4369      	muls	r1, r5
 80046c6:	4361      	muls	r1, r4
 80046c8:	bf18      	it	ne
 80046ca:	2213      	movne	r2, #19
 80046cc:	d107      	bne.n	80046de <ai_platform_network_init+0x72>
 80046ce:	b973      	cbnz	r3, 80046ee <ai_platform_network_init+0x82>
 80046d0:	8911      	ldrh	r1, [r2, #8]
 80046d2:	88d4      	ldrh	r4, [r2, #6]
 80046d4:	68d3      	ldr	r3, [r2, #12]
 80046d6:	4361      	muls	r1, r4
 80046d8:	4359      	muls	r1, r3
 80046da:	d008      	beq.n	80046ee <ai_platform_network_init+0x82>
 80046dc:	2212      	movs	r2, #18
 80046de:	2110      	movs	r1, #16
 80046e0:	3010      	adds	r0, #16
 80046e2:	f000 fa1a 	bl	8004b1a <core_set_error>
 80046e6:	2000      	movs	r0, #0
 80046e8:	b001      	add	sp, #4
 80046ea:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80046ee:	e8b2 10f8 	ldmia.w	r2!, {r3, r4, r5, r6, r7, ip}
 80046f2:	f100 0118 	add.w	r1, r0, #24
 80046f6:	f100 0e30 	add.w	lr, r0, #48	; 0x30
 80046fa:	e881 10f8 	stmia.w	r1, {r3, r4, r5, r6, r7, ip}
 80046fe:	e892 0f0a 	ldmia.w	r2, {r1, r3, r8, r9, sl, fp}
 8004702:	e88e 0f0a 	stmia.w	lr, {r1, r3, r8, r9, sl, fp}
 8004706:	2103      	movs	r1, #3
 8004708:	6d02      	ldr	r2, [r0, #80]	; 0x50
 800470a:	60c1      	str	r1, [r0, #12]
 800470c:	b13a      	cbz	r2, 800471e <ai_platform_network_init+0xb2>
 800470e:	e000      	b.n	8004712 <ai_platform_network_init+0xa6>
 8004710:	460a      	mov	r2, r1
 8004712:	68d1      	ldr	r1, [r2, #12]
 8004714:	6090      	str	r0, [r2, #8]
 8004716:	428a      	cmp	r2, r1
 8004718:	bf18      	it	ne
 800471a:	2900      	cmpne	r1, #0
 800471c:	d1f8      	bne.n	8004710 <ai_platform_network_init+0xa4>
 800471e:	b001      	add	sp, #4
 8004720:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

08004724 <ai_platform_network_process>:
 8004724:	e92d 4ff4 	stmdb	sp!, {r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8004728:	b082      	sub	sp, #8
 800472a:	460a      	mov	r2, r1
 800472c:	b120      	cbz	r0, 8004738 <ai_platform_network_process+0x14>
 800472e:	6801      	ldr	r1, [r0, #0]
 8004730:	f8df 33a8 	ldr.w	r3, [pc, #936]	; 8004adc <.text_22>
 8004734:	4299      	cmp	r1, r3
 8004736:	d000      	beq.n	800473a <ai_platform_network_process+0x16>
 8004738:	2000      	movs	r0, #0
 800473a:	f8df 1390 	ldr.w	r1, [pc, #912]	; 8004acc <.text_18>
 800473e:	680b      	ldr	r3, [r1, #0]
 8004740:	085b      	lsrs	r3, r3, #1
 8004742:	005b      	lsls	r3, r3, #1
 8004744:	600b      	str	r3, [r1, #0]
 8004746:	2101      	movs	r1, #1
 8004748:	f8df 3384 	ldr.w	r3, [pc, #900]	; 8004ad0 <.text_19>
 800474c:	6099      	str	r1, [r3, #8]
 800474e:	6899      	ldr	r1, [r3, #8]
 8004750:	2900      	cmp	r1, #0
 8004752:	d1fc      	bne.n	800474e <ai_platform_network_process+0x2a>
 8004754:	f8df 437c 	ldr.w	r4, [pc, #892]	; 8004ad4 <.text_20>
 8004758:	601c      	str	r4, [r3, #0]
 800475a:	6819      	ldr	r1, [r3, #0]
 800475c:	f8df 3378 	ldr.w	r3, [pc, #888]	; 8004ad8 <.text_21>
 8004760:	4299      	cmp	r1, r3
 8004762:	d000      	beq.n	8004766 <ai_platform_network_process+0x42>
 8004764:	e7fe      	b.n	8004764 <ai_platform_network_process+0x40>
 8004766:	2800      	cmp	r0, #0
 8004768:	f000 8113 	beq.w	8004992 <ai_platform_network_process+0x26e>
 800476c:	f8b0 1048 	ldrh.w	r1, [r0, #72]	; 0x48
 8004770:	b101      	cbz	r1, 8004774 <ai_platform_network_process+0x50>
 8004772:	6cc1      	ldr	r1, [r0, #76]	; 0x4c
 8004774:	2300      	movs	r3, #0
 8004776:	82c3      	strh	r3, [r0, #22]
 8004778:	2400      	movs	r4, #0
 800477a:	7b03      	ldrb	r3, [r0, #12]
 800477c:	8284      	strh	r4, [r0, #20]
 800477e:	f003 0303 	and.w	r3, r3, #3
 8004782:	2b03      	cmp	r3, #3
 8004784:	d002      	beq.n	800478c <ai_platform_network_process+0x68>
 8004786:	2230      	movs	r2, #48	; 0x30
 8004788:	2111      	movs	r1, #17
 800478a:	e0ff      	b.n	800498c <ai_platform_network_process+0x268>
 800478c:	2a00      	cmp	r2, #0
 800478e:	bf1e      	ittt	ne
 8004790:	2900      	cmpne	r1, #0
 8004792:	880b      	ldrhne	r3, [r1, #0]
 8004794:	2b00      	cmpne	r3, #0
 8004796:	f000 80f7 	beq.w	8004988 <ai_platform_network_process+0x264>
 800479a:	f8b2 b004 	ldrh.w	fp, [r2, #4]
 800479e:	9100      	str	r1, [sp, #0]
 80047a0:	46a0      	mov	r8, r4
 80047a2:	46a1      	mov	r9, r4
 80047a4:	2600      	movs	r6, #0
 80047a6:	1d17      	adds	r7, r2, #4
 80047a8:	4682      	mov	sl, r0
 80047aa:	e014      	b.n	80047d6 <ai_platform_network_process+0xb2>
 80047ac:	68f8      	ldr	r0, [r7, #12]
 80047ae:	2800      	cmp	r0, #0
 80047b0:	f000 80e9 	beq.w	8004986 <ai_platform_network_process+0x262>
 80047b4:	8838      	ldrh	r0, [r7, #0]
 80047b6:	2800      	cmp	r0, #0
 80047b8:	d052      	beq.n	8004860 <ai_platform_network_process+0x13c>
 80047ba:	4558      	cmp	r0, fp
 80047bc:	bf28      	it	cs
 80047be:	4683      	movcs	fp, r0
 80047c0:	4622      	mov	r2, r4
 80047c2:	1f39      	subs	r1, r7, #4
 80047c4:	4628      	mov	r0, r5
 80047c6:	f7ff fd59 	bl	800427c <_platform_network_state_setup>
 80047ca:	f108 0801 	add.w	r8, r8, #1
 80047ce:	3718      	adds	r7, #24
 80047d0:	3610      	adds	r6, #16
 80047d2:	f109 0904 	add.w	r9, r9, #4
 80047d6:	9800      	ldr	r0, [sp, #0]
 80047d8:	8801      	ldrh	r1, [r0, #0]
 80047da:	4588      	cmp	r8, r1
 80047dc:	d24a      	bcs.n	8004874 <ai_platform_network_process+0x150>
 80047de:	6840      	ldr	r0, [r0, #4]
 80047e0:	2800      	cmp	r0, #0
 80047e2:	bf1c      	itt	ne
 80047e4:	f850 4009 	ldrne.w	r4, [r0, r9]
 80047e8:	2c00      	cmpne	r4, #0
 80047ea:	d043      	beq.n	8004874 <ai_platform_network_process+0x150>
 80047ec:	9800      	ldr	r0, [sp, #0]
 80047ee:	6881      	ldr	r1, [r0, #8]
 80047f0:	680a      	ldr	r2, [r1, #0]
 80047f2:	1995      	adds	r5, r2, r6
 80047f4:	f000 80c7 	beq.w	8004986 <ai_platform_network_process+0x262>
 80047f8:	69a0      	ldr	r0, [r4, #24]
 80047fa:	6841      	ldr	r1, [r0, #4]
 80047fc:	887b      	ldrh	r3, [r7, #2]
 80047fe:	88ba      	ldrh	r2, [r7, #4]
 8004800:	68b8      	ldr	r0, [r7, #8]
 8004802:	fb03 fc02 	mul.w	ip, r3, r2
 8004806:	fb00 fc0c 	mul.w	ip, r0, ip
 800480a:	4561      	cmp	r1, ip
 800480c:	d32d      	bcc.n	800486a <ai_platform_network_process+0x146>
 800480e:	f8d4 c00c 	ldr.w	ip, [r4, #12]
 8004812:	f8dc e00c 	ldr.w	lr, [ip, #12]
 8004816:	459e      	cmp	lr, r3
 8004818:	bf01      	itttt	eq
 800481a:	f8dc 3008 	ldreq.w	r3, [ip, #8]
 800481e:	4293      	cmpeq	r3, r2
 8004820:	f8dc 2004 	ldreq.w	r2, [ip, #4]
 8004824:	4282      	cmpeq	r2, r0
 8004826:	d120      	bne.n	800486a <ai_platform_network_process+0x146>
 8004828:	69a0      	ldr	r0, [r4, #24]
 800482a:	6800      	ldr	r0, [r0, #0]
 800482c:	f005 fb8e 	bl	8009f4c <ai_array_get_byte_size>
 8004830:	68e1      	ldr	r1, [r4, #12]
 8004832:	68ca      	ldr	r2, [r1, #12]
 8004834:	6961      	ldr	r1, [r4, #20]
 8004836:	68cb      	ldr	r3, [r1, #12]
 8004838:	435a      	muls	r2, r3
 800483a:	4290      	cmp	r0, r2
 800483c:	d315      	bcc.n	800486a <ai_platform_network_process+0x146>
 800483e:	69a0      	ldr	r0, [r4, #24]
 8004840:	6800      	ldr	r0, [r0, #0]
 8004842:	f005 faab 	bl	8009d9c <ai_array_to_buffer_fmt>
 8004846:	f857 1c04 	ldr.w	r1, [r7, #-4]
 800484a:	f020 407e 	bic.w	r0, r0, #4261412864	; 0xfe000000
 800484e:	f021 417e 	bic.w	r1, r1, #4261412864	; 0xfe000000
 8004852:	4288      	cmp	r0, r1
 8004854:	d0aa      	beq.n	80047ac <ai_platform_network_process+0x88>
 8004856:	2219      	movs	r2, #25
 8004858:	2112      	movs	r1, #18
 800485a:	f10a 0010 	add.w	r0, sl, #16
 800485e:	e096      	b.n	800498e <ai_platform_network_process+0x26a>
 8004860:	2221      	movs	r2, #33	; 0x21
 8004862:	2112      	movs	r1, #18
 8004864:	f10a 0010 	add.w	r0, sl, #16
 8004868:	e091      	b.n	800498e <ai_platform_network_process+0x26a>
 800486a:	2218      	movs	r2, #24
 800486c:	2112      	movs	r1, #18
 800486e:	f10a 0010 	add.w	r0, sl, #16
 8004872:	e08c      	b.n	800498e <ai_platform_network_process+0x26a>
 8004874:	9902      	ldr	r1, [sp, #8]
 8004876:	2900      	cmp	r1, #0
 8004878:	4655      	mov	r5, sl
 800487a:	d075      	beq.n	8004968 <ai_platform_network_process+0x244>
 800487c:	f8b5 0048 	ldrh.w	r0, [r5, #72]	; 0x48
 8004880:	2802      	cmp	r0, #2
 8004882:	db7b      	blt.n	800497c <ai_platform_network_process+0x258>
 8004884:	6ce8      	ldr	r0, [r5, #76]	; 0x4c
 8004886:	300c      	adds	r0, #12
 8004888:	bf1c      	itt	ne
 800488a:	8802      	ldrhne	r2, [r0, #0]
 800488c:	2a00      	cmpne	r2, #0
 800488e:	d075      	beq.n	800497c <ai_platform_network_process+0x258>
 8004890:	f04f 0800 	mov.w	r8, #0
 8004894:	46c1      	mov	r9, r8
 8004896:	2600      	movs	r6, #0
 8004898:	1d0f      	adds	r7, r1, #4
 800489a:	9000      	str	r0, [sp, #0]
 800489c:	e013      	b.n	80048c6 <ai_platform_network_process+0x1a2>
 800489e:	68f8      	ldr	r0, [r7, #12]
 80048a0:	2800      	cmp	r0, #0
 80048a2:	d059      	beq.n	8004958 <ai_platform_network_process+0x234>
 80048a4:	8838      	ldrh	r0, [r7, #0]
 80048a6:	2800      	cmp	r0, #0
 80048a8:	d051      	beq.n	800494e <ai_platform_network_process+0x22a>
 80048aa:	4558      	cmp	r0, fp
 80048ac:	bf28      	it	cs
 80048ae:	4683      	movcs	fp, r0
 80048b0:	4622      	mov	r2, r4
 80048b2:	1f39      	subs	r1, r7, #4
 80048b4:	4628      	mov	r0, r5
 80048b6:	f7ff fce1 	bl	800427c <_platform_network_state_setup>
 80048ba:	f108 0801 	add.w	r8, r8, #1
 80048be:	3718      	adds	r7, #24
 80048c0:	3610      	adds	r6, #16
 80048c2:	f109 0904 	add.w	r9, r9, #4
 80048c6:	9800      	ldr	r0, [sp, #0]
 80048c8:	8801      	ldrh	r1, [r0, #0]
 80048ca:	4588      	cmp	r8, r1
 80048cc:	d249      	bcs.n	8004962 <ai_platform_network_process+0x23e>
 80048ce:	6840      	ldr	r0, [r0, #4]
 80048d0:	2800      	cmp	r0, #0
 80048d2:	bf1c      	itt	ne
 80048d4:	f850 4009 	ldrne.w	r4, [r0, r9]
 80048d8:	2c00      	cmpne	r4, #0
 80048da:	d042      	beq.n	8004962 <ai_platform_network_process+0x23e>
 80048dc:	9800      	ldr	r0, [sp, #0]
 80048de:	6881      	ldr	r1, [r0, #8]
 80048e0:	680a      	ldr	r2, [r1, #0]
 80048e2:	1995      	adds	r5, r2, r6
 80048e4:	d038      	beq.n	8004958 <ai_platform_network_process+0x234>
 80048e6:	69a0      	ldr	r0, [r4, #24]
 80048e8:	6841      	ldr	r1, [r0, #4]
 80048ea:	887b      	ldrh	r3, [r7, #2]
 80048ec:	88ba      	ldrh	r2, [r7, #4]
 80048ee:	68b8      	ldr	r0, [r7, #8]
 80048f0:	fb03 fc02 	mul.w	ip, r3, r2
 80048f4:	fb00 fc0c 	mul.w	ip, r0, ip
 80048f8:	4561      	cmp	r1, ip
 80048fa:	d33e      	bcc.n	800497a <ai_platform_network_process+0x256>
 80048fc:	f8d4 c00c 	ldr.w	ip, [r4, #12]
 8004900:	f8dc e00c 	ldr.w	lr, [ip, #12]
 8004904:	459e      	cmp	lr, r3
 8004906:	bf01      	itttt	eq
 8004908:	f8dc 3008 	ldreq.w	r3, [ip, #8]
 800490c:	4293      	cmpeq	r3, r2
 800490e:	f8dc 2004 	ldreq.w	r2, [ip, #4]
 8004912:	4282      	cmpeq	r2, r0
 8004914:	d131      	bne.n	800497a <ai_platform_network_process+0x256>
 8004916:	69a0      	ldr	r0, [r4, #24]
 8004918:	6800      	ldr	r0, [r0, #0]
 800491a:	f005 fb17 	bl	8009f4c <ai_array_get_byte_size>
 800491e:	68e1      	ldr	r1, [r4, #12]
 8004920:	68ca      	ldr	r2, [r1, #12]
 8004922:	6961      	ldr	r1, [r4, #20]
 8004924:	68cb      	ldr	r3, [r1, #12]
 8004926:	435a      	muls	r2, r3
 8004928:	4290      	cmp	r0, r2
 800492a:	d326      	bcc.n	800497a <ai_platform_network_process+0x256>
 800492c:	69a0      	ldr	r0, [r4, #24]
 800492e:	6800      	ldr	r0, [r0, #0]
 8004930:	f005 fa34 	bl	8009d9c <ai_array_to_buffer_fmt>
 8004934:	f857 1c04 	ldr.w	r1, [r7, #-4]
 8004938:	f020 407e 	bic.w	r0, r0, #4261412864	; 0xfe000000
 800493c:	f021 417e 	bic.w	r1, r1, #4261412864	; 0xfe000000
 8004940:	4288      	cmp	r0, r1
 8004942:	d0ac      	beq.n	800489e <ai_platform_network_process+0x17a>
 8004944:	2219      	movs	r2, #25
 8004946:	2113      	movs	r1, #19
 8004948:	f10a 0010 	add.w	r0, sl, #16
 800494c:	e01f      	b.n	800498e <ai_platform_network_process+0x26a>
 800494e:	2221      	movs	r2, #33	; 0x21
 8004950:	2113      	movs	r1, #19
 8004952:	f10a 0010 	add.w	r0, sl, #16
 8004956:	e01a      	b.n	800498e <ai_platform_network_process+0x26a>
 8004958:	2217      	movs	r2, #23
 800495a:	2113      	movs	r1, #19
 800495c:	f10a 0010 	add.w	r0, sl, #16
 8004960:	e015      	b.n	800498e <ai_platform_network_process+0x26a>
 8004962:	4655      	mov	r5, sl
 8004964:	f8a5 b014 	strh.w	fp, [r5, #20]
 8004968:	f8b5 0048 	ldrh.w	r0, [r5, #72]	; 0x48
 800496c:	2800      	cmp	r0, #0
 800496e:	bf14      	ite	ne
 8004970:	f8d5 a04c 	ldrne.w	sl, [r5, #76]	; 0x4c
 8004974:	f04f 0a00 	moveq.w	sl, #0
 8004978:	e00f      	b.n	800499a <ai_platform_network_process+0x276>
 800497a:	4655      	mov	r5, sl
 800497c:	2218      	movs	r2, #24
 800497e:	2113      	movs	r1, #19
 8004980:	f105 0010 	add.w	r0, r5, #16
 8004984:	e003      	b.n	800498e <ai_platform_network_process+0x26a>
 8004986:	4650      	mov	r0, sl
 8004988:	2217      	movs	r2, #23
 800498a:	2112      	movs	r1, #18
 800498c:	3010      	adds	r0, #16
 800498e:	f000 f8c4 	bl	8004b1a <core_set_error>
 8004992:	2000      	movs	r0, #0
 8004994:	b003      	add	sp, #12
 8004996:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800499a:	2802      	cmp	r0, #2
 800499c:	bfa6      	itte	ge
 800499e:	6ce8      	ldrge	r0, [r5, #76]	; 0x4c
 80049a0:	f100 0b0c 	addge.w	fp, r0, #12
 80049a4:	f04f 0b00 	movlt.w	fp, #0
 80049a8:	8ae8      	ldrh	r0, [r5, #22]
 80049aa:	8aa9      	ldrh	r1, [r5, #20]
 80049ac:	ebb0 0f01 	cmp.w	r0, r1
 80049b0:	f080 8087 	bcs.w	8004ac2 <ai_platform_network_process+0x39e>
 80049b4:	f04f 0800 	mov.w	r8, #0
 80049b8:	4654      	mov	r4, sl
 80049ba:	46c1      	mov	r9, r8
 80049bc:	46c2      	mov	sl, r8
 80049be:	e018      	b.n	80049f2 <ai_platform_network_process+0x2ce>
 80049c0:	6882      	ldr	r2, [r0, #8]
 80049c2:	68c3      	ldr	r3, [r0, #12]
 80049c4:	6871      	ldr	r1, [r6, #4]
 80049c6:	1ad2      	subs	r2, r2, r3
 80049c8:	4411      	add	r1, r2
 80049ca:	6081      	str	r1, [r0, #8]
 80049cc:	6872      	ldr	r2, [r6, #4]
 80049ce:	60c2      	str	r2, [r0, #12]
 80049d0:	6870      	ldr	r0, [r6, #4]
 80049d2:	68b1      	ldr	r1, [r6, #8]
 80049d4:	4408      	add	r0, r1
 80049d6:	6070      	str	r0, [r6, #4]
 80049d8:	6831      	ldr	r1, [r6, #0]
 80049da:	4288      	cmp	r0, r1
 80049dc:	d302      	bcc.n	80049e4 <ai_platform_network_process+0x2c0>
 80049de:	68f0      	ldr	r0, [r6, #12]
 80049e0:	4240      	negs	r0, r0
 80049e2:	4408      	add	r0, r1
 80049e4:	6070      	str	r0, [r6, #4]
 80049e6:	f10a 0a01 	add.w	sl, sl, #1
 80049ea:	f109 0910 	add.w	r9, r9, #16
 80049ee:	f108 0804 	add.w	r8, r8, #4
 80049f2:	2c00      	cmp	r4, #0
 80049f4:	bf14      	ite	ne
 80049f6:	8820      	ldrhne	r0, [r4, #0]
 80049f8:	2000      	moveq	r0, #0
 80049fa:	4582      	cmp	sl, r0
 80049fc:	d212      	bcs.n	8004a24 <ai_platform_network_process+0x300>
 80049fe:	6860      	ldr	r0, [r4, #4]
 8004a00:	b180      	cbz	r0, 8004a24 <ai_platform_network_process+0x300>
 8004a02:	f850 0008 	ldr.w	r0, [r0, r8]
 8004a06:	b168      	cbz	r0, 8004a24 <ai_platform_network_process+0x300>
 8004a08:	68a1      	ldr	r1, [r4, #8]
 8004a0a:	6980      	ldr	r0, [r0, #24]
 8004a0c:	680a      	ldr	r2, [r1, #0]
 8004a0e:	6801      	ldr	r1, [r0, #0]
 8004a10:	eb02 0609 	add.w	r6, r2, r9
 8004a14:	008a      	lsls	r2, r1, #2
 8004a16:	d5d3      	bpl.n	80049c0 <ai_platform_network_process+0x29c>
 8004a18:	68b2      	ldr	r2, [r6, #8]
 8004a1a:	6871      	ldr	r1, [r6, #4]
 8004a1c:	6880      	ldr	r0, [r0, #8]
 8004a1e:	f022 fb64 	bl	80270ea <__aeabi_memcpy>
 8004a22:	e7d5      	b.n	80049d0 <ai_platform_network_process+0x2ac>
 8004a24:	46a2      	mov	sl, r4
 8004a26:	4628      	mov	r0, r5
 8004a28:	f000 f936 	bl	8004c98 <ai_layers_forward_all>
 8004a2c:	f04f 0800 	mov.w	r8, #0
 8004a30:	465c      	mov	r4, fp
 8004a32:	46c1      	mov	r9, r8
 8004a34:	46c3      	mov	fp, r8
 8004a36:	e017      	b.n	8004a68 <ai_platform_network_process+0x344>
 8004a38:	6871      	ldr	r1, [r6, #4]
 8004a3a:	68b2      	ldr	r2, [r6, #8]
 8004a3c:	4411      	add	r1, r2
 8004a3e:	6071      	str	r1, [r6, #4]
 8004a40:	6832      	ldr	r2, [r6, #0]
 8004a42:	4291      	cmp	r1, r2
 8004a44:	d302      	bcc.n	8004a4c <ai_platform_network_process+0x328>
 8004a46:	68f1      	ldr	r1, [r6, #12]
 8004a48:	4249      	negs	r1, r1
 8004a4a:	4411      	add	r1, r2
 8004a4c:	6071      	str	r1, [r6, #4]
 8004a4e:	6882      	ldr	r2, [r0, #8]
 8004a50:	68c3      	ldr	r3, [r0, #12]
 8004a52:	1ad2      	subs	r2, r2, r3
 8004a54:	4411      	add	r1, r2
 8004a56:	6081      	str	r1, [r0, #8]
 8004a58:	6872      	ldr	r2, [r6, #4]
 8004a5a:	60c2      	str	r2, [r0, #12]
 8004a5c:	f10b 0b01 	add.w	fp, fp, #1
 8004a60:	f109 0910 	add.w	r9, r9, #16
 8004a64:	f108 0804 	add.w	r8, r8, #4
 8004a68:	2c00      	cmp	r4, #0
 8004a6a:	bf14      	ite	ne
 8004a6c:	8820      	ldrhne	r0, [r4, #0]
 8004a6e:	2000      	moveq	r0, #0
 8004a70:	4583      	cmp	fp, r0
 8004a72:	d21d      	bcs.n	8004ab0 <ai_platform_network_process+0x38c>
 8004a74:	6860      	ldr	r0, [r4, #4]
 8004a76:	b1d8      	cbz	r0, 8004ab0 <ai_platform_network_process+0x38c>
 8004a78:	f850 0008 	ldr.w	r0, [r0, r8]
 8004a7c:	b1c0      	cbz	r0, 8004ab0 <ai_platform_network_process+0x38c>
 8004a7e:	68a1      	ldr	r1, [r4, #8]
 8004a80:	6980      	ldr	r0, [r0, #24]
 8004a82:	680a      	ldr	r2, [r1, #0]
 8004a84:	6801      	ldr	r1, [r0, #0]
 8004a86:	eb02 0609 	add.w	r6, r2, r9
 8004a8a:	008a      	lsls	r2, r1, #2
 8004a8c:	d5d4      	bpl.n	8004a38 <ai_platform_network_process+0x314>
 8004a8e:	6881      	ldr	r1, [r0, #8]
 8004a90:	68b2      	ldr	r2, [r6, #8]
 8004a92:	6870      	ldr	r0, [r6, #4]
 8004a94:	f022 fb29 	bl	80270ea <__aeabi_memcpy>
 8004a98:	6870      	ldr	r0, [r6, #4]
 8004a9a:	68b1      	ldr	r1, [r6, #8]
 8004a9c:	4408      	add	r0, r1
 8004a9e:	6070      	str	r0, [r6, #4]
 8004aa0:	6831      	ldr	r1, [r6, #0]
 8004aa2:	4288      	cmp	r0, r1
 8004aa4:	d302      	bcc.n	8004aac <ai_platform_network_process+0x388>
 8004aa6:	68f0      	ldr	r0, [r6, #12]
 8004aa8:	4240      	negs	r0, r0
 8004aaa:	4408      	add	r0, r1
 8004aac:	6070      	str	r0, [r6, #4]
 8004aae:	e7d5      	b.n	8004a5c <ai_platform_network_process+0x338>
 8004ab0:	8ae8      	ldrh	r0, [r5, #22]
 8004ab2:	8aa9      	ldrh	r1, [r5, #20]
 8004ab4:	1c40      	adds	r0, r0, #1
 8004ab6:	82e8      	strh	r0, [r5, #22]
 8004ab8:	46a3      	mov	fp, r4
 8004aba:	b280      	uxth	r0, r0
 8004abc:	4288      	cmp	r0, r1
 8004abe:	f4ff af79 	bcc.w	80049b4 <ai_platform_network_process+0x290>
 8004ac2:	8ae8      	ldrh	r0, [r5, #22]
 8004ac4:	b003      	add	sp, #12
 8004ac6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	...

08004acc <.text_18>:
 8004acc:	e0002000 	.word	0xe0002000

08004ad0 <.text_19>:
 8004ad0:	40023000 	.word	0x40023000

08004ad4 <.text_20>:
 8004ad4:	f407a5c2 	.word	0xf407a5c2

08004ad8 <.text_21>:
 8004ad8:	b5e8b5cd 	.word	0xb5e8b5cd

08004adc <.text_22>:
 8004adc:	a1c00100 	.word	0xa1c00100

08004ae0 <.text_23>:
 8004ae0:	01030001 	.word	0x01030001

08004ae4 <.text_24>:
 8004ae4:	00000104 	.word	0x00000104

08004ae8 <.text_25>:
 8004ae8:	00000101 	.word	0x00000101

08004aec <.text_26>:
 8004aec:	00000301 	.word	0x00000301

08004af0 <.text_27>:
 8004af0:	00001030 	.word	0x00001030

08004af4 <.text_28>:
 8004af4:	00001001 	.word	0x00001001

08004af8 <_platform_network_sanity_check{5}::signatures>:
 8004af8:	84048403                                ....

08004afc <.text_30>:
 8004afc:	00001002 	.word	0x00001002

08004b00 <.text_31>:
 8004b00:	00001010 	.word	0x00001010

08004b04 <.text_32>:
 8004b04:	00000000 	.word	0x00000000

08004b08 <.text_33>:
 8004b08:	00001010 	.word	0x00001010

08004b0c <core_init>:
 8004b0c:	2001      	movs	r0, #1
 8004b0e:	4770      	bx	lr

08004b10 <core_get_error>:
 8004b10:	4601      	mov	r1, r0
 8004b12:	2200      	movs	r2, #0
 8004b14:	6808      	ldr	r0, [r1, #0]
 8004b16:	600a      	str	r2, [r1, #0]
 8004b18:	4770      	bx	lr

08004b1a <core_set_error>:
 8004b1a:	7803      	ldrb	r3, [r0, #0]
 8004b1c:	ea5f 6c03 	movs.w	ip, r3, lsl #24
 8004b20:	d104      	bne.n	8004b2c <core_set_error+0x12>
 8004b22:	ea41 2102 	orr.w	r1, r1, r2, lsl #8
 8004b26:	6001      	str	r1, [r0, #0]
 8004b28:	2001      	movs	r0, #1
 8004b2a:	4770      	bx	lr
 8004b2c:	2000      	movs	r0, #0
 8004b2e:	4770      	bx	lr

08004b30 <ai_layers_forward_layer>:
 8004b30:	b510      	push	{r4, lr}
 8004b32:	4604      	mov	r4, r0
 8004b34:	6921      	ldr	r1, [r4, #16]
 8004b36:	4788      	blx	r1
 8004b38:	68e0      	ldr	r0, [r4, #12]
 8004b3a:	42a0      	cmp	r0, r4
 8004b3c:	bf08      	it	eq
 8004b3e:	2000      	moveq	r0, #0
 8004b40:	bd10      	pop	{r4, pc}
	...

08004b44 <ai_check_custom_types>:
 8004b44:	b500      	push	{lr}
 8004b46:	b081      	sub	sp, #4
 8004b48:	b160      	cbz	r0, 8004b64 <ai_check_custom_types+0x20>
 8004b4a:	7801      	ldrb	r1, [r0, #0]
 8004b4c:	2903      	cmp	r1, #3
 8004b4e:	d109      	bne.n	8004b64 <ai_check_custom_types+0x20>
 8004b50:	f05f 0204 	movs.w	r2, #4
 8004b54:	a18d      	add	r1, pc, #564	; (adr r1, 8004d8c <ai_check_custom_types::ref_signatures>)
 8004b56:	f022 fcd7 	bl	8027508 <memcmp>
 8004b5a:	1e40      	subs	r0, r0, #1
 8004b5c:	4180      	sbcs	r0, r0
 8004b5e:	0fc0      	lsrs	r0, r0, #31
 8004b60:	b001      	add	sp, #4
 8004b62:	bd00      	pop	{pc}
 8004b64:	2000      	movs	r0, #0
 8004b66:	b001      	add	sp, #4
 8004b68:	bd00      	pop	{pc}
	...

08004b6c <ai_layer_type_name>:
 8004b6c:	f242 7211 	movw	r2, #10001	; 0x2711
 8004b70:	1a81      	subs	r1, r0, r2
 8004b72:	2901      	cmp	r1, #1
 8004b74:	bf81      	itttt	hi
 8004b76:	1ec9      	subhi	r1, r1, #3
 8004b78:	290d      	cmphi	r1, #13
 8004b7a:	390f      	subhi	r1, #15
 8004b7c:	2909      	cmphi	r1, #9
 8004b7e:	f200 806b 	bhi.w	8004c58 <ai_layer_type_name+0xec>
 8004b82:	1a80      	subs	r0, r0, r2
 8004b84:	d033      	beq.n	8004bee <ai_layer_type_name+0x82>
 8004b86:	1e40      	subs	r0, r0, #1
 8004b88:	d033      	beq.n	8004bf2 <ai_layer_type_name+0x86>
 8004b8a:	1e80      	subs	r0, r0, #2
 8004b8c:	d033      	beq.n	8004bf6 <ai_layer_type_name+0x8a>
 8004b8e:	1e40      	subs	r0, r0, #1
 8004b90:	d034      	beq.n	8004bfc <ai_layer_type_name+0x90>
 8004b92:	1e40      	subs	r0, r0, #1
 8004b94:	d034      	beq.n	8004c00 <ai_layer_type_name+0x94>
 8004b96:	1e40      	subs	r0, r0, #1
 8004b98:	d034      	beq.n	8004c04 <ai_layer_type_name+0x98>
 8004b9a:	1e40      	subs	r0, r0, #1
 8004b9c:	d034      	beq.n	8004c08 <ai_layer_type_name+0x9c>
 8004b9e:	1e40      	subs	r0, r0, #1
 8004ba0:	d034      	beq.n	8004c0c <ai_layer_type_name+0xa0>
 8004ba2:	1e40      	subs	r0, r0, #1
 8004ba4:	d034      	beq.n	8004c10 <ai_layer_type_name+0xa4>
 8004ba6:	1e40      	subs	r0, r0, #1
 8004ba8:	d034      	beq.n	8004c14 <ai_layer_type_name+0xa8>
 8004baa:	1e40      	subs	r0, r0, #1
 8004bac:	d034      	beq.n	8004c18 <ai_layer_type_name+0xac>
 8004bae:	1e40      	subs	r0, r0, #1
 8004bb0:	d034      	beq.n	8004c1c <ai_layer_type_name+0xb0>
 8004bb2:	1e40      	subs	r0, r0, #1
 8004bb4:	d034      	beq.n	8004c20 <ai_layer_type_name+0xb4>
 8004bb6:	1e40      	subs	r0, r0, #1
 8004bb8:	d034      	beq.n	8004c24 <ai_layer_type_name+0xb8>
 8004bba:	1e40      	subs	r0, r0, #1
 8004bbc:	d034      	beq.n	8004c28 <ai_layer_type_name+0xbc>
 8004bbe:	1e40      	subs	r0, r0, #1
 8004bc0:	d034      	beq.n	8004c2c <ai_layer_type_name+0xc0>
 8004bc2:	1e80      	subs	r0, r0, #2
 8004bc4:	d034      	beq.n	8004c30 <ai_layer_type_name+0xc4>
 8004bc6:	1e40      	subs	r0, r0, #1
 8004bc8:	d034      	beq.n	8004c34 <ai_layer_type_name+0xc8>
 8004bca:	1e40      	subs	r0, r0, #1
 8004bcc:	d034      	beq.n	8004c38 <ai_layer_type_name+0xcc>
 8004bce:	1e40      	subs	r0, r0, #1
 8004bd0:	d034      	beq.n	8004c3c <ai_layer_type_name+0xd0>
 8004bd2:	1e40      	subs	r0, r0, #1
 8004bd4:	d034      	beq.n	8004c40 <ai_layer_type_name+0xd4>
 8004bd6:	1e40      	subs	r0, r0, #1
 8004bd8:	d034      	beq.n	8004c44 <ai_layer_type_name+0xd8>
 8004bda:	1e40      	subs	r0, r0, #1
 8004bdc:	d034      	beq.n	8004c48 <ai_layer_type_name+0xdc>
 8004bde:	1e40      	subs	r0, r0, #1
 8004be0:	d034      	beq.n	8004c4c <ai_layer_type_name+0xe0>
 8004be2:	1e40      	subs	r0, r0, #1
 8004be4:	d034      	beq.n	8004c50 <ai_layer_type_name+0xe4>
 8004be6:	1e40      	subs	r0, r0, #1
 8004be8:	d034      	beq.n	8004c54 <ai_layer_type_name+0xe8>
 8004bea:	a01c      	add	r0, pc, #112	; (adr r0, 8004c5c <.text_5>)
 8004bec:	4770      	bx	lr
 8004bee:	a01c      	add	r0, pc, #112	; (adr r0, 8004c60 <.text_6>)
 8004bf0:	4770      	bx	lr
 8004bf2:	a01c      	add	r0, pc, #112	; (adr r0, 8004c64 <.text_7>)
 8004bf4:	4770      	bx	lr
 8004bf6:	bf00      	nop
 8004bf8:	a031      	add	r0, pc, #196	; (adr r0, 8004cc0 <.text_15>)
 8004bfa:	4770      	bx	lr
 8004bfc:	a032      	add	r0, pc, #200	; (adr r0, 8004cc8 <.text_16>)
 8004bfe:	4770      	bx	lr
 8004c00:	a019      	add	r0, pc, #100	; (adr r0, 8004c68 <.text_8>)
 8004c02:	4770      	bx	lr
 8004c04:	a019      	add	r0, pc, #100	; (adr r0, 8004c6c <.text_9>)
 8004c06:	4770      	bx	lr
 8004c08:	a031      	add	r0, pc, #196	; (adr r0, 8004cd0 <.text_17>)
 8004c0a:	4770      	bx	lr
 8004c0c:	a018      	add	r0, pc, #96	; (adr r0, 8004c70 <.text_10>)
 8004c0e:	4770      	bx	lr
 8004c10:	a031      	add	r0, pc, #196	; (adr r0, 8004cd8 <.text_18>)
 8004c12:	4770      	bx	lr
 8004c14:	a032      	add	r0, pc, #200	; (adr r0, 8004ce0 <.text_19>)
 8004c16:	4770      	bx	lr
 8004c18:	a036      	add	r0, pc, #216	; (adr r0, 8004cf4 <.text_20>)
 8004c1a:	4770      	bx	lr
 8004c1c:	a038      	add	r0, pc, #224	; (adr r0, 8004d00 <.text_21>)
 8004c1e:	4770      	bx	lr
 8004c20:	a014      	add	r0, pc, #80	; (adr r0, 8004c74 <.text_11>)
 8004c22:	4770      	bx	lr
 8004c24:	a038      	add	r0, pc, #224	; (adr r0, 8004d08 <.text_22>)
 8004c26:	4770      	bx	lr
 8004c28:	a039      	add	r0, pc, #228	; (adr r0, 8004d10 <.text_23>)
 8004c2a:	4770      	bx	lr
 8004c2c:	a03b      	add	r0, pc, #236	; (adr r0, 8004d1c <.text_24>)
 8004c2e:	4770      	bx	lr
 8004c30:	a03f      	add	r0, pc, #252	; (adr r0, 8004d30 <.text_25>)
 8004c32:	4770      	bx	lr
 8004c34:	a040      	add	r0, pc, #256	; (adr r0, 8004d38 <.text_26>)
 8004c36:	4770      	bx	lr
 8004c38:	a041      	add	r0, pc, #260	; (adr r0, 8004d40 <.text_27>)
 8004c3a:	4770      	bx	lr
 8004c3c:	a043      	add	r0, pc, #268	; (adr r0, 8004d4c <.text_28>)
 8004c3e:	4770      	bx	lr
 8004c40:	a044      	add	r0, pc, #272	; (adr r0, 8004d54 <.text_29>)
 8004c42:	4770      	bx	lr
 8004c44:	a045      	add	r0, pc, #276	; (adr r0, 8004d5c <.text_30>)
 8004c46:	4770      	bx	lr
 8004c48:	a00b      	add	r0, pc, #44	; (adr r0, 8004c78 <.text_12>)
 8004c4a:	4770      	bx	lr
 8004c4c:	a049      	add	r0, pc, #292	; (adr r0, 8004d74 <.text_31>)
 8004c4e:	4770      	bx	lr
 8004c50:	a04a      	add	r0, pc, #296	; (adr r0, 8004d7c <.text_32>)
 8004c52:	4770      	bx	lr
 8004c54:	a04b      	add	r0, pc, #300	; (adr r0, 8004d84 <.text_33>)
 8004c56:	4770      	bx	lr
 8004c58:	a000      	add	r0, pc, #0	; (adr r0, 8004c5c <.text_5>)
 8004c5a:	4770      	bx	lr

08004c5c <.text_5>:
 8004c5c:	00000000 	.word	0x00000000

08004c60 <.text_6>:
 8004c60:	00444441 	.word	0x00444441

08004c64 <.text_7>:
 8004c64:	00004e42 	.word	0x00004e42

08004c68 <.text_8>:
 8004c68:	00555247 	.word	0x00555247

08004c6c <.text_9>:
 8004c6c:	004e524c 	.word	0x004e524c

08004c70 <.text_10>:
 8004c70:	00004c4e 	.word	0x00004c4e

08004c74 <.text_11>:
 8004c74:	00004d53 	.word	0x00004d53

08004c78 <.text_12>:
 8004c78:	00444150 	.word	0x00444150

08004c7c <ai_layer_type_is_valid>:
 8004c7c:	f242 7111 	movw	r1, #10001	; 0x2711
 8004c80:	1a40      	subs	r0, r0, r1
 8004c82:	2801      	cmp	r0, #1
 8004c84:	bf81      	itttt	hi
 8004c86:	1ec0      	subhi	r0, r0, #3
 8004c88:	280d      	cmphi	r0, #13
 8004c8a:	380f      	subhi	r0, #15
 8004c8c:	2809      	cmphi	r0, #9
 8004c8e:	d801      	bhi.n	8004c94 <ai_layer_type_is_valid+0x18>
 8004c90:	2001      	movs	r0, #1
 8004c92:	4770      	bx	lr
 8004c94:	2000      	movs	r0, #0
 8004c96:	4770      	bx	lr

08004c98 <ai_layers_forward_all>:
 8004c98:	b530      	push	{r4, r5, lr}
 8004c9a:	4604      	mov	r4, r0
 8004c9c:	b081      	sub	sp, #4
 8004c9e:	6d20      	ldr	r0, [r4, #80]	; 0x50
 8004ca0:	b158      	cbz	r0, 8004cba <ai_layers_forward_all+0x22>
 8004ca2:	6560      	str	r0, [r4, #84]	; 0x54
 8004ca4:	6d65      	ldr	r5, [r4, #84]	; 0x54
 8004ca6:	6929      	ldr	r1, [r5, #16]
 8004ca8:	4628      	mov	r0, r5
 8004caa:	4788      	blx	r1
 8004cac:	68e8      	ldr	r0, [r5, #12]
 8004cae:	42a8      	cmp	r0, r5
 8004cb0:	bf08      	it	eq
 8004cb2:	2000      	moveq	r0, #0
 8004cb4:	2800      	cmp	r0, #0
 8004cb6:	6560      	str	r0, [r4, #84]	; 0x54
 8004cb8:	d1f4      	bne.n	8004ca4 <ai_layers_forward_all+0xc>
 8004cba:	b001      	add	sp, #4
 8004cbc:	bd30      	pop	{r4, r5, pc}
	...

08004cc0 <.text_15>:
 8004cc0:	564e4f43 	.word	0x564e4f43
 8004cc4:	00004432 	.word	0x00004432

08004cc8 <.text_16>:
 8004cc8:	534e4544 	.word	0x534e4544
 8004ccc:	0045      	.short	0x0045
	...

08004cd0 <.text_17>:
 8004cd0:	4d54534c 	.word	0x4d54534c
 8004cd4:	00          	.byte	0x00
 8004cd5:	00          	.byte	0x00
	...

08004cd8 <.text_18>:
 8004cd8:	4d524f4e 	.word	0x4d524f4e
 8004cdc:	00          	.byte	0x00
 8004cdd:	00          	.byte	0x00
	...

08004ce0 <.text_19>:
 8004ce0:	4954504f 	.word	0x4954504f
 8004ce4:	455a494d 	.word	0x455a494d
 8004ce8:	4f435f44 	.word	0x4f435f44
 8004cec:	4432564e 	.word	0x4432564e
 8004cf0:	00          	.byte	0x00
 8004cf1:	00          	.byte	0x00
	...

08004cf4 <.text_20>:
 8004cf4:	4e415254 	.word	0x4e415254
 8004cf8:	534f5053 	.word	0x534f5053
 8004cfc:	0045      	.short	0x0045
	...

08004d00 <.text_21>:
 8004d00:	4c4f4f50 	.word	0x4c4f4f50
 8004d04:	00          	.byte	0x00
 8004d05:	00          	.byte	0x00
	...

08004d08 <.text_22>:
 8004d08:	494c5053 	.word	0x494c5053
 8004d0c:	0054      	.short	0x0054
	...

08004d10 <.text_23>:
 8004d10:	454d4954 	.word	0x454d4954
 8004d14:	4c45445f 	.word	0x4c45445f
 8004d18:	00005941 	.word	0x00005941

08004d1c <.text_24>:
 8004d1c:	454d4954 	.word	0x454d4954
 8004d20:	5349445f 	.word	0x5349445f
 8004d24:	42495254 	.word	0x42495254
 8004d28:	44455455 	.word	0x44455455
 8004d2c:	00          	.byte	0x00
 8004d2d:	00          	.byte	0x00
	...

08004d30 <.text_25>:
 8004d30:	434e4f43 	.word	0x434e4f43
 8004d34:	00005441 	.word	0x00005441

08004d38 <.text_26>:
 8004d38:	4d4d4547 	.word	0x4d4d4547
 8004d3c:	00          	.byte	0x00
 8004d3d:	00          	.byte	0x00
	...

08004d40 <.text_27>:
 8004d40:	41535055 	.word	0x41535055
 8004d44:	454c504d 	.word	0x454c504d
 8004d48:	00          	.byte	0x00
 8004d49:	00          	.byte	0x00
	...

08004d4c <.text_28>:
 8004d4c:	57544c45 	.word	0x57544c45
 8004d50:	00455349 	.word	0x00455349

08004d54 <.text_29>:
 8004d54:	454e4547 	.word	0x454e4547
 8004d58:	00434952 	.word	0x00434952

08004d5c <.text_30>:
 8004d5c:	54534e49 	.word	0x54534e49
 8004d60:	45434e41 	.word	0x45434e41
 8004d64:	4d524f4e 	.word	0x4d524f4e
 8004d68:	5a494c41 	.word	0x5a494c41
 8004d6c:	4f495441 	.word	0x4f495441
 8004d70:	004e      	.short	0x004e
	...

08004d74 <.text_31>:
 8004d74:	43494c53 	.word	0x43494c53
 8004d78:	0045      	.short	0x0045
	...

08004d7c <.text_32>:
 8004d7c:	454c4954 	.word	0x454c4954
 8004d80:	00          	.byte	0x00
 8004d81:	00          	.byte	0x00
	...

08004d84 <.text_33>:
 8004d84:	55444552 	.word	0x55444552
 8004d88:	00004543 	.word	0x00004543

08004d8c <ai_check_custom_types::ref_signatures>:
 8004d8c:	84048403                                ....

08004d90 <ai_conv2d_stripe_f32>:
 8004d90:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8004d94:	b098      	sub	sp, #96	; 0x60
 8004d96:	9825      	ldr	r0, [sp, #148]	; 0x94
 8004d98:	2800      	cmp	r0, #0
 8004d9a:	f000 82cb 	beq.w	8005334 <ai_conv2d_stripe_f32+0x5a4>
 8004d9e:	f9bd 40c0 	ldrsh.w	r4, [sp, #192]	; 0xc0
 8004da2:	f8dd a0b4 	ldr.w	sl, [sp, #180]	; 0xb4
 8004da6:	9d2b      	ldr	r5, [sp, #172]	; 0xac
 8004da8:	9f24      	ldr	r7, [sp, #144]	; 0x90
 8004daa:	9e2c      	ldr	r6, [sp, #176]	; 0xb0
 8004dac:	9004      	str	r0, [sp, #16]
 8004dae:	fb07 6a0a 	mla	sl, r7, sl, r6
 8004db2:	982a      	ldr	r0, [sp, #168]	; 0xa8
 8004db4:	f9bd 60c0 	ldrsh.w	r6, [sp, #192]	; 0xc0
 8004db8:	f8cd a014 	str.w	sl, [sp, #20]
 8004dbc:	1904      	adds	r4, r0, r4
 8004dbe:	1e64      	subs	r4, r4, #1
 8004dc0:	9826      	ldr	r0, [sp, #152]	; 0x98
 8004dc2:	9100      	str	r1, [sp, #0]
 8004dc4:	fb94 f6f6 	sdiv	r6, r4, r6
 8004dc8:	f9bd 40bc 	ldrsh.w	r4, [sp, #188]	; 0xbc
 8004dcc:	9217      	str	r2, [sp, #92]	; 0x5c
 8004dce:	4346      	muls	r6, r0
 8004dd0:	9616      	str	r6, [sp, #88]	; 0x58
 8004dd2:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
 8004dd6:	9e2a      	ldr	r6, [sp, #168]	; 0xa8
 8004dd8:	9822      	ldr	r0, [sp, #136]	; 0x88
 8004dda:	9306      	str	r3, [sp, #24]
 8004ddc:	4344      	muls	r4, r0
 8004dde:	9415      	str	r4, [sp, #84]	; 0x54
 8004de0:	437e      	muls	r6, r7
 8004de2:	f9bd 40c0 	ldrsh.w	r4, [sp, #192]	; 0xc0
 8004de6:	437c      	muls	r4, r7
 8004de8:	9414      	str	r4, [sp, #80]	; 0x50
 8004dea:	4346      	muls	r6, r0
 8004dec:	f9bd 40c0 	ldrsh.w	r4, [sp, #192]	; 0xc0
 8004df0:	982a      	ldr	r0, [sp, #168]	; 0xa8
 8004df2:	960b      	str	r6, [sp, #44]	; 0x2c
 8004df4:	1a24      	subs	r4, r4, r0
 8004df6:	9413      	str	r4, [sp, #76]	; 0x4c
 8004df8:	4604      	mov	r4, r0
 8004dfa:	9826      	ldr	r0, [sp, #152]	; 0x98
 8004dfc:	9e26      	ldr	r6, [sp, #152]	; 0x98
 8004dfe:	4344      	muls	r4, r0
 8004e00:	9412      	str	r4, [sp, #72]	; 0x48
 8004e02:	9c2a      	ldr	r4, [sp, #168]	; 0xa8
 8004e04:	4344      	muls	r4, r0
 8004e06:	9411      	str	r4, [sp, #68]	; 0x44
 8004e08:	f9bd 00c0 	ldrsh.w	r0, [sp, #192]	; 0xc0
 8004e0c:	f9bd 40bc 	ldrsh.w	r4, [sp, #188]	; 0xbc
 8004e10:	fb14 f000 	smulbb	r0, r4, r0
 8004e14:	900a      	str	r0, [sp, #40]	; 0x28
 8004e16:	9c23      	ldr	r4, [sp, #140]	; 0x8c
 8004e18:	9829      	ldr	r0, [sp, #164]	; 0xa4
 8004e1a:	fbb4 f0f0 	udiv	r0, r4, r0
 8004e1e:	9010      	str	r0, [sp, #64]	; 0x40
 8004e20:	9c22      	ldr	r4, [sp, #136]	; 0x88
 8004e22:	9829      	ldr	r0, [sp, #164]	; 0xa4
 8004e24:	fbb4 f0f0 	udiv	r0, r4, r0
 8004e28:	900f      	str	r0, [sp, #60]	; 0x3c
 8004e2a:	9c23      	ldr	r4, [sp, #140]	; 0x8c
 8004e2c:	9822      	ldr	r0, [sp, #136]	; 0x88
 8004e2e:	fbb4 f0f0 	udiv	r0, r4, r0
 8004e32:	9c22      	ldr	r4, [sp, #136]	; 0x88
 8004e34:	900e      	str	r0, [sp, #56]	; 0x38
 8004e36:	4374      	muls	r4, r6
 8004e38:	940d      	str	r4, [sp, #52]	; 0x34
 8004e3a:	9c2a      	ldr	r4, [sp, #168]	; 0xa8
 8004e3c:	1b2d      	subs	r5, r5, r4
 8004e3e:	950c      	str	r5, [sp, #48]	; 0x30
 8004e40:	9f2c      	ldr	r7, [sp, #176]	; 0xb0
 8004e42:	9924      	ldr	r1, [sp, #144]	; 0x90
 8004e44:	982c      	ldr	r0, [sp, #176]	; 0xb0
 8004e46:	9a2e      	ldr	r2, [sp, #184]	; 0xb8
 8004e48:	427f      	negs	r7, r7
 8004e4a:	bfd8      	it	le
 8004e4c:	2700      	movle	r7, #0
 8004e4e:	1a09      	subs	r1, r1, r0
 8004e50:	4291      	cmp	r1, r2
 8004e52:	bf3d      	ittte	cc
 8004e54:	9824      	ldrcc	r0, [sp, #144]	; 0x90
 8004e56:	9e2c      	ldrcc	r6, [sp, #176]	; 0xb0
 8004e58:	1b86      	subcc	r6, r0, r6
 8004e5a:	4616      	movcs	r6, r2
 8004e5c:	9a05      	ldr	r2, [sp, #20]
 8004e5e:	9922      	ldr	r1, [sp, #136]	; 0x88
 8004e60:	9817      	ldr	r0, [sp, #92]	; 0x5c
 8004e62:	18ba      	adds	r2, r7, r2
 8004e64:	434a      	muls	r2, r1
 8004e66:	eb00 0282 	add.w	r2, r0, r2, lsl #2
 8004e6a:	9821      	ldr	r0, [sp, #132]	; 0x84
 8004e6c:	b900      	cbnz	r0, 8004e70 <ai_conv2d_stripe_f32+0xe0>
 8004e6e:	9800      	ldr	r0, [sp, #0]
 8004e70:	9001      	str	r0, [sp, #4]
 8004e72:	1bf6      	subs	r6, r6, r7
 8004e74:	9829      	ldr	r0, [sp, #164]	; 0xa4
 8004e76:	9d0c      	ldr	r5, [sp, #48]	; 0x30
 8004e78:	2801      	cmp	r0, #1
 8004e7a:	bf04      	itt	eq
 8004e7c:	980a      	ldreq	r0, [sp, #40]	; 0x28
 8004e7e:	2801      	cmpeq	r0, #1
 8004e80:	f040 80a9 	bne.w	8004fd6 <ai_conv2d_stripe_f32+0x246>
 8004e84:	9c24      	ldr	r4, [sp, #144]	; 0x90
 8004e86:	9826      	ldr	r0, [sp, #152]	; 0x98
 8004e88:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8004e8a:	1ba4      	subs	r4, r4, r6
 8004e8c:	434c      	muls	r4, r1
 8004e8e:	1b80      	subs	r0, r0, r6
 8004e90:	4341      	muls	r1, r0
 8004e92:	9827      	ldr	r0, [sp, #156]	; 0x9c
 8004e94:	1b40      	subs	r0, r0, r5
 8004e96:	fb00 fc03 	mul.w	ip, r0, r3
 8004e9a:	9811      	ldr	r0, [sp, #68]	; 0x44
 8004e9c:	9b06      	ldr	r3, [sp, #24]
 8004e9e:	4407      	add	r7, r0
 8004ea0:	9822      	ldr	r0, [sp, #136]	; 0x88
 8004ea2:	4347      	muls	r7, r0
 8004ea4:	eb03 0787 	add.w	r7, r3, r7, lsl #2
 8004ea8:	4370      	muls	r0, r6
 8004eaa:	9e01      	ldr	r6, [sp, #4]
 8004eac:	9b00      	ldr	r3, [sp, #0]
 8004eae:	429e      	cmp	r6, r3
 8004eb0:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8004eb2:	eb02 0983 	add.w	r9, r2, r3, lsl #2
 8004eb6:	9a23      	ldr	r2, [sp, #140]	; 0x8c
 8004eb8:	bf0c      	ite	eq
 8004eba:	eddf 0aaf 	vldreq	s1, [pc, #700]	; 8005178 <ai_conv2d_stripe_f32+0x3e8>
 8004ebe:	eef0 0a40 	vmovne.f32	s1, s0
 8004ec2:	2a00      	cmp	r2, #0
 8004ec4:	f000 8222 	beq.w	800530c <ai_conv2d_stripe_f32+0x57c>
 8004ec8:	46b0      	mov	r8, r6
 8004eca:	462e      	mov	r6, r5
 8004ecc:	4613      	mov	r3, r2
 8004ece:	f8cd c008 	str.w	ip, [sp, #8]
 8004ed2:	461d      	mov	r5, r3
 8004ed4:	f8dd e000 	ldr.w	lr, [sp]
 8004ed8:	9b00      	ldr	r3, [sp, #0]
 8004eda:	463a      	mov	r2, r7
 8004edc:	4682      	mov	sl, r0
 8004ede:	f8cd 9004 	str.w	r9, [sp, #4]
 8004ee2:	46c4      	mov	ip, r8
 8004ee4:	f02a 0703 	bic.w	r7, sl, #3
 8004ee8:	ed9c 1a00 	vldr	s2, [ip]
 8004eec:	f8dd 8004 	ldr.w	r8, [sp, #4]
 8004ef0:	2e00      	cmp	r6, #0
 8004ef2:	ee21 1a20 	vmul.f32	s2, s2, s1
 8004ef6:	dd61      	ble.n	8004fbc <ai_conv2d_stripe_f32+0x22c>
 8004ef8:	4630      	mov	r0, r6
 8004efa:	2f00      	cmp	r7, #0
 8004efc:	f04f 0900 	mov.w	r9, #0
 8004f00:	f340 801f 	ble.w	8004f42 <ai_conv2d_stripe_f32+0x1b2>
 8004f04:	edd2 4a00 	vldr	s9, [r2]
 8004f08:	ed98 5a00 	vldr	s10, [r8]
 8004f0c:	edd2 3a01 	vldr	s7, [r2, #4]
 8004f10:	ed98 4a01 	vldr	s8, [r8, #4]
 8004f14:	edd2 2a02 	vldr	s5, [r2, #8]
 8004f18:	ed98 3a02 	vldr	s6, [r8, #8]
 8004f1c:	edd2 1a03 	vldr	s3, [r2, #12]
 8004f20:	ed98 2a03 	vldr	s4, [r8, #12]
 8004f24:	ee04 1a85 	vmla.f32	s2, s9, s10
 8004f28:	ee03 1a84 	vmla.f32	s2, s7, s8
 8004f2c:	3210      	adds	r2, #16
 8004f2e:	f109 0904 	add.w	r9, r9, #4
 8004f32:	ee02 1a83 	vmla.f32	s2, s5, s6
 8004f36:	45b9      	cmp	r9, r7
 8004f38:	ee01 1a82 	vmla.f32	s2, s3, s4
 8004f3c:	f108 0810 	add.w	r8, r8, #16
 8004f40:	dbe0      	blt.n	8004f04 <ai_conv2d_stripe_f32+0x174>
 8004f42:	45d1      	cmp	r9, sl
 8004f44:	f280 8034 	bge.w	8004fb0 <ai_conv2d_stripe_f32+0x220>
 8004f48:	f109 0901 	add.w	r9, r9, #1
 8004f4c:	edd2 2a00 	vldr	s5, [r2]
 8004f50:	edd8 1a00 	vldr	s3, [r8]
 8004f54:	1d12      	adds	r2, r2, #4
 8004f56:	45d1      	cmp	r9, sl
 8004f58:	ee02 1aa1 	vmla.f32	s2, s5, s3
 8004f5c:	f108 0804 	add.w	r8, r8, #4
 8004f60:	da26      	bge.n	8004fb0 <ai_conv2d_stripe_f32+0x220>
 8004f62:	f109 0901 	add.w	r9, r9, #1
 8004f66:	ed92 3a00 	vldr	s6, [r2]
 8004f6a:	ed98 2a00 	vldr	s4, [r8]
 8004f6e:	1d12      	adds	r2, r2, #4
 8004f70:	45d1      	cmp	r9, sl
 8004f72:	ee03 1a02 	vmla.f32	s2, s6, s4
 8004f76:	f108 0804 	add.w	r8, r8, #4
 8004f7a:	da19      	bge.n	8004fb0 <ai_conv2d_stripe_f32+0x220>
 8004f7c:	f109 0901 	add.w	r9, r9, #1
 8004f80:	edd2 2a00 	vldr	s5, [r2]
 8004f84:	edd8 1a00 	vldr	s3, [r8]
 8004f88:	1d12      	adds	r2, r2, #4
 8004f8a:	45d1      	cmp	r9, sl
 8004f8c:	ee02 1aa1 	vmla.f32	s2, s5, s3
 8004f90:	f108 0804 	add.w	r8, r8, #4
 8004f94:	da0c      	bge.n	8004fb0 <ai_conv2d_stripe_f32+0x220>
 8004f96:	f109 0901 	add.w	r9, r9, #1
 8004f9a:	ed92 2a00 	vldr	s4, [r2]
 8004f9e:	ed98 3a00 	vldr	s6, [r8]
 8004fa2:	1d12      	adds	r2, r2, #4
 8004fa4:	45d1      	cmp	r9, sl
 8004fa6:	ee02 1a03 	vmla.f32	s2, s4, s6
 8004faa:	f108 0804 	add.w	r8, r8, #4
 8004fae:	dbcb      	blt.n	8004f48 <ai_conv2d_stripe_f32+0x1b8>
 8004fb0:	1e40      	subs	r0, r0, #1
 8004fb2:	eb08 0884 	add.w	r8, r8, r4, lsl #2
 8004fb6:	eb02 0281 	add.w	r2, r2, r1, lsl #2
 8004fba:	d19e      	bne.n	8004efa <ai_conv2d_stripe_f32+0x16a>
 8004fbc:	9802      	ldr	r0, [sp, #8]
 8004fbe:	ed8e 1a00 	vstr	s2, [lr]
 8004fc2:	1e6d      	subs	r5, r5, #1
 8004fc4:	eb02 0280 	add.w	r2, r2, r0, lsl #2
 8004fc8:	f10e 0e04 	add.w	lr, lr, #4
 8004fcc:	f10c 0c04 	add.w	ip, ip, #4
 8004fd0:	d18a      	bne.n	8004ee8 <ai_conv2d_stripe_f32+0x158>
 8004fd2:	9300      	str	r3, [sp, #0]
 8004fd4:	e19a      	b.n	800530c <ai_conv2d_stripe_f32+0x57c>
 8004fd6:	9829      	ldr	r0, [sp, #164]	; 0xa4
 8004fd8:	4288      	cmp	r0, r1
 8004fda:	bf04      	itt	eq
 8004fdc:	980a      	ldreq	r0, [sp, #40]	; 0x28
 8004fde:	2801      	cmpeq	r0, #1
 8004fe0:	f040 80cc 	bne.w	800517c <ai_conv2d_stripe_f32+0x3ec>
 8004fe4:	980e      	ldr	r0, [sp, #56]	; 0x38
 8004fe6:	9b06      	ldr	r3, [sp, #24]
 8004fe8:	9c00      	ldr	r4, [sp, #0]
 8004fea:	9002      	str	r0, [sp, #8]
 8004fec:	9824      	ldr	r0, [sp, #144]	; 0x90
 8004fee:	1b81      	subs	r1, r0, r6
 8004ff0:	9822      	ldr	r0, [sp, #136]	; 0x88
 8004ff2:	fb01 fa00 	mul.w	sl, r1, r0
 8004ff6:	9826      	ldr	r0, [sp, #152]	; 0x98
 8004ff8:	9926      	ldr	r1, [sp, #152]	; 0x98
 8004ffa:	eba0 0c06 	sub.w	ip, r0, r6
 8004ffe:	9827      	ldr	r0, [sp, #156]	; 0x9c
 8005000:	1b40      	subs	r0, r0, r5
 8005002:	4341      	muls	r1, r0
 8005004:	9812      	ldr	r0, [sp, #72]	; 0x48
 8005006:	183f      	adds	r7, r7, r0
 8005008:	eb03 0087 	add.w	r0, r3, r7, lsl #2
 800500c:	9b01      	ldr	r3, [sp, #4]
 800500e:	42a3      	cmp	r3, r4
 8005010:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8005012:	eb02 0e83 	add.w	lr, r2, r3, lsl #2
 8005016:	bf0c      	ite	eq
 8005018:	eddf 0a57 	vldreq	s1, [pc, #348]	; 8005178 <ai_conv2d_stripe_f32+0x3e8>
 800501c:	eef0 0a40 	vmovne.f32	s1, s0
 8005020:	9b22      	ldr	r3, [sp, #136]	; 0x88
 8005022:	2400      	movs	r4, #0
 8005024:	eb0e 0283 	add.w	r2, lr, r3, lsl #2
 8005028:	4596      	cmp	lr, r2
 800502a:	9203      	str	r2, [sp, #12]
 800502c:	f080 816e 	bcs.w	800530c <ai_conv2d_stripe_f32+0x57c>
 8005030:	9b00      	ldr	r3, [sp, #0]
 8005032:	9a02      	ldr	r2, [sp, #8]
 8005034:	2a00      	cmp	r2, #0
 8005036:	f000 8097 	beq.w	8005168 <ai_conv2d_stripe_f32+0x3d8>
 800503a:	9a01      	ldr	r2, [sp, #4]
 800503c:	9500      	str	r5, [sp, #0]
 800503e:	eb02 0784 	add.w	r7, r2, r4, lsl #2
 8005042:	eb03 0284 	add.w	r2, r3, r4, lsl #2
 8005046:	f8dd b008 	ldr.w	fp, [sp, #8]
 800504a:	9108      	str	r1, [sp, #32]
 800504c:	f8cd e01c 	str.w	lr, [sp, #28]
 8005050:	4615      	mov	r5, r2
 8005052:	9a00      	ldr	r2, [sp, #0]
 8005054:	ed97 1a00 	vldr	s2, [r7]
 8005058:	9907      	ldr	r1, [sp, #28]
 800505a:	2a00      	cmp	r2, #0
 800505c:	ee21 1a20 	vmul.f32	s2, s2, s1
 8005060:	f340 8072 	ble.w	8005148 <ai_conv2d_stripe_f32+0x3b8>
 8005064:	f026 0e03 	bic.w	lr, r6, #3
 8005068:	f1be 0f00 	cmp.w	lr, #0
 800506c:	f04f 0900 	mov.w	r9, #0
 8005070:	f340 8029 	ble.w	80050c6 <ai_conv2d_stripe_f32+0x336>
 8005074:	f8dd 8088 	ldr.w	r8, [sp, #136]	; 0x88
 8005078:	edd0 1a00 	vldr	s3, [r0]
 800507c:	ed91 2a00 	vldr	s4, [r1]
 8005080:	eb01 0188 	add.w	r1, r1, r8, lsl #2
 8005084:	ee01 1a82 	vmla.f32	s2, s3, s4
 8005088:	edd0 1a01 	vldr	s3, [r0, #4]
 800508c:	ed91 2a00 	vldr	s4, [r1]
 8005090:	eb01 0188 	add.w	r1, r1, r8, lsl #2
 8005094:	ee01 1a82 	vmla.f32	s2, s3, s4
 8005098:	edd0 1a02 	vldr	s3, [r0, #8]
 800509c:	ed91 2a00 	vldr	s4, [r1]
 80050a0:	eb01 0188 	add.w	r1, r1, r8, lsl #2
 80050a4:	ee01 1a82 	vmla.f32	s2, s3, s4
 80050a8:	f109 0904 	add.w	r9, r9, #4
 80050ac:	edd0 1a03 	vldr	s3, [r0, #12]
 80050b0:	ed91 2a00 	vldr	s4, [r1]
 80050b4:	3010      	adds	r0, #16
 80050b6:	45f1      	cmp	r9, lr
 80050b8:	ee01 1a82 	vmla.f32	s2, s3, s4
 80050bc:	eb01 0188 	add.w	r1, r1, r8, lsl #2
 80050c0:	dbda      	blt.n	8005078 <ai_conv2d_stripe_f32+0x2e8>
 80050c2:	f8cd 8088 	str.w	r8, [sp, #136]	; 0x88
 80050c6:	45b1      	cmp	r9, r6
 80050c8:	f280 8038 	bge.w	800513c <ai_conv2d_stripe_f32+0x3ac>
 80050cc:	f8dd e088 	ldr.w	lr, [sp, #136]	; 0x88
 80050d0:	f109 0901 	add.w	r9, r9, #1
 80050d4:	edd0 1a00 	vldr	s3, [r0]
 80050d8:	ed91 2a00 	vldr	s4, [r1]
 80050dc:	1d00      	adds	r0, r0, #4
 80050de:	45b1      	cmp	r9, r6
 80050e0:	ee01 1a82 	vmla.f32	s2, s3, s4
 80050e4:	eb01 018e 	add.w	r1, r1, lr, lsl #2
 80050e8:	da26      	bge.n	8005138 <ai_conv2d_stripe_f32+0x3a8>
 80050ea:	f109 0901 	add.w	r9, r9, #1
 80050ee:	ed90 2a00 	vldr	s4, [r0]
 80050f2:	edd1 1a00 	vldr	s3, [r1]
 80050f6:	1d00      	adds	r0, r0, #4
 80050f8:	45b1      	cmp	r9, r6
 80050fa:	ee02 1a21 	vmla.f32	s2, s4, s3
 80050fe:	eb01 018e 	add.w	r1, r1, lr, lsl #2
 8005102:	da19      	bge.n	8005138 <ai_conv2d_stripe_f32+0x3a8>
 8005104:	f109 0901 	add.w	r9, r9, #1
 8005108:	edd0 1a00 	vldr	s3, [r0]
 800510c:	ed91 2a00 	vldr	s4, [r1]
 8005110:	1d00      	adds	r0, r0, #4
 8005112:	45b1      	cmp	r9, r6
 8005114:	ee01 1a82 	vmla.f32	s2, s3, s4
 8005118:	eb01 018e 	add.w	r1, r1, lr, lsl #2
 800511c:	da0c      	bge.n	8005138 <ai_conv2d_stripe_f32+0x3a8>
 800511e:	f109 0901 	add.w	r9, r9, #1
 8005122:	ed90 2a00 	vldr	s4, [r0]
 8005126:	edd1 1a00 	vldr	s3, [r1]
 800512a:	1d00      	adds	r0, r0, #4
 800512c:	45b1      	cmp	r9, r6
 800512e:	ee02 1a21 	vmla.f32	s2, s4, s3
 8005132:	eb01 018e 	add.w	r1, r1, lr, lsl #2
 8005136:	dbcb      	blt.n	80050d0 <ai_conv2d_stripe_f32+0x340>
 8005138:	f8cd e088 	str.w	lr, [sp, #136]	; 0x88
 800513c:	1e52      	subs	r2, r2, #1
 800513e:	eb01 018a 	add.w	r1, r1, sl, lsl #2
 8005142:	eb00 008c 	add.w	r0, r0, ip, lsl #2
 8005146:	d18d      	bne.n	8005064 <ai_conv2d_stripe_f32+0x2d4>
 8005148:	9908      	ldr	r1, [sp, #32]
 800514a:	ed85 1a00 	vstr	s2, [r5]
 800514e:	1c64      	adds	r4, r4, #1
 8005150:	1d2d      	adds	r5, r5, #4
 8005152:	1d3f      	adds	r7, r7, #4
 8005154:	f1bb 0b01 	subs.w	fp, fp, #1
 8005158:	eb00 0081 	add.w	r0, r0, r1, lsl #2
 800515c:	f47f af79 	bne.w	8005052 <ai_conv2d_stripe_f32+0x2c2>
 8005160:	9d00      	ldr	r5, [sp, #0]
 8005162:	9908      	ldr	r1, [sp, #32]
 8005164:	f8dd e01c 	ldr.w	lr, [sp, #28]
 8005168:	9a03      	ldr	r2, [sp, #12]
 800516a:	f10e 0e04 	add.w	lr, lr, #4
 800516e:	4596      	cmp	lr, r2
 8005170:	f4bf af2f 	bcs.w	8004fd2 <ai_conv2d_stripe_f32+0x242>
 8005174:	e75d      	b.n	8005032 <ai_conv2d_stripe_f32+0x2a2>
 8005176:	bf00      	nop
 8005178:	00000000 	.word	0x00000000
 800517c:	f9bd 10bc 	ldrsh.w	r1, [sp, #188]	; 0xbc
 8005180:	f8dd 9050 	ldr.w	r9, [sp, #80]	; 0x50
 8005184:	4608      	mov	r0, r1
 8005186:	1bcb      	subs	r3, r1, r7
 8005188:	fb97 f4f0 	sdiv	r4, r7, r0
 800518c:	fb00 3004 	mla	r0, r0, r4, r3
 8005190:	fb90 faf1 	sdiv	sl, r0, r1
 8005194:	fb01 0a1a 	mls	sl, r1, sl, r0
 8005198:	f9bd 30c0 	ldrsh.w	r3, [sp, #192]	; 0xc0
 800519c:	982a      	ldr	r0, [sp, #168]	; 0xa8
 800519e:	9c13      	ldr	r4, [sp, #76]	; 0x4c
 80051a0:	fb90 f0f3 	sdiv	r0, r0, r3
 80051a4:	fb03 4000 	mla	r0, r3, r0, r4
 80051a8:	1876      	adds	r6, r6, r1
 80051aa:	fb90 fbf3 	sdiv	fp, r0, r3
 80051ae:	1e76      	subs	r6, r6, #1
 80051b0:	187f      	adds	r7, r7, r1
 80051b2:	fb03 0b1b 	mls	fp, r3, fp, r0
 80051b6:	eba6 060a 	sub.w	r6, r6, sl
 80051ba:	eba5 050b 	sub.w	r5, r5, fp
 80051be:	1e7f      	subs	r7, r7, #1
 80051c0:	fb96 f0f1 	sdiv	r0, r6, r1
 80051c4:	9e27      	ldr	r6, [sp, #156]	; 0x9c
 80051c6:	9c22      	ldr	r4, [sp, #136]	; 0x88
 80051c8:	195d      	adds	r5, r3, r5
 80051ca:	1e6d      	subs	r5, r5, #1
 80051cc:	fb00 9911 	mls	r9, r0, r1, r9
 80051d0:	fb97 f1f1 	sdiv	r1, r7, r1
 80051d4:	fb95 fcf3 	sdiv	ip, r5, r3
 80051d8:	9d10      	ldr	r5, [sp, #64]	; 0x40
 80051da:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 80051dc:	9509      	str	r5, [sp, #36]	; 0x24
 80051de:	eba6 060c 	sub.w	r6, r6, ip
 80051e2:	9d26      	ldr	r5, [sp, #152]	; 0x98
 80051e4:	1a2d      	subs	r5, r5, r0
 80051e6:	fb05 f803 	mul.w	r8, r5, r3
 80051ea:	9d26      	ldr	r5, [sp, #152]	; 0x98
 80051ec:	435d      	muls	r5, r3
 80051ee:	fb06 fe05 	mul.w	lr, r6, r5
 80051f2:	9d16      	ldr	r5, [sp, #88]	; 0x58
 80051f4:	9e06      	ldr	r6, [sp, #24]
 80051f6:	194d      	adds	r5, r1, r5
 80051f8:	fb04 f909 	mul.w	r9, r4, r9
 80051fc:	435d      	muls	r5, r3
 80051fe:	9c15      	ldr	r4, [sp, #84]	; 0x54
 8005200:	eb06 0185 	add.w	r1, r6, r5, lsl #2
 8005204:	9d01      	ldr	r5, [sp, #4]
 8005206:	9e00      	ldr	r6, [sp, #0]
 8005208:	1ae4      	subs	r4, r4, r3
 800520a:	42b5      	cmp	r5, r6
 800520c:	9d2a      	ldr	r5, [sp, #168]	; 0xa8
 800520e:	9e24      	ldr	r6, [sp, #144]	; 0x90
 8005210:	445d      	add	r5, fp
 8005212:	fb06 aa05 	mla	sl, r6, r5, sl
 8005216:	9d22      	ldr	r5, [sp, #136]	; 0x88
 8005218:	fb0a f505 	mul.w	r5, sl, r5
 800521c:	bf0c      	ite	eq
 800521e:	eddf 0a47 	vldreq	s1, [pc, #284]	; 800533c <.text_3>
 8005222:	eef0 0a40 	vmovne.f32	s1, s0
 8005226:	eb02 0785 	add.w	r7, r2, r5, lsl #2
 800522a:	9a29      	ldr	r2, [sp, #164]	; 0xa4
 800522c:	2500      	movs	r5, #0
 800522e:	2a00      	cmp	r2, #0
 8005230:	d06c      	beq.n	800530c <ai_conv2d_stripe_f32+0x57c>
 8005232:	9202      	str	r2, [sp, #8]
 8005234:	9a09      	ldr	r2, [sp, #36]	; 0x24
 8005236:	2a00      	cmp	r2, #0
 8005238:	d062      	beq.n	8005300 <ai_conv2d_stripe_f32+0x570>
 800523a:	9a01      	ldr	r2, [sp, #4]
 800523c:	eb02 0685 	add.w	r6, r2, r5, lsl #2
 8005240:	9a00      	ldr	r2, [sp, #0]
 8005242:	f8cd c00c 	str.w	ip, [sp, #12]
 8005246:	eb02 0a85 	add.w	sl, r2, r5, lsl #2
 800524a:	9a09      	ldr	r2, [sp, #36]	; 0x24
 800524c:	f8cd e020 	str.w	lr, [sp, #32]
 8005250:	f8cd 701c 	str.w	r7, [sp, #28]
 8005254:	f8dd e00c 	ldr.w	lr, [sp, #12]
 8005258:	ed96 1a00 	vldr	s2, [r6]
 800525c:	9f07      	ldr	r7, [sp, #28]
 800525e:	f1be 0f00 	cmp.w	lr, #0
 8005262:	ee21 1a20 	vmul.f32	s2, s2, s1
 8005266:	dd3b      	ble.n	80052e0 <ai_conv2d_stripe_f32+0x550>
 8005268:	2800      	cmp	r0, #0
 800526a:	dd32      	ble.n	80052d2 <ai_conv2d_stripe_f32+0x542>
 800526c:	ea4f 0c00 	mov.w	ip, r0
 8005270:	eb07 0b83 	add.w	fp, r7, r3, lsl #2
 8005274:	455f      	cmp	r7, fp
 8005276:	d227      	bcs.n	80052c8 <ai_conv2d_stripe_f32+0x538>
 8005278:	edd1 2a00 	vldr	s5, [r1]
 800527c:	edd7 1a00 	vldr	s3, [r7]
 8005280:	1d09      	adds	r1, r1, #4
 8005282:	1d3f      	adds	r7, r7, #4
 8005284:	455f      	cmp	r7, fp
 8005286:	ee02 1aa1 	vmla.f32	s2, s5, s3
 800528a:	d21d      	bcs.n	80052c8 <ai_conv2d_stripe_f32+0x538>
 800528c:	ed91 3a00 	vldr	s6, [r1]
 8005290:	ed97 2a00 	vldr	s4, [r7]
 8005294:	1d09      	adds	r1, r1, #4
 8005296:	1d3f      	adds	r7, r7, #4
 8005298:	455f      	cmp	r7, fp
 800529a:	ee03 1a02 	vmla.f32	s2, s6, s4
 800529e:	d213      	bcs.n	80052c8 <ai_conv2d_stripe_f32+0x538>
 80052a0:	edd1 2a00 	vldr	s5, [r1]
 80052a4:	edd7 1a00 	vldr	s3, [r7]
 80052a8:	1d09      	adds	r1, r1, #4
 80052aa:	1d3f      	adds	r7, r7, #4
 80052ac:	455f      	cmp	r7, fp
 80052ae:	ee02 1aa1 	vmla.f32	s2, s5, s3
 80052b2:	d209      	bcs.n	80052c8 <ai_conv2d_stripe_f32+0x538>
 80052b4:	ed91 2a00 	vldr	s4, [r1]
 80052b8:	ed97 3a00 	vldr	s6, [r7]
 80052bc:	1d09      	adds	r1, r1, #4
 80052be:	1d3f      	adds	r7, r7, #4
 80052c0:	455f      	cmp	r7, fp
 80052c2:	ee02 1a03 	vmla.f32	s2, s4, s6
 80052c6:	d3d7      	bcc.n	8005278 <ai_conv2d_stripe_f32+0x4e8>
 80052c8:	f1bc 0c01 	subs.w	ip, ip, #1
 80052cc:	eb07 0784 	add.w	r7, r7, r4, lsl #2
 80052d0:	d1ce      	bne.n	8005270 <ai_conv2d_stripe_f32+0x4e0>
 80052d2:	f1be 0e01 	subs.w	lr, lr, #1
 80052d6:	eb07 0789 	add.w	r7, r7, r9, lsl #2
 80052da:	eb01 0188 	add.w	r1, r1, r8, lsl #2
 80052de:	d1c3      	bne.n	8005268 <ai_conv2d_stripe_f32+0x4d8>
 80052e0:	9f08      	ldr	r7, [sp, #32]
 80052e2:	1c6d      	adds	r5, r5, #1
 80052e4:	1d36      	adds	r6, r6, #4
 80052e6:	ed8a 1a00 	vstr	s2, [sl]
 80052ea:	1e52      	subs	r2, r2, #1
 80052ec:	eb01 0187 	add.w	r1, r1, r7, lsl #2
 80052f0:	f10a 0a04 	add.w	sl, sl, #4
 80052f4:	d1ae      	bne.n	8005254 <ai_conv2d_stripe_f32+0x4c4>
 80052f6:	f8dd c00c 	ldr.w	ip, [sp, #12]
 80052fa:	f8dd e020 	ldr.w	lr, [sp, #32]
 80052fe:	9f07      	ldr	r7, [sp, #28]
 8005300:	9a02      	ldr	r2, [sp, #8]
 8005302:	1e52      	subs	r2, r2, #1
 8005304:	eb07 0783 	add.w	r7, r7, r3, lsl #2
 8005308:	9202      	str	r2, [sp, #8]
 800530a:	d193      	bne.n	8005234 <ai_conv2d_stripe_f32+0x4a4>
 800530c:	9800      	ldr	r0, [sp, #0]
 800530e:	9923      	ldr	r1, [sp, #140]	; 0x8c
 8005310:	eb00 0281 	add.w	r2, r0, r1, lsl #2
 8005314:	982c      	ldr	r0, [sp, #176]	; 0xb0
 8005316:	f8bd 10a0 	ldrh.w	r1, [sp, #160]	; 0xa0
 800531a:	9200      	str	r2, [sp, #0]
 800531c:	1841      	adds	r1, r0, r1
 800531e:	912c      	str	r1, [sp, #176]	; 0xb0
 8005320:	9805      	ldr	r0, [sp, #20]
 8005322:	f8bd 10a0 	ldrh.w	r1, [sp, #160]	; 0xa0
 8005326:	1841      	adds	r1, r0, r1
 8005328:	9804      	ldr	r0, [sp, #16]
 800532a:	9105      	str	r1, [sp, #20]
 800532c:	1e40      	subs	r0, r0, #1
 800532e:	9004      	str	r0, [sp, #16]
 8005330:	f47f ad86 	bne.w	8004e40 <ai_conv2d_stripe_f32+0xb0>
 8005334:	b018      	add	sp, #96	; 0x60
 8005336:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	...

0800533c <.text_3>:
 800533c:	00000000 	.word	0x00000000

08005340 <func_dummy>:
 8005340:	4770      	bx	lr
	...

08005344 <ai_dict8_dot_array_f32>:
 8005344:	b4f0      	push	{r4, r5, r6, r7}
 8005346:	4604      	mov	r4, r0
 8005348:	9804      	ldr	r0, [sp, #16]
 800534a:	eb03 0580 	add.w	r5, r3, r0, lsl #2
 800534e:	3d20      	subs	r5, #32
 8005350:	2808      	cmp	r0, #8
 8005352:	ed9f 0adb 	vldr	s0, [pc, #876]	; 80056c0 <.text_7>
 8005356:	d232      	bcs.n	80053be <ai_dict8_dot_array_f32+0x7a>
 8005358:	3520      	adds	r5, #32
 800535a:	42ab      	cmp	r3, r5
 800535c:	f080 8159 	bcs.w	8005612 <ai_dict8_dot_array_f32+0x2ce>
 8005360:	780e      	ldrb	r6, [r1, #0]
 8005362:	edd3 0a00 	vldr	s1, [r3]
 8005366:	eb02 0086 	add.w	r0, r2, r6, lsl #2
 800536a:	ed90 1a00 	vldr	s2, [r0]
 800536e:	1d18      	adds	r0, r3, #4
 8005370:	42a8      	cmp	r0, r5
 8005372:	ee01 0a20 	vmla.f32	s0, s2, s1
 8005376:	f080 814c 	bcs.w	8005612 <ai_dict8_dot_array_f32+0x2ce>
 800537a:	784e      	ldrb	r6, [r1, #1]
 800537c:	edd0 0a00 	vldr	s1, [r0]
 8005380:	eb02 0386 	add.w	r3, r2, r6, lsl #2
 8005384:	1d00      	adds	r0, r0, #4
 8005386:	ed93 1a00 	vldr	s2, [r3]
 800538a:	42a8      	cmp	r0, r5
 800538c:	ee01 0a20 	vmla.f32	s0, s2, s1
 8005390:	f080 813f 	bcs.w	8005612 <ai_dict8_dot_array_f32+0x2ce>
 8005394:	788e      	ldrb	r6, [r1, #2]
 8005396:	edd0 0a00 	vldr	s1, [r0]
 800539a:	eb02 0386 	add.w	r3, r2, r6, lsl #2
 800539e:	1cc9      	adds	r1, r1, #3
 80053a0:	ed93 1a00 	vldr	s2, [r3]
 80053a4:	1d03      	adds	r3, r0, #4
 80053a6:	42ab      	cmp	r3, r5
 80053a8:	ee01 0a20 	vmla.f32	s0, s2, s1
 80053ac:	d3d8      	bcc.n	8005360 <ai_dict8_dot_array_f32+0x1c>
 80053ae:	edd4 0a00 	vldr	s1, [r4]
 80053b2:	ee30 0a80 	vadd.f32	s0, s1, s0
 80053b6:	ed84 0a00 	vstr	s0, [r4]
 80053ba:	bcf0      	pop	{r4, r5, r6, r7}
 80053bc:	4770      	bx	lr
 80053be:	f001 0003 	and.w	r0, r1, #3
 80053c2:	2803      	cmp	r0, #3
 80053c4:	f200 8125 	bhi.w	8005612 <ai_dict8_dot_array_f32+0x2ce>
 80053c8:	e8df f010 	tbh	[pc, r0, lsl #1]
 80053cc:	00890004 	.word	0x00890004
 80053d0:	009f0094 	.word	0x009f0094
 80053d4:	429d      	cmp	r5, r3
 80053d6:	d232      	bcs.n	800543e <ai_dict8_dot_array_f32+0xfa>
 80053d8:	3520      	adds	r5, #32
 80053da:	42ab      	cmp	r3, r5
 80053dc:	f080 8119 	bcs.w	8005612 <ai_dict8_dot_array_f32+0x2ce>
 80053e0:	780e      	ldrb	r6, [r1, #0]
 80053e2:	edd3 0a00 	vldr	s1, [r3]
 80053e6:	eb02 0086 	add.w	r0, r2, r6, lsl #2
 80053ea:	ed90 1a00 	vldr	s2, [r0]
 80053ee:	1d18      	adds	r0, r3, #4
 80053f0:	42a8      	cmp	r0, r5
 80053f2:	ee01 0a20 	vmla.f32	s0, s2, s1
 80053f6:	f080 810c 	bcs.w	8005612 <ai_dict8_dot_array_f32+0x2ce>
 80053fa:	784e      	ldrb	r6, [r1, #1]
 80053fc:	edd0 0a00 	vldr	s1, [r0]
 8005400:	eb02 0386 	add.w	r3, r2, r6, lsl #2
 8005404:	1d00      	adds	r0, r0, #4
 8005406:	ed93 1a00 	vldr	s2, [r3]
 800540a:	42a8      	cmp	r0, r5
 800540c:	ee01 0a20 	vmla.f32	s0, s2, s1
 8005410:	f080 80ff 	bcs.w	8005612 <ai_dict8_dot_array_f32+0x2ce>
 8005414:	788e      	ldrb	r6, [r1, #2]
 8005416:	edd0 0a00 	vldr	s1, [r0]
 800541a:	eb02 0386 	add.w	r3, r2, r6, lsl #2
 800541e:	1cc9      	adds	r1, r1, #3
 8005420:	ed93 1a00 	vldr	s2, [r3]
 8005424:	1d03      	adds	r3, r0, #4
 8005426:	42ab      	cmp	r3, r5
 8005428:	ee01 0a20 	vmla.f32	s0, s2, s1
 800542c:	d3d8      	bcc.n	80053e0 <ai_dict8_dot_array_f32+0x9c>
 800542e:	edd4 0a00 	vldr	s1, [r4]
 8005432:	ee30 0a80 	vadd.f32	s0, s1, s0
 8005436:	ed84 0a00 	vstr	s0, [r4]
 800543a:	bcf0      	pop	{r4, r5, r6, r7}
 800543c:	4770      	bx	lr
 800543e:	78cf      	ldrb	r7, [r1, #3]
 8005440:	ed93 4a00 	vldr	s8, [r3]
 8005444:	ed93 3a01 	vldr	s6, [r3, #4]
 8005448:	ed93 2a02 	vldr	s4, [r3, #8]
 800544c:	ed93 1a03 	vldr	s2, [r3, #12]
 8005450:	eb02 0687 	add.w	r6, r2, r7, lsl #2
 8005454:	788f      	ldrb	r7, [r1, #2]
 8005456:	edd6 0a00 	vldr	s1, [r6]
 800545a:	eb02 0687 	add.w	r6, r2, r7, lsl #2
 800545e:	784f      	ldrb	r7, [r1, #1]
 8005460:	edd6 1a00 	vldr	s3, [r6]
 8005464:	eb02 0687 	add.w	r6, r2, r7, lsl #2
 8005468:	780f      	ldrb	r7, [r1, #0]
 800546a:	edd6 2a00 	vldr	s5, [r6]
 800546e:	eb02 0687 	add.w	r6, r2, r7, lsl #2
 8005472:	f103 0010 	add.w	r0, r3, #16
 8005476:	edd6 3a00 	vldr	s7, [r6]
 800547a:	790b      	ldrb	r3, [r1, #4]
 800547c:	ee03 0a84 	vmla.f32	s0, s7, s8
 8005480:	ee02 0a83 	vmla.f32	s0, s5, s6
 8005484:	ee01 0a82 	vmla.f32	s0, s3, s4
 8005488:	eb02 0783 	add.w	r7, r2, r3, lsl #2
 800548c:	ee00 0a81 	vmla.f32	s0, s1, s2
 8005490:	794b      	ldrb	r3, [r1, #5]
 8005492:	edd7 0a00 	vldr	s1, [r7]
 8005496:	ed90 4a00 	vldr	s8, [r0]
 800549a:	edd0 3a01 	vldr	s7, [r0, #4]
 800549e:	ed90 3a02 	vldr	s6, [r0, #8]
 80054a2:	edd0 2a03 	vldr	s5, [r0, #12]
 80054a6:	eb02 0783 	add.w	r7, r2, r3, lsl #2
 80054aa:	798b      	ldrb	r3, [r1, #6]
 80054ac:	ed97 1a00 	vldr	s2, [r7]
 80054b0:	eb02 0783 	add.w	r7, r2, r3, lsl #2
 80054b4:	79cb      	ldrb	r3, [r1, #7]
 80054b6:	edd7 1a00 	vldr	s3, [r7]
 80054ba:	eb02 0783 	add.w	r7, r2, r3, lsl #2
 80054be:	ee00 0a84 	vmla.f32	s0, s1, s8
 80054c2:	3108      	adds	r1, #8
 80054c4:	f100 0310 	add.w	r3, r0, #16
 80054c8:	ee01 0a23 	vmla.f32	s0, s2, s7
 80054cc:	ed97 2a00 	vldr	s4, [r7]
 80054d0:	ee01 0a83 	vmla.f32	s0, s3, s6
 80054d4:	429d      	cmp	r5, r3
 80054d6:	ee02 0a22 	vmla.f32	s0, s4, s5
 80054da:	d2b0      	bcs.n	800543e <ai_dict8_dot_array_f32+0xfa>
 80054dc:	e77c      	b.n	80053d8 <ai_dict8_dot_array_f32+0x94>
 80054de:	f811 0b01 	ldrb.w	r0, [r1], #1
 80054e2:	edd3 0a00 	vldr	s1, [r3]
 80054e6:	eb02 0680 	add.w	r6, r2, r0, lsl #2
 80054ea:	1d1b      	adds	r3, r3, #4
 80054ec:	ed96 0a00 	vldr	s0, [r6]
 80054f0:	ee20 0a20 	vmul.f32	s0, s0, s1
 80054f4:	f811 0b01 	ldrb.w	r0, [r1], #1
 80054f8:	ed93 1a00 	vldr	s2, [r3]
 80054fc:	eb02 0680 	add.w	r6, r2, r0, lsl #2
 8005500:	1d1b      	adds	r3, r3, #4
 8005502:	edd6 0a00 	vldr	s1, [r6]
 8005506:	ee00 0a81 	vmla.f32	s0, s1, s2
 800550a:	f811 0b01 	ldrb.w	r0, [r1], #1
 800550e:	ed93 1a00 	vldr	s2, [r3]
 8005512:	eb02 0680 	add.w	r6, r2, r0, lsl #2
 8005516:	1d1b      	adds	r3, r3, #4
 8005518:	edd6 0a00 	vldr	s1, [r6]
 800551c:	429d      	cmp	r5, r3
 800551e:	ee00 0a81 	vmla.f32	s0, s1, s2
 8005522:	d34e      	bcc.n	80055c2 <ai_dict8_dot_array_f32+0x27e>
 8005524:	78cf      	ldrb	r7, [r1, #3]
 8005526:	ed93 4a00 	vldr	s8, [r3]
 800552a:	ed93 3a01 	vldr	s6, [r3, #4]
 800552e:	ed93 2a02 	vldr	s4, [r3, #8]
 8005532:	ed93 1a03 	vldr	s2, [r3, #12]
 8005536:	eb02 0687 	add.w	r6, r2, r7, lsl #2
 800553a:	788f      	ldrb	r7, [r1, #2]
 800553c:	edd6 0a00 	vldr	s1, [r6]
 8005540:	eb02 0687 	add.w	r6, r2, r7, lsl #2
 8005544:	784f      	ldrb	r7, [r1, #1]
 8005546:	edd6 1a00 	vldr	s3, [r6]
 800554a:	eb02 0687 	add.w	r6, r2, r7, lsl #2
 800554e:	780f      	ldrb	r7, [r1, #0]
 8005550:	edd6 2a00 	vldr	s5, [r6]
 8005554:	eb02 0687 	add.w	r6, r2, r7, lsl #2
 8005558:	f103 0010 	add.w	r0, r3, #16
 800555c:	edd6 3a00 	vldr	s7, [r6]
 8005560:	790b      	ldrb	r3, [r1, #4]
 8005562:	ee03 0a84 	vmla.f32	s0, s7, s8
 8005566:	ee02 0a83 	vmla.f32	s0, s5, s6
 800556a:	ee01 0a82 	vmla.f32	s0, s3, s4
 800556e:	eb02 0783 	add.w	r7, r2, r3, lsl #2
 8005572:	ee00 0a81 	vmla.f32	s0, s1, s2
 8005576:	794b      	ldrb	r3, [r1, #5]
 8005578:	edd7 0a00 	vldr	s1, [r7]
 800557c:	ed90 4a00 	vldr	s8, [r0]
 8005580:	edd0 3a01 	vldr	s7, [r0, #4]
 8005584:	ed90 3a02 	vldr	s6, [r0, #8]
 8005588:	edd0 2a03 	vldr	s5, [r0, #12]
 800558c:	eb02 0783 	add.w	r7, r2, r3, lsl #2
 8005590:	798b      	ldrb	r3, [r1, #6]
 8005592:	ed97 1a00 	vldr	s2, [r7]
 8005596:	eb02 0783 	add.w	r7, r2, r3, lsl #2
 800559a:	79cb      	ldrb	r3, [r1, #7]
 800559c:	edd7 1a00 	vldr	s3, [r7]
 80055a0:	eb02 0783 	add.w	r7, r2, r3, lsl #2
 80055a4:	ee00 0a84 	vmla.f32	s0, s1, s8
 80055a8:	3108      	adds	r1, #8
 80055aa:	f100 0310 	add.w	r3, r0, #16
 80055ae:	ee01 0a23 	vmla.f32	s0, s2, s7
 80055b2:	ed97 2a00 	vldr	s4, [r7]
 80055b6:	ee01 0a83 	vmla.f32	s0, s3, s6
 80055ba:	429d      	cmp	r5, r3
 80055bc:	ee02 0a22 	vmla.f32	s0, s4, s5
 80055c0:	d2b0      	bcs.n	8005524 <ai_dict8_dot_array_f32+0x1e0>
 80055c2:	3520      	adds	r5, #32
 80055c4:	42ab      	cmp	r3, r5
 80055c6:	d224      	bcs.n	8005612 <ai_dict8_dot_array_f32+0x2ce>
 80055c8:	780e      	ldrb	r6, [r1, #0]
 80055ca:	edd3 0a00 	vldr	s1, [r3]
 80055ce:	eb02 0086 	add.w	r0, r2, r6, lsl #2
 80055d2:	ed90 1a00 	vldr	s2, [r0]
 80055d6:	1d18      	adds	r0, r3, #4
 80055d8:	42a8      	cmp	r0, r5
 80055da:	ee01 0a20 	vmla.f32	s0, s2, s1
 80055de:	d218      	bcs.n	8005612 <ai_dict8_dot_array_f32+0x2ce>
 80055e0:	784e      	ldrb	r6, [r1, #1]
 80055e2:	edd0 0a00 	vldr	s1, [r0]
 80055e6:	eb02 0386 	add.w	r3, r2, r6, lsl #2
 80055ea:	1d00      	adds	r0, r0, #4
 80055ec:	ed93 1a00 	vldr	s2, [r3]
 80055f0:	42a8      	cmp	r0, r5
 80055f2:	ee01 0a20 	vmla.f32	s0, s2, s1
 80055f6:	d20c      	bcs.n	8005612 <ai_dict8_dot_array_f32+0x2ce>
 80055f8:	788e      	ldrb	r6, [r1, #2]
 80055fa:	edd0 0a00 	vldr	s1, [r0]
 80055fe:	eb02 0386 	add.w	r3, r2, r6, lsl #2
 8005602:	1cc9      	adds	r1, r1, #3
 8005604:	ed93 1a00 	vldr	s2, [r3]
 8005608:	1d03      	adds	r3, r0, #4
 800560a:	42ab      	cmp	r3, r5
 800560c:	ee01 0a20 	vmla.f32	s0, s2, s1
 8005610:	d3da      	bcc.n	80055c8 <ai_dict8_dot_array_f32+0x284>
 8005612:	edd4 0a00 	vldr	s1, [r4]
 8005616:	ee30 0a80 	vadd.f32	s0, s1, s0
 800561a:	ed84 0a00 	vstr	s0, [r4]
 800561e:	bcf0      	pop	{r4, r5, r6, r7}
 8005620:	4770      	bx	lr
	...

08005624 <ai_dict4_dot_array_f32>:
 8005624:	b4f0      	push	{r4, r5, r6, r7}
 8005626:	9c04      	ldr	r4, [sp, #16]
 8005628:	0865      	lsrs	r5, r4, #1
 800562a:	006d      	lsls	r5, r5, #1
 800562c:	eb03 0585 	add.w	r5, r3, r5, lsl #2
 8005630:	42ab      	cmp	r3, r5
 8005632:	ed9f 0a23 	vldr	s0, [pc, #140]	; 80056c0 <.text_7>
 8005636:	d22f      	bcs.n	8005698 <ai_dict4_dot_array_f32+0x74>
 8005638:	f811 6b01 	ldrb.w	r6, [r1], #1
 800563c:	edd3 1a00 	vldr	s3, [r3]
 8005640:	edd3 0a01 	vldr	s1, [r3, #4]
 8005644:	f006 070f 	and.w	r7, r6, #15
 8005648:	0936      	lsrs	r6, r6, #4
 800564a:	eb02 0686 	add.w	r6, r2, r6, lsl #2
 800564e:	eb02 0787 	add.w	r7, r2, r7, lsl #2
 8005652:	ed96 2a00 	vldr	s4, [r6]
 8005656:	ed97 1a00 	vldr	s2, [r7]
 800565a:	3308      	adds	r3, #8
 800565c:	ee02 0a21 	vmla.f32	s0, s4, s3
 8005660:	42ab      	cmp	r3, r5
 8005662:	ee01 0a20 	vmla.f32	s0, s2, s1
 8005666:	d217      	bcs.n	8005698 <ai_dict4_dot_array_f32+0x74>
 8005668:	f811 6b01 	ldrb.w	r6, [r1], #1
 800566c:	ed93 1a00 	vldr	s2, [r3]
 8005670:	ed93 2a01 	vldr	s4, [r3, #4]
 8005674:	f006 070f 	and.w	r7, r6, #15
 8005678:	0936      	lsrs	r6, r6, #4
 800567a:	eb02 0686 	add.w	r6, r2, r6, lsl #2
 800567e:	eb02 0787 	add.w	r7, r2, r7, lsl #2
 8005682:	edd6 1a00 	vldr	s3, [r6]
 8005686:	edd7 0a00 	vldr	s1, [r7]
 800568a:	3308      	adds	r3, #8
 800568c:	ee01 0a81 	vmla.f32	s0, s3, s2
 8005690:	42ab      	cmp	r3, r5
 8005692:	ee00 0a82 	vmla.f32	s0, s1, s4
 8005696:	d3cf      	bcc.n	8005638 <ai_dict4_dot_array_f32+0x14>
 8005698:	07e4      	lsls	r4, r4, #31
 800569a:	d509      	bpl.n	80056b0 <ai_dict4_dot_array_f32+0x8c>
 800569c:	7809      	ldrb	r1, [r1, #0]
 800569e:	ed93 1a00 	vldr	s2, [r3]
 80056a2:	0909      	lsrs	r1, r1, #4
 80056a4:	eb02 0281 	add.w	r2, r2, r1, lsl #2
 80056a8:	edd2 0a00 	vldr	s1, [r2]
 80056ac:	ee00 0a81 	vmla.f32	s0, s1, s2
 80056b0:	edd0 1a00 	vldr	s3, [r0]
 80056b4:	ee31 0a80 	vadd.f32	s0, s3, s0
 80056b8:	ed80 0a00 	vstr	s0, [r0]
 80056bc:	bcf0      	pop	{r4, r5, r6, r7}
 80056be:	4770      	bx	lr

080056c0 <.text_7>:
 80056c0:	00000000 	.word	0x00000000

080056c4 <ai_dict_decompress_f32>:
 80056c4:	b4f0      	push	{r4, r5, r6, r7}
 80056c6:	4604      	mov	r4, r0
 80056c8:	9805      	ldr	r0, [sp, #20]
 80056ca:	9e04      	ldr	r6, [sp, #16]
 80056cc:	2b04      	cmp	r3, #4
 80056ce:	eb04 0580 	add.w	r5, r4, r0, lsl #2
 80056d2:	d003      	beq.n	80056dc <ai_dict_decompress_f32+0x18>
 80056d4:	2b08      	cmp	r3, #8
 80056d6:	d03e      	beq.n	8005756 <ai_dict_decompress_f32+0x92>
 80056d8:	bcf0      	pop	{r4, r5, r6, r7}
 80056da:	4770      	bx	lr
 80056dc:	42ac      	cmp	r4, r5
 80056de:	d259      	bcs.n	8005794 <ai_dict_decompress_f32+0xd0>
 80056e0:	0870      	lsrs	r0, r6, #1
 80056e2:	d02e      	beq.n	8005742 <ai_dict_decompress_f32+0x7e>
 80056e4:	07c3      	lsls	r3, r0, #31
 80056e6:	d50c      	bpl.n	8005702 <ai_dict_decompress_f32+0x3e>
 80056e8:	780f      	ldrb	r7, [r1, #0]
 80056ea:	093f      	lsrs	r7, r7, #4
 80056ec:	f852 3027 	ldr.w	r3, [r2, r7, lsl #2]
 80056f0:	6023      	str	r3, [r4, #0]
 80056f2:	f811 7b01 	ldrb.w	r7, [r1], #1
 80056f6:	f007 070f 	and.w	r7, r7, #15
 80056fa:	f852 3027 	ldr.w	r3, [r2, r7, lsl #2]
 80056fe:	6063      	str	r3, [r4, #4]
 8005700:	3408      	adds	r4, #8
 8005702:	0840      	lsrs	r0, r0, #1
 8005704:	d01d      	beq.n	8005742 <ai_dict_decompress_f32+0x7e>
 8005706:	780b      	ldrb	r3, [r1, #0]
 8005708:	091b      	lsrs	r3, r3, #4
 800570a:	f852 7023 	ldr.w	r7, [r2, r3, lsl #2]
 800570e:	6027      	str	r7, [r4, #0]
 8005710:	f811 3b01 	ldrb.w	r3, [r1], #1
 8005714:	f003 030f 	and.w	r3, r3, #15
 8005718:	f852 7023 	ldr.w	r7, [r2, r3, lsl #2]
 800571c:	6067      	str	r7, [r4, #4]
 800571e:	f104 0308 	add.w	r3, r4, #8
 8005722:	780c      	ldrb	r4, [r1, #0]
 8005724:	0924      	lsrs	r4, r4, #4
 8005726:	f852 7024 	ldr.w	r7, [r2, r4, lsl #2]
 800572a:	601f      	str	r7, [r3, #0]
 800572c:	1e40      	subs	r0, r0, #1
 800572e:	f811 4b01 	ldrb.w	r4, [r1], #1
 8005732:	f004 040f 	and.w	r4, r4, #15
 8005736:	f852 7024 	ldr.w	r7, [r2, r4, lsl #2]
 800573a:	605f      	str	r7, [r3, #4]
 800573c:	f103 0408 	add.w	r4, r3, #8
 8005740:	d1e1      	bne.n	8005706 <ai_dict_decompress_f32+0x42>
 8005742:	07f0      	lsls	r0, r6, #31
 8005744:	d5ca      	bpl.n	80056dc <ai_dict_decompress_f32+0x18>
 8005746:	f811 3b01 	ldrb.w	r3, [r1], #1
 800574a:	091b      	lsrs	r3, r3, #4
 800574c:	f852 0023 	ldr.w	r0, [r2, r3, lsl #2]
 8005750:	f844 0b04 	str.w	r0, [r4], #4
 8005754:	e7c2      	b.n	80056dc <ai_dict_decompress_f32+0x18>
 8005756:	42ac      	cmp	r4, r5
 8005758:	d21c      	bcs.n	8005794 <ai_dict_decompress_f32+0xd0>
 800575a:	7808      	ldrb	r0, [r1, #0]
 800575c:	f852 0020 	ldr.w	r0, [r2, r0, lsl #2]
 8005760:	6020      	str	r0, [r4, #0]
 8005762:	1d20      	adds	r0, r4, #4
 8005764:	42a8      	cmp	r0, r5
 8005766:	bf3f      	itttt	cc
 8005768:	784c      	ldrbcc	r4, [r1, #1]
 800576a:	f852 3024 	ldrcc.w	r3, [r2, r4, lsl #2]
 800576e:	f840 3b04 	strcc.w	r3, [r0], #4
 8005772:	42a8      	cmpcc	r0, r5
 8005774:	d20e      	bcs.n	8005794 <ai_dict_decompress_f32+0xd0>
 8005776:	788b      	ldrb	r3, [r1, #2]
 8005778:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 800577c:	f840 3b04 	str.w	r3, [r0], #4
 8005780:	42a8      	cmp	r0, r5
 8005782:	d207      	bcs.n	8005794 <ai_dict_decompress_f32+0xd0>
 8005784:	78cc      	ldrb	r4, [r1, #3]
 8005786:	f852 3024 	ldr.w	r3, [r2, r4, lsl #2]
 800578a:	1d09      	adds	r1, r1, #4
 800578c:	1d04      	adds	r4, r0, #4
 800578e:	42ac      	cmp	r4, r5
 8005790:	6003      	str	r3, [r0, #0]
 8005792:	d3e2      	bcc.n	800575a <ai_dict_decompress_f32+0x96>
 8005794:	bcf0      	pop	{r4, r5, r6, r7}
 8005796:	4770      	bx	lr

08005798 <forward_conv2d>:
 8005798:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800579c:	4605      	mov	r5, r0
 800579e:	b0a9      	sub	sp, #164	; 0xa4
 80057a0:	696b      	ldr	r3, [r5, #20]
 80057a2:	8819      	ldrh	r1, [r3, #0]
 80057a4:	2900      	cmp	r1, #0
 80057a6:	bf1a      	itte	ne
 80057a8:	6858      	ldrne	r0, [r3, #4]
 80057aa:	1d00      	addne	r0, r0, #4
 80057ac:	2004      	moveq	r0, #4
 80057ae:	6800      	ldr	r0, [r0, #0]
 80057b0:	2800      	cmp	r0, #0
 80057b2:	bf14      	ite	ne
 80057b4:	6802      	ldrne	r2, [r0, #0]
 80057b6:	2200      	moveq	r2, #0
 80057b8:	2901      	cmp	r1, #1
 80057ba:	bfc6      	itte	gt
 80057bc:	6858      	ldrgt	r0, [r3, #4]
 80057be:	3010      	addgt	r0, #16
 80057c0:	2004      	movle	r0, #4
 80057c2:	6800      	ldr	r0, [r0, #0]
 80057c4:	2800      	cmp	r0, #0
 80057c6:	bf14      	ite	ne
 80057c8:	f8d0 a000 	ldrne.w	sl, [r0]
 80057cc:	f04f 0a00 	moveq.w	sl, #0
 80057d0:	2902      	cmp	r1, #2
 80057d2:	bfc6      	itte	gt
 80057d4:	6858      	ldrgt	r0, [r3, #4]
 80057d6:	f100 041c 	addgt.w	r4, r0, #28
 80057da:	2404      	movle	r4, #4
 80057dc:	6820      	ldr	r0, [r4, #0]
 80057de:	2800      	cmp	r0, #0
 80057e0:	bf14      	ite	ne
 80057e2:	6806      	ldrne	r6, [r0, #0]
 80057e4:	2600      	moveq	r6, #0
 80057e6:	2902      	cmp	r1, #2
 80057e8:	dd0a      	ble.n	8005800 <forward_conv2d+0x68>
 80057ea:	685b      	ldr	r3, [r3, #4]
 80057ec:	f113 0118 	adds.w	r1, r3, #24
 80057f0:	d006      	beq.n	8005800 <forward_conv2d+0x68>
 80057f2:	8b19      	ldrh	r1, [r3, #24]
 80057f4:	2901      	cmp	r1, #1
 80057f6:	dd03      	ble.n	8005800 <forward_conv2d+0x68>
 80057f8:	69d9      	ldr	r1, [r3, #28]
 80057fa:	b109      	cbz	r1, 8005800 <forward_conv2d+0x68>
 80057fc:	6849      	ldr	r1, [r1, #4]
 80057fe:	e000      	b.n	8005802 <forward_conv2d+0x6a>
 8005800:	2100      	movs	r1, #0
 8005802:	b100      	cbz	r0, 8005806 <forward_conv2d+0x6e>
 8005804:	6880      	ldr	r0, [r0, #8]
 8005806:	68d7      	ldr	r7, [r2, #12]
 8005808:	687b      	ldr	r3, [r7, #4]
 800580a:	931b      	str	r3, [sp, #108]	; 0x6c
 800580c:	f8da 300c 	ldr.w	r3, [sl, #12]
 8005810:	685c      	ldr	r4, [r3, #4]
 8005812:	9404      	str	r4, [sp, #16]
 8005814:	68dc      	ldr	r4, [r3, #12]
 8005816:	689b      	ldr	r3, [r3, #8]
 8005818:	9314      	str	r3, [sp, #80]	; 0x50
 800581a:	68fb      	ldr	r3, [r7, #12]
 800581c:	931a      	str	r3, [sp, #104]	; 0x68
 800581e:	68bf      	ldr	r7, [r7, #8]
 8005820:	9720      	str	r7, [sp, #128]	; 0x80
 8005822:	6a6b      	ldr	r3, [r5, #36]	; 0x24
 8005824:	f8ad 3040 	strh.w	r3, [sp, #64]	; 0x40
 8005828:	8d2f      	ldrh	r7, [r5, #40]	; 0x28
 800582a:	971f      	str	r7, [sp, #124]	; 0x7c
 800582c:	6bab      	ldr	r3, [r5, #56]	; 0x38
 800582e:	681f      	ldr	r7, [r3, #0]
 8005830:	f8b3 8004 	ldrh.w	r8, [r3, #4]
 8005834:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
 8005836:	9319      	str	r3, [sp, #100]	; 0x64
 8005838:	6b2b      	ldr	r3, [r5, #48]	; 0x30
 800583a:	9318      	str	r3, [sp, #96]	; 0x60
 800583c:	68f3      	ldr	r3, [r6, #12]
 800583e:	f8d3 e008 	ldr.w	lr, [r3, #8]
 8005842:	f8cd e04c 	str.w	lr, [sp, #76]	; 0x4c
 8005846:	685b      	ldr	r3, [r3, #4]
 8005848:	9312      	str	r3, [sp, #72]	; 0x48
 800584a:	69ab      	ldr	r3, [r5, #24]
 800584c:	931e      	str	r3, [sp, #120]	; 0x78
 800584e:	6992      	ldr	r2, [r2, #24]
 8005850:	6893      	ldr	r3, [r2, #8]
 8005852:	931d      	str	r3, [sp, #116]	; 0x74
 8005854:	69b2      	ldr	r2, [r6, #24]
 8005856:	f8d2 9008 	ldr.w	r9, [r2, #8]
 800585a:	b119      	cbz	r1, 8005864 <forward_conv2d+0xcc>
 800585c:	698a      	ldr	r2, [r1, #24]
 800585e:	6893      	ldr	r3, [r2, #8]
 8005860:	9317      	str	r3, [sp, #92]	; 0x5c
 8005862:	e001      	b.n	8005868 <forward_conv2d+0xd0>
 8005864:	2200      	movs	r2, #0
 8005866:	9217      	str	r2, [sp, #92]	; 0x5c
 8005868:	f8da 1018 	ldr.w	r1, [sl, #24]
 800586c:	688a      	ldr	r2, [r1, #8]
 800586e:	9203      	str	r2, [sp, #12]
 8005870:	69e9      	ldr	r1, [r5, #28]
 8005872:	b118      	cbz	r0, 800587c <forward_conv2d+0xe4>
 8005874:	6981      	ldr	r1, [r0, #24]
 8005876:	688a      	ldr	r2, [r1, #8]
 8005878:	9215      	str	r2, [sp, #84]	; 0x54
 800587a:	e005      	b.n	8005888 <forward_conv2d+0xf0>
 800587c:	b111      	cbz	r1, 8005884 <forward_conv2d+0xec>
 800587e:	688a      	ldr	r2, [r1, #8]
 8005880:	9215      	str	r2, [sp, #84]	; 0x54
 8005882:	e001      	b.n	8005888 <forward_conv2d+0xf0>
 8005884:	2300      	movs	r3, #0
 8005886:	9315      	str	r3, [sp, #84]	; 0x54
 8005888:	9915      	ldr	r1, [sp, #84]	; 0x54
 800588a:	9102      	str	r1, [sp, #8]
 800588c:	b920      	cbnz	r0, 8005898 <forward_conv2d+0x100>
 800588e:	2100      	movs	r1, #0
 8005890:	2201      	movs	r2, #1
 8005892:	9124      	str	r1, [sp, #144]	; 0x90
 8005894:	9223      	str	r2, [sp, #140]	; 0x8c
 8005896:	e008      	b.n	80058aa <forward_conv2d+0x112>
 8005898:	6941      	ldr	r1, [r0, #20]
 800589a:	688a      	ldr	r2, [r1, #8]
 800589c:	9224      	str	r2, [sp, #144]	; 0x90
 800589e:	6980      	ldr	r0, [r0, #24]
 80058a0:	6841      	ldr	r1, [r0, #4]
 80058a2:	6800      	ldr	r0, [r0, #0]
 80058a4:	f004 fb52 	bl	8009f4c <ai_array_get_byte_size>
 80058a8:	9023      	str	r0, [sp, #140]	; 0x8c
 80058aa:	aa18      	add	r2, sp, #96	; 0x60
 80058ac:	6a28      	ldr	r0, [r5, #32]
 80058ae:	2800      	cmp	r0, #0
 80058b0:	bf12      	itee	ne
 80058b2:	9022      	strne	r0, [sp, #136]	; 0x88
 80058b4:	f8df 1d28 	ldreq.w	r1, [pc, #3368]	; 80065e0 <.text_15>
 80058b8:	9122      	streq	r1, [sp, #136]	; 0x88
 80058ba:	9913      	ldr	r1, [sp, #76]	; 0x4c
 80058bc:	8813      	ldrh	r3, [r2, #0]
 80058be:	1e48      	subs	r0, r1, #1
 80058c0:	1e5b      	subs	r3, r3, #1
 80058c2:	aa19      	add	r2, sp, #100	; 0x64
 80058c4:	fb03 1100 	mla	r1, r3, r0, r1
 80058c8:	9116      	str	r1, [sp, #88]	; 0x58
 80058ca:	9812      	ldr	r0, [sp, #72]	; 0x48
 80058cc:	8813      	ldrh	r3, [r2, #0]
 80058ce:	1e41      	subs	r1, r0, #1
 80058d0:	1e5b      	subs	r3, r3, #1
 80058d2:	fb03 0001 	mla	r0, r3, r1, r0
 80058d6:	901c      	str	r0, [sp, #112]	; 0x70
 80058d8:	2200      	movs	r2, #0
 80058da:	69b6      	ldr	r6, [r6, #24]
 80058dc:	6831      	ldr	r1, [r6, #0]
 80058de:	11cb      	asrs	r3, r1, #7
 80058e0:	ea4f 5c61 	mov.w	ip, r1, asr #21
 80058e4:	1449      	asrs	r1, r1, #17
 80058e6:	f001 010f 	and.w	r1, r1, #15
 80058ea:	2000      	movs	r0, #0
 80058ec:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 80058f0:	f00c 0c03 	and.w	ip, ip, #3
 80058f4:	2904      	cmp	r1, #4
 80058f6:	4683      	mov	fp, r0
 80058f8:	fa23 f30c 	lsr.w	r3, r3, ip
 80058fc:	bf14      	ite	ne
 80058fe:	2908      	cmpne	r1, #8
 8005900:	68f2      	ldreq	r2, [r6, #12]
 8005902:	b1da      	cbz	r2, 800593c <forward_conv2d+0x1a4>
 8005904:	6969      	ldr	r1, [r5, #20]
 8005906:	880d      	ldrh	r5, [r1, #0]
 8005908:	2d04      	cmp	r5, #4
 800590a:	bfa6      	itte	ge
 800590c:	6849      	ldrge	r1, [r1, #4]
 800590e:	3128      	addge	r1, #40	; 0x28
 8005910:	2104      	movlt	r1, #4
 8005912:	6809      	ldr	r1, [r1, #0]
 8005914:	2900      	cmp	r1, #0
 8005916:	bf1f      	itttt	ne
 8005918:	6808      	ldrne	r0, [r1, #0]
 800591a:	2800      	cmpne	r0, #0
 800591c:	6981      	ldrne	r1, [r0, #24]
 800591e:	f8d1 b008 	ldrne.w	fp, [r1, #8]
 8005922:	6980      	ldr	r0, [r0, #24]
 8005924:	6841      	ldr	r1, [r0, #4]
 8005926:	981b      	ldr	r0, [sp, #108]	; 0x6c
 8005928:	9101      	str	r1, [sp, #4]
 800592a:	9000      	str	r0, [sp, #0]
 800592c:	4658      	mov	r0, fp
 800592e:	68b1      	ldr	r1, [r6, #8]
 8005930:	f7ff fec8 	bl	80056c4 <ai_dict_decompress_f32>
 8005934:	f1bb 0f00 	cmp.w	fp, #0
 8005938:	bf18      	it	ne
 800593a:	46d9      	movne	r9, fp
 800593c:	b2bf      	uxth	r7, r7
 800593e:	427f      	negs	r7, r7
 8005940:	2c00      	cmp	r4, #0
 8005942:	d073      	beq.n	8005a2c <forward_conv2d+0x294>
 8005944:	4622      	mov	r2, r4
 8005946:	f1c8 0800 	rsb	r8, r8, #0
 800594a:	9c04      	ldr	r4, [sp, #16]
 800594c:	f8dd b00c 	ldr.w	fp, [sp, #12]
 8005950:	9e02      	ldr	r6, [sp, #8]
 8005952:	f8cd 8098 	str.w	r8, [sp, #152]	; 0x98
 8005956:	f8cd 909c 	str.w	r9, [sp, #156]	; 0x9c
 800595a:	9711      	str	r7, [sp, #68]	; 0x44
 800595c:	9221      	str	r2, [sp, #132]	; 0x84
 800595e:	9826      	ldr	r0, [sp, #152]	; 0x98
 8005960:	991a      	ldr	r1, [sp, #104]	; 0x68
 8005962:	9a11      	ldr	r2, [sp, #68]	; 0x44
 8005964:	9b16      	ldr	r3, [sp, #88]	; 0x58
 8005966:	9025      	str	r0, [sp, #148]	; 0x94
 8005968:	9811      	ldr	r0, [sp, #68]	; 0x44
 800596a:	4240      	negs	r0, r0
 800596c:	bfd8      	it	le
 800596e:	2000      	movle	r0, #0
 8005970:	1a89      	subs	r1, r1, r2
 8005972:	4299      	cmp	r1, r3
 8005974:	bf3d      	ittte	cc
 8005976:	9a1a      	ldrcc	r2, [sp, #104]	; 0x68
 8005978:	9911      	ldrcc	r1, [sp, #68]	; 0x44
 800597a:	1a51      	subcc	r1, r2, r1
 800597c:	4619      	movcs	r1, r3
 800597e:	910a      	str	r1, [sp, #40]	; 0x28
 8005980:	9009      	str	r0, [sp, #36]	; 0x24
 8005982:	9402      	str	r4, [sp, #8]
 8005984:	981e      	ldr	r0, [sp, #120]	; 0x78
 8005986:	f8bd 1040 	ldrh.w	r1, [sp, #64]	; 0x40
 800598a:	9a18      	ldr	r2, [sp, #96]	; 0x60
 800598c:	9008      	str	r0, [sp, #32]
 800598e:	9107      	str	r1, [sp, #28]
 8005990:	b212      	sxth	r2, r2
 8005992:	9813      	ldr	r0, [sp, #76]	; 0x4c
 8005994:	9912      	ldr	r1, [sp, #72]	; 0x48
 8005996:	9b19      	ldr	r3, [sp, #100]	; 0x64
 8005998:	920f      	str	r2, [sp, #60]	; 0x3c
 800599a:	9006      	str	r0, [sp, #24]
 800599c:	9105      	str	r1, [sp, #20]
 800599e:	b21b      	sxth	r3, r3
 80059a0:	9a1c      	ldr	r2, [sp, #112]	; 0x70
 80059a2:	9814      	ldr	r0, [sp, #80]	; 0x50
 80059a4:	9920      	ldr	r1, [sp, #128]	; 0x80
 80059a6:	930e      	str	r3, [sp, #56]	; 0x38
 80059a8:	920d      	str	r2, [sp, #52]	; 0x34
 80059aa:	9004      	str	r0, [sp, #16]
 80059ac:	9103      	str	r1, [sp, #12]
 80059ae:	9b11      	ldr	r3, [sp, #68]	; 0x44
 80059b0:	9a25      	ldr	r2, [sp, #148]	; 0x94
 80059b2:	981b      	ldr	r0, [sp, #108]	; 0x6c
 80059b4:	9917      	ldr	r1, [sp, #92]	; 0x5c
 80059b6:	930c      	str	r3, [sp, #48]	; 0x30
 80059b8:	920b      	str	r2, [sp, #44]	; 0x2c
 80059ba:	9001      	str	r0, [sp, #4]
 80059bc:	9100      	str	r1, [sp, #0]
 80059be:	9b27      	ldr	r3, [sp, #156]	; 0x9c
 80059c0:	9a1d      	ldr	r2, [sp, #116]	; 0x74
 80059c2:	4659      	mov	r1, fp
 80059c4:	2000      	movs	r0, #0
 80059c6:	f7ff f9e3 	bl	8004d90 <ai_conv2d_stripe_f32>
 80059ca:	9814      	ldr	r0, [sp, #80]	; 0x50
 80059cc:	b310      	cbz	r0, 8005a14 <forward_conv2d+0x27c>
 80059ce:	f8cd a000 	str.w	sl, [sp]
 80059d2:	9d15      	ldr	r5, [sp, #84]	; 0x54
 80059d4:	9f24      	ldr	r7, [sp, #144]	; 0x90
 80059d6:	f8dd 808c 	ldr.w	r8, [sp, #140]	; 0x8c
 80059da:	f8dd 9088 	ldr.w	r9, [sp, #136]	; 0x88
 80059de:	4682      	mov	sl, r0
 80059e0:	9800      	ldr	r0, [sp, #0]
 80059e2:	6981      	ldr	r1, [r0, #24]
 80059e4:	f8c1 b008 	str.w	fp, [r1, #8]
 80059e8:	462b      	mov	r3, r5
 80059ea:	4622      	mov	r2, r4
 80059ec:	4608      	mov	r0, r1
 80059ee:	47c8      	blx	r9
 80059f0:	443d      	add	r5, r7
 80059f2:	1ba8      	subs	r0, r5, r6
 80059f4:	4540      	cmp	r0, r8
 80059f6:	bfa8      	it	ge
 80059f8:	4635      	movge	r5, r6
 80059fa:	f1ba 0a01 	subs.w	sl, sl, #1
 80059fe:	eb0b 0b84 	add.w	fp, fp, r4, lsl #2
 8005a02:	d1ed      	bne.n	80059e0 <forward_conv2d+0x248>
 8005a04:	f8dd a000 	ldr.w	sl, [sp]
 8005a08:	9515      	str	r5, [sp, #84]	; 0x54
 8005a0a:	9724      	str	r7, [sp, #144]	; 0x90
 8005a0c:	f8cd 808c 	str.w	r8, [sp, #140]	; 0x8c
 8005a10:	f8cd 9088 	str.w	r9, [sp, #136]	; 0x88
 8005a14:	f8da 0018 	ldr.w	r0, [sl, #24]
 8005a18:	68c1      	ldr	r1, [r0, #12]
 8005a1a:	6081      	str	r1, [r0, #8]
 8005a1c:	9811      	ldr	r0, [sp, #68]	; 0x44
 8005a1e:	991f      	ldr	r1, [sp, #124]	; 0x7c
 8005a20:	1808      	adds	r0, r1, r0
 8005a22:	9011      	str	r0, [sp, #68]	; 0x44
 8005a24:	9821      	ldr	r0, [sp, #132]	; 0x84
 8005a26:	1e40      	subs	r0, r0, #1
 8005a28:	9021      	str	r0, [sp, #132]	; 0x84
 8005a2a:	d198      	bne.n	800595e <forward_conv2d+0x1c6>
 8005a2c:	b029      	add	sp, #164	; 0xa4
 8005a2e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	...

08005a34 <forward_conv2d_nl_pool>:
 8005a34:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8005a38:	4604      	mov	r4, r0
 8005a3a:	b0b9      	sub	sp, #228	; 0xe4
 8005a3c:	6963      	ldr	r3, [r4, #20]
 8005a3e:	8819      	ldrh	r1, [r3, #0]
 8005a40:	2900      	cmp	r1, #0
 8005a42:	bf1a      	itte	ne
 8005a44:	6858      	ldrne	r0, [r3, #4]
 8005a46:	1d00      	addne	r0, r0, #4
 8005a48:	2004      	moveq	r0, #4
 8005a4a:	6800      	ldr	r0, [r0, #0]
 8005a4c:	2800      	cmp	r0, #0
 8005a4e:	bf14      	ite	ne
 8005a50:	6802      	ldrne	r2, [r0, #0]
 8005a52:	2200      	moveq	r2, #0
 8005a54:	2901      	cmp	r1, #1
 8005a56:	bfc6      	itte	gt
 8005a58:	6858      	ldrgt	r0, [r3, #4]
 8005a5a:	3010      	addgt	r0, #16
 8005a5c:	2004      	movle	r0, #4
 8005a5e:	6800      	ldr	r0, [r0, #0]
 8005a60:	2800      	cmp	r0, #0
 8005a62:	bf14      	ite	ne
 8005a64:	f8d0 9000 	ldrne.w	r9, [r0]
 8005a68:	f04f 0900 	moveq.w	r9, #0
 8005a6c:	2902      	cmp	r1, #2
 8005a6e:	bfc6      	itte	gt
 8005a70:	6858      	ldrgt	r0, [r3, #4]
 8005a72:	f100 071c 	addgt.w	r7, r0, #28
 8005a76:	2704      	movle	r7, #4
 8005a78:	6838      	ldr	r0, [r7, #0]
 8005a7a:	2800      	cmp	r0, #0
 8005a7c:	bf14      	ite	ne
 8005a7e:	6806      	ldrne	r6, [r0, #0]
 8005a80:	2600      	moveq	r6, #0
 8005a82:	2902      	cmp	r1, #2
 8005a84:	dd0a      	ble.n	8005a9c <forward_conv2d_nl_pool+0x68>
 8005a86:	685b      	ldr	r3, [r3, #4]
 8005a88:	f113 0118 	adds.w	r1, r3, #24
 8005a8c:	d006      	beq.n	8005a9c <forward_conv2d_nl_pool+0x68>
 8005a8e:	8b19      	ldrh	r1, [r3, #24]
 8005a90:	2901      	cmp	r1, #1
 8005a92:	dd03      	ble.n	8005a9c <forward_conv2d_nl_pool+0x68>
 8005a94:	69d9      	ldr	r1, [r3, #28]
 8005a96:	b109      	cbz	r1, 8005a9c <forward_conv2d_nl_pool+0x68>
 8005a98:	6849      	ldr	r1, [r1, #4]
 8005a9a:	e000      	b.n	8005a9e <forward_conv2d_nl_pool+0x6a>
 8005a9c:	2100      	movs	r1, #0
 8005a9e:	b100      	cbz	r0, 8005aa2 <forward_conv2d_nl_pool+0x6e>
 8005aa0:	6880      	ldr	r0, [r0, #8]
 8005aa2:	68d7      	ldr	r7, [r2, #12]
 8005aa4:	687b      	ldr	r3, [r7, #4]
 8005aa6:	9323      	str	r3, [sp, #140]	; 0x8c
 8005aa8:	f8d9 500c 	ldr.w	r5, [r9, #12]
 8005aac:	686b      	ldr	r3, [r5, #4]
 8005aae:	9310      	str	r3, [sp, #64]	; 0x40
 8005ab0:	68eb      	ldr	r3, [r5, #12]
 8005ab2:	9322      	str	r3, [sp, #136]	; 0x88
 8005ab4:	68ab      	ldr	r3, [r5, #8]
 8005ab6:	9321      	str	r3, [sp, #132]	; 0x84
 8005ab8:	68fb      	ldr	r3, [r7, #12]
 8005aba:	931b      	str	r3, [sp, #108]	; 0x6c
 8005abc:	68bf      	ldr	r7, [r7, #8]
 8005abe:	972d      	str	r7, [sp, #180]	; 0xb4
 8005ac0:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8005ac2:	f8ad 304c 	strh.w	r3, [sp, #76]	; 0x4c
 8005ac6:	8d27      	ldrh	r7, [r4, #40]	; 0x28
 8005ac8:	9720      	str	r7, [sp, #128]	; 0x80
 8005aca:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8005acc:	881f      	ldrh	r7, [r3, #0]
 8005ace:	f8b3 8004 	ldrh.w	r8, [r3, #4]
 8005ad2:	689d      	ldr	r5, [r3, #8]
 8005ad4:	69a3      	ldr	r3, [r4, #24]
 8005ad6:	932c      	str	r3, [sp, #176]	; 0xb0
 8005ad8:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 8005ada:	931f      	str	r3, [sp, #124]	; 0x7c
 8005adc:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8005ade:	931e      	str	r3, [sp, #120]	; 0x78
 8005ae0:	68f3      	ldr	r3, [r6, #12]
 8005ae2:	f8d3 e004 	ldr.w	lr, [r3, #4]
 8005ae6:	f8cd e068 	str.w	lr, [sp, #104]	; 0x68
 8005aea:	689b      	ldr	r3, [r3, #8]
 8005aec:	9319      	str	r3, [sp, #100]	; 0x64
 8005aee:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 8005af0:	932b      	str	r3, [sp, #172]	; 0xac
 8005af2:	6c63      	ldr	r3, [r4, #68]	; 0x44
 8005af4:	932a      	str	r3, [sp, #168]	; 0xa8
 8005af6:	6ca3      	ldr	r3, [r4, #72]	; 0x48
 8005af8:	9311      	str	r3, [sp, #68]	; 0x44
 8005afa:	6d23      	ldr	r3, [r4, #80]	; 0x50
 8005afc:	f8d3 a000 	ldr.w	sl, [r3]
 8005b00:	685b      	ldr	r3, [r3, #4]
 8005b02:	9329      	str	r3, [sp, #164]	; 0xa4
 8005b04:	6992      	ldr	r2, [r2, #24]
 8005b06:	6893      	ldr	r3, [r2, #8]
 8005b08:	9328      	str	r3, [sp, #160]	; 0xa0
 8005b0a:	69b2      	ldr	r2, [r6, #24]
 8005b0c:	f8d2 b008 	ldr.w	fp, [r2, #8]
 8005b10:	b119      	cbz	r1, 8005b1a <forward_conv2d_nl_pool+0xe6>
 8005b12:	698a      	ldr	r2, [r1, #24]
 8005b14:	6893      	ldr	r3, [r2, #8]
 8005b16:	931d      	str	r3, [sp, #116]	; 0x74
 8005b18:	e001      	b.n	8005b1e <forward_conv2d_nl_pool+0xea>
 8005b1a:	2200      	movs	r2, #0
 8005b1c:	921d      	str	r2, [sp, #116]	; 0x74
 8005b1e:	69e1      	ldr	r1, [r4, #28]
 8005b20:	b118      	cbz	r0, 8005b2a <forward_conv2d_nl_pool+0xf6>
 8005b22:	6981      	ldr	r1, [r0, #24]
 8005b24:	688a      	ldr	r2, [r1, #8]
 8005b26:	921c      	str	r2, [sp, #112]	; 0x70
 8005b28:	e005      	b.n	8005b36 <forward_conv2d_nl_pool+0x102>
 8005b2a:	b111      	cbz	r1, 8005b32 <forward_conv2d_nl_pool+0xfe>
 8005b2c:	688a      	ldr	r2, [r1, #8]
 8005b2e:	921c      	str	r2, [sp, #112]	; 0x70
 8005b30:	e001      	b.n	8005b36 <forward_conv2d_nl_pool+0x102>
 8005b32:	2300      	movs	r3, #0
 8005b34:	931c      	str	r3, [sp, #112]	; 0x70
 8005b36:	991c      	ldr	r1, [sp, #112]	; 0x70
 8005b38:	9102      	str	r1, [sp, #8]
 8005b3a:	b920      	cbnz	r0, 8005b46 <forward_conv2d_nl_pool+0x112>
 8005b3c:	2100      	movs	r1, #0
 8005b3e:	2201      	movs	r2, #1
 8005b40:	9116      	str	r1, [sp, #88]	; 0x58
 8005b42:	9215      	str	r2, [sp, #84]	; 0x54
 8005b44:	e008      	b.n	8005b58 <forward_conv2d_nl_pool+0x124>
 8005b46:	6941      	ldr	r1, [r0, #20]
 8005b48:	688a      	ldr	r2, [r1, #8]
 8005b4a:	9216      	str	r2, [sp, #88]	; 0x58
 8005b4c:	6980      	ldr	r0, [r0, #24]
 8005b4e:	6841      	ldr	r1, [r0, #4]
 8005b50:	6800      	ldr	r0, [r0, #0]
 8005b52:	f004 f9fb 	bl	8009f4c <ai_array_get_byte_size>
 8005b56:	9015      	str	r0, [sp, #84]	; 0x54
 8005b58:	aa1e      	add	r2, sp, #120	; 0x78
 8005b5a:	6a20      	ldr	r0, [r4, #32]
 8005b5c:	2800      	cmp	r0, #0
 8005b5e:	bf12      	itee	ne
 8005b60:	9030      	strne	r0, [sp, #192]	; 0xc0
 8005b62:	f8df 1a7c 	ldreq.w	r1, [pc, #2684]	; 80065e0 <.text_15>
 8005b66:	9130      	streq	r1, [sp, #192]	; 0xc0
 8005b68:	6d61      	ldr	r1, [r4, #84]	; 0x54
 8005b6a:	9819      	ldr	r0, [sp, #100]	; 0x64
 8005b6c:	8813      	ldrh	r3, [r2, #0]
 8005b6e:	9127      	str	r1, [sp, #156]	; 0x9c
 8005b70:	1e5b      	subs	r3, r3, #1
 8005b72:	1e41      	subs	r1, r0, #1
 8005b74:	aa1f      	add	r2, sp, #124	; 0x7c
 8005b76:	fb03 0001 	mla	r0, r3, r1, r0
 8005b7a:	9018      	str	r0, [sp, #96]	; 0x60
 8005b7c:	991a      	ldr	r1, [sp, #104]	; 0x68
 8005b7e:	8813      	ldrh	r3, [r2, #0]
 8005b80:	1e48      	subs	r0, r1, #1
 8005b82:	1e5b      	subs	r3, r3, #1
 8005b84:	fb03 1100 	mla	r1, r3, r0, r1
 8005b88:	9126      	str	r1, [sp, #152]	; 0x98
 8005b8a:	6c21      	ldr	r1, [r4, #64]	; 0x40
 8005b8c:	9a1b      	ldr	r2, [sp, #108]	; 0x6c
 8005b8e:	9818      	ldr	r0, [sp, #96]	; 0x60
 8005b90:	9112      	str	r1, [sp, #72]	; 0x48
 8005b92:	1a12      	subs	r2, r2, r0
 8005b94:	18ba      	adds	r2, r7, r2
 8005b96:	9920      	ldr	r1, [sp, #128]	; 0x80
 8005b98:	fa12 f085 	uxtah	r0, r2, r5
 8005b9c:	fbb0 f1f1 	udiv	r1, r0, r1
 8005ba0:	1c49      	adds	r1, r1, #1
 8005ba2:	9114      	str	r1, [sp, #80]	; 0x50
 8005ba4:	2000      	movs	r0, #0
 8005ba6:	69b6      	ldr	r6, [r6, #24]
 8005ba8:	6831      	ldr	r1, [r6, #0]
 8005baa:	2500      	movs	r5, #0
 8005bac:	2200      	movs	r2, #0
 8005bae:	11cb      	asrs	r3, r1, #7
 8005bb0:	ea4f 5c61 	mov.w	ip, r1, asr #21
 8005bb4:	1449      	asrs	r1, r1, #17
 8005bb6:	f001 010f 	and.w	r1, r1, #15
 8005bba:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 8005bbe:	f00c 0c03 	and.w	ip, ip, #3
 8005bc2:	2904      	cmp	r1, #4
 8005bc4:	fa23 f30c 	lsr.w	r3, r3, ip
 8005bc8:	bf14      	ite	ne
 8005bca:	2908      	cmpne	r1, #8
 8005bcc:	68f2      	ldreq	r2, [r6, #12]
 8005bce:	b1da      	cbz	r2, 8005c08 <forward_conv2d_nl_pool+0x1d4>
 8005bd0:	6961      	ldr	r1, [r4, #20]
 8005bd2:	f8b1 c000 	ldrh.w	ip, [r1]
 8005bd6:	f1bc 0f04 	cmp.w	ip, #4
 8005bda:	bfa6      	itte	ge
 8005bdc:	6849      	ldrge	r1, [r1, #4]
 8005bde:	3128      	addge	r1, #40	; 0x28
 8005be0:	2104      	movlt	r1, #4
 8005be2:	6809      	ldr	r1, [r1, #0]
 8005be4:	2900      	cmp	r1, #0
 8005be6:	bf1f      	itttt	ne
 8005be8:	6848      	ldrne	r0, [r1, #4]
 8005bea:	2800      	cmpne	r0, #0
 8005bec:	6981      	ldrne	r1, [r0, #24]
 8005bee:	688d      	ldrne	r5, [r1, #8]
 8005bf0:	6980      	ldr	r0, [r0, #24]
 8005bf2:	6841      	ldr	r1, [r0, #4]
 8005bf4:	9823      	ldr	r0, [sp, #140]	; 0x8c
 8005bf6:	9101      	str	r1, [sp, #4]
 8005bf8:	9000      	str	r0, [sp, #0]
 8005bfa:	4628      	mov	r0, r5
 8005bfc:	68b1      	ldr	r1, [r6, #8]
 8005bfe:	f7ff fd61 	bl	80056c4 <ai_dict_decompress_f32>
 8005c02:	b10d      	cbz	r5, 8005c08 <forward_conv2d_nl_pool+0x1d4>
 8005c04:	4628      	mov	r0, r5
 8005c06:	e000      	b.n	8005c0a <forward_conv2d_nl_pool+0x1d6>
 8005c08:	4658      	mov	r0, fp
 8005c0a:	6963      	ldr	r3, [r4, #20]
 8005c0c:	f8dd c040 	ldr.w	ip, [sp, #64]	; 0x40
 8005c10:	881c      	ldrh	r4, [r3, #0]
 8005c12:	f8d9 1018 	ldr.w	r1, [r9, #24]
 8005c16:	2600      	movs	r6, #0
 8005c18:	2c04      	cmp	r4, #4
 8005c1a:	bfa6      	itte	ge
 8005c1c:	685b      	ldrge	r3, [r3, #4]
 8005c1e:	3328      	addge	r3, #40	; 0x28
 8005c20:	2304      	movlt	r3, #4
 8005c22:	f10d 0e44 	add.w	lr, sp, #68	; 0x44
 8005c26:	681b      	ldr	r3, [r3, #0]
 8005c28:	2b00      	cmp	r3, #0
 8005c2a:	bf14      	ite	ne
 8005c2c:	681d      	ldrne	r5, [r3, #0]
 8005c2e:	2500      	moveq	r5, #0
 8005c30:	427f      	negs	r7, r7
 8005c32:	69ac      	ldr	r4, [r5, #24]
 8005c34:	68eb      	ldr	r3, [r5, #12]
 8005c36:	f8d4 b008 	ldr.w	fp, [r4, #8]
 8005c3a:	689b      	ldr	r3, [r3, #8]
 8005c3c:	9c11      	ldr	r4, [sp, #68]	; 0x44
 8005c3e:	435c      	muls	r4, r3
 8005c40:	fb0c f404 	mul.w	r4, ip, r4
 8005c44:	9437      	str	r4, [sp, #220]	; 0xdc
 8005c46:	fa0f f28a 	sxth.w	r2, sl
 8005c4a:	f9be 4000 	ldrsh.w	r4, [lr]
 8005c4e:	f8dd c084 	ldr.w	ip, [sp, #132]	; 0x84
 8005c52:	9436      	str	r4, [sp, #216]	; 0xd8
 8005c54:	f10d 0e48 	add.w	lr, sp, #72	; 0x48
 8005c58:	9c10      	ldr	r4, [sp, #64]	; 0x40
 8005c5a:	fb0c f404 	mul.w	r4, ip, r4
 8005c5e:	9435      	str	r4, [sp, #212]	; 0xd4
 8005c60:	f1c8 0800 	rsb	r8, r8, #0
 8005c64:	f9be 4000 	ldrsh.w	r4, [lr]
 8005c68:	9434      	str	r4, [sp, #208]	; 0xd0
 8005c6a:	4691      	mov	r9, r2
 8005c6c:	9c10      	ldr	r4, [sp, #64]	; 0x40
 8005c6e:	f8cd 80c8 	str.w	r8, [sp, #200]	; 0xc8
 8005c72:	435c      	muls	r4, r3
 8005c74:	9433      	str	r4, [sp, #204]	; 0xcc
 8005c76:	9c22      	ldr	r4, [sp, #136]	; 0x88
 8005c78:	2c00      	cmp	r4, #0
 8005c7a:	f000 812e 	beq.w	8005eda <forward_conv2d_nl_pool+0x4a6>
 8005c7e:	f8dd a008 	ldr.w	sl, [sp, #8]
 8005c82:	9038      	str	r0, [sp, #224]	; 0xe0
 8005c84:	9125      	str	r1, [sp, #148]	; 0x94
 8005c86:	4614      	mov	r4, r2
 8005c88:	962f      	str	r6, [sp, #188]	; 0xbc
 8005c8a:	962e      	str	r6, [sp, #184]	; 0xb8
 8005c8c:	9324      	str	r3, [sp, #144]	; 0x90
 8005c8e:	9717      	str	r7, [sp, #92]	; 0x5c
 8005c90:	9814      	ldr	r0, [sp, #80]	; 0x50
 8005c92:	2800      	cmp	r0, #0
 8005c94:	dd6a      	ble.n	8005d6c <forward_conv2d_nl_pool+0x338>
 8005c96:	9832      	ldr	r0, [sp, #200]	; 0xc8
 8005c98:	991b      	ldr	r1, [sp, #108]	; 0x6c
 8005c9a:	9a17      	ldr	r2, [sp, #92]	; 0x5c
 8005c9c:	9b18      	ldr	r3, [sp, #96]	; 0x60
 8005c9e:	9031      	str	r0, [sp, #196]	; 0xc4
 8005ca0:	9817      	ldr	r0, [sp, #92]	; 0x5c
 8005ca2:	4240      	negs	r0, r0
 8005ca4:	bfd8      	it	le
 8005ca6:	2000      	movle	r0, #0
 8005ca8:	1a89      	subs	r1, r1, r2
 8005caa:	4299      	cmp	r1, r3
 8005cac:	bf3d      	ittte	cc
 8005cae:	9a1b      	ldrcc	r2, [sp, #108]	; 0x6c
 8005cb0:	9917      	ldrcc	r1, [sp, #92]	; 0x5c
 8005cb2:	1a51      	subcc	r1, r2, r1
 8005cb4:	4619      	movcs	r1, r3
 8005cb6:	9009      	str	r0, [sp, #36]	; 0x24
 8005cb8:	910a      	str	r1, [sp, #40]	; 0x28
 8005cba:	982c      	ldr	r0, [sp, #176]	; 0xb0
 8005cbc:	f8bd 104c 	ldrh.w	r1, [sp, #76]	; 0x4c
 8005cc0:	9a1e      	ldr	r2, [sp, #120]	; 0x78
 8005cc2:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
 8005cc4:	9008      	str	r0, [sp, #32]
 8005cc6:	9107      	str	r1, [sp, #28]
 8005cc8:	b212      	sxth	r2, r2
 8005cca:	9819      	ldr	r0, [sp, #100]	; 0x64
 8005ccc:	991a      	ldr	r1, [sp, #104]	; 0x68
 8005cce:	9006      	str	r0, [sp, #24]
 8005cd0:	920f      	str	r2, [sp, #60]	; 0x3c
 8005cd2:	9105      	str	r1, [sp, #20]
 8005cd4:	b21b      	sxth	r3, r3
 8005cd6:	9824      	ldr	r0, [sp, #144]	; 0x90
 8005cd8:	9a26      	ldr	r2, [sp, #152]	; 0x98
 8005cda:	992d      	ldr	r1, [sp, #180]	; 0xb4
 8005cdc:	9004      	str	r0, [sp, #16]
 8005cde:	930e      	str	r3, [sp, #56]	; 0x38
 8005ce0:	920d      	str	r2, [sp, #52]	; 0x34
 8005ce2:	9103      	str	r1, [sp, #12]
 8005ce4:	9810      	ldr	r0, [sp, #64]	; 0x40
 8005ce6:	9b17      	ldr	r3, [sp, #92]	; 0x5c
 8005ce8:	9a31      	ldr	r2, [sp, #196]	; 0xc4
 8005cea:	9923      	ldr	r1, [sp, #140]	; 0x8c
 8005cec:	9002      	str	r0, [sp, #8]
 8005cee:	930c      	str	r3, [sp, #48]	; 0x30
 8005cf0:	920b      	str	r2, [sp, #44]	; 0x2c
 8005cf2:	9101      	str	r1, [sp, #4]
 8005cf4:	4659      	mov	r1, fp
 8005cf6:	981d      	ldr	r0, [sp, #116]	; 0x74
 8005cf8:	9b38      	ldr	r3, [sp, #224]	; 0xe0
 8005cfa:	9a28      	ldr	r2, [sp, #160]	; 0xa0
 8005cfc:	9000      	str	r0, [sp, #0]
 8005cfe:	2000      	movs	r0, #0
 8005d00:	f7ff f846 	bl	8004d90 <ai_conv2d_stripe_f32>
 8005d04:	9824      	ldr	r0, [sp, #144]	; 0x90
 8005d06:	b350      	cbz	r0, 8005d5e <forward_conv2d_nl_pool+0x32a>
 8005d08:	f8cd a008 	str.w	sl, [sp, #8]
 8005d0c:	9e10      	ldr	r6, [sp, #64]	; 0x40
 8005d0e:	9f1c      	ldr	r7, [sp, #112]	; 0x70
 8005d10:	f8dd 80c0 	ldr.w	r8, [sp, #192]	; 0xc0
 8005d14:	4682      	mov	sl, r0
 8005d16:	69a9      	ldr	r1, [r5, #24]
 8005d18:	463b      	mov	r3, r7
 8005d1a:	f8c1 b008 	str.w	fp, [r1, #8]
 8005d1e:	4632      	mov	r2, r6
 8005d20:	4608      	mov	r0, r1
 8005d22:	47c0      	blx	r8
 8005d24:	9816      	ldr	r0, [sp, #88]	; 0x58
 8005d26:	9902      	ldr	r1, [sp, #8]
 8005d28:	4407      	add	r7, r0
 8005d2a:	9815      	ldr	r0, [sp, #84]	; 0x54
 8005d2c:	1a79      	subs	r1, r7, r1
 8005d2e:	4281      	cmp	r1, r0
 8005d30:	69a8      	ldr	r0, [r5, #24]
 8005d32:	6841      	ldr	r1, [r0, #4]
 8005d34:	68c0      	ldr	r0, [r0, #12]
 8005d36:	bfa8      	it	ge
 8005d38:	9f02      	ldrge	r7, [sp, #8]
 8005d3a:	eb0b 0b86 	add.w	fp, fp, r6, lsl #2
 8005d3e:	eb00 0281 	add.w	r2, r0, r1, lsl #2
 8005d42:	4593      	cmp	fp, r2
 8005d44:	d302      	bcc.n	8005d4c <forward_conv2d_nl_pool+0x318>
 8005d46:	0089      	lsls	r1, r1, #2
 8005d48:	4249      	negs	r1, r1
 8005d4a:	448b      	add	fp, r1
 8005d4c:	f1ba 0a01 	subs.w	sl, sl, #1
 8005d50:	d1e1      	bne.n	8005d16 <forward_conv2d_nl_pool+0x2e2>
 8005d52:	f8dd a008 	ldr.w	sl, [sp, #8]
 8005d56:	9610      	str	r6, [sp, #64]	; 0x40
 8005d58:	971c      	str	r7, [sp, #112]	; 0x70
 8005d5a:	f8cd 80c0 	str.w	r8, [sp, #192]	; 0xc0
 8005d5e:	69a8      	ldr	r0, [r5, #24]
 8005d60:	68c1      	ldr	r1, [r0, #12]
 8005d62:	6081      	str	r1, [r0, #8]
 8005d64:	f109 0001 	add.w	r0, r9, #1
 8005d68:	fa0f f980 	sxth.w	r9, r0
 8005d6c:	9814      	ldr	r0, [sp, #80]	; 0x50
 8005d6e:	1e40      	subs	r0, r0, #1
 8005d70:	9014      	str	r0, [sp, #80]	; 0x50
 8005d72:	d56b      	bpl.n	8005e4c <forward_conv2d_nl_pool+0x418>
 8005d74:	9833      	ldr	r0, [sp, #204]	; 0xcc
 8005d76:	fb00 f009 	mul.w	r0, r0, r9
 8005d7a:	0080      	lsls	r0, r0, #2
 8005d7c:	4240      	negs	r0, r0
 8005d7e:	eb0b 0200 	add.w	r2, fp, r0
 8005d82:	69a8      	ldr	r0, [r5, #24]
 8005d84:	68c3      	ldr	r3, [r0, #12]
 8005d86:	429a      	cmp	r2, r3
 8005d88:	bf3c      	itt	cc
 8005d8a:	6847      	ldrcc	r7, [r0, #4]
 8005d8c:	eb02 0287 	addcc.w	r2, r2, r7, lsl #2
 8005d90:	4293      	cmp	r3, r2
 8005d92:	4659      	mov	r1, fp
 8005d94:	d236      	bcs.n	8005e04 <forward_conv2d_nl_pool+0x3d0>
 8005d96:	9e34      	ldr	r6, [sp, #208]	; 0xd0
 8005d98:	45b1      	cmp	r9, r6
 8005d9a:	d033      	beq.n	8005e04 <forward_conv2d_nl_pool+0x3d0>
 8005d9c:	6846      	ldr	r6, [r0, #4]
 8005d9e:	eb03 0386 	add.w	r3, r3, r6, lsl #2
 8005da2:	429a      	cmp	r2, r3
 8005da4:	f080 802e 	bcs.w	8005e04 <forward_conv2d_nl_pool+0x3d0>
 8005da8:	ed92 0a00 	vldr	s0, [r2]
 8005dac:	ed8b 0a00 	vstr	s0, [fp]
 8005db0:	68c3      	ldr	r3, [r0, #12]
 8005db2:	6846      	ldr	r6, [r0, #4]
 8005db4:	1d12      	adds	r2, r2, #4
 8005db6:	eb03 0786 	add.w	r7, r3, r6, lsl #2
 8005dba:	42ba      	cmp	r2, r7
 8005dbc:	d222      	bcs.n	8005e04 <forward_conv2d_nl_pool+0x3d0>
 8005dbe:	edd2 0a00 	vldr	s1, [r2]
 8005dc2:	edcb 0a01 	vstr	s1, [fp, #4]
 8005dc6:	68c3      	ldr	r3, [r0, #12]
 8005dc8:	6846      	ldr	r6, [r0, #4]
 8005dca:	1d12      	adds	r2, r2, #4
 8005dcc:	eb03 0786 	add.w	r7, r3, r6, lsl #2
 8005dd0:	42ba      	cmp	r2, r7
 8005dd2:	d217      	bcs.n	8005e04 <forward_conv2d_nl_pool+0x3d0>
 8005dd4:	ed92 0a00 	vldr	s0, [r2]
 8005dd8:	ed8b 0a02 	vstr	s0, [fp, #8]
 8005ddc:	68c3      	ldr	r3, [r0, #12]
 8005dde:	6846      	ldr	r6, [r0, #4]
 8005de0:	1d12      	adds	r2, r2, #4
 8005de2:	eb03 0786 	add.w	r7, r3, r6, lsl #2
 8005de6:	42ba      	cmp	r2, r7
 8005de8:	d20c      	bcs.n	8005e04 <forward_conv2d_nl_pool+0x3d0>
 8005dea:	edd2 0a00 	vldr	s1, [r2]
 8005dee:	edcb 0a03 	vstr	s1, [fp, #12]
 8005df2:	68c3      	ldr	r3, [r0, #12]
 8005df4:	6846      	ldr	r6, [r0, #4]
 8005df6:	1d12      	adds	r2, r2, #4
 8005df8:	eb03 0786 	add.w	r7, r3, r6, lsl #2
 8005dfc:	42ba      	cmp	r2, r7
 8005dfe:	f10b 0b10 	add.w	fp, fp, #16
 8005e02:	d3d1      	bcc.n	8005da8 <forward_conv2d_nl_pool+0x374>
 8005e04:	9a2f      	ldr	r2, [sp, #188]	; 0xbc
 8005e06:	9b12      	ldr	r3, [sp, #72]	; 0x48
 8005e08:	189a      	adds	r2, r3, r2
 8005e0a:	eba2 0209 	sub.w	r2, r2, r9
 8005e0e:	922f      	str	r2, [sp, #188]	; 0xbc
 8005e10:	9a11      	ldr	r2, [sp, #68]	; 0x44
 8005e12:	9b37      	ldr	r3, [sp, #220]	; 0xdc
 8005e14:	444a      	add	r2, r9
 8005e16:	fa0f f982 	sxth.w	r9, r2
 8005e1a:	eb01 0b83 	add.w	fp, r1, r3, lsl #2
 8005e1e:	68c1      	ldr	r1, [r0, #12]
 8005e20:	6842      	ldr	r2, [r0, #4]
 8005e22:	eb01 0382 	add.w	r3, r1, r2, lsl #2
 8005e26:	459b      	cmp	fp, r3
 8005e28:	460b      	mov	r3, r1
 8005e2a:	d30f      	bcc.n	8005e4c <forward_conv2d_nl_pool+0x418>
 8005e2c:	6841      	ldr	r1, [r0, #4]
 8005e2e:	008a      	lsls	r2, r1, #2
 8005e30:	4252      	negs	r2, r2
 8005e32:	4493      	add	fp, r2
 8005e34:	eb03 0181 	add.w	r1, r3, r1, lsl #2
 8005e38:	458b      	cmp	fp, r1
 8005e3a:	bf24      	itt	cs
 8005e3c:	4493      	addcs	fp, r2
 8005e3e:	458b      	cmpcs	fp, r1
 8005e40:	bf21      	itttt	cs
 8005e42:	4493      	addcs	fp, r2
 8005e44:	458b      	cmpcs	fp, r1
 8005e46:	4493      	addcs	fp, r2
 8005e48:	458b      	cmpcs	fp, r1
 8005e4a:	d2ef      	bcs.n	8005e2c <forward_conv2d_nl_pool+0x3f8>
 8005e4c:	9812      	ldr	r0, [sp, #72]	; 0x48
 8005e4e:	4581      	cmp	r9, r0
 8005e50:	d339      	bcc.n	8005ec6 <forward_conv2d_nl_pool+0x492>
 8005e52:	9911      	ldr	r1, [sp, #68]	; 0x44
 8005e54:	9a21      	ldr	r2, [sp, #132]	; 0x84
 8005e56:	9b10      	ldr	r3, [sp, #64]	; 0x40
 8005e58:	9e27      	ldr	r6, [sp, #156]	; 0x9c
 8005e5a:	eba9 0001 	sub.w	r0, r9, r1
 8005e5e:	fa0f f980 	sxth.w	r9, r0
 8005e62:	982e      	ldr	r0, [sp, #184]	; 0xb8
 8005e64:	1c40      	adds	r0, r0, #1
 8005e66:	902e      	str	r0, [sp, #184]	; 0xb8
 8005e68:	2101      	movs	r1, #1
 8005e6a:	9825      	ldr	r0, [sp, #148]	; 0x94
 8005e6c:	9008      	str	r0, [sp, #32]
 8005e6e:	9107      	str	r1, [sp, #28]
 8005e70:	b292      	uxth	r2, r2
 8005e72:	9811      	ldr	r0, [sp, #68]	; 0x44
 8005e74:	992a      	ldr	r1, [sp, #168]	; 0xa8
 8005e76:	9206      	str	r2, [sp, #24]
 8005e78:	b280      	uxth	r0, r0
 8005e7a:	9005      	str	r0, [sp, #20]
 8005e7c:	b289      	uxth	r1, r1
 8005e7e:	9829      	ldr	r0, [sp, #164]	; 0xa4
 8005e80:	9a12      	ldr	r2, [sp, #72]	; 0x48
 8005e82:	9104      	str	r1, [sp, #16]
 8005e84:	b280      	uxth	r0, r0
 8005e86:	b2a1      	uxth	r1, r4
 8005e88:	9002      	str	r0, [sp, #8]
 8005e8a:	9103      	str	r1, [sp, #12]
 8005e8c:	b29b      	uxth	r3, r3
 8005e8e:	982b      	ldr	r0, [sp, #172]	; 0xac
 8005e90:	9912      	ldr	r1, [sp, #72]	; 0x48
 8005e92:	b280      	uxth	r0, r0
 8005e94:	b289      	uxth	r1, r1
 8005e96:	9000      	str	r0, [sp, #0]
 8005e98:	9101      	str	r1, [sp, #4]
 8005e9a:	982f      	ldr	r0, [sp, #188]	; 0xbc
 8005e9c:	9924      	ldr	r1, [sp, #144]	; 0x90
 8005e9e:	1a12      	subs	r2, r2, r0
 8005ea0:	69a8      	ldr	r0, [r5, #24]
 8005ea2:	b292      	uxth	r2, r2
 8005ea4:	b289      	uxth	r1, r1
 8005ea6:	47b0      	blx	r6
 8005ea8:	9825      	ldr	r0, [sp, #148]	; 0x94
 8005eaa:	6881      	ldr	r1, [r0, #8]
 8005eac:	9835      	ldr	r0, [sp, #212]	; 0xd4
 8005eae:	eb01 0280 	add.w	r2, r1, r0, lsl #2
 8005eb2:	9925      	ldr	r1, [sp, #148]	; 0x94
 8005eb4:	608a      	str	r2, [r1, #8]
 8005eb6:	9836      	ldr	r0, [sp, #216]	; 0xd8
 8005eb8:	1a20      	subs	r0, r4, r0
 8005eba:	2800      	cmp	r0, #0
 8005ebc:	bfc3      	ittte	gt
 8005ebe:	9811      	ldrgt	r0, [sp, #68]	; 0x44
 8005ec0:	1a24      	subgt	r4, r4, r0
 8005ec2:	b224      	sxthgt	r4, r4
 8005ec4:	2400      	movle	r4, #0
 8005ec6:	9817      	ldr	r0, [sp, #92]	; 0x5c
 8005ec8:	9920      	ldr	r1, [sp, #128]	; 0x80
 8005eca:	1808      	adds	r0, r1, r0
 8005ecc:	9017      	str	r0, [sp, #92]	; 0x5c
 8005ece:	9922      	ldr	r1, [sp, #136]	; 0x88
 8005ed0:	982e      	ldr	r0, [sp, #184]	; 0xb8
 8005ed2:	4288      	cmp	r0, r1
 8005ed4:	f4ff aedc 	bcc.w	8005c90 <forward_conv2d_nl_pool+0x25c>
 8005ed8:	9925      	ldr	r1, [sp, #148]	; 0x94
 8005eda:	69a8      	ldr	r0, [r5, #24]
 8005edc:	68c2      	ldr	r2, [r0, #12]
 8005ede:	6082      	str	r2, [r0, #8]
 8005ee0:	68c8      	ldr	r0, [r1, #12]
 8005ee2:	6088      	str	r0, [r1, #8]
 8005ee4:	b039      	add	sp, #228	; 0xe4
 8005ee6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	...

08005eec <forward_dense>:
 8005eec:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8005ef0:	b081      	sub	sp, #4
 8005ef2:	ed2d 8b02 	vpush	{d8}
 8005ef6:	b088      	sub	sp, #32
 8005ef8:	6944      	ldr	r4, [r0, #20]
 8005efa:	8820      	ldrh	r0, [r4, #0]
 8005efc:	2800      	cmp	r0, #0
 8005efe:	bf1a      	itte	ne
 8005f00:	6861      	ldrne	r1, [r4, #4]
 8005f02:	1d09      	addne	r1, r1, #4
 8005f04:	2104      	moveq	r1, #4
 8005f06:	6809      	ldr	r1, [r1, #0]
 8005f08:	2900      	cmp	r1, #0
 8005f0a:	bf14      	ite	ne
 8005f0c:	680a      	ldrne	r2, [r1, #0]
 8005f0e:	2200      	moveq	r2, #0
 8005f10:	2802      	cmp	r0, #2
 8005f12:	bfa6      	itte	ge
 8005f14:	6861      	ldrge	r1, [r4, #4]
 8005f16:	3110      	addge	r1, #16
 8005f18:	2104      	movlt	r1, #4
 8005f1a:	6809      	ldr	r1, [r1, #0]
 8005f1c:	2900      	cmp	r1, #0
 8005f1e:	bf14      	ite	ne
 8005f20:	680f      	ldrne	r7, [r1, #0]
 8005f22:	2700      	moveq	r7, #0
 8005f24:	2802      	cmp	r0, #2
 8005f26:	bfc6      	itte	gt
 8005f28:	6861      	ldrgt	r1, [r4, #4]
 8005f2a:	311c      	addgt	r1, #28
 8005f2c:	2104      	movle	r1, #4
 8005f2e:	6809      	ldr	r1, [r1, #0]
 8005f30:	2900      	cmp	r1, #0
 8005f32:	bf14      	ite	ne
 8005f34:	680b      	ldrne	r3, [r1, #0]
 8005f36:	2300      	moveq	r3, #0
 8005f38:	2802      	cmp	r0, #2
 8005f3a:	dd0b      	ble.n	8005f54 <forward_dense+0x68>
 8005f3c:	6861      	ldr	r1, [r4, #4]
 8005f3e:	f111 0018 	adds.w	r0, r1, #24
 8005f42:	d007      	beq.n	8005f54 <forward_dense+0x68>
 8005f44:	8b08      	ldrh	r0, [r1, #24]
 8005f46:	2802      	cmp	r0, #2
 8005f48:	db04      	blt.n	8005f54 <forward_dense+0x68>
 8005f4a:	69c8      	ldr	r0, [r1, #28]
 8005f4c:	b110      	cbz	r0, 8005f54 <forward_dense+0x68>
 8005f4e:	f8d0 a004 	ldr.w	sl, [r0, #4]
 8005f52:	e001      	b.n	8005f58 <forward_dense+0x6c>
 8005f54:	f04f 0a00 	mov.w	sl, #0
 8005f58:	68d0      	ldr	r0, [r2, #12]
 8005f5a:	6844      	ldr	r4, [r0, #4]
 8005f5c:	68f8      	ldr	r0, [r7, #12]
 8005f5e:	6845      	ldr	r5, [r0, #4]
 8005f60:	6881      	ldr	r1, [r0, #8]
 8005f62:	68c0      	ldr	r0, [r0, #12]
 8005f64:	699e      	ldr	r6, [r3, #24]
 8005f66:	69bf      	ldr	r7, [r7, #24]
 8005f68:	f8d6 e000 	ldr.w	lr, [r6]
 8005f6c:	6992      	ldr	r2, [r2, #24]
 8005f6e:	68bf      	ldr	r7, [r7, #8]
 8005f70:	4341      	muls	r1, r0
 8005f72:	2000      	movs	r0, #0
 8005f74:	ea4f 19ee 	mov.w	r9, lr, asr #7
 8005f78:	ea4f 586e 	mov.w	r8, lr, asr #21
 8005f7c:	ea4f 4e6e 	mov.w	lr, lr, asr #17
 8005f80:	f00e 0e0f 	and.w	lr, lr, #15
 8005f84:	f1be 0f04 	cmp.w	lr, #4
 8005f88:	bf14      	ite	ne
 8005f8a:	f1be 0f08 	cmpne.w	lr, #8
 8005f8e:	68f0      	ldreq	r0, [r6, #12]
 8005f90:	f009 097f 	and.w	r9, r9, #127	; 0x7f
 8005f94:	f008 0803 	and.w	r8, r8, #3
 8005f98:	695e      	ldr	r6, [r3, #20]
 8005f9a:	6876      	ldr	r6, [r6, #4]
 8005f9c:	fa29 f908 	lsr.w	r9, r9, r8
 8005fa0:	f8d2 8008 	ldr.w	r8, [r2, #8]
 8005fa4:	2900      	cmp	r1, #0
 8005fa6:	eb07 0285 	add.w	r2, r7, r5, lsl #2
 8005faa:	f000 80ea 	beq.w	8006182 <forward_dense+0x296>
 8005fae:	9307      	str	r3, [sp, #28]
 8005fb0:	f8cd a014 	str.w	sl, [sp, #20]
 8005fb4:	9506      	str	r5, [sp, #24]
 8005fb6:	9201      	str	r2, [sp, #4]
 8005fb8:	9104      	str	r1, [sp, #16]
 8005fba:	9907      	ldr	r1, [sp, #28]
 8005fbc:	698a      	ldr	r2, [r1, #24]
 8005fbe:	9905      	ldr	r1, [sp, #20]
 8005fc0:	f8d2 b008 	ldr.w	fp, [r2, #8]
 8005fc4:	9b01      	ldr	r3, [sp, #4]
 8005fc6:	2900      	cmp	r1, #0
 8005fc8:	bf1a      	itte	ne
 8005fca:	698a      	ldrne	r2, [r1, #24]
 8005fcc:	6892      	ldrne	r2, [r2, #8]
 8005fce:	2200      	moveq	r2, #0
 8005fd0:	2800      	cmp	r0, #0
 8005fd2:	f040 80ab 	bne.w	800612c <forward_dense+0x240>
 8005fd6:	429f      	cmp	r7, r3
 8005fd8:	f080 80c7 	bcs.w	800616a <forward_dense+0x27e>
 8005fdc:	9003      	str	r0, [sp, #12]
 8005fde:	2a00      	cmp	r2, #0
 8005fe0:	bf0e      	itee	eq
 8005fe2:	ed9f 0a6b 	vldreq	s0, [pc, #428]	; 8006190 <.text_12>
 8005fe6:	ed92 0a00 	vldrne	s0, [r2]
 8005fea:	1d12      	addne	r2, r2, #4
 8005fec:	2c04      	cmp	r4, #4
 8005fee:	4620      	mov	r0, r4
 8005ff0:	46c6      	mov	lr, r8
 8005ff2:	46dc      	mov	ip, fp
 8005ff4:	eddf 0a66 	vldr	s1, [pc, #408]	; 8006190 <.text_12>
 8005ff8:	d35d      	bcc.n	80060b6 <forward_dense+0x1ca>
 8005ffa:	08a1      	lsrs	r1, r4, #2
 8005ffc:	07cd      	lsls	r5, r1, #31
 8005ffe:	d51c      	bpl.n	800603a <forward_dense+0x14e>
 8006000:	ed9c 4a00 	vldr	s8, [ip]
 8006004:	edde 4a00 	vldr	s9, [lr]
 8006008:	ed9c 3a01 	vldr	s6, [ip, #4]
 800600c:	edde 3a01 	vldr	s7, [lr, #4]
 8006010:	ed9c 2a02 	vldr	s4, [ip, #8]
 8006014:	edde 2a02 	vldr	s5, [lr, #8]
 8006018:	ed9c 1a03 	vldr	s2, [ip, #12]
 800601c:	edde 1a03 	vldr	s3, [lr, #12]
 8006020:	ee44 0a24 	vmla.f32	s1, s8, s9
 8006024:	ee43 0a23 	vmla.f32	s1, s6, s7
 8006028:	ee42 0a22 	vmla.f32	s1, s4, s5
 800602c:	ee41 0a21 	vmla.f32	s1, s2, s3
 8006030:	f10e 0e10 	add.w	lr, lr, #16
 8006034:	f10c 0c10 	add.w	ip, ip, #16
 8006038:	1f00      	subs	r0, r0, #4
 800603a:	0849      	lsrs	r1, r1, #1
 800603c:	f000 803b 	beq.w	80060b6 <forward_dense+0x1ca>
 8006040:	edde 4a00 	vldr	s9, [lr]
 8006044:	edde 3a01 	vldr	s7, [lr, #4]
 8006048:	edde 2a02 	vldr	s5, [lr, #8]
 800604c:	edde 1a03 	vldr	s3, [lr, #12]
 8006050:	ed9c 1a03 	vldr	s2, [ip, #12]
 8006054:	ed9c 2a02 	vldr	s4, [ip, #8]
 8006058:	ed9c 3a01 	vldr	s6, [ip, #4]
 800605c:	ed9c 4a00 	vldr	s8, [ip]
 8006060:	ee44 0a24 	vmla.f32	s1, s8, s9
 8006064:	ee43 0a23 	vmla.f32	s1, s6, s7
 8006068:	ee42 0a22 	vmla.f32	s1, s4, s5
 800606c:	ee41 0a21 	vmla.f32	s1, s2, s3
 8006070:	f10e 0510 	add.w	r5, lr, #16
 8006074:	f10c 0c10 	add.w	ip, ip, #16
 8006078:	edd5 8a00 	vldr	s17, [r5]
 800607c:	ed9c 8a00 	vldr	s16, [ip]
 8006080:	ed9c 7a01 	vldr	s14, [ip, #4]
 8006084:	edd5 7a01 	vldr	s15, [r5, #4]
 8006088:	ed9c 6a02 	vldr	s12, [ip, #8]
 800608c:	edd5 6a02 	vldr	s13, [r5, #8]
 8006090:	ed9c 5a03 	vldr	s10, [ip, #12]
 8006094:	edd5 5a03 	vldr	s11, [r5, #12]
 8006098:	ee48 0a28 	vmla.f32	s1, s16, s17
 800609c:	ee47 0a27 	vmla.f32	s1, s14, s15
 80060a0:	3808      	subs	r0, #8
 80060a2:	ee46 0a26 	vmla.f32	s1, s12, s13
 80060a6:	1e49      	subs	r1, r1, #1
 80060a8:	ee45 0a25 	vmla.f32	s1, s10, s11
 80060ac:	f105 0e10 	add.w	lr, r5, #16
 80060b0:	f10c 0c10 	add.w	ip, ip, #16
 80060b4:	d1c4      	bne.n	8006040 <forward_dense+0x154>
 80060b6:	b378      	cbz	r0, 8006118 <forward_dense+0x22c>
 80060b8:	f010 0103 	ands.w	r1, r0, #3
 80060bc:	f000 800c 	beq.w	80060d8 <forward_dense+0x1ec>
 80060c0:	ed9c 1a00 	vldr	s2, [ip]
 80060c4:	edde 1a00 	vldr	s3, [lr]
 80060c8:	1e49      	subs	r1, r1, #1
 80060ca:	ee41 0a21 	vmla.f32	s1, s2, s3
 80060ce:	f10e 0e04 	add.w	lr, lr, #4
 80060d2:	f10c 0c04 	add.w	ip, ip, #4
 80060d6:	d1f3      	bne.n	80060c0 <forward_dense+0x1d4>
 80060d8:	0880      	lsrs	r0, r0, #2
 80060da:	d01d      	beq.n	8006118 <forward_dense+0x22c>
 80060dc:	ed9c 2a00 	vldr	s4, [ip]
 80060e0:	ed9e 1a00 	vldr	s2, [lr]
 80060e4:	eddc 1a01 	vldr	s3, [ip, #4]
 80060e8:	edde 2a01 	vldr	s5, [lr, #4]
 80060ec:	ee42 0a01 	vmla.f32	s1, s4, s2
 80060f0:	ee41 0aa2 	vmla.f32	s1, s3, s5
 80060f4:	ed9c 2a02 	vldr	s4, [ip, #8]
 80060f8:	ed9e 1a02 	vldr	s2, [lr, #8]
 80060fc:	eddc 1a03 	vldr	s3, [ip, #12]
 8006100:	edde 2a03 	vldr	s5, [lr, #12]
 8006104:	ee42 0a01 	vmla.f32	s1, s4, s2
 8006108:	1e40      	subs	r0, r0, #1
 800610a:	ee41 0aa2 	vmla.f32	s1, s3, s5
 800610e:	f10e 0e10 	add.w	lr, lr, #16
 8006112:	f10c 0c10 	add.w	ip, ip, #16
 8006116:	d1e1      	bne.n	80060dc <forward_dense+0x1f0>
 8006118:	ee30 0a20 	vadd.f32	s0, s0, s1
 800611c:	ed87 0a00 	vstr	s0, [r7]
 8006120:	1d3f      	adds	r7, r7, #4
 8006122:	429f      	cmp	r7, r3
 8006124:	44b3      	add	fp, r6
 8006126:	f4ff af5a 	bcc.w	8005fde <forward_dense+0xf2>
 800612a:	e01d      	b.n	8006168 <forward_dense+0x27c>
 800612c:	429f      	cmp	r7, r3
 800612e:	d21c      	bcs.n	800616a <forward_dense+0x27e>
 8006130:	469a      	mov	sl, r3
 8006132:	9003      	str	r0, [sp, #12]
 8006134:	4615      	mov	r5, r2
 8006136:	2d00      	cmp	r5, #0
 8006138:	bf14      	ite	ne
 800613a:	f855 0b04 	ldrne.w	r0, [r5], #4
 800613e:	2000      	moveq	r0, #0
 8006140:	9002      	str	r0, [sp, #8]
 8006142:	f1b9 0f04 	cmp.w	r9, #4
 8006146:	9a03      	ldr	r2, [sp, #12]
 8006148:	9400      	str	r4, [sp, #0]
 800614a:	4643      	mov	r3, r8
 800614c:	4659      	mov	r1, fp
 800614e:	a802      	add	r0, sp, #8
 8006150:	d102      	bne.n	8006158 <forward_dense+0x26c>
 8006152:	f7ff fa67 	bl	8005624 <ai_dict4_dot_array_f32>
 8006156:	e001      	b.n	800615c <forward_dense+0x270>
 8006158:	f7ff f8f4 	bl	8005344 <ai_dict8_dot_array_f32>
 800615c:	9802      	ldr	r0, [sp, #8]
 800615e:	f847 0b04 	str.w	r0, [r7], #4
 8006162:	4557      	cmp	r7, sl
 8006164:	44b3      	add	fp, r6
 8006166:	d3e6      	bcc.n	8006136 <forward_dense+0x24a>
 8006168:	9803      	ldr	r0, [sp, #12]
 800616a:	9901      	ldr	r1, [sp, #4]
 800616c:	9a06      	ldr	r2, [sp, #24]
 800616e:	eb01 0382 	add.w	r3, r1, r2, lsl #2
 8006172:	9904      	ldr	r1, [sp, #16]
 8006174:	9301      	str	r3, [sp, #4]
 8006176:	1e49      	subs	r1, r1, #1
 8006178:	eb08 0884 	add.w	r8, r8, r4, lsl #2
 800617c:	9104      	str	r1, [sp, #16]
 800617e:	f47f af1c 	bne.w	8005fba <forward_dense+0xce>
 8006182:	b008      	add	sp, #32
 8006184:	ecbd 8b02 	vpop	{d8}
 8006188:	b001      	add	sp, #4
 800618a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	...

08006190 <.text_12>:
 8006190:	00000000 	.word	0x00000000

08006194 <forward_gemm>:
 8006194:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8006198:	4604      	mov	r4, r0
 800619a:	b091      	sub	sp, #68	; 0x44
 800619c:	6961      	ldr	r1, [r4, #20]
 800619e:	8808      	ldrh	r0, [r1, #0]
 80061a0:	2800      	cmp	r0, #0
 80061a2:	bf1a      	itte	ne
 80061a4:	6848      	ldrne	r0, [r1, #4]
 80061a6:	1d02      	addne	r2, r0, #4
 80061a8:	2204      	moveq	r2, #4
 80061aa:	460b      	mov	r3, r1
 80061ac:	6810      	ldr	r0, [r2, #0]
 80061ae:	8819      	ldrh	r1, [r3, #0]
 80061b0:	2800      	cmp	r0, #0
 80061b2:	bf14      	ite	ne
 80061b4:	6805      	ldrne	r5, [r0, #0]
 80061b6:	2500      	moveq	r5, #0
 80061b8:	2900      	cmp	r1, #0
 80061ba:	bf1d      	ittte	ne
 80061bc:	6858      	ldrne	r0, [r3, #4]
 80061be:	2800      	cmpne	r0, #0
 80061c0:	f8b0 c000 	ldrhne.w	ip, [r0]
 80061c4:	f04f 0c00 	moveq.w	ip, #0
 80061c8:	2902      	cmp	r1, #2
 80061ca:	bfa6      	itte	ge
 80061cc:	6858      	ldrge	r0, [r3, #4]
 80061ce:	3010      	addge	r0, #16
 80061d0:	2004      	movlt	r0, #4
 80061d2:	6800      	ldr	r0, [r0, #0]
 80061d4:	2800      	cmp	r0, #0
 80061d6:	bf14      	ite	ne
 80061d8:	6801      	ldrne	r1, [r0, #0]
 80061da:	2100      	moveq	r1, #0
 80061dc:	2600      	movs	r6, #0
 80061de:	f1bc 0f03 	cmp.w	ip, #3
 80061e2:	46b2      	mov	sl, r6
 80061e4:	d107      	bne.n	80061f6 <forward_gemm+0x62>
 80061e6:	6810      	ldr	r0, [r2, #0]
 80061e8:	2800      	cmp	r0, #0
 80061ea:	d026      	beq.n	800623a <forward_gemm+0xa6>
 80061ec:	6846      	ldr	r6, [r0, #4]
 80061ee:	d024      	beq.n	800623a <forward_gemm+0xa6>
 80061f0:	f8d0 a008 	ldr.w	sl, [r0, #8]
 80061f4:	e021      	b.n	800623a <forward_gemm+0xa6>
 80061f6:	f1bc 0f02 	cmp.w	ip, #2
 80061fa:	d10d      	bne.n	8006218 <forward_gemm+0x84>
 80061fc:	6810      	ldr	r0, [r2, #0]
 80061fe:	b100      	cbz	r0, 8006202 <forward_gemm+0x6e>
 8006200:	6846      	ldr	r6, [r0, #4]
 8006202:	881a      	ldrh	r2, [r3, #0]
 8006204:	2a02      	cmp	r2, #2
 8006206:	bfc6      	itte	gt
 8006208:	6858      	ldrgt	r0, [r3, #4]
 800620a:	301c      	addgt	r0, #28
 800620c:	2004      	movle	r0, #4
 800620e:	6800      	ldr	r0, [r0, #0]
 8006210:	b198      	cbz	r0, 800623a <forward_gemm+0xa6>
 8006212:	f8d0 a000 	ldr.w	sl, [r0]
 8006216:	e010      	b.n	800623a <forward_gemm+0xa6>
 8006218:	f1bc 0f01 	cmp.w	ip, #1
 800621c:	d10d      	bne.n	800623a <forward_gemm+0xa6>
 800621e:	881a      	ldrh	r2, [r3, #0]
 8006220:	2a02      	cmp	r2, #2
 8006222:	bfc6      	itte	gt
 8006224:	6858      	ldrgt	r0, [r3, #4]
 8006226:	f100 021c 	addgt.w	r2, r0, #28
 800622a:	2204      	movle	r2, #4
 800622c:	6810      	ldr	r0, [r2, #0]
 800622e:	2800      	cmp	r0, #0
 8006230:	d003      	beq.n	800623a <forward_gemm+0xa6>
 8006232:	6806      	ldr	r6, [r0, #0]
 8006234:	bf18      	it	ne
 8006236:	f8d0 a004 	ldrne.w	sl, [r0, #4]
 800623a:	68c8      	ldr	r0, [r1, #12]
 800623c:	6989      	ldr	r1, [r1, #24]
 800623e:	688b      	ldr	r3, [r1, #8]
 8006240:	6842      	ldr	r2, [r0, #4]
 8006242:	68c1      	ldr	r1, [r0, #12]
 8006244:	b292      	uxth	r2, r2
 8006246:	b289      	uxth	r1, r1
 8006248:	a806      	add	r0, sp, #24
 800624a:	f020 fb71 	bl	8026930 <arm_mat_init_f32>
 800624e:	69a9      	ldr	r1, [r5, #24]
 8006250:	68e8      	ldr	r0, [r5, #12]
 8006252:	688b      	ldr	r3, [r1, #8]
 8006254:	6842      	ldr	r2, [r0, #4]
 8006256:	68c1      	ldr	r1, [r0, #12]
 8006258:	b292      	uxth	r2, r2
 800625a:	b289      	uxth	r1, r1
 800625c:	a804      	add	r0, sp, #16
 800625e:	f020 fb67 	bl	8026930 <arm_mat_init_f32>
 8006262:	69b1      	ldr	r1, [r6, #24]
 8006264:	68f0      	ldr	r0, [r6, #12]
 8006266:	688b      	ldr	r3, [r1, #8]
 8006268:	6842      	ldr	r2, [r0, #4]
 800626a:	68c1      	ldr	r1, [r0, #12]
 800626c:	b292      	uxth	r2, r2
 800626e:	b289      	uxth	r1, r1
 8006270:	a802      	add	r0, sp, #8
 8006272:	f020 fb5d 	bl	8026930 <arm_mat_init_f32>
 8006276:	f8da 1018 	ldr.w	r1, [sl, #24]
 800627a:	f8da 000c 	ldr.w	r0, [sl, #12]
 800627e:	688b      	ldr	r3, [r1, #8]
 8006280:	6842      	ldr	r2, [r0, #4]
 8006282:	68c1      	ldr	r1, [r0, #12]
 8006284:	b292      	uxth	r2, r2
 8006286:	b289      	uxth	r1, r1
 8006288:	4668      	mov	r0, sp
 800628a:	f020 fb51 	bl	8026930 <arm_mat_init_f32>
 800628e:	f994 5021 	ldrsb.w	r5, [r4, #33]	; 0x21
 8006292:	f994 0020 	ldrsb.w	r0, [r4, #32]
 8006296:	9905      	ldr	r1, [sp, #20]
 8006298:	9a03      	ldr	r2, [sp, #12]
 800629a:	ed94 0a07 	vldr	s0, [r4, #28]
 800629e:	edd4 0a06 	vldr	s1, [r4, #24]
 80062a2:	910b      	str	r1, [sp, #44]	; 0x2c
 80062a4:	920e      	str	r2, [sp, #56]	; 0x38
 80062a6:	920d      	str	r2, [sp, #52]	; 0x34
 80062a8:	2300      	movs	r3, #0
 80062aa:	f8bd e010 	ldrh.w	lr, [sp, #16]
 80062ae:	f8bd 8012 	ldrh.w	r8, [sp, #18]
 80062b2:	9901      	ldr	r1, [sp, #4]
 80062b4:	f8bd 7002 	ldrh.w	r7, [sp, #2]
 80062b8:	f8bd c000 	ldrh.w	ip, [sp]
 80062bc:	9c07      	ldr	r4, [sp, #28]
 80062be:	f8bd a008 	ldrh.w	sl, [sp, #8]
 80062c2:	f8bd 6018 	ldrh.w	r6, [sp, #24]
 80062c6:	f8bd b01a 	ldrh.w	fp, [sp, #26]
 80062ca:	9108      	str	r1, [sp, #32]
 80062cc:	0002      	movs	r2, r0
 80062ce:	bf0c      	ite	eq
 80062d0:	4672      	moveq	r2, lr
 80062d2:	4642      	movne	r2, r8
 80062d4:	2f01      	cmp	r7, #1
 80062d6:	bf0c      	ite	eq
 80062d8:	4699      	moveq	r9, r3
 80062da:	f04f 0904 	movne.w	r9, #4
 80062de:	f8bd 100a 	ldrh.w	r1, [sp, #10]
 80062e2:	f1bc 0f01 	cmp.w	ip, #1
 80062e6:	d104      	bne.n	80062f2 <forward_gemm+0x15e>
 80062e8:	2f01      	cmp	r7, #1
 80062ea:	d004      	beq.n	80062f6 <forward_gemm+0x162>
 80062ec:	f1cb 0700 	rsb	r7, fp, #0
 80062f0:	e002      	b.n	80062f8 <forward_gemm+0x164>
 80062f2:	2f01      	cmp	r7, #1
 80062f4:	d000      	beq.n	80062f8 <forward_gemm+0x164>
 80062f6:	2700      	movs	r7, #0
 80062f8:	2800      	cmp	r0, #0
 80062fa:	bf0c      	ite	eq
 80062fc:	46f4      	moveq	ip, lr
 80062fe:	46c4      	movne	ip, r8
 8006300:	b23f      	sxth	r7, r7
 8006302:	45b4      	cmp	ip, r6
 8006304:	970c      	str	r7, [sp, #48]	; 0x30
 8006306:	f040 808b 	bne.w	8006420 <forward_gemm+0x28c>
 800630a:	2d00      	cmp	r5, #0
 800630c:	bf0c      	ite	eq
 800630e:	9109      	streq	r1, [sp, #36]	; 0x24
 8006310:	f8cd a024 	strne.w	sl, [sp, #36]	; 0x24
 8006314:	9f09      	ldr	r7, [sp, #36]	; 0x24
 8006316:	455f      	cmp	r7, fp
 8006318:	f040 8082 	bne.w	8006420 <forward_gemm+0x28c>
 800631c:	2800      	cmp	r0, #0
 800631e:	bf0c      	ite	eq
 8006320:	46c4      	moveq	ip, r8
 8006322:	46f4      	movne	ip, lr
 8006324:	2d00      	cmp	r5, #0
 8006326:	bf0c      	ite	eq
 8006328:	4657      	moveq	r7, sl
 800632a:	460f      	movne	r7, r1
 800632c:	45bc      	cmp	ip, r7
 800632e:	d177      	bne.n	8006420 <forward_gemm+0x28c>
 8006330:	9e08      	ldr	r6, [sp, #32]
 8006332:	f8dd c02c 	ldr.w	ip, [sp, #44]	; 0x2c
 8006336:	9410      	str	r4, [sp, #64]	; 0x40
 8006338:	f8ad 3022 	strh.w	r3, [sp, #34]	; 0x22
 800633c:	f8ad 2020 	strh.w	r2, [sp, #32]
 8006340:	9a10      	ldr	r2, [sp, #64]	; 0x40
 8006342:	f8bd 3022 	ldrh.w	r3, [sp, #34]	; 0x22
 8006346:	f8cd c02c 	str.w	ip, [sp, #44]	; 0x2c
 800634a:	eb02 0783 	add.w	r7, r2, r3, lsl #2
 800634e:	9a09      	ldr	r2, [sp, #36]	; 0x24
 8006350:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 8006352:	f8dd c034 	ldr.w	ip, [sp, #52]	; 0x34
 8006356:	f8ad e028 	strh.w	lr, [sp, #40]	; 0x28
 800635a:	ea4f 0488 	mov.w	r4, r8, lsl #2
 800635e:	f8cd 803c 	str.w	r8, [sp, #60]	; 0x3c
 8006362:	2800      	cmp	r0, #0
 8006364:	bf0c      	ite	eq
 8006366:	f8dd 803c 	ldreq.w	r8, [sp, #60]	; 0x3c
 800636a:	f8bd 8028 	ldrhne.w	r8, [sp, #40]	; 0x28
 800636e:	fa1f fb88 	uxth.w	fp, r8
 8006372:	f8dd e02c 	ldr.w	lr, [sp, #44]	; 0x2c
 8006376:	f1bb 0f00 	cmp.w	fp, #0
 800637a:	ed9f 1a9a 	vldr	s2, [pc, #616]	; 80065e4 <.text_16>
 800637e:	d019      	beq.n	80063b4 <forward_gemm+0x220>
 8006380:	2800      	cmp	r0, #0
 8006382:	bf0c      	ite	eq
 8006384:	f04f 0b04 	moveq.w	fp, #4
 8006388:	46a3      	movne	fp, r4
 800638a:	2d00      	cmp	r5, #0
 800638c:	f1a8 0801 	sub.w	r8, r8, #1
 8006390:	edde 1a00 	vldr	s3, [lr]
 8006394:	ed93 2a00 	vldr	s4, [r3]
 8006398:	44de      	add	lr, fp
 800639a:	bf0c      	ite	eq
 800639c:	ea4f 0b81 	moveq.w	fp, r1, lsl #2
 80063a0:	f04f 0b04 	movne.w	fp, #4
 80063a4:	445b      	add	r3, fp
 80063a6:	fa1f fb88 	uxth.w	fp, r8
 80063aa:	f1bb 0f00 	cmp.w	fp, #0
 80063ae:	ee01 1a82 	vmla.f32	s2, s3, s4
 80063b2:	d1e5      	bne.n	8006380 <forward_gemm+0x1ec>
 80063b4:	ee20 1a81 	vmul.f32	s2, s1, s2
 80063b8:	edd6 1a00 	vldr	s3, [r6]
 80063bc:	ee00 1a21 	vmla.f32	s2, s0, s3
 80063c0:	ed87 1a00 	vstr	s2, [r7]
 80063c4:	1d3f      	adds	r7, r7, #4
 80063c6:	1e52      	subs	r2, r2, #1
 80063c8:	b292      	uxth	r2, r2
 80063ca:	002b      	movs	r3, r5
 80063cc:	bf0e      	itee	eq
 80063ce:	1a8b      	subeq	r3, r1, r2
 80063d0:	ebaa 0302 	subne.w	r3, sl, r2
 80063d4:	434b      	mulne	r3, r1
 80063d6:	2a00      	cmp	r2, #0
 80063d8:	444e      	add	r6, r9
 80063da:	eb0c 0383 	add.w	r3, ip, r3, lsl #2
 80063de:	d1c0      	bne.n	8006362 <forward_gemm+0x1ce>
 80063e0:	f8bd 7022 	ldrh.w	r7, [sp, #34]	; 0x22
 80063e4:	9b09      	ldr	r3, [sp, #36]	; 0x24
 80063e6:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 80063e8:	f8bd e028 	ldrh.w	lr, [sp, #40]	; 0x28
 80063ec:	f8dd 803c 	ldr.w	r8, [sp, #60]	; 0x3c
 80063f0:	f8cd c034 	str.w	ip, [sp, #52]	; 0x34
 80063f4:	19df      	adds	r7, r3, r7
 80063f6:	f8ad 7022 	strh.w	r7, [sp, #34]	; 0x22
 80063fa:	b100      	cbz	r0, 80063fe <forward_gemm+0x26a>
 80063fc:	2404      	movs	r4, #4
 80063fe:	eb02 0c04 	add.w	ip, r2, r4
 8006402:	f8bd 4020 	ldrh.w	r4, [sp, #32]
 8006406:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 8006408:	1e67      	subs	r7, r4, #1
 800640a:	eb06 0682 	add.w	r6, r6, r2, lsl #2
 800640e:	f8ad 7020 	strh.w	r7, [sp, #32]
 8006412:	f8bd 2020 	ldrh.w	r2, [sp, #32]
 8006416:	2a00      	cmp	r2, #0
 8006418:	d192      	bne.n	8006340 <forward_gemm+0x1ac>
 800641a:	b011      	add	sp, #68	; 0x44
 800641c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8006420:	fb0b f606 	mul.w	r6, fp, r6
 8006424:	2e00      	cmp	r6, #0
 8006426:	ddf8      	ble.n	800641a <forward_gemm+0x286>
 8006428:	f016 0003 	ands.w	r0, r6, #3
 800642c:	d003      	beq.n	8006436 <forward_gemm+0x2a2>
 800642e:	1e40      	subs	r0, r0, #1
 8006430:	f844 3b04 	str.w	r3, [r4], #4
 8006434:	d1fb      	bne.n	800642e <forward_gemm+0x29a>
 8006436:	08b1      	lsrs	r1, r6, #2
 8006438:	d0ef      	beq.n	800641a <forward_gemm+0x286>
 800643a:	6023      	str	r3, [r4, #0]
 800643c:	6063      	str	r3, [r4, #4]
 800643e:	60a3      	str	r3, [r4, #8]
 8006440:	60e3      	str	r3, [r4, #12]
 8006442:	3410      	adds	r4, #16
 8006444:	1e49      	subs	r1, r1, #1
 8006446:	d1f8      	bne.n	800643a <forward_gemm+0x2a6>
 8006448:	b011      	add	sp, #68	; 0x44
 800644a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	...

08006450 <forward_matmul>:
 8006450:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8006454:	b08b      	sub	sp, #44	; 0x2c
 8006456:	6944      	ldr	r4, [r0, #20]
 8006458:	8822      	ldrh	r2, [r4, #0]
 800645a:	2a00      	cmp	r2, #0
 800645c:	bf1a      	itte	ne
 800645e:	6860      	ldrne	r0, [r4, #4]
 8006460:	1d03      	addne	r3, r0, #4
 8006462:	2304      	moveq	r3, #4
 8006464:	6819      	ldr	r1, [r3, #0]
 8006466:	2900      	cmp	r1, #0
 8006468:	bf14      	ite	ne
 800646a:	6808      	ldrne	r0, [r1, #0]
 800646c:	2000      	moveq	r0, #0
 800646e:	2900      	cmp	r1, #0
 8006470:	bf14      	ite	ne
 8006472:	f8d1 b004 	ldrne.w	fp, [r1, #4]
 8006476:	f04f 0b00 	moveq.w	fp, #0
 800647a:	2a02      	cmp	r2, #2
 800647c:	bfa6      	itte	ge
 800647e:	6861      	ldrge	r1, [r4, #4]
 8006480:	3110      	addge	r1, #16
 8006482:	2104      	movlt	r1, #4
 8006484:	6809      	ldr	r1, [r1, #0]
 8006486:	2900      	cmp	r1, #0
 8006488:	bf14      	ite	ne
 800648a:	680b      	ldrne	r3, [r1, #0]
 800648c:	2300      	moveq	r3, #0
 800648e:	f1bb 0f00 	cmp.w	fp, #0
 8006492:	d108      	bne.n	80064a6 <forward_matmul+0x56>
 8006494:	2a02      	cmp	r2, #2
 8006496:	bfc6      	itte	gt
 8006498:	6861      	ldrgt	r1, [r4, #4]
 800649a:	311c      	addgt	r1, #28
 800649c:	2104      	movle	r1, #4
 800649e:	6809      	ldr	r1, [r1, #0]
 80064a0:	b109      	cbz	r1, 80064a6 <forward_matmul+0x56>
 80064a2:	f8d1 b000 	ldr.w	fp, [r1]
 80064a6:	68dd      	ldr	r5, [r3, #12]
 80064a8:	68c4      	ldr	r4, [r0, #12]
 80064aa:	f8db 900c 	ldr.w	r9, [fp, #12]
 80064ae:	686e      	ldr	r6, [r5, #4]
 80064b0:	f8d4 e000 	ldr.w	lr, [r4]
 80064b4:	f8d9 2000 	ldr.w	r2, [r9]
 80064b8:	f8d5 a000 	ldr.w	sl, [r5]
 80064bc:	68a1      	ldr	r1, [r4, #8]
 80064be:	f8d9 8008 	ldr.w	r8, [r9, #8]
 80064c2:	f8d5 c008 	ldr.w	ip, [r5, #8]
 80064c6:	68ef      	ldr	r7, [r5, #12]
 80064c8:	9706      	str	r7, [sp, #24]
 80064ca:	fb01 f50e 	mul.w	r5, r1, lr
 80064ce:	699b      	ldr	r3, [r3, #24]
 80064d0:	68e7      	ldr	r7, [r4, #12]
 80064d2:	689b      	ldr	r3, [r3, #8]
 80064d4:	434f      	muls	r7, r1
 80064d6:	fb0e f707 	mul.w	r7, lr, r7
 80064da:	970a      	str	r7, [sp, #40]	; 0x28
 80064dc:	f8d9 400c 	ldr.w	r4, [r9, #12]
 80064e0:	fb08 f404 	mul.w	r4, r8, r4
 80064e4:	4354      	muls	r4, r2
 80064e6:	2e00      	cmp	r6, #0
 80064e8:	9409      	str	r4, [sp, #36]	; 0x24
 80064ea:	fb08 f802 	mul.w	r8, r8, r2
 80064ee:	d074      	beq.n	80065da <forward_matmul+0x18a>
 80064f0:	2400      	movs	r4, #0
 80064f2:	46a1      	mov	r9, r4
 80064f4:	9602      	str	r6, [sp, #8]
 80064f6:	9e06      	ldr	r6, [sp, #24]
 80064f8:	2e00      	cmp	r6, #0
 80064fa:	d064      	beq.n	80065c6 <forward_matmul+0x176>
 80064fc:	9f06      	ldr	r7, [sp, #24]
 80064fe:	9701      	str	r7, [sp, #4]
 8006500:	f8cd c00c 	str.w	ip, [sp, #12]
 8006504:	2600      	movs	r6, #0
 8006506:	9505      	str	r5, [sp, #20]
 8006508:	9d03      	ldr	r5, [sp, #12]
 800650a:	2d00      	cmp	r5, #0
 800650c:	d051      	beq.n	80065b2 <forward_matmul+0x162>
 800650e:	9500      	str	r5, [sp, #0]
 8006510:	f8cd a010 	str.w	sl, [sp, #16]
 8006514:	9207      	str	r2, [sp, #28]
 8006516:	f04f 0a00 	mov.w	sl, #0
 800651a:	9a04      	ldr	r2, [sp, #16]
 800651c:	2a00      	cmp	r2, #0
 800651e:	d03f      	beq.n	80065a0 <forward_matmul+0x150>
 8006520:	f04f 0c00 	mov.w	ip, #0
 8006524:	9008      	str	r0, [sp, #32]
 8006526:	9808      	ldr	r0, [sp, #32]
 8006528:	6985      	ldr	r5, [r0, #24]
 800652a:	68a8      	ldr	r0, [r5, #8]
 800652c:	f8db 7018 	ldr.w	r7, [fp, #24]
 8006530:	4420      	add	r0, r4
 8006532:	4430      	add	r0, r6
 8006534:	eb00 050c 	add.w	r5, r0, ip
 8006538:	68b8      	ldr	r0, [r7, #8]
 800653a:	4448      	add	r0, r9
 800653c:	4450      	add	r0, sl
 800653e:	eb00 070c 	add.w	r7, r0, ip
 8006542:	ed9f 0a28 	vldr	s0, [pc, #160]	; 80065e4 <.text_16>
 8006546:	b319      	cbz	r1, 8006590 <forward_matmul+0x140>
 8006548:	07c8      	lsls	r0, r1, #31
 800654a:	d509      	bpl.n	8006560 <forward_matmul+0x110>
 800654c:	edd5 0a00 	vldr	s1, [r5]
 8006550:	ed97 1a00 	vldr	s2, [r7]
 8006554:	ee00 0a81 	vmla.f32	s0, s1, s2
 8006558:	eb05 058e 	add.w	r5, r5, lr, lsl #2
 800655c:	eb07 0788 	add.w	r7, r7, r8, lsl #2
 8006560:	0848      	lsrs	r0, r1, #1
 8006562:	d015      	beq.n	8006590 <forward_matmul+0x140>
 8006564:	edd5 0a00 	vldr	s1, [r5]
 8006568:	ed97 1a00 	vldr	s2, [r7]
 800656c:	eb05 058e 	add.w	r5, r5, lr, lsl #2
 8006570:	eb07 0788 	add.w	r7, r7, r8, lsl #2
 8006574:	ee00 0a81 	vmla.f32	s0, s1, s2
 8006578:	edd5 0a00 	vldr	s1, [r5]
 800657c:	ed97 1a00 	vldr	s2, [r7]
 8006580:	1e40      	subs	r0, r0, #1
 8006582:	ee00 0a81 	vmla.f32	s0, s1, s2
 8006586:	eb05 058e 	add.w	r5, r5, lr, lsl #2
 800658a:	eb07 0788 	add.w	r7, r7, r8, lsl #2
 800658e:	d1e9      	bne.n	8006564 <forward_matmul+0x114>
 8006590:	ed83 0a00 	vstr	s0, [r3]
 8006594:	1d1b      	adds	r3, r3, #4
 8006596:	1e52      	subs	r2, r2, #1
 8006598:	f10c 0c04 	add.w	ip, ip, #4
 800659c:	d1c3      	bne.n	8006526 <forward_matmul+0xd6>
 800659e:	9808      	ldr	r0, [sp, #32]
 80065a0:	9d00      	ldr	r5, [sp, #0]
 80065a2:	9a07      	ldr	r2, [sp, #28]
 80065a4:	1e6d      	subs	r5, r5, #1
 80065a6:	eb0a 0a82 	add.w	sl, sl, r2, lsl #2
 80065aa:	9500      	str	r5, [sp, #0]
 80065ac:	d1b5      	bne.n	800651a <forward_matmul+0xca>
 80065ae:	f8dd a010 	ldr.w	sl, [sp, #16]
 80065b2:	9f01      	ldr	r7, [sp, #4]
 80065b4:	9d05      	ldr	r5, [sp, #20]
 80065b6:	1e7f      	subs	r7, r7, #1
 80065b8:	eb06 0685 	add.w	r6, r6, r5, lsl #2
 80065bc:	9701      	str	r7, [sp, #4]
 80065be:	d1a3      	bne.n	8006508 <forward_matmul+0xb8>
 80065c0:	f8dd c00c 	ldr.w	ip, [sp, #12]
 80065c4:	9d05      	ldr	r5, [sp, #20]
 80065c6:	9e09      	ldr	r6, [sp, #36]	; 0x24
 80065c8:	9f0a      	ldr	r7, [sp, #40]	; 0x28
 80065ca:	eb09 0986 	add.w	r9, r9, r6, lsl #2
 80065ce:	9e02      	ldr	r6, [sp, #8]
 80065d0:	1e76      	subs	r6, r6, #1
 80065d2:	eb04 0487 	add.w	r4, r4, r7, lsl #2
 80065d6:	9602      	str	r6, [sp, #8]
 80065d8:	d18d      	bne.n	80064f6 <forward_matmul+0xa6>
 80065da:	b00b      	add	sp, #44	; 0x2c
 80065dc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

080065e0 <.text_15>:
 80065e0:	08005341 	.word	0x08005341

080065e4 <.text_16>:
 80065e4:	00000000 	.word	0x00000000

080065e8 <ai_shape_get_size>:
 80065e8:	b470      	push	{r4, r5, r6}
 80065ea:	4601      	mov	r1, r0
 80065ec:	f04f 0201 	mov.w	r2, #1
 80065f0:	680b      	ldr	r3, [r1, #0]
 80065f2:	0a1b      	lsrs	r3, r3, #8
 80065f4:	d01e      	beq.n	8006634 <ai_shape_get_size+0x4c>
 80065f6:	684c      	ldr	r4, [r1, #4]
 80065f8:	eb04 0183 	add.w	r1, r4, r3, lsl #2
 80065fc:	4618      	mov	r0, r3
 80065fe:	1f0d      	subs	r5, r1, #4
 8006600:	f010 0103 	ands.w	r1, r0, #3
 8006604:	f000 8006 	beq.w	8006614 <ai_shape_get_size+0x2c>
 8006608:	f855 6904 	ldr.w	r6, [r5], #-4
 800660c:	1e5b      	subs	r3, r3, #1
 800660e:	4372      	muls	r2, r6
 8006610:	1e49      	subs	r1, r1, #1
 8006612:	d1f9      	bne.n	8006608 <ai_shape_get_size+0x20>
 8006614:	0880      	lsrs	r0, r0, #2
 8006616:	d00d      	beq.n	8006634 <ai_shape_get_size+0x4c>
 8006618:	eb04 0183 	add.w	r1, r4, r3, lsl #2
 800661c:	3910      	subs	r1, #16
 800661e:	68cb      	ldr	r3, [r1, #12]
 8006620:	688c      	ldr	r4, [r1, #8]
 8006622:	684d      	ldr	r5, [r1, #4]
 8006624:	f851 6910 	ldr.w	r6, [r1], #-16
 8006628:	4363      	muls	r3, r4
 800662a:	436b      	muls	r3, r5
 800662c:	4373      	muls	r3, r6
 800662e:	435a      	muls	r2, r3
 8006630:	1e40      	subs	r0, r0, #1
 8006632:	d1f4      	bne.n	800661e <ai_shape_get_size+0x36>
 8006634:	bc70      	pop	{r4, r5, r6}
 8006636:	4610      	mov	r0, r2
 8006638:	4770      	bx	lr
	...

0800663c <nl_func_acos_array_f32>:
 800663c:	b570      	push	{r4, r5, r6, lr}
 800663e:	688c      	ldr	r4, [r1, #8]
 8006640:	6880      	ldr	r0, [r0, #8]
 8006642:	eb04 0182 	add.w	r1, r4, r2, lsl #2
 8006646:	1f0d      	subs	r5, r1, #4
 8006648:	eb00 0182 	add.w	r1, r0, r2, lsl #2
 800664c:	1f0e      	subs	r6, r1, #4
 800664e:	42a5      	cmp	r5, r4
 8006650:	f0c0 800a 	bcc.w	8006668 <nl_func_acos_array_f32+0x2c>
 8006654:	ed95 0a00 	vldr	s0, [r5]
 8006658:	f024 fc40 	bl	802aedc <acosf>
 800665c:	ed86 0a00 	vstr	s0, [r6]
 8006660:	1f2d      	subs	r5, r5, #4
 8006662:	1f36      	subs	r6, r6, #4
 8006664:	42a5      	cmp	r5, r4
 8006666:	d2f5      	bcs.n	8006654 <nl_func_acos_array_f32+0x18>
 8006668:	bd70      	pop	{r4, r5, r6, pc}
	...

0800666c <forward_acos>:
 800666c:	b5f0      	push	{r4, r5, r6, r7, lr}
 800666e:	b081      	sub	sp, #4
 8006670:	6942      	ldr	r2, [r0, #20]
 8006672:	8811      	ldrh	r1, [r2, #0]
 8006674:	2900      	cmp	r1, #0
 8006676:	bf1a      	itte	ne
 8006678:	6850      	ldrne	r0, [r2, #4]
 800667a:	1d00      	addne	r0, r0, #4
 800667c:	2004      	moveq	r0, #4
 800667e:	f04f 0501 	mov.w	r5, #1
 8006682:	6800      	ldr	r0, [r0, #0]
 8006684:	2800      	cmp	r0, #0
 8006686:	bf14      	ite	ne
 8006688:	6803      	ldrne	r3, [r0, #0]
 800668a:	2300      	moveq	r3, #0
 800668c:	2902      	cmp	r1, #2
 800668e:	bfa6      	itte	ge
 8006690:	6850      	ldrge	r0, [r2, #4]
 8006692:	3010      	addge	r0, #16
 8006694:	2004      	movlt	r0, #4
 8006696:	6800      	ldr	r0, [r0, #0]
 8006698:	2800      	cmp	r0, #0
 800669a:	bf19      	ittee	ne
 800669c:	6800      	ldrne	r0, [r0, #0]
 800669e:	f100 0418 	addne.w	r4, r0, #24
 80066a2:	2100      	moveq	r1, #0
 80066a4:	f101 0418 	addeq.w	r4, r1, #24
 80066a8:	f103 0108 	add.w	r1, r3, #8
 80066ac:	680a      	ldr	r2, [r1, #0]
 80066ae:	0a12      	lsrs	r2, r2, #8
 80066b0:	d01e      	beq.n	80066f0 <forward_acos+0x84>
 80066b2:	684e      	ldr	r6, [r1, #4]
 80066b4:	eb06 0182 	add.w	r1, r6, r2, lsl #2
 80066b8:	4610      	mov	r0, r2
 80066ba:	1f0f      	subs	r7, r1, #4
 80066bc:	f010 0103 	ands.w	r1, r0, #3
 80066c0:	d006      	beq.n	80066d0 <forward_acos+0x64>
 80066c2:	1e52      	subs	r2, r2, #1
 80066c4:	f857 c904 	ldr.w	ip, [r7], #-4
 80066c8:	1e49      	subs	r1, r1, #1
 80066ca:	fb0c f505 	mul.w	r5, ip, r5
 80066ce:	d1f8      	bne.n	80066c2 <forward_acos+0x56>
 80066d0:	0880      	lsrs	r0, r0, #2
 80066d2:	d00d      	beq.n	80066f0 <forward_acos+0x84>
 80066d4:	eb06 0182 	add.w	r1, r6, r2, lsl #2
 80066d8:	3910      	subs	r1, #16
 80066da:	68ca      	ldr	r2, [r1, #12]
 80066dc:	688e      	ldr	r6, [r1, #8]
 80066de:	684f      	ldr	r7, [r1, #4]
 80066e0:	4372      	muls	r2, r6
 80066e2:	f851 6910 	ldr.w	r6, [r1], #-16
 80066e6:	437a      	muls	r2, r7
 80066e8:	4372      	muls	r2, r6
 80066ea:	4355      	muls	r5, r2
 80066ec:	1e40      	subs	r0, r0, #1
 80066ee:	d1f4      	bne.n	80066da <forward_acos+0x6e>
 80066f0:	6998      	ldr	r0, [r3, #24]
 80066f2:	6886      	ldr	r6, [r0, #8]
 80066f4:	6821      	ldr	r1, [r4, #0]
 80066f6:	eb06 0085 	add.w	r0, r6, r5, lsl #2
 80066fa:	1f07      	subs	r7, r0, #4
 80066fc:	6888      	ldr	r0, [r1, #8]
 80066fe:	eb00 0285 	add.w	r2, r0, r5, lsl #2
 8006702:	1f14      	subs	r4, r2, #4
 8006704:	42b7      	cmp	r7, r6
 8006706:	d309      	bcc.n	800671c <forward_acos+0xb0>
 8006708:	ed97 0a00 	vldr	s0, [r7]
 800670c:	f024 fbe6 	bl	802aedc <acosf>
 8006710:	ed84 0a00 	vstr	s0, [r4]
 8006714:	1f3f      	subs	r7, r7, #4
 8006716:	1f24      	subs	r4, r4, #4
 8006718:	42b7      	cmp	r7, r6
 800671a:	d2f5      	bcs.n	8006708 <forward_acos+0x9c>
 800671c:	b001      	add	sp, #4
 800671e:	bdf0      	pop	{r4, r5, r6, r7, pc}

08006720 <nl_func_acosh_array_f32>:
 8006720:	b570      	push	{r4, r5, r6, lr}
 8006722:	688c      	ldr	r4, [r1, #8]
 8006724:	6880      	ldr	r0, [r0, #8]
 8006726:	eb04 0182 	add.w	r1, r4, r2, lsl #2
 800672a:	1f0d      	subs	r5, r1, #4
 800672c:	eb00 0182 	add.w	r1, r0, r2, lsl #2
 8006730:	1f0e      	subs	r6, r1, #4
 8006732:	42a5      	cmp	r5, r4
 8006734:	f0c0 800a 	bcc.w	800674c <nl_func_acosh_array_f32+0x2c>
 8006738:	ed95 0a00 	vldr	s0, [r5]
 800673c:	f024 fbfa 	bl	802af34 <acoshf>
 8006740:	ed86 0a00 	vstr	s0, [r6]
 8006744:	1f2d      	subs	r5, r5, #4
 8006746:	1f36      	subs	r6, r6, #4
 8006748:	42a5      	cmp	r5, r4
 800674a:	d2f5      	bcs.n	8006738 <nl_func_acosh_array_f32+0x18>
 800674c:	bd70      	pop	{r4, r5, r6, pc}
	...

08006750 <forward_acosh>:
 8006750:	b5f0      	push	{r4, r5, r6, r7, lr}
 8006752:	b081      	sub	sp, #4
 8006754:	6942      	ldr	r2, [r0, #20]
 8006756:	8811      	ldrh	r1, [r2, #0]
 8006758:	2900      	cmp	r1, #0
 800675a:	bf1a      	itte	ne
 800675c:	6850      	ldrne	r0, [r2, #4]
 800675e:	1d00      	addne	r0, r0, #4
 8006760:	2004      	moveq	r0, #4
 8006762:	f04f 0501 	mov.w	r5, #1
 8006766:	6800      	ldr	r0, [r0, #0]
 8006768:	2800      	cmp	r0, #0
 800676a:	bf14      	ite	ne
 800676c:	6803      	ldrne	r3, [r0, #0]
 800676e:	2300      	moveq	r3, #0
 8006770:	2902      	cmp	r1, #2
 8006772:	bfa6      	itte	ge
 8006774:	6850      	ldrge	r0, [r2, #4]
 8006776:	3010      	addge	r0, #16
 8006778:	2004      	movlt	r0, #4
 800677a:	6800      	ldr	r0, [r0, #0]
 800677c:	2800      	cmp	r0, #0
 800677e:	bf19      	ittee	ne
 8006780:	6800      	ldrne	r0, [r0, #0]
 8006782:	f100 0418 	addne.w	r4, r0, #24
 8006786:	2100      	moveq	r1, #0
 8006788:	f101 0418 	addeq.w	r4, r1, #24
 800678c:	f103 0108 	add.w	r1, r3, #8
 8006790:	680a      	ldr	r2, [r1, #0]
 8006792:	0a12      	lsrs	r2, r2, #8
 8006794:	d01e      	beq.n	80067d4 <forward_acosh+0x84>
 8006796:	684e      	ldr	r6, [r1, #4]
 8006798:	eb06 0182 	add.w	r1, r6, r2, lsl #2
 800679c:	4610      	mov	r0, r2
 800679e:	1f0f      	subs	r7, r1, #4
 80067a0:	f010 0103 	ands.w	r1, r0, #3
 80067a4:	d006      	beq.n	80067b4 <forward_acosh+0x64>
 80067a6:	1e52      	subs	r2, r2, #1
 80067a8:	f857 c904 	ldr.w	ip, [r7], #-4
 80067ac:	1e49      	subs	r1, r1, #1
 80067ae:	fb0c f505 	mul.w	r5, ip, r5
 80067b2:	d1f8      	bne.n	80067a6 <forward_acosh+0x56>
 80067b4:	0880      	lsrs	r0, r0, #2
 80067b6:	d00d      	beq.n	80067d4 <forward_acosh+0x84>
 80067b8:	eb06 0182 	add.w	r1, r6, r2, lsl #2
 80067bc:	3910      	subs	r1, #16
 80067be:	68ca      	ldr	r2, [r1, #12]
 80067c0:	688e      	ldr	r6, [r1, #8]
 80067c2:	684f      	ldr	r7, [r1, #4]
 80067c4:	4372      	muls	r2, r6
 80067c6:	f851 6910 	ldr.w	r6, [r1], #-16
 80067ca:	437a      	muls	r2, r7
 80067cc:	4372      	muls	r2, r6
 80067ce:	4355      	muls	r5, r2
 80067d0:	1e40      	subs	r0, r0, #1
 80067d2:	d1f4      	bne.n	80067be <forward_acosh+0x6e>
 80067d4:	6998      	ldr	r0, [r3, #24]
 80067d6:	6886      	ldr	r6, [r0, #8]
 80067d8:	6821      	ldr	r1, [r4, #0]
 80067da:	eb06 0085 	add.w	r0, r6, r5, lsl #2
 80067de:	1f07      	subs	r7, r0, #4
 80067e0:	6888      	ldr	r0, [r1, #8]
 80067e2:	eb00 0285 	add.w	r2, r0, r5, lsl #2
 80067e6:	1f14      	subs	r4, r2, #4
 80067e8:	42b7      	cmp	r7, r6
 80067ea:	d309      	bcc.n	8006800 <forward_acosh+0xb0>
 80067ec:	ed97 0a00 	vldr	s0, [r7]
 80067f0:	f024 fba0 	bl	802af34 <acoshf>
 80067f4:	ed84 0a00 	vstr	s0, [r4]
 80067f8:	1f3f      	subs	r7, r7, #4
 80067fa:	1f24      	subs	r4, r4, #4
 80067fc:	42b7      	cmp	r7, r6
 80067fe:	d2f5      	bcs.n	80067ec <forward_acosh+0x9c>
 8006800:	b001      	add	sp, #4
 8006802:	bdf0      	pop	{r4, r5, r6, r7, pc}

08006804 <nl_func_asin_array_f32>:
 8006804:	b570      	push	{r4, r5, r6, lr}
 8006806:	688c      	ldr	r4, [r1, #8]
 8006808:	6880      	ldr	r0, [r0, #8]
 800680a:	eb04 0182 	add.w	r1, r4, r2, lsl #2
 800680e:	1f0d      	subs	r5, r1, #4
 8006810:	eb00 0182 	add.w	r1, r0, r2, lsl #2
 8006814:	1f0e      	subs	r6, r1, #4
 8006816:	42a5      	cmp	r5, r4
 8006818:	f0c0 800a 	bcc.w	8006830 <nl_func_asin_array_f32+0x2c>
 800681c:	ed95 0a00 	vldr	s0, [r5]
 8006820:	f024 fba8 	bl	802af74 <asinf>
 8006824:	ed86 0a00 	vstr	s0, [r6]
 8006828:	1f2d      	subs	r5, r5, #4
 800682a:	1f36      	subs	r6, r6, #4
 800682c:	42a5      	cmp	r5, r4
 800682e:	d2f5      	bcs.n	800681c <nl_func_asin_array_f32+0x18>
 8006830:	bd70      	pop	{r4, r5, r6, pc}
	...

08006834 <forward_asin>:
 8006834:	b5f0      	push	{r4, r5, r6, r7, lr}
 8006836:	b081      	sub	sp, #4
 8006838:	6942      	ldr	r2, [r0, #20]
 800683a:	8811      	ldrh	r1, [r2, #0]
 800683c:	2900      	cmp	r1, #0
 800683e:	bf1a      	itte	ne
 8006840:	6850      	ldrne	r0, [r2, #4]
 8006842:	1d00      	addne	r0, r0, #4
 8006844:	2004      	moveq	r0, #4
 8006846:	f04f 0501 	mov.w	r5, #1
 800684a:	6800      	ldr	r0, [r0, #0]
 800684c:	2800      	cmp	r0, #0
 800684e:	bf14      	ite	ne
 8006850:	6803      	ldrne	r3, [r0, #0]
 8006852:	2300      	moveq	r3, #0
 8006854:	2902      	cmp	r1, #2
 8006856:	bfa6      	itte	ge
 8006858:	6850      	ldrge	r0, [r2, #4]
 800685a:	3010      	addge	r0, #16
 800685c:	2004      	movlt	r0, #4
 800685e:	6800      	ldr	r0, [r0, #0]
 8006860:	2800      	cmp	r0, #0
 8006862:	bf19      	ittee	ne
 8006864:	6800      	ldrne	r0, [r0, #0]
 8006866:	f100 0418 	addne.w	r4, r0, #24
 800686a:	2100      	moveq	r1, #0
 800686c:	f101 0418 	addeq.w	r4, r1, #24
 8006870:	f103 0108 	add.w	r1, r3, #8
 8006874:	680a      	ldr	r2, [r1, #0]
 8006876:	0a12      	lsrs	r2, r2, #8
 8006878:	d01e      	beq.n	80068b8 <forward_asin+0x84>
 800687a:	684e      	ldr	r6, [r1, #4]
 800687c:	eb06 0182 	add.w	r1, r6, r2, lsl #2
 8006880:	4610      	mov	r0, r2
 8006882:	1f0f      	subs	r7, r1, #4
 8006884:	f010 0103 	ands.w	r1, r0, #3
 8006888:	d006      	beq.n	8006898 <forward_asin+0x64>
 800688a:	1e52      	subs	r2, r2, #1
 800688c:	f857 c904 	ldr.w	ip, [r7], #-4
 8006890:	1e49      	subs	r1, r1, #1
 8006892:	fb0c f505 	mul.w	r5, ip, r5
 8006896:	d1f8      	bne.n	800688a <forward_asin+0x56>
 8006898:	0880      	lsrs	r0, r0, #2
 800689a:	d00d      	beq.n	80068b8 <forward_asin+0x84>
 800689c:	eb06 0182 	add.w	r1, r6, r2, lsl #2
 80068a0:	3910      	subs	r1, #16
 80068a2:	68ca      	ldr	r2, [r1, #12]
 80068a4:	688e      	ldr	r6, [r1, #8]
 80068a6:	684f      	ldr	r7, [r1, #4]
 80068a8:	4372      	muls	r2, r6
 80068aa:	f851 6910 	ldr.w	r6, [r1], #-16
 80068ae:	437a      	muls	r2, r7
 80068b0:	4372      	muls	r2, r6
 80068b2:	4355      	muls	r5, r2
 80068b4:	1e40      	subs	r0, r0, #1
 80068b6:	d1f4      	bne.n	80068a2 <forward_asin+0x6e>
 80068b8:	6998      	ldr	r0, [r3, #24]
 80068ba:	6886      	ldr	r6, [r0, #8]
 80068bc:	6821      	ldr	r1, [r4, #0]
 80068be:	eb06 0085 	add.w	r0, r6, r5, lsl #2
 80068c2:	1f07      	subs	r7, r0, #4
 80068c4:	6888      	ldr	r0, [r1, #8]
 80068c6:	eb00 0285 	add.w	r2, r0, r5, lsl #2
 80068ca:	1f14      	subs	r4, r2, #4
 80068cc:	42b7      	cmp	r7, r6
 80068ce:	d309      	bcc.n	80068e4 <forward_asin+0xb0>
 80068d0:	ed97 0a00 	vldr	s0, [r7]
 80068d4:	f024 fb4e 	bl	802af74 <asinf>
 80068d8:	ed84 0a00 	vstr	s0, [r4]
 80068dc:	1f3f      	subs	r7, r7, #4
 80068de:	1f24      	subs	r4, r4, #4
 80068e0:	42b7      	cmp	r7, r6
 80068e2:	d2f5      	bcs.n	80068d0 <forward_asin+0x9c>
 80068e4:	b001      	add	sp, #4
 80068e6:	bdf0      	pop	{r4, r5, r6, r7, pc}

080068e8 <nl_func_asinh_array_f32>:
 80068e8:	b570      	push	{r4, r5, r6, lr}
 80068ea:	688c      	ldr	r4, [r1, #8]
 80068ec:	6880      	ldr	r0, [r0, #8]
 80068ee:	eb04 0182 	add.w	r1, r4, r2, lsl #2
 80068f2:	1f0d      	subs	r5, r1, #4
 80068f4:	eb00 0182 	add.w	r1, r0, r2, lsl #2
 80068f8:	1f0e      	subs	r6, r1, #4
 80068fa:	42a5      	cmp	r5, r4
 80068fc:	f0c0 800a 	bcc.w	8006914 <nl_func_asinh_array_f32+0x2c>
 8006900:	ed95 0a00 	vldr	s0, [r5]
 8006904:	f023 fd1e 	bl	802a344 <asinhf>
 8006908:	ed86 0a00 	vstr	s0, [r6]
 800690c:	1f2d      	subs	r5, r5, #4
 800690e:	1f36      	subs	r6, r6, #4
 8006910:	42a5      	cmp	r5, r4
 8006912:	d2f5      	bcs.n	8006900 <nl_func_asinh_array_f32+0x18>
 8006914:	bd70      	pop	{r4, r5, r6, pc}
	...

08006918 <forward_asinh>:
 8006918:	b5f0      	push	{r4, r5, r6, r7, lr}
 800691a:	b081      	sub	sp, #4
 800691c:	6942      	ldr	r2, [r0, #20]
 800691e:	8811      	ldrh	r1, [r2, #0]
 8006920:	2900      	cmp	r1, #0
 8006922:	bf1a      	itte	ne
 8006924:	6850      	ldrne	r0, [r2, #4]
 8006926:	1d00      	addne	r0, r0, #4
 8006928:	2004      	moveq	r0, #4
 800692a:	f04f 0501 	mov.w	r5, #1
 800692e:	6800      	ldr	r0, [r0, #0]
 8006930:	2800      	cmp	r0, #0
 8006932:	bf14      	ite	ne
 8006934:	6803      	ldrne	r3, [r0, #0]
 8006936:	2300      	moveq	r3, #0
 8006938:	2902      	cmp	r1, #2
 800693a:	bfa6      	itte	ge
 800693c:	6850      	ldrge	r0, [r2, #4]
 800693e:	3010      	addge	r0, #16
 8006940:	2004      	movlt	r0, #4
 8006942:	6800      	ldr	r0, [r0, #0]
 8006944:	2800      	cmp	r0, #0
 8006946:	bf19      	ittee	ne
 8006948:	6800      	ldrne	r0, [r0, #0]
 800694a:	f100 0418 	addne.w	r4, r0, #24
 800694e:	2100      	moveq	r1, #0
 8006950:	f101 0418 	addeq.w	r4, r1, #24
 8006954:	f103 0108 	add.w	r1, r3, #8
 8006958:	680a      	ldr	r2, [r1, #0]
 800695a:	0a12      	lsrs	r2, r2, #8
 800695c:	d01e      	beq.n	800699c <forward_asinh+0x84>
 800695e:	684e      	ldr	r6, [r1, #4]
 8006960:	eb06 0182 	add.w	r1, r6, r2, lsl #2
 8006964:	4610      	mov	r0, r2
 8006966:	1f0f      	subs	r7, r1, #4
 8006968:	f010 0103 	ands.w	r1, r0, #3
 800696c:	d006      	beq.n	800697c <forward_asinh+0x64>
 800696e:	1e52      	subs	r2, r2, #1
 8006970:	f857 c904 	ldr.w	ip, [r7], #-4
 8006974:	1e49      	subs	r1, r1, #1
 8006976:	fb0c f505 	mul.w	r5, ip, r5
 800697a:	d1f8      	bne.n	800696e <forward_asinh+0x56>
 800697c:	0880      	lsrs	r0, r0, #2
 800697e:	d00d      	beq.n	800699c <forward_asinh+0x84>
 8006980:	eb06 0182 	add.w	r1, r6, r2, lsl #2
 8006984:	3910      	subs	r1, #16
 8006986:	68ca      	ldr	r2, [r1, #12]
 8006988:	688e      	ldr	r6, [r1, #8]
 800698a:	684f      	ldr	r7, [r1, #4]
 800698c:	4372      	muls	r2, r6
 800698e:	f851 6910 	ldr.w	r6, [r1], #-16
 8006992:	437a      	muls	r2, r7
 8006994:	4372      	muls	r2, r6
 8006996:	4355      	muls	r5, r2
 8006998:	1e40      	subs	r0, r0, #1
 800699a:	d1f4      	bne.n	8006986 <forward_asinh+0x6e>
 800699c:	6998      	ldr	r0, [r3, #24]
 800699e:	6886      	ldr	r6, [r0, #8]
 80069a0:	6821      	ldr	r1, [r4, #0]
 80069a2:	eb06 0085 	add.w	r0, r6, r5, lsl #2
 80069a6:	1f07      	subs	r7, r0, #4
 80069a8:	6888      	ldr	r0, [r1, #8]
 80069aa:	eb00 0285 	add.w	r2, r0, r5, lsl #2
 80069ae:	1f14      	subs	r4, r2, #4
 80069b0:	42b7      	cmp	r7, r6
 80069b2:	d309      	bcc.n	80069c8 <forward_asinh+0xb0>
 80069b4:	ed97 0a00 	vldr	s0, [r7]
 80069b8:	f023 fcc4 	bl	802a344 <asinhf>
 80069bc:	ed84 0a00 	vstr	s0, [r4]
 80069c0:	1f3f      	subs	r7, r7, #4
 80069c2:	1f24      	subs	r4, r4, #4
 80069c4:	42b7      	cmp	r7, r6
 80069c6:	d2f5      	bcs.n	80069b4 <forward_asinh+0x9c>
 80069c8:	b001      	add	sp, #4
 80069ca:	bdf0      	pop	{r4, r5, r6, r7, pc}

080069cc <nl_func_atan_array_f32>:
 80069cc:	b570      	push	{r4, r5, r6, lr}
 80069ce:	688c      	ldr	r4, [r1, #8]
 80069d0:	6880      	ldr	r0, [r0, #8]
 80069d2:	eb04 0182 	add.w	r1, r4, r2, lsl #2
 80069d6:	1f0d      	subs	r5, r1, #4
 80069d8:	eb00 0182 	add.w	r1, r0, r2, lsl #2
 80069dc:	1f0e      	subs	r6, r1, #4
 80069de:	42a5      	cmp	r5, r4
 80069e0:	f0c0 800a 	bcc.w	80069f8 <nl_func_atan_array_f32+0x2c>
 80069e4:	ed95 0a00 	vldr	s0, [r5]
 80069e8:	f023 fd14 	bl	802a414 <atanf>
 80069ec:	ed86 0a00 	vstr	s0, [r6]
 80069f0:	1f2d      	subs	r5, r5, #4
 80069f2:	1f36      	subs	r6, r6, #4
 80069f4:	42a5      	cmp	r5, r4
 80069f6:	d2f5      	bcs.n	80069e4 <nl_func_atan_array_f32+0x18>
 80069f8:	bd70      	pop	{r4, r5, r6, pc}
	...

080069fc <forward_atan>:
 80069fc:	b5f0      	push	{r4, r5, r6, r7, lr}
 80069fe:	b081      	sub	sp, #4
 8006a00:	6942      	ldr	r2, [r0, #20]
 8006a02:	8811      	ldrh	r1, [r2, #0]
 8006a04:	2900      	cmp	r1, #0
 8006a06:	bf1a      	itte	ne
 8006a08:	6850      	ldrne	r0, [r2, #4]
 8006a0a:	1d00      	addne	r0, r0, #4
 8006a0c:	2004      	moveq	r0, #4
 8006a0e:	f04f 0501 	mov.w	r5, #1
 8006a12:	6800      	ldr	r0, [r0, #0]
 8006a14:	2800      	cmp	r0, #0
 8006a16:	bf14      	ite	ne
 8006a18:	6803      	ldrne	r3, [r0, #0]
 8006a1a:	2300      	moveq	r3, #0
 8006a1c:	2902      	cmp	r1, #2
 8006a1e:	bfa6      	itte	ge
 8006a20:	6850      	ldrge	r0, [r2, #4]
 8006a22:	3010      	addge	r0, #16
 8006a24:	2004      	movlt	r0, #4
 8006a26:	6800      	ldr	r0, [r0, #0]
 8006a28:	2800      	cmp	r0, #0
 8006a2a:	bf19      	ittee	ne
 8006a2c:	6800      	ldrne	r0, [r0, #0]
 8006a2e:	f100 0418 	addne.w	r4, r0, #24
 8006a32:	2100      	moveq	r1, #0
 8006a34:	f101 0418 	addeq.w	r4, r1, #24
 8006a38:	f103 0108 	add.w	r1, r3, #8
 8006a3c:	680a      	ldr	r2, [r1, #0]
 8006a3e:	0a12      	lsrs	r2, r2, #8
 8006a40:	d01e      	beq.n	8006a80 <forward_atan+0x84>
 8006a42:	684e      	ldr	r6, [r1, #4]
 8006a44:	eb06 0182 	add.w	r1, r6, r2, lsl #2
 8006a48:	4610      	mov	r0, r2
 8006a4a:	1f0f      	subs	r7, r1, #4
 8006a4c:	f010 0103 	ands.w	r1, r0, #3
 8006a50:	d006      	beq.n	8006a60 <forward_atan+0x64>
 8006a52:	1e52      	subs	r2, r2, #1
 8006a54:	f857 c904 	ldr.w	ip, [r7], #-4
 8006a58:	1e49      	subs	r1, r1, #1
 8006a5a:	fb0c f505 	mul.w	r5, ip, r5
 8006a5e:	d1f8      	bne.n	8006a52 <forward_atan+0x56>
 8006a60:	0880      	lsrs	r0, r0, #2
 8006a62:	d00d      	beq.n	8006a80 <forward_atan+0x84>
 8006a64:	eb06 0182 	add.w	r1, r6, r2, lsl #2
 8006a68:	3910      	subs	r1, #16
 8006a6a:	68ca      	ldr	r2, [r1, #12]
 8006a6c:	688e      	ldr	r6, [r1, #8]
 8006a6e:	684f      	ldr	r7, [r1, #4]
 8006a70:	4372      	muls	r2, r6
 8006a72:	f851 6910 	ldr.w	r6, [r1], #-16
 8006a76:	437a      	muls	r2, r7
 8006a78:	4372      	muls	r2, r6
 8006a7a:	4355      	muls	r5, r2
 8006a7c:	1e40      	subs	r0, r0, #1
 8006a7e:	d1f4      	bne.n	8006a6a <forward_atan+0x6e>
 8006a80:	6998      	ldr	r0, [r3, #24]
 8006a82:	6886      	ldr	r6, [r0, #8]
 8006a84:	6821      	ldr	r1, [r4, #0]
 8006a86:	eb06 0085 	add.w	r0, r6, r5, lsl #2
 8006a8a:	1f07      	subs	r7, r0, #4
 8006a8c:	6888      	ldr	r0, [r1, #8]
 8006a8e:	eb00 0285 	add.w	r2, r0, r5, lsl #2
 8006a92:	1f14      	subs	r4, r2, #4
 8006a94:	42b7      	cmp	r7, r6
 8006a96:	d309      	bcc.n	8006aac <forward_atan+0xb0>
 8006a98:	ed97 0a00 	vldr	s0, [r7]
 8006a9c:	f023 fcba 	bl	802a414 <atanf>
 8006aa0:	ed84 0a00 	vstr	s0, [r4]
 8006aa4:	1f3f      	subs	r7, r7, #4
 8006aa6:	1f24      	subs	r4, r4, #4
 8006aa8:	42b7      	cmp	r7, r6
 8006aaa:	d2f5      	bcs.n	8006a98 <forward_atan+0x9c>
 8006aac:	b001      	add	sp, #4
 8006aae:	bdf0      	pop	{r4, r5, r6, r7, pc}

08006ab0 <nl_func_atanh_array_f32>:
 8006ab0:	b570      	push	{r4, r5, r6, lr}
 8006ab2:	688c      	ldr	r4, [r1, #8]
 8006ab4:	6880      	ldr	r0, [r0, #8]
 8006ab6:	eb04 0182 	add.w	r1, r4, r2, lsl #2
 8006aba:	1f0d      	subs	r5, r1, #4
 8006abc:	eb00 0182 	add.w	r1, r0, r2, lsl #2
 8006ac0:	1f0e      	subs	r6, r1, #4
 8006ac2:	42a5      	cmp	r5, r4
 8006ac4:	f0c0 800a 	bcc.w	8006adc <nl_func_atanh_array_f32+0x2c>
 8006ac8:	ed95 0a00 	vldr	s0, [r5]
 8006acc:	f024 fa7e 	bl	802afcc <atanhf>
 8006ad0:	ed86 0a00 	vstr	s0, [r6]
 8006ad4:	1f2d      	subs	r5, r5, #4
 8006ad6:	1f36      	subs	r6, r6, #4
 8006ad8:	42a5      	cmp	r5, r4
 8006ada:	d2f5      	bcs.n	8006ac8 <nl_func_atanh_array_f32+0x18>
 8006adc:	bd70      	pop	{r4, r5, r6, pc}
	...

08006ae0 <forward_atanh>:
 8006ae0:	b5f0      	push	{r4, r5, r6, r7, lr}
 8006ae2:	b081      	sub	sp, #4
 8006ae4:	6942      	ldr	r2, [r0, #20]
 8006ae6:	8811      	ldrh	r1, [r2, #0]
 8006ae8:	2900      	cmp	r1, #0
 8006aea:	bf1a      	itte	ne
 8006aec:	6850      	ldrne	r0, [r2, #4]
 8006aee:	1d00      	addne	r0, r0, #4
 8006af0:	2004      	moveq	r0, #4
 8006af2:	f04f 0501 	mov.w	r5, #1
 8006af6:	6800      	ldr	r0, [r0, #0]
 8006af8:	2800      	cmp	r0, #0
 8006afa:	bf14      	ite	ne
 8006afc:	6803      	ldrne	r3, [r0, #0]
 8006afe:	2300      	moveq	r3, #0
 8006b00:	2902      	cmp	r1, #2
 8006b02:	bfa6      	itte	ge
 8006b04:	6850      	ldrge	r0, [r2, #4]
 8006b06:	3010      	addge	r0, #16
 8006b08:	2004      	movlt	r0, #4
 8006b0a:	6800      	ldr	r0, [r0, #0]
 8006b0c:	2800      	cmp	r0, #0
 8006b0e:	bf19      	ittee	ne
 8006b10:	6800      	ldrne	r0, [r0, #0]
 8006b12:	f100 0418 	addne.w	r4, r0, #24
 8006b16:	2100      	moveq	r1, #0
 8006b18:	f101 0418 	addeq.w	r4, r1, #24
 8006b1c:	f103 0108 	add.w	r1, r3, #8
 8006b20:	680a      	ldr	r2, [r1, #0]
 8006b22:	0a12      	lsrs	r2, r2, #8
 8006b24:	d01e      	beq.n	8006b64 <forward_atanh+0x84>
 8006b26:	684e      	ldr	r6, [r1, #4]
 8006b28:	eb06 0182 	add.w	r1, r6, r2, lsl #2
 8006b2c:	4610      	mov	r0, r2
 8006b2e:	1f0f      	subs	r7, r1, #4
 8006b30:	f010 0103 	ands.w	r1, r0, #3
 8006b34:	d006      	beq.n	8006b44 <forward_atanh+0x64>
 8006b36:	1e52      	subs	r2, r2, #1
 8006b38:	f857 c904 	ldr.w	ip, [r7], #-4
 8006b3c:	1e49      	subs	r1, r1, #1
 8006b3e:	fb0c f505 	mul.w	r5, ip, r5
 8006b42:	d1f8      	bne.n	8006b36 <forward_atanh+0x56>
 8006b44:	0880      	lsrs	r0, r0, #2
 8006b46:	d00d      	beq.n	8006b64 <forward_atanh+0x84>
 8006b48:	eb06 0182 	add.w	r1, r6, r2, lsl #2
 8006b4c:	3910      	subs	r1, #16
 8006b4e:	68ca      	ldr	r2, [r1, #12]
 8006b50:	688e      	ldr	r6, [r1, #8]
 8006b52:	684f      	ldr	r7, [r1, #4]
 8006b54:	4372      	muls	r2, r6
 8006b56:	f851 6910 	ldr.w	r6, [r1], #-16
 8006b5a:	437a      	muls	r2, r7
 8006b5c:	4372      	muls	r2, r6
 8006b5e:	4355      	muls	r5, r2
 8006b60:	1e40      	subs	r0, r0, #1
 8006b62:	d1f4      	bne.n	8006b4e <forward_atanh+0x6e>
 8006b64:	6998      	ldr	r0, [r3, #24]
 8006b66:	6886      	ldr	r6, [r0, #8]
 8006b68:	6821      	ldr	r1, [r4, #0]
 8006b6a:	eb06 0085 	add.w	r0, r6, r5, lsl #2
 8006b6e:	1f07      	subs	r7, r0, #4
 8006b70:	6888      	ldr	r0, [r1, #8]
 8006b72:	eb00 0285 	add.w	r2, r0, r5, lsl #2
 8006b76:	1f14      	subs	r4, r2, #4
 8006b78:	42b7      	cmp	r7, r6
 8006b7a:	d309      	bcc.n	8006b90 <forward_atanh+0xb0>
 8006b7c:	ed97 0a00 	vldr	s0, [r7]
 8006b80:	f024 fa24 	bl	802afcc <atanhf>
 8006b84:	ed84 0a00 	vstr	s0, [r4]
 8006b88:	1f3f      	subs	r7, r7, #4
 8006b8a:	1f24      	subs	r4, r4, #4
 8006b8c:	42b7      	cmp	r7, r6
 8006b8e:	d2f5      	bcs.n	8006b7c <forward_atanh+0x9c>
 8006b90:	b001      	add	sp, #4
 8006b92:	bdf0      	pop	{r4, r5, r6, r7, pc}

08006b94 <nl_func_cos_array_f32>:
 8006b94:	b570      	push	{r4, r5, r6, lr}
 8006b96:	688c      	ldr	r4, [r1, #8]
 8006b98:	6880      	ldr	r0, [r0, #8]
 8006b9a:	eb04 0182 	add.w	r1, r4, r2, lsl #2
 8006b9e:	1f0d      	subs	r5, r1, #4
 8006ba0:	eb00 0182 	add.w	r1, r0, r2, lsl #2
 8006ba4:	1f0e      	subs	r6, r1, #4
 8006ba6:	42a5      	cmp	r5, r4
 8006ba8:	f0c0 800a 	bcc.w	8006bc0 <nl_func_cos_array_f32+0x2c>
 8006bac:	ed95 0a00 	vldr	s0, [r5]
 8006bb0:	f023 fd46 	bl	802a640 <cosf>
 8006bb4:	ed86 0a00 	vstr	s0, [r6]
 8006bb8:	1f2d      	subs	r5, r5, #4
 8006bba:	1f36      	subs	r6, r6, #4
 8006bbc:	42a5      	cmp	r5, r4
 8006bbe:	d2f5      	bcs.n	8006bac <nl_func_cos_array_f32+0x18>
 8006bc0:	bd70      	pop	{r4, r5, r6, pc}
	...

08006bc4 <forward_cos>:
 8006bc4:	b5f0      	push	{r4, r5, r6, r7, lr}
 8006bc6:	b081      	sub	sp, #4
 8006bc8:	6942      	ldr	r2, [r0, #20]
 8006bca:	8811      	ldrh	r1, [r2, #0]
 8006bcc:	2900      	cmp	r1, #0
 8006bce:	bf1a      	itte	ne
 8006bd0:	6850      	ldrne	r0, [r2, #4]
 8006bd2:	1d00      	addne	r0, r0, #4
 8006bd4:	2004      	moveq	r0, #4
 8006bd6:	f04f 0501 	mov.w	r5, #1
 8006bda:	6800      	ldr	r0, [r0, #0]
 8006bdc:	2800      	cmp	r0, #0
 8006bde:	bf14      	ite	ne
 8006be0:	6803      	ldrne	r3, [r0, #0]
 8006be2:	2300      	moveq	r3, #0
 8006be4:	2902      	cmp	r1, #2
 8006be6:	bfa6      	itte	ge
 8006be8:	6850      	ldrge	r0, [r2, #4]
 8006bea:	3010      	addge	r0, #16
 8006bec:	2004      	movlt	r0, #4
 8006bee:	6800      	ldr	r0, [r0, #0]
 8006bf0:	2800      	cmp	r0, #0
 8006bf2:	bf19      	ittee	ne
 8006bf4:	6800      	ldrne	r0, [r0, #0]
 8006bf6:	f100 0418 	addne.w	r4, r0, #24
 8006bfa:	2100      	moveq	r1, #0
 8006bfc:	f101 0418 	addeq.w	r4, r1, #24
 8006c00:	f103 0108 	add.w	r1, r3, #8
 8006c04:	680a      	ldr	r2, [r1, #0]
 8006c06:	0a12      	lsrs	r2, r2, #8
 8006c08:	d01e      	beq.n	8006c48 <forward_cos+0x84>
 8006c0a:	684e      	ldr	r6, [r1, #4]
 8006c0c:	eb06 0182 	add.w	r1, r6, r2, lsl #2
 8006c10:	4610      	mov	r0, r2
 8006c12:	1f0f      	subs	r7, r1, #4
 8006c14:	f010 0103 	ands.w	r1, r0, #3
 8006c18:	d006      	beq.n	8006c28 <forward_cos+0x64>
 8006c1a:	1e52      	subs	r2, r2, #1
 8006c1c:	f857 c904 	ldr.w	ip, [r7], #-4
 8006c20:	1e49      	subs	r1, r1, #1
 8006c22:	fb0c f505 	mul.w	r5, ip, r5
 8006c26:	d1f8      	bne.n	8006c1a <forward_cos+0x56>
 8006c28:	0880      	lsrs	r0, r0, #2
 8006c2a:	d00d      	beq.n	8006c48 <forward_cos+0x84>
 8006c2c:	eb06 0182 	add.w	r1, r6, r2, lsl #2
 8006c30:	3910      	subs	r1, #16
 8006c32:	68ca      	ldr	r2, [r1, #12]
 8006c34:	688e      	ldr	r6, [r1, #8]
 8006c36:	684f      	ldr	r7, [r1, #4]
 8006c38:	4372      	muls	r2, r6
 8006c3a:	f851 6910 	ldr.w	r6, [r1], #-16
 8006c3e:	437a      	muls	r2, r7
 8006c40:	4372      	muls	r2, r6
 8006c42:	4355      	muls	r5, r2
 8006c44:	1e40      	subs	r0, r0, #1
 8006c46:	d1f4      	bne.n	8006c32 <forward_cos+0x6e>
 8006c48:	6998      	ldr	r0, [r3, #24]
 8006c4a:	6886      	ldr	r6, [r0, #8]
 8006c4c:	6821      	ldr	r1, [r4, #0]
 8006c4e:	eb06 0085 	add.w	r0, r6, r5, lsl #2
 8006c52:	1f07      	subs	r7, r0, #4
 8006c54:	6888      	ldr	r0, [r1, #8]
 8006c56:	eb00 0285 	add.w	r2, r0, r5, lsl #2
 8006c5a:	1f14      	subs	r4, r2, #4
 8006c5c:	42b7      	cmp	r7, r6
 8006c5e:	d309      	bcc.n	8006c74 <forward_cos+0xb0>
 8006c60:	ed97 0a00 	vldr	s0, [r7]
 8006c64:	f023 fcec 	bl	802a640 <cosf>
 8006c68:	ed84 0a00 	vstr	s0, [r4]
 8006c6c:	1f3f      	subs	r7, r7, #4
 8006c6e:	1f24      	subs	r4, r4, #4
 8006c70:	42b7      	cmp	r7, r6
 8006c72:	d2f5      	bcs.n	8006c60 <forward_cos+0x9c>
 8006c74:	b001      	add	sp, #4
 8006c76:	bdf0      	pop	{r4, r5, r6, r7, pc}

08006c78 <nl_func_cosh_array_f32>:
 8006c78:	b570      	push	{r4, r5, r6, lr}
 8006c7a:	688c      	ldr	r4, [r1, #8]
 8006c7c:	6880      	ldr	r0, [r0, #8]
 8006c7e:	eb04 0182 	add.w	r1, r4, r2, lsl #2
 8006c82:	1f0d      	subs	r5, r1, #4
 8006c84:	eb00 0182 	add.w	r1, r0, r2, lsl #2
 8006c88:	1f0e      	subs	r6, r1, #4
 8006c8a:	42a5      	cmp	r5, r4
 8006c8c:	f0c0 800a 	bcc.w	8006ca4 <nl_func_cosh_array_f32+0x2c>
 8006c90:	ed95 0a00 	vldr	s0, [r5]
 8006c94:	f024 f9ca 	bl	802b02c <coshf>
 8006c98:	ed86 0a00 	vstr	s0, [r6]
 8006c9c:	1f2d      	subs	r5, r5, #4
 8006c9e:	1f36      	subs	r6, r6, #4
 8006ca0:	42a5      	cmp	r5, r4
 8006ca2:	d2f5      	bcs.n	8006c90 <nl_func_cosh_array_f32+0x18>
 8006ca4:	bd70      	pop	{r4, r5, r6, pc}
	...

08006ca8 <forward_cosh>:
 8006ca8:	b5f0      	push	{r4, r5, r6, r7, lr}
 8006caa:	b081      	sub	sp, #4
 8006cac:	6942      	ldr	r2, [r0, #20]
 8006cae:	8811      	ldrh	r1, [r2, #0]
 8006cb0:	2900      	cmp	r1, #0
 8006cb2:	bf1a      	itte	ne
 8006cb4:	6850      	ldrne	r0, [r2, #4]
 8006cb6:	1d00      	addne	r0, r0, #4
 8006cb8:	2004      	moveq	r0, #4
 8006cba:	f04f 0501 	mov.w	r5, #1
 8006cbe:	6800      	ldr	r0, [r0, #0]
 8006cc0:	2800      	cmp	r0, #0
 8006cc2:	bf14      	ite	ne
 8006cc4:	6803      	ldrne	r3, [r0, #0]
 8006cc6:	2300      	moveq	r3, #0
 8006cc8:	2902      	cmp	r1, #2
 8006cca:	bfa6      	itte	ge
 8006ccc:	6850      	ldrge	r0, [r2, #4]
 8006cce:	3010      	addge	r0, #16
 8006cd0:	2004      	movlt	r0, #4
 8006cd2:	6800      	ldr	r0, [r0, #0]
 8006cd4:	2800      	cmp	r0, #0
 8006cd6:	bf19      	ittee	ne
 8006cd8:	6800      	ldrne	r0, [r0, #0]
 8006cda:	f100 0418 	addne.w	r4, r0, #24
 8006cde:	2100      	moveq	r1, #0
 8006ce0:	f101 0418 	addeq.w	r4, r1, #24
 8006ce4:	f103 0108 	add.w	r1, r3, #8
 8006ce8:	680a      	ldr	r2, [r1, #0]
 8006cea:	0a12      	lsrs	r2, r2, #8
 8006cec:	d01e      	beq.n	8006d2c <forward_cosh+0x84>
 8006cee:	684e      	ldr	r6, [r1, #4]
 8006cf0:	eb06 0182 	add.w	r1, r6, r2, lsl #2
 8006cf4:	4610      	mov	r0, r2
 8006cf6:	1f0f      	subs	r7, r1, #4
 8006cf8:	f010 0103 	ands.w	r1, r0, #3
 8006cfc:	d006      	beq.n	8006d0c <forward_cosh+0x64>
 8006cfe:	1e52      	subs	r2, r2, #1
 8006d00:	f857 c904 	ldr.w	ip, [r7], #-4
 8006d04:	1e49      	subs	r1, r1, #1
 8006d06:	fb0c f505 	mul.w	r5, ip, r5
 8006d0a:	d1f8      	bne.n	8006cfe <forward_cosh+0x56>
 8006d0c:	0880      	lsrs	r0, r0, #2
 8006d0e:	d00d      	beq.n	8006d2c <forward_cosh+0x84>
 8006d10:	eb06 0182 	add.w	r1, r6, r2, lsl #2
 8006d14:	3910      	subs	r1, #16
 8006d16:	68ca      	ldr	r2, [r1, #12]
 8006d18:	688e      	ldr	r6, [r1, #8]
 8006d1a:	684f      	ldr	r7, [r1, #4]
 8006d1c:	4372      	muls	r2, r6
 8006d1e:	f851 6910 	ldr.w	r6, [r1], #-16
 8006d22:	437a      	muls	r2, r7
 8006d24:	4372      	muls	r2, r6
 8006d26:	4355      	muls	r5, r2
 8006d28:	1e40      	subs	r0, r0, #1
 8006d2a:	d1f4      	bne.n	8006d16 <forward_cosh+0x6e>
 8006d2c:	6998      	ldr	r0, [r3, #24]
 8006d2e:	6886      	ldr	r6, [r0, #8]
 8006d30:	6821      	ldr	r1, [r4, #0]
 8006d32:	eb06 0085 	add.w	r0, r6, r5, lsl #2
 8006d36:	1f07      	subs	r7, r0, #4
 8006d38:	6888      	ldr	r0, [r1, #8]
 8006d3a:	eb00 0285 	add.w	r2, r0, r5, lsl #2
 8006d3e:	1f14      	subs	r4, r2, #4
 8006d40:	42b7      	cmp	r7, r6
 8006d42:	d309      	bcc.n	8006d58 <forward_cosh+0xb0>
 8006d44:	ed97 0a00 	vldr	s0, [r7]
 8006d48:	f024 f970 	bl	802b02c <coshf>
 8006d4c:	ed84 0a00 	vstr	s0, [r4]
 8006d50:	1f3f      	subs	r7, r7, #4
 8006d52:	1f24      	subs	r4, r4, #4
 8006d54:	42b7      	cmp	r7, r6
 8006d56:	d2f5      	bcs.n	8006d44 <forward_cosh+0x9c>
 8006d58:	b001      	add	sp, #4
 8006d5a:	bdf0      	pop	{r4, r5, r6, r7, pc}

08006d5c <nl_func_erf_array_f32>:
 8006d5c:	b570      	push	{r4, r5, r6, lr}
 8006d5e:	688c      	ldr	r4, [r1, #8]
 8006d60:	6880      	ldr	r0, [r0, #8]
 8006d62:	eb04 0182 	add.w	r1, r4, r2, lsl #2
 8006d66:	1f0d      	subs	r5, r1, #4
 8006d68:	eb00 0182 	add.w	r1, r0, r2, lsl #2
 8006d6c:	1f0e      	subs	r6, r1, #4
 8006d6e:	42a5      	cmp	r5, r4
 8006d70:	f0c0 800a 	bcc.w	8006d88 <nl_func_erf_array_f32+0x2c>
 8006d74:	ed95 0a00 	vldr	s0, [r5]
 8006d78:	f023 fca6 	bl	802a6c8 <erff>
 8006d7c:	ed86 0a00 	vstr	s0, [r6]
 8006d80:	1f2d      	subs	r5, r5, #4
 8006d82:	1f36      	subs	r6, r6, #4
 8006d84:	42a5      	cmp	r5, r4
 8006d86:	d2f5      	bcs.n	8006d74 <nl_func_erf_array_f32+0x18>
 8006d88:	bd70      	pop	{r4, r5, r6, pc}
	...

08006d8c <forward_erf>:
 8006d8c:	b5f0      	push	{r4, r5, r6, r7, lr}
 8006d8e:	b081      	sub	sp, #4
 8006d90:	6942      	ldr	r2, [r0, #20]
 8006d92:	8811      	ldrh	r1, [r2, #0]
 8006d94:	2900      	cmp	r1, #0
 8006d96:	bf1a      	itte	ne
 8006d98:	6850      	ldrne	r0, [r2, #4]
 8006d9a:	1d00      	addne	r0, r0, #4
 8006d9c:	2004      	moveq	r0, #4
 8006d9e:	f04f 0501 	mov.w	r5, #1
 8006da2:	6800      	ldr	r0, [r0, #0]
 8006da4:	2800      	cmp	r0, #0
 8006da6:	bf14      	ite	ne
 8006da8:	6803      	ldrne	r3, [r0, #0]
 8006daa:	2300      	moveq	r3, #0
 8006dac:	2902      	cmp	r1, #2
 8006dae:	bfa6      	itte	ge
 8006db0:	6850      	ldrge	r0, [r2, #4]
 8006db2:	3010      	addge	r0, #16
 8006db4:	2004      	movlt	r0, #4
 8006db6:	6800      	ldr	r0, [r0, #0]
 8006db8:	2800      	cmp	r0, #0
 8006dba:	bf19      	ittee	ne
 8006dbc:	6800      	ldrne	r0, [r0, #0]
 8006dbe:	f100 0418 	addne.w	r4, r0, #24
 8006dc2:	2100      	moveq	r1, #0
 8006dc4:	f101 0418 	addeq.w	r4, r1, #24
 8006dc8:	f103 0108 	add.w	r1, r3, #8
 8006dcc:	680a      	ldr	r2, [r1, #0]
 8006dce:	0a12      	lsrs	r2, r2, #8
 8006dd0:	d01e      	beq.n	8006e10 <forward_erf+0x84>
 8006dd2:	684e      	ldr	r6, [r1, #4]
 8006dd4:	eb06 0182 	add.w	r1, r6, r2, lsl #2
 8006dd8:	4610      	mov	r0, r2
 8006dda:	1f0f      	subs	r7, r1, #4
 8006ddc:	f010 0103 	ands.w	r1, r0, #3
 8006de0:	d006      	beq.n	8006df0 <forward_erf+0x64>
 8006de2:	1e52      	subs	r2, r2, #1
 8006de4:	f857 c904 	ldr.w	ip, [r7], #-4
 8006de8:	1e49      	subs	r1, r1, #1
 8006dea:	fb0c f505 	mul.w	r5, ip, r5
 8006dee:	d1f8      	bne.n	8006de2 <forward_erf+0x56>
 8006df0:	0880      	lsrs	r0, r0, #2
 8006df2:	d00d      	beq.n	8006e10 <forward_erf+0x84>
 8006df4:	eb06 0182 	add.w	r1, r6, r2, lsl #2
 8006df8:	3910      	subs	r1, #16
 8006dfa:	68ca      	ldr	r2, [r1, #12]
 8006dfc:	688e      	ldr	r6, [r1, #8]
 8006dfe:	684f      	ldr	r7, [r1, #4]
 8006e00:	4372      	muls	r2, r6
 8006e02:	f851 6910 	ldr.w	r6, [r1], #-16
 8006e06:	437a      	muls	r2, r7
 8006e08:	4372      	muls	r2, r6
 8006e0a:	4355      	muls	r5, r2
 8006e0c:	1e40      	subs	r0, r0, #1
 8006e0e:	d1f4      	bne.n	8006dfa <forward_erf+0x6e>
 8006e10:	6998      	ldr	r0, [r3, #24]
 8006e12:	6886      	ldr	r6, [r0, #8]
 8006e14:	6821      	ldr	r1, [r4, #0]
 8006e16:	eb06 0085 	add.w	r0, r6, r5, lsl #2
 8006e1a:	1f07      	subs	r7, r0, #4
 8006e1c:	6888      	ldr	r0, [r1, #8]
 8006e1e:	eb00 0285 	add.w	r2, r0, r5, lsl #2
 8006e22:	1f14      	subs	r4, r2, #4
 8006e24:	42b7      	cmp	r7, r6
 8006e26:	d309      	bcc.n	8006e3c <forward_erf+0xb0>
 8006e28:	ed97 0a00 	vldr	s0, [r7]
 8006e2c:	f023 fc4c 	bl	802a6c8 <erff>
 8006e30:	ed84 0a00 	vstr	s0, [r4]
 8006e34:	1f3f      	subs	r7, r7, #4
 8006e36:	1f24      	subs	r4, r4, #4
 8006e38:	42b7      	cmp	r7, r6
 8006e3a:	d2f5      	bcs.n	8006e28 <forward_erf+0x9c>
 8006e3c:	b001      	add	sp, #4
 8006e3e:	bdf0      	pop	{r4, r5, r6, r7, pc}

08006e40 <nl_func_log_array_f32>:
 8006e40:	b570      	push	{r4, r5, r6, lr}
 8006e42:	688c      	ldr	r4, [r1, #8]
 8006e44:	6880      	ldr	r0, [r0, #8]
 8006e46:	eb04 0182 	add.w	r1, r4, r2, lsl #2
 8006e4a:	1f0d      	subs	r5, r1, #4
 8006e4c:	eb00 0182 	add.w	r1, r0, r2, lsl #2
 8006e50:	1f0e      	subs	r6, r1, #4
 8006e52:	42a5      	cmp	r5, r4
 8006e54:	f0c0 800a 	bcc.w	8006e6c <nl_func_log_array_f32+0x2c>
 8006e58:	ed95 0a00 	vldr	s0, [r5]
 8006e5c:	f024 f964 	bl	802b128 <logf>
 8006e60:	ed86 0a00 	vstr	s0, [r6]
 8006e64:	1f2d      	subs	r5, r5, #4
 8006e66:	1f36      	subs	r6, r6, #4
 8006e68:	42a5      	cmp	r5, r4
 8006e6a:	d2f5      	bcs.n	8006e58 <nl_func_log_array_f32+0x18>
 8006e6c:	bd70      	pop	{r4, r5, r6, pc}
	...

08006e70 <forward_log>:
 8006e70:	b5f0      	push	{r4, r5, r6, r7, lr}
 8006e72:	b081      	sub	sp, #4
 8006e74:	6942      	ldr	r2, [r0, #20]
 8006e76:	8811      	ldrh	r1, [r2, #0]
 8006e78:	2900      	cmp	r1, #0
 8006e7a:	bf1a      	itte	ne
 8006e7c:	6850      	ldrne	r0, [r2, #4]
 8006e7e:	1d00      	addne	r0, r0, #4
 8006e80:	2004      	moveq	r0, #4
 8006e82:	f04f 0501 	mov.w	r5, #1
 8006e86:	6800      	ldr	r0, [r0, #0]
 8006e88:	2800      	cmp	r0, #0
 8006e8a:	bf14      	ite	ne
 8006e8c:	6803      	ldrne	r3, [r0, #0]
 8006e8e:	2300      	moveq	r3, #0
 8006e90:	2902      	cmp	r1, #2
 8006e92:	bfa6      	itte	ge
 8006e94:	6850      	ldrge	r0, [r2, #4]
 8006e96:	3010      	addge	r0, #16
 8006e98:	2004      	movlt	r0, #4
 8006e9a:	6800      	ldr	r0, [r0, #0]
 8006e9c:	2800      	cmp	r0, #0
 8006e9e:	bf19      	ittee	ne
 8006ea0:	6800      	ldrne	r0, [r0, #0]
 8006ea2:	f100 0418 	addne.w	r4, r0, #24
 8006ea6:	2100      	moveq	r1, #0
 8006ea8:	f101 0418 	addeq.w	r4, r1, #24
 8006eac:	f103 0108 	add.w	r1, r3, #8
 8006eb0:	680a      	ldr	r2, [r1, #0]
 8006eb2:	0a12      	lsrs	r2, r2, #8
 8006eb4:	d01e      	beq.n	8006ef4 <forward_log+0x84>
 8006eb6:	684e      	ldr	r6, [r1, #4]
 8006eb8:	eb06 0182 	add.w	r1, r6, r2, lsl #2
 8006ebc:	4610      	mov	r0, r2
 8006ebe:	1f0f      	subs	r7, r1, #4
 8006ec0:	f010 0103 	ands.w	r1, r0, #3
 8006ec4:	d006      	beq.n	8006ed4 <forward_log+0x64>
 8006ec6:	1e52      	subs	r2, r2, #1
 8006ec8:	f857 c904 	ldr.w	ip, [r7], #-4
 8006ecc:	1e49      	subs	r1, r1, #1
 8006ece:	fb0c f505 	mul.w	r5, ip, r5
 8006ed2:	d1f8      	bne.n	8006ec6 <forward_log+0x56>
 8006ed4:	0880      	lsrs	r0, r0, #2
 8006ed6:	d00d      	beq.n	8006ef4 <forward_log+0x84>
 8006ed8:	eb06 0182 	add.w	r1, r6, r2, lsl #2
 8006edc:	3910      	subs	r1, #16
 8006ede:	68ca      	ldr	r2, [r1, #12]
 8006ee0:	688e      	ldr	r6, [r1, #8]
 8006ee2:	684f      	ldr	r7, [r1, #4]
 8006ee4:	4372      	muls	r2, r6
 8006ee6:	f851 6910 	ldr.w	r6, [r1], #-16
 8006eea:	437a      	muls	r2, r7
 8006eec:	4372      	muls	r2, r6
 8006eee:	4355      	muls	r5, r2
 8006ef0:	1e40      	subs	r0, r0, #1
 8006ef2:	d1f4      	bne.n	8006ede <forward_log+0x6e>
 8006ef4:	6998      	ldr	r0, [r3, #24]
 8006ef6:	6886      	ldr	r6, [r0, #8]
 8006ef8:	6821      	ldr	r1, [r4, #0]
 8006efa:	eb06 0085 	add.w	r0, r6, r5, lsl #2
 8006efe:	1f07      	subs	r7, r0, #4
 8006f00:	6888      	ldr	r0, [r1, #8]
 8006f02:	eb00 0285 	add.w	r2, r0, r5, lsl #2
 8006f06:	1f14      	subs	r4, r2, #4
 8006f08:	42b7      	cmp	r7, r6
 8006f0a:	d309      	bcc.n	8006f20 <forward_log+0xb0>
 8006f0c:	ed97 0a00 	vldr	s0, [r7]
 8006f10:	f024 f90a 	bl	802b128 <logf>
 8006f14:	ed84 0a00 	vstr	s0, [r4]
 8006f18:	1f3f      	subs	r7, r7, #4
 8006f1a:	1f24      	subs	r4, r4, #4
 8006f1c:	42b7      	cmp	r7, r6
 8006f1e:	d2f5      	bcs.n	8006f0c <forward_log+0x9c>
 8006f20:	b001      	add	sp, #4
 8006f22:	bdf0      	pop	{r4, r5, r6, r7, pc}

08006f24 <nl_func_rsqrt_array_f32>:
 8006f24:	b570      	push	{r4, r5, r6, lr}
 8006f26:	460c      	mov	r4, r1
 8006f28:	6880      	ldr	r0, [r0, #8]
 8006f2a:	68a1      	ldr	r1, [r4, #8]
 8006f2c:	eb01 0382 	add.w	r3, r1, r2, lsl #2
 8006f30:	eb00 0282 	add.w	r2, r0, r2, lsl #2
 8006f34:	1f1d      	subs	r5, r3, #4
 8006f36:	1f16      	subs	r6, r2, #4
 8006f38:	428d      	cmp	r5, r1
 8006f3a:	d30e      	bcc.n	8006f5a <nl_func_rsqrt_array_f32+0x36>
 8006f3c:	ed95 0a00 	vldr	s0, [r5]
 8006f40:	f003 f95a 	bl	800a1f8 <ai_math_sqrt>
 8006f44:	eef7 0a00 	vmov.f32	s1, #112	; 0x3f800000  1.0
 8006f48:	eec0 0a80 	vdiv.f32	s1, s1, s0
 8006f4c:	edc6 0a00 	vstr	s1, [r6]
 8006f50:	1f2d      	subs	r5, r5, #4
 8006f52:	68a0      	ldr	r0, [r4, #8]
 8006f54:	1f36      	subs	r6, r6, #4
 8006f56:	4285      	cmp	r5, r0
 8006f58:	d2f0      	bcs.n	8006f3c <nl_func_rsqrt_array_f32+0x18>
 8006f5a:	bd70      	pop	{r4, r5, r6, pc}

08006f5c <forward_rsqrt>:
 8006f5c:	b5f0      	push	{r4, r5, r6, r7, lr}
 8006f5e:	b081      	sub	sp, #4
 8006f60:	6942      	ldr	r2, [r0, #20]
 8006f62:	8811      	ldrh	r1, [r2, #0]
 8006f64:	2900      	cmp	r1, #0
 8006f66:	bf1a      	itte	ne
 8006f68:	6850      	ldrne	r0, [r2, #4]
 8006f6a:	1d00      	addne	r0, r0, #4
 8006f6c:	2004      	moveq	r0, #4
 8006f6e:	f04f 0501 	mov.w	r5, #1
 8006f72:	6800      	ldr	r0, [r0, #0]
 8006f74:	2800      	cmp	r0, #0
 8006f76:	bf14      	ite	ne
 8006f78:	6803      	ldrne	r3, [r0, #0]
 8006f7a:	2300      	moveq	r3, #0
 8006f7c:	2902      	cmp	r1, #2
 8006f7e:	bfa6      	itte	ge
 8006f80:	6850      	ldrge	r0, [r2, #4]
 8006f82:	3010      	addge	r0, #16
 8006f84:	2004      	movlt	r0, #4
 8006f86:	6800      	ldr	r0, [r0, #0]
 8006f88:	2800      	cmp	r0, #0
 8006f8a:	bf19      	ittee	ne
 8006f8c:	6800      	ldrne	r0, [r0, #0]
 8006f8e:	f100 0418 	addne.w	r4, r0, #24
 8006f92:	2100      	moveq	r1, #0
 8006f94:	f101 0418 	addeq.w	r4, r1, #24
 8006f98:	f103 0108 	add.w	r1, r3, #8
 8006f9c:	680a      	ldr	r2, [r1, #0]
 8006f9e:	0a12      	lsrs	r2, r2, #8
 8006fa0:	d01e      	beq.n	8006fe0 <forward_rsqrt+0x84>
 8006fa2:	684e      	ldr	r6, [r1, #4]
 8006fa4:	eb06 0182 	add.w	r1, r6, r2, lsl #2
 8006fa8:	4610      	mov	r0, r2
 8006faa:	1f0f      	subs	r7, r1, #4
 8006fac:	f010 0103 	ands.w	r1, r0, #3
 8006fb0:	d006      	beq.n	8006fc0 <forward_rsqrt+0x64>
 8006fb2:	1e52      	subs	r2, r2, #1
 8006fb4:	f857 c904 	ldr.w	ip, [r7], #-4
 8006fb8:	1e49      	subs	r1, r1, #1
 8006fba:	fb0c f505 	mul.w	r5, ip, r5
 8006fbe:	d1f8      	bne.n	8006fb2 <forward_rsqrt+0x56>
 8006fc0:	0880      	lsrs	r0, r0, #2
 8006fc2:	d00d      	beq.n	8006fe0 <forward_rsqrt+0x84>
 8006fc4:	eb06 0182 	add.w	r1, r6, r2, lsl #2
 8006fc8:	3910      	subs	r1, #16
 8006fca:	68ca      	ldr	r2, [r1, #12]
 8006fcc:	688e      	ldr	r6, [r1, #8]
 8006fce:	684f      	ldr	r7, [r1, #4]
 8006fd0:	4372      	muls	r2, r6
 8006fd2:	f851 6910 	ldr.w	r6, [r1], #-16
 8006fd6:	437a      	muls	r2, r7
 8006fd8:	4372      	muls	r2, r6
 8006fda:	4355      	muls	r5, r2
 8006fdc:	1e40      	subs	r0, r0, #1
 8006fde:	d1f4      	bne.n	8006fca <forward_rsqrt+0x6e>
 8006fe0:	699e      	ldr	r6, [r3, #24]
 8006fe2:	68b0      	ldr	r0, [r6, #8]
 8006fe4:	6822      	ldr	r2, [r4, #0]
 8006fe6:	eb00 0185 	add.w	r1, r0, r5, lsl #2
 8006fea:	1f0f      	subs	r7, r1, #4
 8006fec:	6891      	ldr	r1, [r2, #8]
 8006fee:	eb01 0385 	add.w	r3, r1, r5, lsl #2
 8006ff2:	1f1c      	subs	r4, r3, #4
 8006ff4:	4287      	cmp	r7, r0
 8006ff6:	d30e      	bcc.n	8007016 <forward_rsqrt+0xba>
 8006ff8:	ed97 0a00 	vldr	s0, [r7]
 8006ffc:	f003 f8fc 	bl	800a1f8 <ai_math_sqrt>
 8007000:	eef7 0a00 	vmov.f32	s1, #112	; 0x3f800000  1.0
 8007004:	eec0 0a80 	vdiv.f32	s1, s1, s0
 8007008:	edc4 0a00 	vstr	s1, [r4]
 800700c:	1f3f      	subs	r7, r7, #4
 800700e:	68b0      	ldr	r0, [r6, #8]
 8007010:	1f24      	subs	r4, r4, #4
 8007012:	4287      	cmp	r7, r0
 8007014:	d2f0      	bcs.n	8006ff8 <forward_rsqrt+0x9c>
 8007016:	b001      	add	sp, #4
 8007018:	bdf0      	pop	{r4, r5, r6, r7, pc}
	...

0800701c <nl_func_sin_array_f32>:
 800701c:	b570      	push	{r4, r5, r6, lr}
 800701e:	688c      	ldr	r4, [r1, #8]
 8007020:	6880      	ldr	r0, [r0, #8]
 8007022:	eb04 0182 	add.w	r1, r4, r2, lsl #2
 8007026:	1f0d      	subs	r5, r1, #4
 8007028:	eb00 0182 	add.w	r1, r0, r2, lsl #2
 800702c:	1f0e      	subs	r6, r1, #4
 800702e:	42a5      	cmp	r5, r4
 8007030:	f0c0 800a 	bcc.w	8007048 <nl_func_sin_array_f32+0x2c>
 8007034:	ed95 0a00 	vldr	s0, [r5]
 8007038:	f023 fe8c 	bl	802ad54 <sinf>
 800703c:	ed86 0a00 	vstr	s0, [r6]
 8007040:	1f2d      	subs	r5, r5, #4
 8007042:	1f36      	subs	r6, r6, #4
 8007044:	42a5      	cmp	r5, r4
 8007046:	d2f5      	bcs.n	8007034 <nl_func_sin_array_f32+0x18>
 8007048:	bd70      	pop	{r4, r5, r6, pc}
	...

0800704c <forward_sin>:
 800704c:	b5f0      	push	{r4, r5, r6, r7, lr}
 800704e:	b081      	sub	sp, #4
 8007050:	6942      	ldr	r2, [r0, #20]
 8007052:	8811      	ldrh	r1, [r2, #0]
 8007054:	2900      	cmp	r1, #0
 8007056:	bf1a      	itte	ne
 8007058:	6850      	ldrne	r0, [r2, #4]
 800705a:	1d00      	addne	r0, r0, #4
 800705c:	2004      	moveq	r0, #4
 800705e:	f04f 0501 	mov.w	r5, #1
 8007062:	6800      	ldr	r0, [r0, #0]
 8007064:	2800      	cmp	r0, #0
 8007066:	bf14      	ite	ne
 8007068:	6803      	ldrne	r3, [r0, #0]
 800706a:	2300      	moveq	r3, #0
 800706c:	2902      	cmp	r1, #2
 800706e:	bfa6      	itte	ge
 8007070:	6850      	ldrge	r0, [r2, #4]
 8007072:	3010      	addge	r0, #16
 8007074:	2004      	movlt	r0, #4
 8007076:	6800      	ldr	r0, [r0, #0]
 8007078:	2800      	cmp	r0, #0
 800707a:	bf19      	ittee	ne
 800707c:	6800      	ldrne	r0, [r0, #0]
 800707e:	f100 0418 	addne.w	r4, r0, #24
 8007082:	2100      	moveq	r1, #0
 8007084:	f101 0418 	addeq.w	r4, r1, #24
 8007088:	f103 0108 	add.w	r1, r3, #8
 800708c:	680a      	ldr	r2, [r1, #0]
 800708e:	0a12      	lsrs	r2, r2, #8
 8007090:	d01e      	beq.n	80070d0 <forward_sin+0x84>
 8007092:	684e      	ldr	r6, [r1, #4]
 8007094:	eb06 0182 	add.w	r1, r6, r2, lsl #2
 8007098:	4610      	mov	r0, r2
 800709a:	1f0f      	subs	r7, r1, #4
 800709c:	f010 0103 	ands.w	r1, r0, #3
 80070a0:	d006      	beq.n	80070b0 <forward_sin+0x64>
 80070a2:	1e52      	subs	r2, r2, #1
 80070a4:	f857 c904 	ldr.w	ip, [r7], #-4
 80070a8:	1e49      	subs	r1, r1, #1
 80070aa:	fb0c f505 	mul.w	r5, ip, r5
 80070ae:	d1f8      	bne.n	80070a2 <forward_sin+0x56>
 80070b0:	0880      	lsrs	r0, r0, #2
 80070b2:	d00d      	beq.n	80070d0 <forward_sin+0x84>
 80070b4:	eb06 0182 	add.w	r1, r6, r2, lsl #2
 80070b8:	3910      	subs	r1, #16
 80070ba:	68ca      	ldr	r2, [r1, #12]
 80070bc:	688e      	ldr	r6, [r1, #8]
 80070be:	684f      	ldr	r7, [r1, #4]
 80070c0:	4372      	muls	r2, r6
 80070c2:	f851 6910 	ldr.w	r6, [r1], #-16
 80070c6:	437a      	muls	r2, r7
 80070c8:	4372      	muls	r2, r6
 80070ca:	4355      	muls	r5, r2
 80070cc:	1e40      	subs	r0, r0, #1
 80070ce:	d1f4      	bne.n	80070ba <forward_sin+0x6e>
 80070d0:	6998      	ldr	r0, [r3, #24]
 80070d2:	6886      	ldr	r6, [r0, #8]
 80070d4:	6821      	ldr	r1, [r4, #0]
 80070d6:	eb06 0085 	add.w	r0, r6, r5, lsl #2
 80070da:	1f07      	subs	r7, r0, #4
 80070dc:	6888      	ldr	r0, [r1, #8]
 80070de:	eb00 0285 	add.w	r2, r0, r5, lsl #2
 80070e2:	1f14      	subs	r4, r2, #4
 80070e4:	42b7      	cmp	r7, r6
 80070e6:	d309      	bcc.n	80070fc <forward_sin+0xb0>
 80070e8:	ed97 0a00 	vldr	s0, [r7]
 80070ec:	f023 fe32 	bl	802ad54 <sinf>
 80070f0:	ed84 0a00 	vstr	s0, [r4]
 80070f4:	1f3f      	subs	r7, r7, #4
 80070f6:	1f24      	subs	r4, r4, #4
 80070f8:	42b7      	cmp	r7, r6
 80070fa:	d2f5      	bcs.n	80070e8 <forward_sin+0x9c>
 80070fc:	b001      	add	sp, #4
 80070fe:	bdf0      	pop	{r4, r5, r6, r7, pc}

08007100 <nl_func_sinh_array_f32>:
 8007100:	b570      	push	{r4, r5, r6, lr}
 8007102:	688c      	ldr	r4, [r1, #8]
 8007104:	6880      	ldr	r0, [r0, #8]
 8007106:	eb04 0182 	add.w	r1, r4, r2, lsl #2
 800710a:	1f0d      	subs	r5, r1, #4
 800710c:	eb00 0182 	add.w	r1, r0, r2, lsl #2
 8007110:	1f0e      	subs	r6, r1, #4
 8007112:	42a5      	cmp	r5, r4
 8007114:	f0c0 800a 	bcc.w	800712c <nl_func_sinh_array_f32+0x2c>
 8007118:	ed95 0a00 	vldr	s0, [r5]
 800711c:	f024 f8b8 	bl	802b290 <sinhf>
 8007120:	ed86 0a00 	vstr	s0, [r6]
 8007124:	1f2d      	subs	r5, r5, #4
 8007126:	1f36      	subs	r6, r6, #4
 8007128:	42a5      	cmp	r5, r4
 800712a:	d2f5      	bcs.n	8007118 <nl_func_sinh_array_f32+0x18>
 800712c:	bd70      	pop	{r4, r5, r6, pc}
	...

08007130 <forward_sinh>:
 8007130:	b5f0      	push	{r4, r5, r6, r7, lr}
 8007132:	b081      	sub	sp, #4
 8007134:	6942      	ldr	r2, [r0, #20]
 8007136:	8811      	ldrh	r1, [r2, #0]
 8007138:	2900      	cmp	r1, #0
 800713a:	bf1a      	itte	ne
 800713c:	6850      	ldrne	r0, [r2, #4]
 800713e:	1d00      	addne	r0, r0, #4
 8007140:	2004      	moveq	r0, #4
 8007142:	f04f 0501 	mov.w	r5, #1
 8007146:	6800      	ldr	r0, [r0, #0]
 8007148:	2800      	cmp	r0, #0
 800714a:	bf14      	ite	ne
 800714c:	6803      	ldrne	r3, [r0, #0]
 800714e:	2300      	moveq	r3, #0
 8007150:	2902      	cmp	r1, #2
 8007152:	bfa6      	itte	ge
 8007154:	6850      	ldrge	r0, [r2, #4]
 8007156:	3010      	addge	r0, #16
 8007158:	2004      	movlt	r0, #4
 800715a:	6800      	ldr	r0, [r0, #0]
 800715c:	2800      	cmp	r0, #0
 800715e:	bf19      	ittee	ne
 8007160:	6800      	ldrne	r0, [r0, #0]
 8007162:	f100 0418 	addne.w	r4, r0, #24
 8007166:	2100      	moveq	r1, #0
 8007168:	f101 0418 	addeq.w	r4, r1, #24
 800716c:	f103 0108 	add.w	r1, r3, #8
 8007170:	680a      	ldr	r2, [r1, #0]
 8007172:	0a12      	lsrs	r2, r2, #8
 8007174:	d01e      	beq.n	80071b4 <forward_sinh+0x84>
 8007176:	684e      	ldr	r6, [r1, #4]
 8007178:	eb06 0182 	add.w	r1, r6, r2, lsl #2
 800717c:	4610      	mov	r0, r2
 800717e:	1f0f      	subs	r7, r1, #4
 8007180:	f010 0103 	ands.w	r1, r0, #3
 8007184:	d006      	beq.n	8007194 <forward_sinh+0x64>
 8007186:	1e52      	subs	r2, r2, #1
 8007188:	f857 c904 	ldr.w	ip, [r7], #-4
 800718c:	1e49      	subs	r1, r1, #1
 800718e:	fb0c f505 	mul.w	r5, ip, r5
 8007192:	d1f8      	bne.n	8007186 <forward_sinh+0x56>
 8007194:	0880      	lsrs	r0, r0, #2
 8007196:	d00d      	beq.n	80071b4 <forward_sinh+0x84>
 8007198:	eb06 0182 	add.w	r1, r6, r2, lsl #2
 800719c:	3910      	subs	r1, #16
 800719e:	68ca      	ldr	r2, [r1, #12]
 80071a0:	688e      	ldr	r6, [r1, #8]
 80071a2:	684f      	ldr	r7, [r1, #4]
 80071a4:	4372      	muls	r2, r6
 80071a6:	f851 6910 	ldr.w	r6, [r1], #-16
 80071aa:	437a      	muls	r2, r7
 80071ac:	4372      	muls	r2, r6
 80071ae:	4355      	muls	r5, r2
 80071b0:	1e40      	subs	r0, r0, #1
 80071b2:	d1f4      	bne.n	800719e <forward_sinh+0x6e>
 80071b4:	6998      	ldr	r0, [r3, #24]
 80071b6:	6886      	ldr	r6, [r0, #8]
 80071b8:	6821      	ldr	r1, [r4, #0]
 80071ba:	eb06 0085 	add.w	r0, r6, r5, lsl #2
 80071be:	1f07      	subs	r7, r0, #4
 80071c0:	6888      	ldr	r0, [r1, #8]
 80071c2:	eb00 0285 	add.w	r2, r0, r5, lsl #2
 80071c6:	1f14      	subs	r4, r2, #4
 80071c8:	42b7      	cmp	r7, r6
 80071ca:	d309      	bcc.n	80071e0 <forward_sinh+0xb0>
 80071cc:	ed97 0a00 	vldr	s0, [r7]
 80071d0:	f024 f85e 	bl	802b290 <sinhf>
 80071d4:	ed84 0a00 	vstr	s0, [r4]
 80071d8:	1f3f      	subs	r7, r7, #4
 80071da:	1f24      	subs	r4, r4, #4
 80071dc:	42b7      	cmp	r7, r6
 80071de:	d2f5      	bcs.n	80071cc <forward_sinh+0x9c>
 80071e0:	b001      	add	sp, #4
 80071e2:	bdf0      	pop	{r4, r5, r6, r7, pc}

080071e4 <nl_func_tan_array_f32>:
 80071e4:	b570      	push	{r4, r5, r6, lr}
 80071e6:	688c      	ldr	r4, [r1, #8]
 80071e8:	6880      	ldr	r0, [r0, #8]
 80071ea:	eb04 0182 	add.w	r1, r4, r2, lsl #2
 80071ee:	1f0d      	subs	r5, r1, #4
 80071f0:	eb00 0182 	add.w	r1, r0, r2, lsl #2
 80071f4:	1f0e      	subs	r6, r1, #4
 80071f6:	42a5      	cmp	r5, r4
 80071f8:	f0c0 800a 	bcc.w	8007210 <nl_func_tan_array_f32+0x2c>
 80071fc:	ed95 0a00 	vldr	s0, [r5]
 8007200:	f023 fdee 	bl	802ade0 <tanf>
 8007204:	ed86 0a00 	vstr	s0, [r6]
 8007208:	1f2d      	subs	r5, r5, #4
 800720a:	1f36      	subs	r6, r6, #4
 800720c:	42a5      	cmp	r5, r4
 800720e:	d2f5      	bcs.n	80071fc <nl_func_tan_array_f32+0x18>
 8007210:	bd70      	pop	{r4, r5, r6, pc}
	...

08007214 <forward_tan>:
 8007214:	b5f0      	push	{r4, r5, r6, r7, lr}
 8007216:	b081      	sub	sp, #4
 8007218:	6942      	ldr	r2, [r0, #20]
 800721a:	8811      	ldrh	r1, [r2, #0]
 800721c:	2900      	cmp	r1, #0
 800721e:	bf1a      	itte	ne
 8007220:	6850      	ldrne	r0, [r2, #4]
 8007222:	1d00      	addne	r0, r0, #4
 8007224:	2004      	moveq	r0, #4
 8007226:	f04f 0501 	mov.w	r5, #1
 800722a:	6800      	ldr	r0, [r0, #0]
 800722c:	2800      	cmp	r0, #0
 800722e:	bf14      	ite	ne
 8007230:	6803      	ldrne	r3, [r0, #0]
 8007232:	2300      	moveq	r3, #0
 8007234:	2902      	cmp	r1, #2
 8007236:	bfa6      	itte	ge
 8007238:	6850      	ldrge	r0, [r2, #4]
 800723a:	3010      	addge	r0, #16
 800723c:	2004      	movlt	r0, #4
 800723e:	6800      	ldr	r0, [r0, #0]
 8007240:	2800      	cmp	r0, #0
 8007242:	bf19      	ittee	ne
 8007244:	6800      	ldrne	r0, [r0, #0]
 8007246:	f100 0418 	addne.w	r4, r0, #24
 800724a:	2100      	moveq	r1, #0
 800724c:	f101 0418 	addeq.w	r4, r1, #24
 8007250:	f103 0108 	add.w	r1, r3, #8
 8007254:	680a      	ldr	r2, [r1, #0]
 8007256:	0a12      	lsrs	r2, r2, #8
 8007258:	d01e      	beq.n	8007298 <forward_tan+0x84>
 800725a:	684e      	ldr	r6, [r1, #4]
 800725c:	eb06 0182 	add.w	r1, r6, r2, lsl #2
 8007260:	4610      	mov	r0, r2
 8007262:	1f0f      	subs	r7, r1, #4
 8007264:	f010 0103 	ands.w	r1, r0, #3
 8007268:	d006      	beq.n	8007278 <forward_tan+0x64>
 800726a:	1e52      	subs	r2, r2, #1
 800726c:	f857 c904 	ldr.w	ip, [r7], #-4
 8007270:	1e49      	subs	r1, r1, #1
 8007272:	fb0c f505 	mul.w	r5, ip, r5
 8007276:	d1f8      	bne.n	800726a <forward_tan+0x56>
 8007278:	0880      	lsrs	r0, r0, #2
 800727a:	d00d      	beq.n	8007298 <forward_tan+0x84>
 800727c:	eb06 0182 	add.w	r1, r6, r2, lsl #2
 8007280:	3910      	subs	r1, #16
 8007282:	68ca      	ldr	r2, [r1, #12]
 8007284:	688e      	ldr	r6, [r1, #8]
 8007286:	684f      	ldr	r7, [r1, #4]
 8007288:	4372      	muls	r2, r6
 800728a:	f851 6910 	ldr.w	r6, [r1], #-16
 800728e:	437a      	muls	r2, r7
 8007290:	4372      	muls	r2, r6
 8007292:	4355      	muls	r5, r2
 8007294:	1e40      	subs	r0, r0, #1
 8007296:	d1f4      	bne.n	8007282 <forward_tan+0x6e>
 8007298:	6998      	ldr	r0, [r3, #24]
 800729a:	6886      	ldr	r6, [r0, #8]
 800729c:	6821      	ldr	r1, [r4, #0]
 800729e:	eb06 0085 	add.w	r0, r6, r5, lsl #2
 80072a2:	1f07      	subs	r7, r0, #4
 80072a4:	6888      	ldr	r0, [r1, #8]
 80072a6:	eb00 0285 	add.w	r2, r0, r5, lsl #2
 80072aa:	1f14      	subs	r4, r2, #4
 80072ac:	42b7      	cmp	r7, r6
 80072ae:	d309      	bcc.n	80072c4 <forward_tan+0xb0>
 80072b0:	ed97 0a00 	vldr	s0, [r7]
 80072b4:	f023 fd94 	bl	802ade0 <tanf>
 80072b8:	ed84 0a00 	vstr	s0, [r4]
 80072bc:	1f3f      	subs	r7, r7, #4
 80072be:	1f24      	subs	r4, r4, #4
 80072c0:	42b7      	cmp	r7, r6
 80072c2:	d2f5      	bcs.n	80072b0 <forward_tan+0x9c>
 80072c4:	b001      	add	sp, #4
 80072c6:	bdf0      	pop	{r4, r5, r6, r7, pc}

080072c8 <nl_func_abs_array_f32>:
 80072c8:	6889      	ldr	r1, [r1, #8]
 80072ca:	6880      	ldr	r0, [r0, #8]
 80072cc:	eb01 0382 	add.w	r3, r1, r2, lsl #2
 80072d0:	eb00 0282 	add.w	r2, r0, r2, lsl #2
 80072d4:	1f1b      	subs	r3, r3, #4
 80072d6:	1f10      	subs	r0, r2, #4
 80072d8:	428b      	cmp	r3, r1
 80072da:	d307      	bcc.n	80072ec <nl_func_abs_array_f32+0x24>
 80072dc:	f853 c904 	ldr.w	ip, [r3], #-4
 80072e0:	f02c 4200 	bic.w	r2, ip, #2147483648	; 0x80000000
 80072e4:	428b      	cmp	r3, r1
 80072e6:	f840 2904 	str.w	r2, [r0], #-4
 80072ea:	d2f7      	bcs.n	80072dc <nl_func_abs_array_f32+0x14>
 80072ec:	4770      	bx	lr
	...

080072f0 <forward_abs>:
 80072f0:	b4f0      	push	{r4, r5, r6, r7}
 80072f2:	6942      	ldr	r2, [r0, #20]
 80072f4:	8811      	ldrh	r1, [r2, #0]
 80072f6:	2900      	cmp	r1, #0
 80072f8:	bf1a      	itte	ne
 80072fa:	6850      	ldrne	r0, [r2, #4]
 80072fc:	1d00      	addne	r0, r0, #4
 80072fe:	2004      	moveq	r0, #4
 8007300:	f04f 0501 	mov.w	r5, #1
 8007304:	6800      	ldr	r0, [r0, #0]
 8007306:	2800      	cmp	r0, #0
 8007308:	bf14      	ite	ne
 800730a:	6803      	ldrne	r3, [r0, #0]
 800730c:	2300      	moveq	r3, #0
 800730e:	2902      	cmp	r1, #2
 8007310:	bfa6      	itte	ge
 8007312:	6850      	ldrge	r0, [r2, #4]
 8007314:	3010      	addge	r0, #16
 8007316:	2004      	movlt	r0, #4
 8007318:	6800      	ldr	r0, [r0, #0]
 800731a:	2800      	cmp	r0, #0
 800731c:	bf19      	ittee	ne
 800731e:	6800      	ldrne	r0, [r0, #0]
 8007320:	f100 0418 	addne.w	r4, r0, #24
 8007324:	2100      	moveq	r1, #0
 8007326:	f101 0418 	addeq.w	r4, r1, #24
 800732a:	f103 0108 	add.w	r1, r3, #8
 800732e:	680a      	ldr	r2, [r1, #0]
 8007330:	0a12      	lsrs	r2, r2, #8
 8007332:	d01e      	beq.n	8007372 <forward_abs+0x82>
 8007334:	684e      	ldr	r6, [r1, #4]
 8007336:	eb06 0182 	add.w	r1, r6, r2, lsl #2
 800733a:	4610      	mov	r0, r2
 800733c:	1f0f      	subs	r7, r1, #4
 800733e:	f010 0103 	ands.w	r1, r0, #3
 8007342:	d006      	beq.n	8007352 <forward_abs+0x62>
 8007344:	1e52      	subs	r2, r2, #1
 8007346:	f857 c904 	ldr.w	ip, [r7], #-4
 800734a:	1e49      	subs	r1, r1, #1
 800734c:	fb0c f505 	mul.w	r5, ip, r5
 8007350:	d1f8      	bne.n	8007344 <forward_abs+0x54>
 8007352:	0880      	lsrs	r0, r0, #2
 8007354:	d00d      	beq.n	8007372 <forward_abs+0x82>
 8007356:	eb06 0182 	add.w	r1, r6, r2, lsl #2
 800735a:	3910      	subs	r1, #16
 800735c:	68ca      	ldr	r2, [r1, #12]
 800735e:	688e      	ldr	r6, [r1, #8]
 8007360:	684f      	ldr	r7, [r1, #4]
 8007362:	4372      	muls	r2, r6
 8007364:	f851 6910 	ldr.w	r6, [r1], #-16
 8007368:	437a      	muls	r2, r7
 800736a:	4372      	muls	r2, r6
 800736c:	4355      	muls	r5, r2
 800736e:	1e40      	subs	r0, r0, #1
 8007370:	d1f4      	bne.n	800735c <forward_abs+0x6c>
 8007372:	6998      	ldr	r0, [r3, #24]
 8007374:	6822      	ldr	r2, [r4, #0]
 8007376:	6880      	ldr	r0, [r0, #8]
 8007378:	6893      	ldr	r3, [r2, #8]
 800737a:	eb00 0185 	add.w	r1, r0, r5, lsl #2
 800737e:	eb03 0485 	add.w	r4, r3, r5, lsl #2
 8007382:	1f09      	subs	r1, r1, #4
 8007384:	1f22      	subs	r2, r4, #4
 8007386:	4281      	cmp	r1, r0
 8007388:	f0c0 8008 	bcc.w	800739c <forward_abs+0xac>
 800738c:	f851 3904 	ldr.w	r3, [r1], #-4
 8007390:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
 8007394:	4281      	cmp	r1, r0
 8007396:	f842 3904 	str.w	r3, [r2], #-4
 800739a:	d2f7      	bcs.n	800738c <forward_abs+0x9c>
 800739c:	bcf0      	pop	{r4, r5, r6, r7}
 800739e:	4770      	bx	lr

080073a0 <nl_func_ceil_array_f32>:
 80073a0:	b570      	push	{r4, r5, r6, lr}
 80073a2:	688c      	ldr	r4, [r1, #8]
 80073a4:	6880      	ldr	r0, [r0, #8]
 80073a6:	eb04 0182 	add.w	r1, r4, r2, lsl #2
 80073aa:	1f0d      	subs	r5, r1, #4
 80073ac:	eb00 0182 	add.w	r1, r0, r2, lsl #2
 80073b0:	1f0e      	subs	r6, r1, #4
 80073b2:	42a5      	cmp	r5, r4
 80073b4:	f0c0 800a 	bcc.w	80073cc <nl_func_ceil_array_f32+0x2c>
 80073b8:	ed95 0a00 	vldr	s0, [r5]
 80073bc:	f023 f8fe 	bl	802a5bc <ceilf>
 80073c0:	ed86 0a00 	vstr	s0, [r6]
 80073c4:	1f2d      	subs	r5, r5, #4
 80073c6:	1f36      	subs	r6, r6, #4
 80073c8:	42a5      	cmp	r5, r4
 80073ca:	d2f5      	bcs.n	80073b8 <nl_func_ceil_array_f32+0x18>
 80073cc:	bd70      	pop	{r4, r5, r6, pc}
	...

080073d0 <forward_ceil>:
 80073d0:	b5f0      	push	{r4, r5, r6, r7, lr}
 80073d2:	b081      	sub	sp, #4
 80073d4:	6942      	ldr	r2, [r0, #20]
 80073d6:	8811      	ldrh	r1, [r2, #0]
 80073d8:	2900      	cmp	r1, #0
 80073da:	bf1a      	itte	ne
 80073dc:	6850      	ldrne	r0, [r2, #4]
 80073de:	1d00      	addne	r0, r0, #4
 80073e0:	2004      	moveq	r0, #4
 80073e2:	f04f 0501 	mov.w	r5, #1
 80073e6:	6800      	ldr	r0, [r0, #0]
 80073e8:	2800      	cmp	r0, #0
 80073ea:	bf14      	ite	ne
 80073ec:	6803      	ldrne	r3, [r0, #0]
 80073ee:	2300      	moveq	r3, #0
 80073f0:	2902      	cmp	r1, #2
 80073f2:	bfa6      	itte	ge
 80073f4:	6850      	ldrge	r0, [r2, #4]
 80073f6:	3010      	addge	r0, #16
 80073f8:	2004      	movlt	r0, #4
 80073fa:	6800      	ldr	r0, [r0, #0]
 80073fc:	2800      	cmp	r0, #0
 80073fe:	bf19      	ittee	ne
 8007400:	6800      	ldrne	r0, [r0, #0]
 8007402:	f100 0418 	addne.w	r4, r0, #24
 8007406:	2100      	moveq	r1, #0
 8007408:	f101 0418 	addeq.w	r4, r1, #24
 800740c:	f103 0108 	add.w	r1, r3, #8
 8007410:	680a      	ldr	r2, [r1, #0]
 8007412:	0a12      	lsrs	r2, r2, #8
 8007414:	d01e      	beq.n	8007454 <forward_ceil+0x84>
 8007416:	684e      	ldr	r6, [r1, #4]
 8007418:	eb06 0182 	add.w	r1, r6, r2, lsl #2
 800741c:	4610      	mov	r0, r2
 800741e:	1f0f      	subs	r7, r1, #4
 8007420:	f010 0103 	ands.w	r1, r0, #3
 8007424:	d006      	beq.n	8007434 <forward_ceil+0x64>
 8007426:	1e52      	subs	r2, r2, #1
 8007428:	f857 c904 	ldr.w	ip, [r7], #-4
 800742c:	1e49      	subs	r1, r1, #1
 800742e:	fb0c f505 	mul.w	r5, ip, r5
 8007432:	d1f8      	bne.n	8007426 <forward_ceil+0x56>
 8007434:	0880      	lsrs	r0, r0, #2
 8007436:	d00d      	beq.n	8007454 <forward_ceil+0x84>
 8007438:	eb06 0182 	add.w	r1, r6, r2, lsl #2
 800743c:	3910      	subs	r1, #16
 800743e:	68ca      	ldr	r2, [r1, #12]
 8007440:	688e      	ldr	r6, [r1, #8]
 8007442:	684f      	ldr	r7, [r1, #4]
 8007444:	4372      	muls	r2, r6
 8007446:	f851 6910 	ldr.w	r6, [r1], #-16
 800744a:	437a      	muls	r2, r7
 800744c:	4372      	muls	r2, r6
 800744e:	4355      	muls	r5, r2
 8007450:	1e40      	subs	r0, r0, #1
 8007452:	d1f4      	bne.n	800743e <forward_ceil+0x6e>
 8007454:	6998      	ldr	r0, [r3, #24]
 8007456:	6886      	ldr	r6, [r0, #8]
 8007458:	6821      	ldr	r1, [r4, #0]
 800745a:	eb06 0085 	add.w	r0, r6, r5, lsl #2
 800745e:	1f07      	subs	r7, r0, #4
 8007460:	6888      	ldr	r0, [r1, #8]
 8007462:	eb00 0285 	add.w	r2, r0, r5, lsl #2
 8007466:	1f14      	subs	r4, r2, #4
 8007468:	42b7      	cmp	r7, r6
 800746a:	d309      	bcc.n	8007480 <forward_ceil+0xb0>
 800746c:	ed97 0a00 	vldr	s0, [r7]
 8007470:	f023 f8a4 	bl	802a5bc <ceilf>
 8007474:	ed84 0a00 	vstr	s0, [r4]
 8007478:	1f3f      	subs	r7, r7, #4
 800747a:	1f24      	subs	r4, r4, #4
 800747c:	42b7      	cmp	r7, r6
 800747e:	d2f5      	bcs.n	800746c <forward_ceil+0x9c>
 8007480:	b001      	add	sp, #4
 8007482:	bdf0      	pop	{r4, r5, r6, r7, pc}

08007484 <nl_func_floor_array_f32>:
 8007484:	b570      	push	{r4, r5, r6, lr}
 8007486:	688c      	ldr	r4, [r1, #8]
 8007488:	6880      	ldr	r0, [r0, #8]
 800748a:	eb04 0182 	add.w	r1, r4, r2, lsl #2
 800748e:	1f0d      	subs	r5, r1, #4
 8007490:	eb00 0182 	add.w	r1, r0, r2, lsl #2
 8007494:	1f0e      	subs	r6, r1, #4
 8007496:	42a5      	cmp	r5, r4
 8007498:	f0c0 800a 	bcc.w	80074b0 <nl_func_floor_array_f32+0x2c>
 800749c:	ed95 0a00 	vldr	s0, [r5]
 80074a0:	f023 faf4 	bl	802aa8c <floorf>
 80074a4:	ed86 0a00 	vstr	s0, [r6]
 80074a8:	1f2d      	subs	r5, r5, #4
 80074aa:	1f36      	subs	r6, r6, #4
 80074ac:	42a5      	cmp	r5, r4
 80074ae:	d2f5      	bcs.n	800749c <nl_func_floor_array_f32+0x18>
 80074b0:	bd70      	pop	{r4, r5, r6, pc}
	...

080074b4 <forward_floor>:
 80074b4:	b5f0      	push	{r4, r5, r6, r7, lr}
 80074b6:	b081      	sub	sp, #4
 80074b8:	6942      	ldr	r2, [r0, #20]
 80074ba:	8811      	ldrh	r1, [r2, #0]
 80074bc:	2900      	cmp	r1, #0
 80074be:	bf1a      	itte	ne
 80074c0:	6850      	ldrne	r0, [r2, #4]
 80074c2:	1d00      	addne	r0, r0, #4
 80074c4:	2004      	moveq	r0, #4
 80074c6:	f04f 0501 	mov.w	r5, #1
 80074ca:	6800      	ldr	r0, [r0, #0]
 80074cc:	2800      	cmp	r0, #0
 80074ce:	bf14      	ite	ne
 80074d0:	6803      	ldrne	r3, [r0, #0]
 80074d2:	2300      	moveq	r3, #0
 80074d4:	2902      	cmp	r1, #2
 80074d6:	bfa6      	itte	ge
 80074d8:	6850      	ldrge	r0, [r2, #4]
 80074da:	3010      	addge	r0, #16
 80074dc:	2004      	movlt	r0, #4
 80074de:	6800      	ldr	r0, [r0, #0]
 80074e0:	2800      	cmp	r0, #0
 80074e2:	bf19      	ittee	ne
 80074e4:	6800      	ldrne	r0, [r0, #0]
 80074e6:	f100 0418 	addne.w	r4, r0, #24
 80074ea:	2100      	moveq	r1, #0
 80074ec:	f101 0418 	addeq.w	r4, r1, #24
 80074f0:	f103 0108 	add.w	r1, r3, #8
 80074f4:	680a      	ldr	r2, [r1, #0]
 80074f6:	0a12      	lsrs	r2, r2, #8
 80074f8:	d01e      	beq.n	8007538 <forward_floor+0x84>
 80074fa:	684e      	ldr	r6, [r1, #4]
 80074fc:	eb06 0182 	add.w	r1, r6, r2, lsl #2
 8007500:	4610      	mov	r0, r2
 8007502:	1f0f      	subs	r7, r1, #4
 8007504:	f010 0103 	ands.w	r1, r0, #3
 8007508:	d006      	beq.n	8007518 <forward_floor+0x64>
 800750a:	1e52      	subs	r2, r2, #1
 800750c:	f857 c904 	ldr.w	ip, [r7], #-4
 8007510:	1e49      	subs	r1, r1, #1
 8007512:	fb0c f505 	mul.w	r5, ip, r5
 8007516:	d1f8      	bne.n	800750a <forward_floor+0x56>
 8007518:	0880      	lsrs	r0, r0, #2
 800751a:	d00d      	beq.n	8007538 <forward_floor+0x84>
 800751c:	eb06 0182 	add.w	r1, r6, r2, lsl #2
 8007520:	3910      	subs	r1, #16
 8007522:	68ca      	ldr	r2, [r1, #12]
 8007524:	688e      	ldr	r6, [r1, #8]
 8007526:	684f      	ldr	r7, [r1, #4]
 8007528:	4372      	muls	r2, r6
 800752a:	f851 6910 	ldr.w	r6, [r1], #-16
 800752e:	437a      	muls	r2, r7
 8007530:	4372      	muls	r2, r6
 8007532:	4355      	muls	r5, r2
 8007534:	1e40      	subs	r0, r0, #1
 8007536:	d1f4      	bne.n	8007522 <forward_floor+0x6e>
 8007538:	6998      	ldr	r0, [r3, #24]
 800753a:	6886      	ldr	r6, [r0, #8]
 800753c:	6821      	ldr	r1, [r4, #0]
 800753e:	eb06 0085 	add.w	r0, r6, r5, lsl #2
 8007542:	1f07      	subs	r7, r0, #4
 8007544:	6888      	ldr	r0, [r1, #8]
 8007546:	eb00 0285 	add.w	r2, r0, r5, lsl #2
 800754a:	1f14      	subs	r4, r2, #4
 800754c:	42b7      	cmp	r7, r6
 800754e:	d309      	bcc.n	8007564 <forward_floor+0xb0>
 8007550:	ed97 0a00 	vldr	s0, [r7]
 8007554:	f023 fa9a 	bl	802aa8c <floorf>
 8007558:	ed84 0a00 	vstr	s0, [r4]
 800755c:	1f3f      	subs	r7, r7, #4
 800755e:	1f24      	subs	r4, r4, #4
 8007560:	42b7      	cmp	r7, r6
 8007562:	d2f5      	bcs.n	8007550 <forward_floor+0x9c>
 8007564:	b001      	add	sp, #4
 8007566:	bdf0      	pop	{r4, r5, r6, r7, pc}

08007568 <nl_func_round_array_f32>:
 8007568:	b570      	push	{r4, r5, r6, lr}
 800756a:	688c      	ldr	r4, [r1, #8]
 800756c:	6880      	ldr	r0, [r0, #8]
 800756e:	eb04 0182 	add.w	r1, r4, r2, lsl #2
 8007572:	1f0d      	subs	r5, r1, #4
 8007574:	eb00 0182 	add.w	r1, r0, r2, lsl #2
 8007578:	1f0e      	subs	r6, r1, #4
 800757a:	42a5      	cmp	r5, r4
 800757c:	f0c0 800a 	bcc.w	8007594 <nl_func_round_array_f32+0x2c>
 8007580:	ed95 0a00 	vldr	s0, [r5]
 8007584:	f023 fbc2 	bl	802ad0c <roundf>
 8007588:	ed86 0a00 	vstr	s0, [r6]
 800758c:	1f2d      	subs	r5, r5, #4
 800758e:	1f36      	subs	r6, r6, #4
 8007590:	42a5      	cmp	r5, r4
 8007592:	d2f5      	bcs.n	8007580 <nl_func_round_array_f32+0x18>
 8007594:	bd70      	pop	{r4, r5, r6, pc}
	...

08007598 <forward_round>:
 8007598:	b5f0      	push	{r4, r5, r6, r7, lr}
 800759a:	b081      	sub	sp, #4
 800759c:	6942      	ldr	r2, [r0, #20]
 800759e:	8811      	ldrh	r1, [r2, #0]
 80075a0:	2900      	cmp	r1, #0
 80075a2:	bf1a      	itte	ne
 80075a4:	6850      	ldrne	r0, [r2, #4]
 80075a6:	1d00      	addne	r0, r0, #4
 80075a8:	2004      	moveq	r0, #4
 80075aa:	f04f 0501 	mov.w	r5, #1
 80075ae:	6800      	ldr	r0, [r0, #0]
 80075b0:	2800      	cmp	r0, #0
 80075b2:	bf14      	ite	ne
 80075b4:	6803      	ldrne	r3, [r0, #0]
 80075b6:	2300      	moveq	r3, #0
 80075b8:	2902      	cmp	r1, #2
 80075ba:	bfa6      	itte	ge
 80075bc:	6850      	ldrge	r0, [r2, #4]
 80075be:	3010      	addge	r0, #16
 80075c0:	2004      	movlt	r0, #4
 80075c2:	6800      	ldr	r0, [r0, #0]
 80075c4:	2800      	cmp	r0, #0
 80075c6:	bf19      	ittee	ne
 80075c8:	6800      	ldrne	r0, [r0, #0]
 80075ca:	f100 0418 	addne.w	r4, r0, #24
 80075ce:	2100      	moveq	r1, #0
 80075d0:	f101 0418 	addeq.w	r4, r1, #24
 80075d4:	f103 0108 	add.w	r1, r3, #8
 80075d8:	680a      	ldr	r2, [r1, #0]
 80075da:	0a12      	lsrs	r2, r2, #8
 80075dc:	d01e      	beq.n	800761c <forward_round+0x84>
 80075de:	684e      	ldr	r6, [r1, #4]
 80075e0:	eb06 0182 	add.w	r1, r6, r2, lsl #2
 80075e4:	4610      	mov	r0, r2
 80075e6:	1f0f      	subs	r7, r1, #4
 80075e8:	f010 0103 	ands.w	r1, r0, #3
 80075ec:	d006      	beq.n	80075fc <forward_round+0x64>
 80075ee:	1e52      	subs	r2, r2, #1
 80075f0:	f857 c904 	ldr.w	ip, [r7], #-4
 80075f4:	1e49      	subs	r1, r1, #1
 80075f6:	fb0c f505 	mul.w	r5, ip, r5
 80075fa:	d1f8      	bne.n	80075ee <forward_round+0x56>
 80075fc:	0880      	lsrs	r0, r0, #2
 80075fe:	d00d      	beq.n	800761c <forward_round+0x84>
 8007600:	eb06 0182 	add.w	r1, r6, r2, lsl #2
 8007604:	3910      	subs	r1, #16
 8007606:	68ca      	ldr	r2, [r1, #12]
 8007608:	688e      	ldr	r6, [r1, #8]
 800760a:	684f      	ldr	r7, [r1, #4]
 800760c:	4372      	muls	r2, r6
 800760e:	f851 6910 	ldr.w	r6, [r1], #-16
 8007612:	437a      	muls	r2, r7
 8007614:	4372      	muls	r2, r6
 8007616:	4355      	muls	r5, r2
 8007618:	1e40      	subs	r0, r0, #1
 800761a:	d1f4      	bne.n	8007606 <forward_round+0x6e>
 800761c:	6998      	ldr	r0, [r3, #24]
 800761e:	6886      	ldr	r6, [r0, #8]
 8007620:	6821      	ldr	r1, [r4, #0]
 8007622:	eb06 0085 	add.w	r0, r6, r5, lsl #2
 8007626:	1f07      	subs	r7, r0, #4
 8007628:	6888      	ldr	r0, [r1, #8]
 800762a:	eb00 0285 	add.w	r2, r0, r5, lsl #2
 800762e:	1f14      	subs	r4, r2, #4
 8007630:	42b7      	cmp	r7, r6
 8007632:	d309      	bcc.n	8007648 <forward_round+0xb0>
 8007634:	ed97 0a00 	vldr	s0, [r7]
 8007638:	f023 fb68 	bl	802ad0c <roundf>
 800763c:	ed84 0a00 	vstr	s0, [r4]
 8007640:	1f3f      	subs	r7, r7, #4
 8007642:	1f24      	subs	r4, r4, #4
 8007644:	42b7      	cmp	r7, r6
 8007646:	d2f5      	bcs.n	8007634 <forward_round+0x9c>
 8007648:	b001      	add	sp, #4
 800764a:	bdf0      	pop	{r4, r5, r6, r7, pc}

0800764c <nl_func_neg_array_f32>:
 800764c:	6889      	ldr	r1, [r1, #8]
 800764e:	6880      	ldr	r0, [r0, #8]
 8007650:	eb01 0382 	add.w	r3, r1, r2, lsl #2
 8007654:	eb00 0282 	add.w	r2, r0, r2, lsl #2
 8007658:	1f1b      	subs	r3, r3, #4
 800765a:	1f12      	subs	r2, r2, #4
 800765c:	428b      	cmp	r3, r1
 800765e:	d32b      	bcc.n	80076b8 <nl_func_neg_array_f32+0x6c>
 8007660:	eebf 0a00 	vmov.f32	s0, #240	; 0xbf800000 -1.0
 8007664:	edd3 0a00 	vldr	s1, [r3]
 8007668:	1f18      	subs	r0, r3, #4
 800766a:	ee60 0a80 	vmul.f32	s1, s1, s0
 800766e:	4288      	cmp	r0, r1
 8007670:	edc2 0a00 	vstr	s1, [r2]
 8007674:	d320      	bcc.n	80076b8 <nl_func_neg_array_f32+0x6c>
 8007676:	ed90 1a00 	vldr	s2, [r0]
 800767a:	1f13      	subs	r3, r2, #4
 800767c:	1f00      	subs	r0, r0, #4
 800767e:	ee21 1a00 	vmul.f32	s2, s2, s0
 8007682:	4288      	cmp	r0, r1
 8007684:	ed83 1a00 	vstr	s2, [r3]
 8007688:	d316      	bcc.n	80076b8 <nl_func_neg_array_f32+0x6c>
 800768a:	edd0 0a00 	vldr	s1, [r0]
 800768e:	f1a2 0308 	sub.w	r3, r2, #8
 8007692:	1f00      	subs	r0, r0, #4
 8007694:	ee60 0a80 	vmul.f32	s1, s1, s0
 8007698:	4288      	cmp	r0, r1
 800769a:	edc3 0a00 	vstr	s1, [r3]
 800769e:	d30b      	bcc.n	80076b8 <nl_func_neg_array_f32+0x6c>
 80076a0:	ed90 1a00 	vldr	s2, [r0]
 80076a4:	f1a2 030c 	sub.w	r3, r2, #12
 80076a8:	ee61 0a00 	vmul.f32	s1, s2, s0
 80076ac:	edc3 0a00 	vstr	s1, [r3]
 80076b0:	1f03      	subs	r3, r0, #4
 80076b2:	3a10      	subs	r2, #16
 80076b4:	428b      	cmp	r3, r1
 80076b6:	d2d5      	bcs.n	8007664 <nl_func_neg_array_f32+0x18>
 80076b8:	4770      	bx	lr
	...

080076bc <forward_neg>:
 80076bc:	b4f0      	push	{r4, r5, r6, r7}
 80076be:	6942      	ldr	r2, [r0, #20]
 80076c0:	8811      	ldrh	r1, [r2, #0]
 80076c2:	2900      	cmp	r1, #0
 80076c4:	bf1a      	itte	ne
 80076c6:	6850      	ldrne	r0, [r2, #4]
 80076c8:	1d00      	addne	r0, r0, #4
 80076ca:	2004      	moveq	r0, #4
 80076cc:	f04f 0501 	mov.w	r5, #1
 80076d0:	6800      	ldr	r0, [r0, #0]
 80076d2:	2800      	cmp	r0, #0
 80076d4:	bf14      	ite	ne
 80076d6:	6803      	ldrne	r3, [r0, #0]
 80076d8:	2300      	moveq	r3, #0
 80076da:	2902      	cmp	r1, #2
 80076dc:	bfa6      	itte	ge
 80076de:	6850      	ldrge	r0, [r2, #4]
 80076e0:	3010      	addge	r0, #16
 80076e2:	2004      	movlt	r0, #4
 80076e4:	6800      	ldr	r0, [r0, #0]
 80076e6:	2800      	cmp	r0, #0
 80076e8:	bf19      	ittee	ne
 80076ea:	6800      	ldrne	r0, [r0, #0]
 80076ec:	f100 0418 	addne.w	r4, r0, #24
 80076f0:	2100      	moveq	r1, #0
 80076f2:	f101 0418 	addeq.w	r4, r1, #24
 80076f6:	f103 0108 	add.w	r1, r3, #8
 80076fa:	680a      	ldr	r2, [r1, #0]
 80076fc:	0a12      	lsrs	r2, r2, #8
 80076fe:	d01e      	beq.n	800773e <forward_neg+0x82>
 8007700:	684e      	ldr	r6, [r1, #4]
 8007702:	eb06 0182 	add.w	r1, r6, r2, lsl #2
 8007706:	4610      	mov	r0, r2
 8007708:	1f0f      	subs	r7, r1, #4
 800770a:	f010 0103 	ands.w	r1, r0, #3
 800770e:	d006      	beq.n	800771e <forward_neg+0x62>
 8007710:	1e52      	subs	r2, r2, #1
 8007712:	f857 c904 	ldr.w	ip, [r7], #-4
 8007716:	1e49      	subs	r1, r1, #1
 8007718:	fb0c f505 	mul.w	r5, ip, r5
 800771c:	d1f8      	bne.n	8007710 <forward_neg+0x54>
 800771e:	0880      	lsrs	r0, r0, #2
 8007720:	d00d      	beq.n	800773e <forward_neg+0x82>
 8007722:	eb06 0182 	add.w	r1, r6, r2, lsl #2
 8007726:	3910      	subs	r1, #16
 8007728:	68ca      	ldr	r2, [r1, #12]
 800772a:	688e      	ldr	r6, [r1, #8]
 800772c:	684f      	ldr	r7, [r1, #4]
 800772e:	4372      	muls	r2, r6
 8007730:	f851 6910 	ldr.w	r6, [r1], #-16
 8007734:	437a      	muls	r2, r7
 8007736:	4372      	muls	r2, r6
 8007738:	4355      	muls	r5, r2
 800773a:	1e40      	subs	r0, r0, #1
 800773c:	d1f4      	bne.n	8007728 <forward_neg+0x6c>
 800773e:	6998      	ldr	r0, [r3, #24]
 8007740:	6822      	ldr	r2, [r4, #0]
 8007742:	6880      	ldr	r0, [r0, #8]
 8007744:	6893      	ldr	r3, [r2, #8]
 8007746:	eb00 0185 	add.w	r1, r0, r5, lsl #2
 800774a:	eb03 0485 	add.w	r4, r3, r5, lsl #2
 800774e:	1f09      	subs	r1, r1, #4
 8007750:	1f22      	subs	r2, r4, #4
 8007752:	4281      	cmp	r1, r0
 8007754:	f0c0 802c 	bcc.w	80077b0 <forward_neg+0xf4>
 8007758:	eebf 0a00 	vmov.f32	s0, #240	; 0xbf800000 -1.0
 800775c:	edd1 0a00 	vldr	s1, [r1]
 8007760:	1f09      	subs	r1, r1, #4
 8007762:	ee60 0a80 	vmul.f32	s1, s1, s0
 8007766:	4281      	cmp	r1, r0
 8007768:	edc2 0a00 	vstr	s1, [r2]
 800776c:	d320      	bcc.n	80077b0 <forward_neg+0xf4>
 800776e:	ed91 1a00 	vldr	s2, [r1]
 8007772:	1f13      	subs	r3, r2, #4
 8007774:	1f09      	subs	r1, r1, #4
 8007776:	ee21 1a00 	vmul.f32	s2, s2, s0
 800777a:	4281      	cmp	r1, r0
 800777c:	ed83 1a00 	vstr	s2, [r3]
 8007780:	d316      	bcc.n	80077b0 <forward_neg+0xf4>
 8007782:	edd1 0a00 	vldr	s1, [r1]
 8007786:	f1a2 0308 	sub.w	r3, r2, #8
 800778a:	1f09      	subs	r1, r1, #4
 800778c:	ee60 0a80 	vmul.f32	s1, s1, s0
 8007790:	4281      	cmp	r1, r0
 8007792:	edc3 0a00 	vstr	s1, [r3]
 8007796:	d30b      	bcc.n	80077b0 <forward_neg+0xf4>
 8007798:	ed91 1a00 	vldr	s2, [r1]
 800779c:	f1a2 030c 	sub.w	r3, r2, #12
 80077a0:	1f09      	subs	r1, r1, #4
 80077a2:	3a10      	subs	r2, #16
 80077a4:	ee61 0a00 	vmul.f32	s1, s2, s0
 80077a8:	4281      	cmp	r1, r0
 80077aa:	edc3 0a00 	vstr	s1, [r3]
 80077ae:	d2d5      	bcs.n	800775c <forward_neg+0xa0>
 80077b0:	bcf0      	pop	{r4, r5, r6, r7}
 80077b2:	4770      	bx	lr

080077b4 <nl_func_reciprocal_array_f32>:
 80077b4:	6889      	ldr	r1, [r1, #8]
 80077b6:	6880      	ldr	r0, [r0, #8]
 80077b8:	eb01 0382 	add.w	r3, r1, r2, lsl #2
 80077bc:	eb00 0282 	add.w	r2, r0, r2, lsl #2
 80077c0:	1f1b      	subs	r3, r3, #4
 80077c2:	1f12      	subs	r2, r2, #4
 80077c4:	428b      	cmp	r3, r1
 80077c6:	d331      	bcc.n	800782c <nl_func_reciprocal_array_f32+0x78>
 80077c8:	ed93 0a00 	vldr	s0, [r3]
 80077cc:	eef7 0a00 	vmov.f32	s1, #112	; 0x3f800000  1.0
 80077d0:	1f18      	subs	r0, r3, #4
 80077d2:	ee80 0a80 	vdiv.f32	s0, s1, s0
 80077d6:	4288      	cmp	r0, r1
 80077d8:	ed82 0a00 	vstr	s0, [r2]
 80077dc:	d326      	bcc.n	800782c <nl_func_reciprocal_array_f32+0x78>
 80077de:	edd0 0a00 	vldr	s1, [r0]
 80077e2:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
 80077e6:	1f13      	subs	r3, r2, #4
 80077e8:	1f00      	subs	r0, r0, #4
 80077ea:	ee80 0a20 	vdiv.f32	s0, s0, s1
 80077ee:	4288      	cmp	r0, r1
 80077f0:	ed83 0a00 	vstr	s0, [r3]
 80077f4:	d31a      	bcc.n	800782c <nl_func_reciprocal_array_f32+0x78>
 80077f6:	ed90 0a00 	vldr	s0, [r0]
 80077fa:	eef7 0a00 	vmov.f32	s1, #112	; 0x3f800000  1.0
 80077fe:	f1a2 0308 	sub.w	r3, r2, #8
 8007802:	1f00      	subs	r0, r0, #4
 8007804:	ee80 0a80 	vdiv.f32	s0, s1, s0
 8007808:	4288      	cmp	r0, r1
 800780a:	ed83 0a00 	vstr	s0, [r3]
 800780e:	d30d      	bcc.n	800782c <nl_func_reciprocal_array_f32+0x78>
 8007810:	edd0 0a00 	vldr	s1, [r0]
 8007814:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
 8007818:	f1a2 030c 	sub.w	r3, r2, #12
 800781c:	ee80 0a20 	vdiv.f32	s0, s0, s1
 8007820:	ed83 0a00 	vstr	s0, [r3]
 8007824:	1f03      	subs	r3, r0, #4
 8007826:	3a10      	subs	r2, #16
 8007828:	428b      	cmp	r3, r1
 800782a:	d2cd      	bcs.n	80077c8 <nl_func_reciprocal_array_f32+0x14>
 800782c:	4770      	bx	lr
	...

08007830 <forward_reciprocal>:
 8007830:	b4f0      	push	{r4, r5, r6, r7}
 8007832:	6942      	ldr	r2, [r0, #20]
 8007834:	8811      	ldrh	r1, [r2, #0]
 8007836:	2900      	cmp	r1, #0
 8007838:	bf1a      	itte	ne
 800783a:	6850      	ldrne	r0, [r2, #4]
 800783c:	1d00      	addne	r0, r0, #4
 800783e:	2004      	moveq	r0, #4
 8007840:	f04f 0501 	mov.w	r5, #1
 8007844:	6800      	ldr	r0, [r0, #0]
 8007846:	2800      	cmp	r0, #0
 8007848:	bf14      	ite	ne
 800784a:	6803      	ldrne	r3, [r0, #0]
 800784c:	2300      	moveq	r3, #0
 800784e:	2902      	cmp	r1, #2
 8007850:	bfa6      	itte	ge
 8007852:	6850      	ldrge	r0, [r2, #4]
 8007854:	3010      	addge	r0, #16
 8007856:	2004      	movlt	r0, #4
 8007858:	6800      	ldr	r0, [r0, #0]
 800785a:	2800      	cmp	r0, #0
 800785c:	bf19      	ittee	ne
 800785e:	6800      	ldrne	r0, [r0, #0]
 8007860:	f100 0418 	addne.w	r4, r0, #24
 8007864:	2100      	moveq	r1, #0
 8007866:	f101 0418 	addeq.w	r4, r1, #24
 800786a:	f103 0108 	add.w	r1, r3, #8
 800786e:	680a      	ldr	r2, [r1, #0]
 8007870:	0a12      	lsrs	r2, r2, #8
 8007872:	d01e      	beq.n	80078b2 <forward_reciprocal+0x82>
 8007874:	684e      	ldr	r6, [r1, #4]
 8007876:	eb06 0182 	add.w	r1, r6, r2, lsl #2
 800787a:	4610      	mov	r0, r2
 800787c:	1f0f      	subs	r7, r1, #4
 800787e:	f010 0103 	ands.w	r1, r0, #3
 8007882:	d006      	beq.n	8007892 <forward_reciprocal+0x62>
 8007884:	1e52      	subs	r2, r2, #1
 8007886:	f857 c904 	ldr.w	ip, [r7], #-4
 800788a:	1e49      	subs	r1, r1, #1
 800788c:	fb0c f505 	mul.w	r5, ip, r5
 8007890:	d1f8      	bne.n	8007884 <forward_reciprocal+0x54>
 8007892:	0880      	lsrs	r0, r0, #2
 8007894:	d00d      	beq.n	80078b2 <forward_reciprocal+0x82>
 8007896:	eb06 0182 	add.w	r1, r6, r2, lsl #2
 800789a:	3910      	subs	r1, #16
 800789c:	68ca      	ldr	r2, [r1, #12]
 800789e:	688e      	ldr	r6, [r1, #8]
 80078a0:	684f      	ldr	r7, [r1, #4]
 80078a2:	4372      	muls	r2, r6
 80078a4:	f851 6910 	ldr.w	r6, [r1], #-16
 80078a8:	437a      	muls	r2, r7
 80078aa:	4372      	muls	r2, r6
 80078ac:	4355      	muls	r5, r2
 80078ae:	1e40      	subs	r0, r0, #1
 80078b0:	d1f4      	bne.n	800789c <forward_reciprocal+0x6c>
 80078b2:	6998      	ldr	r0, [r3, #24]
 80078b4:	6822      	ldr	r2, [r4, #0]
 80078b6:	6880      	ldr	r0, [r0, #8]
 80078b8:	6893      	ldr	r3, [r2, #8]
 80078ba:	eb00 0185 	add.w	r1, r0, r5, lsl #2
 80078be:	eb03 0485 	add.w	r4, r3, r5, lsl #2
 80078c2:	1f09      	subs	r1, r1, #4
 80078c4:	1f22      	subs	r2, r4, #4
 80078c6:	4281      	cmp	r1, r0
 80078c8:	f0c0 8032 	bcc.w	8007930 <forward_reciprocal+0x100>
 80078cc:	ed91 0a00 	vldr	s0, [r1]
 80078d0:	eef7 0a00 	vmov.f32	s1, #112	; 0x3f800000  1.0
 80078d4:	1f09      	subs	r1, r1, #4
 80078d6:	ee80 0a80 	vdiv.f32	s0, s1, s0
 80078da:	4281      	cmp	r1, r0
 80078dc:	ed82 0a00 	vstr	s0, [r2]
 80078e0:	d326      	bcc.n	8007930 <forward_reciprocal+0x100>
 80078e2:	edd1 0a00 	vldr	s1, [r1]
 80078e6:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
 80078ea:	1f13      	subs	r3, r2, #4
 80078ec:	1f09      	subs	r1, r1, #4
 80078ee:	ee80 0a20 	vdiv.f32	s0, s0, s1
 80078f2:	4281      	cmp	r1, r0
 80078f4:	ed83 0a00 	vstr	s0, [r3]
 80078f8:	d31a      	bcc.n	8007930 <forward_reciprocal+0x100>
 80078fa:	ed91 0a00 	vldr	s0, [r1]
 80078fe:	eef7 0a00 	vmov.f32	s1, #112	; 0x3f800000  1.0
 8007902:	f1a2 0308 	sub.w	r3, r2, #8
 8007906:	1f09      	subs	r1, r1, #4
 8007908:	ee80 0a80 	vdiv.f32	s0, s1, s0
 800790c:	4281      	cmp	r1, r0
 800790e:	ed83 0a00 	vstr	s0, [r3]
 8007912:	d30d      	bcc.n	8007930 <forward_reciprocal+0x100>
 8007914:	edd1 0a00 	vldr	s1, [r1]
 8007918:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
 800791c:	f1a2 030c 	sub.w	r3, r2, #12
 8007920:	1f09      	subs	r1, r1, #4
 8007922:	3a10      	subs	r2, #16
 8007924:	ee80 0a20 	vdiv.f32	s0, s0, s1
 8007928:	4281      	cmp	r1, r0
 800792a:	ed83 0a00 	vstr	s0, [r3]
 800792e:	d2cd      	bcs.n	80078cc <forward_reciprocal+0x9c>
 8007930:	bcf0      	pop	{r4, r5, r6, r7}
 8007932:	4770      	bx	lr

08007934 <nl_func_exp_array_f32>:
 8007934:	b570      	push	{r4, r5, r6, lr}
 8007936:	688c      	ldr	r4, [r1, #8]
 8007938:	6880      	ldr	r0, [r0, #8]
 800793a:	eb04 0182 	add.w	r1, r4, r2, lsl #2
 800793e:	1f0d      	subs	r5, r1, #4
 8007940:	eb00 0182 	add.w	r1, r0, r2, lsl #2
 8007944:	1f0e      	subs	r6, r1, #4
 8007946:	42a5      	cmp	r5, r4
 8007948:	f0c0 800a 	bcc.w	8007960 <nl_func_exp_array_f32+0x2c>
 800794c:	ed95 0a00 	vldr	s0, [r5]
 8007950:	f023 fb94 	bl	802b07c <expf>
 8007954:	ed86 0a00 	vstr	s0, [r6]
 8007958:	1f2d      	subs	r5, r5, #4
 800795a:	1f36      	subs	r6, r6, #4
 800795c:	42a5      	cmp	r5, r4
 800795e:	d2f5      	bcs.n	800794c <nl_func_exp_array_f32+0x18>
 8007960:	bd70      	pop	{r4, r5, r6, pc}
	...

08007964 <forward_exp>:
 8007964:	b5f0      	push	{r4, r5, r6, r7, lr}
 8007966:	b081      	sub	sp, #4
 8007968:	6942      	ldr	r2, [r0, #20]
 800796a:	8811      	ldrh	r1, [r2, #0]
 800796c:	2900      	cmp	r1, #0
 800796e:	bf1a      	itte	ne
 8007970:	6850      	ldrne	r0, [r2, #4]
 8007972:	1d00      	addne	r0, r0, #4
 8007974:	2004      	moveq	r0, #4
 8007976:	f04f 0501 	mov.w	r5, #1
 800797a:	6800      	ldr	r0, [r0, #0]
 800797c:	2800      	cmp	r0, #0
 800797e:	bf14      	ite	ne
 8007980:	6803      	ldrne	r3, [r0, #0]
 8007982:	2300      	moveq	r3, #0
 8007984:	2902      	cmp	r1, #2
 8007986:	bfa6      	itte	ge
 8007988:	6850      	ldrge	r0, [r2, #4]
 800798a:	3010      	addge	r0, #16
 800798c:	2004      	movlt	r0, #4
 800798e:	6800      	ldr	r0, [r0, #0]
 8007990:	2800      	cmp	r0, #0
 8007992:	bf19      	ittee	ne
 8007994:	6800      	ldrne	r0, [r0, #0]
 8007996:	f100 0418 	addne.w	r4, r0, #24
 800799a:	2100      	moveq	r1, #0
 800799c:	f101 0418 	addeq.w	r4, r1, #24
 80079a0:	f103 0108 	add.w	r1, r3, #8
 80079a4:	680a      	ldr	r2, [r1, #0]
 80079a6:	0a12      	lsrs	r2, r2, #8
 80079a8:	d01e      	beq.n	80079e8 <forward_exp+0x84>
 80079aa:	684e      	ldr	r6, [r1, #4]
 80079ac:	eb06 0182 	add.w	r1, r6, r2, lsl #2
 80079b0:	4610      	mov	r0, r2
 80079b2:	1f0f      	subs	r7, r1, #4
 80079b4:	f010 0103 	ands.w	r1, r0, #3
 80079b8:	d006      	beq.n	80079c8 <forward_exp+0x64>
 80079ba:	1e52      	subs	r2, r2, #1
 80079bc:	f857 c904 	ldr.w	ip, [r7], #-4
 80079c0:	1e49      	subs	r1, r1, #1
 80079c2:	fb0c f505 	mul.w	r5, ip, r5
 80079c6:	d1f8      	bne.n	80079ba <forward_exp+0x56>
 80079c8:	0880      	lsrs	r0, r0, #2
 80079ca:	d00d      	beq.n	80079e8 <forward_exp+0x84>
 80079cc:	eb06 0182 	add.w	r1, r6, r2, lsl #2
 80079d0:	3910      	subs	r1, #16
 80079d2:	68ca      	ldr	r2, [r1, #12]
 80079d4:	688e      	ldr	r6, [r1, #8]
 80079d6:	684f      	ldr	r7, [r1, #4]
 80079d8:	4372      	muls	r2, r6
 80079da:	f851 6910 	ldr.w	r6, [r1], #-16
 80079de:	437a      	muls	r2, r7
 80079e0:	4372      	muls	r2, r6
 80079e2:	4355      	muls	r5, r2
 80079e4:	1e40      	subs	r0, r0, #1
 80079e6:	d1f4      	bne.n	80079d2 <forward_exp+0x6e>
 80079e8:	6998      	ldr	r0, [r3, #24]
 80079ea:	6886      	ldr	r6, [r0, #8]
 80079ec:	6821      	ldr	r1, [r4, #0]
 80079ee:	eb06 0085 	add.w	r0, r6, r5, lsl #2
 80079f2:	1f07      	subs	r7, r0, #4
 80079f4:	6888      	ldr	r0, [r1, #8]
 80079f6:	eb00 0285 	add.w	r2, r0, r5, lsl #2
 80079fa:	1f14      	subs	r4, r2, #4
 80079fc:	42b7      	cmp	r7, r6
 80079fe:	d309      	bcc.n	8007a14 <forward_exp+0xb0>
 8007a00:	ed97 0a00 	vldr	s0, [r7]
 8007a04:	f023 fb3a 	bl	802b07c <expf>
 8007a08:	ed84 0a00 	vstr	s0, [r4]
 8007a0c:	1f3f      	subs	r7, r7, #4
 8007a0e:	1f24      	subs	r4, r4, #4
 8007a10:	42b7      	cmp	r7, r6
 8007a12:	d2f5      	bcs.n	8007a00 <forward_exp+0x9c>
 8007a14:	b001      	add	sp, #4
 8007a16:	bdf0      	pop	{r4, r5, r6, r7, pc}

08007a18 <nl_func_sigmoid_array_f32>:
 8007a18:	b570      	push	{r4, r5, r6, lr}
 8007a1a:	688c      	ldr	r4, [r1, #8]
 8007a1c:	6880      	ldr	r0, [r0, #8]
 8007a1e:	eb04 0182 	add.w	r1, r4, r2, lsl #2
 8007a22:	1f0d      	subs	r5, r1, #4
 8007a24:	eb00 0182 	add.w	r1, r0, r2, lsl #2
 8007a28:	1f0e      	subs	r6, r1, #4
 8007a2a:	42a5      	cmp	r5, r4
 8007a2c:	f0c0 8014 	bcc.w	8007a58 <nl_func_sigmoid_array_f32+0x40>
 8007a30:	ed95 0a00 	vldr	s0, [r5]
 8007a34:	eeb1 0a40 	vneg.f32	s0, s0
 8007a38:	f023 fb20 	bl	802b07c <expf>
 8007a3c:	eef7 0a00 	vmov.f32	s1, #112	; 0x3f800000  1.0
 8007a40:	ee70 0a20 	vadd.f32	s1, s0, s1
 8007a44:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
 8007a48:	ee80 0a20 	vdiv.f32	s0, s0, s1
 8007a4c:	ed86 0a00 	vstr	s0, [r6]
 8007a50:	1f2d      	subs	r5, r5, #4
 8007a52:	1f36      	subs	r6, r6, #4
 8007a54:	42a5      	cmp	r5, r4
 8007a56:	d2eb      	bcs.n	8007a30 <nl_func_sigmoid_array_f32+0x18>
 8007a58:	bd70      	pop	{r4, r5, r6, pc}
	...

08007a5c <forward_sigmoid>:
 8007a5c:	b5f0      	push	{r4, r5, r6, r7, lr}
 8007a5e:	b081      	sub	sp, #4
 8007a60:	6942      	ldr	r2, [r0, #20]
 8007a62:	8811      	ldrh	r1, [r2, #0]
 8007a64:	2900      	cmp	r1, #0
 8007a66:	bf1a      	itte	ne
 8007a68:	6850      	ldrne	r0, [r2, #4]
 8007a6a:	1d00      	addne	r0, r0, #4
 8007a6c:	2004      	moveq	r0, #4
 8007a6e:	f04f 0501 	mov.w	r5, #1
 8007a72:	6800      	ldr	r0, [r0, #0]
 8007a74:	2800      	cmp	r0, #0
 8007a76:	bf14      	ite	ne
 8007a78:	6803      	ldrne	r3, [r0, #0]
 8007a7a:	2300      	moveq	r3, #0
 8007a7c:	2902      	cmp	r1, #2
 8007a7e:	bfa6      	itte	ge
 8007a80:	6850      	ldrge	r0, [r2, #4]
 8007a82:	3010      	addge	r0, #16
 8007a84:	2004      	movlt	r0, #4
 8007a86:	6800      	ldr	r0, [r0, #0]
 8007a88:	2800      	cmp	r0, #0
 8007a8a:	bf19      	ittee	ne
 8007a8c:	6800      	ldrne	r0, [r0, #0]
 8007a8e:	f100 0418 	addne.w	r4, r0, #24
 8007a92:	2100      	moveq	r1, #0
 8007a94:	f101 0418 	addeq.w	r4, r1, #24
 8007a98:	f103 0108 	add.w	r1, r3, #8
 8007a9c:	680a      	ldr	r2, [r1, #0]
 8007a9e:	0a12      	lsrs	r2, r2, #8
 8007aa0:	d01e      	beq.n	8007ae0 <forward_sigmoid+0x84>
 8007aa2:	684e      	ldr	r6, [r1, #4]
 8007aa4:	eb06 0182 	add.w	r1, r6, r2, lsl #2
 8007aa8:	4610      	mov	r0, r2
 8007aaa:	1f0f      	subs	r7, r1, #4
 8007aac:	f010 0103 	ands.w	r1, r0, #3
 8007ab0:	d006      	beq.n	8007ac0 <forward_sigmoid+0x64>
 8007ab2:	1e52      	subs	r2, r2, #1
 8007ab4:	f857 c904 	ldr.w	ip, [r7], #-4
 8007ab8:	1e49      	subs	r1, r1, #1
 8007aba:	fb0c f505 	mul.w	r5, ip, r5
 8007abe:	d1f8      	bne.n	8007ab2 <forward_sigmoid+0x56>
 8007ac0:	0880      	lsrs	r0, r0, #2
 8007ac2:	d00d      	beq.n	8007ae0 <forward_sigmoid+0x84>
 8007ac4:	eb06 0182 	add.w	r1, r6, r2, lsl #2
 8007ac8:	3910      	subs	r1, #16
 8007aca:	68ca      	ldr	r2, [r1, #12]
 8007acc:	688e      	ldr	r6, [r1, #8]
 8007ace:	684f      	ldr	r7, [r1, #4]
 8007ad0:	4372      	muls	r2, r6
 8007ad2:	f851 6910 	ldr.w	r6, [r1], #-16
 8007ad6:	437a      	muls	r2, r7
 8007ad8:	4372      	muls	r2, r6
 8007ada:	4355      	muls	r5, r2
 8007adc:	1e40      	subs	r0, r0, #1
 8007ade:	d1f4      	bne.n	8007aca <forward_sigmoid+0x6e>
 8007ae0:	6998      	ldr	r0, [r3, #24]
 8007ae2:	6886      	ldr	r6, [r0, #8]
 8007ae4:	6821      	ldr	r1, [r4, #0]
 8007ae6:	eb06 0085 	add.w	r0, r6, r5, lsl #2
 8007aea:	1f07      	subs	r7, r0, #4
 8007aec:	6888      	ldr	r0, [r1, #8]
 8007aee:	eb00 0285 	add.w	r2, r0, r5, lsl #2
 8007af2:	1f14      	subs	r4, r2, #4
 8007af4:	42b7      	cmp	r7, r6
 8007af6:	d313      	bcc.n	8007b20 <forward_sigmoid+0xc4>
 8007af8:	ed97 0a00 	vldr	s0, [r7]
 8007afc:	eeb1 0a40 	vneg.f32	s0, s0
 8007b00:	f023 fabc 	bl	802b07c <expf>
 8007b04:	eef7 0a00 	vmov.f32	s1, #112	; 0x3f800000  1.0
 8007b08:	ee70 0a20 	vadd.f32	s1, s0, s1
 8007b0c:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
 8007b10:	ee80 0a20 	vdiv.f32	s0, s0, s1
 8007b14:	ed84 0a00 	vstr	s0, [r4]
 8007b18:	1f3f      	subs	r7, r7, #4
 8007b1a:	1f24      	subs	r4, r4, #4
 8007b1c:	42b7      	cmp	r7, r6
 8007b1e:	d2eb      	bcs.n	8007af8 <forward_sigmoid+0x9c>
 8007b20:	b001      	add	sp, #4
 8007b22:	bdf0      	pop	{r4, r5, r6, r7, pc}

08007b24 <nl_func_sign_array_f32>:
 8007b24:	6889      	ldr	r1, [r1, #8]
 8007b26:	6880      	ldr	r0, [r0, #8]
 8007b28:	eb01 0382 	add.w	r3, r1, r2, lsl #2
 8007b2c:	eb00 0282 	add.w	r2, r0, r2, lsl #2
 8007b30:	1f1b      	subs	r3, r3, #4
 8007b32:	1f10      	subs	r0, r2, #4
 8007b34:	428b      	cmp	r3, r1
 8007b36:	d314      	bcc.n	8007b62 <nl_func_sign_array_f32+0x3e>
 8007b38:	f04f 32ff 	mov.w	r2, #4294967295
 8007b3c:	ed93 0a00 	vldr	s0, [r3]
 8007b40:	eeb5 0a40 	vcmp.f32	s0, #0.0
 8007b44:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8007b48:	bfcc      	ite	gt
 8007b4a:	ed9f 0a39 	vldrgt	s0, [pc, #228]	; 8007c30 <.text_49>
 8007b4e:	ee00 2a10 	vmovle	s0, r2
 8007b52:	eeb8 0ac0 	vcvt.f32.s32	s0, s0
 8007b56:	ed80 0a00 	vstr	s0, [r0]
 8007b5a:	1f1b      	subs	r3, r3, #4
 8007b5c:	1f00      	subs	r0, r0, #4
 8007b5e:	428b      	cmp	r3, r1
 8007b60:	d2ec      	bcs.n	8007b3c <nl_func_sign_array_f32+0x18>
 8007b62:	4770      	bx	lr

08007b64 <forward_sign>:
 8007b64:	b4f0      	push	{r4, r5, r6, r7}
 8007b66:	6942      	ldr	r2, [r0, #20]
 8007b68:	8811      	ldrh	r1, [r2, #0]
 8007b6a:	2900      	cmp	r1, #0
 8007b6c:	bf1a      	itte	ne
 8007b6e:	6850      	ldrne	r0, [r2, #4]
 8007b70:	1d00      	addne	r0, r0, #4
 8007b72:	2004      	moveq	r0, #4
 8007b74:	f04f 0501 	mov.w	r5, #1
 8007b78:	6800      	ldr	r0, [r0, #0]
 8007b7a:	2800      	cmp	r0, #0
 8007b7c:	bf14      	ite	ne
 8007b7e:	6803      	ldrne	r3, [r0, #0]
 8007b80:	2300      	moveq	r3, #0
 8007b82:	2901      	cmp	r1, #1
 8007b84:	bfc6      	itte	gt
 8007b86:	6850      	ldrgt	r0, [r2, #4]
 8007b88:	3010      	addgt	r0, #16
 8007b8a:	2004      	movle	r0, #4
 8007b8c:	6800      	ldr	r0, [r0, #0]
 8007b8e:	2800      	cmp	r0, #0
 8007b90:	bf19      	ittee	ne
 8007b92:	6800      	ldrne	r0, [r0, #0]
 8007b94:	f100 0418 	addne.w	r4, r0, #24
 8007b98:	2100      	moveq	r1, #0
 8007b9a:	f101 0418 	addeq.w	r4, r1, #24
 8007b9e:	f103 0108 	add.w	r1, r3, #8
 8007ba2:	680a      	ldr	r2, [r1, #0]
 8007ba4:	0a12      	lsrs	r2, r2, #8
 8007ba6:	d01e      	beq.n	8007be6 <forward_sign+0x82>
 8007ba8:	684e      	ldr	r6, [r1, #4]
 8007baa:	eb06 0182 	add.w	r1, r6, r2, lsl #2
 8007bae:	4610      	mov	r0, r2
 8007bb0:	1f0f      	subs	r7, r1, #4
 8007bb2:	f010 0103 	ands.w	r1, r0, #3
 8007bb6:	d006      	beq.n	8007bc6 <forward_sign+0x62>
 8007bb8:	1e52      	subs	r2, r2, #1
 8007bba:	f857 c904 	ldr.w	ip, [r7], #-4
 8007bbe:	1e49      	subs	r1, r1, #1
 8007bc0:	fb0c f505 	mul.w	r5, ip, r5
 8007bc4:	d1f8      	bne.n	8007bb8 <forward_sign+0x54>
 8007bc6:	0880      	lsrs	r0, r0, #2
 8007bc8:	d00d      	beq.n	8007be6 <forward_sign+0x82>
 8007bca:	eb06 0182 	add.w	r1, r6, r2, lsl #2
 8007bce:	3910      	subs	r1, #16
 8007bd0:	68ca      	ldr	r2, [r1, #12]
 8007bd2:	688e      	ldr	r6, [r1, #8]
 8007bd4:	684f      	ldr	r7, [r1, #4]
 8007bd6:	4372      	muls	r2, r6
 8007bd8:	f851 6910 	ldr.w	r6, [r1], #-16
 8007bdc:	437a      	muls	r2, r7
 8007bde:	4372      	muls	r2, r6
 8007be0:	4355      	muls	r5, r2
 8007be2:	1e40      	subs	r0, r0, #1
 8007be4:	d1f4      	bne.n	8007bd0 <forward_sign+0x6c>
 8007be6:	6998      	ldr	r0, [r3, #24]
 8007be8:	6822      	ldr	r2, [r4, #0]
 8007bea:	6880      	ldr	r0, [r0, #8]
 8007bec:	6893      	ldr	r3, [r2, #8]
 8007bee:	eb00 0185 	add.w	r1, r0, r5, lsl #2
 8007bf2:	eb03 0485 	add.w	r4, r3, r5, lsl #2
 8007bf6:	1f09      	subs	r1, r1, #4
 8007bf8:	1f22      	subs	r2, r4, #4
 8007bfa:	4281      	cmp	r1, r0
 8007bfc:	f0c0 8015 	bcc.w	8007c2a <forward_sign+0xc6>
 8007c00:	f04f 33ff 	mov.w	r3, #4294967295
 8007c04:	ed91 0a00 	vldr	s0, [r1]
 8007c08:	eeb5 0a40 	vcmp.f32	s0, #0.0
 8007c0c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8007c10:	bfcc      	ite	gt
 8007c12:	ed9f 0a07 	vldrgt	s0, [pc, #28]	; 8007c30 <.text_49>
 8007c16:	ee00 3a10 	vmovle	s0, r3
 8007c1a:	eeb8 0ac0 	vcvt.f32.s32	s0, s0
 8007c1e:	ed82 0a00 	vstr	s0, [r2]
 8007c22:	1f09      	subs	r1, r1, #4
 8007c24:	1f12      	subs	r2, r2, #4
 8007c26:	4281      	cmp	r1, r0
 8007c28:	d2ec      	bcs.n	8007c04 <forward_sign+0xa0>
 8007c2a:	bcf0      	pop	{r4, r5, r6, r7}
 8007c2c:	4770      	bx	lr
	...

08007c30 <.text_49>:
 8007c30:	00000001 	.word	0x00000001

08007c34 <nl_func_sqrt_array_f32>:
 8007c34:	b570      	push	{r4, r5, r6, lr}
 8007c36:	460c      	mov	r4, r1
 8007c38:	6880      	ldr	r0, [r0, #8]
 8007c3a:	68a1      	ldr	r1, [r4, #8]
 8007c3c:	eb01 0382 	add.w	r3, r1, r2, lsl #2
 8007c40:	eb00 0282 	add.w	r2, r0, r2, lsl #2
 8007c44:	1f1d      	subs	r5, r3, #4
 8007c46:	1f16      	subs	r6, r2, #4
 8007c48:	428d      	cmp	r5, r1
 8007c4a:	d30a      	bcc.n	8007c62 <nl_func_sqrt_array_f32+0x2e>
 8007c4c:	ed95 0a00 	vldr	s0, [r5]
 8007c50:	f002 fad2 	bl	800a1f8 <ai_math_sqrt>
 8007c54:	ed86 0a00 	vstr	s0, [r6]
 8007c58:	1f2d      	subs	r5, r5, #4
 8007c5a:	68a0      	ldr	r0, [r4, #8]
 8007c5c:	1f36      	subs	r6, r6, #4
 8007c5e:	4285      	cmp	r5, r0
 8007c60:	d2f4      	bcs.n	8007c4c <nl_func_sqrt_array_f32+0x18>
 8007c62:	bd70      	pop	{r4, r5, r6, pc}

08007c64 <forward_sqrt>:
 8007c64:	b5f0      	push	{r4, r5, r6, r7, lr}
 8007c66:	b081      	sub	sp, #4
 8007c68:	6942      	ldr	r2, [r0, #20]
 8007c6a:	8811      	ldrh	r1, [r2, #0]
 8007c6c:	2900      	cmp	r1, #0
 8007c6e:	bf1a      	itte	ne
 8007c70:	6850      	ldrne	r0, [r2, #4]
 8007c72:	1d00      	addne	r0, r0, #4
 8007c74:	2004      	moveq	r0, #4
 8007c76:	f04f 0501 	mov.w	r5, #1
 8007c7a:	6800      	ldr	r0, [r0, #0]
 8007c7c:	2800      	cmp	r0, #0
 8007c7e:	bf14      	ite	ne
 8007c80:	6803      	ldrne	r3, [r0, #0]
 8007c82:	2300      	moveq	r3, #0
 8007c84:	2902      	cmp	r1, #2
 8007c86:	bfa6      	itte	ge
 8007c88:	6850      	ldrge	r0, [r2, #4]
 8007c8a:	3010      	addge	r0, #16
 8007c8c:	2004      	movlt	r0, #4
 8007c8e:	6800      	ldr	r0, [r0, #0]
 8007c90:	2800      	cmp	r0, #0
 8007c92:	bf19      	ittee	ne
 8007c94:	6800      	ldrne	r0, [r0, #0]
 8007c96:	f100 0418 	addne.w	r4, r0, #24
 8007c9a:	2100      	moveq	r1, #0
 8007c9c:	f101 0418 	addeq.w	r4, r1, #24
 8007ca0:	f103 0108 	add.w	r1, r3, #8
 8007ca4:	680a      	ldr	r2, [r1, #0]
 8007ca6:	0a12      	lsrs	r2, r2, #8
 8007ca8:	d01e      	beq.n	8007ce8 <forward_sqrt+0x84>
 8007caa:	684e      	ldr	r6, [r1, #4]
 8007cac:	eb06 0182 	add.w	r1, r6, r2, lsl #2
 8007cb0:	4610      	mov	r0, r2
 8007cb2:	1f0f      	subs	r7, r1, #4
 8007cb4:	f010 0103 	ands.w	r1, r0, #3
 8007cb8:	d006      	beq.n	8007cc8 <forward_sqrt+0x64>
 8007cba:	1e52      	subs	r2, r2, #1
 8007cbc:	f857 c904 	ldr.w	ip, [r7], #-4
 8007cc0:	1e49      	subs	r1, r1, #1
 8007cc2:	fb0c f505 	mul.w	r5, ip, r5
 8007cc6:	d1f8      	bne.n	8007cba <forward_sqrt+0x56>
 8007cc8:	0880      	lsrs	r0, r0, #2
 8007cca:	d00d      	beq.n	8007ce8 <forward_sqrt+0x84>
 8007ccc:	eb06 0182 	add.w	r1, r6, r2, lsl #2
 8007cd0:	3910      	subs	r1, #16
 8007cd2:	68ca      	ldr	r2, [r1, #12]
 8007cd4:	688e      	ldr	r6, [r1, #8]
 8007cd6:	684f      	ldr	r7, [r1, #4]
 8007cd8:	4372      	muls	r2, r6
 8007cda:	f851 6910 	ldr.w	r6, [r1], #-16
 8007cde:	437a      	muls	r2, r7
 8007ce0:	4372      	muls	r2, r6
 8007ce2:	4355      	muls	r5, r2
 8007ce4:	1e40      	subs	r0, r0, #1
 8007ce6:	d1f4      	bne.n	8007cd2 <forward_sqrt+0x6e>
 8007ce8:	699e      	ldr	r6, [r3, #24]
 8007cea:	68b0      	ldr	r0, [r6, #8]
 8007cec:	6822      	ldr	r2, [r4, #0]
 8007cee:	eb00 0185 	add.w	r1, r0, r5, lsl #2
 8007cf2:	1f0f      	subs	r7, r1, #4
 8007cf4:	6891      	ldr	r1, [r2, #8]
 8007cf6:	eb01 0385 	add.w	r3, r1, r5, lsl #2
 8007cfa:	1f1c      	subs	r4, r3, #4
 8007cfc:	4287      	cmp	r7, r0
 8007cfe:	d30a      	bcc.n	8007d16 <forward_sqrt+0xb2>
 8007d00:	ed97 0a00 	vldr	s0, [r7]
 8007d04:	f002 fa78 	bl	800a1f8 <ai_math_sqrt>
 8007d08:	ed84 0a00 	vstr	s0, [r4]
 8007d0c:	1f3f      	subs	r7, r7, #4
 8007d0e:	68b0      	ldr	r0, [r6, #8]
 8007d10:	1f24      	subs	r4, r4, #4
 8007d12:	4287      	cmp	r7, r0
 8007d14:	d2f4      	bcs.n	8007d00 <forward_sqrt+0x9c>
 8007d16:	b001      	add	sp, #4
 8007d18:	bdf0      	pop	{r4, r5, r6, r7, pc}
	...

08007d1c <nl_func_soft_plus_array_f32>:
 8007d1c:	b570      	push	{r4, r5, r6, lr}
 8007d1e:	688c      	ldr	r4, [r1, #8]
 8007d20:	6880      	ldr	r0, [r0, #8]
 8007d22:	eb04 0182 	add.w	r1, r4, r2, lsl #2
 8007d26:	1f0d      	subs	r5, r1, #4
 8007d28:	eb00 0182 	add.w	r1, r0, r2, lsl #2
 8007d2c:	1f0e      	subs	r6, r1, #4
 8007d2e:	42a5      	cmp	r5, r4
 8007d30:	f0c0 8010 	bcc.w	8007d54 <nl_func_soft_plus_array_f32+0x38>
 8007d34:	ed95 0a00 	vldr	s0, [r5]
 8007d38:	f023 f9a0 	bl	802b07c <expf>
 8007d3c:	eef7 0a00 	vmov.f32	s1, #112	; 0x3f800000  1.0
 8007d40:	ee30 0a20 	vadd.f32	s0, s0, s1
 8007d44:	f023 f9f0 	bl	802b128 <logf>
 8007d48:	ed86 0a00 	vstr	s0, [r6]
 8007d4c:	1f2d      	subs	r5, r5, #4
 8007d4e:	1f36      	subs	r6, r6, #4
 8007d50:	42a5      	cmp	r5, r4
 8007d52:	d2ef      	bcs.n	8007d34 <nl_func_soft_plus_array_f32+0x18>
 8007d54:	bd70      	pop	{r4, r5, r6, pc}
	...

08007d58 <forward_soft_plus>:
 8007d58:	b5f0      	push	{r4, r5, r6, r7, lr}
 8007d5a:	b081      	sub	sp, #4
 8007d5c:	6942      	ldr	r2, [r0, #20]
 8007d5e:	8811      	ldrh	r1, [r2, #0]
 8007d60:	2900      	cmp	r1, #0
 8007d62:	bf1a      	itte	ne
 8007d64:	6850      	ldrne	r0, [r2, #4]
 8007d66:	1d00      	addne	r0, r0, #4
 8007d68:	2004      	moveq	r0, #4
 8007d6a:	f04f 0501 	mov.w	r5, #1
 8007d6e:	6800      	ldr	r0, [r0, #0]
 8007d70:	2800      	cmp	r0, #0
 8007d72:	bf14      	ite	ne
 8007d74:	6803      	ldrne	r3, [r0, #0]
 8007d76:	2300      	moveq	r3, #0
 8007d78:	2902      	cmp	r1, #2
 8007d7a:	bfa6      	itte	ge
 8007d7c:	6850      	ldrge	r0, [r2, #4]
 8007d7e:	3010      	addge	r0, #16
 8007d80:	2004      	movlt	r0, #4
 8007d82:	6800      	ldr	r0, [r0, #0]
 8007d84:	2800      	cmp	r0, #0
 8007d86:	bf19      	ittee	ne
 8007d88:	6800      	ldrne	r0, [r0, #0]
 8007d8a:	f100 0418 	addne.w	r4, r0, #24
 8007d8e:	2100      	moveq	r1, #0
 8007d90:	f101 0418 	addeq.w	r4, r1, #24
 8007d94:	f103 0108 	add.w	r1, r3, #8
 8007d98:	680a      	ldr	r2, [r1, #0]
 8007d9a:	0a12      	lsrs	r2, r2, #8
 8007d9c:	d01e      	beq.n	8007ddc <forward_soft_plus+0x84>
 8007d9e:	684e      	ldr	r6, [r1, #4]
 8007da0:	eb06 0182 	add.w	r1, r6, r2, lsl #2
 8007da4:	4610      	mov	r0, r2
 8007da6:	1f0f      	subs	r7, r1, #4
 8007da8:	f010 0103 	ands.w	r1, r0, #3
 8007dac:	d006      	beq.n	8007dbc <forward_soft_plus+0x64>
 8007dae:	1e52      	subs	r2, r2, #1
 8007db0:	f857 c904 	ldr.w	ip, [r7], #-4
 8007db4:	1e49      	subs	r1, r1, #1
 8007db6:	fb0c f505 	mul.w	r5, ip, r5
 8007dba:	d1f8      	bne.n	8007dae <forward_soft_plus+0x56>
 8007dbc:	0880      	lsrs	r0, r0, #2
 8007dbe:	d00d      	beq.n	8007ddc <forward_soft_plus+0x84>
 8007dc0:	eb06 0182 	add.w	r1, r6, r2, lsl #2
 8007dc4:	3910      	subs	r1, #16
 8007dc6:	68ca      	ldr	r2, [r1, #12]
 8007dc8:	688e      	ldr	r6, [r1, #8]
 8007dca:	684f      	ldr	r7, [r1, #4]
 8007dcc:	4372      	muls	r2, r6
 8007dce:	f851 6910 	ldr.w	r6, [r1], #-16
 8007dd2:	437a      	muls	r2, r7
 8007dd4:	4372      	muls	r2, r6
 8007dd6:	4355      	muls	r5, r2
 8007dd8:	1e40      	subs	r0, r0, #1
 8007dda:	d1f4      	bne.n	8007dc6 <forward_soft_plus+0x6e>
 8007ddc:	6998      	ldr	r0, [r3, #24]
 8007dde:	6886      	ldr	r6, [r0, #8]
 8007de0:	6821      	ldr	r1, [r4, #0]
 8007de2:	eb06 0085 	add.w	r0, r6, r5, lsl #2
 8007de6:	1f07      	subs	r7, r0, #4
 8007de8:	6888      	ldr	r0, [r1, #8]
 8007dea:	eb00 0285 	add.w	r2, r0, r5, lsl #2
 8007dee:	1f14      	subs	r4, r2, #4
 8007df0:	42b7      	cmp	r7, r6
 8007df2:	d30f      	bcc.n	8007e14 <forward_soft_plus+0xbc>
 8007df4:	ed97 0a00 	vldr	s0, [r7]
 8007df8:	f023 f940 	bl	802b07c <expf>
 8007dfc:	eef7 0a00 	vmov.f32	s1, #112	; 0x3f800000  1.0
 8007e00:	ee30 0a20 	vadd.f32	s0, s0, s1
 8007e04:	f023 f990 	bl	802b128 <logf>
 8007e08:	ed84 0a00 	vstr	s0, [r4]
 8007e0c:	1f3f      	subs	r7, r7, #4
 8007e0e:	1f24      	subs	r4, r4, #4
 8007e10:	42b7      	cmp	r7, r6
 8007e12:	d2ef      	bcs.n	8007df4 <forward_soft_plus+0x9c>
 8007e14:	b001      	add	sp, #4
 8007e16:	bdf0      	pop	{r4, r5, r6, r7, pc}

08007e18 <nl_func_soft_sign_array_f32>:
 8007e18:	6889      	ldr	r1, [r1, #8]
 8007e1a:	6880      	ldr	r0, [r0, #8]
 8007e1c:	eb01 0382 	add.w	r3, r1, r2, lsl #2
 8007e20:	eb00 0282 	add.w	r2, r0, r2, lsl #2
 8007e24:	1f1b      	subs	r3, r3, #4
 8007e26:	1f10      	subs	r0, r2, #4
 8007e28:	428b      	cmp	r3, r1
 8007e2a:	d30f      	bcc.n	8007e4c <nl_func_soft_sign_array_f32+0x34>
 8007e2c:	ed93 0a00 	vldr	s0, [r3]
 8007e30:	eef0 0ac0 	vabs.f32	s1, s0
 8007e34:	eeb7 1a00 	vmov.f32	s2, #112	; 0x3f800000  1.0
 8007e38:	ee70 0a81 	vadd.f32	s1, s1, s2
 8007e3c:	ee80 0a20 	vdiv.f32	s0, s0, s1
 8007e40:	ed80 0a00 	vstr	s0, [r0]
 8007e44:	1f1b      	subs	r3, r3, #4
 8007e46:	1f00      	subs	r0, r0, #4
 8007e48:	428b      	cmp	r3, r1
 8007e4a:	d2ef      	bcs.n	8007e2c <nl_func_soft_sign_array_f32+0x14>
 8007e4c:	4770      	bx	lr
	...

08007e50 <forward_soft_sign>:
 8007e50:	b4f0      	push	{r4, r5, r6, r7}
 8007e52:	6942      	ldr	r2, [r0, #20]
 8007e54:	8811      	ldrh	r1, [r2, #0]
 8007e56:	2900      	cmp	r1, #0
 8007e58:	bf1a      	itte	ne
 8007e5a:	6850      	ldrne	r0, [r2, #4]
 8007e5c:	1d00      	addne	r0, r0, #4
 8007e5e:	2004      	moveq	r0, #4
 8007e60:	f04f 0501 	mov.w	r5, #1
 8007e64:	6800      	ldr	r0, [r0, #0]
 8007e66:	2800      	cmp	r0, #0
 8007e68:	bf14      	ite	ne
 8007e6a:	6803      	ldrne	r3, [r0, #0]
 8007e6c:	2300      	moveq	r3, #0
 8007e6e:	2902      	cmp	r1, #2
 8007e70:	bfa6      	itte	ge
 8007e72:	6850      	ldrge	r0, [r2, #4]
 8007e74:	3010      	addge	r0, #16
 8007e76:	2004      	movlt	r0, #4
 8007e78:	6800      	ldr	r0, [r0, #0]
 8007e7a:	2800      	cmp	r0, #0
 8007e7c:	bf19      	ittee	ne
 8007e7e:	6800      	ldrne	r0, [r0, #0]
 8007e80:	f100 0418 	addne.w	r4, r0, #24
 8007e84:	2100      	moveq	r1, #0
 8007e86:	f101 0418 	addeq.w	r4, r1, #24
 8007e8a:	f103 0108 	add.w	r1, r3, #8
 8007e8e:	680a      	ldr	r2, [r1, #0]
 8007e90:	0a12      	lsrs	r2, r2, #8
 8007e92:	d01e      	beq.n	8007ed2 <forward_soft_sign+0x82>
 8007e94:	684e      	ldr	r6, [r1, #4]
 8007e96:	eb06 0182 	add.w	r1, r6, r2, lsl #2
 8007e9a:	4610      	mov	r0, r2
 8007e9c:	1f0f      	subs	r7, r1, #4
 8007e9e:	f010 0103 	ands.w	r1, r0, #3
 8007ea2:	d006      	beq.n	8007eb2 <forward_soft_sign+0x62>
 8007ea4:	1e52      	subs	r2, r2, #1
 8007ea6:	f857 c904 	ldr.w	ip, [r7], #-4
 8007eaa:	1e49      	subs	r1, r1, #1
 8007eac:	fb0c f505 	mul.w	r5, ip, r5
 8007eb0:	d1f8      	bne.n	8007ea4 <forward_soft_sign+0x54>
 8007eb2:	0880      	lsrs	r0, r0, #2
 8007eb4:	d00d      	beq.n	8007ed2 <forward_soft_sign+0x82>
 8007eb6:	eb06 0182 	add.w	r1, r6, r2, lsl #2
 8007eba:	3910      	subs	r1, #16
 8007ebc:	68ca      	ldr	r2, [r1, #12]
 8007ebe:	688e      	ldr	r6, [r1, #8]
 8007ec0:	684f      	ldr	r7, [r1, #4]
 8007ec2:	4372      	muls	r2, r6
 8007ec4:	f851 6910 	ldr.w	r6, [r1], #-16
 8007ec8:	437a      	muls	r2, r7
 8007eca:	4372      	muls	r2, r6
 8007ecc:	4355      	muls	r5, r2
 8007ece:	1e40      	subs	r0, r0, #1
 8007ed0:	d1f4      	bne.n	8007ebc <forward_soft_sign+0x6c>
 8007ed2:	6998      	ldr	r0, [r3, #24]
 8007ed4:	6822      	ldr	r2, [r4, #0]
 8007ed6:	6880      	ldr	r0, [r0, #8]
 8007ed8:	6893      	ldr	r3, [r2, #8]
 8007eda:	eb00 0185 	add.w	r1, r0, r5, lsl #2
 8007ede:	eb03 0485 	add.w	r4, r3, r5, lsl #2
 8007ee2:	1f09      	subs	r1, r1, #4
 8007ee4:	1f22      	subs	r2, r4, #4
 8007ee6:	4281      	cmp	r1, r0
 8007ee8:	f0c0 8010 	bcc.w	8007f0c <forward_soft_sign+0xbc>
 8007eec:	ed91 0a00 	vldr	s0, [r1]
 8007ef0:	eef0 0ac0 	vabs.f32	s1, s0
 8007ef4:	eeb7 1a00 	vmov.f32	s2, #112	; 0x3f800000  1.0
 8007ef8:	ee70 0a81 	vadd.f32	s1, s1, s2
 8007efc:	ee80 0a20 	vdiv.f32	s0, s0, s1
 8007f00:	ed82 0a00 	vstr	s0, [r2]
 8007f04:	1f09      	subs	r1, r1, #4
 8007f06:	1f12      	subs	r2, r2, #4
 8007f08:	4281      	cmp	r1, r0
 8007f0a:	d2ef      	bcs.n	8007eec <forward_soft_sign+0x9c>
 8007f0c:	bcf0      	pop	{r4, r5, r6, r7}
 8007f0e:	4770      	bx	lr

08007f10 <nl_func_tanh_array_f32>:
 8007f10:	b570      	push	{r4, r5, r6, lr}
 8007f12:	688c      	ldr	r4, [r1, #8]
 8007f14:	6880      	ldr	r0, [r0, #8]
 8007f16:	eb04 0182 	add.w	r1, r4, r2, lsl #2
 8007f1a:	1f0d      	subs	r5, r1, #4
 8007f1c:	eb00 0182 	add.w	r1, r0, r2, lsl #2
 8007f20:	1f0e      	subs	r6, r1, #4
 8007f22:	42a5      	cmp	r5, r4
 8007f24:	f0c0 800a 	bcc.w	8007f3c <nl_func_tanh_array_f32+0x2c>
 8007f28:	ed95 0a00 	vldr	s0, [r5]
 8007f2c:	f022 ff84 	bl	802ae38 <tanhf>
 8007f30:	ed86 0a00 	vstr	s0, [r6]
 8007f34:	1f2d      	subs	r5, r5, #4
 8007f36:	1f36      	subs	r6, r6, #4
 8007f38:	42a5      	cmp	r5, r4
 8007f3a:	d2f5      	bcs.n	8007f28 <nl_func_tanh_array_f32+0x18>
 8007f3c:	bd70      	pop	{r4, r5, r6, pc}
	...

08007f40 <forward_tanh>:
 8007f40:	b5f0      	push	{r4, r5, r6, r7, lr}
 8007f42:	b081      	sub	sp, #4
 8007f44:	6942      	ldr	r2, [r0, #20]
 8007f46:	8811      	ldrh	r1, [r2, #0]
 8007f48:	2900      	cmp	r1, #0
 8007f4a:	bf1a      	itte	ne
 8007f4c:	6850      	ldrne	r0, [r2, #4]
 8007f4e:	1d00      	addne	r0, r0, #4
 8007f50:	2004      	moveq	r0, #4
 8007f52:	f04f 0501 	mov.w	r5, #1
 8007f56:	6800      	ldr	r0, [r0, #0]
 8007f58:	2800      	cmp	r0, #0
 8007f5a:	bf14      	ite	ne
 8007f5c:	6803      	ldrne	r3, [r0, #0]
 8007f5e:	2300      	moveq	r3, #0
 8007f60:	2902      	cmp	r1, #2
 8007f62:	bfa6      	itte	ge
 8007f64:	6850      	ldrge	r0, [r2, #4]
 8007f66:	3010      	addge	r0, #16
 8007f68:	2004      	movlt	r0, #4
 8007f6a:	6800      	ldr	r0, [r0, #0]
 8007f6c:	2800      	cmp	r0, #0
 8007f6e:	bf19      	ittee	ne
 8007f70:	6800      	ldrne	r0, [r0, #0]
 8007f72:	f100 0418 	addne.w	r4, r0, #24
 8007f76:	2100      	moveq	r1, #0
 8007f78:	f101 0418 	addeq.w	r4, r1, #24
 8007f7c:	f103 0108 	add.w	r1, r3, #8
 8007f80:	680a      	ldr	r2, [r1, #0]
 8007f82:	0a12      	lsrs	r2, r2, #8
 8007f84:	d01e      	beq.n	8007fc4 <forward_tanh+0x84>
 8007f86:	684e      	ldr	r6, [r1, #4]
 8007f88:	eb06 0182 	add.w	r1, r6, r2, lsl #2
 8007f8c:	4610      	mov	r0, r2
 8007f8e:	1f0f      	subs	r7, r1, #4
 8007f90:	f010 0103 	ands.w	r1, r0, #3
 8007f94:	d006      	beq.n	8007fa4 <forward_tanh+0x64>
 8007f96:	1e52      	subs	r2, r2, #1
 8007f98:	f857 c904 	ldr.w	ip, [r7], #-4
 8007f9c:	1e49      	subs	r1, r1, #1
 8007f9e:	fb0c f505 	mul.w	r5, ip, r5
 8007fa2:	d1f8      	bne.n	8007f96 <forward_tanh+0x56>
 8007fa4:	0880      	lsrs	r0, r0, #2
 8007fa6:	d00d      	beq.n	8007fc4 <forward_tanh+0x84>
 8007fa8:	eb06 0182 	add.w	r1, r6, r2, lsl #2
 8007fac:	3910      	subs	r1, #16
 8007fae:	68ca      	ldr	r2, [r1, #12]
 8007fb0:	688e      	ldr	r6, [r1, #8]
 8007fb2:	684f      	ldr	r7, [r1, #4]
 8007fb4:	4372      	muls	r2, r6
 8007fb6:	f851 6910 	ldr.w	r6, [r1], #-16
 8007fba:	437a      	muls	r2, r7
 8007fbc:	4372      	muls	r2, r6
 8007fbe:	4355      	muls	r5, r2
 8007fc0:	1e40      	subs	r0, r0, #1
 8007fc2:	d1f4      	bne.n	8007fae <forward_tanh+0x6e>
 8007fc4:	6998      	ldr	r0, [r3, #24]
 8007fc6:	6886      	ldr	r6, [r0, #8]
 8007fc8:	6821      	ldr	r1, [r4, #0]
 8007fca:	eb06 0085 	add.w	r0, r6, r5, lsl #2
 8007fce:	1f07      	subs	r7, r0, #4
 8007fd0:	6888      	ldr	r0, [r1, #8]
 8007fd2:	eb00 0285 	add.w	r2, r0, r5, lsl #2
 8007fd6:	1f14      	subs	r4, r2, #4
 8007fd8:	42b7      	cmp	r7, r6
 8007fda:	d309      	bcc.n	8007ff0 <forward_tanh+0xb0>
 8007fdc:	ed97 0a00 	vldr	s0, [r7]
 8007fe0:	f022 ff2a 	bl	802ae38 <tanhf>
 8007fe4:	ed84 0a00 	vstr	s0, [r4]
 8007fe8:	1f3f      	subs	r7, r7, #4
 8007fea:	1f24      	subs	r4, r4, #4
 8007fec:	42b7      	cmp	r7, r6
 8007fee:	d2f5      	bcs.n	8007fdc <forward_tanh+0x9c>
 8007ff0:	b001      	add	sp, #4
 8007ff2:	bdf0      	pop	{r4, r5, r6, r7, pc}

08007ff4 <nl_func_relu_array_f32>:
 8007ff4:	6889      	ldr	r1, [r1, #8]
 8007ff6:	6880      	ldr	r0, [r0, #8]
 8007ff8:	eb01 0382 	add.w	r3, r1, r2, lsl #2
 8007ffc:	eb00 0282 	add.w	r2, r0, r2, lsl #2
 8008000:	1f1b      	subs	r3, r3, #4
 8008002:	1f10      	subs	r0, r2, #4
 8008004:	428b      	cmp	r3, r1
 8008006:	d30e      	bcc.n	8008026 <nl_func_relu_array_f32+0x32>
 8008008:	ed93 0a00 	vldr	s0, [r3]
 800800c:	eeb5 0a40 	vcmp.f32	s0, #0.0
 8008010:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8008014:	bf48      	it	mi
 8008016:	ed9f 0a7b 	vldrmi	s0, [pc, #492]	; 8008204 <.text_62>
 800801a:	ed80 0a00 	vstr	s0, [r0]
 800801e:	1f1b      	subs	r3, r3, #4
 8008020:	1f00      	subs	r0, r0, #4
 8008022:	428b      	cmp	r3, r1
 8008024:	d2f0      	bcs.n	8008008 <nl_func_relu_array_f32+0x14>
 8008026:	4770      	bx	lr

08008028 <nl_func_sm_channel_f32>:
 8008028:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800802c:	ed2d 8b02 	vpush	{d8}
 8008030:	688f      	ldr	r7, [r1, #8]
 8008032:	6886      	ldr	r6, [r0, #8]
 8008034:	ed97 8a00 	vldr	s16, [r7]
 8008038:	4614      	mov	r4, r2
 800803a:	2c02      	cmp	r4, #2
 800803c:	eddf 8a71 	vldr	s17, [pc, #452]	; 8008204 <.text_62>
 8008040:	d33d      	bcc.n	80080be <nl_func_sm_channel_f32+0x96>
 8008042:	1e61      	subs	r1, r4, #1
 8008044:	1d3a      	adds	r2, r7, #4
 8008046:	f011 0003 	ands.w	r0, r1, #3
 800804a:	d00c      	beq.n	8008066 <nl_func_sm_channel_f32+0x3e>
 800804c:	ed92 0a00 	vldr	s0, [r2]
 8008050:	eeb4 0a48 	vcmp.f32	s0, s16
 8008054:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8008058:	bf58      	it	pl
 800805a:	eeb0 8a40 	vmovpl.f32	s16, s0
 800805e:	1e40      	subs	r0, r0, #1
 8008060:	f102 0204 	add.w	r2, r2, #4
 8008064:	d1f2      	bne.n	800804c <nl_func_sm_channel_f32+0x24>
 8008066:	0889      	lsrs	r1, r1, #2
 8008068:	f000 802b 	beq.w	80080c2 <nl_func_sm_channel_f32+0x9a>
 800806c:	ed92 0a00 	vldr	s0, [r2]
 8008070:	eeb4 0a48 	vcmp.f32	s0, s16
 8008074:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8008078:	bf58      	it	pl
 800807a:	eeb0 8a40 	vmovpl.f32	s16, s0
 800807e:	ed92 0a01 	vldr	s0, [r2, #4]
 8008082:	eeb4 0a48 	vcmp.f32	s0, s16
 8008086:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800808a:	bf58      	it	pl
 800808c:	eeb0 8a40 	vmovpl.f32	s16, s0
 8008090:	ed92 0a02 	vldr	s0, [r2, #8]
 8008094:	eeb4 0a48 	vcmp.f32	s0, s16
 8008098:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800809c:	bf58      	it	pl
 800809e:	eeb0 8a40 	vmovpl.f32	s16, s0
 80080a2:	ed92 0a03 	vldr	s0, [r2, #12]
 80080a6:	eeb4 0a48 	vcmp.f32	s0, s16
 80080aa:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80080ae:	bf58      	it	pl
 80080b0:	eeb0 8a40 	vmovpl.f32	s16, s0
 80080b4:	1e49      	subs	r1, r1, #1
 80080b6:	f102 0210 	add.w	r2, r2, #16
 80080ba:	d1d7      	bne.n	800806c <nl_func_sm_channel_f32+0x44>
 80080bc:	e001      	b.n	80080c2 <nl_func_sm_channel_f32+0x9a>
 80080be:	2c00      	cmp	r4, #0
 80080c0:	d040      	beq.n	8008144 <nl_func_sm_channel_f32+0x11c>
 80080c2:	46b0      	mov	r8, r6
 80080c4:	ea4f 0504 	mov.w	r5, r4
 80080c8:	ed97 0a00 	vldr	s0, [r7]
 80080cc:	ee30 0a48 	vsub.f32	s0, s0, s16
 80080d0:	f022 ffd4 	bl	802b07c <expf>
 80080d4:	1d3f      	adds	r7, r7, #4
 80080d6:	ed88 0a00 	vstr	s0, [r8]
 80080da:	1e6d      	subs	r5, r5, #1
 80080dc:	ee78 8a80 	vadd.f32	s17, s17, s0
 80080e0:	f108 0804 	add.w	r8, r8, #4
 80080e4:	d1f0      	bne.n	80080c8 <nl_func_sm_channel_f32+0xa0>
 80080e6:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
 80080ea:	f014 0003 	ands.w	r0, r4, #3
 80080ee:	ee80 0a28 	vdiv.f32	s0, s0, s17
 80080f2:	d009      	beq.n	8008108 <nl_func_sm_channel_f32+0xe0>
 80080f4:	edd6 0a00 	vldr	s1, [r6]
 80080f8:	ee60 0a80 	vmul.f32	s1, s1, s0
 80080fc:	edc6 0a00 	vstr	s1, [r6]
 8008100:	1e40      	subs	r0, r0, #1
 8008102:	f106 0604 	add.w	r6, r6, #4
 8008106:	d1f5      	bne.n	80080f4 <nl_func_sm_channel_f32+0xcc>
 8008108:	08a4      	lsrs	r4, r4, #2
 800810a:	d01b      	beq.n	8008144 <nl_func_sm_channel_f32+0x11c>
 800810c:	edd6 0a00 	vldr	s1, [r6]
 8008110:	ee60 0a80 	vmul.f32	s1, s1, s0
 8008114:	edc6 0a00 	vstr	s1, [r6]
 8008118:	1e64      	subs	r4, r4, #1
 800811a:	ed96 1a01 	vldr	s2, [r6, #4]
 800811e:	edd6 0a02 	vldr	s1, [r6, #8]
 8008122:	ee21 1a00 	vmul.f32	s2, s2, s0
 8008126:	ed86 1a01 	vstr	s2, [r6, #4]
 800812a:	ee60 0a80 	vmul.f32	s1, s1, s0
 800812e:	ed96 1a03 	vldr	s2, [r6, #12]
 8008132:	edc6 0a02 	vstr	s1, [r6, #8]
 8008136:	ee21 1a00 	vmul.f32	s2, s2, s0
 800813a:	ed86 1a03 	vstr	s2, [r6, #12]
 800813e:	f106 0610 	add.w	r6, r6, #16
 8008142:	d1e3      	bne.n	800810c <nl_func_sm_channel_f32+0xe4>
 8008144:	ecbd 8b02 	vpop	{d8}
 8008148:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

0800814c <nl_func_sm_array_f32>:
 800814c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8008150:	460d      	mov	r5, r1
 8008152:	4604      	mov	r4, r0
 8008154:	9f08      	ldr	r7, [sp, #32]
 8008156:	68a8      	ldr	r0, [r5, #8]
 8008158:	9e09      	ldr	r6, [sp, #36]	; 0x24
 800815a:	00bf      	lsls	r7, r7, #2
 800815c:	427f      	negs	r7, r7
 800815e:	eb00 0182 	add.w	r1, r0, r2, lsl #2
 8008162:	68a0      	ldr	r0, [r4, #8]
 8008164:	eb01 0a07 	add.w	sl, r1, r7
 8008168:	00b6      	lsls	r6, r6, #2
 800816a:	4276      	negs	r6, r6
 800816c:	eb00 0182 	add.w	r1, r0, r2, lsl #2
 8008170:	68ea      	ldr	r2, [r5, #12]
 8008172:	4592      	cmp	sl, r2
 8008174:	eb01 0906 	add.w	r9, r1, r6
 8008178:	d30f      	bcc.n	800819a <nl_func_sm_array_f32+0x4e>
 800817a:	4698      	mov	r8, r3
 800817c:	f8c5 a008 	str.w	sl, [r5, #8]
 8008180:	f8c4 9008 	str.w	r9, [r4, #8]
 8008184:	2300      	movs	r3, #0
 8008186:	4642      	mov	r2, r8
 8008188:	4629      	mov	r1, r5
 800818a:	4620      	mov	r0, r4
 800818c:	f7ff ff4c 	bl	8008028 <nl_func_sm_channel_f32>
 8008190:	68e8      	ldr	r0, [r5, #12]
 8008192:	44ba      	add	sl, r7
 8008194:	4582      	cmp	sl, r0
 8008196:	44b1      	add	r9, r6
 8008198:	d2f0      	bcs.n	800817c <nl_func_sm_array_f32+0x30>
 800819a:	68e9      	ldr	r1, [r5, #12]
 800819c:	60a9      	str	r1, [r5, #8]
 800819e:	68e0      	ldr	r0, [r4, #12]
 80081a0:	60a0      	str	r0, [r4, #8]
 80081a2:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	...

080081a8 <nl_func_hard_sigmoid_array_f32>:
 80081a8:	6889      	ldr	r1, [r1, #8]
 80081aa:	6880      	ldr	r0, [r0, #8]
 80081ac:	eb01 0382 	add.w	r3, r1, r2, lsl #2
 80081b0:	eb00 0282 	add.w	r2, r0, r2, lsl #2
 80081b4:	1f1b      	subs	r3, r3, #4
 80081b6:	1f10      	subs	r0, r2, #4
 80081b8:	428b      	cmp	r3, r1
 80081ba:	d321      	bcc.n	8008200 <nl_func_hard_sigmoid_array_f32+0x58>
 80081bc:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
 80081c0:	eddf 0ab8 	vldr	s1, [pc, #736]	; 80084a4 <.text_68>
 80081c4:	edd3 1a00 	vldr	s3, [r3]
 80081c8:	ed9f 2ab7 	vldr	s4, [pc, #732]	; 80084a8 <.text_69>
 80081cc:	eeb6 1a00 	vmov.f32	s2, #96	; 0x3f000000  0.5
 80081d0:	ee01 1a82 	vmla.f32	s2, s3, s4
 80081d4:	eeb4 1a60 	vcmp.f32	s2, s1
 80081d8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80081dc:	da08      	bge.n	80081f0 <nl_func_hard_sigmoid_array_f32+0x48>
 80081de:	eeb5 1a40 	vcmp.f32	s2, #0.0
 80081e2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80081e6:	d505      	bpl.n	80081f4 <nl_func_hard_sigmoid_array_f32+0x4c>
 80081e8:	ed9f 1a06 	vldr	s2, [pc, #24]	; 8008204 <.text_62>
 80081ec:	e002      	b.n	80081f4 <nl_func_hard_sigmoid_array_f32+0x4c>
 80081ee:	bf00      	nop
 80081f0:	eeb0 1a40 	vmov.f32	s2, s0
 80081f4:	ed80 1a00 	vstr	s2, [r0]
 80081f8:	1f1b      	subs	r3, r3, #4
 80081fa:	1f00      	subs	r0, r0, #4
 80081fc:	428b      	cmp	r3, r1
 80081fe:	d2e1      	bcs.n	80081c4 <nl_func_hard_sigmoid_array_f32+0x1c>
 8008200:	4770      	bx	lr
	...

08008204 <.text_62>:
 8008204:	00000000 	.word	0x00000000

08008208 <nl_func_clip_array_f32>:
 8008208:	6889      	ldr	r1, [r1, #8]
 800820a:	6880      	ldr	r0, [r0, #8]
 800820c:	ed93 0a00 	vldr	s0, [r3]
 8008210:	edd3 0a01 	vldr	s1, [r3, #4]
 8008214:	eb01 0382 	add.w	r3, r1, r2, lsl #2
 8008218:	eb00 0282 	add.w	r2, r0, r2, lsl #2
 800821c:	1f1b      	subs	r3, r3, #4
 800821e:	1f10      	subs	r0, r2, #4
 8008220:	428b      	cmp	r3, r1
 8008222:	d315      	bcc.n	8008250 <nl_func_clip_array_f32+0x48>
 8008224:	ed93 1a00 	vldr	s2, [r3]
 8008228:	eeb4 0a41 	vcmp.f32	s0, s2
 800822c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8008230:	bf58      	it	pl
 8008232:	eeb0 1a40 	vmovpl.f32	s2, s0
 8008236:	eeb4 1a60 	vcmp.f32	s2, s1
 800823a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800823e:	bf58      	it	pl
 8008240:	eeb0 1a60 	vmovpl.f32	s2, s1
 8008244:	ed80 1a00 	vstr	s2, [r0]
 8008248:	1f1b      	subs	r3, r3, #4
 800824a:	1f00      	subs	r0, r0, #4
 800824c:	428b      	cmp	r3, r1
 800824e:	d2e9      	bcs.n	8008224 <nl_func_clip_array_f32+0x1c>
 8008250:	4770      	bx	lr
	...

08008254 <nl_func_hardmax_array_f32>:
 8008254:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8008258:	6852      	ldr	r2, [r2, #4]
 800825a:	6855      	ldr	r5, [r2, #4]
 800825c:	68d4      	ldr	r4, [r2, #12]
 800825e:	688e      	ldr	r6, [r1, #8]
 8008260:	f8d0 8008 	ldr.w	r8, [r0, #8]
 8008264:	436c      	muls	r4, r5
 8008266:	00a1      	lsls	r1, r4, #2
 8008268:	4640      	mov	r0, r8
 800826a:	f01e ff3b 	bl	80270e4 <__aeabi_memclr>
 800826e:	2200      	movs	r2, #0
 8008270:	2c00      	cmp	r4, #0
 8008272:	4633      	mov	r3, r6
 8008274:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
 8008278:	f000 805b 	beq.w	8008332 <nl_func_hardmax_array_f32+0xde>
 800827c:	f102 0c01 	add.w	ip, r2, #1
 8008280:	eb05 0e02 	add.w	lr, r5, r2
 8008284:	45f4      	cmp	ip, lr
 8008286:	edd3 0a00 	vldr	s1, [r3]
 800828a:	d249      	bcs.n	8008320 <nl_func_hardmax_array_f32+0xcc>
 800828c:	1e69      	subs	r1, r5, #1
 800828e:	f011 0003 	ands.w	r0, r1, #3
 8008292:	eb06 078c 	add.w	r7, r6, ip, lsl #2
 8008296:	d00f      	beq.n	80082b8 <nl_func_hardmax_array_f32+0x64>
 8008298:	ed97 1a00 	vldr	s2, [r7]
 800829c:	eef4 0a41 	vcmp.f32	s1, s2
 80082a0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80082a4:	bf44      	itt	mi
 80082a6:	eef0 0a41 	vmovmi.f32	s1, s2
 80082aa:	4662      	movmi	r2, ip
 80082ac:	1e40      	subs	r0, r0, #1
 80082ae:	f10c 0c01 	add.w	ip, ip, #1
 80082b2:	f107 0704 	add.w	r7, r7, #4
 80082b6:	d1ef      	bne.n	8008298 <nl_func_hardmax_array_f32+0x44>
 80082b8:	0889      	lsrs	r1, r1, #2
 80082ba:	d031      	beq.n	8008320 <nl_func_hardmax_array_f32+0xcc>
 80082bc:	ed97 1a00 	vldr	s2, [r7]
 80082c0:	eef4 0a41 	vcmp.f32	s1, s2
 80082c4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80082c8:	bf44      	itt	mi
 80082ca:	eef0 0a41 	vmovmi.f32	s1, s2
 80082ce:	4662      	movmi	r2, ip
 80082d0:	ed97 1a01 	vldr	s2, [r7, #4]
 80082d4:	eef4 0a41 	vcmp.f32	s1, s2
 80082d8:	f10c 0001 	add.w	r0, ip, #1
 80082dc:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80082e0:	bf44      	itt	mi
 80082e2:	eef0 0a41 	vmovmi.f32	s1, s2
 80082e6:	4602      	movmi	r2, r0
 80082e8:	ed97 1a02 	vldr	s2, [r7, #8]
 80082ec:	1c40      	adds	r0, r0, #1
 80082ee:	eef4 0a41 	vcmp.f32	s1, s2
 80082f2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80082f6:	bf44      	itt	mi
 80082f8:	eef0 0a41 	vmovmi.f32	s1, s2
 80082fc:	4602      	movmi	r2, r0
 80082fe:	ed97 1a03 	vldr	s2, [r7, #12]
 8008302:	1c40      	adds	r0, r0, #1
 8008304:	eef4 0a41 	vcmp.f32	s1, s2
 8008308:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800830c:	bf44      	itt	mi
 800830e:	eef0 0a41 	vmovmi.f32	s1, s2
 8008312:	4602      	movmi	r2, r0
 8008314:	1e49      	subs	r1, r1, #1
 8008316:	f100 0c01 	add.w	ip, r0, #1
 800831a:	f107 0710 	add.w	r7, r7, #16
 800831e:	d1cd      	bne.n	80082bc <nl_func_hardmax_array_f32+0x68>
 8008320:	eb08 0082 	add.w	r0, r8, r2, lsl #2
 8008324:	4672      	mov	r2, lr
 8008326:	42a2      	cmp	r2, r4
 8008328:	ed80 0a00 	vstr	s0, [r0]
 800832c:	eb03 0385 	add.w	r3, r3, r5, lsl #2
 8008330:	d3a4      	bcc.n	800827c <nl_func_hardmax_array_f32+0x28>
 8008332:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	...

08008338 <nl_func_relu_generic_array_f32>:
 8008338:	6880      	ldr	r0, [r0, #8]
 800833a:	ed93 0a00 	vldr	s0, [r3]
 800833e:	edd3 0a01 	vldr	s1, [r3, #4]
 8008342:	ed93 1a02 	vldr	s2, [r3, #8]
 8008346:	6889      	ldr	r1, [r1, #8]
 8008348:	1f03      	subs	r3, r0, #4
 800834a:	eb03 0082 	add.w	r0, r3, r2, lsl #2
 800834e:	eeb5 1a40 	vcmp.f32	s2, #0.0
 8008352:	1f0b      	subs	r3, r1, #4
 8008354:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8008358:	eb03 0282 	add.w	r2, r3, r2, lsl #2
 800835c:	d52a      	bpl.n	80083b4 <nl_func_relu_generic_array_f32+0x7c>
 800835e:	eef5 0a40 	vcmp.f32	s1, #0.0
 8008362:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8008366:	d013      	beq.n	8008390 <nl_func_relu_generic_array_f32+0x58>
 8008368:	428a      	cmp	r2, r1
 800836a:	d310      	bcc.n	800838e <nl_func_relu_generic_array_f32+0x56>
 800836c:	ed92 1a00 	vldr	s2, [r2]
 8008370:	eeb4 1a40 	vcmp.f32	s2, s0
 8008374:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8008378:	bf44      	itt	mi
 800837a:	ee31 1a40 	vsubmi.f32	s2, s2, s0
 800837e:	ee21 1a20 	vmulmi.f32	s2, s2, s1
 8008382:	ed80 1a00 	vstr	s2, [r0]
 8008386:	1f12      	subs	r2, r2, #4
 8008388:	1f00      	subs	r0, r0, #4
 800838a:	428a      	cmp	r2, r1
 800838c:	d2ee      	bcs.n	800836c <nl_func_relu_generic_array_f32+0x34>
 800838e:	4770      	bx	lr
 8008390:	428a      	cmp	r2, r1
 8008392:	d3fc      	bcc.n	800838e <nl_func_relu_generic_array_f32+0x56>
 8008394:	edd2 0a00 	vldr	s1, [r2]
 8008398:	eef4 0a40 	vcmp.f32	s1, s0
 800839c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80083a0:	bf48      	it	mi
 80083a2:	eddf 0aa7 	vldrmi	s1, [pc, #668]	; 8008640 <.text_73>
 80083a6:	edc0 0a00 	vstr	s1, [r0]
 80083aa:	1f12      	subs	r2, r2, #4
 80083ac:	1f00      	subs	r0, r0, #4
 80083ae:	428a      	cmp	r2, r1
 80083b0:	d2f0      	bcs.n	8008394 <nl_func_relu_generic_array_f32+0x5c>
 80083b2:	4770      	bx	lr
 80083b4:	428a      	cmp	r2, r1
 80083b6:	d3ea      	bcc.n	800838e <nl_func_relu_generic_array_f32+0x56>
 80083b8:	edd2 1a00 	vldr	s3, [r2]
 80083bc:	eef4 1a41 	vcmp.f32	s3, s2
 80083c0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80083c4:	d50a      	bpl.n	80083dc <nl_func_relu_generic_array_f32+0xa4>
 80083c6:	eef4 1a40 	vcmp.f32	s3, s0
 80083ca:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80083ce:	d507      	bpl.n	80083e0 <nl_func_relu_generic_array_f32+0xa8>
 80083d0:	ee71 1ac0 	vsub.f32	s3, s3, s0
 80083d4:	ee61 1aa0 	vmul.f32	s3, s3, s1
 80083d8:	e002      	b.n	80083e0 <nl_func_relu_generic_array_f32+0xa8>
 80083da:	bf00      	nop
 80083dc:	eef0 1a41 	vmov.f32	s3, s2
 80083e0:	edc0 1a00 	vstr	s3, [r0]
 80083e4:	1f12      	subs	r2, r2, #4
 80083e6:	1f00      	subs	r0, r0, #4
 80083e8:	428a      	cmp	r2, r1
 80083ea:	d2e5      	bcs.n	80083b8 <nl_func_relu_generic_array_f32+0x80>
 80083ec:	4770      	bx	lr
	...

080083f0 <nl_func_relu_thresholded_array_f32>:
 80083f0:	6889      	ldr	r1, [r1, #8]
 80083f2:	6880      	ldr	r0, [r0, #8]
 80083f4:	ed93 0a00 	vldr	s0, [r3]
 80083f8:	eb01 0382 	add.w	r3, r1, r2, lsl #2
 80083fc:	eb00 0282 	add.w	r2, r0, r2, lsl #2
 8008400:	1f1b      	subs	r3, r3, #4
 8008402:	1f10      	subs	r0, r2, #4
 8008404:	428b      	cmp	r3, r1
 8008406:	d30e      	bcc.n	8008426 <nl_func_relu_thresholded_array_f32+0x36>
 8008408:	edd3 0a00 	vldr	s1, [r3]
 800840c:	eef4 0a40 	vcmp.f32	s1, s0
 8008410:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8008414:	bf48      	it	mi
 8008416:	eddf 0a8a 	vldrmi	s1, [pc, #552]	; 8008640 <.text_73>
 800841a:	edc0 0a00 	vstr	s1, [r0]
 800841e:	1f1b      	subs	r3, r3, #4
 8008420:	1f00      	subs	r0, r0, #4
 8008422:	428b      	cmp	r3, r1
 8008424:	d2f0      	bcs.n	8008408 <nl_func_relu_thresholded_array_f32+0x18>
 8008426:	4770      	bx	lr

08008428 <nl_func_elu_array_f32>:
 8008428:	b570      	push	{r4, r5, r6, lr}
 800842a:	ed2d 8b04 	vpush	{d8-d9}
 800842e:	688c      	ldr	r4, [r1, #8]
 8008430:	6880      	ldr	r0, [r0, #8]
 8008432:	ed93 8a00 	vldr	s16, [r3]
 8008436:	eb04 0182 	add.w	r1, r4, r2, lsl #2
 800843a:	1f0d      	subs	r5, r1, #4
 800843c:	eb00 0182 	add.w	r1, r0, r2, lsl #2
 8008440:	1f0e      	subs	r6, r1, #4
 8008442:	42a5      	cmp	r5, r4
 8008444:	f0c0 802a 	bcc.w	800849c <nl_func_elu_array_f32+0x74>
 8008448:	edd5 8a00 	vldr	s17, [r5]
 800844c:	eef5 8a40 	vcmp.f32	s17, #0.0
 8008450:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8008454:	bf4c      	ite	mi
 8008456:	ed9f 9a7a 	vldrmi	s18, [pc, #488]	; 8008640 <.text_73>
 800845a:	eeb0 9a68 	vmovpl.f32	s18, s17
 800845e:	eeb0 0a68 	vmov.f32	s0, s17
 8008462:	f022 fe0b 	bl	802b07c <expf>
 8008466:	eeff 0a00 	vmov.f32	s1, #240	; 0xbf800000 -1.0
 800846a:	ee30 0a20 	vadd.f32	s0, s0, s1
 800846e:	ee20 0a08 	vmul.f32	s0, s0, s16
 8008472:	eeb5 0a40 	vcmp.f32	s0, #0.0
 8008476:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800847a:	dc09      	bgt.n	8008490 <nl_func_elu_array_f32+0x68>
 800847c:	eeb0 0a68 	vmov.f32	s0, s17
 8008480:	f022 fdfc 	bl	802b07c <expf>
 8008484:	eeff 0a00 	vmov.f32	s1, #240	; 0xbf800000 -1.0
 8008488:	ee30 0a20 	vadd.f32	s0, s0, s1
 800848c:	ee00 9a08 	vmla.f32	s18, s0, s16
 8008490:	ed86 9a00 	vstr	s18, [r6]
 8008494:	1f2d      	subs	r5, r5, #4
 8008496:	1f36      	subs	r6, r6, #4
 8008498:	42a5      	cmp	r5, r4
 800849a:	d2d5      	bcs.n	8008448 <nl_func_elu_array_f32+0x20>
 800849c:	ecbd 8b04 	vpop	{d8-d9}
 80084a0:	bd70      	pop	{r4, r5, r6, pc}
	...

080084a4 <.text_68>:
 80084a4:	3f800001 	.word	0x3f800001

080084a8 <.text_69>:
 80084a8:	3e4ccccd 	.word	0x3e4ccccd

080084ac <nl_func_selu_array_f32>:
 80084ac:	b570      	push	{r4, r5, r6, lr}
 80084ae:	ed2d 8b04 	vpush	{d8-d9}
 80084b2:	688c      	ldr	r4, [r1, #8]
 80084b4:	6880      	ldr	r0, [r0, #8]
 80084b6:	ed93 8a00 	vldr	s16, [r3]
 80084ba:	edd3 8a01 	vldr	s17, [r3, #4]
 80084be:	eb04 0182 	add.w	r1, r4, r2, lsl #2
 80084c2:	1f0d      	subs	r5, r1, #4
 80084c4:	eb00 0182 	add.w	r1, r0, r2, lsl #2
 80084c8:	1f0e      	subs	r6, r1, #4
 80084ca:	42a5      	cmp	r5, r4
 80084cc:	f0c0 802c 	bcc.w	8008528 <nl_func_selu_array_f32+0x7c>
 80084d0:	ed95 9a00 	vldr	s18, [r5]
 80084d4:	eeb5 9a40 	vcmp.f32	s18, #0.0
 80084d8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80084dc:	bf4c      	ite	mi
 80084de:	eddf 9a58 	vldrmi	s19, [pc, #352]	; 8008640 <.text_73>
 80084e2:	eef0 9a49 	vmovpl.f32	s19, s18
 80084e6:	eeb0 0a49 	vmov.f32	s0, s18
 80084ea:	f022 fdc7 	bl	802b07c <expf>
 80084ee:	eeff 0a00 	vmov.f32	s1, #240	; 0xbf800000 -1.0
 80084f2:	ee30 0a20 	vadd.f32	s0, s0, s1
 80084f6:	ee20 0a08 	vmul.f32	s0, s0, s16
 80084fa:	eeb5 0a40 	vcmp.f32	s0, #0.0
 80084fe:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8008502:	dc09      	bgt.n	8008518 <nl_func_selu_array_f32+0x6c>
 8008504:	eeb0 0a49 	vmov.f32	s0, s18
 8008508:	f022 fdb8 	bl	802b07c <expf>
 800850c:	eeff 0a00 	vmov.f32	s1, #240	; 0xbf800000 -1.0
 8008510:	ee30 0a20 	vadd.f32	s0, s0, s1
 8008514:	ee40 9a08 	vmla.f32	s19, s0, s16
 8008518:	ee28 0aa9 	vmul.f32	s0, s17, s19
 800851c:	ed86 0a00 	vstr	s0, [r6]
 8008520:	1f2d      	subs	r5, r5, #4
 8008522:	1f36      	subs	r6, r6, #4
 8008524:	42a5      	cmp	r5, r4
 8008526:	d2d3      	bcs.n	80084d0 <nl_func_selu_array_f32+0x24>
 8008528:	ecbd 8b04 	vpop	{d8-d9}
 800852c:	bd70      	pop	{r4, r5, r6, pc}
	...

08008530 <nl_func_prelu_array_f32>:
 8008530:	6889      	ldr	r1, [r1, #8]
 8008532:	6880      	ldr	r0, [r0, #8]
 8008534:	eb03 0382 	add.w	r3, r3, r2, lsl #2
 8008538:	eb01 0c82 	add.w	ip, r1, r2, lsl #2
 800853c:	eb00 0282 	add.w	r2, r0, r2, lsl #2
 8008540:	1f1b      	subs	r3, r3, #4
 8008542:	f1ac 0c04 	sub.w	ip, ip, #4
 8008546:	1f10      	subs	r0, r2, #4
 8008548:	458c      	cmp	ip, r1
 800854a:	d320      	bcc.n	800858e <nl_func_prelu_array_f32+0x5e>
 800854c:	ed9c 0a00 	vldr	s0, [ip]
 8008550:	eeb5 0a40 	vcmp.f32	s0, #0.0
 8008554:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8008558:	bf4c      	ite	mi
 800855a:	eddf 0a39 	vldrmi	s1, [pc, #228]	; 8008640 <.text_73>
 800855e:	eef0 0a40 	vmovpl.f32	s1, s0
 8008562:	461a      	mov	r2, r3
 8008564:	eeb1 0a40 	vneg.f32	s0, s0
 8008568:	1f13      	subs	r3, r2, #4
 800856a:	eeb5 0a40 	vcmp.f32	s0, #0.0
 800856e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8008572:	bf48      	it	mi
 8008574:	ed9f 0a32 	vldrmi	s0, [pc, #200]	; 8008640 <.text_73>
 8008578:	ed92 1a00 	vldr	s2, [r2]
 800857c:	ee41 0a40 	vmls.f32	s1, s2, s0
 8008580:	edc0 0a00 	vstr	s1, [r0]
 8008584:	f1ac 0c04 	sub.w	ip, ip, #4
 8008588:	1f00      	subs	r0, r0, #4
 800858a:	458c      	cmp	ip, r1
 800858c:	d2de      	bcs.n	800854c <nl_func_prelu_array_f32+0x1c>
 800858e:	4770      	bx	lr

08008590 <forward_relu>:
 8008590:	b570      	push	{r4, r5, r6, lr}
 8008592:	4604      	mov	r4, r0
 8008594:	6962      	ldr	r2, [r4, #20]
 8008596:	8811      	ldrh	r1, [r2, #0]
 8008598:	2900      	cmp	r1, #0
 800859a:	bf1a      	itte	ne
 800859c:	6850      	ldrne	r0, [r2, #4]
 800859e:	1d00      	addne	r0, r0, #4
 80085a0:	2004      	moveq	r0, #4
 80085a2:	6800      	ldr	r0, [r0, #0]
 80085a4:	2800      	cmp	r0, #0
 80085a6:	bf14      	ite	ne
 80085a8:	6805      	ldrne	r5, [r0, #0]
 80085aa:	2500      	moveq	r5, #0
 80085ac:	2902      	cmp	r1, #2
 80085ae:	bfa6      	itte	ge
 80085b0:	6850      	ldrge	r0, [r2, #4]
 80085b2:	3010      	addge	r0, #16
 80085b4:	2004      	movlt	r0, #4
 80085b6:	6800      	ldr	r0, [r0, #0]
 80085b8:	2800      	cmp	r0, #0
 80085ba:	bf19      	ittee	ne
 80085bc:	6800      	ldrne	r0, [r0, #0]
 80085be:	f100 0618 	addne.w	r6, r0, #24
 80085c2:	2100      	moveq	r1, #0
 80085c4:	f101 0618 	addeq.w	r6, r1, #24
 80085c8:	69a0      	ldr	r0, [r4, #24]
 80085ca:	b9f8      	cbnz	r0, 800860c <forward_relu+0x7c>
 80085cc:	f105 0008 	add.w	r0, r5, #8
 80085d0:	f7fe f80a 	bl	80065e8 <ai_shape_get_size>
 80085d4:	69a9      	ldr	r1, [r5, #24]
 80085d6:	6833      	ldr	r3, [r6, #0]
 80085d8:	6889      	ldr	r1, [r1, #8]
 80085da:	689c      	ldr	r4, [r3, #8]
 80085dc:	eb01 0280 	add.w	r2, r1, r0, lsl #2
 80085e0:	eb04 0080 	add.w	r0, r4, r0, lsl #2
 80085e4:	1f12      	subs	r2, r2, #4
 80085e6:	1f00      	subs	r0, r0, #4
 80085e8:	428a      	cmp	r2, r1
 80085ea:	d328      	bcc.n	800863e <forward_relu+0xae>
 80085ec:	ed92 0a00 	vldr	s0, [r2]
 80085f0:	eeb5 0a40 	vcmp.f32	s0, #0.0
 80085f4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80085f8:	bf48      	it	mi
 80085fa:	ed9f 0a11 	vldrmi	s0, [pc, #68]	; 8008640 <.text_73>
 80085fe:	ed80 0a00 	vstr	s0, [r0]
 8008602:	1f12      	subs	r2, r2, #4
 8008604:	1f00      	subs	r0, r0, #4
 8008606:	428a      	cmp	r2, r1
 8008608:	d2f0      	bcs.n	80085ec <forward_relu+0x5c>
 800860a:	bd70      	pop	{r4, r5, r6, pc}
 800860c:	6840      	ldr	r0, [r0, #4]
 800860e:	2801      	cmp	r0, #1
 8008610:	f105 0008 	add.w	r0, r5, #8
 8008614:	d109      	bne.n	800862a <forward_relu+0x9a>
 8008616:	f7fd ffe7 	bl	80065e8 <ai_shape_get_size>
 800861a:	4602      	mov	r2, r0
 800861c:	69a0      	ldr	r0, [r4, #24]
 800861e:	6883      	ldr	r3, [r0, #8]
 8008620:	69a9      	ldr	r1, [r5, #24]
 8008622:	6830      	ldr	r0, [r6, #0]
 8008624:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
 8008628:	e6e2      	b.n	80083f0 <nl_func_relu_thresholded_array_f32>
 800862a:	f7fd ffdd 	bl	80065e8 <ai_shape_get_size>
 800862e:	69a1      	ldr	r1, [r4, #24]
 8008630:	688b      	ldr	r3, [r1, #8]
 8008632:	69a9      	ldr	r1, [r5, #24]
 8008634:	4602      	mov	r2, r0
 8008636:	6830      	ldr	r0, [r6, #0]
 8008638:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
 800863c:	e67c      	b.n	8008338 <nl_func_relu_generic_array_f32>
 800863e:	bd70      	pop	{r4, r5, r6, pc}

08008640 <.text_73>:
 8008640:	00000000 	.word	0x00000000

08008644 <forward_relu_thresholded>:
 8008644:	b5f0      	push	{r4, r5, r6, r7, lr}
 8008646:	4602      	mov	r2, r0
 8008648:	f04f 0601 	mov.w	r6, #1
 800864c:	6953      	ldr	r3, [r2, #20]
 800864e:	8819      	ldrh	r1, [r3, #0]
 8008650:	2900      	cmp	r1, #0
 8008652:	bf1a      	itte	ne
 8008654:	6858      	ldrne	r0, [r3, #4]
 8008656:	1d00      	addne	r0, r0, #4
 8008658:	2004      	moveq	r0, #4
 800865a:	6800      	ldr	r0, [r0, #0]
 800865c:	2800      	cmp	r0, #0
 800865e:	bf14      	ite	ne
 8008660:	6804      	ldrne	r4, [r0, #0]
 8008662:	2400      	moveq	r4, #0
 8008664:	2902      	cmp	r1, #2
 8008666:	bfa6      	itte	ge
 8008668:	6858      	ldrge	r0, [r3, #4]
 800866a:	3010      	addge	r0, #16
 800866c:	2004      	movlt	r0, #4
 800866e:	6800      	ldr	r0, [r0, #0]
 8008670:	2800      	cmp	r0, #0
 8008672:	bf19      	ittee	ne
 8008674:	6800      	ldrne	r0, [r0, #0]
 8008676:	f100 0518 	addne.w	r5, r0, #24
 800867a:	2100      	moveq	r1, #0
 800867c:	f101 0518 	addeq.w	r5, r1, #24
 8008680:	f104 0108 	add.w	r1, r4, #8
 8008684:	680b      	ldr	r3, [r1, #0]
 8008686:	0a1b      	lsrs	r3, r3, #8
 8008688:	d01f      	beq.n	80086ca <forward_relu_thresholded+0x86>
 800868a:	684f      	ldr	r7, [r1, #4]
 800868c:	eb07 0183 	add.w	r1, r7, r3, lsl #2
 8008690:	4618      	mov	r0, r3
 8008692:	f1a1 0c04 	sub.w	ip, r1, #4
 8008696:	f010 0103 	ands.w	r1, r0, #3
 800869a:	d006      	beq.n	80086aa <forward_relu_thresholded+0x66>
 800869c:	1e5b      	subs	r3, r3, #1
 800869e:	f85c e904 	ldr.w	lr, [ip], #-4
 80086a2:	1e49      	subs	r1, r1, #1
 80086a4:	fb0e f606 	mul.w	r6, lr, r6
 80086a8:	d1f8      	bne.n	800869c <forward_relu_thresholded+0x58>
 80086aa:	0880      	lsrs	r0, r0, #2
 80086ac:	d00d      	beq.n	80086ca <forward_relu_thresholded+0x86>
 80086ae:	eb07 0183 	add.w	r1, r7, r3, lsl #2
 80086b2:	3910      	subs	r1, #16
 80086b4:	68cb      	ldr	r3, [r1, #12]
 80086b6:	688f      	ldr	r7, [r1, #8]
 80086b8:	437b      	muls	r3, r7
 80086ba:	684f      	ldr	r7, [r1, #4]
 80086bc:	437b      	muls	r3, r7
 80086be:	f851 7910 	ldr.w	r7, [r1], #-16
 80086c2:	437b      	muls	r3, r7
 80086c4:	435e      	muls	r6, r3
 80086c6:	1e40      	subs	r0, r0, #1
 80086c8:	d1f4      	bne.n	80086b4 <forward_relu_thresholded+0x70>
 80086ca:	6990      	ldr	r0, [r2, #24]
 80086cc:	6881      	ldr	r1, [r0, #8]
 80086ce:	69a0      	ldr	r0, [r4, #24]
 80086d0:	682a      	ldr	r2, [r5, #0]
 80086d2:	6880      	ldr	r0, [r0, #8]
 80086d4:	6893      	ldr	r3, [r2, #8]
 80086d6:	ed91 0a00 	vldr	s0, [r1]
 80086da:	eb00 0186 	add.w	r1, r0, r6, lsl #2
 80086de:	eb03 0486 	add.w	r4, r3, r6, lsl #2
 80086e2:	1f09      	subs	r1, r1, #4
 80086e4:	1f22      	subs	r2, r4, #4
 80086e6:	4281      	cmp	r1, r0
 80086e8:	f0c0 800f 	bcc.w	800870a <forward_relu_thresholded+0xc6>
 80086ec:	edd1 0a00 	vldr	s1, [r1]
 80086f0:	eef4 0a40 	vcmp.f32	s1, s0
 80086f4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80086f8:	bf48      	it	mi
 80086fa:	eddf 0ac2 	vldrmi	s1, [pc, #776]	; 8008a04 <.text_80>
 80086fe:	edc2 0a00 	vstr	s1, [r2]
 8008702:	1f09      	subs	r1, r1, #4
 8008704:	1f12      	subs	r2, r2, #4
 8008706:	4281      	cmp	r1, r0
 8008708:	d2f0      	bcs.n	80086ec <forward_relu_thresholded+0xa8>
 800870a:	bdf0      	pop	{r4, r5, r6, r7, pc}

0800870c <forward_elu>:
 800870c:	b570      	push	{r4, r5, r6, lr}
 800870e:	4604      	mov	r4, r0
 8008710:	6962      	ldr	r2, [r4, #20]
 8008712:	8811      	ldrh	r1, [r2, #0]
 8008714:	2900      	cmp	r1, #0
 8008716:	bf1a      	itte	ne
 8008718:	6850      	ldrne	r0, [r2, #4]
 800871a:	1d00      	addne	r0, r0, #4
 800871c:	2004      	moveq	r0, #4
 800871e:	6800      	ldr	r0, [r0, #0]
 8008720:	2800      	cmp	r0, #0
 8008722:	bf14      	ite	ne
 8008724:	6805      	ldrne	r5, [r0, #0]
 8008726:	2500      	moveq	r5, #0
 8008728:	2902      	cmp	r1, #2
 800872a:	bfa6      	itte	ge
 800872c:	6850      	ldrge	r0, [r2, #4]
 800872e:	3010      	addge	r0, #16
 8008730:	2004      	movlt	r0, #4
 8008732:	6800      	ldr	r0, [r0, #0]
 8008734:	2800      	cmp	r0, #0
 8008736:	bf19      	ittee	ne
 8008738:	6800      	ldrne	r0, [r0, #0]
 800873a:	f100 0618 	addne.w	r6, r0, #24
 800873e:	2100      	moveq	r1, #0
 8008740:	f101 0618 	addeq.w	r6, r1, #24
 8008744:	f105 0008 	add.w	r0, r5, #8
 8008748:	f7fd ff4e 	bl	80065e8 <ai_shape_get_size>
 800874c:	4602      	mov	r2, r0
 800874e:	69a0      	ldr	r0, [r4, #24]
 8008750:	6883      	ldr	r3, [r0, #8]
 8008752:	69a9      	ldr	r1, [r5, #24]
 8008754:	6830      	ldr	r0, [r6, #0]
 8008756:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
 800875a:	e665      	b.n	8008428 <nl_func_elu_array_f32>

0800875c <forward_selu>:
 800875c:	b570      	push	{r4, r5, r6, lr}
 800875e:	4604      	mov	r4, r0
 8008760:	6962      	ldr	r2, [r4, #20]
 8008762:	8811      	ldrh	r1, [r2, #0]
 8008764:	2900      	cmp	r1, #0
 8008766:	bf1a      	itte	ne
 8008768:	6850      	ldrne	r0, [r2, #4]
 800876a:	1d00      	addne	r0, r0, #4
 800876c:	2004      	moveq	r0, #4
 800876e:	6800      	ldr	r0, [r0, #0]
 8008770:	2800      	cmp	r0, #0
 8008772:	bf14      	ite	ne
 8008774:	6805      	ldrne	r5, [r0, #0]
 8008776:	2500      	moveq	r5, #0
 8008778:	2902      	cmp	r1, #2
 800877a:	bfa6      	itte	ge
 800877c:	6850      	ldrge	r0, [r2, #4]
 800877e:	3010      	addge	r0, #16
 8008780:	2004      	movlt	r0, #4
 8008782:	6800      	ldr	r0, [r0, #0]
 8008784:	2800      	cmp	r0, #0
 8008786:	bf19      	ittee	ne
 8008788:	6800      	ldrne	r0, [r0, #0]
 800878a:	f100 0618 	addne.w	r6, r0, #24
 800878e:	2100      	moveq	r1, #0
 8008790:	f101 0618 	addeq.w	r6, r1, #24
 8008794:	f105 0008 	add.w	r0, r5, #8
 8008798:	f7fd ff26 	bl	80065e8 <ai_shape_get_size>
 800879c:	4602      	mov	r2, r0
 800879e:	69a0      	ldr	r0, [r4, #24]
 80087a0:	6883      	ldr	r3, [r0, #8]
 80087a2:	69a9      	ldr	r1, [r5, #24]
 80087a4:	6830      	ldr	r0, [r6, #0]
 80087a6:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
 80087aa:	e67f      	b.n	80084ac <nl_func_selu_array_f32>

080087ac <forward_prelu>:
 80087ac:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80087b0:	b083      	sub	sp, #12
 80087b2:	6942      	ldr	r2, [r0, #20]
 80087b4:	8810      	ldrh	r0, [r2, #0]
 80087b6:	2800      	cmp	r0, #0
 80087b8:	bf1a      	itte	ne
 80087ba:	6851      	ldrne	r1, [r2, #4]
 80087bc:	1d09      	addne	r1, r1, #4
 80087be:	2104      	moveq	r1, #4
 80087c0:	6809      	ldr	r1, [r1, #0]
 80087c2:	2900      	cmp	r1, #0
 80087c4:	bf19      	ittee	ne
 80087c6:	6809      	ldrne	r1, [r1, #0]
 80087c8:	f101 0518 	addne.w	r5, r1, #24
 80087cc:	2300      	moveq	r3, #0
 80087ce:	f103 0518 	addeq.w	r5, r3, #24
 80087d2:	2801      	cmp	r0, #1
 80087d4:	bfc6      	itte	gt
 80087d6:	6851      	ldrgt	r1, [r2, #4]
 80087d8:	3110      	addgt	r1, #16
 80087da:	2104      	movle	r1, #4
 80087dc:	6809      	ldr	r1, [r1, #0]
 80087de:	2900      	cmp	r1, #0
 80087e0:	bf19      	ittee	ne
 80087e2:	6809      	ldrne	r1, [r1, #0]
 80087e4:	f101 0618 	addne.w	r6, r1, #24
 80087e8:	2300      	moveq	r3, #0
 80087ea:	f103 0618 	addeq.w	r6, r3, #24
 80087ee:	2802      	cmp	r0, #2
 80087f0:	bfc6      	itte	gt
 80087f2:	6850      	ldrgt	r0, [r2, #4]
 80087f4:	301c      	addgt	r0, #28
 80087f6:	2004      	movle	r0, #4
 80087f8:	6800      	ldr	r0, [r0, #0]
 80087fa:	2800      	cmp	r0, #0
 80087fc:	bf14      	ite	ne
 80087fe:	6804      	ldrne	r4, [r0, #0]
 8008800:	2400      	moveq	r4, #0
 8008802:	69a0      	ldr	r0, [r4, #24]
 8008804:	6887      	ldr	r7, [r0, #8]
 8008806:	b12c      	cbz	r4, 8008814 <forward_prelu+0x68>
 8008808:	6841      	ldr	r1, [r0, #4]
 800880a:	6800      	ldr	r0, [r0, #0]
 800880c:	f001 fb9e 	bl	8009f4c <ai_array_get_byte_size>
 8008810:	4680      	mov	r8, r0
 8008812:	e001      	b.n	8008818 <forward_prelu+0x6c>
 8008814:	f04f 0801 	mov.w	r8, #1
 8008818:	6828      	ldr	r0, [r5, #0]
 800881a:	6841      	ldr	r1, [r0, #4]
 800881c:	6800      	ldr	r0, [r0, #0]
 800881e:	f001 fb95 	bl	8009f4c <ai_array_get_byte_size>
 8008822:	4601      	mov	r1, r0
 8008824:	6828      	ldr	r0, [r5, #0]
 8008826:	6832      	ldr	r2, [r6, #0]
 8008828:	6880      	ldr	r0, [r0, #8]
 800882a:	f8d2 9008 	ldr.w	r9, [r2, #8]
 800882e:	4401      	add	r1, r0
 8008830:	f104 0308 	add.w	r3, r4, #8
 8008834:	4288      	cmp	r0, r1
 8008836:	9300      	str	r3, [sp, #0]
 8008838:	d241      	bcs.n	80088be <forward_prelu+0x112>
 800883a:	9702      	str	r7, [sp, #8]
 800883c:	9101      	str	r1, [sp, #4]
 800883e:	4607      	mov	r7, r0
 8008840:	6829      	ldr	r1, [r5, #0]
 8008842:	608f      	str	r7, [r1, #8]
 8008844:	f04f 0201 	mov.w	r2, #1
 8008848:	6834      	ldr	r4, [r6, #0]
 800884a:	f8c4 9008 	str.w	r9, [r4, #8]
 800884e:	9b00      	ldr	r3, [sp, #0]
 8008850:	6818      	ldr	r0, [r3, #0]
 8008852:	0a00      	lsrs	r0, r0, #8
 8008854:	d02a      	beq.n	80088ac <forward_prelu+0x100>
 8008856:	f8d3 e004 	ldr.w	lr, [r3, #4]
 800885a:	eb0e 0380 	add.w	r3, lr, r0, lsl #2
 800885e:	4684      	mov	ip, r0
 8008860:	f1a3 0a04 	sub.w	sl, r3, #4
 8008864:	f01c 0303 	ands.w	r3, ip, #3
 8008868:	d006      	beq.n	8008878 <forward_prelu+0xcc>
 800886a:	1e40      	subs	r0, r0, #1
 800886c:	f85a b904 	ldr.w	fp, [sl], #-4
 8008870:	1e5b      	subs	r3, r3, #1
 8008872:	fb0b f202 	mul.w	r2, fp, r2
 8008876:	d1f8      	bne.n	800886a <forward_prelu+0xbe>
 8008878:	ea5f 0c9c 	movs.w	ip, ip, lsr #2
 800887c:	4663      	mov	r3, ip
 800887e:	d015      	beq.n	80088ac <forward_prelu+0x100>
 8008880:	eb0e 0080 	add.w	r0, lr, r0, lsl #2
 8008884:	f1b0 0010 	subs.w	r0, r0, #16
 8008888:	f8d0 c00c 	ldr.w	ip, [r0, #12]
 800888c:	f8d0 e008 	ldr.w	lr, [r0, #8]
 8008890:	f8d0 a004 	ldr.w	sl, [r0, #4]
 8008894:	f850 b910 	ldr.w	fp, [r0], #-16
 8008898:	fb0e fc0c 	mul.w	ip, lr, ip
 800889c:	fb0a fc0c 	mul.w	ip, sl, ip
 80088a0:	fb0b fc0c 	mul.w	ip, fp, ip
 80088a4:	1e5b      	subs	r3, r3, #1
 80088a6:	fb0c f202 	mul.w	r2, ip, r2
 80088aa:	d1ed      	bne.n	8008888 <forward_prelu+0xdc>
 80088ac:	9b02      	ldr	r3, [sp, #8]
 80088ae:	4620      	mov	r0, r4
 80088b0:	f7ff fe3e 	bl	8008530 <nl_func_prelu_array_f32>
 80088b4:	9801      	ldr	r0, [sp, #4]
 80088b6:	4447      	add	r7, r8
 80088b8:	4287      	cmp	r7, r0
 80088ba:	44c1      	add	r9, r8
 80088bc:	d3c0      	bcc.n	8008840 <forward_prelu+0x94>
 80088be:	6828      	ldr	r0, [r5, #0]
 80088c0:	68c1      	ldr	r1, [r0, #12]
 80088c2:	6081      	str	r1, [r0, #8]
 80088c4:	6830      	ldr	r0, [r6, #0]
 80088c6:	68c1      	ldr	r1, [r0, #12]
 80088c8:	6081      	str	r1, [r0, #8]
 80088ca:	b003      	add	sp, #12
 80088cc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

080088d0 <forward_clip>:
 80088d0:	b570      	push	{r4, r5, r6, lr}
 80088d2:	4604      	mov	r4, r0
 80088d4:	6962      	ldr	r2, [r4, #20]
 80088d6:	8811      	ldrh	r1, [r2, #0]
 80088d8:	2900      	cmp	r1, #0
 80088da:	bf1a      	itte	ne
 80088dc:	6850      	ldrne	r0, [r2, #4]
 80088de:	1d00      	addne	r0, r0, #4
 80088e0:	2004      	moveq	r0, #4
 80088e2:	6800      	ldr	r0, [r0, #0]
 80088e4:	2800      	cmp	r0, #0
 80088e6:	bf14      	ite	ne
 80088e8:	6805      	ldrne	r5, [r0, #0]
 80088ea:	2500      	moveq	r5, #0
 80088ec:	2902      	cmp	r1, #2
 80088ee:	bfa6      	itte	ge
 80088f0:	6850      	ldrge	r0, [r2, #4]
 80088f2:	3010      	addge	r0, #16
 80088f4:	2004      	movlt	r0, #4
 80088f6:	6800      	ldr	r0, [r0, #0]
 80088f8:	2800      	cmp	r0, #0
 80088fa:	bf19      	ittee	ne
 80088fc:	6800      	ldrne	r0, [r0, #0]
 80088fe:	f100 0618 	addne.w	r6, r0, #24
 8008902:	2100      	moveq	r1, #0
 8008904:	f101 0618 	addeq.w	r6, r1, #24
 8008908:	f105 0008 	add.w	r0, r5, #8
 800890c:	f7fd fe6c 	bl	80065e8 <ai_shape_get_size>
 8008910:	4602      	mov	r2, r0
 8008912:	69a0      	ldr	r0, [r4, #24]
 8008914:	6883      	ldr	r3, [r0, #8]
 8008916:	69a9      	ldr	r1, [r5, #24]
 8008918:	6830      	ldr	r0, [r6, #0]
 800891a:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
 800891e:	e473      	b.n	8008208 <nl_func_clip_array_f32>

08008920 <forward_hard_sigmoid>:
 8008920:	b4f0      	push	{r4, r5, r6, r7}
 8008922:	6942      	ldr	r2, [r0, #20]
 8008924:	8811      	ldrh	r1, [r2, #0]
 8008926:	2900      	cmp	r1, #0
 8008928:	bf1a      	itte	ne
 800892a:	6850      	ldrne	r0, [r2, #4]
 800892c:	1d00      	addne	r0, r0, #4
 800892e:	2004      	moveq	r0, #4
 8008930:	f04f 0501 	mov.w	r5, #1
 8008934:	6800      	ldr	r0, [r0, #0]
 8008936:	2800      	cmp	r0, #0
 8008938:	bf14      	ite	ne
 800893a:	6803      	ldrne	r3, [r0, #0]
 800893c:	2300      	moveq	r3, #0
 800893e:	2902      	cmp	r1, #2
 8008940:	bfa6      	itte	ge
 8008942:	6850      	ldrge	r0, [r2, #4]
 8008944:	3010      	addge	r0, #16
 8008946:	2004      	movlt	r0, #4
 8008948:	6800      	ldr	r0, [r0, #0]
 800894a:	2800      	cmp	r0, #0
 800894c:	bf19      	ittee	ne
 800894e:	6800      	ldrne	r0, [r0, #0]
 8008950:	f100 0418 	addne.w	r4, r0, #24
 8008954:	2100      	moveq	r1, #0
 8008956:	f101 0418 	addeq.w	r4, r1, #24
 800895a:	f103 0108 	add.w	r1, r3, #8
 800895e:	680a      	ldr	r2, [r1, #0]
 8008960:	0a12      	lsrs	r2, r2, #8
 8008962:	d01e      	beq.n	80089a2 <forward_hard_sigmoid+0x82>
 8008964:	684e      	ldr	r6, [r1, #4]
 8008966:	eb06 0182 	add.w	r1, r6, r2, lsl #2
 800896a:	4610      	mov	r0, r2
 800896c:	1f0f      	subs	r7, r1, #4
 800896e:	f010 0103 	ands.w	r1, r0, #3
 8008972:	d006      	beq.n	8008982 <forward_hard_sigmoid+0x62>
 8008974:	1e52      	subs	r2, r2, #1
 8008976:	f857 c904 	ldr.w	ip, [r7], #-4
 800897a:	1e49      	subs	r1, r1, #1
 800897c:	fb0c f505 	mul.w	r5, ip, r5
 8008980:	d1f8      	bne.n	8008974 <forward_hard_sigmoid+0x54>
 8008982:	0880      	lsrs	r0, r0, #2
 8008984:	d00d      	beq.n	80089a2 <forward_hard_sigmoid+0x82>
 8008986:	eb06 0182 	add.w	r1, r6, r2, lsl #2
 800898a:	3910      	subs	r1, #16
 800898c:	68ca      	ldr	r2, [r1, #12]
 800898e:	688e      	ldr	r6, [r1, #8]
 8008990:	684f      	ldr	r7, [r1, #4]
 8008992:	4372      	muls	r2, r6
 8008994:	f851 6910 	ldr.w	r6, [r1], #-16
 8008998:	437a      	muls	r2, r7
 800899a:	4372      	muls	r2, r6
 800899c:	4355      	muls	r5, r2
 800899e:	1e40      	subs	r0, r0, #1
 80089a0:	d1f4      	bne.n	800898c <forward_hard_sigmoid+0x6c>
 80089a2:	6998      	ldr	r0, [r3, #24]
 80089a4:	6822      	ldr	r2, [r4, #0]
 80089a6:	6880      	ldr	r0, [r0, #8]
 80089a8:	6893      	ldr	r3, [r2, #8]
 80089aa:	eb00 0185 	add.w	r1, r0, r5, lsl #2
 80089ae:	eb03 0485 	add.w	r4, r3, r5, lsl #2
 80089b2:	1f09      	subs	r1, r1, #4
 80089b4:	1f22      	subs	r2, r4, #4
 80089b6:	4281      	cmp	r1, r0
 80089b8:	f0c0 8022 	bcc.w	8008a00 <forward_hard_sigmoid+0xe0>
 80089bc:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
 80089c0:	eddf 0a11 	vldr	s1, [pc, #68]	; 8008a08 <.text_81>
 80089c4:	edd1 1a00 	vldr	s3, [r1]
 80089c8:	ed9f 2a10 	vldr	s4, [pc, #64]	; 8008a0c <.text_82>
 80089cc:	eeb6 1a00 	vmov.f32	s2, #96	; 0x3f000000  0.5
 80089d0:	ee01 1a82 	vmla.f32	s2, s3, s4
 80089d4:	eeb4 1a60 	vcmp.f32	s2, s1
 80089d8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80089dc:	da08      	bge.n	80089f0 <forward_hard_sigmoid+0xd0>
 80089de:	eeb5 1a40 	vcmp.f32	s2, #0.0
 80089e2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80089e6:	d505      	bpl.n	80089f4 <forward_hard_sigmoid+0xd4>
 80089e8:	ed9f 1a06 	vldr	s2, [pc, #24]	; 8008a04 <.text_80>
 80089ec:	e002      	b.n	80089f4 <forward_hard_sigmoid+0xd4>
 80089ee:	bf00      	nop
 80089f0:	eeb0 1a40 	vmov.f32	s2, s0
 80089f4:	ed82 1a00 	vstr	s2, [r2]
 80089f8:	1f09      	subs	r1, r1, #4
 80089fa:	1f12      	subs	r2, r2, #4
 80089fc:	4281      	cmp	r1, r0
 80089fe:	d2e1      	bcs.n	80089c4 <forward_hard_sigmoid+0xa4>
 8008a00:	bcf0      	pop	{r4, r5, r6, r7}
 8008a02:	4770      	bx	lr

08008a04 <.text_80>:
 8008a04:	00000000 	.word	0x00000000

08008a08 <.text_81>:
 8008a08:	3f800001 	.word	0x3f800001

08008a0c <.text_82>:
 8008a0c:	3e4ccccd 	.word	0x3e4ccccd

08008a10 <forward_sm>:
 8008a10:	b5f0      	push	{r4, r5, r6, r7, lr}
 8008a12:	b083      	sub	sp, #12
 8008a14:	6942      	ldr	r2, [r0, #20]
 8008a16:	8811      	ldrh	r1, [r2, #0]
 8008a18:	2900      	cmp	r1, #0
 8008a1a:	bf1a      	itte	ne
 8008a1c:	6850      	ldrne	r0, [r2, #4]
 8008a1e:	1d00      	addne	r0, r0, #4
 8008a20:	2004      	moveq	r0, #4
 8008a22:	6800      	ldr	r0, [r0, #0]
 8008a24:	2800      	cmp	r0, #0
 8008a26:	bf14      	ite	ne
 8008a28:	6804      	ldrne	r4, [r0, #0]
 8008a2a:	2400      	moveq	r4, #0
 8008a2c:	2902      	cmp	r1, #2
 8008a2e:	bfa6      	itte	ge
 8008a30:	6850      	ldrge	r0, [r2, #4]
 8008a32:	3010      	addge	r0, #16
 8008a34:	2004      	movlt	r0, #4
 8008a36:	6800      	ldr	r0, [r0, #0]
 8008a38:	2800      	cmp	r0, #0
 8008a3a:	bf14      	ite	ne
 8008a3c:	6805      	ldrne	r5, [r0, #0]
 8008a3e:	2500      	moveq	r5, #0
 8008a40:	68e0      	ldr	r0, [r4, #12]
 8008a42:	68e9      	ldr	r1, [r5, #12]
 8008a44:	6846      	ldr	r6, [r0, #4]
 8008a46:	684f      	ldr	r7, [r1, #4]
 8008a48:	f104 0008 	add.w	r0, r4, #8
 8008a4c:	f7fd fdcc 	bl	80065e8 <ai_shape_get_size>
 8008a50:	4602      	mov	r2, r0
 8008a52:	9701      	str	r7, [sp, #4]
 8008a54:	9600      	str	r6, [sp, #0]
 8008a56:	69a1      	ldr	r1, [r4, #24]
 8008a58:	69a8      	ldr	r0, [r5, #24]
 8008a5a:	4633      	mov	r3, r6
 8008a5c:	f7ff fb76 	bl	800814c <nl_func_sm_array_f32>
 8008a60:	b003      	add	sp, #12
 8008a62:	bdf0      	pop	{r4, r5, r6, r7, pc}

08008a64 <forward_hardmax>:
 8008a64:	b430      	push	{r4, r5}
 8008a66:	6943      	ldr	r3, [r0, #20]
 8008a68:	881a      	ldrh	r2, [r3, #0]
 8008a6a:	6980      	ldr	r0, [r0, #24]
 8008a6c:	2a00      	cmp	r2, #0
 8008a6e:	bf1a      	itte	ne
 8008a70:	6859      	ldrne	r1, [r3, #4]
 8008a72:	1d09      	addne	r1, r1, #4
 8008a74:	2104      	moveq	r1, #4
 8008a76:	6809      	ldr	r1, [r1, #0]
 8008a78:	2900      	cmp	r1, #0
 8008a7a:	bf14      	ite	ne
 8008a7c:	680c      	ldrne	r4, [r1, #0]
 8008a7e:	2400      	moveq	r4, #0
 8008a80:	2a02      	cmp	r2, #2
 8008a82:	bfa6      	itte	ge
 8008a84:	6859      	ldrge	r1, [r3, #4]
 8008a86:	3110      	addge	r1, #16
 8008a88:	2104      	movlt	r1, #4
 8008a8a:	6809      	ldr	r1, [r1, #0]
 8008a8c:	6883      	ldr	r3, [r0, #8]
 8008a8e:	2900      	cmp	r1, #0
 8008a90:	bf19      	ittee	ne
 8008a92:	6809      	ldrne	r1, [r1, #0]
 8008a94:	f101 0518 	addne.w	r5, r1, #24
 8008a98:	2200      	moveq	r2, #0
 8008a9a:	f102 0518 	addeq.w	r5, r2, #24
 8008a9e:	69a1      	ldr	r1, [r4, #24]
 8008aa0:	6828      	ldr	r0, [r5, #0]
 8008aa2:	f104 0208 	add.w	r2, r4, #8
 8008aa6:	bc30      	pop	{r4, r5}
 8008aa8:	f7ff bbd4 	b.w	8008254 <nl_func_hardmax_array_f32>

08008aac <pool_func_mp_array_f32>:
 8008aac:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8008ab0:	4688      	mov	r8, r1
 8008ab2:	b08b      	sub	sp, #44	; 0x2c
 8008ab4:	f8d0 b008 	ldr.w	fp, [r0, #8]
 8008ab8:	991b      	ldr	r1, [sp, #108]	; 0x6c
 8008aba:	f9bd e064 	ldrsh.w	lr, [sp, #100]	; 0x64
 8008abe:	9f17      	ldr	r7, [sp, #92]	; 0x5c
 8008ac0:	9c15      	ldr	r4, [sp, #84]	; 0x54
 8008ac2:	1e48      	subs	r0, r1, #1
 8008ac4:	fb10 fe0e 	smulbb	lr, r0, lr
 8008ac8:	4615      	mov	r5, r2
 8008aca:	ebae 0e07 	sub.w	lr, lr, r7
 8008ace:	9a1c      	ldr	r2, [sp, #112]	; 0x70
 8008ad0:	f8bd 0058 	ldrh.w	r0, [sp, #88]	; 0x58
 8008ad4:	6892      	ldr	r2, [r2, #8]
 8008ad6:	44a6      	add	lr, r4
 8008ad8:	f1ae 0601 	sub.w	r6, lr, #1
 8008adc:	469c      	mov	ip, r3
 8008ade:	1b76      	subs	r6, r6, r5
 8008ae0:	9b18      	ldr	r3, [sp, #96]	; 0x60
 8008ae2:	4338      	orrs	r0, r7
 8008ae4:	f040 80dd 	bne.w	8008ca2 <pool_func_mp_array_f32+0x1f6>
 8008ae8:	f9bd 0068 	ldrsh.w	r0, [sp, #104]	; 0x68
 8008aec:	f1a0 0901 	sub.w	r9, r0, #1
 8008af0:	f9bd 0058 	ldrsh.w	r0, [sp, #88]	; 0x58
 8008af4:	fb19 f903 	smulbb	r9, r9, r3
 8008af8:	eba9 0900 	sub.w	r9, r9, r0
 8008afc:	f9bd 0050 	ldrsh.w	r0, [sp, #80]	; 0x50
 8008b00:	4448      	add	r0, r9
 8008b02:	1e40      	subs	r0, r0, #1
 8008b04:	eba0 0008 	sub.w	r0, r0, r8
 8008b08:	b200      	sxth	r0, r0
 8008b0a:	2800      	cmp	r0, #0
 8008b0c:	bf44      	itt	mi
 8008b0e:	b236      	sxthmi	r6, r6
 8008b10:	2e00      	cmpmi	r6, #0
 8008b12:	f140 80c6 	bpl.w	8008ca2 <pool_func_mp_array_f32+0x1f6>
 8008b16:	2000      	movs	r0, #0
 8008b18:	000d      	movs	r5, r1
 8008b1a:	9008      	str	r0, [sp, #32]
 8008b1c:	f000 8178 	beq.w	8008e10 <pool_func_mp_array_f32+0x364>
 8008b20:	b224      	sxth	r4, r4
 8008b22:	f8ad 4006 	strh.w	r4, [sp, #6]
 8008b26:	9002      	str	r0, [sp, #8]
 8008b28:	9007      	str	r0, [sp, #28]
 8008b2a:	9106      	str	r1, [sp, #24]
 8008b2c:	ea4f 040c 	mov.w	r4, ip
 8008b30:	ed9f 0ab9 	vldr	s0, [pc, #740]	; 8008e18 <.text_3>
 8008b34:	f8bd 0068 	ldrh.w	r0, [sp, #104]	; 0x68
 8008b38:	f9bd 7006 	ldrsh.w	r7, [sp, #6]
 8008b3c:	2800      	cmp	r0, #0
 8008b3e:	f000 8096 	beq.w	8008c6e <pool_func_mp_array_f32+0x1c2>
 8008b42:	9907      	ldr	r1, [sp, #28]
 8008b44:	9808      	ldr	r0, [sp, #32]
 8008b46:	f9bd 6050 	ldrsh.w	r6, [sp, #80]	; 0x50
 8008b4a:	f8bd 5068 	ldrh.w	r5, [sp, #104]	; 0x68
 8008b4e:	9103      	str	r1, [sp, #12]
 8008b50:	f04f 0a00 	mov.w	sl, #0
 8008b54:	f8bd 1064 	ldrh.w	r1, [sp, #100]	; 0x64
 8008b58:	f8ad c002 	strh.w	ip, [sp, #2]
 8008b5c:	4348      	muls	r0, r1
 8008b5e:	b200      	sxth	r0, r0
 8008b60:	900a      	str	r0, [sp, #40]	; 0x28
 8008b62:	f8ad 3060 	strh.w	r3, [sp, #96]	; 0x60
 8008b66:	9204      	str	r2, [sp, #16]
 8008b68:	f8ad 6000 	strh.w	r6, [sp]
 8008b6c:	f8cd 5014 	str.w	r5, [sp, #20]
 8008b70:	f8ad 8004 	strh.w	r8, [sp, #4]
 8008b74:	f8bd 0002 	ldrh.w	r0, [sp, #2]
 8008b78:	f9bd e000 	ldrsh.w	lr, [sp]
 8008b7c:	2100      	movs	r1, #0
 8008b7e:	2800      	cmp	r0, #0
 8008b80:	d05d      	beq.n	8008c3e <pool_func_mp_array_f32+0x192>
 8008b82:	9a03      	ldr	r2, [sp, #12]
 8008b84:	9804      	ldr	r0, [sp, #16]
 8008b86:	4362      	muls	r2, r4
 8008b88:	ab02      	add	r3, sp, #8
 8008b8a:	eb00 0c82 	add.w	ip, r0, r2, lsl #2
 8008b8e:	5e58      	ldrsh	r0, [r3, r1]
 8008b90:	9009      	str	r0, [sp, #36]	; 0x24
 8008b92:	fa0f f58a 	sxth.w	r5, sl
 8008b96:	f8bd 8004 	ldrh.w	r8, [sp, #4]
 8008b9a:	9809      	ldr	r0, [sp, #36]	; 0x24
 8008b9c:	42b8      	cmp	r0, r7
 8008b9e:	eef0 0a40 	vmov.f32	s1, s0
 8008ba2:	da45      	bge.n	8008c30 <pool_func_mp_array_f32+0x184>
 8008ba4:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 8008ba6:	fb08 f900 	mul.w	r9, r8, r0
 8008baa:	1aba      	subs	r2, r7, r2
 8008bac:	4658      	mov	r0, fp
 8008bae:	4575      	cmp	r5, lr
 8008bb0:	462e      	mov	r6, r5
 8008bb2:	da39      	bge.n	8008c28 <pool_func_mp_array_f32+0x17c>
 8008bb4:	ebae 0305 	sub.w	r3, lr, r5
 8008bb8:	ea5f 7bc3 	movs.w	fp, r3, lsl #31
 8008bbc:	d50f      	bpl.n	8008bde <pool_func_mp_array_f32+0x132>
 8008bbe:	eb09 0b06 	add.w	fp, r9, r6
 8008bc2:	fb0b 1b04 	mla	fp, fp, r4, r1
 8008bc6:	eb00 0b8b 	add.w	fp, r0, fp, lsl #2
 8008bca:	ed9b 1a00 	vldr	s2, [fp]
 8008bce:	eeb4 1a60 	vcmp.f32	s2, s1
 8008bd2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8008bd6:	bf58      	it	pl
 8008bd8:	eef0 0a41 	vmovpl.f32	s1, s2
 8008bdc:	1c76      	adds	r6, r6, #1
 8008bde:	085b      	lsrs	r3, r3, #1
 8008be0:	f000 8022 	beq.w	8008c28 <pool_func_mp_array_f32+0x17c>
 8008be4:	eb09 0b06 	add.w	fp, r9, r6
 8008be8:	fb0b 1b04 	mla	fp, fp, r4, r1
 8008bec:	eb00 0b8b 	add.w	fp, r0, fp, lsl #2
 8008bf0:	ed9b 1a00 	vldr	s2, [fp]
 8008bf4:	eeb4 1a60 	vcmp.f32	s2, s1
 8008bf8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8008bfc:	bf58      	it	pl
 8008bfe:	eef0 0a41 	vmovpl.f32	s1, s2
 8008c02:	1c76      	adds	r6, r6, #1
 8008c04:	eb09 0b06 	add.w	fp, r9, r6
 8008c08:	fb0b 1b04 	mla	fp, fp, r4, r1
 8008c0c:	eb00 0b8b 	add.w	fp, r0, fp, lsl #2
 8008c10:	ed9b 1a00 	vldr	s2, [fp]
 8008c14:	eeb4 1a60 	vcmp.f32	s2, s1
 8008c18:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8008c1c:	bf58      	it	pl
 8008c1e:	eef0 0a41 	vmovpl.f32	s1, s2
 8008c22:	1c76      	adds	r6, r6, #1
 8008c24:	1e5b      	subs	r3, r3, #1
 8008c26:	d1dd      	bne.n	8008be4 <pool_func_mp_array_f32+0x138>
 8008c28:	1e52      	subs	r2, r2, #1
 8008c2a:	44c1      	add	r9, r8
 8008c2c:	d1bf      	bne.n	8008bae <pool_func_mp_array_f32+0x102>
 8008c2e:	4683      	mov	fp, r0
 8008c30:	1c49      	adds	r1, r1, #1
 8008c32:	edcc 0a00 	vstr	s1, [ip]
 8008c36:	42a1      	cmp	r1, r4
 8008c38:	f10c 0c04 	add.w	ip, ip, #4
 8008c3c:	dbad      	blt.n	8008b9a <pool_func_mp_array_f32+0xee>
 8008c3e:	9803      	ldr	r0, [sp, #12]
 8008c40:	f8bd 1000 	ldrh.w	r1, [sp]
 8008c44:	1c40      	adds	r0, r0, #1
 8008c46:	9003      	str	r0, [sp, #12]
 8008c48:	f8bd 0060 	ldrh.w	r0, [sp, #96]	; 0x60
 8008c4c:	4482      	add	sl, r0
 8008c4e:	f9bd 0060 	ldrsh.w	r0, [sp, #96]	; 0x60
 8008c52:	1841      	adds	r1, r0, r1
 8008c54:	f8ad 1000 	strh.w	r1, [sp]
 8008c58:	9905      	ldr	r1, [sp, #20]
 8008c5a:	1e49      	subs	r1, r1, #1
 8008c5c:	9105      	str	r1, [sp, #20]
 8008c5e:	d189      	bne.n	8008b74 <pool_func_mp_array_f32+0xc8>
 8008c60:	f8bd c002 	ldrh.w	ip, [sp, #2]
 8008c64:	f8bd 3060 	ldrh.w	r3, [sp, #96]	; 0x60
 8008c68:	9a04      	ldr	r2, [sp, #16]
 8008c6a:	f8bd 8004 	ldrh.w	r8, [sp, #4]
 8008c6e:	9908      	ldr	r1, [sp, #32]
 8008c70:	f8bd 5068 	ldrh.w	r5, [sp, #104]	; 0x68
 8008c74:	f8bd 7006 	ldrh.w	r7, [sp, #6]
 8008c78:	1c49      	adds	r1, r1, #1
 8008c7a:	9108      	str	r1, [sp, #32]
 8008c7c:	9907      	ldr	r1, [sp, #28]
 8008c7e:	194d      	adds	r5, r1, r5
 8008c80:	9507      	str	r5, [sp, #28]
 8008c82:	9902      	ldr	r1, [sp, #8]
 8008c84:	f8bd 5064 	ldrh.w	r5, [sp, #100]	; 0x64
 8008c88:	194d      	adds	r5, r1, r5
 8008c8a:	9502      	str	r5, [sp, #8]
 8008c8c:	f9bd 1064 	ldrsh.w	r1, [sp, #100]	; 0x64
 8008c90:	9d06      	ldr	r5, [sp, #24]
 8008c92:	19cf      	adds	r7, r1, r7
 8008c94:	1e6d      	subs	r5, r5, #1
 8008c96:	f8ad 7006 	strh.w	r7, [sp, #6]
 8008c9a:	9506      	str	r5, [sp, #24]
 8008c9c:	f000 80b8 	beq.w	8008e10 <pool_func_mp_array_f32+0x364>
 8008ca0:	e748      	b.n	8008b34 <pool_func_mp_array_f32+0x88>
 8008ca2:	0008      	movs	r0, r1
 8008ca4:	f000 80b4 	beq.w	8008e10 <pool_func_mp_array_f32+0x364>
 8008ca8:	427f      	negs	r7, r7
 8008caa:	19e4      	adds	r4, r4, r7
 8008cac:	f8ad 7000 	strh.w	r7, [sp]
 8008cb0:	f8ad 400a 	strh.w	r4, [sp, #10]
 8008cb4:	2000      	movs	r0, #0
 8008cb6:	9008      	str	r0, [sp, #32]
 8008cb8:	f8cd 101c 	str.w	r1, [sp, #28]
 8008cbc:	ed9f 0a56 	vldr	s0, [pc, #344]	; 8008e18 <.text_3>
 8008cc0:	f8bd 0068 	ldrh.w	r0, [sp, #104]	; 0x68
 8008cc4:	f9bd a00a 	ldrsh.w	sl, [sp, #10]
 8008cc8:	2800      	cmp	r0, #0
 8008cca:	f000 8089 	beq.w	8008de0 <pool_func_mp_array_f32+0x334>
 8008cce:	f9bd e058 	ldrsh.w	lr, [sp, #88]	; 0x58
 8008cd2:	f9bd 7050 	ldrsh.w	r7, [sp, #80]	; 0x50
 8008cd6:	9908      	ldr	r1, [sp, #32]
 8008cd8:	f8bd 4068 	ldrh.w	r4, [sp, #104]	; 0x68
 8008cdc:	9103      	str	r1, [sp, #12]
 8008cde:	f1ce 0e00 	rsb	lr, lr, #0
 8008ce2:	4477      	add	r7, lr
 8008ce4:	f8ad c002 	strh.w	ip, [sp, #2]
 8008ce8:	f8ad 3060 	strh.w	r3, [sp, #96]	; 0x60
 8008cec:	9204      	str	r2, [sp, #16]
 8008cee:	f8ad e006 	strh.w	lr, [sp, #6]
 8008cf2:	f8ad 7008 	strh.w	r7, [sp, #8]
 8008cf6:	9406      	str	r4, [sp, #24]
 8008cf8:	f8ad 8004 	strh.w	r8, [sp, #4]
 8008cfc:	f8bd 1002 	ldrh.w	r1, [sp, #2]
 8008d00:	f9bd 0008 	ldrsh.w	r0, [sp, #8]
 8008d04:	2600      	movs	r6, #0
 8008d06:	2900      	cmp	r1, #0
 8008d08:	d04e      	beq.n	8008da8 <pool_func_mp_array_f32+0x2fc>
 8008d0a:	f8bd 2002 	ldrh.w	r2, [sp, #2]
 8008d0e:	9b03      	ldr	r3, [sp, #12]
 8008d10:	9904      	ldr	r1, [sp, #16]
 8008d12:	f9bd 4006 	ldrsh.w	r4, [sp, #6]
 8008d16:	435a      	muls	r2, r3
 8008d18:	eb01 0182 	add.w	r1, r1, r2, lsl #2
 8008d1c:	f8bd 2002 	ldrh.w	r2, [sp, #2]
 8008d20:	f8bd 3004 	ldrh.w	r3, [sp, #4]
 8008d24:	f8cd 1014 	str.w	r1, [sp, #20]
 8008d28:	f9bd 1000 	ldrsh.w	r1, [sp]
 8008d2c:	4551      	cmp	r1, sl
 8008d2e:	eef0 0a40 	vmov.f32	s1, s0
 8008d32:	da2a      	bge.n	8008d8a <pool_func_mp_array_f32+0x2de>
 8008d34:	fb03 f901 	mul.w	r9, r3, r1
 8008d38:	f8ad 5002 	strh.w	r5, [sp, #2]
 8008d3c:	4284      	cmp	r4, r0
 8008d3e:	4625      	mov	r5, r4
 8008d40:	da1d      	bge.n	8008d7e <pool_func_mp_array_f32+0x2d2>
 8008d42:	f8bd 7002 	ldrh.w	r7, [sp, #2]
 8008d46:	46de      	mov	lr, fp
 8008d48:	2900      	cmp	r1, #0
 8008d4a:	bf58      	it	pl
 8008d4c:	2d00      	cmppl	r5, #0
 8008d4e:	d412      	bmi.n	8008d76 <pool_func_mp_array_f32+0x2ca>
 8008d50:	42b9      	cmp	r1, r7
 8008d52:	bfb8      	it	lt
 8008d54:	429d      	cmplt	r5, r3
 8008d56:	da0e      	bge.n	8008d76 <pool_func_mp_array_f32+0x2ca>
 8008d58:	eb09 0b05 	add.w	fp, r9, r5
 8008d5c:	fb0b 6b02 	mla	fp, fp, r2, r6
 8008d60:	eb0e 0b8b 	add.w	fp, lr, fp, lsl #2
 8008d64:	ed9b 1a00 	vldr	s2, [fp]
 8008d68:	eeb4 1a60 	vcmp.f32	s2, s1
 8008d6c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8008d70:	bf58      	it	pl
 8008d72:	eef0 0a41 	vmovpl.f32	s1, s2
 8008d76:	1c6d      	adds	r5, r5, #1
 8008d78:	4285      	cmp	r5, r0
 8008d7a:	dbe5      	blt.n	8008d48 <pool_func_mp_array_f32+0x29c>
 8008d7c:	46f3      	mov	fp, lr
 8008d7e:	1c49      	adds	r1, r1, #1
 8008d80:	4551      	cmp	r1, sl
 8008d82:	4499      	add	r9, r3
 8008d84:	dbda      	blt.n	8008d3c <pool_func_mp_array_f32+0x290>
 8008d86:	f8bd 5002 	ldrh.w	r5, [sp, #2]
 8008d8a:	1c76      	adds	r6, r6, #1
 8008d8c:	9905      	ldr	r1, [sp, #20]
 8008d8e:	edc1 0a00 	vstr	s1, [r1]
 8008d92:	9905      	ldr	r1, [sp, #20]
 8008d94:	1d0f      	adds	r7, r1, #4
 8008d96:	4296      	cmp	r6, r2
 8008d98:	9705      	str	r7, [sp, #20]
 8008d9a:	dbc5      	blt.n	8008d28 <pool_func_mp_array_f32+0x27c>
 8008d9c:	f8ad 2002 	strh.w	r2, [sp, #2]
 8008da0:	f8ad 4006 	strh.w	r4, [sp, #6]
 8008da4:	f8ad 3004 	strh.w	r3, [sp, #4]
 8008da8:	9803      	ldr	r0, [sp, #12]
 8008daa:	f9bd 1060 	ldrsh.w	r1, [sp, #96]	; 0x60
 8008dae:	1c40      	adds	r0, r0, #1
 8008db0:	9003      	str	r0, [sp, #12]
 8008db2:	f8bd 0008 	ldrh.w	r0, [sp, #8]
 8008db6:	1808      	adds	r0, r1, r0
 8008db8:	f8ad 0008 	strh.w	r0, [sp, #8]
 8008dbc:	f9bd 1060 	ldrsh.w	r1, [sp, #96]	; 0x60
 8008dc0:	f8bd 0006 	ldrh.w	r0, [sp, #6]
 8008dc4:	1808      	adds	r0, r1, r0
 8008dc6:	f8ad 0006 	strh.w	r0, [sp, #6]
 8008dca:	9806      	ldr	r0, [sp, #24]
 8008dcc:	1e40      	subs	r0, r0, #1
 8008dce:	9006      	str	r0, [sp, #24]
 8008dd0:	d194      	bne.n	8008cfc <pool_func_mp_array_f32+0x250>
 8008dd2:	f8bd c002 	ldrh.w	ip, [sp, #2]
 8008dd6:	f8bd 3060 	ldrh.w	r3, [sp, #96]	; 0x60
 8008dda:	9a04      	ldr	r2, [sp, #16]
 8008ddc:	f8bd 8004 	ldrh.w	r8, [sp, #4]
 8008de0:	9908      	ldr	r1, [sp, #32]
 8008de2:	f8bd 4068 	ldrh.w	r4, [sp, #104]	; 0x68
 8008de6:	f8bd 700a 	ldrh.w	r7, [sp, #10]
 8008dea:	190c      	adds	r4, r1, r4
 8008dec:	9408      	str	r4, [sp, #32]
 8008dee:	f8bd 4000 	ldrh.w	r4, [sp]
 8008df2:	f9bd 1064 	ldrsh.w	r1, [sp, #100]	; 0x64
 8008df6:	19cf      	adds	r7, r1, r7
 8008df8:	f9bd 1064 	ldrsh.w	r1, [sp, #100]	; 0x64
 8008dfc:	f8ad 700a 	strh.w	r7, [sp, #10]
 8008e00:	190c      	adds	r4, r1, r4
 8008e02:	f8ad 4000 	strh.w	r4, [sp]
 8008e06:	9c07      	ldr	r4, [sp, #28]
 8008e08:	1e64      	subs	r4, r4, #1
 8008e0a:	9407      	str	r4, [sp, #28]
 8008e0c:	f47f af58 	bne.w	8008cc0 <pool_func_mp_array_f32+0x214>
 8008e10:	b00b      	add	sp, #44	; 0x2c
 8008e12:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	...

08008e18 <.text_3>:
 8008e18:	cf000000 	.word	0xcf000000

08008e1c <pool_func_ap_array_f32>:
 8008e1c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8008e20:	468b      	mov	fp, r1
 8008e22:	b08c      	sub	sp, #48	; 0x30
 8008e24:	4699      	mov	r9, r3
 8008e26:	991c      	ldr	r1, [sp, #112]	; 0x70
 8008e28:	f9bd c068 	ldrsh.w	ip, [sp, #104]	; 0x68
 8008e2c:	9b18      	ldr	r3, [sp, #96]	; 0x60
 8008e2e:	4692      	mov	sl, r2
 8008e30:	1e4f      	subs	r7, r1, #1
 8008e32:	9a16      	ldr	r2, [sp, #88]	; 0x58
 8008e34:	9d1d      	ldr	r5, [sp, #116]	; 0x74
 8008e36:	f8dd 8064 	ldr.w	r8, [sp, #100]	; 0x64
 8008e3a:	6880      	ldr	r0, [r0, #8]
 8008e3c:	68ad      	ldr	r5, [r5, #8]
 8008e3e:	fb17 fc0c 	smulbb	ip, r7, ip
 8008e42:	ebac 0c03 	sub.w	ip, ip, r3
 8008e46:	f8bd 705c 	ldrh.w	r7, [sp, #92]	; 0x5c
 8008e4a:	4494      	add	ip, r2
 8008e4c:	f1ac 0401 	sub.w	r4, ip, #1
 8008e50:	431f      	orrs	r7, r3
 8008e52:	eba4 060a 	sub.w	r6, r4, sl
 8008e56:	f040 80dc 	bne.w	8009012 <pool_func_ap_array_f32+0x1f6>
 8008e5a:	f9bd 706c 	ldrsh.w	r7, [sp, #108]	; 0x6c
 8008e5e:	1e7c      	subs	r4, r7, #1
 8008e60:	f9bd 705c 	ldrsh.w	r7, [sp, #92]	; 0x5c
 8008e64:	fb14 f408 	smulbb	r4, r4, r8
 8008e68:	1be4      	subs	r4, r4, r7
 8008e6a:	f9bd 7054 	ldrsh.w	r7, [sp, #84]	; 0x54
 8008e6e:	193c      	adds	r4, r7, r4
 8008e70:	1e64      	subs	r4, r4, #1
 8008e72:	eba4 040b 	sub.w	r4, r4, fp
 8008e76:	b224      	sxth	r4, r4
 8008e78:	2c00      	cmp	r4, #0
 8008e7a:	bf44      	itt	mi
 8008e7c:	b234      	sxthmi	r4, r6
 8008e7e:	2c00      	cmpmi	r4, #0
 8008e80:	f140 80c7 	bpl.w	8009012 <pool_func_ap_array_f32+0x1f6>
 8008e84:	2400      	movs	r4, #0
 8008e86:	000b      	movs	r3, r1
 8008e88:	9409      	str	r4, [sp, #36]	; 0x24
 8008e8a:	f000 81af 	beq.w	80091ec <pool_func_ap_array_f32+0x3d0>
 8008e8e:	b212      	sxth	r2, r2
 8008e90:	f8ad 2004 	strh.w	r2, [sp, #4]
 8008e94:	9408      	str	r4, [sp, #32]
 8008e96:	9407      	str	r4, [sp, #28]
 8008e98:	f8cd 1018 	str.w	r1, [sp, #24]
 8008e9c:	f8bd 106c 	ldrh.w	r1, [sp, #108]	; 0x6c
 8008ea0:	f9bd e004 	ldrsh.w	lr, [sp, #4]
 8008ea4:	2900      	cmp	r1, #0
 8008ea6:	f000 809a 	beq.w	8008fde <pool_func_ap_array_f32+0x1c2>
 8008eaa:	9907      	ldr	r1, [sp, #28]
 8008eac:	9a09      	ldr	r2, [sp, #36]	; 0x24
 8008eae:	f9bd 4054 	ldrsh.w	r4, [sp, #84]	; 0x54
 8008eb2:	f8bd 306c 	ldrh.w	r3, [sp, #108]	; 0x6c
 8008eb6:	9102      	str	r1, [sp, #8]
 8008eb8:	2700      	movs	r7, #0
 8008eba:	f8bd 1068 	ldrh.w	r1, [sp, #104]	; 0x68
 8008ebe:	434a      	muls	r2, r1
 8008ec0:	b212      	sxth	r2, r2
 8008ec2:	ae08      	add	r6, sp, #32
 8008ec4:	920b      	str	r2, [sp, #44]	; 0x2c
 8008ec6:	46ca      	mov	sl, r9
 8008ec8:	5ff1      	ldrsh	r1, [r6, r7]
 8008eca:	910a      	str	r1, [sp, #40]	; 0x28
 8008ecc:	f8ad 9002 	strh.w	r9, [sp, #2]
 8008ed0:	f8ad 8064 	strh.w	r8, [sp, #100]	; 0x64
 8008ed4:	9505      	str	r5, [sp, #20]
 8008ed6:	f8ad 4000 	strh.w	r4, [sp]
 8008eda:	9303      	str	r3, [sp, #12]
 8008edc:	f8bd 1002 	ldrh.w	r1, [sp, #2]
 8008ee0:	f9bd c000 	ldrsh.w	ip, [sp]
 8008ee4:	2200      	movs	r2, #0
 8008ee6:	2900      	cmp	r1, #0
 8008ee8:	d063      	beq.n	8008fb2 <pool_func_ap_array_f32+0x196>
 8008eea:	9d02      	ldr	r5, [sp, #8]
 8008eec:	9905      	ldr	r1, [sp, #20]
 8008eee:	f8cd e010 	str.w	lr, [sp, #16]
 8008ef2:	fb05 f50a 	mul.w	r5, r5, sl
 8008ef6:	eb01 0585 	add.w	r5, r1, r5, lsl #2
 8008efa:	f8ad b006 	strh.w	fp, [sp, #6]
 8008efe:	990a      	ldr	r1, [sp, #40]	; 0x28
 8008f00:	9b04      	ldr	r3, [sp, #16]
 8008f02:	4299      	cmp	r1, r3
 8008f04:	ed9f 0abb 	vldr	s0, [pc, #748]	; 80091f4 <.text_5>
 8008f08:	eddf 0aba 	vldr	s1, [pc, #744]	; 80091f4 <.text_5>
 8008f0c:	da43      	bge.n	8008f96 <pool_func_ap_array_f32+0x17a>
 8008f0e:	9c0b      	ldr	r4, [sp, #44]	; 0x2c
 8008f10:	f8bd b006 	ldrh.w	fp, [sp, #6]
 8008f14:	eba3 0804 	sub.w	r8, r3, r4
 8008f18:	fb01 f10b 	mul.w	r1, r1, fp
 8008f1c:	4603      	mov	r3, r0
 8008f1e:	ee10 ea90 	vmov	lr, s1
 8008f22:	b23c      	sxth	r4, r7
 8008f24:	4564      	cmp	r4, ip
 8008f26:	46b9      	mov	r9, r7
 8008f28:	da2e      	bge.n	8008f88 <pool_func_ap_array_f32+0x16c>
 8008f2a:	ebac 0004 	sub.w	r0, ip, r4
 8008f2e:	44e6      	add	lr, ip
 8008f30:	07c6      	lsls	r6, r0, #31
 8008f32:	ebae 0e04 	sub.w	lr, lr, r4
 8008f36:	d50a      	bpl.n	8008f4e <pool_func_ap_array_f32+0x132>
 8008f38:	190c      	adds	r4, r1, r4
 8008f3a:	fb04 240a 	mla	r4, r4, sl, r2
 8008f3e:	eb03 0484 	add.w	r4, r3, r4, lsl #2
 8008f42:	f109 0901 	add.w	r9, r9, #1
 8008f46:	edd4 0a00 	vldr	s1, [r4]
 8008f4a:	ee30 0a20 	vadd.f32	s0, s0, s1
 8008f4e:	0840      	lsrs	r0, r0, #1
 8008f50:	f000 801a 	beq.w	8008f88 <pool_func_ap_array_f32+0x16c>
 8008f54:	fa01 f489 	sxtah	r4, r1, r9
 8008f58:	f109 0901 	add.w	r9, r9, #1
 8008f5c:	fb04 240a 	mla	r4, r4, sl, r2
 8008f60:	fa01 f689 	sxtah	r6, r1, r9
 8008f64:	eb03 0484 	add.w	r4, r3, r4, lsl #2
 8008f68:	fb06 260a 	mla	r6, r6, sl, r2
 8008f6c:	edd4 0a00 	vldr	s1, [r4]
 8008f70:	eb03 0486 	add.w	r4, r3, r6, lsl #2
 8008f74:	ee30 0a20 	vadd.f32	s0, s0, s1
 8008f78:	ed94 1a00 	vldr	s2, [r4]
 8008f7c:	1e40      	subs	r0, r0, #1
 8008f7e:	ee30 0a01 	vadd.f32	s0, s0, s2
 8008f82:	f109 0901 	add.w	r9, r9, #1
 8008f86:	d1e5      	bne.n	8008f54 <pool_func_ap_array_f32+0x138>
 8008f88:	f1b8 0801 	subs.w	r8, r8, #1
 8008f8c:	4459      	add	r1, fp
 8008f8e:	d1c8      	bne.n	8008f22 <pool_func_ap_array_f32+0x106>
 8008f90:	4618      	mov	r0, r3
 8008f92:	ee00 ea90 	vmov	s1, lr
 8008f96:	eef8 0ae0 	vcvt.f32.s32	s1, s1
 8008f9a:	ee80 0a20 	vdiv.f32	s0, s0, s1
 8008f9e:	ed85 0a00 	vstr	s0, [r5]
 8008fa2:	1c52      	adds	r2, r2, #1
 8008fa4:	1d2d      	adds	r5, r5, #4
 8008fa6:	4552      	cmp	r2, sl
 8008fa8:	dba9      	blt.n	8008efe <pool_func_ap_array_f32+0xe2>
 8008faa:	f8dd e010 	ldr.w	lr, [sp, #16]
 8008fae:	f8bd b006 	ldrh.w	fp, [sp, #6]
 8008fb2:	9902      	ldr	r1, [sp, #8]
 8008fb4:	f9bd 2064 	ldrsh.w	r2, [sp, #100]	; 0x64
 8008fb8:	1c49      	adds	r1, r1, #1
 8008fba:	9102      	str	r1, [sp, #8]
 8008fbc:	f8bd 1000 	ldrh.w	r1, [sp]
 8008fc0:	1851      	adds	r1, r2, r1
 8008fc2:	f8ad 1000 	strh.w	r1, [sp]
 8008fc6:	f9bd 1064 	ldrsh.w	r1, [sp, #100]	; 0x64
 8008fca:	9a03      	ldr	r2, [sp, #12]
 8008fcc:	19cf      	adds	r7, r1, r7
 8008fce:	1e52      	subs	r2, r2, #1
 8008fd0:	9203      	str	r2, [sp, #12]
 8008fd2:	d183      	bne.n	8008edc <pool_func_ap_array_f32+0xc0>
 8008fd4:	f8bd 9002 	ldrh.w	r9, [sp, #2]
 8008fd8:	f8bd 8064 	ldrh.w	r8, [sp, #100]	; 0x64
 8008fdc:	9d05      	ldr	r5, [sp, #20]
 8008fde:	9909      	ldr	r1, [sp, #36]	; 0x24
 8008fe0:	f8bd 206c 	ldrh.w	r2, [sp, #108]	; 0x6c
 8008fe4:	f8bd 3004 	ldrh.w	r3, [sp, #4]
 8008fe8:	1c49      	adds	r1, r1, #1
 8008fea:	9109      	str	r1, [sp, #36]	; 0x24
 8008fec:	9907      	ldr	r1, [sp, #28]
 8008fee:	188a      	adds	r2, r1, r2
 8008ff0:	9207      	str	r2, [sp, #28]
 8008ff2:	9908      	ldr	r1, [sp, #32]
 8008ff4:	f8bd 2068 	ldrh.w	r2, [sp, #104]	; 0x68
 8008ff8:	188a      	adds	r2, r1, r2
 8008ffa:	9208      	str	r2, [sp, #32]
 8008ffc:	f9bd 1068 	ldrsh.w	r1, [sp, #104]	; 0x68
 8009000:	9a06      	ldr	r2, [sp, #24]
 8009002:	18cb      	adds	r3, r1, r3
 8009004:	1e52      	subs	r2, r2, #1
 8009006:	f8ad 3004 	strh.w	r3, [sp, #4]
 800900a:	9206      	str	r2, [sp, #24]
 800900c:	f000 80ee 	beq.w	80091ec <pool_func_ap_array_f32+0x3d0>
 8009010:	e744      	b.n	8008e9c <pool_func_ap_array_f32+0x80>
 8009012:	000f      	movs	r7, r1
 8009014:	f000 80ea 	beq.w	80091ec <pool_func_ap_array_f32+0x3d0>
 8009018:	425b      	negs	r3, r3
 800901a:	18d2      	adds	r2, r2, r3
 800901c:	2700      	movs	r7, #0
 800901e:	f8ad 3000 	strh.w	r3, [sp]
 8009022:	f8ad 200a 	strh.w	r2, [sp, #10]
 8009026:	9709      	str	r7, [sp, #36]	; 0x24
 8009028:	f8cd 1020 	str.w	r1, [sp, #32]
 800902c:	f8bd 106c 	ldrh.w	r1, [sp, #108]	; 0x6c
 8009030:	f9bd 300a 	ldrsh.w	r3, [sp, #10]
 8009034:	2900      	cmp	r1, #0
 8009036:	f000 80c1 	beq.w	80091bc <pool_func_ap_array_f32+0x3a0>
 800903a:	f9bd 605c 	ldrsh.w	r6, [sp, #92]	; 0x5c
 800903e:	f9bd 4054 	ldrsh.w	r4, [sp, #84]	; 0x54
 8009042:	9a09      	ldr	r2, [sp, #36]	; 0x24
 8009044:	f8bd 106c 	ldrh.w	r1, [sp, #108]	; 0x6c
 8009048:	9204      	str	r2, [sp, #16]
 800904a:	4276      	negs	r6, r6
 800904c:	19a4      	adds	r4, r4, r6
 800904e:	f8ad 9002 	strh.w	r9, [sp, #2]
 8009052:	f8ad 8064 	strh.w	r8, [sp, #100]	; 0x64
 8009056:	9505      	str	r5, [sp, #20]
 8009058:	f8ad 6004 	strh.w	r6, [sp, #4]
 800905c:	f8ad 4008 	strh.w	r4, [sp, #8]
 8009060:	f8cd 101c 	str.w	r1, [sp, #28]
 8009064:	f8ad b006 	strh.w	fp, [sp, #6]
 8009068:	f8bd 2002 	ldrh.w	r2, [sp, #2]
 800906c:	f9bd 8008 	ldrsh.w	r8, [sp, #8]
 8009070:	2100      	movs	r1, #0
 8009072:	2a00      	cmp	r2, #0
 8009074:	f000 8085 	beq.w	8009182 <pool_func_ap_array_f32+0x366>
 8009078:	f8bd 5002 	ldrh.w	r5, [sp, #2]
 800907c:	9c04      	ldr	r4, [sp, #16]
 800907e:	9a05      	ldr	r2, [sp, #20]
 8009080:	f8bd 9006 	ldrh.w	r9, [sp, #6]
 8009084:	f8ad a00c 	strh.w	sl, [sp, #12]
 8009088:	4365      	muls	r5, r4
 800908a:	eb02 0585 	add.w	r5, r2, r5, lsl #2
 800908e:	9506      	str	r5, [sp, #24]
 8009090:	f9bd 5000 	ldrsh.w	r5, [sp]
 8009094:	f8bd a002 	ldrh.w	sl, [sp, #2]
 8009098:	429d      	cmp	r5, r3
 800909a:	ed9f 0a56 	vldr	s0, [pc, #344]	; 80091f4 <.text_5>
 800909e:	eddf 0a55 	vldr	s1, [pc, #340]	; 80091f4 <.text_5>
 80090a2:	da5d      	bge.n	8009160 <pool_func_ap_array_f32+0x344>
 80090a4:	930a      	str	r3, [sp, #40]	; 0x28
 80090a6:	fb09 fe05 	mul.w	lr, r9, r5
 80090aa:	462b      	mov	r3, r5
 80090ac:	f9bd 5004 	ldrsh.w	r5, [sp, #4]
 80090b0:	f8bd b00c 	ldrh.w	fp, [sp, #12]
 80090b4:	ee10 2a90 	vmov	r2, s1
 80090b8:	4545      	cmp	r5, r8
 80090ba:	462f      	mov	r7, r5
 80090bc:	da44      	bge.n	8009148 <pool_func_ap_array_f32+0x32c>
 80090be:	eba8 0405 	sub.w	r4, r8, r5
 80090c2:	07e6      	lsls	r6, r4, #31
 80090c4:	d513      	bpl.n	80090ee <pool_func_ap_array_f32+0x2d2>
 80090c6:	2b00      	cmp	r3, #0
 80090c8:	bf58      	it	pl
 80090ca:	2f00      	cmppl	r7, #0
 80090cc:	d40e      	bmi.n	80090ec <pool_func_ap_array_f32+0x2d0>
 80090ce:	455b      	cmp	r3, fp
 80090d0:	bfb8      	it	lt
 80090d2:	454f      	cmplt	r7, r9
 80090d4:	da0a      	bge.n	80090ec <pool_func_ap_array_f32+0x2d0>
 80090d6:	eb0e 0607 	add.w	r6, lr, r7
 80090da:	fb06 160a 	mla	r6, r6, sl, r1
 80090de:	eb00 0686 	add.w	r6, r0, r6, lsl #2
 80090e2:	1c52      	adds	r2, r2, #1
 80090e4:	edd6 0a00 	vldr	s1, [r6]
 80090e8:	ee30 0a20 	vadd.f32	s0, s0, s1
 80090ec:	1c7f      	adds	r7, r7, #1
 80090ee:	0864      	lsrs	r4, r4, #1
 80090f0:	d02a      	beq.n	8009148 <pool_func_ap_array_f32+0x32c>
 80090f2:	2b00      	cmp	r3, #0
 80090f4:	d405      	bmi.n	8009102 <pool_func_ap_array_f32+0x2e6>
 80090f6:	2f00      	cmp	r7, #0
 80090f8:	bf48      	it	mi
 80090fa:	1c7e      	addmi	r6, r7, #1
 80090fc:	d410      	bmi.n	8009120 <pool_func_ap_array_f32+0x304>
 80090fe:	455b      	cmp	r3, fp
 8009100:	db01      	blt.n	8009106 <pool_func_ap_array_f32+0x2ea>
 8009102:	1c7e      	adds	r6, r7, #1
 8009104:	e01d      	b.n	8009142 <pool_func_ap_array_f32+0x326>
 8009106:	1c7e      	adds	r6, r7, #1
 8009108:	454f      	cmp	r7, r9
 800910a:	da09      	bge.n	8009120 <pool_func_ap_array_f32+0x304>
 800910c:	4477      	add	r7, lr
 800910e:	fb07 170a 	mla	r7, r7, sl, r1
 8009112:	eb00 0787 	add.w	r7, r0, r7, lsl #2
 8009116:	1c52      	adds	r2, r2, #1
 8009118:	edd7 0a00 	vldr	s1, [r7]
 800911c:	ee30 0a20 	vadd.f32	s0, s0, s1
 8009120:	2e00      	cmp	r6, #0
 8009122:	d40e      	bmi.n	8009142 <pool_func_ap_array_f32+0x326>
 8009124:	455b      	cmp	r3, fp
 8009126:	bfb8      	it	lt
 8009128:	454e      	cmplt	r6, r9
 800912a:	da0a      	bge.n	8009142 <pool_func_ap_array_f32+0x326>
 800912c:	eb0e 0706 	add.w	r7, lr, r6
 8009130:	fb07 170a 	mla	r7, r7, sl, r1
 8009134:	eb00 0787 	add.w	r7, r0, r7, lsl #2
 8009138:	1c52      	adds	r2, r2, #1
 800913a:	edd7 0a00 	vldr	s1, [r7]
 800913e:	ee30 0a20 	vadd.f32	s0, s0, s1
 8009142:	1c77      	adds	r7, r6, #1
 8009144:	1e64      	subs	r4, r4, #1
 8009146:	d1d4      	bne.n	80090f2 <pool_func_ap_array_f32+0x2d6>
 8009148:	9f0a      	ldr	r7, [sp, #40]	; 0x28
 800914a:	1c5b      	adds	r3, r3, #1
 800914c:	42bb      	cmp	r3, r7
 800914e:	44ce      	add	lr, r9
 8009150:	dbb2      	blt.n	80090b8 <pool_func_ap_array_f32+0x29c>
 8009152:	463b      	mov	r3, r7
 8009154:	ee00 2a90 	vmov	s1, r2
 8009158:	f8ad 5004 	strh.w	r5, [sp, #4]
 800915c:	f8ad b00c 	strh.w	fp, [sp, #12]
 8009160:	eef8 0ae0 	vcvt.f32.s32	s1, s1
 8009164:	9d06      	ldr	r5, [sp, #24]
 8009166:	ee80 0a20 	vdiv.f32	s0, s0, s1
 800916a:	ed85 0a00 	vstr	s0, [r5]
 800916e:	1c49      	adds	r1, r1, #1
 8009170:	9a06      	ldr	r2, [sp, #24]
 8009172:	1d15      	adds	r5, r2, #4
 8009174:	4551      	cmp	r1, sl
 8009176:	9506      	str	r5, [sp, #24]
 8009178:	db8a      	blt.n	8009090 <pool_func_ap_array_f32+0x274>
 800917a:	f8ad 9006 	strh.w	r9, [sp, #6]
 800917e:	f8bd a00c 	ldrh.w	sl, [sp, #12]
 8009182:	9904      	ldr	r1, [sp, #16]
 8009184:	f9bd 2064 	ldrsh.w	r2, [sp, #100]	; 0x64
 8009188:	1c49      	adds	r1, r1, #1
 800918a:	9104      	str	r1, [sp, #16]
 800918c:	f8bd 1008 	ldrh.w	r1, [sp, #8]
 8009190:	1851      	adds	r1, r2, r1
 8009192:	f8ad 1008 	strh.w	r1, [sp, #8]
 8009196:	f9bd 2064 	ldrsh.w	r2, [sp, #100]	; 0x64
 800919a:	f8bd 1004 	ldrh.w	r1, [sp, #4]
 800919e:	1851      	adds	r1, r2, r1
 80091a0:	f8ad 1004 	strh.w	r1, [sp, #4]
 80091a4:	9907      	ldr	r1, [sp, #28]
 80091a6:	1e49      	subs	r1, r1, #1
 80091a8:	9107      	str	r1, [sp, #28]
 80091aa:	f47f af5d 	bne.w	8009068 <pool_func_ap_array_f32+0x24c>
 80091ae:	f8bd 9002 	ldrh.w	r9, [sp, #2]
 80091b2:	f8bd 8064 	ldrh.w	r8, [sp, #100]	; 0x64
 80091b6:	9d05      	ldr	r5, [sp, #20]
 80091b8:	f8bd b006 	ldrh.w	fp, [sp, #6]
 80091bc:	9909      	ldr	r1, [sp, #36]	; 0x24
 80091be:	f8bd 206c 	ldrh.w	r2, [sp, #108]	; 0x6c
 80091c2:	f8bd 300a 	ldrh.w	r3, [sp, #10]
 80091c6:	188a      	adds	r2, r1, r2
 80091c8:	9209      	str	r2, [sp, #36]	; 0x24
 80091ca:	f8bd 2000 	ldrh.w	r2, [sp]
 80091ce:	f9bd 1068 	ldrsh.w	r1, [sp, #104]	; 0x68
 80091d2:	18cb      	adds	r3, r1, r3
 80091d4:	f9bd 1068 	ldrsh.w	r1, [sp, #104]	; 0x68
 80091d8:	f8ad 300a 	strh.w	r3, [sp, #10]
 80091dc:	188a      	adds	r2, r1, r2
 80091de:	f8ad 2000 	strh.w	r2, [sp]
 80091e2:	9a08      	ldr	r2, [sp, #32]
 80091e4:	1e52      	subs	r2, r2, #1
 80091e6:	9208      	str	r2, [sp, #32]
 80091e8:	f47f af20 	bne.w	800902c <pool_func_ap_array_f32+0x210>
 80091ec:	b00c      	add	sp, #48	; 0x30
 80091ee:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	...

080091f4 <.text_5>:
 80091f4:	00000000 	.word	0x00000000

080091f8 <pool_func_mp_kernel_array_f32>:
 80091f8:	b470      	push	{r4, r5, r6}
 80091fa:	eb01 0482 	add.w	r4, r1, r2, lsl #2
 80091fe:	42a1      	cmp	r1, r4
 8009200:	d257      	bcs.n	80092b2 <pool_func_mp_kernel_array_f32+0xba>
 8009202:	2b00      	cmp	r3, #0
 8009204:	d051      	beq.n	80092aa <pool_func_mp_kernel_array_f32+0xb2>
 8009206:	f013 0203 	ands.w	r2, r3, #3
 800920a:	460d      	mov	r5, r1
 800920c:	4606      	mov	r6, r0
 800920e:	d011      	beq.n	8009234 <pool_func_mp_kernel_array_f32+0x3c>
 8009210:	ed96 0a00 	vldr	s0, [r6]
 8009214:	edd5 0a00 	vldr	s1, [r5]
 8009218:	eef4 0a40 	vcmp.f32	s1, s0
 800921c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8009220:	bf58      	it	pl
 8009222:	eeb0 0a60 	vmovpl.f32	s0, s1
 8009226:	ed86 0a00 	vstr	s0, [r6]
 800922a:	1e52      	subs	r2, r2, #1
 800922c:	1d36      	adds	r6, r6, #4
 800922e:	1d2d      	adds	r5, r5, #4
 8009230:	2a00      	cmp	r2, #0
 8009232:	d1ed      	bne.n	8009210 <pool_func_mp_kernel_array_f32+0x18>
 8009234:	089a      	lsrs	r2, r3, #2
 8009236:	d038      	beq.n	80092aa <pool_func_mp_kernel_array_f32+0xb2>
 8009238:	edd5 0a00 	vldr	s1, [r5]
 800923c:	edd6 1a00 	vldr	s3, [r6]
 8009240:	eef4 0a61 	vcmp.f32	s1, s3
 8009244:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8009248:	bf48      	it	mi
 800924a:	eef0 0a61 	vmovmi.f32	s1, s3
 800924e:	edc6 0a00 	vstr	s1, [r6]
 8009252:	edd5 0a01 	vldr	s1, [r5, #4]
 8009256:	edd6 1a01 	vldr	s3, [r6, #4]
 800925a:	ed96 0a02 	vldr	s0, [r6, #8]
 800925e:	eef4 0a61 	vcmp.f32	s1, s3
 8009262:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8009266:	bf48      	it	mi
 8009268:	eef0 0a61 	vmovmi.f32	s1, s3
 800926c:	edc6 0a01 	vstr	s1, [r6, #4]
 8009270:	ed95 1a02 	vldr	s2, [r5, #8]
 8009274:	edd6 1a03 	vldr	s3, [r6, #12]
 8009278:	eeb4 1a40 	vcmp.f32	s2, s0
 800927c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8009280:	bf48      	it	mi
 8009282:	eeb0 1a40 	vmovmi.f32	s2, s0
 8009286:	ed86 1a02 	vstr	s2, [r6, #8]
 800928a:	edd5 0a03 	vldr	s1, [r5, #12]
 800928e:	eef4 0a61 	vcmp.f32	s1, s3
 8009292:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8009296:	bf58      	it	pl
 8009298:	eef0 1a60 	vmovpl.f32	s3, s1
 800929c:	edc6 1a03 	vstr	s3, [r6, #12]
 80092a0:	1e52      	subs	r2, r2, #1
 80092a2:	3610      	adds	r6, #16
 80092a4:	3510      	adds	r5, #16
 80092a6:	2a00      	cmp	r2, #0
 80092a8:	d1c6      	bne.n	8009238 <pool_func_mp_kernel_array_f32+0x40>
 80092aa:	eb01 0183 	add.w	r1, r1, r3, lsl #2
 80092ae:	42a1      	cmp	r1, r4
 80092b0:	d3a7      	bcc.n	8009202 <pool_func_mp_kernel_array_f32+0xa>
 80092b2:	bc70      	pop	{r4, r5, r6}
 80092b4:	4770      	bx	lr
	...

080092b8 <pool_func_ap_kernel_array_f32>:
 80092b8:	b470      	push	{r4, r5, r6}
 80092ba:	eb01 0482 	add.w	r4, r1, r2, lsl #2
 80092be:	42a1      	cmp	r1, r4
 80092c0:	d24f      	bcs.n	8009362 <pool_func_ap_kernel_array_f32+0xaa>
 80092c2:	2b00      	cmp	r3, #0
 80092c4:	d049      	beq.n	800935a <pool_func_ap_kernel_array_f32+0xa2>
 80092c6:	f013 0203 	ands.w	r2, r3, #3
 80092ca:	460d      	mov	r5, r1
 80092cc:	4606      	mov	r6, r0
 80092ce:	d00e      	beq.n	80092ee <pool_func_ap_kernel_array_f32+0x36>
 80092d0:	ed95 0a00 	vldr	s0, [r5]
 80092d4:	4288      	cmp	r0, r1
 80092d6:	bf1c      	itt	ne
 80092d8:	edd6 0a00 	vldrne	s1, [r6]
 80092dc:	ee30 0a80 	vaddne.f32	s0, s1, s0
 80092e0:	ed86 0a00 	vstr	s0, [r6]
 80092e4:	1e52      	subs	r2, r2, #1
 80092e6:	1d36      	adds	r6, r6, #4
 80092e8:	1d2d      	adds	r5, r5, #4
 80092ea:	2a00      	cmp	r2, #0
 80092ec:	d1f0      	bne.n	80092d0 <pool_func_ap_kernel_array_f32+0x18>
 80092ee:	089a      	lsrs	r2, r3, #2
 80092f0:	d033      	beq.n	800935a <pool_func_ap_kernel_array_f32+0xa2>
 80092f2:	4288      	cmp	r0, r1
 80092f4:	edd5 1a00 	vldr	s3, [r5]
 80092f8:	d10c      	bne.n	8009314 <pool_func_ap_kernel_array_f32+0x5c>
 80092fa:	edc6 1a00 	vstr	s3, [r6]
 80092fe:	ed95 0a01 	vldr	s0, [r5, #4]
 8009302:	ed86 0a01 	vstr	s0, [r6, #4]
 8009306:	edd5 1a02 	vldr	s3, [r5, #8]
 800930a:	edc6 1a02 	vstr	s3, [r6, #8]
 800930e:	edd5 1a03 	vldr	s3, [r5, #12]
 8009312:	e01b      	b.n	800934c <pool_func_ap_kernel_array_f32+0x94>
 8009314:	edd6 0a00 	vldr	s1, [r6]
 8009318:	ee30 0aa1 	vadd.f32	s0, s1, s3
 800931c:	ed86 0a00 	vstr	s0, [r6]
 8009320:	ed96 1a01 	vldr	s2, [r6, #4]
 8009324:	ed95 0a01 	vldr	s0, [r5, #4]
 8009328:	edd6 1a02 	vldr	s3, [r6, #8]
 800932c:	ee31 0a00 	vadd.f32	s0, s2, s0
 8009330:	ed86 0a01 	vstr	s0, [r6, #4]
 8009334:	edd5 0a02 	vldr	s1, [r5, #8]
 8009338:	ee31 0aa0 	vadd.f32	s0, s3, s1
 800933c:	ed86 0a02 	vstr	s0, [r6, #8]
 8009340:	ed96 0a03 	vldr	s0, [r6, #12]
 8009344:	ed95 1a03 	vldr	s2, [r5, #12]
 8009348:	ee70 1a01 	vadd.f32	s3, s0, s2
 800934c:	edc6 1a03 	vstr	s3, [r6, #12]
 8009350:	1e52      	subs	r2, r2, #1
 8009352:	3610      	adds	r6, #16
 8009354:	3510      	adds	r5, #16
 8009356:	2a00      	cmp	r2, #0
 8009358:	d1cb      	bne.n	80092f2 <pool_func_ap_kernel_array_f32+0x3a>
 800935a:	eb01 0183 	add.w	r1, r1, r3, lsl #2
 800935e:	42a1      	cmp	r1, r4
 8009360:	d3af      	bcc.n	80092c2 <pool_func_ap_kernel_array_f32+0xa>
 8009362:	9903      	ldr	r1, [sp, #12]
 8009364:	b3a1      	cbz	r1, 80093d0 <pool_func_ap_kernel_array_f32+0x118>
 8009366:	ee00 1a10 	vmov	s0, r1
 800936a:	eeb8 0a40 	vcvt.f32.u32	s0, s0
 800936e:	eef7 0a00 	vmov.f32	s1, #112	; 0x3f800000  1.0
 8009372:	ee80 0a80 	vdiv.f32	s0, s1, s0
 8009376:	b35b      	cbz	r3, 80093d0 <pool_func_ap_kernel_array_f32+0x118>
 8009378:	f013 0103 	ands.w	r1, r3, #3
 800937c:	f000 800a 	beq.w	8009394 <pool_func_ap_kernel_array_f32+0xdc>
 8009380:	edd0 0a00 	vldr	s1, [r0]
 8009384:	ee60 0a80 	vmul.f32	s1, s1, s0
 8009388:	edc0 0a00 	vstr	s1, [r0]
 800938c:	1e49      	subs	r1, r1, #1
 800938e:	f100 0004 	add.w	r0, r0, #4
 8009392:	d1f5      	bne.n	8009380 <pool_func_ap_kernel_array_f32+0xc8>
 8009394:	089b      	lsrs	r3, r3, #2
 8009396:	d01b      	beq.n	80093d0 <pool_func_ap_kernel_array_f32+0x118>
 8009398:	edd0 0a00 	vldr	s1, [r0]
 800939c:	ee60 0a80 	vmul.f32	s1, s1, s0
 80093a0:	edc0 0a00 	vstr	s1, [r0]
 80093a4:	1e5b      	subs	r3, r3, #1
 80093a6:	ed90 1a01 	vldr	s2, [r0, #4]
 80093aa:	edd0 0a02 	vldr	s1, [r0, #8]
 80093ae:	ee21 1a00 	vmul.f32	s2, s2, s0
 80093b2:	ed80 1a01 	vstr	s2, [r0, #4]
 80093b6:	ee60 0a80 	vmul.f32	s1, s1, s0
 80093ba:	ed90 1a03 	vldr	s2, [r0, #12]
 80093be:	edc0 0a02 	vstr	s1, [r0, #8]
 80093c2:	ee21 1a00 	vmul.f32	s2, s2, s0
 80093c6:	ed80 1a03 	vstr	s2, [r0, #12]
 80093ca:	f100 0010 	add.w	r0, r0, #16
 80093ce:	d1e3      	bne.n	8009398 <pool_func_ap_kernel_array_f32+0xe0>
 80093d0:	bc70      	pop	{r4, r5, r6}
 80093d2:	4770      	bx	lr

080093d4 <forward_mp>:
 80093d4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80093d8:	4604      	mov	r4, r0
 80093da:	b08e      	sub	sp, #56	; 0x38
 80093dc:	6962      	ldr	r2, [r4, #20]
 80093de:	8811      	ldrh	r1, [r2, #0]
 80093e0:	2900      	cmp	r1, #0
 80093e2:	bf1a      	itte	ne
 80093e4:	6850      	ldrne	r0, [r2, #4]
 80093e6:	1d00      	addne	r0, r0, #4
 80093e8:	2004      	moveq	r0, #4
 80093ea:	6800      	ldr	r0, [r0, #0]
 80093ec:	2800      	cmp	r0, #0
 80093ee:	bf14      	ite	ne
 80093f0:	6805      	ldrne	r5, [r0, #0]
 80093f2:	2500      	moveq	r5, #0
 80093f4:	2901      	cmp	r1, #1
 80093f6:	bfc6      	itte	gt
 80093f8:	6850      	ldrgt	r0, [r2, #4]
 80093fa:	3010      	addgt	r0, #16
 80093fc:	2004      	movle	r0, #4
 80093fe:	6800      	ldr	r0, [r0, #0]
 8009400:	68ea      	ldr	r2, [r5, #12]
 8009402:	2800      	cmp	r0, #0
 8009404:	bf14      	ite	ne
 8009406:	6807      	ldrne	r7, [r0, #0]
 8009408:	2700      	moveq	r7, #0
 800940a:	68f9      	ldr	r1, [r7, #12]
 800940c:	68d0      	ldr	r0, [r2, #12]
 800940e:	68cb      	ldr	r3, [r1, #12]
 8009410:	9009      	str	r0, [sp, #36]	; 0x24
 8009412:	6889      	ldr	r1, [r1, #8]
 8009414:	9108      	str	r1, [sp, #32]
 8009416:	f8d2 8008 	ldr.w	r8, [r2, #8]
 800941a:	6851      	ldr	r1, [r2, #4]
 800941c:	69a2      	ldr	r2, [r4, #24]
 800941e:	69e0      	ldr	r0, [r4, #28]
 8009420:	9007      	str	r0, [sp, #28]
 8009422:	6a66      	ldr	r6, [r4, #36]	; 0x24
 8009424:	6a20      	ldr	r0, [r4, #32]
 8009426:	960d      	str	r6, [sp, #52]	; 0x34
 8009428:	f8d4 c02c 	ldr.w	ip, [r4, #44]	; 0x2c
 800942c:	69ac      	ldr	r4, [r5, #24]
 800942e:	69bd      	ldr	r5, [r7, #24]
 8009430:	f8dc 7000 	ldr.w	r7, [ip]
 8009434:	f8dc 6004 	ldr.w	r6, [ip, #4]
 8009438:	68a4      	ldr	r4, [r4, #8]
 800943a:	f8d5 e008 	ldr.w	lr, [r5, #8]
 800943e:	427f      	negs	r7, r7
 8009440:	2b00      	cmp	r3, #0
 8009442:	9700      	str	r7, [sp, #0]
 8009444:	f000 80d9 	beq.w	80095fa <forward_mp+0x226>
 8009448:	9301      	str	r3, [sp, #4]
 800944a:	4276      	negs	r6, r6
 800944c:	960c      	str	r6, [sp, #48]	; 0x30
 800944e:	fb01 f508 	mul.w	r5, r1, r8
 8009452:	950b      	str	r5, [sp, #44]	; 0x2c
 8009454:	9d00      	ldr	r5, [sp, #0]
 8009456:	9b00      	ldr	r3, [sp, #0]
 8009458:	9f00      	ldr	r7, [sp, #0]
 800945a:	426d      	negs	r5, r5
 800945c:	9d09      	ldr	r5, [sp, #36]	; 0x24
 800945e:	bfcc      	ite	gt
 8009460:	2600      	movgt	r6, #0
 8009462:	9e00      	ldrle	r6, [sp, #0]
 8009464:	1aeb      	subs	r3, r5, r3
 8009466:	9d07      	ldr	r5, [sp, #28]
 8009468:	42ab      	cmp	r3, r5
 800946a:	bf88      	it	hi
 800946c:	462b      	movhi	r3, r5
 800946e:	19df      	adds	r7, r3, r7
 8009470:	9b08      	ldr	r3, [sp, #32]
 8009472:	9d0c      	ldr	r5, [sp, #48]	; 0x30
 8009474:	2b00      	cmp	r3, #0
 8009476:	f000 80b7 	beq.w	80095e8 <forward_mp+0x214>
 800947a:	fb08 fa06 	mul.w	sl, r8, r6
 800947e:	f8cd a028 	str.w	sl, [sp, #40]	; 0x28
 8009482:	f8cd 800c 	str.w	r8, [sp, #12]
 8009486:	9202      	str	r2, [sp, #8]
 8009488:	9006      	str	r0, [sp, #24]
 800948a:	9605      	str	r6, [sp, #20]
 800948c:	9704      	str	r7, [sp, #16]
 800948e:	4268      	negs	r0, r5
 8009490:	9f03      	ldr	r7, [sp, #12]
 8009492:	9a02      	ldr	r2, [sp, #8]
 8009494:	f8dd 802c 	ldr.w	r8, [sp, #44]	; 0x2c
 8009498:	bfcc      	ite	gt
 800949a:	2000      	movgt	r0, #0
 800949c:	4628      	movle	r0, r5
 800949e:	1b7f      	subs	r7, r7, r5
 80094a0:	4297      	cmp	r7, r2
 80094a2:	bf88      	it	hi
 80094a4:	4617      	movhi	r7, r2
 80094a6:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 80094a8:	197f      	adds	r7, r7, r5
 80094aa:	1a3f      	subs	r7, r7, r0
 80094ac:	1880      	adds	r0, r0, r2
 80094ae:	4348      	muls	r0, r1
 80094b0:	434f      	muls	r7, r1
 80094b2:	eb04 0c80 	add.w	ip, r4, r0, lsl #2
 80094b6:	b311      	cbz	r1, 80094fe <forward_mp+0x12a>
 80094b8:	f011 0003 	ands.w	r0, r1, #3
 80094bc:	4672      	mov	r2, lr
 80094be:	4666      	mov	r6, ip
 80094c0:	f000 8006 	beq.w	80094d0 <forward_mp+0xfc>
 80094c4:	f856 9b04 	ldr.w	r9, [r6], #4
 80094c8:	f842 9b04 	str.w	r9, [r2], #4
 80094cc:	1e40      	subs	r0, r0, #1
 80094ce:	d1f9      	bne.n	80094c4 <forward_mp+0xf0>
 80094d0:	0888      	lsrs	r0, r1, #2
 80094d2:	d014      	beq.n	80094fe <forward_mp+0x12a>
 80094d4:	ed96 0a00 	vldr	s0, [r6]
 80094d8:	ed82 0a00 	vstr	s0, [r2]
 80094dc:	1e40      	subs	r0, r0, #1
 80094de:	edd6 0a01 	vldr	s1, [r6, #4]
 80094e2:	edc2 0a01 	vstr	s1, [r2, #4]
 80094e6:	ed96 0a02 	vldr	s0, [r6, #8]
 80094ea:	ed82 0a02 	vstr	s0, [r2, #8]
 80094ee:	edd6 0a03 	vldr	s1, [r6, #12]
 80094f2:	edc2 0a03 	vstr	s1, [r2, #12]
 80094f6:	3210      	adds	r2, #16
 80094f8:	3610      	adds	r6, #16
 80094fa:	2800      	cmp	r0, #0
 80094fc:	d1ea      	bne.n	80094d4 <forward_mp+0x100>
 80094fe:	9805      	ldr	r0, [sp, #20]
 8009500:	9a04      	ldr	r2, [sp, #16]
 8009502:	4290      	cmp	r0, r2
 8009504:	da66      	bge.n	80095d4 <forward_mp+0x200>
 8009506:	4610      	mov	r0, r2
 8009508:	9a05      	ldr	r2, [sp, #20]
 800950a:	1a82      	subs	r2, r0, r2
 800950c:	46e2      	mov	sl, ip
 800950e:	eb0a 0b87 	add.w	fp, sl, r7, lsl #2
 8009512:	45da      	cmp	sl, fp
 8009514:	d25a      	bcs.n	80095cc <forward_mp+0x1f8>
 8009516:	2900      	cmp	r1, #0
 8009518:	d054      	beq.n	80095c4 <forward_mp+0x1f0>
 800951a:	f011 0003 	ands.w	r0, r1, #3
 800951e:	4656      	mov	r6, sl
 8009520:	46f1      	mov	r9, lr
 8009522:	d012      	beq.n	800954a <forward_mp+0x176>
 8009524:	ed99 0a00 	vldr	s0, [r9]
 8009528:	edd6 0a00 	vldr	s1, [r6]
 800952c:	eef4 0a40 	vcmp.f32	s1, s0
 8009530:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8009534:	bf58      	it	pl
 8009536:	eeb0 0a60 	vmovpl.f32	s0, s1
 800953a:	1e40      	subs	r0, r0, #1
 800953c:	1d36      	adds	r6, r6, #4
 800953e:	ed89 0a00 	vstr	s0, [r9]
 8009542:	2800      	cmp	r0, #0
 8009544:	f109 0904 	add.w	r9, r9, #4
 8009548:	d1ec      	bne.n	8009524 <forward_mp+0x150>
 800954a:	0888      	lsrs	r0, r1, #2
 800954c:	f000 803a 	beq.w	80095c4 <forward_mp+0x1f0>
 8009550:	edd6 0a00 	vldr	s1, [r6]
 8009554:	edd9 1a00 	vldr	s3, [r9]
 8009558:	eef4 0a61 	vcmp.f32	s1, s3
 800955c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8009560:	bf48      	it	mi
 8009562:	eef0 0a61 	vmovmi.f32	s1, s3
 8009566:	edc9 0a00 	vstr	s1, [r9]
 800956a:	edd6 0a01 	vldr	s1, [r6, #4]
 800956e:	edd9 1a01 	vldr	s3, [r9, #4]
 8009572:	ed99 0a02 	vldr	s0, [r9, #8]
 8009576:	eef4 0a61 	vcmp.f32	s1, s3
 800957a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800957e:	bf48      	it	mi
 8009580:	eef0 0a61 	vmovmi.f32	s1, s3
 8009584:	edc9 0a01 	vstr	s1, [r9, #4]
 8009588:	ed96 1a02 	vldr	s2, [r6, #8]
 800958c:	edd9 1a03 	vldr	s3, [r9, #12]
 8009590:	eeb4 1a40 	vcmp.f32	s2, s0
 8009594:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8009598:	bf48      	it	mi
 800959a:	eeb0 1a40 	vmovmi.f32	s2, s0
 800959e:	ed89 1a02 	vstr	s2, [r9, #8]
 80095a2:	edd6 0a03 	vldr	s1, [r6, #12]
 80095a6:	eef4 0a61 	vcmp.f32	s1, s3
 80095aa:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80095ae:	bf58      	it	pl
 80095b0:	eef0 1a60 	vmovpl.f32	s3, s1
 80095b4:	1e40      	subs	r0, r0, #1
 80095b6:	3610      	adds	r6, #16
 80095b8:	edc9 1a03 	vstr	s3, [r9, #12]
 80095bc:	2800      	cmp	r0, #0
 80095be:	f109 0910 	add.w	r9, r9, #16
 80095c2:	d1c5      	bne.n	8009550 <forward_mp+0x17c>
 80095c4:	eb0a 0a81 	add.w	sl, sl, r1, lsl #2
 80095c8:	45da      	cmp	sl, fp
 80095ca:	d3a4      	bcc.n	8009516 <forward_mp+0x142>
 80095cc:	1e52      	subs	r2, r2, #1
 80095ce:	eb0c 0c88 	add.w	ip, ip, r8, lsl #2
 80095d2:	d19b      	bne.n	800950c <forward_mp+0x138>
 80095d4:	9806      	ldr	r0, [sp, #24]
 80095d6:	1945      	adds	r5, r0, r5
 80095d8:	1e5b      	subs	r3, r3, #1
 80095da:	eb0e 0e81 	add.w	lr, lr, r1, lsl #2
 80095de:	f47f af56 	bne.w	800948e <forward_mp+0xba>
 80095e2:	f8dd 800c 	ldr.w	r8, [sp, #12]
 80095e6:	9a02      	ldr	r2, [sp, #8]
 80095e8:	9d00      	ldr	r5, [sp, #0]
 80095ea:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 80095ec:	195d      	adds	r5, r3, r5
 80095ee:	9500      	str	r5, [sp, #0]
 80095f0:	9d01      	ldr	r5, [sp, #4]
 80095f2:	1e6d      	subs	r5, r5, #1
 80095f4:	9501      	str	r5, [sp, #4]
 80095f6:	f47f af2d 	bne.w	8009454 <forward_mp+0x80>
 80095fa:	b00e      	add	sp, #56	; 0x38
 80095fc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

08009600 <forward_ap>:
 8009600:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8009604:	4686      	mov	lr, r0
 8009606:	b097      	sub	sp, #92	; 0x5c
 8009608:	f8de 2014 	ldr.w	r2, [lr, #20]
 800960c:	8811      	ldrh	r1, [r2, #0]
 800960e:	2900      	cmp	r1, #0
 8009610:	bf1a      	itte	ne
 8009612:	6850      	ldrne	r0, [r2, #4]
 8009614:	1d00      	addne	r0, r0, #4
 8009616:	2004      	moveq	r0, #4
 8009618:	6800      	ldr	r0, [r0, #0]
 800961a:	2800      	cmp	r0, #0
 800961c:	bf14      	ite	ne
 800961e:	6804      	ldrne	r4, [r0, #0]
 8009620:	2400      	moveq	r4, #0
 8009622:	2901      	cmp	r1, #1
 8009624:	bfc6      	itte	gt
 8009626:	6850      	ldrgt	r0, [r2, #4]
 8009628:	3010      	addgt	r0, #16
 800962a:	2004      	movle	r0, #4
 800962c:	6800      	ldr	r0, [r0, #0]
 800962e:	68e3      	ldr	r3, [r4, #12]
 8009630:	68dd      	ldr	r5, [r3, #12]
 8009632:	2800      	cmp	r0, #0
 8009634:	bf14      	ite	ne
 8009636:	6806      	ldrne	r6, [r0, #0]
 8009638:	2600      	moveq	r6, #0
 800963a:	68f2      	ldr	r2, [r6, #12]
 800963c:	68d0      	ldr	r0, [r2, #12]
 800963e:	950d      	str	r5, [sp, #52]	; 0x34
 8009640:	6892      	ldr	r2, [r2, #8]
 8009642:	920c      	str	r2, [sp, #48]	; 0x30
 8009644:	f8d3 c008 	ldr.w	ip, [r3, #8]
 8009648:	6859      	ldr	r1, [r3, #4]
 800964a:	f8de 3018 	ldr.w	r3, [lr, #24]
 800964e:	f8de 501c 	ldr.w	r5, [lr, #28]
 8009652:	9505      	str	r5, [sp, #20]
 8009654:	f8de 8020 	ldr.w	r8, [lr, #32]
 8009658:	f8de 5024 	ldr.w	r5, [lr, #36]	; 0x24
 800965c:	9516      	str	r5, [sp, #88]	; 0x58
 800965e:	69a4      	ldr	r4, [r4, #24]
 8009660:	f8de 202c 	ldr.w	r2, [lr, #44]	; 0x2c
 8009664:	68a5      	ldr	r5, [r4, #8]
 8009666:	6857      	ldr	r7, [r2, #4]
 8009668:	69b4      	ldr	r4, [r6, #24]
 800966a:	6812      	ldr	r2, [r2, #0]
 800966c:	f8d4 9008 	ldr.w	r9, [r4, #8]
 8009670:	4252      	negs	r2, r2
 8009672:	2800      	cmp	r0, #0
 8009674:	9201      	str	r2, [sp, #4]
 8009676:	f000 812e 	beq.w	80098d6 <forward_ap+0x2d6>
 800967a:	9004      	str	r0, [sp, #16]
 800967c:	427f      	negs	r7, r7
 800967e:	9715      	str	r7, [sp, #84]	; 0x54
 8009680:	fb01 f20c 	mul.w	r2, r1, ip
 8009684:	9c05      	ldr	r4, [sp, #20]
 8009686:	9213      	str	r2, [sp, #76]	; 0x4c
 8009688:	435c      	muls	r4, r3
 800968a:	9414      	str	r4, [sp, #80]	; 0x50
 800968c:	9a01      	ldr	r2, [sp, #4]
 800968e:	9801      	ldr	r0, [sp, #4]
 8009690:	9c01      	ldr	r4, [sp, #4]
 8009692:	9f15      	ldr	r7, [sp, #84]	; 0x54
 8009694:	4252      	negs	r2, r2
 8009696:	9a0d      	ldr	r2, [sp, #52]	; 0x34
 8009698:	bfcc      	ite	gt
 800969a:	2600      	movgt	r6, #0
 800969c:	9e01      	ldrle	r6, [sp, #4]
 800969e:	1a10      	subs	r0, r2, r0
 80096a0:	9a05      	ldr	r2, [sp, #20]
 80096a2:	9700      	str	r7, [sp, #0]
 80096a4:	4290      	cmp	r0, r2
 80096a6:	bf88      	it	hi
 80096a8:	4610      	movhi	r0, r2
 80096aa:	1904      	adds	r4, r0, r4
 80096ac:	980c      	ldr	r0, [sp, #48]	; 0x30
 80096ae:	2800      	cmp	r0, #0
 80096b0:	f000 8108 	beq.w	80098c4 <forward_ap+0x2c4>
 80096b4:	fb0c f006 	mul.w	r0, ip, r6
 80096b8:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 80096ba:	9012      	str	r0, [sp, #72]	; 0x48
 80096bc:	9202      	str	r2, [sp, #8]
 80096be:	1b30      	subs	r0, r6, r4
 80096c0:	9011      	str	r0, [sp, #68]	; 0x44
 80096c2:	f8cd e038 	str.w	lr, [sp, #56]	; 0x38
 80096c6:	f8cd c01c 	str.w	ip, [sp, #28]
 80096ca:	9306      	str	r3, [sp, #24]
 80096cc:	f8cd 802c 	str.w	r8, [sp, #44]	; 0x2c
 80096d0:	950a      	str	r5, [sp, #40]	; 0x28
 80096d2:	9609      	str	r6, [sp, #36]	; 0x24
 80096d4:	9408      	str	r4, [sp, #32]
 80096d6:	9800      	ldr	r0, [sp, #0]
 80096d8:	9a07      	ldr	r2, [sp, #28]
 80096da:	9f00      	ldr	r7, [sp, #0]
 80096dc:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 80096de:	4240      	negs	r0, r0
 80096e0:	9800      	ldr	r0, [sp, #0]
 80096e2:	bfcc      	ite	gt
 80096e4:	f04f 0e00 	movgt.w	lr, #0
 80096e8:	f8dd e000 	ldrle.w	lr, [sp]
 80096ec:	1a10      	subs	r0, r2, r0
 80096ee:	9a06      	ldr	r2, [sp, #24]
 80096f0:	4290      	cmp	r0, r2
 80096f2:	bf88      	it	hi
 80096f4:	4610      	movhi	r0, r2
 80096f6:	9a13      	ldr	r2, [sp, #76]	; 0x4c
 80096f8:	9203      	str	r2, [sp, #12]
 80096fa:	19c7      	adds	r7, r0, r7
 80096fc:	9811      	ldr	r0, [sp, #68]	; 0x44
 80096fe:	9a12      	ldr	r2, [sp, #72]	; 0x48
 8009700:	ebae 0407 	sub.w	r4, lr, r7
 8009704:	4344      	muls	r4, r0
 8009706:	980a      	ldr	r0, [sp, #40]	; 0x28
 8009708:	4472      	add	r2, lr
 800970a:	434a      	muls	r2, r1
 800970c:	eba7 050e 	sub.w	r5, r7, lr
 8009710:	eb00 0682 	add.w	r6, r0, r2, lsl #2
 8009714:	f893 0030 	ldrb.w	r0, [r3, #48]	; 0x30
 8009718:	434d      	muls	r5, r1
 800971a:	2200      	movs	r2, #0
 800971c:	2800      	cmp	r0, #0
 800971e:	bf14      	ite	ne
 8009720:	f8dd 8050 	ldrne.w	r8, [sp, #80]	; 0x50
 8009724:	46a0      	moveq	r8, r4
 8009726:	b189      	cbz	r1, 800974c <forward_ap+0x14c>
 8009728:	f011 0003 	ands.w	r0, r1, #3
 800972c:	464b      	mov	r3, r9
 800972e:	d003      	beq.n	8009738 <forward_ap+0x138>
 8009730:	1e40      	subs	r0, r0, #1
 8009732:	f843 2b04 	str.w	r2, [r3], #4
 8009736:	d1fb      	bne.n	8009730 <forward_ap+0x130>
 8009738:	0888      	lsrs	r0, r1, #2
 800973a:	d007      	beq.n	800974c <forward_ap+0x14c>
 800973c:	601a      	str	r2, [r3, #0]
 800973e:	605a      	str	r2, [r3, #4]
 8009740:	609a      	str	r2, [r3, #8]
 8009742:	60da      	str	r2, [r3, #12]
 8009744:	1e40      	subs	r0, r0, #1
 8009746:	f103 0310 	add.w	r3, r3, #16
 800974a:	d1f7      	bne.n	800973c <forward_ap+0x13c>
 800974c:	9809      	ldr	r0, [sp, #36]	; 0x24
 800974e:	9b08      	ldr	r3, [sp, #32]
 8009750:	4298      	cmp	r0, r3
 8009752:	f280 80a5 	bge.w	80098a0 <forward_ap+0x2a0>
 8009756:	1a1b      	subs	r3, r3, r0
 8009758:	eba7 000e 	sub.w	r0, r7, lr
 800975c:	900f      	str	r0, [sp, #60]	; 0x3c
 800975e:	9410      	str	r4, [sp, #64]	; 0x40
 8009760:	4694      	mov	ip, r2
 8009762:	980f      	ldr	r0, [sp, #60]	; 0x3c
 8009764:	9a10      	ldr	r2, [sp, #64]	; 0x40
 8009766:	4484      	add	ip, r0
 8009768:	4562      	cmp	r2, ip
 800976a:	46b6      	mov	lr, r6
 800976c:	bf0c      	ite	eq
 800976e:	4644      	moveq	r4, r8
 8009770:	2400      	movne	r4, #0
 8009772:	eb0e 0785 	add.w	r7, lr, r5, lsl #2
 8009776:	45be      	cmp	lr, r7
 8009778:	d24f      	bcs.n	800981a <forward_ap+0x21a>
 800977a:	2200      	movs	r2, #0
 800977c:	2900      	cmp	r1, #0
 800977e:	d048      	beq.n	8009812 <forward_ap+0x212>
 8009780:	f011 0003 	ands.w	r0, r1, #3
 8009784:	46f2      	mov	sl, lr
 8009786:	46cb      	mov	fp, r9
 8009788:	f000 8011 	beq.w	80097ae <forward_ap+0x1ae>
 800978c:	ed9a 0a00 	vldr	s0, [sl]
 8009790:	45f1      	cmp	r9, lr
 8009792:	bf1c      	itt	ne
 8009794:	eddb 0a00 	vldrne	s1, [fp]
 8009798:	ee30 0a80 	vaddne.f32	s0, s1, s0
 800979c:	1c52      	adds	r2, r2, #1
 800979e:	ed8b 0a00 	vstr	s0, [fp]
 80097a2:	1e40      	subs	r0, r0, #1
 80097a4:	f10b 0b04 	add.w	fp, fp, #4
 80097a8:	f10a 0a04 	add.w	sl, sl, #4
 80097ac:	d1ee      	bne.n	800978c <forward_ap+0x18c>
 80097ae:	0888      	lsrs	r0, r1, #2
 80097b0:	f000 802f 	beq.w	8009812 <forward_ap+0x212>
 80097b4:	eb0e 0a82 	add.w	sl, lr, r2, lsl #2
 80097b8:	eb09 0282 	add.w	r2, r9, r2, lsl #2
 80097bc:	edda 1a00 	vldr	s3, [sl]
 80097c0:	45f1      	cmp	r9, lr
 80097c2:	bf1c      	itt	ne
 80097c4:	ed92 0a00 	vldrne	s0, [r2]
 80097c8:	ee70 1a21 	vaddne.f32	s3, s0, s3
 80097cc:	edc2 1a00 	vstr	s3, [r2]
 80097d0:	edda 1a01 	vldr	s3, [sl, #4]
 80097d4:	bf1c      	itt	ne
 80097d6:	edd2 0a01 	vldrne	s1, [r2, #4]
 80097da:	ee70 1aa1 	vaddne.f32	s3, s1, s3
 80097de:	edc2 1a01 	vstr	s3, [r2, #4]
 80097e2:	ed9a 1a02 	vldr	s2, [sl, #8]
 80097e6:	bf1c      	itt	ne
 80097e8:	ed92 0a02 	vldrne	s0, [r2, #8]
 80097ec:	ee30 1a01 	vaddne.f32	s2, s0, s2
 80097f0:	ed82 1a02 	vstr	s2, [r2, #8]
 80097f4:	edda 1a03 	vldr	s3, [sl, #12]
 80097f8:	bf1c      	itt	ne
 80097fa:	edd2 0a03 	vldrne	s1, [r2, #12]
 80097fe:	ee70 1aa1 	vaddne.f32	s3, s1, s3
 8009802:	edc2 1a03 	vstr	s3, [r2, #12]
 8009806:	1e40      	subs	r0, r0, #1
 8009808:	3210      	adds	r2, #16
 800980a:	2800      	cmp	r0, #0
 800980c:	f10a 0a10 	add.w	sl, sl, #16
 8009810:	d1d4      	bne.n	80097bc <forward_ap+0x1bc>
 8009812:	eb0e 0e81 	add.w	lr, lr, r1, lsl #2
 8009816:	45be      	cmp	lr, r7
 8009818:	d3af      	bcc.n	800977a <forward_ap+0x17a>
 800981a:	2c00      	cmp	r4, #0
 800981c:	d03a      	beq.n	8009894 <forward_ap+0x294>
 800981e:	ee00 4a10 	vmov	s0, r4
 8009822:	eeb8 0a40 	vcvt.f32.u32	s0, s0
 8009826:	eef7 0a00 	vmov.f32	s1, #112	; 0x3f800000  1.0
 800982a:	ee80 0a80 	vdiv.f32	s0, s1, s0
 800982e:	2200      	movs	r2, #0
 8009830:	b381      	cbz	r1, 8009894 <forward_ap+0x294>
 8009832:	f011 0003 	ands.w	r0, r1, #3
 8009836:	464c      	mov	r4, r9
 8009838:	f000 800b 	beq.w	8009852 <forward_ap+0x252>
 800983c:	edd4 0a00 	vldr	s1, [r4]
 8009840:	ee60 0a80 	vmul.f32	s1, s1, s0
 8009844:	1c52      	adds	r2, r2, #1
 8009846:	edc4 0a00 	vstr	s1, [r4]
 800984a:	1e40      	subs	r0, r0, #1
 800984c:	f104 0404 	add.w	r4, r4, #4
 8009850:	d1f4      	bne.n	800983c <forward_ap+0x23c>
 8009852:	0888      	lsrs	r0, r1, #2
 8009854:	f000 801e 	beq.w	8009894 <forward_ap+0x294>
 8009858:	eb09 0282 	add.w	r2, r9, r2, lsl #2
 800985c:	edd2 0a00 	vldr	s1, [r2]
 8009860:	ee60 0a80 	vmul.f32	s1, s1, s0
 8009864:	edc2 0a00 	vstr	s1, [r2]
 8009868:	1e40      	subs	r0, r0, #1
 800986a:	ed92 1a01 	vldr	s2, [r2, #4]
 800986e:	edd2 0a02 	vldr	s1, [r2, #8]
 8009872:	ee21 1a00 	vmul.f32	s2, s2, s0
 8009876:	ed82 1a01 	vstr	s2, [r2, #4]
 800987a:	ee60 0a80 	vmul.f32	s1, s1, s0
 800987e:	ed92 1a03 	vldr	s2, [r2, #12]
 8009882:	edc2 0a02 	vstr	s1, [r2, #8]
 8009886:	ee21 1a00 	vmul.f32	s2, s2, s0
 800988a:	ed82 1a03 	vstr	s2, [r2, #12]
 800988e:	f102 0210 	add.w	r2, r2, #16
 8009892:	d1e3      	bne.n	800985c <forward_ap+0x25c>
 8009894:	9803      	ldr	r0, [sp, #12]
 8009896:	1e5b      	subs	r3, r3, #1
 8009898:	eb06 0680 	add.w	r6, r6, r0, lsl #2
 800989c:	f47f af61 	bne.w	8009762 <forward_ap+0x162>
 80098a0:	9800      	ldr	r0, [sp, #0]
 80098a2:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 80098a4:	1810      	adds	r0, r2, r0
 80098a6:	9000      	str	r0, [sp, #0]
 80098a8:	eb09 0981 	add.w	r9, r9, r1, lsl #2
 80098ac:	9802      	ldr	r0, [sp, #8]
 80098ae:	1e40      	subs	r0, r0, #1
 80098b0:	9002      	str	r0, [sp, #8]
 80098b2:	f47f af10 	bne.w	80096d6 <forward_ap+0xd6>
 80098b6:	f8dd e038 	ldr.w	lr, [sp, #56]	; 0x38
 80098ba:	f8dd c01c 	ldr.w	ip, [sp, #28]
 80098be:	9b06      	ldr	r3, [sp, #24]
 80098c0:	9d0a      	ldr	r5, [sp, #40]	; 0x28
 80098c2:	4690      	mov	r8, r2
 80098c4:	9c01      	ldr	r4, [sp, #4]
 80098c6:	9a16      	ldr	r2, [sp, #88]	; 0x58
 80098c8:	1914      	adds	r4, r2, r4
 80098ca:	9401      	str	r4, [sp, #4]
 80098cc:	9c04      	ldr	r4, [sp, #16]
 80098ce:	1e64      	subs	r4, r4, #1
 80098d0:	9404      	str	r4, [sp, #16]
 80098d2:	f47f aedb 	bne.w	800968c <forward_ap+0x8c>
 80098d6:	b017      	add	sp, #92	; 0x5c
 80098d8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

080098dc <ai_array_fmt_name>:
 80098dc:	f020 407e 	bic.w	r0, r0, #4261412864	; 0xfe000000
 80098e0:	f1b0 0140 	subs.w	r1, r0, #64	; 0x40
 80098e4:	d062      	beq.n	80099ac <ai_array_fmt_name+0xd0>
 80098e6:	f44f 2280 	mov.w	r2, #262144	; 0x40000
 80098ea:	1a89      	subs	r1, r1, r2
 80098ec:	f000 8094 	beq.w	8009a18 <ai_array_fmt_name+0x13c>
 80098f0:	f44f 7200 	mov.w	r2, #512	; 0x200
 80098f4:	1a89      	subs	r1, r1, r2
 80098f6:	d071      	beq.n	80099dc <ai_array_fmt_name+0x100>
 80098f8:	1a89      	subs	r1, r1, r2
 80098fa:	d063      	beq.n	80099c4 <ai_array_fmt_name+0xe8>
 80098fc:	1fc9      	subs	r1, r1, #7
 80098fe:	f000 808e 	beq.w	8009a1e <ai_array_fmt_name+0x142>
 8009902:	f240 32f9 	movw	r2, #1017	; 0x3f9
 8009906:	1a89      	subs	r1, r1, r2
 8009908:	d05f      	beq.n	80099ca <ai_array_fmt_name+0xee>
 800990a:	390f      	subs	r1, #15
 800990c:	f000 808a 	beq.w	8009a24 <ai_array_fmt_name+0x148>
 8009910:	f240 72f1 	movw	r2, #2033	; 0x7f1
 8009914:	1a89      	subs	r1, r1, r2
 8009916:	d05b      	beq.n	80099d0 <ai_array_fmt_name+0xf4>
 8009918:	391f      	subs	r1, #31
 800991a:	f000 8086 	beq.w	8009a2a <ai_array_fmt_name+0x14e>
 800991e:	f640 72e1 	movw	r2, #4065	; 0xfe1
 8009922:	1a89      	subs	r1, r1, r2
 8009924:	d057      	beq.n	80099d6 <ai_array_fmt_name+0xfa>
 8009926:	f8df 25d4 	ldr.w	r2, [pc, #1492]	; 8009efc <.text_15>
 800992a:	1a89      	subs	r1, r1, r2
 800992c:	f000 808f 	beq.w	8009a4e <ai_array_fmt_name+0x172>
 8009930:	f44f 12c0 	mov.w	r2, #1572864	; 0x180000
 8009934:	1a89      	subs	r1, r1, r2
 8009936:	f000 8087 	beq.w	8009a48 <ai_array_fmt_name+0x16c>
 800993a:	f8df 25c4 	ldr.w	r2, [pc, #1476]	; 8009f00 <.text_16>
 800993e:	1a89      	subs	r1, r1, r2
 8009940:	d05e      	beq.n	8009a00 <ai_array_fmt_name+0x124>
 8009942:	f44f 7200 	mov.w	r2, #512	; 0x200
 8009946:	1a89      	subs	r1, r1, r2
 8009948:	d057      	beq.n	80099fa <ai_array_fmt_name+0x11e>
 800994a:	1a89      	subs	r1, r1, r2
 800994c:	d049      	beq.n	80099e2 <ai_array_fmt_name+0x106>
 800994e:	1fc9      	subs	r1, r1, #7
 8009950:	d059      	beq.n	8009a06 <ai_array_fmt_name+0x12a>
 8009952:	f240 32f9 	movw	r2, #1017	; 0x3f9
 8009956:	1a89      	subs	r1, r1, r2
 8009958:	d046      	beq.n	80099e8 <ai_array_fmt_name+0x10c>
 800995a:	390f      	subs	r1, #15
 800995c:	d056      	beq.n	8009a0c <ai_array_fmt_name+0x130>
 800995e:	f240 72f1 	movw	r2, #2033	; 0x7f1
 8009962:	1a89      	subs	r1, r1, r2
 8009964:	d043      	beq.n	80099ee <ai_array_fmt_name+0x112>
 8009966:	391f      	subs	r1, #31
 8009968:	d053      	beq.n	8009a12 <ai_array_fmt_name+0x136>
 800996a:	f640 72e1 	movw	r2, #4065	; 0xfe1
 800996e:	1a89      	subs	r1, r1, r2
 8009970:	d040      	beq.n	80099f4 <ai_array_fmt_name+0x118>
 8009972:	f8df 2588 	ldr.w	r2, [pc, #1416]	; 8009efc <.text_15>
 8009976:	1a89      	subs	r1, r1, r2
 8009978:	d063      	beq.n	8009a42 <ai_array_fmt_name+0x166>
 800997a:	f44f 12c0 	mov.w	r2, #1572864	; 0x180000
 800997e:	1a89      	subs	r1, r1, r2
 8009980:	d05c      	beq.n	8009a3c <ai_array_fmt_name+0x160>
 8009982:	f8df 2580 	ldr.w	r2, [pc, #1408]	; 8009f04 <.text_17>
 8009986:	1a89      	subs	r1, r1, r2
 8009988:	d019      	beq.n	80099be <ai_array_fmt_name+0xe2>
 800998a:	f44f 6200 	mov.w	r2, #2048	; 0x800
 800998e:	1a89      	subs	r1, r1, r2
 8009990:	d00f      	beq.n	80099b2 <ai_array_fmt_name+0xd6>
 8009992:	f44f 5280 	mov.w	r2, #4096	; 0x1000
 8009996:	1a89      	subs	r1, r1, r2
 8009998:	d00e      	beq.n	80099b8 <ai_array_fmt_name+0xdc>
 800999a:	f8df 256c 	ldr.w	r2, [pc, #1388]	; 8009f08 <.text_18>
 800999e:	1a89      	subs	r1, r1, r2
 80099a0:	d049      	beq.n	8009a36 <ai_array_fmt_name+0x15a>
 80099a2:	f44f 12c0 	mov.w	r2, #1572864	; 0x180000
 80099a6:	1a89      	subs	r1, r1, r2
 80099a8:	d042      	beq.n	8009a30 <ai_array_fmt_name+0x154>
 80099aa:	e053      	b.n	8009a54 <ai_array_fmt_name+0x178>
 80099ac:	f20f 6074 	addw	r0, pc, #1652	; 0x674
 80099b0:	4770      	bx	lr
 80099b2:	f20f 607c 	addw	r0, pc, #1660	; 0x67c
 80099b6:	4770      	bx	lr
 80099b8:	f20f 6080 	addw	r0, pc, #1664	; 0x680
 80099bc:	4770      	bx	lr
 80099be:	f20f 6088 	addw	r0, pc, #1672	; 0x688
 80099c2:	4770      	bx	lr
 80099c4:	f20f 608c 	addw	r0, pc, #1676	; 0x68c
 80099c8:	4770      	bx	lr
 80099ca:	f20f 6090 	addw	r0, pc, #1680	; 0x690
 80099ce:	4770      	bx	lr
 80099d0:	f20f 6090 	addw	r0, pc, #1680	; 0x690
 80099d4:	4770      	bx	lr
 80099d6:	f20f 6094 	addw	r0, pc, #1684	; 0x694
 80099da:	4770      	bx	lr
 80099dc:	f20f 6094 	addw	r0, pc, #1684	; 0x694
 80099e0:	4770      	bx	lr
 80099e2:	f20f 6098 	addw	r0, pc, #1688	; 0x698
 80099e6:	4770      	bx	lr
 80099e8:	f20f 6098 	addw	r0, pc, #1688	; 0x698
 80099ec:	4770      	bx	lr
 80099ee:	f20f 609c 	addw	r0, pc, #1692	; 0x69c
 80099f2:	4770      	bx	lr
 80099f4:	f20f 609c 	addw	r0, pc, #1692	; 0x69c
 80099f8:	4770      	bx	lr
 80099fa:	f20f 60a0 	addw	r0, pc, #1696	; 0x6a0
 80099fe:	4770      	bx	lr
 8009a00:	f20f 60a0 	addw	r0, pc, #1696	; 0x6a0
 8009a04:	4770      	bx	lr
 8009a06:	f20f 60a4 	addw	r0, pc, #1700	; 0x6a4
 8009a0a:	4770      	bx	lr
 8009a0c:	f20f 60a4 	addw	r0, pc, #1700	; 0x6a4
 8009a10:	4770      	bx	lr
 8009a12:	f20f 60a8 	addw	r0, pc, #1704	; 0x6a8
 8009a16:	4770      	bx	lr
 8009a18:	f20f 60a8 	addw	r0, pc, #1704	; 0x6a8
 8009a1c:	4770      	bx	lr
 8009a1e:	f20f 60ac 	addw	r0, pc, #1708	; 0x6ac
 8009a22:	4770      	bx	lr
 8009a24:	f20f 60ac 	addw	r0, pc, #1708	; 0x6ac
 8009a28:	4770      	bx	lr
 8009a2a:	f20f 60b4 	addw	r0, pc, #1716	; 0x6b4
 8009a2e:	4770      	bx	lr
 8009a30:	f20f 60b8 	addw	r0, pc, #1720	; 0x6b8
 8009a34:	4770      	bx	lr
 8009a36:	f20f 60c4 	addw	r0, pc, #1732	; 0x6c4
 8009a3a:	4770      	bx	lr
 8009a3c:	f20f 60cc 	addw	r0, pc, #1740	; 0x6cc
 8009a40:	4770      	bx	lr
 8009a42:	f20f 60d8 	addw	r0, pc, #1752	; 0x6d8
 8009a46:	4770      	bx	lr
 8009a48:	f20f 60e0 	addw	r0, pc, #1760	; 0x6e0
 8009a4c:	4770      	bx	lr
 8009a4e:	f20f 60ec 	addw	r0, pc, #1772	; 0x6ec
 8009a52:	4770      	bx	lr
 8009a54:	f36f 000d 	bfc	r0, #0, #14
 8009a58:	f040 0040 	orr.w	r0, r0, #64	; 0x40
 8009a5c:	2840      	cmp	r0, #64	; 0x40
 8009a5e:	d009      	beq.n	8009a74 <ai_array_fmt_name+0x198>
 8009a60:	f8df 14a8 	ldr.w	r1, [pc, #1192]	; 8009f0c <.text_19>
 8009a64:	4288      	cmp	r0, r1
 8009a66:	d00b      	beq.n	8009a80 <ai_array_fmt_name+0x1a4>
 8009a68:	f8df 14a4 	ldr.w	r1, [pc, #1188]	; 8009f10 <.text_20>
 8009a6c:	4288      	cmp	r0, r1
 8009a6e:	d004      	beq.n	8009a7a <ai_array_fmt_name+0x19e>
 8009a70:	a07a      	add	r0, pc, #488	; (adr r0, 8009c5c <.text_8>)
 8009a72:	4770      	bx	lr
 8009a74:	f20f 60d4 	addw	r0, pc, #1748	; 0x6d4
 8009a78:	4770      	bx	lr
 8009a7a:	f20f 60e8 	addw	r0, pc, #1768	; 0x6e8
 8009a7e:	4770      	bx	lr
 8009a80:	f20f 60f4 	addw	r0, pc, #1780	; 0x6f4
 8009a84:	4770      	bx	lr

08009a86 <ai_array_fmt_exported>:
 8009a86:	f020 407e 	bic.w	r0, r0, #4261412864	; 0xfe000000
 8009a8a:	f1b0 0140 	subs.w	r1, r0, #64	; 0x40
 8009a8e:	d068      	beq.n	8009b62 <ai_array_fmt_exported+0xdc>
 8009a90:	f44f 2280 	mov.w	r2, #262144	; 0x40000
 8009a94:	1a89      	subs	r1, r1, r2
 8009a96:	d064      	beq.n	8009b62 <ai_array_fmt_exported+0xdc>
 8009a98:	f44f 7200 	mov.w	r2, #512	; 0x200
 8009a9c:	1a89      	subs	r1, r1, r2
 8009a9e:	d062      	beq.n	8009b66 <ai_array_fmt_exported+0xe0>
 8009aa0:	1a89      	subs	r1, r1, r2
 8009aa2:	d05e      	beq.n	8009b62 <ai_array_fmt_exported+0xdc>
 8009aa4:	1fc9      	subs	r1, r1, #7
 8009aa6:	d05c      	beq.n	8009b62 <ai_array_fmt_exported+0xdc>
 8009aa8:	f240 32f9 	movw	r2, #1017	; 0x3f9
 8009aac:	1a89      	subs	r1, r1, r2
 8009aae:	d058      	beq.n	8009b62 <ai_array_fmt_exported+0xdc>
 8009ab0:	390f      	subs	r1, #15
 8009ab2:	d056      	beq.n	8009b62 <ai_array_fmt_exported+0xdc>
 8009ab4:	f240 72f1 	movw	r2, #2033	; 0x7f1
 8009ab8:	1a89      	subs	r1, r1, r2
 8009aba:	d054      	beq.n	8009b66 <ai_array_fmt_exported+0xe0>
 8009abc:	391f      	subs	r1, #31
 8009abe:	d052      	beq.n	8009b66 <ai_array_fmt_exported+0xe0>
 8009ac0:	f640 72e1 	movw	r2, #4065	; 0xfe1
 8009ac4:	1a89      	subs	r1, r1, r2
 8009ac6:	d04e      	beq.n	8009b66 <ai_array_fmt_exported+0xe0>
 8009ac8:	f8df 2430 	ldr.w	r2, [pc, #1072]	; 8009efc <.text_15>
 8009acc:	1a89      	subs	r1, r1, r2
 8009ace:	d04a      	beq.n	8009b66 <ai_array_fmt_exported+0xe0>
 8009ad0:	f44f 12c0 	mov.w	r2, #1572864	; 0x180000
 8009ad4:	1a89      	subs	r1, r1, r2
 8009ad6:	d046      	beq.n	8009b66 <ai_array_fmt_exported+0xe0>
 8009ad8:	f8df 2424 	ldr.w	r2, [pc, #1060]	; 8009f00 <.text_16>
 8009adc:	1a89      	subs	r1, r1, r2
 8009ade:	d040      	beq.n	8009b62 <ai_array_fmt_exported+0xdc>
 8009ae0:	f44f 7200 	mov.w	r2, #512	; 0x200
 8009ae4:	1a89      	subs	r1, r1, r2
 8009ae6:	d03e      	beq.n	8009b66 <ai_array_fmt_exported+0xe0>
 8009ae8:	1a89      	subs	r1, r1, r2
 8009aea:	d03a      	beq.n	8009b62 <ai_array_fmt_exported+0xdc>
 8009aec:	1fc9      	subs	r1, r1, #7
 8009aee:	d038      	beq.n	8009b62 <ai_array_fmt_exported+0xdc>
 8009af0:	f240 32f9 	movw	r2, #1017	; 0x3f9
 8009af4:	1a89      	subs	r1, r1, r2
 8009af6:	d034      	beq.n	8009b62 <ai_array_fmt_exported+0xdc>
 8009af8:	390f      	subs	r1, #15
 8009afa:	d032      	beq.n	8009b62 <ai_array_fmt_exported+0xdc>
 8009afc:	f240 72f1 	movw	r2, #2033	; 0x7f1
 8009b00:	1a89      	subs	r1, r1, r2
 8009b02:	d030      	beq.n	8009b66 <ai_array_fmt_exported+0xe0>
 8009b04:	391f      	subs	r1, #31
 8009b06:	d02e      	beq.n	8009b66 <ai_array_fmt_exported+0xe0>
 8009b08:	f640 72e1 	movw	r2, #4065	; 0xfe1
 8009b0c:	1a89      	subs	r1, r1, r2
 8009b0e:	d02a      	beq.n	8009b66 <ai_array_fmt_exported+0xe0>
 8009b10:	f8df 23e8 	ldr.w	r2, [pc, #1000]	; 8009efc <.text_15>
 8009b14:	1a89      	subs	r1, r1, r2
 8009b16:	d026      	beq.n	8009b66 <ai_array_fmt_exported+0xe0>
 8009b18:	f44f 12c0 	mov.w	r2, #1572864	; 0x180000
 8009b1c:	1a89      	subs	r1, r1, r2
 8009b1e:	d022      	beq.n	8009b66 <ai_array_fmt_exported+0xe0>
 8009b20:	f8df 23e0 	ldr.w	r2, [pc, #992]	; 8009f04 <.text_17>
 8009b24:	1a89      	subs	r1, r1, r2
 8009b26:	d01e      	beq.n	8009b66 <ai_array_fmt_exported+0xe0>
 8009b28:	f44f 6200 	mov.w	r2, #2048	; 0x800
 8009b2c:	1a89      	subs	r1, r1, r2
 8009b2e:	d018      	beq.n	8009b62 <ai_array_fmt_exported+0xdc>
 8009b30:	f44f 5280 	mov.w	r2, #4096	; 0x1000
 8009b34:	1a89      	subs	r1, r1, r2
 8009b36:	d016      	beq.n	8009b66 <ai_array_fmt_exported+0xe0>
 8009b38:	f8df 23cc 	ldr.w	r2, [pc, #972]	; 8009f08 <.text_18>
 8009b3c:	1a89      	subs	r1, r1, r2
 8009b3e:	d012      	beq.n	8009b66 <ai_array_fmt_exported+0xe0>
 8009b40:	f44f 12c0 	mov.w	r2, #1572864	; 0x180000
 8009b44:	1a89      	subs	r1, r1, r2
 8009b46:	d00e      	beq.n	8009b66 <ai_array_fmt_exported+0xe0>
 8009b48:	f36f 000d 	bfc	r0, #0, #14
 8009b4c:	f040 0040 	orr.w	r0, r0, #64	; 0x40
 8009b50:	2840      	cmp	r0, #64	; 0x40
 8009b52:	bf1f      	itttt	ne
 8009b54:	f8df 33b4 	ldrne.w	r3, [pc, #948]	; 8009f0c <.text_19>
 8009b58:	4298      	cmpne	r0, r3
 8009b5a:	f8df 33b4 	ldrne.w	r3, [pc, #948]	; 8009f10 <.text_20>
 8009b5e:	4298      	cmpne	r0, r3
 8009b60:	d101      	bne.n	8009b66 <ai_array_fmt_exported+0xe0>
 8009b62:	2001      	movs	r0, #1
 8009b64:	4770      	bx	lr
 8009b66:	2000      	movs	r0, #0
 8009b68:	4770      	bx	lr

08009b6a <ai_array_fmt_valid>:
 8009b6a:	f020 407e 	bic.w	r0, r0, #4261412864	; 0xfe000000
 8009b6e:	f1b0 0140 	subs.w	r1, r0, #64	; 0x40
 8009b72:	d069      	beq.n	8009c48 <ai_array_fmt_valid+0xde>
 8009b74:	f44f 2280 	mov.w	r2, #262144	; 0x40000
 8009b78:	1a89      	subs	r1, r1, r2
 8009b7a:	d065      	beq.n	8009c48 <ai_array_fmt_valid+0xde>
 8009b7c:	f44f 7200 	mov.w	r2, #512	; 0x200
 8009b80:	1a89      	subs	r1, r1, r2
 8009b82:	d061      	beq.n	8009c48 <ai_array_fmt_valid+0xde>
 8009b84:	1a89      	subs	r1, r1, r2
 8009b86:	d05f      	beq.n	8009c48 <ai_array_fmt_valid+0xde>
 8009b88:	1fc9      	subs	r1, r1, #7
 8009b8a:	d05d      	beq.n	8009c48 <ai_array_fmt_valid+0xde>
 8009b8c:	f240 32f9 	movw	r2, #1017	; 0x3f9
 8009b90:	1a89      	subs	r1, r1, r2
 8009b92:	d059      	beq.n	8009c48 <ai_array_fmt_valid+0xde>
 8009b94:	390f      	subs	r1, #15
 8009b96:	d057      	beq.n	8009c48 <ai_array_fmt_valid+0xde>
 8009b98:	f240 72f1 	movw	r2, #2033	; 0x7f1
 8009b9c:	1a89      	subs	r1, r1, r2
 8009b9e:	d053      	beq.n	8009c48 <ai_array_fmt_valid+0xde>
 8009ba0:	391f      	subs	r1, #31
 8009ba2:	d051      	beq.n	8009c48 <ai_array_fmt_valid+0xde>
 8009ba4:	f640 72e1 	movw	r2, #4065	; 0xfe1
 8009ba8:	1a89      	subs	r1, r1, r2
 8009baa:	d04d      	beq.n	8009c48 <ai_array_fmt_valid+0xde>
 8009bac:	f8df 234c 	ldr.w	r2, [pc, #844]	; 8009efc <.text_15>
 8009bb0:	1a89      	subs	r1, r1, r2
 8009bb2:	d049      	beq.n	8009c48 <ai_array_fmt_valid+0xde>
 8009bb4:	f44f 12c0 	mov.w	r2, #1572864	; 0x180000
 8009bb8:	1a89      	subs	r1, r1, r2
 8009bba:	d045      	beq.n	8009c48 <ai_array_fmt_valid+0xde>
 8009bbc:	f8df 2340 	ldr.w	r2, [pc, #832]	; 8009f00 <.text_16>
 8009bc0:	1a89      	subs	r1, r1, r2
 8009bc2:	d041      	beq.n	8009c48 <ai_array_fmt_valid+0xde>
 8009bc4:	f44f 7200 	mov.w	r2, #512	; 0x200
 8009bc8:	1a89      	subs	r1, r1, r2
 8009bca:	d03d      	beq.n	8009c48 <ai_array_fmt_valid+0xde>
 8009bcc:	1a89      	subs	r1, r1, r2
 8009bce:	d03b      	beq.n	8009c48 <ai_array_fmt_valid+0xde>
 8009bd0:	1fc9      	subs	r1, r1, #7
 8009bd2:	d039      	beq.n	8009c48 <ai_array_fmt_valid+0xde>
 8009bd4:	f240 32f9 	movw	r2, #1017	; 0x3f9
 8009bd8:	1a89      	subs	r1, r1, r2
 8009bda:	d035      	beq.n	8009c48 <ai_array_fmt_valid+0xde>
 8009bdc:	390f      	subs	r1, #15
 8009bde:	d033      	beq.n	8009c48 <ai_array_fmt_valid+0xde>
 8009be0:	f240 72f1 	movw	r2, #2033	; 0x7f1
 8009be4:	1a89      	subs	r1, r1, r2
 8009be6:	d02f      	beq.n	8009c48 <ai_array_fmt_valid+0xde>
 8009be8:	391f      	subs	r1, #31
 8009bea:	d02d      	beq.n	8009c48 <ai_array_fmt_valid+0xde>
 8009bec:	f640 72e1 	movw	r2, #4065	; 0xfe1
 8009bf0:	1a89      	subs	r1, r1, r2
 8009bf2:	d029      	beq.n	8009c48 <ai_array_fmt_valid+0xde>
 8009bf4:	f8df 2304 	ldr.w	r2, [pc, #772]	; 8009efc <.text_15>
 8009bf8:	1a89      	subs	r1, r1, r2
 8009bfa:	d025      	beq.n	8009c48 <ai_array_fmt_valid+0xde>
 8009bfc:	f44f 12c0 	mov.w	r2, #1572864	; 0x180000
 8009c00:	1a89      	subs	r1, r1, r2
 8009c02:	d021      	beq.n	8009c48 <ai_array_fmt_valid+0xde>
 8009c04:	f8df 22fc 	ldr.w	r2, [pc, #764]	; 8009f04 <.text_17>
 8009c08:	1a89      	subs	r1, r1, r2
 8009c0a:	d01d      	beq.n	8009c48 <ai_array_fmt_valid+0xde>
 8009c0c:	f44f 6200 	mov.w	r2, #2048	; 0x800
 8009c10:	1a89      	subs	r1, r1, r2
 8009c12:	d019      	beq.n	8009c48 <ai_array_fmt_valid+0xde>
 8009c14:	f44f 5280 	mov.w	r2, #4096	; 0x1000
 8009c18:	1a89      	subs	r1, r1, r2
 8009c1a:	d015      	beq.n	8009c48 <ai_array_fmt_valid+0xde>
 8009c1c:	f8df 22e8 	ldr.w	r2, [pc, #744]	; 8009f08 <.text_18>
 8009c20:	1a89      	subs	r1, r1, r2
 8009c22:	d011      	beq.n	8009c48 <ai_array_fmt_valid+0xde>
 8009c24:	f44f 12c0 	mov.w	r2, #1572864	; 0x180000
 8009c28:	1a89      	subs	r1, r1, r2
 8009c2a:	bf1e      	ittt	ne
 8009c2c:	f36f 000d 	bfcne	r0, #0, #14
 8009c30:	f040 0040 	orrne.w	r0, r0, #64	; 0x40
 8009c34:	2840      	cmpne	r0, #64	; 0x40
 8009c36:	d007      	beq.n	8009c48 <ai_array_fmt_valid+0xde>
 8009c38:	f8df 32d0 	ldr.w	r3, [pc, #720]	; 8009f0c <.text_19>
 8009c3c:	4298      	cmp	r0, r3
 8009c3e:	bf1c      	itt	ne
 8009c40:	f8df 32cc 	ldrne.w	r3, [pc, #716]	; 8009f10 <.text_20>
 8009c44:	4298      	cmpne	r0, r3
 8009c46:	d101      	bne.n	8009c4c <ai_array_fmt_valid+0xe2>
 8009c48:	2001      	movs	r0, #1
 8009c4a:	4770      	bx	lr
 8009c4c:	2000      	movs	r0, #0
 8009c4e:	4770      	bx	lr

08009c50 <ai_array_fmt_get_formats>:
 8009c50:	f8df 12c0 	ldr.w	r1, [pc, #704]	; 8009f14 <.text_21>
 8009c54:	6001      	str	r1, [r0, #0]
 8009c56:	201c      	movs	r0, #28
 8009c58:	4770      	bx	lr
	...

08009c5c <.text_8>:
 8009c5c:	00000000 	.word	0x00000000

08009c60 <ai_buffer_fmt_name>:
 8009c60:	f020 407e 	bic.w	r0, r0, #4261412864	; 0xfe000000
 8009c64:	f1b0 0140 	subs.w	r1, r0, #64	; 0x40
 8009c68:	d022      	beq.n	8009cb0 <ai_buffer_fmt_name+0x50>
 8009c6a:	f44f 2280 	mov.w	r2, #262144	; 0x40000
 8009c6e:	1a89      	subs	r1, r1, r2
 8009c70:	d039      	beq.n	8009ce6 <ai_buffer_fmt_name+0x86>
 8009c72:	f44f 6280 	mov.w	r2, #1024	; 0x400
 8009c76:	1a89      	subs	r1, r1, r2
 8009c78:	d020      	beq.n	8009cbc <ai_buffer_fmt_name+0x5c>
 8009c7a:	1fc9      	subs	r1, r1, #7
 8009c7c:	d036      	beq.n	8009cec <ai_buffer_fmt_name+0x8c>
 8009c7e:	f240 32f9 	movw	r2, #1017	; 0x3f9
 8009c82:	1a89      	subs	r1, r1, r2
 8009c84:	d01d      	beq.n	8009cc2 <ai_buffer_fmt_name+0x62>
 8009c86:	390f      	subs	r1, #15
 8009c88:	d033      	beq.n	8009cf2 <ai_buffer_fmt_name+0x92>
 8009c8a:	4aa3      	ldr	r2, [pc, #652]	; (8009f18 <.text_22>)
 8009c8c:	1a89      	subs	r1, r1, r2
 8009c8e:	d021      	beq.n	8009cd4 <ai_buffer_fmt_name+0x74>
 8009c90:	f44f 6280 	mov.w	r2, #1024	; 0x400
 8009c94:	1a89      	subs	r1, r1, r2
 8009c96:	d017      	beq.n	8009cc8 <ai_buffer_fmt_name+0x68>
 8009c98:	1fc9      	subs	r1, r1, #7
 8009c9a:	d01e      	beq.n	8009cda <ai_buffer_fmt_name+0x7a>
 8009c9c:	f240 32f9 	movw	r2, #1017	; 0x3f9
 8009ca0:	1a89      	subs	r1, r1, r2
 8009ca2:	d014      	beq.n	8009cce <ai_buffer_fmt_name+0x6e>
 8009ca4:	390f      	subs	r1, #15
 8009ca6:	d01b      	beq.n	8009ce0 <ai_buffer_fmt_name+0x80>
 8009ca8:	4a9c      	ldr	r2, [pc, #624]	; (8009f1c <.text_23>)
 8009caa:	1a89      	subs	r1, r1, r2
 8009cac:	d003      	beq.n	8009cb6 <ai_buffer_fmt_name+0x56>
 8009cae:	e023      	b.n	8009cf8 <ai_buffer_fmt_name+0x98>
 8009cb0:	f20f 3070 	addw	r0, pc, #880	; 0x370
 8009cb4:	4770      	bx	lr
 8009cb6:	f20f 3078 	addw	r0, pc, #888	; 0x378
 8009cba:	4770      	bx	lr
 8009cbc:	f20f 3094 	addw	r0, pc, #916	; 0x394
 8009cc0:	4770      	bx	lr
 8009cc2:	f20f 3098 	addw	r0, pc, #920	; 0x398
 8009cc6:	4770      	bx	lr
 8009cc8:	f20f 30b0 	addw	r0, pc, #944	; 0x3b0
 8009ccc:	4770      	bx	lr
 8009cce:	f20f 30b4 	addw	r0, pc, #948	; 0x3b4
 8009cd2:	4770      	bx	lr
 8009cd4:	f20f 30cc 	addw	r0, pc, #972	; 0x3cc
 8009cd8:	4770      	bx	lr
 8009cda:	f20f 30d0 	addw	r0, pc, #976	; 0x3d0
 8009cde:	4770      	bx	lr
 8009ce0:	f20f 30d0 	addw	r0, pc, #976	; 0x3d0
 8009ce4:	4770      	bx	lr
 8009ce6:	f20f 30dc 	addw	r0, pc, #988	; 0x3dc
 8009cea:	4770      	bx	lr
 8009cec:	f20f 30dc 	addw	r0, pc, #988	; 0x3dc
 8009cf0:	4770      	bx	lr
 8009cf2:	f20f 30e0 	addw	r0, pc, #992	; 0x3e0
 8009cf6:	4770      	bx	lr
 8009cf8:	0b80      	lsrs	r0, r0, #14
 8009cfa:	0380      	lsls	r0, r0, #14
 8009cfc:	f040 0040 	orr.w	r0, r0, #64	; 0x40
 8009d00:	2840      	cmp	r0, #64	; 0x40
 8009d02:	d007      	beq.n	8009d14 <ai_buffer_fmt_name+0xb4>
 8009d04:	4981      	ldr	r1, [pc, #516]	; (8009f0c <.text_19>)
 8009d06:	4288      	cmp	r0, r1
 8009d08:	d00a      	beq.n	8009d20 <ai_buffer_fmt_name+0xc0>
 8009d0a:	4981      	ldr	r1, [pc, #516]	; (8009f10 <.text_20>)
 8009d0c:	4288      	cmp	r0, r1
 8009d0e:	d004      	beq.n	8009d1a <ai_buffer_fmt_name+0xba>
 8009d10:	a079      	add	r0, pc, #484	; (adr r0, 8009ef8 <.text_14>)
 8009d12:	4770      	bx	lr
 8009d14:	f20f 4074 	addw	r0, pc, #1140	; 0x474
 8009d18:	4770      	bx	lr
 8009d1a:	f20f 4088 	addw	r0, pc, #1160	; 0x488
 8009d1e:	4770      	bx	lr
 8009d20:	f20f 4094 	addw	r0, pc, #1172	; 0x494
 8009d24:	4770      	bx	lr

08009d26 <ai_buffer_fmt_valid>:
 8009d26:	f020 407e 	bic.w	r0, r0, #4261412864	; 0xfe000000
 8009d2a:	f1b0 0140 	subs.w	r1, r0, #64	; 0x40
 8009d2e:	d02d      	beq.n	8009d8c <ai_buffer_fmt_valid+0x66>
 8009d30:	f44f 2280 	mov.w	r2, #262144	; 0x40000
 8009d34:	1a89      	subs	r1, r1, r2
 8009d36:	d029      	beq.n	8009d8c <ai_buffer_fmt_valid+0x66>
 8009d38:	f44f 6280 	mov.w	r2, #1024	; 0x400
 8009d3c:	1a89      	subs	r1, r1, r2
 8009d3e:	d025      	beq.n	8009d8c <ai_buffer_fmt_valid+0x66>
 8009d40:	1fc9      	subs	r1, r1, #7
 8009d42:	d023      	beq.n	8009d8c <ai_buffer_fmt_valid+0x66>
 8009d44:	f240 32f9 	movw	r2, #1017	; 0x3f9
 8009d48:	1a89      	subs	r1, r1, r2
 8009d4a:	d01f      	beq.n	8009d8c <ai_buffer_fmt_valid+0x66>
 8009d4c:	390f      	subs	r1, #15
 8009d4e:	d01d      	beq.n	8009d8c <ai_buffer_fmt_valid+0x66>
 8009d50:	4a71      	ldr	r2, [pc, #452]	; (8009f18 <.text_22>)
 8009d52:	1a89      	subs	r1, r1, r2
 8009d54:	d01a      	beq.n	8009d8c <ai_buffer_fmt_valid+0x66>
 8009d56:	f44f 6280 	mov.w	r2, #1024	; 0x400
 8009d5a:	1a89      	subs	r1, r1, r2
 8009d5c:	d016      	beq.n	8009d8c <ai_buffer_fmt_valid+0x66>
 8009d5e:	1fc9      	subs	r1, r1, #7
 8009d60:	d014      	beq.n	8009d8c <ai_buffer_fmt_valid+0x66>
 8009d62:	f240 32f9 	movw	r2, #1017	; 0x3f9
 8009d66:	1a89      	subs	r1, r1, r2
 8009d68:	d010      	beq.n	8009d8c <ai_buffer_fmt_valid+0x66>
 8009d6a:	390f      	subs	r1, #15
 8009d6c:	d00e      	beq.n	8009d8c <ai_buffer_fmt_valid+0x66>
 8009d6e:	4a6b      	ldr	r2, [pc, #428]	; (8009f1c <.text_23>)
 8009d70:	1a89      	subs	r1, r1, r2
 8009d72:	bf1f      	itttt	ne
 8009d74:	0b80      	lsrne	r0, r0, #14
 8009d76:	0380      	lslne	r0, r0, #14
 8009d78:	f040 0040 	orrne.w	r0, r0, #64	; 0x40
 8009d7c:	2840      	cmpne	r0, #64	; 0x40
 8009d7e:	d005      	beq.n	8009d8c <ai_buffer_fmt_valid+0x66>
 8009d80:	4b62      	ldr	r3, [pc, #392]	; (8009f0c <.text_19>)
 8009d82:	4298      	cmp	r0, r3
 8009d84:	bf1c      	itt	ne
 8009d86:	4b62      	ldrne	r3, [pc, #392]	; (8009f10 <.text_20>)
 8009d88:	4298      	cmpne	r0, r3
 8009d8a:	d101      	bne.n	8009d90 <ai_buffer_fmt_valid+0x6a>
 8009d8c:	2001      	movs	r0, #1
 8009d8e:	4770      	bx	lr
 8009d90:	2000      	movs	r0, #0
 8009d92:	4770      	bx	lr

08009d94 <ai_buffer_fmt_get_formats>:
 8009d94:	4962      	ldr	r1, [pc, #392]	; (8009f20 <.text_24>)
 8009d96:	6001      	str	r1, [r0, #0]
 8009d98:	200c      	movs	r0, #12
 8009d9a:	4770      	bx	lr

08009d9c <ai_array_to_buffer_fmt>:
 8009d9c:	4601      	mov	r1, r0
 8009d9e:	2040      	movs	r0, #64	; 0x40
 8009da0:	f3c1 4243 	ubfx	r2, r1, #17, #4
 8009da4:	2a02      	cmp	r2, #2
 8009da6:	d104      	bne.n	8009db2 <ai_array_to_buffer_fmt+0x16>
 8009da8:	485e      	ldr	r0, [pc, #376]	; (8009f24 <.text_25>)
 8009daa:	4008      	ands	r0, r1
 8009dac:	f440 2080 	orr.w	r0, r0, #262144	; 0x40000
 8009db0:	e037      	b.n	8009e22 <ai_array_to_buffer_fmt+0x86>
 8009db2:	f021 427e 	bic.w	r2, r1, #4261412864	; 0xfe000000
 8009db6:	4b55      	ldr	r3, [pc, #340]	; (8009f0c <.text_19>)
 8009db8:	1ad2      	subs	r2, r2, r3
 8009dba:	d02d      	beq.n	8009e18 <ai_array_to_buffer_fmt+0x7c>
 8009dbc:	f44f 6380 	mov.w	r3, #1024	; 0x400
 8009dc0:	1ad2      	subs	r2, r2, r3
 8009dc2:	d01b      	beq.n	8009dfc <ai_array_to_buffer_fmt+0x60>
 8009dc4:	1fd2      	subs	r2, r2, #7
 8009dc6:	d029      	beq.n	8009e1c <ai_array_to_buffer_fmt+0x80>
 8009dc8:	f240 33f9 	movw	r3, #1017	; 0x3f9
 8009dcc:	1ad2      	subs	r2, r2, r3
 8009dce:	d017      	beq.n	8009e00 <ai_array_to_buffer_fmt+0x64>
 8009dd0:	3a0f      	subs	r2, #15
 8009dd2:	d025      	beq.n	8009e20 <ai_array_to_buffer_fmt+0x84>
 8009dd4:	4b50      	ldr	r3, [pc, #320]	; (8009f18 <.text_22>)
 8009dd6:	1ad2      	subs	r2, r2, r3
 8009dd8:	d018      	beq.n	8009e0c <ai_array_to_buffer_fmt+0x70>
 8009dda:	f44f 6380 	mov.w	r3, #1024	; 0x400
 8009dde:	1ad2      	subs	r2, r2, r3
 8009de0:	d010      	beq.n	8009e04 <ai_array_to_buffer_fmt+0x68>
 8009de2:	1fd2      	subs	r2, r2, #7
 8009de4:	d014      	beq.n	8009e10 <ai_array_to_buffer_fmt+0x74>
 8009de6:	f240 33f9 	movw	r3, #1017	; 0x3f9
 8009dea:	1ad2      	subs	r2, r2, r3
 8009dec:	d00c      	beq.n	8009e08 <ai_array_to_buffer_fmt+0x6c>
 8009dee:	3a0f      	subs	r2, #15
 8009df0:	d010      	beq.n	8009e14 <ai_array_to_buffer_fmt+0x78>
 8009df2:	4b4a      	ldr	r3, [pc, #296]	; (8009f1c <.text_23>)
 8009df4:	1ad2      	subs	r2, r2, r3
 8009df6:	d114      	bne.n	8009e22 <ai_array_to_buffer_fmt+0x86>
 8009df8:	484b      	ldr	r0, [pc, #300]	; (8009f28 <.text_26>)
 8009dfa:	e012      	b.n	8009e22 <ai_array_to_buffer_fmt+0x86>
 8009dfc:	484b      	ldr	r0, [pc, #300]	; (8009f2c <.text_27>)
 8009dfe:	e010      	b.n	8009e22 <ai_array_to_buffer_fmt+0x86>
 8009e00:	484b      	ldr	r0, [pc, #300]	; (8009f30 <.text_28>)
 8009e02:	e00e      	b.n	8009e22 <ai_array_to_buffer_fmt+0x86>
 8009e04:	484b      	ldr	r0, [pc, #300]	; (8009f34 <.text_29>)
 8009e06:	e00c      	b.n	8009e22 <ai_array_to_buffer_fmt+0x86>
 8009e08:	484b      	ldr	r0, [pc, #300]	; (8009f38 <.text_30>)
 8009e0a:	e00a      	b.n	8009e22 <ai_array_to_buffer_fmt+0x86>
 8009e0c:	4840      	ldr	r0, [pc, #256]	; (8009f10 <.text_20>)
 8009e0e:	e008      	b.n	8009e22 <ai_array_to_buffer_fmt+0x86>
 8009e10:	484a      	ldr	r0, [pc, #296]	; (8009f3c <.text_31>)
 8009e12:	e006      	b.n	8009e22 <ai_array_to_buffer_fmt+0x86>
 8009e14:	484a      	ldr	r0, [pc, #296]	; (8009f40 <.text_32>)
 8009e16:	e004      	b.n	8009e22 <ai_array_to_buffer_fmt+0x86>
 8009e18:	4618      	mov	r0, r3
 8009e1a:	e002      	b.n	8009e22 <ai_array_to_buffer_fmt+0x86>
 8009e1c:	4849      	ldr	r0, [pc, #292]	; (8009f44 <.text_33>)
 8009e1e:	e000      	b.n	8009e22 <ai_array_to_buffer_fmt+0x86>
 8009e20:	4849      	ldr	r0, [pc, #292]	; (8009f48 <.text_34>)
 8009e22:	004a      	lsls	r2, r1, #1
 8009e24:	bf4c      	ite	mi
 8009e26:	f04f 4280 	movmi.w	r2, #1073741824	; 0x40000000
 8009e2a:	2200      	movpl	r2, #0
 8009e2c:	4310      	orrs	r0, r2
 8009e2e:	008a      	lsls	r2, r1, #2
 8009e30:	bf4c      	ite	mi
 8009e32:	f04f 5200 	movmi.w	r2, #536870912	; 0x20000000
 8009e36:	2200      	movpl	r2, #0
 8009e38:	4310      	orrs	r0, r2
 8009e3a:	0109      	lsls	r1, r1, #4
 8009e3c:	bf4c      	ite	mi
 8009e3e:	f04f 6100 	movmi.w	r1, #134217728	; 0x8000000
 8009e42:	2100      	movpl	r1, #0
 8009e44:	4308      	orrs	r0, r1
 8009e46:	4770      	bx	lr

08009e48 <ai_buffer_to_array_fmt>:
 8009e48:	4602      	mov	r2, r0
 8009e4a:	f022 407e 	bic.w	r0, r2, #4261412864	; 0xfe000000
 8009e4e:	3840      	subs	r0, #64	; 0x40
 8009e50:	d022      	beq.n	8009e98 <ai_buffer_to_array_fmt+0x50>
 8009e52:	f44f 2180 	mov.w	r1, #262144	; 0x40000
 8009e56:	1a40      	subs	r0, r0, r1
 8009e58:	d030      	beq.n	8009ebc <ai_buffer_to_array_fmt+0x74>
 8009e5a:	f44f 6180 	mov.w	r1, #1024	; 0x400
 8009e5e:	1a40      	subs	r0, r0, r1
 8009e60:	d01e      	beq.n	8009ea0 <ai_buffer_to_array_fmt+0x58>
 8009e62:	1fc0      	subs	r0, r0, #7
 8009e64:	d02c      	beq.n	8009ec0 <ai_buffer_to_array_fmt+0x78>
 8009e66:	f240 31f9 	movw	r1, #1017	; 0x3f9
 8009e6a:	1a40      	subs	r0, r0, r1
 8009e6c:	d01a      	beq.n	8009ea4 <ai_buffer_to_array_fmt+0x5c>
 8009e6e:	380f      	subs	r0, #15
 8009e70:	d028      	beq.n	8009ec4 <ai_buffer_to_array_fmt+0x7c>
 8009e72:	4929      	ldr	r1, [pc, #164]	; (8009f18 <.text_22>)
 8009e74:	1a40      	subs	r0, r0, r1
 8009e76:	d01b      	beq.n	8009eb0 <ai_buffer_to_array_fmt+0x68>
 8009e78:	f44f 6180 	mov.w	r1, #1024	; 0x400
 8009e7c:	1a40      	subs	r0, r0, r1
 8009e7e:	d013      	beq.n	8009ea8 <ai_buffer_to_array_fmt+0x60>
 8009e80:	1fc0      	subs	r0, r0, #7
 8009e82:	d017      	beq.n	8009eb4 <ai_buffer_to_array_fmt+0x6c>
 8009e84:	f240 31f9 	movw	r1, #1017	; 0x3f9
 8009e88:	1a40      	subs	r0, r0, r1
 8009e8a:	d00f      	beq.n	8009eac <ai_buffer_to_array_fmt+0x64>
 8009e8c:	380f      	subs	r0, #15
 8009e8e:	d013      	beq.n	8009eb8 <ai_buffer_to_array_fmt+0x70>
 8009e90:	4922      	ldr	r1, [pc, #136]	; (8009f1c <.text_23>)
 8009e92:	1a40      	subs	r0, r0, r1
 8009e94:	d002      	beq.n	8009e9c <ai_buffer_to_array_fmt+0x54>
 8009e96:	e017      	b.n	8009ec8 <ai_buffer_to_array_fmt+0x80>
 8009e98:	2040      	movs	r0, #64	; 0x40
 8009e9a:	e01f      	b.n	8009edc <ai_buffer_to_array_fmt+0x94>
 8009e9c:	4822      	ldr	r0, [pc, #136]	; (8009f28 <.text_26>)
 8009e9e:	e01d      	b.n	8009edc <ai_buffer_to_array_fmt+0x94>
 8009ea0:	4822      	ldr	r0, [pc, #136]	; (8009f2c <.text_27>)
 8009ea2:	e01b      	b.n	8009edc <ai_buffer_to_array_fmt+0x94>
 8009ea4:	4822      	ldr	r0, [pc, #136]	; (8009f30 <.text_28>)
 8009ea6:	e019      	b.n	8009edc <ai_buffer_to_array_fmt+0x94>
 8009ea8:	4822      	ldr	r0, [pc, #136]	; (8009f34 <.text_29>)
 8009eaa:	e017      	b.n	8009edc <ai_buffer_to_array_fmt+0x94>
 8009eac:	4822      	ldr	r0, [pc, #136]	; (8009f38 <.text_30>)
 8009eae:	e015      	b.n	8009edc <ai_buffer_to_array_fmt+0x94>
 8009eb0:	4817      	ldr	r0, [pc, #92]	; (8009f10 <.text_20>)
 8009eb2:	e013      	b.n	8009edc <ai_buffer_to_array_fmt+0x94>
 8009eb4:	4821      	ldr	r0, [pc, #132]	; (8009f3c <.text_31>)
 8009eb6:	e011      	b.n	8009edc <ai_buffer_to_array_fmt+0x94>
 8009eb8:	4821      	ldr	r0, [pc, #132]	; (8009f40 <.text_32>)
 8009eba:	e00f      	b.n	8009edc <ai_buffer_to_array_fmt+0x94>
 8009ebc:	4813      	ldr	r0, [pc, #76]	; (8009f0c <.text_19>)
 8009ebe:	e00d      	b.n	8009edc <ai_buffer_to_array_fmt+0x94>
 8009ec0:	4820      	ldr	r0, [pc, #128]	; (8009f44 <.text_33>)
 8009ec2:	e00b      	b.n	8009edc <ai_buffer_to_array_fmt+0x94>
 8009ec4:	4820      	ldr	r0, [pc, #128]	; (8009f48 <.text_34>)
 8009ec6:	e009      	b.n	8009edc <ai_buffer_to_array_fmt+0x94>
 8009ec8:	f3c2 51c0 	ubfx	r1, r2, #23, #1
 8009ecc:	f3c2 000d 	ubfx	r0, r2, #0, #14
 8009ed0:	2900      	cmp	r1, #0
 8009ed2:	bf14      	ite	ne
 8009ed4:	f440 0004 	orrne.w	r0, r0, #8650752	; 0x840000
 8009ed8:	f440 2080 	orreq.w	r0, r0, #262144	; 0x40000
 8009edc:	0051      	lsls	r1, r2, #1
 8009ede:	bf48      	it	mi
 8009ee0:	f040 4080 	orrmi.w	r0, r0, #1073741824	; 0x40000000
 8009ee4:	0091      	lsls	r1, r2, #2
 8009ee6:	bf48      	it	mi
 8009ee8:	f040 5000 	orrmi.w	r0, r0, #536870912	; 0x20000000
 8009eec:	0111      	lsls	r1, r2, #4
 8009eee:	bf48      	it	mi
 8009ef0:	f040 6000 	orrmi.w	r0, r0, #134217728	; 0x8000000
 8009ef4:	4770      	bx	lr
	...

08009ef8 <.text_14>:
 8009ef8:	00000000 	.word	0x00000000

08009efc <.text_15>:
 8009efc:	002be80f 	.word	0x002be80f

08009f00 <.text_16>:
 8009f00:	003bf7f1 	.word	0x003bf7f1

08009f04 <.text_17>:
 8009f04:	00b9fff1 	.word	0x00b9fff1

08009f08 <.text_18>:
 8009f08:	004df000 	.word	0x004df000

08009f0c <.text_19>:
 8009f0c:	00040040 	.word	0x00040040

08009f10 <.text_20>:
 8009f10:	00840040 	.word	0x00840040

08009f14 <.text_21>:
 8009f14:	08041748 	.word	0x08041748

08009f18 <.text_22>:
 8009f18:	007ff7f1 	.word	0x007ff7f1

08009f1c <.text_23>:
 8009f1c:	00fe07f1 	.word	0x00fe07f1

08009f20 <.text_24>:
 8009f20:	080417b8 	.word	0x080417b8

08009f24 <.text_25>:
 8009f24:	00803fff 	.word	0x00803fff

08009f28 <.text_26>:
 8009f28:	01821040 	.word	0x01821040

08009f2c <.text_27>:
 8009f2c:	00040440 	.word	0x00040440

08009f30 <.text_28>:
 8009f30:	00040840 	.word	0x00040840

08009f34 <.text_29>:
 8009f34:	00840440 	.word	0x00840440

08009f38 <.text_30>:
 8009f38:	00840840 	.word	0x00840840

08009f3c <.text_31>:
 8009f3c:	00840447 	.word	0x00840447

08009f40 <.text_32>:
 8009f40:	0084084f 	.word	0x0084084f

08009f44 <.text_33>:
 8009f44:	00040447 	.word	0x00040447

08009f48 <.text_34>:
 8009f48:	0004084f 	.word	0x0004084f

08009f4c <ai_array_get_byte_size>:
 8009f4c:	b909      	cbnz	r1, 8009f52 <ai_array_get_byte_size+0x6>
 8009f4e:	2000      	movs	r0, #0
 8009f50:	4770      	bx	lr
 8009f52:	11c2      	asrs	r2, r0, #7
 8009f54:	f002 027f 	and.w	r2, r2, #127	; 0x7f
 8009f58:	f3c0 3382 	ubfx	r3, r0, #14, #3
 8009f5c:	189b      	adds	r3, r3, r2
 8009f5e:	4359      	muls	r1, r3
 8009f60:	1dc9      	adds	r1, r1, #7
 8009f62:	08c9      	lsrs	r1, r1, #3
 8009f64:	1543      	asrs	r3, r0, #21
 8009f66:	00c9      	lsls	r1, r1, #3
 8009f68:	f003 0303 	and.w	r3, r3, #3
 8009f6c:	ea4f 4c60 	mov.w	ip, r0, asr #17
 8009f70:	40d9      	lsrs	r1, r3
 8009f72:	f00c 0c0f 	and.w	ip, ip, #15
 8009f76:	f1bc 0f04 	cmp.w	ip, #4
 8009f7a:	d00a      	beq.n	8009f92 <ai_array_get_byte_size+0x46>
 8009f7c:	f1bc 0f08 	cmp.w	ip, #8
 8009f80:	bf02      	ittt	eq
 8009f82:	f3c0 3082 	ubfxeq	r0, r0, #14, #3
 8009f86:	1882      	addeq	r2, r0, r2
 8009f88:	eb01 2102 	addeq.w	r1, r1, r2, lsl #8
 8009f8c:	1dc9      	adds	r1, r1, #7
 8009f8e:	08c8      	lsrs	r0, r1, #3
 8009f90:	4770      	bx	lr
 8009f92:	f3c0 3082 	ubfx	r0, r0, #14, #3
 8009f96:	1882      	adds	r2, r0, r2
 8009f98:	eb01 1102 	add.w	r1, r1, r2, lsl #4
 8009f9c:	1dc9      	adds	r1, r1, #7
 8009f9e:	08c8      	lsrs	r0, r1, #3
 8009fa0:	4770      	bx	lr

08009fa2 <ai_array_get_data_byte_size>:
 8009fa2:	b909      	cbnz	r1, 8009fa8 <ai_array_get_data_byte_size+0x6>
 8009fa4:	2000      	movs	r0, #0
 8009fa6:	4770      	bx	lr
 8009fa8:	11c2      	asrs	r2, r0, #7
 8009faa:	f002 027f 	and.w	r2, r2, #127	; 0x7f
 8009fae:	f3c0 3382 	ubfx	r3, r0, #14, #3
 8009fb2:	189a      	adds	r2, r3, r2
 8009fb4:	4351      	muls	r1, r2
 8009fb6:	1dc9      	adds	r1, r1, #7
 8009fb8:	08c9      	lsrs	r1, r1, #3
 8009fba:	1540      	asrs	r0, r0, #21
 8009fbc:	00c9      	lsls	r1, r1, #3
 8009fbe:	f000 0003 	and.w	r0, r0, #3
 8009fc2:	40c1      	lsrs	r1, r0
 8009fc4:	1dc9      	adds	r1, r1, #7
 8009fc6:	08c8      	lsrs	r0, r1, #3
 8009fc8:	4770      	bx	lr

08009fca <ai_array_get_elems_from_size>:
 8009fca:	b909      	cbnz	r1, 8009fd0 <ai_array_get_elems_from_size+0x6>
 8009fcc:	2000      	movs	r0, #0
 8009fce:	4770      	bx	lr
 8009fd0:	1442      	asrs	r2, r0, #17
 8009fd2:	00c9      	lsls	r1, r1, #3
 8009fd4:	f002 020f 	and.w	r2, r2, #15
 8009fd8:	2a04      	cmp	r2, #4
 8009fda:	d002      	beq.n	8009fe2 <ai_array_get_elems_from_size+0x18>
 8009fdc:	2a08      	cmp	r2, #8
 8009fde:	d009      	beq.n	8009ff4 <ai_array_get_elems_from_size+0x2a>
 8009fe0:	e010      	b.n	800a004 <ai_array_get_elems_from_size+0x3a>
 8009fe2:	11c3      	asrs	r3, r0, #7
 8009fe4:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 8009fe8:	f3c0 3282 	ubfx	r2, r0, #14, #3
 8009fec:	18d2      	adds	r2, r2, r3
 8009fee:	eba1 1102 	sub.w	r1, r1, r2, lsl #4
 8009ff2:	e007      	b.n	800a004 <ai_array_get_elems_from_size+0x3a>
 8009ff4:	11c2      	asrs	r2, r0, #7
 8009ff6:	f002 027f 	and.w	r2, r2, #127	; 0x7f
 8009ffa:	f3c0 3382 	ubfx	r3, r0, #14, #3
 8009ffe:	189a      	adds	r2, r3, r2
 800a000:	eba1 2102 	sub.w	r1, r1, r2, lsl #8
 800a004:	1542      	asrs	r2, r0, #21
 800a006:	f002 0203 	and.w	r2, r2, #3
 800a00a:	4091      	lsls	r1, r2
 800a00c:	1dc9      	adds	r1, r1, #7
 800a00e:	11c2      	asrs	r2, r0, #7
 800a010:	08c9      	lsrs	r1, r1, #3
 800a012:	f002 027f 	and.w	r2, r2, #127	; 0x7f
 800a016:	f3c0 3082 	ubfx	r0, r0, #14, #3
 800a01a:	00c9      	lsls	r1, r1, #3
 800a01c:	1880      	adds	r0, r0, r2
 800a01e:	fbb1 f0f0 	udiv	r0, r1, r0
 800a022:	4770      	bx	lr

0800a024 <.text_38>:
 800a024:	5f544d46 	.word	0x5f544d46
 800a028:	454e4f4e 	.word	0x454e4f4e
 800a02c:	00          	.byte	0x00
 800a02d:	00          	.byte	0x00
	...

0800a030 <.text_39>:
 800a030:	5f544d46 	.word	0x5f544d46
 800a034:	414f4c46 	.word	0x414f4c46
 800a038:	0054      	.short	0x0054
	...

0800a03c <.text_40>:
 800a03c:	5f544d46 	.word	0x5f544d46
 800a040:	414f4c46 	.word	0x414f4c46
 800a044:	00343654 	.word	0x00343654

0800a048 <.text_41>:
 800a048:	5f544d46 	.word	0x5f544d46
 800a04c:	414f4c46 	.word	0x414f4c46
 800a050:	00363154 	.word	0x00363154

0800a054 <.text_42>:
 800a054:	5f544d46 	.word	0x5f544d46
 800a058:	00003855 	.word	0x00003855

0800a05c <.text_43>:
 800a05c:	5f544d46 	.word	0x5f544d46
 800a060:	00363155 	.word	0x00363155

0800a064 <.text_44>:
 800a064:	5f544d46 	.word	0x5f544d46
 800a068:	00323355 	.word	0x00323355

0800a06c <.text_45>:
 800a06c:	5f544d46 	.word	0x5f544d46
 800a070:	00343655 	.word	0x00343655

0800a074 <.text_46>:
 800a074:	5f544d46 	.word	0x5f544d46
 800a078:	00003455 	.word	0x00003455

0800a07c <.text_47>:
 800a07c:	5f544d46 	.word	0x5f544d46
 800a080:	00003853 	.word	0x00003853

0800a084 <.text_48>:
 800a084:	5f544d46 	.word	0x5f544d46
 800a088:	00363153 	.word	0x00363153

0800a08c <.text_49>:
 800a08c:	5f544d46 	.word	0x5f544d46
 800a090:	00323353 	.word	0x00323353

0800a094 <.text_50>:
 800a094:	5f544d46 	.word	0x5f544d46
 800a098:	00343653 	.word	0x00343653

0800a09c <.text_51>:
 800a09c:	5f544d46 	.word	0x5f544d46
 800a0a0:	00003453 	.word	0x00003453

0800a0a4 <.text_52>:
 800a0a4:	5f544d46 	.word	0x5f544d46
 800a0a8:	0051      	.short	0x0051
	...

0800a0ac <.text_53>:
 800a0ac:	5f544d46 	.word	0x5f544d46
 800a0b0:	00003751 	.word	0x00003751

0800a0b4 <.text_54>:
 800a0b4:	5f544d46 	.word	0x5f544d46
 800a0b8:	00353151 	.word	0x00353151

0800a0bc <.text_55>:
 800a0bc:	5f544d46 	.word	0x5f544d46
 800a0c0:	00313351 	.word	0x00313351

0800a0c4 <.text_56>:
 800a0c4:	5f544d46 	.word	0x5f544d46
 800a0c8:	00005155 	.word	0x00005155

0800a0cc <.text_57>:
 800a0cc:	5f544d46 	.word	0x5f544d46
 800a0d0:	00375155 	.word	0x00375155

0800a0d4 <.text_58>:
 800a0d4:	5f544d46 	.word	0x5f544d46
 800a0d8:	35315155 	.word	0x35315155
 800a0dc:	00          	.byte	0x00
 800a0dd:	00          	.byte	0x00
	...

0800a0e0 <.text_59>:
 800a0e0:	5f544d46 	.word	0x5f544d46
 800a0e4:	31335155 	.word	0x31335155
 800a0e8:	00          	.byte	0x00
 800a0e9:	00          	.byte	0x00
	...

0800a0ec <.text_60>:
 800a0ec:	5f544d46 	.word	0x5f544d46
 800a0f0:	3454554c 	.word	0x3454554c
 800a0f4:	4f4c465f 	.word	0x4f4c465f
 800a0f8:	00005441 	.word	0x00005441

0800a0fc <.text_61>:
 800a0fc:	5f544d46 	.word	0x5f544d46
 800a100:	3854554c 	.word	0x3854554c
 800a104:	4f4c465f 	.word	0x4f4c465f
 800a108:	00005441 	.word	0x00005441

0800a10c <.text_62>:
 800a10c:	5f544d46 	.word	0x5f544d46
 800a110:	3454554c 	.word	0x3454554c
 800a114:	3531515f 	.word	0x3531515f
 800a118:	00          	.byte	0x00
 800a119:	00          	.byte	0x00
	...

0800a11c <.text_63>:
 800a11c:	5f544d46 	.word	0x5f544d46
 800a120:	3854554c 	.word	0x3854554c
 800a124:	3531515f 	.word	0x3531515f
 800a128:	00          	.byte	0x00
 800a129:	00          	.byte	0x00
	...

0800a12c <.text_64>:
 800a12c:	5f544d46 	.word	0x5f544d46
 800a130:	3454554c 	.word	0x3454554c
 800a134:	3151555f 	.word	0x3151555f
 800a138:	0035      	.short	0x0035
	...

0800a13c <.text_65>:
 800a13c:	5f544d46 	.word	0x5f544d46
 800a140:	3854554c 	.word	0x3854554c
 800a144:	3151555f 	.word	0x3151555f
 800a148:	0035      	.short	0x0035
	...

0800a14c <.text_66>:
 800a14c:	415f4941 	.word	0x415f4941
 800a150:	59415252 	.word	0x59415252
 800a154:	524f465f 	.word	0x524f465f
 800a158:	5f54414d 	.word	0x5f54414d
 800a15c:	454e4f4e 	.word	0x454e4f4e
 800a160:	00          	.byte	0x00
 800a161:	00          	.byte	0x00
	...

0800a164 <.text_67>:
 800a164:	415f4941 	.word	0x415f4941
 800a168:	59415252 	.word	0x59415252
 800a16c:	524f465f 	.word	0x524f465f
 800a170:	5f54414d 	.word	0x5f54414d
 800a174:	0051      	.short	0x0051
	...

0800a178 <.text_68>:
 800a178:	415f4941 	.word	0x415f4941
 800a17c:	59415252 	.word	0x59415252
 800a180:	524f465f 	.word	0x524f465f
 800a184:	5f54414d 	.word	0x5f54414d
 800a188:	00005155 	.word	0x00005155

0800a18c <.text_69>:
 800a18c:	425f4941 	.word	0x425f4941
 800a190:	45464655 	.word	0x45464655
 800a194:	4f465f52 	.word	0x4f465f52
 800a198:	54414d52 	.word	0x54414d52
 800a19c:	4e4f4e5f 	.word	0x4e4f4e5f
 800a1a0:	0045      	.short	0x0045
	...

0800a1a4 <.text_70>:
 800a1a4:	425f4941 	.word	0x425f4941
 800a1a8:	45464655 	.word	0x45464655
 800a1ac:	4f465f52 	.word	0x4f465f52
 800a1b0:	54414d52 	.word	0x54414d52
 800a1b4:	0000515f 	.word	0x0000515f

0800a1b8 <.text_71>:
 800a1b8:	425f4941 	.word	0x425f4941
 800a1bc:	45464655 	.word	0x45464655
 800a1c0:	4f465f52 	.word	0x4f465f52
 800a1c4:	54414d52 	.word	0x54414d52
 800a1c8:	0051555f 	.word	0x0051555f

0800a1cc <ai_math_dot_array>:
 800a1cc:	b530      	push	{r4, r5, lr}
 800a1ce:	4604      	mov	r4, r0
 800a1d0:	4608      	mov	r0, r1
 800a1d2:	b081      	sub	sp, #4
 800a1d4:	4611      	mov	r1, r2
 800a1d6:	461a      	mov	r2, r3
 800a1d8:	2500      	movs	r5, #0
 800a1da:	9500      	str	r5, [sp, #0]
 800a1dc:	466b      	mov	r3, sp
 800a1de:	f01c fc49 	bl	8026a74 <arm_dot_prod_f32>
 800a1e2:	ed94 0a00 	vldr	s0, [r4]
 800a1e6:	eddd 0a00 	vldr	s1, [sp]
 800a1ea:	ee70 0a20 	vadd.f32	s1, s0, s1
 800a1ee:	edc4 0a00 	vstr	s1, [r4]
 800a1f2:	b001      	add	sp, #4
 800a1f4:	bd30      	pop	{r4, r5, pc}
	...

0800a1f8 <ai_math_sqrt>:
 800a1f8:	eef0 0a40 	vmov.f32	s1, s0
 800a1fc:	eef5 0a40 	vcmp.f32	s1, #0.0
 800a200:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800a204:	ed9f 0a29 	vldr	s0, [pc, #164]	; 800a2ac <.text_13>
 800a208:	db01      	blt.n	800a20e <ai_math_sqrt+0x16>
 800a20a:	eeb1 0ae0 	vsqrt.f32	s0, s1
 800a20e:	4770      	bx	lr

0800a210 <ai_math_exp>:
 800a210:	f020 bf34 	b.w	802b07c <expf>

0800a214 <ai_math_pow>:
 800a214:	f020 bfe4 	b.w	802b1e0 <powf>

0800a218 <ai_math_tanh>:
 800a218:	f020 be0e 	b.w	802ae38 <tanhf>

0800a21c <ai_math_cosh>:
 800a21c:	f020 bf06 	b.w	802b02c <coshf>

0800a220 <ai_math_relu>:
 800a220:	eeb5 0a40 	vcmp.f32	s0, #0.0
 800a224:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800a228:	bf48      	it	mi
 800a22a:	ed9f 0a20 	vldrmi	s0, [pc, #128]	; 800a2ac <.text_13>
 800a22e:	4770      	bx	lr

0800a230 <ai_math_prelu>:
 800a230:	eeb5 0a40 	vcmp.f32	s0, #0.0
 800a234:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800a238:	bf48      	it	mi
 800a23a:	ee20 0a20 	vmulmi.f32	s0, s0, s1
 800a23e:	4770      	bx	lr

0800a240 <ai_math_sigmoid>:
 800a240:	b500      	push	{lr}
 800a242:	b081      	sub	sp, #4
 800a244:	eeb1 0a40 	vneg.f32	s0, s0
 800a248:	f020 ff18 	bl	802b07c <expf>
 800a24c:	eef7 0a00 	vmov.f32	s1, #112	; 0x3f800000  1.0
 800a250:	ee30 0a20 	vadd.f32	s0, s0, s1
 800a254:	eeb7 1a00 	vmov.f32	s2, #112	; 0x3f800000  1.0
 800a258:	ee81 0a00 	vdiv.f32	s0, s2, s0
 800a25c:	b001      	add	sp, #4
 800a25e:	bd00      	pop	{pc}

0800a260 <ai_math_hard_sigmoid>:
 800a260:	eef0 0a40 	vmov.f32	s1, s0
 800a264:	ed9f 1a12 	vldr	s2, [pc, #72]	; 800a2b0 <.text_14>
 800a268:	eeb6 0a00 	vmov.f32	s0, #96	; 0x3f000000  0.5
 800a26c:	ee00 0a81 	vmla.f32	s0, s1, s2
 800a270:	eddf 0a10 	vldr	s1, [pc, #64]	; 800a2b4 <.text_15>
 800a274:	eeb4 0a60 	vcmp.f32	s0, s1
 800a278:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800a27c:	da07      	bge.n	800a28e <ai_math_hard_sigmoid+0x2e>
 800a27e:	eeb5 0a40 	vcmp.f32	s0, #0.0
 800a282:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800a286:	d504      	bpl.n	800a292 <ai_math_hard_sigmoid+0x32>
 800a288:	ed9f 0a08 	vldr	s0, [pc, #32]	; 800a2ac <.text_13>
 800a28c:	4770      	bx	lr
 800a28e:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
 800a292:	4770      	bx	lr

0800a294 <ai_math_sign>:
 800a294:	eeb5 0a40 	vcmp.f32	s0, #0.0
 800a298:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800a29c:	bfcc      	ite	gt
 800a29e:	ed9f 0a06 	vldrgt	s0, [pc, #24]	; 800a2b8 <.text_16>
 800a2a2:	ed9f 0a06 	vldrle	s0, [pc, #24]	; 800a2bc <.text_17>
 800a2a6:	eeb8 0ac0 	vcvt.f32.s32	s0, s0
 800a2aa:	4770      	bx	lr

0800a2ac <.text_13>:
 800a2ac:	00000000 	.word	0x00000000

0800a2b0 <.text_14>:
 800a2b0:	3e4ccccd 	.word	0x3e4ccccd

0800a2b4 <.text_15>:
 800a2b4:	3f800001 	.word	0x3f800001

0800a2b8 <.text_16>:
 800a2b8:	00000001 	.word	0x00000001

0800a2bc <.text_17>:
 800a2bc:	ffffffff 	.word	0xffffffff

0800a2c0 <ai_div>:
 800a2c0:	ee80 0a20 	vdiv.f32	s0, s0, s1
 800a2c4:	4770      	bx	lr

0800a2c6 <ai_floor_div>:
 800a2c6:	ee80 0a20 	vdiv.f32	s0, s0, s1
 800a2ca:	f020 bbdf 	b.w	802aa8c <floorf>

0800a2ce <ai_floor_mod>:
 800a2ce:	f020 bf0b 	b.w	802b0e8 <fmodf>

0800a2d2 <ai_max>:
 800a2d2:	eef4 0a40 	vcmp.f32	s1, s0
 800a2d6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800a2da:	bf58      	it	pl
 800a2dc:	eeb0 0a60 	vmovpl.f32	s0, s1
 800a2e0:	4770      	bx	lr

0800a2e2 <ai_min>:
 800a2e2:	eeb4 0a60 	vcmp.f32	s0, s1
 800a2e6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800a2ea:	bf58      	it	pl
 800a2ec:	eeb0 0a60 	vmovpl.f32	s0, s1
 800a2f0:	4770      	bx	lr

0800a2f2 <ai_mul>:
 800a2f2:	ee20 0a20 	vmul.f32	s0, s0, s1
 800a2f6:	4770      	bx	lr

0800a2f8 <ai_sub>:
 800a2f8:	ee30 0a60 	vsub.f32	s0, s0, s1
 800a2fc:	4770      	bx	lr

0800a2fe <ai_sum>:
 800a2fe:	ee30 0a20 	vadd.f32	s0, s0, s1
 800a302:	4770      	bx	lr

0800a304 <arm_bitreversal_32>:
 800a304:	1c4b      	adds	r3, r1, #1
 800a306:	2b01      	cmp	r3, #1
 800a308:	bf98      	it	ls
 800a30a:	4770      	bxls	lr
 800a30c:	e92d 03f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9}
 800a310:	1c91      	adds	r1, r2, #2
 800a312:	089b      	lsrs	r3, r3, #2

0800a314 <arm_bitreversal_32_0>:
 800a314:	f8b1 8004 	ldrh.w	r8, [r1, #4]
 800a318:	f8b1 9002 	ldrh.w	r9, [r1, #2]
 800a31c:	880a      	ldrh	r2, [r1, #0]
 800a31e:	f831 cc02 	ldrh.w	ip, [r1, #-2]
 800a322:	4480      	add	r8, r0
 800a324:	4481      	add	r9, r0
 800a326:	4402      	add	r2, r0
 800a328:	4484      	add	ip, r0
 800a32a:	f8d9 7000 	ldr.w	r7, [r9]
 800a32e:	f8d8 6000 	ldr.w	r6, [r8]
 800a332:	6815      	ldr	r5, [r2, #0]
 800a334:	f8dc 4000 	ldr.w	r4, [ip]
 800a338:	f8c9 6000 	str.w	r6, [r9]
 800a33c:	f8c8 7000 	str.w	r7, [r8]
 800a340:	f8cc 5000 	str.w	r5, [ip]
 800a344:	6014      	str	r4, [r2, #0]
 800a346:	f8d9 7004 	ldr.w	r7, [r9, #4]
 800a34a:	f8d8 6004 	ldr.w	r6, [r8, #4]
 800a34e:	6855      	ldr	r5, [r2, #4]
 800a350:	f8dc 4004 	ldr.w	r4, [ip, #4]
 800a354:	f8c9 6004 	str.w	r6, [r9, #4]
 800a358:	f8c8 7004 	str.w	r7, [r8, #4]
 800a35c:	f8cc 5004 	str.w	r5, [ip, #4]
 800a360:	6054      	str	r4, [r2, #4]
 800a362:	3108      	adds	r1, #8
 800a364:	3b01      	subs	r3, #1
 800a366:	d1d5      	bne.n	800a314 <arm_bitreversal_32_0>
 800a368:	e8bd 03f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9}
 800a36c:	4770      	bx	lr

0800a36e <arm_bitreversal_16>:
 800a36e:	1c4b      	adds	r3, r1, #1
 800a370:	2b01      	cmp	r3, #1
 800a372:	bf98      	it	ls
 800a374:	4770      	bxls	lr
 800a376:	e92d 03f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9}
 800a37a:	1c91      	adds	r1, r2, #2
 800a37c:	089b      	lsrs	r3, r3, #2

0800a37e <arm_bitreversal_16_0>:
 800a37e:	f8b1 8004 	ldrh.w	r8, [r1, #4]
 800a382:	f8b1 9002 	ldrh.w	r9, [r1, #2]
 800a386:	880a      	ldrh	r2, [r1, #0]
 800a388:	f831 cc02 	ldrh.w	ip, [r1, #-2]
 800a38c:	eb00 0858 	add.w	r8, r0, r8, lsr #1
 800a390:	eb00 0959 	add.w	r9, r0, r9, lsr #1
 800a394:	eb00 0252 	add.w	r2, r0, r2, lsr #1
 800a398:	eb00 0c5c 	add.w	ip, r0, ip, lsr #1
 800a39c:	f8d9 7000 	ldr.w	r7, [r9]
 800a3a0:	f8d8 6000 	ldr.w	r6, [r8]
 800a3a4:	6815      	ldr	r5, [r2, #0]
 800a3a6:	f8dc 4000 	ldr.w	r4, [ip]
 800a3aa:	f8c9 6000 	str.w	r6, [r9]
 800a3ae:	f8c8 7000 	str.w	r7, [r8]
 800a3b2:	f8cc 5000 	str.w	r5, [ip]
 800a3b6:	6014      	str	r4, [r2, #0]
 800a3b8:	3108      	adds	r1, #8
 800a3ba:	3b01      	subs	r3, #1
 800a3bc:	d1df      	bne.n	800a37e <arm_bitreversal_16_0>
 800a3be:	e8bd 03f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9}
 800a3c2:	4770      	bx	lr

0800a3c4 <__aeabi_memset>:
 800a3c4:	b470      	push	{r4, r5, r6}
 800a3c6:	0784      	lsls	r4, r0, #30
 800a3c8:	d046      	beq.n	800a458 <__aeabi_memset+0x94>
 800a3ca:	1e4c      	subs	r4, r1, #1
 800a3cc:	2900      	cmp	r1, #0
 800a3ce:	d041      	beq.n	800a454 <__aeabi_memset+0x90>
 800a3d0:	b2d5      	uxtb	r5, r2
 800a3d2:	4603      	mov	r3, r0
 800a3d4:	e002      	b.n	800a3dc <__aeabi_memset+0x18>
 800a3d6:	1e61      	subs	r1, r4, #1
 800a3d8:	b3e4      	cbz	r4, 800a454 <__aeabi_memset+0x90>
 800a3da:	460c      	mov	r4, r1
 800a3dc:	f803 5b01 	strb.w	r5, [r3], #1
 800a3e0:	0799      	lsls	r1, r3, #30
 800a3e2:	d1f8      	bne.n	800a3d6 <__aeabi_memset+0x12>
 800a3e4:	2c03      	cmp	r4, #3
 800a3e6:	d92e      	bls.n	800a446 <__aeabi_memset+0x82>
 800a3e8:	b2d5      	uxtb	r5, r2
 800a3ea:	ea45 2505 	orr.w	r5, r5, r5, lsl #8
 800a3ee:	2c0f      	cmp	r4, #15
 800a3f0:	ea45 4505 	orr.w	r5, r5, r5, lsl #16
 800a3f4:	d919      	bls.n	800a42a <__aeabi_memset+0x66>
 800a3f6:	4626      	mov	r6, r4
 800a3f8:	f103 0110 	add.w	r1, r3, #16
 800a3fc:	3e10      	subs	r6, #16
 800a3fe:	2e0f      	cmp	r6, #15
 800a400:	f841 5c10 	str.w	r5, [r1, #-16]
 800a404:	f841 5c0c 	str.w	r5, [r1, #-12]
 800a408:	f841 5c08 	str.w	r5, [r1, #-8]
 800a40c:	f841 5c04 	str.w	r5, [r1, #-4]
 800a410:	f101 0110 	add.w	r1, r1, #16
 800a414:	d8f2      	bhi.n	800a3fc <__aeabi_memset+0x38>
 800a416:	f1a4 0110 	sub.w	r1, r4, #16
 800a41a:	f021 010f 	bic.w	r1, r1, #15
 800a41e:	f004 040f 	and.w	r4, r4, #15
 800a422:	3110      	adds	r1, #16
 800a424:	2c03      	cmp	r4, #3
 800a426:	440b      	add	r3, r1
 800a428:	d90d      	bls.n	800a446 <__aeabi_memset+0x82>
 800a42a:	461e      	mov	r6, r3
 800a42c:	4621      	mov	r1, r4
 800a42e:	3904      	subs	r1, #4
 800a430:	2903      	cmp	r1, #3
 800a432:	f846 5b04 	str.w	r5, [r6], #4
 800a436:	d8fa      	bhi.n	800a42e <__aeabi_memset+0x6a>
 800a438:	1f21      	subs	r1, r4, #4
 800a43a:	f021 0103 	bic.w	r1, r1, #3
 800a43e:	3104      	adds	r1, #4
 800a440:	440b      	add	r3, r1
 800a442:	f004 0403 	and.w	r4, r4, #3
 800a446:	b12c      	cbz	r4, 800a454 <__aeabi_memset+0x90>
 800a448:	b2d2      	uxtb	r2, r2
 800a44a:	441c      	add	r4, r3
 800a44c:	f803 2b01 	strb.w	r2, [r3], #1
 800a450:	42a3      	cmp	r3, r4
 800a452:	d1fb      	bne.n	800a44c <__aeabi_memset+0x88>
 800a454:	bc70      	pop	{r4, r5, r6}
 800a456:	4770      	bx	lr
 800a458:	460c      	mov	r4, r1
 800a45a:	4603      	mov	r3, r0
 800a45c:	e7c2      	b.n	800a3e4 <__aeabi_memset+0x20>

0800a45e <strcmp>:
 800a45e:	f810 2b01 	ldrb.w	r2, [r0], #1
 800a462:	f811 3b01 	ldrb.w	r3, [r1], #1
 800a466:	2a01      	cmp	r2, #1
 800a468:	bf28      	it	cs
 800a46a:	429a      	cmpcs	r2, r3
 800a46c:	d0f7      	beq.n	800a45e <strcmp>
 800a46e:	1ad0      	subs	r0, r2, r3
 800a470:	4770      	bx	lr

0800a472 <strlen>:
 800a472:	4603      	mov	r3, r0
 800a474:	f813 2b01 	ldrb.w	r2, [r3], #1
 800a478:	2a00      	cmp	r2, #0
 800a47a:	d1fb      	bne.n	800a474 <strlen+0x2>
 800a47c:	1a18      	subs	r0, r3, r0
 800a47e:	3801      	subs	r0, #1
 800a480:	4770      	bx	lr
	...

0800a490 <memchr>:
 800a490:	f001 01ff 	and.w	r1, r1, #255	; 0xff
 800a494:	2a10      	cmp	r2, #16
 800a496:	db2b      	blt.n	800a4f0 <memchr+0x60>
 800a498:	f010 0f07 	tst.w	r0, #7
 800a49c:	d008      	beq.n	800a4b0 <memchr+0x20>
 800a49e:	f810 3b01 	ldrb.w	r3, [r0], #1
 800a4a2:	3a01      	subs	r2, #1
 800a4a4:	428b      	cmp	r3, r1
 800a4a6:	d02d      	beq.n	800a504 <memchr+0x74>
 800a4a8:	f010 0f07 	tst.w	r0, #7
 800a4ac:	b342      	cbz	r2, 800a500 <memchr+0x70>
 800a4ae:	d1f6      	bne.n	800a49e <memchr+0xe>
 800a4b0:	b4f0      	push	{r4, r5, r6, r7}
 800a4b2:	ea41 2101 	orr.w	r1, r1, r1, lsl #8
 800a4b6:	ea41 4101 	orr.w	r1, r1, r1, lsl #16
 800a4ba:	f022 0407 	bic.w	r4, r2, #7
 800a4be:	f07f 0700 	mvns.w	r7, #0
 800a4c2:	2300      	movs	r3, #0
 800a4c4:	e8f0 5602 	ldrd	r5, r6, [r0], #8
 800a4c8:	3c08      	subs	r4, #8
 800a4ca:	ea85 0501 	eor.w	r5, r5, r1
 800a4ce:	ea86 0601 	eor.w	r6, r6, r1
 800a4d2:	fa85 f547 	uadd8	r5, r5, r7
 800a4d6:	faa3 f587 	sel	r5, r3, r7
 800a4da:	fa86 f647 	uadd8	r6, r6, r7
 800a4de:	faa5 f687 	sel	r6, r5, r7
 800a4e2:	b98e      	cbnz	r6, 800a508 <memchr+0x78>
 800a4e4:	d1ee      	bne.n	800a4c4 <memchr+0x34>
 800a4e6:	bcf0      	pop	{r4, r5, r6, r7}
 800a4e8:	f001 01ff 	and.w	r1, r1, #255	; 0xff
 800a4ec:	f002 0207 	and.w	r2, r2, #7
 800a4f0:	b132      	cbz	r2, 800a500 <memchr+0x70>
 800a4f2:	f810 3b01 	ldrb.w	r3, [r0], #1
 800a4f6:	3a01      	subs	r2, #1
 800a4f8:	ea83 0301 	eor.w	r3, r3, r1
 800a4fc:	b113      	cbz	r3, 800a504 <memchr+0x74>
 800a4fe:	d1f8      	bne.n	800a4f2 <memchr+0x62>
 800a500:	2000      	movs	r0, #0
 800a502:	4770      	bx	lr
 800a504:	3801      	subs	r0, #1
 800a506:	4770      	bx	lr
 800a508:	2d00      	cmp	r5, #0
 800a50a:	bf06      	itte	eq
 800a50c:	4635      	moveq	r5, r6
 800a50e:	3803      	subeq	r0, #3
 800a510:	3807      	subne	r0, #7
 800a512:	f015 0f01 	tst.w	r5, #1
 800a516:	d107      	bne.n	800a528 <memchr+0x98>
 800a518:	3001      	adds	r0, #1
 800a51a:	f415 7f80 	tst.w	r5, #256	; 0x100
 800a51e:	bf02      	ittt	eq
 800a520:	3001      	addeq	r0, #1
 800a522:	f415 3fc0 	tsteq.w	r5, #98304	; 0x18000
 800a526:	3001      	addeq	r0, #1
 800a528:	bcf0      	pop	{r4, r5, r6, r7}
 800a52a:	3801      	subs	r0, #1
 800a52c:	4770      	bx	lr
 800a52e:	bf00      	nop

0800a530 <__aeabi_drsub>:
 800a530:	f081 4100 	eor.w	r1, r1, #2147483648	; 0x80000000
 800a534:	e002      	b.n	800a53c <__adddf3>
 800a536:	bf00      	nop

0800a538 <__aeabi_dsub>:
 800a538:	f083 4300 	eor.w	r3, r3, #2147483648	; 0x80000000

0800a53c <__adddf3>:
 800a53c:	b530      	push	{r4, r5, lr}
 800a53e:	ea4f 0441 	mov.w	r4, r1, lsl #1
 800a542:	ea4f 0543 	mov.w	r5, r3, lsl #1
 800a546:	ea94 0f05 	teq	r4, r5
 800a54a:	bf08      	it	eq
 800a54c:	ea90 0f02 	teqeq	r0, r2
 800a550:	bf1f      	itttt	ne
 800a552:	ea54 0c00 	orrsne.w	ip, r4, r0
 800a556:	ea55 0c02 	orrsne.w	ip, r5, r2
 800a55a:	ea7f 5c64 	mvnsne.w	ip, r4, asr #21
 800a55e:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
 800a562:	f000 80e2 	beq.w	800a72a <__adddf3+0x1ee>
 800a566:	ea4f 5454 	mov.w	r4, r4, lsr #21
 800a56a:	ebd4 5555 	rsbs	r5, r4, r5, lsr #21
 800a56e:	bfb8      	it	lt
 800a570:	426d      	neglt	r5, r5
 800a572:	dd0c      	ble.n	800a58e <__adddf3+0x52>
 800a574:	442c      	add	r4, r5
 800a576:	ea80 0202 	eor.w	r2, r0, r2
 800a57a:	ea81 0303 	eor.w	r3, r1, r3
 800a57e:	ea82 0000 	eor.w	r0, r2, r0
 800a582:	ea83 0101 	eor.w	r1, r3, r1
 800a586:	ea80 0202 	eor.w	r2, r0, r2
 800a58a:	ea81 0303 	eor.w	r3, r1, r3
 800a58e:	2d36      	cmp	r5, #54	; 0x36
 800a590:	bf88      	it	hi
 800a592:	bd30      	pophi	{r4, r5, pc}
 800a594:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
 800a598:	ea4f 3101 	mov.w	r1, r1, lsl #12
 800a59c:	f44f 1c80 	mov.w	ip, #1048576	; 0x100000
 800a5a0:	ea4c 3111 	orr.w	r1, ip, r1, lsr #12
 800a5a4:	d002      	beq.n	800a5ac <__adddf3+0x70>
 800a5a6:	4240      	negs	r0, r0
 800a5a8:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 800a5ac:	f013 4f00 	tst.w	r3, #2147483648	; 0x80000000
 800a5b0:	ea4f 3303 	mov.w	r3, r3, lsl #12
 800a5b4:	ea4c 3313 	orr.w	r3, ip, r3, lsr #12
 800a5b8:	d002      	beq.n	800a5c0 <__adddf3+0x84>
 800a5ba:	4252      	negs	r2, r2
 800a5bc:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
 800a5c0:	ea94 0f05 	teq	r4, r5
 800a5c4:	f000 80a7 	beq.w	800a716 <__adddf3+0x1da>
 800a5c8:	f1a4 0401 	sub.w	r4, r4, #1
 800a5cc:	f1d5 0e20 	rsbs	lr, r5, #32
 800a5d0:	db0d      	blt.n	800a5ee <__adddf3+0xb2>
 800a5d2:	fa02 fc0e 	lsl.w	ip, r2, lr
 800a5d6:	fa22 f205 	lsr.w	r2, r2, r5
 800a5da:	1880      	adds	r0, r0, r2
 800a5dc:	f141 0100 	adc.w	r1, r1, #0
 800a5e0:	fa03 f20e 	lsl.w	r2, r3, lr
 800a5e4:	1880      	adds	r0, r0, r2
 800a5e6:	fa43 f305 	asr.w	r3, r3, r5
 800a5ea:	4159      	adcs	r1, r3
 800a5ec:	e00e      	b.n	800a60c <__adddf3+0xd0>
 800a5ee:	f1a5 0520 	sub.w	r5, r5, #32
 800a5f2:	f10e 0e20 	add.w	lr, lr, #32
 800a5f6:	2a01      	cmp	r2, #1
 800a5f8:	fa03 fc0e 	lsl.w	ip, r3, lr
 800a5fc:	bf28      	it	cs
 800a5fe:	f04c 0c02 	orrcs.w	ip, ip, #2
 800a602:	fa43 f305 	asr.w	r3, r3, r5
 800a606:	18c0      	adds	r0, r0, r3
 800a608:	eb51 71e3 	adcs.w	r1, r1, r3, asr #31
 800a60c:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
 800a610:	d507      	bpl.n	800a622 <__adddf3+0xe6>
 800a612:	f04f 0e00 	mov.w	lr, #0
 800a616:	f1dc 0c00 	rsbs	ip, ip, #0
 800a61a:	eb7e 0000 	sbcs.w	r0, lr, r0
 800a61e:	eb6e 0101 	sbc.w	r1, lr, r1
 800a622:	f5b1 1f80 	cmp.w	r1, #1048576	; 0x100000
 800a626:	d31b      	bcc.n	800a660 <__adddf3+0x124>
 800a628:	f5b1 1f00 	cmp.w	r1, #2097152	; 0x200000
 800a62c:	d30c      	bcc.n	800a648 <__adddf3+0x10c>
 800a62e:	0849      	lsrs	r1, r1, #1
 800a630:	ea5f 0030 	movs.w	r0, r0, rrx
 800a634:	ea4f 0c3c 	mov.w	ip, ip, rrx
 800a638:	f104 0401 	add.w	r4, r4, #1
 800a63c:	ea4f 5244 	mov.w	r2, r4, lsl #21
 800a640:	f512 0f80 	cmn.w	r2, #4194304	; 0x400000
 800a644:	f080 809a 	bcs.w	800a77c <__adddf3+0x240>
 800a648:	f1bc 4f00 	cmp.w	ip, #2147483648	; 0x80000000
 800a64c:	bf08      	it	eq
 800a64e:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
 800a652:	f150 0000 	adcs.w	r0, r0, #0
 800a656:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 800a65a:	ea41 0105 	orr.w	r1, r1, r5
 800a65e:	bd30      	pop	{r4, r5, pc}
 800a660:	ea5f 0c4c 	movs.w	ip, ip, lsl #1
 800a664:	4140      	adcs	r0, r0
 800a666:	eb41 0101 	adc.w	r1, r1, r1
 800a66a:	3c01      	subs	r4, #1
 800a66c:	bf28      	it	cs
 800a66e:	f5b1 1f80 	cmpcs.w	r1, #1048576	; 0x100000
 800a672:	d2e9      	bcs.n	800a648 <__adddf3+0x10c>
 800a674:	f091 0f00 	teq	r1, #0
 800a678:	bf04      	itt	eq
 800a67a:	4601      	moveq	r1, r0
 800a67c:	2000      	moveq	r0, #0
 800a67e:	fab1 f381 	clz	r3, r1
 800a682:	bf08      	it	eq
 800a684:	3320      	addeq	r3, #32
 800a686:	f1a3 030b 	sub.w	r3, r3, #11
 800a68a:	f1b3 0220 	subs.w	r2, r3, #32
 800a68e:	da0c      	bge.n	800a6aa <__adddf3+0x16e>
 800a690:	320c      	adds	r2, #12
 800a692:	dd08      	ble.n	800a6a6 <__adddf3+0x16a>
 800a694:	f102 0c14 	add.w	ip, r2, #20
 800a698:	f1c2 020c 	rsb	r2, r2, #12
 800a69c:	fa01 f00c 	lsl.w	r0, r1, ip
 800a6a0:	fa21 f102 	lsr.w	r1, r1, r2
 800a6a4:	e00c      	b.n	800a6c0 <__adddf3+0x184>
 800a6a6:	f102 0214 	add.w	r2, r2, #20
 800a6aa:	bfd8      	it	le
 800a6ac:	f1c2 0c20 	rsble	ip, r2, #32
 800a6b0:	fa01 f102 	lsl.w	r1, r1, r2
 800a6b4:	fa20 fc0c 	lsr.w	ip, r0, ip
 800a6b8:	bfdc      	itt	le
 800a6ba:	ea41 010c 	orrle.w	r1, r1, ip
 800a6be:	4090      	lslle	r0, r2
 800a6c0:	1ae4      	subs	r4, r4, r3
 800a6c2:	bfa2      	ittt	ge
 800a6c4:	eb01 5104 	addge.w	r1, r1, r4, lsl #20
 800a6c8:	4329      	orrge	r1, r5
 800a6ca:	bd30      	popge	{r4, r5, pc}
 800a6cc:	ea6f 0404 	mvn.w	r4, r4
 800a6d0:	3c1f      	subs	r4, #31
 800a6d2:	da1c      	bge.n	800a70e <__adddf3+0x1d2>
 800a6d4:	340c      	adds	r4, #12
 800a6d6:	dc0e      	bgt.n	800a6f6 <__adddf3+0x1ba>
 800a6d8:	f104 0414 	add.w	r4, r4, #20
 800a6dc:	f1c4 0220 	rsb	r2, r4, #32
 800a6e0:	fa20 f004 	lsr.w	r0, r0, r4
 800a6e4:	fa01 f302 	lsl.w	r3, r1, r2
 800a6e8:	ea40 0003 	orr.w	r0, r0, r3
 800a6ec:	fa21 f304 	lsr.w	r3, r1, r4
 800a6f0:	ea45 0103 	orr.w	r1, r5, r3
 800a6f4:	bd30      	pop	{r4, r5, pc}
 800a6f6:	f1c4 040c 	rsb	r4, r4, #12
 800a6fa:	f1c4 0220 	rsb	r2, r4, #32
 800a6fe:	fa20 f002 	lsr.w	r0, r0, r2
 800a702:	fa01 f304 	lsl.w	r3, r1, r4
 800a706:	ea40 0003 	orr.w	r0, r0, r3
 800a70a:	4629      	mov	r1, r5
 800a70c:	bd30      	pop	{r4, r5, pc}
 800a70e:	fa21 f004 	lsr.w	r0, r1, r4
 800a712:	4629      	mov	r1, r5
 800a714:	bd30      	pop	{r4, r5, pc}
 800a716:	f094 0f00 	teq	r4, #0
 800a71a:	f483 1380 	eor.w	r3, r3, #1048576	; 0x100000
 800a71e:	bf06      	itte	eq
 800a720:	f481 1180 	eoreq.w	r1, r1, #1048576	; 0x100000
 800a724:	3401      	addeq	r4, #1
 800a726:	3d01      	subne	r5, #1
 800a728:	e74e      	b.n	800a5c8 <__adddf3+0x8c>
 800a72a:	ea7f 5c64 	mvns.w	ip, r4, asr #21
 800a72e:	bf18      	it	ne
 800a730:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
 800a734:	d029      	beq.n	800a78a <__adddf3+0x24e>
 800a736:	ea94 0f05 	teq	r4, r5
 800a73a:	bf08      	it	eq
 800a73c:	ea90 0f02 	teqeq	r0, r2
 800a740:	d005      	beq.n	800a74e <__adddf3+0x212>
 800a742:	ea54 0c00 	orrs.w	ip, r4, r0
 800a746:	bf04      	itt	eq
 800a748:	4619      	moveq	r1, r3
 800a74a:	4610      	moveq	r0, r2
 800a74c:	bd30      	pop	{r4, r5, pc}
 800a74e:	ea91 0f03 	teq	r1, r3
 800a752:	bf1e      	ittt	ne
 800a754:	2100      	movne	r1, #0
 800a756:	2000      	movne	r0, #0
 800a758:	bd30      	popne	{r4, r5, pc}
 800a75a:	ea5f 5c54 	movs.w	ip, r4, lsr #21
 800a75e:	d105      	bne.n	800a76c <__adddf3+0x230>
 800a760:	0040      	lsls	r0, r0, #1
 800a762:	4149      	adcs	r1, r1
 800a764:	bf28      	it	cs
 800a766:	f041 4100 	orrcs.w	r1, r1, #2147483648	; 0x80000000
 800a76a:	bd30      	pop	{r4, r5, pc}
 800a76c:	f514 0480 	adds.w	r4, r4, #4194304	; 0x400000
 800a770:	bf3c      	itt	cc
 800a772:	f501 1180 	addcc.w	r1, r1, #1048576	; 0x100000
 800a776:	bd30      	popcc	{r4, r5, pc}
 800a778:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
 800a77c:	f045 41fe 	orr.w	r1, r5, #2130706432	; 0x7f000000
 800a780:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
 800a784:	f04f 0000 	mov.w	r0, #0
 800a788:	bd30      	pop	{r4, r5, pc}
 800a78a:	ea7f 5c64 	mvns.w	ip, r4, asr #21
 800a78e:	bf1a      	itte	ne
 800a790:	4619      	movne	r1, r3
 800a792:	4610      	movne	r0, r2
 800a794:	ea7f 5c65 	mvnseq.w	ip, r5, asr #21
 800a798:	bf1c      	itt	ne
 800a79a:	460b      	movne	r3, r1
 800a79c:	4602      	movne	r2, r0
 800a79e:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
 800a7a2:	bf06      	itte	eq
 800a7a4:	ea52 3503 	orrseq.w	r5, r2, r3, lsl #12
 800a7a8:	ea91 0f03 	teqeq	r1, r3
 800a7ac:	f441 2100 	orrne.w	r1, r1, #524288	; 0x80000
 800a7b0:	bd30      	pop	{r4, r5, pc}
 800a7b2:	bf00      	nop

0800a7b4 <__aeabi_ui2d>:
 800a7b4:	f090 0f00 	teq	r0, #0
 800a7b8:	bf04      	itt	eq
 800a7ba:	2100      	moveq	r1, #0
 800a7bc:	4770      	bxeq	lr
 800a7be:	b530      	push	{r4, r5, lr}
 800a7c0:	f44f 6480 	mov.w	r4, #1024	; 0x400
 800a7c4:	f104 0432 	add.w	r4, r4, #50	; 0x32
 800a7c8:	f04f 0500 	mov.w	r5, #0
 800a7cc:	f04f 0100 	mov.w	r1, #0
 800a7d0:	e750      	b.n	800a674 <__adddf3+0x138>
 800a7d2:	bf00      	nop

0800a7d4 <__aeabi_i2d>:
 800a7d4:	f090 0f00 	teq	r0, #0
 800a7d8:	bf04      	itt	eq
 800a7da:	2100      	moveq	r1, #0
 800a7dc:	4770      	bxeq	lr
 800a7de:	b530      	push	{r4, r5, lr}
 800a7e0:	f44f 6480 	mov.w	r4, #1024	; 0x400
 800a7e4:	f104 0432 	add.w	r4, r4, #50	; 0x32
 800a7e8:	f010 4500 	ands.w	r5, r0, #2147483648	; 0x80000000
 800a7ec:	bf48      	it	mi
 800a7ee:	4240      	negmi	r0, r0
 800a7f0:	f04f 0100 	mov.w	r1, #0
 800a7f4:	e73e      	b.n	800a674 <__adddf3+0x138>
 800a7f6:	bf00      	nop

0800a7f8 <__aeabi_f2d>:
 800a7f8:	0042      	lsls	r2, r0, #1
 800a7fa:	ea4f 01e2 	mov.w	r1, r2, asr #3
 800a7fe:	ea4f 0131 	mov.w	r1, r1, rrx
 800a802:	ea4f 7002 	mov.w	r0, r2, lsl #28
 800a806:	bf1f      	itttt	ne
 800a808:	f012 437f 	andsne.w	r3, r2, #4278190080	; 0xff000000
 800a80c:	f093 4f7f 	teqne	r3, #4278190080	; 0xff000000
 800a810:	f081 5160 	eorne.w	r1, r1, #939524096	; 0x38000000
 800a814:	4770      	bxne	lr
 800a816:	f032 427f 	bics.w	r2, r2, #4278190080	; 0xff000000
 800a81a:	bf08      	it	eq
 800a81c:	4770      	bxeq	lr
 800a81e:	f093 4f7f 	teq	r3, #4278190080	; 0xff000000
 800a822:	bf04      	itt	eq
 800a824:	f441 2100 	orreq.w	r1, r1, #524288	; 0x80000
 800a828:	4770      	bxeq	lr
 800a82a:	b530      	push	{r4, r5, lr}
 800a82c:	f44f 7460 	mov.w	r4, #896	; 0x380
 800a830:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
 800a834:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
 800a838:	e71c      	b.n	800a674 <__adddf3+0x138>
 800a83a:	bf00      	nop

0800a83c <__aeabi_ul2d>:
 800a83c:	ea50 0201 	orrs.w	r2, r0, r1
 800a840:	bf08      	it	eq
 800a842:	4770      	bxeq	lr
 800a844:	b530      	push	{r4, r5, lr}
 800a846:	f04f 0500 	mov.w	r5, #0
 800a84a:	e00a      	b.n	800a862 <__aeabi_l2d+0x16>

0800a84c <__aeabi_l2d>:
 800a84c:	ea50 0201 	orrs.w	r2, r0, r1
 800a850:	bf08      	it	eq
 800a852:	4770      	bxeq	lr
 800a854:	b530      	push	{r4, r5, lr}
 800a856:	f011 4500 	ands.w	r5, r1, #2147483648	; 0x80000000
 800a85a:	d502      	bpl.n	800a862 <__aeabi_l2d+0x16>
 800a85c:	4240      	negs	r0, r0
 800a85e:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 800a862:	f44f 6480 	mov.w	r4, #1024	; 0x400
 800a866:	f104 0432 	add.w	r4, r4, #50	; 0x32
 800a86a:	ea5f 5c91 	movs.w	ip, r1, lsr #22
 800a86e:	f43f aed8 	beq.w	800a622 <__adddf3+0xe6>
 800a872:	f04f 0203 	mov.w	r2, #3
 800a876:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
 800a87a:	bf18      	it	ne
 800a87c:	3203      	addne	r2, #3
 800a87e:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
 800a882:	bf18      	it	ne
 800a884:	3203      	addne	r2, #3
 800a886:	eb02 02dc 	add.w	r2, r2, ip, lsr #3
 800a88a:	f1c2 0320 	rsb	r3, r2, #32
 800a88e:	fa00 fc03 	lsl.w	ip, r0, r3
 800a892:	fa20 f002 	lsr.w	r0, r0, r2
 800a896:	fa01 fe03 	lsl.w	lr, r1, r3
 800a89a:	ea40 000e 	orr.w	r0, r0, lr
 800a89e:	fa21 f102 	lsr.w	r1, r1, r2
 800a8a2:	4414      	add	r4, r2
 800a8a4:	e6bd      	b.n	800a622 <__adddf3+0xe6>
 800a8a6:	bf00      	nop

0800a8a8 <__aeabi_dmul>:
 800a8a8:	b570      	push	{r4, r5, r6, lr}
 800a8aa:	f04f 0cff 	mov.w	ip, #255	; 0xff
 800a8ae:	f44c 6ce0 	orr.w	ip, ip, #1792	; 0x700
 800a8b2:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
 800a8b6:	bf1d      	ittte	ne
 800a8b8:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
 800a8bc:	ea94 0f0c 	teqne	r4, ip
 800a8c0:	ea95 0f0c 	teqne	r5, ip
 800a8c4:	f000 f8de 	bleq	800aa84 <__aeabi_dmul+0x1dc>
 800a8c8:	442c      	add	r4, r5
 800a8ca:	ea81 0603 	eor.w	r6, r1, r3
 800a8ce:	ea21 514c 	bic.w	r1, r1, ip, lsl #21
 800a8d2:	ea23 534c 	bic.w	r3, r3, ip, lsl #21
 800a8d6:	ea50 3501 	orrs.w	r5, r0, r1, lsl #12
 800a8da:	bf18      	it	ne
 800a8dc:	ea52 3503 	orrsne.w	r5, r2, r3, lsl #12
 800a8e0:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 800a8e4:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
 800a8e8:	d038      	beq.n	800a95c <__aeabi_dmul+0xb4>
 800a8ea:	fba0 ce02 	umull	ip, lr, r0, r2
 800a8ee:	f04f 0500 	mov.w	r5, #0
 800a8f2:	fbe1 e502 	umlal	lr, r5, r1, r2
 800a8f6:	f006 4200 	and.w	r2, r6, #2147483648	; 0x80000000
 800a8fa:	fbe0 e503 	umlal	lr, r5, r0, r3
 800a8fe:	f04f 0600 	mov.w	r6, #0
 800a902:	fbe1 5603 	umlal	r5, r6, r1, r3
 800a906:	f09c 0f00 	teq	ip, #0
 800a90a:	bf18      	it	ne
 800a90c:	f04e 0e01 	orrne.w	lr, lr, #1
 800a910:	f1a4 04ff 	sub.w	r4, r4, #255	; 0xff
 800a914:	f5b6 7f00 	cmp.w	r6, #512	; 0x200
 800a918:	f564 7440 	sbc.w	r4, r4, #768	; 0x300
 800a91c:	d204      	bcs.n	800a928 <__aeabi_dmul+0x80>
 800a91e:	ea5f 0e4e 	movs.w	lr, lr, lsl #1
 800a922:	416d      	adcs	r5, r5
 800a924:	eb46 0606 	adc.w	r6, r6, r6
 800a928:	ea42 21c6 	orr.w	r1, r2, r6, lsl #11
 800a92c:	ea41 5155 	orr.w	r1, r1, r5, lsr #21
 800a930:	ea4f 20c5 	mov.w	r0, r5, lsl #11
 800a934:	ea40 505e 	orr.w	r0, r0, lr, lsr #21
 800a938:	ea4f 2ece 	mov.w	lr, lr, lsl #11
 800a93c:	f1b4 0cfd 	subs.w	ip, r4, #253	; 0xfd
 800a940:	bf88      	it	hi
 800a942:	f5bc 6fe0 	cmphi.w	ip, #1792	; 0x700
 800a946:	d81e      	bhi.n	800a986 <__aeabi_dmul+0xde>
 800a948:	f1be 4f00 	cmp.w	lr, #2147483648	; 0x80000000
 800a94c:	bf08      	it	eq
 800a94e:	ea5f 0e50 	movseq.w	lr, r0, lsr #1
 800a952:	f150 0000 	adcs.w	r0, r0, #0
 800a956:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 800a95a:	bd70      	pop	{r4, r5, r6, pc}
 800a95c:	f006 4600 	and.w	r6, r6, #2147483648	; 0x80000000
 800a960:	ea46 0101 	orr.w	r1, r6, r1
 800a964:	ea40 0002 	orr.w	r0, r0, r2
 800a968:	ea81 0103 	eor.w	r1, r1, r3
 800a96c:	ebb4 045c 	subs.w	r4, r4, ip, lsr #1
 800a970:	bfc2      	ittt	gt
 800a972:	ebd4 050c 	rsbsgt	r5, r4, ip
 800a976:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
 800a97a:	bd70      	popgt	{r4, r5, r6, pc}
 800a97c:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 800a980:	f04f 0e00 	mov.w	lr, #0
 800a984:	3c01      	subs	r4, #1
 800a986:	f300 80ab 	bgt.w	800aae0 <__aeabi_dmul+0x238>
 800a98a:	f114 0f36 	cmn.w	r4, #54	; 0x36
 800a98e:	bfde      	ittt	le
 800a990:	2000      	movle	r0, #0
 800a992:	f001 4100 	andle.w	r1, r1, #2147483648	; 0x80000000
 800a996:	bd70      	pople	{r4, r5, r6, pc}
 800a998:	f1c4 0400 	rsb	r4, r4, #0
 800a99c:	3c20      	subs	r4, #32
 800a99e:	da35      	bge.n	800aa0c <__aeabi_dmul+0x164>
 800a9a0:	340c      	adds	r4, #12
 800a9a2:	dc1b      	bgt.n	800a9dc <__aeabi_dmul+0x134>
 800a9a4:	f104 0414 	add.w	r4, r4, #20
 800a9a8:	f1c4 0520 	rsb	r5, r4, #32
 800a9ac:	fa00 f305 	lsl.w	r3, r0, r5
 800a9b0:	fa20 f004 	lsr.w	r0, r0, r4
 800a9b4:	fa01 f205 	lsl.w	r2, r1, r5
 800a9b8:	ea40 0002 	orr.w	r0, r0, r2
 800a9bc:	f001 4200 	and.w	r2, r1, #2147483648	; 0x80000000
 800a9c0:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
 800a9c4:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
 800a9c8:	fa21 f604 	lsr.w	r6, r1, r4
 800a9cc:	eb42 0106 	adc.w	r1, r2, r6
 800a9d0:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
 800a9d4:	bf08      	it	eq
 800a9d6:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
 800a9da:	bd70      	pop	{r4, r5, r6, pc}
 800a9dc:	f1c4 040c 	rsb	r4, r4, #12
 800a9e0:	f1c4 0520 	rsb	r5, r4, #32
 800a9e4:	fa00 f304 	lsl.w	r3, r0, r4
 800a9e8:	fa20 f005 	lsr.w	r0, r0, r5
 800a9ec:	fa01 f204 	lsl.w	r2, r1, r4
 800a9f0:	ea40 0002 	orr.w	r0, r0, r2
 800a9f4:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 800a9f8:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
 800a9fc:	f141 0100 	adc.w	r1, r1, #0
 800aa00:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
 800aa04:	bf08      	it	eq
 800aa06:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
 800aa0a:	bd70      	pop	{r4, r5, r6, pc}
 800aa0c:	f1c4 0520 	rsb	r5, r4, #32
 800aa10:	fa00 f205 	lsl.w	r2, r0, r5
 800aa14:	ea4e 0e02 	orr.w	lr, lr, r2
 800aa18:	fa20 f304 	lsr.w	r3, r0, r4
 800aa1c:	fa01 f205 	lsl.w	r2, r1, r5
 800aa20:	ea43 0302 	orr.w	r3, r3, r2
 800aa24:	fa21 f004 	lsr.w	r0, r1, r4
 800aa28:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 800aa2c:	fa21 f204 	lsr.w	r2, r1, r4
 800aa30:	ea20 0002 	bic.w	r0, r0, r2
 800aa34:	eb00 70d3 	add.w	r0, r0, r3, lsr #31
 800aa38:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
 800aa3c:	bf08      	it	eq
 800aa3e:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
 800aa42:	bd70      	pop	{r4, r5, r6, pc}
 800aa44:	f094 0f00 	teq	r4, #0
 800aa48:	d10f      	bne.n	800aa6a <__aeabi_dmul+0x1c2>
 800aa4a:	f001 4600 	and.w	r6, r1, #2147483648	; 0x80000000
 800aa4e:	0040      	lsls	r0, r0, #1
 800aa50:	eb41 0101 	adc.w	r1, r1, r1
 800aa54:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 800aa58:	bf08      	it	eq
 800aa5a:	3c01      	subeq	r4, #1
 800aa5c:	d0f7      	beq.n	800aa4e <__aeabi_dmul+0x1a6>
 800aa5e:	ea41 0106 	orr.w	r1, r1, r6
 800aa62:	f095 0f00 	teq	r5, #0
 800aa66:	bf18      	it	ne
 800aa68:	4770      	bxne	lr
 800aa6a:	f003 4600 	and.w	r6, r3, #2147483648	; 0x80000000
 800aa6e:	0052      	lsls	r2, r2, #1
 800aa70:	eb43 0303 	adc.w	r3, r3, r3
 800aa74:	f413 1f80 	tst.w	r3, #1048576	; 0x100000
 800aa78:	bf08      	it	eq
 800aa7a:	3d01      	subeq	r5, #1
 800aa7c:	d0f7      	beq.n	800aa6e <__aeabi_dmul+0x1c6>
 800aa7e:	ea43 0306 	orr.w	r3, r3, r6
 800aa82:	4770      	bx	lr
 800aa84:	ea94 0f0c 	teq	r4, ip
 800aa88:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
 800aa8c:	bf18      	it	ne
 800aa8e:	ea95 0f0c 	teqne	r5, ip
 800aa92:	d00c      	beq.n	800aaae <__aeabi_dmul+0x206>
 800aa94:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
 800aa98:	bf18      	it	ne
 800aa9a:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
 800aa9e:	d1d1      	bne.n	800aa44 <__aeabi_dmul+0x19c>
 800aaa0:	ea81 0103 	eor.w	r1, r1, r3
 800aaa4:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 800aaa8:	f04f 0000 	mov.w	r0, #0
 800aaac:	bd70      	pop	{r4, r5, r6, pc}
 800aaae:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
 800aab2:	bf06      	itte	eq
 800aab4:	4610      	moveq	r0, r2
 800aab6:	4619      	moveq	r1, r3
 800aab8:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
 800aabc:	d019      	beq.n	800aaf2 <__aeabi_dmul+0x24a>
 800aabe:	ea94 0f0c 	teq	r4, ip
 800aac2:	d102      	bne.n	800aaca <__aeabi_dmul+0x222>
 800aac4:	ea50 3601 	orrs.w	r6, r0, r1, lsl #12
 800aac8:	d113      	bne.n	800aaf2 <__aeabi_dmul+0x24a>
 800aaca:	ea95 0f0c 	teq	r5, ip
 800aace:	d105      	bne.n	800aadc <__aeabi_dmul+0x234>
 800aad0:	ea52 3603 	orrs.w	r6, r2, r3, lsl #12
 800aad4:	bf1c      	itt	ne
 800aad6:	4610      	movne	r0, r2
 800aad8:	4619      	movne	r1, r3
 800aada:	d10a      	bne.n	800aaf2 <__aeabi_dmul+0x24a>
 800aadc:	ea81 0103 	eor.w	r1, r1, r3
 800aae0:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 800aae4:	f041 41fe 	orr.w	r1, r1, #2130706432	; 0x7f000000
 800aae8:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
 800aaec:	f04f 0000 	mov.w	r0, #0
 800aaf0:	bd70      	pop	{r4, r5, r6, pc}
 800aaf2:	f041 41fe 	orr.w	r1, r1, #2130706432	; 0x7f000000
 800aaf6:	f441 0178 	orr.w	r1, r1, #16252928	; 0xf80000
 800aafa:	bd70      	pop	{r4, r5, r6, pc}

0800aafc <__aeabi_ddiv>:
 800aafc:	b570      	push	{r4, r5, r6, lr}
 800aafe:	f04f 0cff 	mov.w	ip, #255	; 0xff
 800ab02:	f44c 6ce0 	orr.w	ip, ip, #1792	; 0x700
 800ab06:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
 800ab0a:	bf1d      	ittte	ne
 800ab0c:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
 800ab10:	ea94 0f0c 	teqne	r4, ip
 800ab14:	ea95 0f0c 	teqne	r5, ip
 800ab18:	f000 f8a7 	bleq	800ac6a <__aeabi_ddiv+0x16e>
 800ab1c:	eba4 0405 	sub.w	r4, r4, r5
 800ab20:	ea81 0e03 	eor.w	lr, r1, r3
 800ab24:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
 800ab28:	ea4f 3101 	mov.w	r1, r1, lsl #12
 800ab2c:	f000 8088 	beq.w	800ac40 <__aeabi_ddiv+0x144>
 800ab30:	ea4f 3303 	mov.w	r3, r3, lsl #12
 800ab34:	f04f 5580 	mov.w	r5, #268435456	; 0x10000000
 800ab38:	ea45 1313 	orr.w	r3, r5, r3, lsr #4
 800ab3c:	ea43 6312 	orr.w	r3, r3, r2, lsr #24
 800ab40:	ea4f 2202 	mov.w	r2, r2, lsl #8
 800ab44:	ea45 1511 	orr.w	r5, r5, r1, lsr #4
 800ab48:	ea45 6510 	orr.w	r5, r5, r0, lsr #24
 800ab4c:	ea4f 2600 	mov.w	r6, r0, lsl #8
 800ab50:	f00e 4100 	and.w	r1, lr, #2147483648	; 0x80000000
 800ab54:	429d      	cmp	r5, r3
 800ab56:	bf08      	it	eq
 800ab58:	4296      	cmpeq	r6, r2
 800ab5a:	f144 04fd 	adc.w	r4, r4, #253	; 0xfd
 800ab5e:	f504 7440 	add.w	r4, r4, #768	; 0x300
 800ab62:	d202      	bcs.n	800ab6a <__aeabi_ddiv+0x6e>
 800ab64:	085b      	lsrs	r3, r3, #1
 800ab66:	ea4f 0232 	mov.w	r2, r2, rrx
 800ab6a:	1ab6      	subs	r6, r6, r2
 800ab6c:	eb65 0503 	sbc.w	r5, r5, r3
 800ab70:	085b      	lsrs	r3, r3, #1
 800ab72:	ea4f 0232 	mov.w	r2, r2, rrx
 800ab76:	f44f 1080 	mov.w	r0, #1048576	; 0x100000
 800ab7a:	f44f 2c00 	mov.w	ip, #524288	; 0x80000
 800ab7e:	ebb6 0e02 	subs.w	lr, r6, r2
 800ab82:	eb75 0e03 	sbcs.w	lr, r5, r3
 800ab86:	bf22      	ittt	cs
 800ab88:	1ab6      	subcs	r6, r6, r2
 800ab8a:	4675      	movcs	r5, lr
 800ab8c:	ea40 000c 	orrcs.w	r0, r0, ip
 800ab90:	085b      	lsrs	r3, r3, #1
 800ab92:	ea4f 0232 	mov.w	r2, r2, rrx
 800ab96:	ebb6 0e02 	subs.w	lr, r6, r2
 800ab9a:	eb75 0e03 	sbcs.w	lr, r5, r3
 800ab9e:	bf22      	ittt	cs
 800aba0:	1ab6      	subcs	r6, r6, r2
 800aba2:	4675      	movcs	r5, lr
 800aba4:	ea40 005c 	orrcs.w	r0, r0, ip, lsr #1
 800aba8:	085b      	lsrs	r3, r3, #1
 800abaa:	ea4f 0232 	mov.w	r2, r2, rrx
 800abae:	ebb6 0e02 	subs.w	lr, r6, r2
 800abb2:	eb75 0e03 	sbcs.w	lr, r5, r3
 800abb6:	bf22      	ittt	cs
 800abb8:	1ab6      	subcs	r6, r6, r2
 800abba:	4675      	movcs	r5, lr
 800abbc:	ea40 009c 	orrcs.w	r0, r0, ip, lsr #2
 800abc0:	085b      	lsrs	r3, r3, #1
 800abc2:	ea4f 0232 	mov.w	r2, r2, rrx
 800abc6:	ebb6 0e02 	subs.w	lr, r6, r2
 800abca:	eb75 0e03 	sbcs.w	lr, r5, r3
 800abce:	bf22      	ittt	cs
 800abd0:	1ab6      	subcs	r6, r6, r2
 800abd2:	4675      	movcs	r5, lr
 800abd4:	ea40 00dc 	orrcs.w	r0, r0, ip, lsr #3
 800abd8:	ea55 0e06 	orrs.w	lr, r5, r6
 800abdc:	d018      	beq.n	800ac10 <__aeabi_ddiv+0x114>
 800abde:	ea4f 1505 	mov.w	r5, r5, lsl #4
 800abe2:	ea45 7516 	orr.w	r5, r5, r6, lsr #28
 800abe6:	ea4f 1606 	mov.w	r6, r6, lsl #4
 800abea:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 800abee:	ea43 7352 	orr.w	r3, r3, r2, lsr #29
 800abf2:	ea4f 02c2 	mov.w	r2, r2, lsl #3
 800abf6:	ea5f 1c1c 	movs.w	ip, ip, lsr #4
 800abfa:	d1c0      	bne.n	800ab7e <__aeabi_ddiv+0x82>
 800abfc:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 800ac00:	d10b      	bne.n	800ac1a <__aeabi_ddiv+0x11e>
 800ac02:	ea41 0100 	orr.w	r1, r1, r0
 800ac06:	f04f 0000 	mov.w	r0, #0
 800ac0a:	f04f 4c00 	mov.w	ip, #2147483648	; 0x80000000
 800ac0e:	e7b6      	b.n	800ab7e <__aeabi_ddiv+0x82>
 800ac10:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 800ac14:	bf04      	itt	eq
 800ac16:	4301      	orreq	r1, r0
 800ac18:	2000      	moveq	r0, #0
 800ac1a:	f1b4 0cfd 	subs.w	ip, r4, #253	; 0xfd
 800ac1e:	bf88      	it	hi
 800ac20:	f5bc 6fe0 	cmphi.w	ip, #1792	; 0x700
 800ac24:	f63f aeaf 	bhi.w	800a986 <__aeabi_dmul+0xde>
 800ac28:	ebb5 0c03 	subs.w	ip, r5, r3
 800ac2c:	bf04      	itt	eq
 800ac2e:	ebb6 0c02 	subseq.w	ip, r6, r2
 800ac32:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
 800ac36:	f150 0000 	adcs.w	r0, r0, #0
 800ac3a:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 800ac3e:	bd70      	pop	{r4, r5, r6, pc}
 800ac40:	f00e 4e00 	and.w	lr, lr, #2147483648	; 0x80000000
 800ac44:	ea4e 3111 	orr.w	r1, lr, r1, lsr #12
 800ac48:	eb14 045c 	adds.w	r4, r4, ip, lsr #1
 800ac4c:	bfc2      	ittt	gt
 800ac4e:	ebd4 050c 	rsbsgt	r5, r4, ip
 800ac52:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
 800ac56:	bd70      	popgt	{r4, r5, r6, pc}
 800ac58:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 800ac5c:	f04f 0e00 	mov.w	lr, #0
 800ac60:	3c01      	subs	r4, #1
 800ac62:	e690      	b.n	800a986 <__aeabi_dmul+0xde>
 800ac64:	ea45 0e06 	orr.w	lr, r5, r6
 800ac68:	e68d      	b.n	800a986 <__aeabi_dmul+0xde>
 800ac6a:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
 800ac6e:	ea94 0f0c 	teq	r4, ip
 800ac72:	bf08      	it	eq
 800ac74:	ea95 0f0c 	teqeq	r5, ip
 800ac78:	f43f af3b 	beq.w	800aaf2 <__aeabi_dmul+0x24a>
 800ac7c:	ea94 0f0c 	teq	r4, ip
 800ac80:	d10a      	bne.n	800ac98 <__aeabi_ddiv+0x19c>
 800ac82:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
 800ac86:	f47f af34 	bne.w	800aaf2 <__aeabi_dmul+0x24a>
 800ac8a:	ea95 0f0c 	teq	r5, ip
 800ac8e:	f47f af25 	bne.w	800aadc <__aeabi_dmul+0x234>
 800ac92:	4610      	mov	r0, r2
 800ac94:	4619      	mov	r1, r3
 800ac96:	e72c      	b.n	800aaf2 <__aeabi_dmul+0x24a>
 800ac98:	ea95 0f0c 	teq	r5, ip
 800ac9c:	d106      	bne.n	800acac <__aeabi_ddiv+0x1b0>
 800ac9e:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
 800aca2:	f43f aefd 	beq.w	800aaa0 <__aeabi_dmul+0x1f8>
 800aca6:	4610      	mov	r0, r2
 800aca8:	4619      	mov	r1, r3
 800acaa:	e722      	b.n	800aaf2 <__aeabi_dmul+0x24a>
 800acac:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
 800acb0:	bf18      	it	ne
 800acb2:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
 800acb6:	f47f aec5 	bne.w	800aa44 <__aeabi_dmul+0x19c>
 800acba:	ea50 0441 	orrs.w	r4, r0, r1, lsl #1
 800acbe:	f47f af0d 	bne.w	800aadc <__aeabi_dmul+0x234>
 800acc2:	ea52 0543 	orrs.w	r5, r2, r3, lsl #1
 800acc6:	f47f aeeb 	bne.w	800aaa0 <__aeabi_dmul+0x1f8>
 800acca:	e712      	b.n	800aaf2 <__aeabi_dmul+0x24a>

0800accc <__gedf2>:
 800accc:	f04f 3cff 	mov.w	ip, #4294967295
 800acd0:	e006      	b.n	800ace0 <__cmpdf2+0x4>
 800acd2:	bf00      	nop

0800acd4 <__ledf2>:
 800acd4:	f04f 0c01 	mov.w	ip, #1
 800acd8:	e002      	b.n	800ace0 <__cmpdf2+0x4>
 800acda:	bf00      	nop

0800acdc <__cmpdf2>:
 800acdc:	f04f 0c01 	mov.w	ip, #1
 800ace0:	f84d cd04 	str.w	ip, [sp, #-4]!
 800ace4:	ea4f 0c41 	mov.w	ip, r1, lsl #1
 800ace8:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
 800acec:	ea4f 0c43 	mov.w	ip, r3, lsl #1
 800acf0:	bf18      	it	ne
 800acf2:	ea7f 5c6c 	mvnsne.w	ip, ip, asr #21
 800acf6:	d01b      	beq.n	800ad30 <__cmpdf2+0x54>
 800acf8:	b001      	add	sp, #4
 800acfa:	ea50 0c41 	orrs.w	ip, r0, r1, lsl #1
 800acfe:	bf0c      	ite	eq
 800ad00:	ea52 0c43 	orrseq.w	ip, r2, r3, lsl #1
 800ad04:	ea91 0f03 	teqne	r1, r3
 800ad08:	bf02      	ittt	eq
 800ad0a:	ea90 0f02 	teqeq	r0, r2
 800ad0e:	2000      	moveq	r0, #0
 800ad10:	4770      	bxeq	lr
 800ad12:	f110 0f00 	cmn.w	r0, #0
 800ad16:	ea91 0f03 	teq	r1, r3
 800ad1a:	bf58      	it	pl
 800ad1c:	4299      	cmppl	r1, r3
 800ad1e:	bf08      	it	eq
 800ad20:	4290      	cmpeq	r0, r2
 800ad22:	bf2c      	ite	cs
 800ad24:	17d8      	asrcs	r0, r3, #31
 800ad26:	ea6f 70e3 	mvncc.w	r0, r3, asr #31
 800ad2a:	f040 0001 	orr.w	r0, r0, #1
 800ad2e:	4770      	bx	lr
 800ad30:	ea4f 0c41 	mov.w	ip, r1, lsl #1
 800ad34:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
 800ad38:	d102      	bne.n	800ad40 <__cmpdf2+0x64>
 800ad3a:	ea50 3c01 	orrs.w	ip, r0, r1, lsl #12
 800ad3e:	d107      	bne.n	800ad50 <__cmpdf2+0x74>
 800ad40:	ea4f 0c43 	mov.w	ip, r3, lsl #1
 800ad44:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
 800ad48:	d1d6      	bne.n	800acf8 <__cmpdf2+0x1c>
 800ad4a:	ea52 3c03 	orrs.w	ip, r2, r3, lsl #12
 800ad4e:	d0d3      	beq.n	800acf8 <__cmpdf2+0x1c>
 800ad50:	f85d 0b04 	ldr.w	r0, [sp], #4
 800ad54:	4770      	bx	lr
 800ad56:	bf00      	nop

0800ad58 <__aeabi_cdrcmple>:
 800ad58:	4684      	mov	ip, r0
 800ad5a:	4610      	mov	r0, r2
 800ad5c:	4662      	mov	r2, ip
 800ad5e:	468c      	mov	ip, r1
 800ad60:	4619      	mov	r1, r3
 800ad62:	4663      	mov	r3, ip
 800ad64:	e000      	b.n	800ad68 <__aeabi_cdcmpeq>
 800ad66:	bf00      	nop

0800ad68 <__aeabi_cdcmpeq>:
 800ad68:	b501      	push	{r0, lr}
 800ad6a:	f7ff ffb7 	bl	800acdc <__cmpdf2>
 800ad6e:	2800      	cmp	r0, #0
 800ad70:	bf48      	it	mi
 800ad72:	f110 0f00 	cmnmi.w	r0, #0
 800ad76:	bd01      	pop	{r0, pc}

0800ad78 <__aeabi_dcmpeq>:
 800ad78:	f84d ed08 	str.w	lr, [sp, #-8]!
 800ad7c:	f7ff fff4 	bl	800ad68 <__aeabi_cdcmpeq>
 800ad80:	bf0c      	ite	eq
 800ad82:	2001      	moveq	r0, #1
 800ad84:	2000      	movne	r0, #0
 800ad86:	f85d fb08 	ldr.w	pc, [sp], #8
 800ad8a:	bf00      	nop

0800ad8c <__aeabi_dcmplt>:
 800ad8c:	f84d ed08 	str.w	lr, [sp, #-8]!
 800ad90:	f7ff ffea 	bl	800ad68 <__aeabi_cdcmpeq>
 800ad94:	bf34      	ite	cc
 800ad96:	2001      	movcc	r0, #1
 800ad98:	2000      	movcs	r0, #0
 800ad9a:	f85d fb08 	ldr.w	pc, [sp], #8
 800ad9e:	bf00      	nop

0800ada0 <__aeabi_dcmple>:
 800ada0:	f84d ed08 	str.w	lr, [sp, #-8]!
 800ada4:	f7ff ffe0 	bl	800ad68 <__aeabi_cdcmpeq>
 800ada8:	bf94      	ite	ls
 800adaa:	2001      	movls	r0, #1
 800adac:	2000      	movhi	r0, #0
 800adae:	f85d fb08 	ldr.w	pc, [sp], #8
 800adb2:	bf00      	nop

0800adb4 <__aeabi_dcmpge>:
 800adb4:	f84d ed08 	str.w	lr, [sp, #-8]!
 800adb8:	f7ff ffce 	bl	800ad58 <__aeabi_cdrcmple>
 800adbc:	bf94      	ite	ls
 800adbe:	2001      	movls	r0, #1
 800adc0:	2000      	movhi	r0, #0
 800adc2:	f85d fb08 	ldr.w	pc, [sp], #8
 800adc6:	bf00      	nop

0800adc8 <__aeabi_dcmpgt>:
 800adc8:	f84d ed08 	str.w	lr, [sp, #-8]!
 800adcc:	f7ff ffc4 	bl	800ad58 <__aeabi_cdrcmple>
 800add0:	bf34      	ite	cc
 800add2:	2001      	movcc	r0, #1
 800add4:	2000      	movcs	r0, #0
 800add6:	f85d fb08 	ldr.w	pc, [sp], #8
 800adda:	bf00      	nop

0800addc <__aeabi_dcmpun>:
 800addc:	ea4f 0c41 	mov.w	ip, r1, lsl #1
 800ade0:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
 800ade4:	d102      	bne.n	800adec <__aeabi_dcmpun+0x10>
 800ade6:	ea50 3c01 	orrs.w	ip, r0, r1, lsl #12
 800adea:	d10a      	bne.n	800ae02 <__aeabi_dcmpun+0x26>
 800adec:	ea4f 0c43 	mov.w	ip, r3, lsl #1
 800adf0:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
 800adf4:	d102      	bne.n	800adfc <__aeabi_dcmpun+0x20>
 800adf6:	ea52 3c03 	orrs.w	ip, r2, r3, lsl #12
 800adfa:	d102      	bne.n	800ae02 <__aeabi_dcmpun+0x26>
 800adfc:	f04f 0000 	mov.w	r0, #0
 800ae00:	4770      	bx	lr
 800ae02:	f04f 0001 	mov.w	r0, #1
 800ae06:	4770      	bx	lr

0800ae08 <__aeabi_d2iz>:
 800ae08:	ea4f 0241 	mov.w	r2, r1, lsl #1
 800ae0c:	f512 1200 	adds.w	r2, r2, #2097152	; 0x200000
 800ae10:	d215      	bcs.n	800ae3e <__aeabi_d2iz+0x36>
 800ae12:	d511      	bpl.n	800ae38 <__aeabi_d2iz+0x30>
 800ae14:	f46f 7378 	mvn.w	r3, #992	; 0x3e0
 800ae18:	ebb3 5262 	subs.w	r2, r3, r2, asr #21
 800ae1c:	d912      	bls.n	800ae44 <__aeabi_d2iz+0x3c>
 800ae1e:	ea4f 23c1 	mov.w	r3, r1, lsl #11
 800ae22:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 800ae26:	ea43 5350 	orr.w	r3, r3, r0, lsr #21
 800ae2a:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
 800ae2e:	fa23 f002 	lsr.w	r0, r3, r2
 800ae32:	bf18      	it	ne
 800ae34:	4240      	negne	r0, r0
 800ae36:	4770      	bx	lr
 800ae38:	f04f 0000 	mov.w	r0, #0
 800ae3c:	4770      	bx	lr
 800ae3e:	ea50 3001 	orrs.w	r0, r0, r1, lsl #12
 800ae42:	d105      	bne.n	800ae50 <__aeabi_d2iz+0x48>
 800ae44:	f011 4000 	ands.w	r0, r1, #2147483648	; 0x80000000
 800ae48:	bf08      	it	eq
 800ae4a:	f06f 4000 	mvneq.w	r0, #2147483648	; 0x80000000
 800ae4e:	4770      	bx	lr
 800ae50:	f04f 0000 	mov.w	r0, #0
 800ae54:	4770      	bx	lr
 800ae56:	bf00      	nop

0800ae58 <__aeabi_uldivmod>:
 800ae58:	b953      	cbnz	r3, 800ae70 <__aeabi_uldivmod+0x18>
 800ae5a:	b94a      	cbnz	r2, 800ae70 <__aeabi_uldivmod+0x18>
 800ae5c:	2900      	cmp	r1, #0
 800ae5e:	bf08      	it	eq
 800ae60:	2800      	cmpeq	r0, #0
 800ae62:	bf1c      	itt	ne
 800ae64:	f04f 31ff 	movne.w	r1, #4294967295
 800ae68:	f04f 30ff 	movne.w	r0, #4294967295
 800ae6c:	f000 b974 	b.w	800b158 <__aeabi_idiv0>
 800ae70:	f1ad 0c08 	sub.w	ip, sp, #8
 800ae74:	e96d ce04 	strd	ip, lr, [sp, #-16]!
 800ae78:	f000 f806 	bl	800ae88 <__udivmoddi4>
 800ae7c:	f8dd e004 	ldr.w	lr, [sp, #4]
 800ae80:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 800ae84:	b004      	add	sp, #16
 800ae86:	4770      	bx	lr

0800ae88 <__udivmoddi4>:
 800ae88:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 800ae8c:	9d08      	ldr	r5, [sp, #32]
 800ae8e:	4604      	mov	r4, r0
 800ae90:	468e      	mov	lr, r1
 800ae92:	2b00      	cmp	r3, #0
 800ae94:	d14d      	bne.n	800af32 <__udivmoddi4+0xaa>
 800ae96:	428a      	cmp	r2, r1
 800ae98:	4694      	mov	ip, r2
 800ae9a:	d969      	bls.n	800af70 <__udivmoddi4+0xe8>
 800ae9c:	fab2 f282 	clz	r2, r2
 800aea0:	b152      	cbz	r2, 800aeb8 <__udivmoddi4+0x30>
 800aea2:	fa01 f302 	lsl.w	r3, r1, r2
 800aea6:	f1c2 0120 	rsb	r1, r2, #32
 800aeaa:	fa20 f101 	lsr.w	r1, r0, r1
 800aeae:	fa0c fc02 	lsl.w	ip, ip, r2
 800aeb2:	ea41 0e03 	orr.w	lr, r1, r3
 800aeb6:	4094      	lsls	r4, r2
 800aeb8:	ea4f 481c 	mov.w	r8, ip, lsr #16
 800aebc:	0c21      	lsrs	r1, r4, #16
 800aebe:	fbbe f6f8 	udiv	r6, lr, r8
 800aec2:	fa1f f78c 	uxth.w	r7, ip
 800aec6:	fb08 e316 	mls	r3, r8, r6, lr
 800aeca:	ea41 4303 	orr.w	r3, r1, r3, lsl #16
 800aece:	fb06 f107 	mul.w	r1, r6, r7
 800aed2:	4299      	cmp	r1, r3
 800aed4:	d90a      	bls.n	800aeec <__udivmoddi4+0x64>
 800aed6:	eb1c 0303 	adds.w	r3, ip, r3
 800aeda:	f106 30ff 	add.w	r0, r6, #4294967295
 800aede:	f080 811f 	bcs.w	800b120 <__udivmoddi4+0x298>
 800aee2:	4299      	cmp	r1, r3
 800aee4:	f240 811c 	bls.w	800b120 <__udivmoddi4+0x298>
 800aee8:	3e02      	subs	r6, #2
 800aeea:	4463      	add	r3, ip
 800aeec:	1a5b      	subs	r3, r3, r1
 800aeee:	b2a4      	uxth	r4, r4
 800aef0:	fbb3 f0f8 	udiv	r0, r3, r8
 800aef4:	fb08 3310 	mls	r3, r8, r0, r3
 800aef8:	ea44 4403 	orr.w	r4, r4, r3, lsl #16
 800aefc:	fb00 f707 	mul.w	r7, r0, r7
 800af00:	42a7      	cmp	r7, r4
 800af02:	d90a      	bls.n	800af1a <__udivmoddi4+0x92>
 800af04:	eb1c 0404 	adds.w	r4, ip, r4
 800af08:	f100 33ff 	add.w	r3, r0, #4294967295
 800af0c:	f080 810a 	bcs.w	800b124 <__udivmoddi4+0x29c>
 800af10:	42a7      	cmp	r7, r4
 800af12:	f240 8107 	bls.w	800b124 <__udivmoddi4+0x29c>
 800af16:	4464      	add	r4, ip
 800af18:	3802      	subs	r0, #2
 800af1a:	ea40 4006 	orr.w	r0, r0, r6, lsl #16
 800af1e:	1be4      	subs	r4, r4, r7
 800af20:	2600      	movs	r6, #0
 800af22:	b11d      	cbz	r5, 800af2c <__udivmoddi4+0xa4>
 800af24:	40d4      	lsrs	r4, r2
 800af26:	2300      	movs	r3, #0
 800af28:	e9c5 4300 	strd	r4, r3, [r5]
 800af2c:	4631      	mov	r1, r6
 800af2e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 800af32:	428b      	cmp	r3, r1
 800af34:	d909      	bls.n	800af4a <__udivmoddi4+0xc2>
 800af36:	2d00      	cmp	r5, #0
 800af38:	f000 80ef 	beq.w	800b11a <__udivmoddi4+0x292>
 800af3c:	2600      	movs	r6, #0
 800af3e:	e9c5 0100 	strd	r0, r1, [r5]
 800af42:	4630      	mov	r0, r6
 800af44:	4631      	mov	r1, r6
 800af46:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 800af4a:	fab3 f683 	clz	r6, r3
 800af4e:	2e00      	cmp	r6, #0
 800af50:	d14a      	bne.n	800afe8 <__udivmoddi4+0x160>
 800af52:	428b      	cmp	r3, r1
 800af54:	d302      	bcc.n	800af5c <__udivmoddi4+0xd4>
 800af56:	4282      	cmp	r2, r0
 800af58:	f200 80f9 	bhi.w	800b14e <__udivmoddi4+0x2c6>
 800af5c:	1a84      	subs	r4, r0, r2
 800af5e:	eb61 0303 	sbc.w	r3, r1, r3
 800af62:	2001      	movs	r0, #1
 800af64:	469e      	mov	lr, r3
 800af66:	2d00      	cmp	r5, #0
 800af68:	d0e0      	beq.n	800af2c <__udivmoddi4+0xa4>
 800af6a:	e9c5 4e00 	strd	r4, lr, [r5]
 800af6e:	e7dd      	b.n	800af2c <__udivmoddi4+0xa4>
 800af70:	b902      	cbnz	r2, 800af74 <__udivmoddi4+0xec>
 800af72:	deff      	udf	#255	; 0xff
 800af74:	fab2 f282 	clz	r2, r2
 800af78:	2a00      	cmp	r2, #0
 800af7a:	f040 8092 	bne.w	800b0a2 <__udivmoddi4+0x21a>
 800af7e:	eba1 010c 	sub.w	r1, r1, ip
 800af82:	ea4f 471c 	mov.w	r7, ip, lsr #16
 800af86:	fa1f fe8c 	uxth.w	lr, ip
 800af8a:	2601      	movs	r6, #1
 800af8c:	0c20      	lsrs	r0, r4, #16
 800af8e:	fbb1 f3f7 	udiv	r3, r1, r7
 800af92:	fb07 1113 	mls	r1, r7, r3, r1
 800af96:	ea40 4101 	orr.w	r1, r0, r1, lsl #16
 800af9a:	fb0e f003 	mul.w	r0, lr, r3
 800af9e:	4288      	cmp	r0, r1
 800afa0:	d908      	bls.n	800afb4 <__udivmoddi4+0x12c>
 800afa2:	eb1c 0101 	adds.w	r1, ip, r1
 800afa6:	f103 38ff 	add.w	r8, r3, #4294967295
 800afaa:	d202      	bcs.n	800afb2 <__udivmoddi4+0x12a>
 800afac:	4288      	cmp	r0, r1
 800afae:	f200 80cb 	bhi.w	800b148 <__udivmoddi4+0x2c0>
 800afb2:	4643      	mov	r3, r8
 800afb4:	1a09      	subs	r1, r1, r0
 800afb6:	b2a4      	uxth	r4, r4
 800afb8:	fbb1 f0f7 	udiv	r0, r1, r7
 800afbc:	fb07 1110 	mls	r1, r7, r0, r1
 800afc0:	ea44 4401 	orr.w	r4, r4, r1, lsl #16
 800afc4:	fb0e fe00 	mul.w	lr, lr, r0
 800afc8:	45a6      	cmp	lr, r4
 800afca:	d908      	bls.n	800afde <__udivmoddi4+0x156>
 800afcc:	eb1c 0404 	adds.w	r4, ip, r4
 800afd0:	f100 31ff 	add.w	r1, r0, #4294967295
 800afd4:	d202      	bcs.n	800afdc <__udivmoddi4+0x154>
 800afd6:	45a6      	cmp	lr, r4
 800afd8:	f200 80bb 	bhi.w	800b152 <__udivmoddi4+0x2ca>
 800afdc:	4608      	mov	r0, r1
 800afde:	eba4 040e 	sub.w	r4, r4, lr
 800afe2:	ea40 4003 	orr.w	r0, r0, r3, lsl #16
 800afe6:	e79c      	b.n	800af22 <__udivmoddi4+0x9a>
 800afe8:	f1c6 0720 	rsb	r7, r6, #32
 800afec:	40b3      	lsls	r3, r6
 800afee:	fa22 fc07 	lsr.w	ip, r2, r7
 800aff2:	ea4c 0c03 	orr.w	ip, ip, r3
 800aff6:	fa20 f407 	lsr.w	r4, r0, r7
 800affa:	fa01 f306 	lsl.w	r3, r1, r6
 800affe:	431c      	orrs	r4, r3
 800b000:	40f9      	lsrs	r1, r7
 800b002:	ea4f 491c 	mov.w	r9, ip, lsr #16
 800b006:	fa00 f306 	lsl.w	r3, r0, r6
 800b00a:	fbb1 f8f9 	udiv	r8, r1, r9
 800b00e:	0c20      	lsrs	r0, r4, #16
 800b010:	fa1f fe8c 	uxth.w	lr, ip
 800b014:	fb09 1118 	mls	r1, r9, r8, r1
 800b018:	ea40 4101 	orr.w	r1, r0, r1, lsl #16
 800b01c:	fb08 f00e 	mul.w	r0, r8, lr
 800b020:	4288      	cmp	r0, r1
 800b022:	fa02 f206 	lsl.w	r2, r2, r6
 800b026:	d90b      	bls.n	800b040 <__udivmoddi4+0x1b8>
 800b028:	eb1c 0101 	adds.w	r1, ip, r1
 800b02c:	f108 3aff 	add.w	sl, r8, #4294967295
 800b030:	f080 8088 	bcs.w	800b144 <__udivmoddi4+0x2bc>
 800b034:	4288      	cmp	r0, r1
 800b036:	f240 8085 	bls.w	800b144 <__udivmoddi4+0x2bc>
 800b03a:	f1a8 0802 	sub.w	r8, r8, #2
 800b03e:	4461      	add	r1, ip
 800b040:	1a09      	subs	r1, r1, r0
 800b042:	b2a4      	uxth	r4, r4
 800b044:	fbb1 f0f9 	udiv	r0, r1, r9
 800b048:	fb09 1110 	mls	r1, r9, r0, r1
 800b04c:	ea44 4101 	orr.w	r1, r4, r1, lsl #16
 800b050:	fb00 fe0e 	mul.w	lr, r0, lr
 800b054:	458e      	cmp	lr, r1
 800b056:	d908      	bls.n	800b06a <__udivmoddi4+0x1e2>
 800b058:	eb1c 0101 	adds.w	r1, ip, r1
 800b05c:	f100 34ff 	add.w	r4, r0, #4294967295
 800b060:	d26c      	bcs.n	800b13c <__udivmoddi4+0x2b4>
 800b062:	458e      	cmp	lr, r1
 800b064:	d96a      	bls.n	800b13c <__udivmoddi4+0x2b4>
 800b066:	3802      	subs	r0, #2
 800b068:	4461      	add	r1, ip
 800b06a:	ea40 4008 	orr.w	r0, r0, r8, lsl #16
 800b06e:	fba0 9402 	umull	r9, r4, r0, r2
 800b072:	eba1 010e 	sub.w	r1, r1, lr
 800b076:	42a1      	cmp	r1, r4
 800b078:	46c8      	mov	r8, r9
 800b07a:	46a6      	mov	lr, r4
 800b07c:	d356      	bcc.n	800b12c <__udivmoddi4+0x2a4>
 800b07e:	d053      	beq.n	800b128 <__udivmoddi4+0x2a0>
 800b080:	b15d      	cbz	r5, 800b09a <__udivmoddi4+0x212>
 800b082:	ebb3 0208 	subs.w	r2, r3, r8
 800b086:	eb61 010e 	sbc.w	r1, r1, lr
 800b08a:	fa01 f707 	lsl.w	r7, r1, r7
 800b08e:	fa22 f306 	lsr.w	r3, r2, r6
 800b092:	40f1      	lsrs	r1, r6
 800b094:	431f      	orrs	r7, r3
 800b096:	e9c5 7100 	strd	r7, r1, [r5]
 800b09a:	2600      	movs	r6, #0
 800b09c:	4631      	mov	r1, r6
 800b09e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 800b0a2:	f1c2 0320 	rsb	r3, r2, #32
 800b0a6:	40d8      	lsrs	r0, r3
 800b0a8:	fa0c fc02 	lsl.w	ip, ip, r2
 800b0ac:	fa21 f303 	lsr.w	r3, r1, r3
 800b0b0:	4091      	lsls	r1, r2
 800b0b2:	4301      	orrs	r1, r0
 800b0b4:	ea4f 471c 	mov.w	r7, ip, lsr #16
 800b0b8:	fa1f fe8c 	uxth.w	lr, ip
 800b0bc:	fbb3 f0f7 	udiv	r0, r3, r7
 800b0c0:	fb07 3610 	mls	r6, r7, r0, r3
 800b0c4:	0c0b      	lsrs	r3, r1, #16
 800b0c6:	ea43 4306 	orr.w	r3, r3, r6, lsl #16
 800b0ca:	fb00 f60e 	mul.w	r6, r0, lr
 800b0ce:	429e      	cmp	r6, r3
 800b0d0:	fa04 f402 	lsl.w	r4, r4, r2
 800b0d4:	d908      	bls.n	800b0e8 <__udivmoddi4+0x260>
 800b0d6:	eb1c 0303 	adds.w	r3, ip, r3
 800b0da:	f100 38ff 	add.w	r8, r0, #4294967295
 800b0de:	d22f      	bcs.n	800b140 <__udivmoddi4+0x2b8>
 800b0e0:	429e      	cmp	r6, r3
 800b0e2:	d92d      	bls.n	800b140 <__udivmoddi4+0x2b8>
 800b0e4:	3802      	subs	r0, #2
 800b0e6:	4463      	add	r3, ip
 800b0e8:	1b9b      	subs	r3, r3, r6
 800b0ea:	b289      	uxth	r1, r1
 800b0ec:	fbb3 f6f7 	udiv	r6, r3, r7
 800b0f0:	fb07 3316 	mls	r3, r7, r6, r3
 800b0f4:	ea41 4103 	orr.w	r1, r1, r3, lsl #16
 800b0f8:	fb06 f30e 	mul.w	r3, r6, lr
 800b0fc:	428b      	cmp	r3, r1
 800b0fe:	d908      	bls.n	800b112 <__udivmoddi4+0x28a>
 800b100:	eb1c 0101 	adds.w	r1, ip, r1
 800b104:	f106 38ff 	add.w	r8, r6, #4294967295
 800b108:	d216      	bcs.n	800b138 <__udivmoddi4+0x2b0>
 800b10a:	428b      	cmp	r3, r1
 800b10c:	d914      	bls.n	800b138 <__udivmoddi4+0x2b0>
 800b10e:	3e02      	subs	r6, #2
 800b110:	4461      	add	r1, ip
 800b112:	1ac9      	subs	r1, r1, r3
 800b114:	ea46 4600 	orr.w	r6, r6, r0, lsl #16
 800b118:	e738      	b.n	800af8c <__udivmoddi4+0x104>
 800b11a:	462e      	mov	r6, r5
 800b11c:	4628      	mov	r0, r5
 800b11e:	e705      	b.n	800af2c <__udivmoddi4+0xa4>
 800b120:	4606      	mov	r6, r0
 800b122:	e6e3      	b.n	800aeec <__udivmoddi4+0x64>
 800b124:	4618      	mov	r0, r3
 800b126:	e6f8      	b.n	800af1a <__udivmoddi4+0x92>
 800b128:	454b      	cmp	r3, r9
 800b12a:	d2a9      	bcs.n	800b080 <__udivmoddi4+0x1f8>
 800b12c:	ebb9 0802 	subs.w	r8, r9, r2
 800b130:	eb64 0e0c 	sbc.w	lr, r4, ip
 800b134:	3801      	subs	r0, #1
 800b136:	e7a3      	b.n	800b080 <__udivmoddi4+0x1f8>
 800b138:	4646      	mov	r6, r8
 800b13a:	e7ea      	b.n	800b112 <__udivmoddi4+0x28a>
 800b13c:	4620      	mov	r0, r4
 800b13e:	e794      	b.n	800b06a <__udivmoddi4+0x1e2>
 800b140:	4640      	mov	r0, r8
 800b142:	e7d1      	b.n	800b0e8 <__udivmoddi4+0x260>
 800b144:	46d0      	mov	r8, sl
 800b146:	e77b      	b.n	800b040 <__udivmoddi4+0x1b8>
 800b148:	3b02      	subs	r3, #2
 800b14a:	4461      	add	r1, ip
 800b14c:	e732      	b.n	800afb4 <__udivmoddi4+0x12c>
 800b14e:	4630      	mov	r0, r6
 800b150:	e709      	b.n	800af66 <__udivmoddi4+0xde>
 800b152:	4464      	add	r4, ip
 800b154:	3802      	subs	r0, #2
 800b156:	e742      	b.n	800afde <__udivmoddi4+0x156>

0800b158 <__aeabi_idiv0>:
 800b158:	4770      	bx	lr
 800b15a:	bf00      	nop

0800b15c <BSP_LED_Init>:
{
  int32_t          status = BSP_ERROR_NONE;
  GPIO_InitTypeDef GPIO_Init;

  /* Enable the GPIO_LED Clock */
  LED2_GPIO_CLK_ENABLE();
 800b15c:	4b10      	ldr	r3, [pc, #64]	; (800b1a0 <BSP_LED_Init+0x44>)
  /* configure the GPIO_LED pin */
  GPIO_Init.Pin   = LED_PIN[Led];
  GPIO_Init.Mode  = GPIO_MODE_OUTPUT_PP;
  GPIO_Init.Pull  = GPIO_PULLDOWN;
  GPIO_Init.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
  HAL_GPIO_Init(LED_PORT[Led], &GPIO_Init);
 800b15e:	4811      	ldr	r0, [pc, #68]	; (800b1a4 <BSP_LED_Init+0x48>)
  LED2_GPIO_CLK_ENABLE();
 800b160:	6cda      	ldr	r2, [r3, #76]	; 0x4c
{
 800b162:	b510      	push	{r4, lr}
  LED2_GPIO_CLK_ENABLE();
 800b164:	f042 0202 	orr.w	r2, r2, #2
 800b168:	64da      	str	r2, [r3, #76]	; 0x4c
 800b16a:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
{
 800b16c:	b086      	sub	sp, #24
  LED2_GPIO_CLK_ENABLE();
 800b16e:	f003 0302 	and.w	r3, r3, #2
 800b172:	9300      	str	r3, [sp, #0]
  GPIO_Init.Pull  = GPIO_PULLDOWN;
 800b174:	2302      	movs	r3, #2
  GPIO_Init.Pin   = LED_PIN[Led];
 800b176:	f44f 4480 	mov.w	r4, #16384	; 0x4000
  GPIO_Init.Mode  = GPIO_MODE_OUTPUT_PP;
 800b17a:	2201      	movs	r2, #1
  HAL_GPIO_Init(LED_PORT[Led], &GPIO_Init);
 800b17c:	a901      	add	r1, sp, #4
  GPIO_Init.Pull  = GPIO_PULLDOWN;
 800b17e:	9303      	str	r3, [sp, #12]
  LED2_GPIO_CLK_ENABLE();
 800b180:	9b00      	ldr	r3, [sp, #0]
  GPIO_Init.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 800b182:	2303      	movs	r3, #3
  GPIO_Init.Mode  = GPIO_MODE_OUTPUT_PP;
 800b184:	e9cd 4201 	strd	r4, r2, [sp, #4]
  GPIO_Init.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 800b188:	9304      	str	r3, [sp, #16]
  HAL_GPIO_Init(LED_PORT[Led], &GPIO_Init);
 800b18a:	f005 fb57 	bl	801083c <HAL_GPIO_Init>

  HAL_GPIO_WritePin(LED_PORT[Led], LED_PIN[Led], GPIO_PIN_RESET);
 800b18e:	4805      	ldr	r0, [pc, #20]	; (800b1a4 <BSP_LED_Init+0x48>)
 800b190:	2200      	movs	r2, #0
 800b192:	4621      	mov	r1, r4
 800b194:	f005 fd24 	bl	8010be0 <HAL_GPIO_WritePin>

  return status;
}
 800b198:	2000      	movs	r0, #0
 800b19a:	b006      	add	sp, #24
 800b19c:	bd10      	pop	{r4, pc}
 800b19e:	bf00      	nop
 800b1a0:	40021000 	.word	0x40021000
 800b1a4:	48000400 	.word	0x48000400

0800b1a8 <BSP_LED_On>:
  *   This parameter can be one of following parameters:
  *     @arg  LED2
  * @retval BSP error code
  */
int32_t BSP_LED_On(Led_TypeDef Led)
{
 800b1a8:	b508      	push	{r3, lr}
  int32_t status = BSP_ERROR_NONE;

  HAL_GPIO_WritePin(LED_PORT[Led], LED_PIN[Led], GPIO_PIN_SET);
 800b1aa:	4804      	ldr	r0, [pc, #16]	; (800b1bc <BSP_LED_On+0x14>)
 800b1ac:	2201      	movs	r2, #1
 800b1ae:	f44f 4180 	mov.w	r1, #16384	; 0x4000
 800b1b2:	f005 fd15 	bl	8010be0 <HAL_GPIO_WritePin>

  return status;
}
 800b1b6:	2000      	movs	r0, #0
 800b1b8:	bd08      	pop	{r3, pc}
 800b1ba:	bf00      	nop
 800b1bc:	48000400 	.word	0x48000400

0800b1c0 <BSP_LED_Off>:
  *   This parameter can be one of following parameters:
  *     @arg  LED2
  * @retval BSP error code
  */
int32_t BSP_LED_Off(Led_TypeDef Led)
{
 800b1c0:	b508      	push	{r3, lr}
  int32_t status = BSP_ERROR_NONE;

  HAL_GPIO_WritePin(LED_PORT[Led], LED_PIN[Led], GPIO_PIN_RESET);
 800b1c2:	4804      	ldr	r0, [pc, #16]	; (800b1d4 <BSP_LED_Off+0x14>)
 800b1c4:	2200      	movs	r2, #0
 800b1c6:	f44f 4180 	mov.w	r1, #16384	; 0x4000
 800b1ca:	f005 fd09 	bl	8010be0 <HAL_GPIO_WritePin>

  return status;
}
 800b1ce:	2000      	movs	r0, #0
 800b1d0:	bd08      	pop	{r3, pc}
 800b1d2:	bf00      	nop
 800b1d4:	48000400 	.word	0x48000400

0800b1d8 <BSP_PB_Init>:
  uint32_t              BSP_BUTTON_IT_PRIO[BUTTONn] = {BSP_BUTTON_USER_IT_PRIORITY};
  uint32_t              BUTTON_EXTI_LINE[BUTTONn]   = {BUTTON_USER_EXTI_LINE};
  BSP_EXTI_LineCallback ButtonCallback[BUTTONn]     = {BUTTON_USER_EXTI_Callback};

  /* Enable the BUTTON clock */
  BUTTON_USER_GPIO_CLK_ENABLE();
 800b1d8:	4b22      	ldr	r3, [pc, #136]	; (800b264 <BSP_PB_Init+0x8c>)
{
 800b1da:	b530      	push	{r4, r5, lr}
  BUTTON_USER_GPIO_CLK_ENABLE();
 800b1dc:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 800b1de:	f042 0204 	orr.w	r2, r2, #4
 800b1e2:	64da      	str	r2, [r3, #76]	; 0x4c
 800b1e4:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
{
 800b1e6:	b087      	sub	sp, #28
  BUTTON_USER_GPIO_CLK_ENABLE();
 800b1e8:	f003 0304 	and.w	r3, r3, #4

  GPIO_Init.Pin   = BUTTON_PIN[Button];
 800b1ec:	f44f 5400 	mov.w	r4, #8192	; 0x2000
  BUTTON_USER_GPIO_CLK_ENABLE();
 800b1f0:	9300      	str	r3, [sp, #0]
  GPIO_Init.Pull  = GPIO_NOPULL;
 800b1f2:	2200      	movs	r2, #0
  GPIO_Init.Speed = GPIO_SPEED_FREQ_HIGH;
 800b1f4:	2302      	movs	r3, #2
  GPIO_Init.Pin   = BUTTON_PIN[Button];
 800b1f6:	9401      	str	r4, [sp, #4]
  GPIO_Init.Speed = GPIO_SPEED_FREQ_HIGH;
 800b1f8:	e9cd 2303 	strd	r2, r3, [sp, #12]
  BUTTON_USER_GPIO_CLK_ENABLE();
 800b1fc:	9d00      	ldr	r5, [sp, #0]

  if (ButtonMode == BUTTON_MODE_GPIO)
 800b1fe:	460c      	mov	r4, r1
 800b200:	b329      	cbz	r1, 800b24e <BSP_PB_Init+0x76>
    /* Configure Button pin as input */
    GPIO_Init.Mode = GPIO_MODE_INPUT;
    HAL_GPIO_Init(BUTTON_PORT[Button], &GPIO_Init);
  }

  if (ButtonMode == BUTTON_MODE_EXTI)
 800b202:	2901      	cmp	r1, #1
 800b204:	d002      	beq.n	800b20c <BSP_PB_Init+0x34>
  int32_t               status = BSP_ERROR_NONE;
 800b206:	4610      	mov	r0, r2
      status = BSP_ERROR_PERIPH_FAILURE;
    }  
  }

  return status;
}
 800b208:	b007      	add	sp, #28
 800b20a:	bd30      	pop	{r4, r5, pc}
    GPIO_Init.Mode = GPIO_MODE_IT_FALLING;
 800b20c:	4b16      	ldr	r3, [pc, #88]	; (800b268 <BSP_PB_Init+0x90>)
 800b20e:	9302      	str	r3, [sp, #8]
    HAL_GPIO_Init(BUTTON_PORT[Button], &GPIO_Init);
 800b210:	4605      	mov	r5, r0
 800b212:	a901      	add	r1, sp, #4
 800b214:	4815      	ldr	r0, [pc, #84]	; (800b26c <BSP_PB_Init+0x94>)
 800b216:	f005 fb11 	bl	801083c <HAL_GPIO_Init>
    if (HAL_EXTI_GetHandle(&hpb_exti[Button], BUTTON_EXTI_LINE[Button]) == HAL_OK)
 800b21a:	4815      	ldr	r0, [pc, #84]	; (800b270 <BSP_PB_Init+0x98>)
 800b21c:	4915      	ldr	r1, [pc, #84]	; (800b274 <BSP_PB_Init+0x9c>)
 800b21e:	eb00 05c5 	add.w	r5, r0, r5, lsl #3
 800b222:	4628      	mov	r0, r5
 800b224:	f005 f968 	bl	80104f8 <HAL_EXTI_GetHandle>
 800b228:	4601      	mov	r1, r0
 800b22a:	b9c0      	cbnz	r0, 800b25e <BSP_PB_Init+0x86>
      if (HAL_EXTI_RegisterCallback(&hpb_exti[Button], HAL_EXTI_COMMON_CB_ID, ButtonCallback[Button]) == HAL_OK)
 800b22c:	4a12      	ldr	r2, [pc, #72]	; (800b278 <BSP_PB_Init+0xa0>)
 800b22e:	4628      	mov	r0, r5
 800b230:	f005 f95c 	bl	80104ec <HAL_EXTI_RegisterCallback>
 800b234:	4604      	mov	r4, r0
 800b236:	b990      	cbnz	r0, 800b25e <BSP_PB_Init+0x86>
        HAL_NVIC_SetPriority(BUTTON_IRQn[Button], BSP_BUTTON_IT_PRIO[Button], 0x00);
 800b238:	4602      	mov	r2, r0
 800b23a:	210f      	movs	r1, #15
 800b23c:	2028      	movs	r0, #40	; 0x28
 800b23e:	f004 fb1f 	bl	800f880 <HAL_NVIC_SetPriority>
        HAL_NVIC_EnableIRQ(BUTTON_IRQn[Button]);
 800b242:	2028      	movs	r0, #40	; 0x28
 800b244:	f004 fb5a 	bl	800f8fc <HAL_NVIC_EnableIRQ>
  int32_t               status = BSP_ERROR_NONE;
 800b248:	4620      	mov	r0, r4
}
 800b24a:	b007      	add	sp, #28
 800b24c:	bd30      	pop	{r4, r5, pc}
    HAL_GPIO_Init(BUTTON_PORT[Button], &GPIO_Init);
 800b24e:	4807      	ldr	r0, [pc, #28]	; (800b26c <BSP_PB_Init+0x94>)
    GPIO_Init.Mode = GPIO_MODE_INPUT;
 800b250:	9402      	str	r4, [sp, #8]
    HAL_GPIO_Init(BUTTON_PORT[Button], &GPIO_Init);
 800b252:	a901      	add	r1, sp, #4
 800b254:	f005 faf2 	bl	801083c <HAL_GPIO_Init>
  int32_t               status = BSP_ERROR_NONE;
 800b258:	4620      	mov	r0, r4
}
 800b25a:	b007      	add	sp, #28
 800b25c:	bd30      	pop	{r4, r5, pc}
      status = BSP_ERROR_PERIPH_FAILURE;
 800b25e:	f06f 0003 	mvn.w	r0, #3
 800b262:	e7d1      	b.n	800b208 <BSP_PB_Init+0x30>
 800b264:	40021000 	.word	0x40021000
 800b268:	10210000 	.word	0x10210000
 800b26c:	48000800 	.word	0x48000800
 800b270:	2000220c 	.word	0x2000220c
 800b274:	1600000d 	.word	0x1600000d
 800b278:	0800b299 	.word	0x0800b299

0800b27c <BSP_PB_GetState>:
  *   This parameter should be:
  *     @arg BUTTON_USER
  * @retval 0 means released, 1 means pressed.
  */
int32_t BSP_PB_GetState(Button_TypeDef Button)
{
 800b27c:	b508      	push	{r3, lr}
  int32_t status;

  status = (HAL_GPIO_ReadPin(BUTTON_PORT[Button], BUTTON_PIN[Button]) == GPIO_PIN_SET) ? 0 : 1;
 800b27e:	f44f 5100 	mov.w	r1, #8192	; 0x2000
 800b282:	4803      	ldr	r0, [pc, #12]	; (800b290 <BSP_PB_GetState+0x14>)
 800b284:	f005 fca6 	bl	8010bd4 <HAL_GPIO_ReadPin>

  return status;
}
 800b288:	3801      	subs	r0, #1
 800b28a:	bf18      	it	ne
 800b28c:	2001      	movne	r0, #1
 800b28e:	bd08      	pop	{r3, pc}
 800b290:	48000800 	.word	0x48000800

0800b294 <BSP_PB_Callback>:
  /* Prevent unused argument(s) compilation warning */
  UNUSED(Button);

  /* This function should be implemented by the user application.
     It is called into this driver when an event on Button is triggered. */
}
 800b294:	4770      	bx	lr
 800b296:	bf00      	nop

0800b298 <BUTTON_USER_EXTI_Callback>:
/**
  * @brief  User EXTI line detection callbacks.
  * @retval None
  */
static void BUTTON_USER_EXTI_Callback(void)
{
 800b298:	b508      	push	{r3, lr}
  BSP_PB_Callback(BUTTON_USER);
 800b29a:	2000      	movs	r0, #0
 800b29c:	f7ff fffa 	bl	800b294 <BSP_PB_Callback>
}
 800b2a0:	bd08      	pop	{r3, pc}
 800b2a2:	bf00      	nop

0800b2a4 <MX_USART1_Init>:
{
 800b2a4:	b430      	push	{r4, r5}
  huart->Init.WordLength     = (uint32_t) MXInit->WordLength;
 800b2a6:	e9d1 4200 	ldrd	r4, r2, [r1]
  huart->Init.StopBits       = (uint32_t) MXInit->StopBits;
 800b2aa:	890d      	ldrh	r5, [r1, #8]
  huart->Init.WordLength     = (uint32_t) MXInit->WordLength;
 800b2ac:	e9c0 4201 	strd	r4, r2, [r0, #4]
  huart->Init.Parity         = (uint32_t) MXInit->Parity;
 800b2b0:	894c      	ldrh	r4, [r1, #10]
  huart->Init.HwFlowCtl      = (uint32_t) MXInit->HwFlowCtl;
 800b2b2:	898a      	ldrh	r2, [r1, #12]
  huart->Init.Parity         = (uint32_t) MXInit->Parity;
 800b2b4:	e9c0 5403 	strd	r5, r4, [r0, #12]
  huart->Init.Mode           = UART_MODE_TX_RX;
 800b2b8:	240c      	movs	r4, #12
  huart->Init.HwFlowCtl      = (uint32_t) MXInit->HwFlowCtl;
 800b2ba:	e9c0 4205 	strd	r4, r2, [r0, #20]
  huart->Init.OverSampling   = UART_OVERSAMPLING_8;
 800b2be:	f44f 4100 	mov.w	r1, #32768	; 0x8000
  huart->Init.OneBitSampling = UART_ONE_BIT_SAMPLE_DISABLE;
 800b2c2:	2200      	movs	r2, #0
}
 800b2c4:	bc30      	pop	{r4, r5}
  huart->Init.OneBitSampling = UART_ONE_BIT_SAMPLE_DISABLE;
 800b2c6:	e9c0 1207 	strd	r1, r2, [r0, #28]
  return HAL_UART_Init(huart);
 800b2ca:	f009 bd49 	b.w	8014d60 <HAL_UART_Init>
 800b2ce:	bf00      	nop

0800b2d0 <MX_UART4_Init>:
 800b2d0:	b430      	push	{r4, r5}
 800b2d2:	e9d1 4200 	ldrd	r4, r2, [r1]
 800b2d6:	890d      	ldrh	r5, [r1, #8]
 800b2d8:	e9c0 4201 	strd	r4, r2, [r0, #4]
 800b2dc:	894c      	ldrh	r4, [r1, #10]
 800b2de:	898a      	ldrh	r2, [r1, #12]
 800b2e0:	e9c0 5403 	strd	r5, r4, [r0, #12]
 800b2e4:	240c      	movs	r4, #12
 800b2e6:	e9c0 4205 	strd	r4, r2, [r0, #20]
 800b2ea:	f44f 4100 	mov.w	r1, #32768	; 0x8000
 800b2ee:	2200      	movs	r2, #0
 800b2f0:	bc30      	pop	{r4, r5}
 800b2f2:	e9c0 1207 	strd	r1, r2, [r0, #28]
 800b2f6:	f009 bd33 	b.w	8014d60 <HAL_UART_Init>
 800b2fa:	bf00      	nop

0800b2fc <BSP_COM_Init>:
  if (COM_Init == NULL)
 800b2fc:	2900      	cmp	r1, #0
 800b2fe:	f000 80a0 	beq.w	800b442 <BSP_COM_Init+0x146>
{
 800b302:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 800b306:	4604      	mov	r4, r0
    hcom_uart[COM].Instance = COM_UART[COM];
 800b308:	484f      	ldr	r0, [pc, #316]	; (800b448 <BSP_COM_Init+0x14c>)
 800b30a:	4b50      	ldr	r3, [pc, #320]	; (800b44c <BSP_COM_Init+0x150>)
 800b30c:	eb00 12c4 	add.w	r2, r0, r4, lsl #7
{
 800b310:	b095      	sub	sp, #84	; 0x54
    hcom_uart[COM].Instance = COM_UART[COM];
 800b312:	f853 3024 	ldr.w	r3, [r3, r4, lsl #2]
 800b316:	6093      	str	r3, [r2, #8]
  * @retval None.
  */
static void UART_MspInit(UART_HandleTypeDef *huart)
{
  GPIO_InitTypeDef GPIO_Init;
  GPIO_TypeDef    *COM_TX_PORT[COMn] = {COM1_TX_GPIO_PORT, COM2_TX_GPIO_PORT};
 800b318:	4a4d      	ldr	r2, [pc, #308]	; (800b450 <BSP_COM_Init+0x154>)
 800b31a:	920b      	str	r2, [sp, #44]	; 0x2c
  GPIO_TypeDef    *COM_RX_PORT[COMn] = {COM1_RX_GPIO_PORT, COM2_RX_GPIO_PORT};
 800b31c:	920d      	str	r2, [sp, #52]	; 0x34
  uint16_t         COM_TX_PIN[COMn]  = {COM1_TX_PIN, COM2_TX_PIN};
 800b31e:	2240      	movs	r2, #64	; 0x40
 800b320:	f8ad 200c 	strh.w	r2, [sp, #12]
 800b324:	2201      	movs	r2, #1
 800b326:	f8ad 200e 	strh.w	r2, [sp, #14]
  uint16_t         COM_RX_PIN[COMn]  = {COM1_RX_PIN, COM2_RX_PIN};
 800b32a:	2280      	movs	r2, #128	; 0x80
 800b32c:	f8ad 2010 	strh.w	r2, [sp, #16]
 800b330:	2202      	movs	r2, #2
 800b332:	f8ad 2012 	strh.w	r2, [sp, #18]
  uint8_t          COM_TX_AF[COMn]   = {COM1_TX_AF, COM2_TX_AF};
 800b336:	f640 0207 	movw	r2, #2055	; 0x807
 800b33a:	f8ad 2004 	strh.w	r2, [sp, #4]
  uint8_t          COM_RX_AF[COMn]   = {COM1_RX_AF, COM2_RX_AF};
 800b33e:	f8ad 2008 	strh.w	r2, [sp, #8]
  COM_TypeDef      COM;

  /* Get COM according instance */
  COM = (huart->Instance == COM1_INSTANCE) ? COM1 : COM2;
 800b342:	4a44      	ldr	r2, [pc, #272]	; (800b454 <BSP_COM_Init+0x158>)
    UART_MspInit(&hcom_uart[COM]);
 800b344:	3008      	adds	r0, #8
  COM = (huart->Instance == COM1_INSTANCE) ? COM1 : COM2;
 800b346:	4293      	cmp	r3, r2
  GPIO_TypeDef    *COM_TX_PORT[COMn] = {COM1_TX_GPIO_PORT, COM2_TX_GPIO_PORT};
 800b348:	f04f 4290 	mov.w	r2, #1207959552	; 0x48000000
 800b34c:	460f      	mov	r7, r1
    UART_MspInit(&hcom_uart[COM]);
 800b34e:	eb00 15c4 	add.w	r5, r0, r4, lsl #7
  COM = (huart->Instance == COM1_INSTANCE) ? COM1 : COM2;
 800b352:	bf14      	ite	ne
 800b354:	2301      	movne	r3, #1
 800b356:	2300      	moveq	r3, #0
  GPIO_TypeDef    *COM_TX_PORT[COMn] = {COM1_TX_GPIO_PORT, COM2_TX_GPIO_PORT};
 800b358:	920c      	str	r2, [sp, #48]	; 0x30
  GPIO_TypeDef    *COM_RX_PORT[COMn] = {COM1_RX_GPIO_PORT, COM2_RX_GPIO_PORT};
 800b35a:	920e      	str	r2, [sp, #56]	; 0x38

  /* Enable COM and GPIO clocks */
  if (COM == COM1)
 800b35c:	d051      	beq.n	800b402 <BSP_COM_Init+0x106>
    COM1_RX_GPIO_CLK_ENABLE();
    COM1_CLK_ENABLE();
  }
  else /* COM = COM2 */
  {
    COM2_TX_GPIO_CLK_ENABLE();
 800b35e:	4a3e      	ldr	r2, [pc, #248]	; (800b458 <BSP_COM_Init+0x15c>)
 800b360:	6cd1      	ldr	r1, [r2, #76]	; 0x4c
 800b362:	f041 0101 	orr.w	r1, r1, #1
 800b366:	64d1      	str	r1, [r2, #76]	; 0x4c
 800b368:	6cd1      	ldr	r1, [r2, #76]	; 0x4c
 800b36a:	f001 0101 	and.w	r1, r1, #1
 800b36e:	9108      	str	r1, [sp, #32]
 800b370:	9908      	ldr	r1, [sp, #32]
    COM2_RX_GPIO_CLK_ENABLE();
 800b372:	6cd1      	ldr	r1, [r2, #76]	; 0x4c
 800b374:	f041 0101 	orr.w	r1, r1, #1
 800b378:	64d1      	str	r1, [r2, #76]	; 0x4c
 800b37a:	6cd1      	ldr	r1, [r2, #76]	; 0x4c
 800b37c:	f001 0101 	and.w	r1, r1, #1
 800b380:	9109      	str	r1, [sp, #36]	; 0x24
 800b382:	9909      	ldr	r1, [sp, #36]	; 0x24
    COM2_CLK_ENABLE();
 800b384:	6d91      	ldr	r1, [r2, #88]	; 0x58
 800b386:	f441 2100 	orr.w	r1, r1, #524288	; 0x80000
 800b38a:	6591      	str	r1, [r2, #88]	; 0x58
 800b38c:	6d92      	ldr	r2, [r2, #88]	; 0x58
 800b38e:	f402 2200 	and.w	r2, r2, #524288	; 0x80000
 800b392:	920a      	str	r2, [sp, #40]	; 0x28
 800b394:	9a0a      	ldr	r2, [sp, #40]	; 0x28
  }

  /* Configure COM Tx as alternate function */
  GPIO_Init.Pin       = COM_TX_PIN[COM];
 800b396:	aa14      	add	r2, sp, #80	; 0x50
 800b398:	eb02 0943 	add.w	r9, r2, r3, lsl #1
  GPIO_Init.Mode      = GPIO_MODE_AF_PP;
  GPIO_Init.Speed     = GPIO_SPEED_FREQ_HIGH;
  GPIO_Init.Pull      = GPIO_PULLUP;
  GPIO_Init.Alternate = COM_TX_AF[COM];
 800b39c:	f103 0250 	add.w	r2, r3, #80	; 0x50
 800b3a0:	eb0d 0802 	add.w	r8, sp, r2
  HAL_GPIO_Init(COM_TX_PORT[COM], &GPIO_Init);
 800b3a4:	aa14      	add	r2, sp, #80	; 0x50
 800b3a6:	eb02 0683 	add.w	r6, r2, r3, lsl #2
  GPIO_Init.Pin       = COM_TX_PIN[COM];
 800b3aa:	f839 3c44 	ldrh.w	r3, [r9, #-68]
 800b3ae:	930f      	str	r3, [sp, #60]	; 0x3c
  GPIO_Init.Alternate = COM_TX_AF[COM];
 800b3b0:	f818 3c4c 	ldrb.w	r3, [r8, #-76]
 800b3b4:	9313      	str	r3, [sp, #76]	; 0x4c
  GPIO_Init.Mode      = GPIO_MODE_AF_PP;
 800b3b6:	2302      	movs	r3, #2
  HAL_GPIO_Init(COM_TX_PORT[COM], &GPIO_Init);
 800b3b8:	f856 0c24 	ldr.w	r0, [r6, #-36]
  GPIO_Init.Mode      = GPIO_MODE_AF_PP;
 800b3bc:	9310      	str	r3, [sp, #64]	; 0x40
  GPIO_Init.Speed     = GPIO_SPEED_FREQ_HIGH;
 800b3be:	9312      	str	r3, [sp, #72]	; 0x48
  HAL_GPIO_Init(COM_TX_PORT[COM], &GPIO_Init);
 800b3c0:	a90f      	add	r1, sp, #60	; 0x3c
  GPIO_Init.Pull      = GPIO_PULLUP;
 800b3c2:	2301      	movs	r3, #1
 800b3c4:	9311      	str	r3, [sp, #68]	; 0x44
  HAL_GPIO_Init(COM_TX_PORT[COM], &GPIO_Init);
 800b3c6:	f005 fa39 	bl	801083c <HAL_GPIO_Init>

  /* Configure COM Rx as alternate function */
  GPIO_Init.Pin       = COM_RX_PIN[COM];
 800b3ca:	f839 3c40 	ldrh.w	r3, [r9, #-64]
  GPIO_Init.Alternate = COM_RX_AF[COM];
  HAL_GPIO_Init(COM_RX_PORT[COM], &GPIO_Init);
 800b3ce:	f856 0c1c 	ldr.w	r0, [r6, #-28]
  GPIO_Init.Pin       = COM_RX_PIN[COM];
 800b3d2:	930f      	str	r3, [sp, #60]	; 0x3c
  HAL_GPIO_Init(COM_RX_PORT[COM], &GPIO_Init);
 800b3d4:	a90f      	add	r1, sp, #60	; 0x3c
  GPIO_Init.Alternate = COM_RX_AF[COM];
 800b3d6:	f818 3c48 	ldrb.w	r3, [r8, #-72]
 800b3da:	9313      	str	r3, [sp, #76]	; 0x4c
  HAL_GPIO_Init(COM_RX_PORT[COM], &GPIO_Init);
 800b3dc:	f005 fa2e 	bl	801083c <HAL_GPIO_Init>
        if (MX_USART1_Init(&hcom_uart[COM], COM_Init) != HAL_OK)
 800b3e0:	4639      	mov	r1, r7
 800b3e2:	4628      	mov	r0, r5
      if (COM == COM1)
 800b3e4:	b134      	cbz	r4, 800b3f4 <BSP_COM_Init+0xf8>
        if (MX_UART4_Init(&hcom_uart[COM], COM_Init) != HAL_OK)
 800b3e6:	f7ff ff73 	bl	800b2d0 <MX_UART4_Init>
 800b3ea:	b938      	cbnz	r0, 800b3fc <BSP_COM_Init+0x100>
  int32_t status = BSP_ERROR_NONE;
 800b3ec:	2000      	movs	r0, #0
}
 800b3ee:	b015      	add	sp, #84	; 0x54
 800b3f0:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
        if (MX_USART1_Init(&hcom_uart[COM], COM_Init) != HAL_OK)
 800b3f4:	f7ff ff56 	bl	800b2a4 <MX_USART1_Init>
 800b3f8:	2800      	cmp	r0, #0
 800b3fa:	d0f7      	beq.n	800b3ec <BSP_COM_Init+0xf0>
          status = BSP_ERROR_PERIPH_FAILURE;
 800b3fc:	f06f 0003 	mvn.w	r0, #3
 800b400:	e7f5      	b.n	800b3ee <BSP_COM_Init+0xf2>
    COM1_TX_GPIO_CLK_ENABLE();
 800b402:	f102 4278 	add.w	r2, r2, #4160749568	; 0xf8000000
 800b406:	f502 3204 	add.w	r2, r2, #135168	; 0x21000
 800b40a:	6cd1      	ldr	r1, [r2, #76]	; 0x4c
 800b40c:	f041 0102 	orr.w	r1, r1, #2
 800b410:	64d1      	str	r1, [r2, #76]	; 0x4c
 800b412:	6cd1      	ldr	r1, [r2, #76]	; 0x4c
 800b414:	f001 0102 	and.w	r1, r1, #2
 800b418:	9105      	str	r1, [sp, #20]
 800b41a:	9905      	ldr	r1, [sp, #20]
    COM1_RX_GPIO_CLK_ENABLE();
 800b41c:	6cd1      	ldr	r1, [r2, #76]	; 0x4c
 800b41e:	f041 0102 	orr.w	r1, r1, #2
 800b422:	64d1      	str	r1, [r2, #76]	; 0x4c
 800b424:	6cd1      	ldr	r1, [r2, #76]	; 0x4c
 800b426:	f001 0102 	and.w	r1, r1, #2
 800b42a:	9106      	str	r1, [sp, #24]
 800b42c:	9906      	ldr	r1, [sp, #24]
    COM1_CLK_ENABLE();
 800b42e:	6e11      	ldr	r1, [r2, #96]	; 0x60
 800b430:	f441 4180 	orr.w	r1, r1, #16384	; 0x4000
 800b434:	6611      	str	r1, [r2, #96]	; 0x60
 800b436:	6e12      	ldr	r2, [r2, #96]	; 0x60
 800b438:	f402 4280 	and.w	r2, r2, #16384	; 0x4000
 800b43c:	9207      	str	r2, [sp, #28]
 800b43e:	9a07      	ldr	r2, [sp, #28]
 800b440:	e7a9      	b.n	800b396 <BSP_COM_Init+0x9a>
    status = BSP_ERROR_WRONG_PARAM;
 800b442:	f06f 0001 	mvn.w	r0, #1
}
 800b446:	4770      	bx	lr
 800b448:	2000220c 	.word	0x2000220c
 800b44c:	0802d2e0 	.word	0x0802d2e0
 800b450:	48000400 	.word	0x48000400
 800b454:	40013800 	.word	0x40013800
 800b458:	40021000 	.word	0x40021000

0800b45c <DFSDM_FilterMspInit>:
  * @brief  Initialize DFSDM filter MSP.
  * @param  hdfsdm_filter DFSDM filter handle.
  * @retval None.
  */
static void DFSDM_FilterMspInit(DFSDM_Filter_HandleTypeDef *hdfsdm_filter)
{
 800b45c:	b530      	push	{r4, r5, lr}
  if(hdfsdm_filter->Instance == DFSDM1_Filter0)
 800b45e:	4b38      	ldr	r3, [pc, #224]	; (800b540 <DFSDM_FilterMspInit+0xe4>)
 800b460:	6802      	ldr	r2, [r0, #0]
 800b462:	429a      	cmp	r2, r3
{
 800b464:	b083      	sub	sp, #12
 800b466:	4601      	mov	r1, r0
  if(hdfsdm_filter->Instance == DFSDM1_Filter0)
 800b468:	d037      	beq.n	800b4da <DFSDM_FilterMspInit+0x7e>
    HAL_NVIC_SetPriority(DMA1_Channel4_IRQn, BSP_AUDIO_IN_IT_PRIORITY, 0);
    HAL_NVIC_EnableIRQ(DMA1_Channel4_IRQn);
  }
  else /* DFSDM1_Filter1 */
  {
    if (Audio_In_Ctx[0].Device == AUDIO_IN_DIGITAL_MIC2)
 800b46a:	4b36      	ldr	r3, [pc, #216]	; (800b544 <DFSDM_FilterMspInit+0xe8>)
 800b46c:	681b      	ldr	r3, [r3, #0]
 800b46e:	2b20      	cmp	r3, #32
 800b470:	d109      	bne.n	800b486 <DFSDM_FilterMspInit+0x2a>
    {
      /* Enable the DMA clock needed if only MIC2 is used */
      __HAL_RCC_DMA1_CLK_ENABLE();
 800b472:	4b35      	ldr	r3, [pc, #212]	; (800b548 <DFSDM_FilterMspInit+0xec>)
 800b474:	6c9a      	ldr	r2, [r3, #72]	; 0x48
 800b476:	f042 0201 	orr.w	r2, r2, #1
 800b47a:	649a      	str	r2, [r3, #72]	; 0x48
 800b47c:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800b47e:	f003 0301 	and.w	r3, r3, #1
 800b482:	9301      	str	r3, [sp, #4]
 800b484:	9b01      	ldr	r3, [sp, #4]
    }

    /* Configure the hDmaDfsdm[1] handle parameters */
    hDmaDfsdm[1].Init.Request             = DMA_REQUEST_0;
 800b486:	4b31      	ldr	r3, [pc, #196]	; (800b54c <DFSDM_FilterMspInit+0xf0>)
    hDmaDfsdm[1].Init.MemInc              = DMA_MINC_ENABLE;
    hDmaDfsdm[1].Init.PeriphDataAlignment = DMA_PDATAALIGN_WORD;
    hDmaDfsdm[1].Init.MemDataAlignment    = DMA_MDATAALIGN_WORD;
    hDmaDfsdm[1].Init.Mode                = DMA_CIRCULAR;
    hDmaDfsdm[1].Init.Priority            = DMA_PRIORITY_HIGH;
    hDmaDfsdm[1].Instance                 = DMA1_Channel5;
 800b488:	4a31      	ldr	r2, [pc, #196]	; (800b550 <DFSDM_FilterMspInit+0xf4>)
 800b48a:	461c      	mov	r4, r3
    hDmaDfsdm[1].Init.PeriphDataAlignment = DMA_PDATAALIGN_WORD;
 800b48c:	f04f 0c80 	mov.w	ip, #128	; 0x80
    hDmaDfsdm[1].Instance                 = DMA1_Channel5;
 800b490:	f844 2f48 	str.w	r2, [r4, #72]!
    hDmaDfsdm[1].Init.PeriphDataAlignment = DMA_PDATAALIGN_WORD;
 800b494:	f44f 7200 	mov.w	r2, #512	; 0x200
 800b498:	e9c3 c216 	strd	ip, r2, [r3, #88]	; 0x58
    hDmaDfsdm[1].Init.Mode                = DMA_CIRCULAR;
 800b49c:	f44f 6e00 	mov.w	lr, #2048	; 0x800
 800b4a0:	2220      	movs	r2, #32
 800b4a2:	e9c3 e218 	strd	lr, r2, [r3, #96]	; 0x60
    hDmaDfsdm[1].Init.Request             = DMA_REQUEST_0;
 800b4a6:	2500      	movs	r5, #0
    hDmaDfsdm[1].Init.Priority            = DMA_PRIORITY_HIGH;
 800b4a8:	f44f 5200 	mov.w	r2, #8192	; 0x2000
 800b4ac:	669a      	str	r2, [r3, #104]	; 0x68
    hDmaDfsdm[1].Init.Direction           = DMA_PERIPH_TO_MEMORY;
 800b4ae:	e9c3 5513 	strd	r5, r5, [r3, #76]	; 0x4c
    hDmaDfsdm[1].Init.PeriphInc           = DMA_PINC_DISABLE;
 800b4b2:	655d      	str	r5, [r3, #84]	; 0x54

    /* Associate the DMA handle */
    __HAL_LINKDMA(hdfsdm_filter, hdmaReg, hDmaDfsdm[1]);

    /* Deinitialize the DMA channel for new transfer */
    if (HAL_DMA_DeInit(&hDmaDfsdm[1]) != HAL_OK)
 800b4b4:	4620      	mov	r0, r4
    __HAL_LINKDMA(hdfsdm_filter, hdmaReg, hDmaDfsdm[1]);
 800b4b6:	628c      	str	r4, [r1, #40]	; 0x28
 800b4b8:	6719      	str	r1, [r3, #112]	; 0x70
    if (HAL_DMA_DeInit(&hDmaDfsdm[1]) != HAL_OK)
 800b4ba:	f004 fedd 	bl	8010278 <HAL_DMA_DeInit>
    {
      /* Nothing to do */
    }

    /* Configure the DMA Channel */
    if (HAL_DMA_Init(&hDmaDfsdm[1]) != HAL_OK)
 800b4be:	4620      	mov	r0, r4
 800b4c0:	f004 fe60 	bl	8010184 <HAL_DMA_Init>
    {
      /* Nothing to do */
    }

    /* DMA IRQ Channel configuration */
    HAL_NVIC_SetPriority(DMA1_Channel5_IRQn, BSP_AUDIO_IN_IT_PRIORITY, 0);
 800b4c4:	462a      	mov	r2, r5
 800b4c6:	200f      	movs	r0, #15
 800b4c8:	216c      	movs	r1, #108	; 0x6c
 800b4ca:	f004 f9d9 	bl	800f880 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(DMA1_Channel5_IRQn);
 800b4ce:	200f      	movs	r0, #15
  }
}
 800b4d0:	b003      	add	sp, #12
 800b4d2:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
    HAL_NVIC_EnableIRQ(DMA1_Channel5_IRQn);
 800b4d6:	f004 ba11 	b.w	800f8fc <HAL_NVIC_EnableIRQ>
    __HAL_RCC_DMA1_CLK_ENABLE();
 800b4da:	f503 432f 	add.w	r3, r3, #44800	; 0xaf00
    hDmaDfsdm[0].Init.Request             = DMA_REQUEST_0;
 800b4de:	4c1b      	ldr	r4, [pc, #108]	; (800b54c <DFSDM_FilterMspInit+0xf0>)
    __HAL_RCC_DMA1_CLK_ENABLE();
 800b4e0:	6c9a      	ldr	r2, [r3, #72]	; 0x48
 800b4e2:	f042 0201 	orr.w	r2, r2, #1
 800b4e6:	649a      	str	r2, [r3, #72]	; 0x48
 800b4e8:	6c9b      	ldr	r3, [r3, #72]	; 0x48
    __HAL_LINKDMA(hdfsdm_filter, hdmaReg, hDmaDfsdm[0]);
 800b4ea:	6284      	str	r4, [r0, #40]	; 0x28
    hDmaDfsdm[0].Init.Request             = DMA_REQUEST_0;
 800b4ec:	2500      	movs	r5, #0
    hDmaDfsdm[0].Init.MemInc              = DMA_MINC_ENABLE;
 800b4ee:	2180      	movs	r1, #128	; 0x80
    hDmaDfsdm[0].Init.PeriphDataAlignment = DMA_PDATAALIGN_WORD;
 800b4f0:	f44f 7200 	mov.w	r2, #512	; 0x200
    hDmaDfsdm[0].Init.MemInc              = DMA_MINC_ENABLE;
 800b4f4:	e9c4 5103 	strd	r5, r1, [r4, #12]
    hDmaDfsdm[0].Init.PeriphDataAlignment = DMA_PDATAALIGN_WORD;
 800b4f8:	6162      	str	r2, [r4, #20]
    hDmaDfsdm[0].Init.Mode                = DMA_CIRCULAR;
 800b4fa:	f44f 6100 	mov.w	r1, #2048	; 0x800
    __HAL_RCC_DMA1_CLK_ENABLE();
 800b4fe:	f003 0301 	and.w	r3, r3, #1
    hDmaDfsdm[0].Init.Mode                = DMA_CIRCULAR;
 800b502:	2220      	movs	r2, #32
 800b504:	e9c4 1206 	strd	r1, r2, [r4, #24]
    __HAL_RCC_DMA1_CLK_ENABLE();
 800b508:	9300      	str	r3, [sp, #0]
    hDmaDfsdm[0].Init.Priority            = DMA_PRIORITY_HIGH;
 800b50a:	f44f 5200 	mov.w	r2, #8192	; 0x2000
    hDmaDfsdm[0].Instance                 = DMA1_Channel4;
 800b50e:	4b11      	ldr	r3, [pc, #68]	; (800b554 <DFSDM_FilterMspInit+0xf8>)
    hDmaDfsdm[0].Init.Priority            = DMA_PRIORITY_HIGH;
 800b510:	6222      	str	r2, [r4, #32]
    hDmaDfsdm[0].Instance                 = DMA1_Channel4;
 800b512:	6023      	str	r3, [r4, #0]
    __HAL_LINKDMA(hdfsdm_filter, hdmaReg, hDmaDfsdm[0]);
 800b514:	62a0      	str	r0, [r4, #40]	; 0x28
    hDmaDfsdm[0].Init.Direction           = DMA_PERIPH_TO_MEMORY;
 800b516:	e9c4 5501 	strd	r5, r5, [r4, #4]
    __HAL_RCC_DMA1_CLK_ENABLE();
 800b51a:	9800      	ldr	r0, [sp, #0]
    if (HAL_DMA_DeInit(&hDmaDfsdm[0]) != HAL_OK)
 800b51c:	4620      	mov	r0, r4
 800b51e:	f004 feab 	bl	8010278 <HAL_DMA_DeInit>
    if (HAL_DMA_Init(&hDmaDfsdm[0]) != HAL_OK)
 800b522:	4620      	mov	r0, r4
 800b524:	f004 fe2e 	bl	8010184 <HAL_DMA_Init>
    HAL_NVIC_SetPriority(DMA1_Channel4_IRQn, BSP_AUDIO_IN_IT_PRIORITY, 0);
 800b528:	462a      	mov	r2, r5
 800b52a:	200e      	movs	r0, #14
 800b52c:	216c      	movs	r1, #108	; 0x6c
 800b52e:	f004 f9a7 	bl	800f880 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(DMA1_Channel4_IRQn);
 800b532:	200e      	movs	r0, #14
}
 800b534:	b003      	add	sp, #12
 800b536:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
    HAL_NVIC_EnableIRQ(DMA1_Channel5_IRQn);
 800b53a:	f004 b9df 	b.w	800f8fc <HAL_NVIC_EnableIRQ>
 800b53e:	bf00      	nop
 800b540:	40016100 	.word	0x40016100
 800b544:	20000000 	.word	0x20000000
 800b548:	40021000 	.word	0x40021000
 800b54c:	20002314 	.word	0x20002314
 800b550:	40020058 	.word	0x40020058
 800b554:	40020044 	.word	0x40020044

0800b558 <DFSDM_ChannelMspInit.part.0>:
static void DFSDM_ChannelMspInit(DFSDM_Channel_HandleTypeDef *hdfsdm_channel)
 800b558:	b530      	push	{r4, r5, lr}
    AUDIO_DFSDM1_CLK_ENABLE();
 800b55a:	4c1a      	ldr	r4, [pc, #104]	; (800b5c4 <DFSDM_ChannelMspInit.part.0+0x6c>)
    HAL_GPIO_Init(AUDIO_DFSDM1_CKOUT_GPIO_PORT, &GPIO_InitStruct);
 800b55c:	481a      	ldr	r0, [pc, #104]	; (800b5c8 <DFSDM_ChannelMspInit.part.0+0x70>)
    AUDIO_DFSDM1_CLK_ENABLE();
 800b55e:	6e23      	ldr	r3, [r4, #96]	; 0x60
 800b560:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 800b564:	6623      	str	r3, [r4, #96]	; 0x60
 800b566:	6e23      	ldr	r3, [r4, #96]	; 0x60
static void DFSDM_ChannelMspInit(DFSDM_Channel_HandleTypeDef *hdfsdm_channel)
 800b568:	b089      	sub	sp, #36	; 0x24
    AUDIO_DFSDM1_CLK_ENABLE();
 800b56a:	f003 7380 	and.w	r3, r3, #16777216	; 0x1000000
 800b56e:	9300      	str	r3, [sp, #0]
 800b570:	9b00      	ldr	r3, [sp, #0]
    AUDIO_DFSDM1_CKOUT_GPIO_CLK_ENABLE();
 800b572:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
 800b574:	f043 0310 	orr.w	r3, r3, #16
 800b578:	64e3      	str	r3, [r4, #76]	; 0x4c
 800b57a:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
 800b57c:	f003 0310 	and.w	r3, r3, #16
 800b580:	9301      	str	r3, [sp, #4]
    GPIO_InitStruct.Mode      = GPIO_MODE_AF_PP;
 800b582:	2302      	movs	r3, #2
    AUDIO_DFSDM1_CKOUT_GPIO_CLK_ENABLE();
 800b584:	9a01      	ldr	r2, [sp, #4]
    GPIO_InitStruct.Mode      = GPIO_MODE_AF_PP;
 800b586:	9304      	str	r3, [sp, #16]
    GPIO_InitStruct.Speed     = GPIO_SPEED_FREQ_VERY_HIGH;
 800b588:	2200      	movs	r2, #0
 800b58a:	2303      	movs	r3, #3
 800b58c:	e9cd 2305 	strd	r2, r3, [sp, #20]
    GPIO_InitStruct.Alternate = AUDIO_DFSDM1_CKOUT_GPIO_AF;
 800b590:	2506      	movs	r5, #6
    GPIO_InitStruct.Pin       = AUDIO_DFSDM1_CKOUT_GPIO_PIN;
 800b592:	f44f 7300 	mov.w	r3, #512	; 0x200
    HAL_GPIO_Init(AUDIO_DFSDM1_CKOUT_GPIO_PORT, &GPIO_InitStruct);
 800b596:	a903      	add	r1, sp, #12
    GPIO_InitStruct.Pin       = AUDIO_DFSDM1_CKOUT_GPIO_PIN;
 800b598:	9303      	str	r3, [sp, #12]
    GPIO_InitStruct.Alternate = AUDIO_DFSDM1_CKOUT_GPIO_AF;
 800b59a:	9507      	str	r5, [sp, #28]
    HAL_GPIO_Init(AUDIO_DFSDM1_CKOUT_GPIO_PORT, &GPIO_InitStruct);
 800b59c:	f005 f94e 	bl	801083c <HAL_GPIO_Init>
    AUDIO_DFSDM1_DATIN2_GPIO_CLK_ENABLE();
 800b5a0:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
    HAL_GPIO_Init(AUDIO_DFSDM1_DATIN2_GPIO_PORT, &GPIO_InitStruct);
 800b5a2:	4809      	ldr	r0, [pc, #36]	; (800b5c8 <DFSDM_ChannelMspInit.part.0+0x70>)
    AUDIO_DFSDM1_DATIN2_GPIO_CLK_ENABLE();
 800b5a4:	f043 0310 	orr.w	r3, r3, #16
 800b5a8:	64e3      	str	r3, [r4, #76]	; 0x4c
 800b5aa:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
    GPIO_InitStruct.Alternate = AUDIO_DFSDM1_DATIN2_GPIO_AF;
 800b5ac:	9507      	str	r5, [sp, #28]
    AUDIO_DFSDM1_DATIN2_GPIO_CLK_ENABLE();
 800b5ae:	f003 0310 	and.w	r3, r3, #16
 800b5b2:	9302      	str	r3, [sp, #8]
    HAL_GPIO_Init(AUDIO_DFSDM1_DATIN2_GPIO_PORT, &GPIO_InitStruct);
 800b5b4:	a903      	add	r1, sp, #12
    GPIO_InitStruct.Pin       = AUDIO_DFSDM1_DATIN2_GPIO_PIN;
 800b5b6:	2380      	movs	r3, #128	; 0x80
    AUDIO_DFSDM1_DATIN2_GPIO_CLK_ENABLE();
 800b5b8:	9a02      	ldr	r2, [sp, #8]
    GPIO_InitStruct.Pin       = AUDIO_DFSDM1_DATIN2_GPIO_PIN;
 800b5ba:	9303      	str	r3, [sp, #12]
    HAL_GPIO_Init(AUDIO_DFSDM1_DATIN2_GPIO_PORT, &GPIO_InitStruct);
 800b5bc:	f005 f93e 	bl	801083c <HAL_GPIO_Init>
}
 800b5c0:	b009      	add	sp, #36	; 0x24
 800b5c2:	bd30      	pop	{r4, r5, pc}
 800b5c4:	40021000 	.word	0x40021000
 800b5c8:	48001000 	.word	0x48001000

0800b5cc <DFSDM_ChannelMspDeInit.isra.0>:
static void DFSDM_ChannelMspDeInit(DFSDM_Channel_HandleTypeDef *hdfsdm_channel)
 800b5cc:	b508      	push	{r3, lr}
  if (((hdfsdm_channel->Instance == DFSDM1_Channel2) && ((Audio_In_Ctx[0].Device & AUDIO_IN_DIGITAL_MIC1) != 0U)) || \
 800b5ce:	4b0f      	ldr	r3, [pc, #60]	; (800b60c <DFSDM_ChannelMspDeInit.isra.0+0x40>)
 800b5d0:	4298      	cmp	r0, r3
 800b5d2:	d016      	beq.n	800b602 <DFSDM_ChannelMspDeInit.isra.0+0x36>
 800b5d4:	4b0e      	ldr	r3, [pc, #56]	; (800b610 <DFSDM_ChannelMspDeInit.isra.0+0x44>)
 800b5d6:	4298      	cmp	r0, r3
 800b5d8:	d000      	beq.n	800b5dc <DFSDM_ChannelMspDeInit.isra.0+0x10>
}
 800b5da:	bd08      	pop	{r3, pc}
      ((hdfsdm_channel->Instance == DFSDM1_Channel1) && (Audio_In_Ctx[0].Device == AUDIO_IN_DIGITAL_MIC2)))
 800b5dc:	4b0d      	ldr	r3, [pc, #52]	; (800b614 <DFSDM_ChannelMspDeInit.isra.0+0x48>)
 800b5de:	681b      	ldr	r3, [r3, #0]
 800b5e0:	2b20      	cmp	r3, #32
 800b5e2:	d1fa      	bne.n	800b5da <DFSDM_ChannelMspDeInit.isra.0+0xe>
    HAL_GPIO_DeInit(AUDIO_DFSDM1_CKOUT_GPIO_PORT, AUDIO_DFSDM1_CKOUT_GPIO_PIN);
 800b5e4:	480c      	ldr	r0, [pc, #48]	; (800b618 <DFSDM_ChannelMspDeInit.isra.0+0x4c>)
 800b5e6:	f44f 7100 	mov.w	r1, #512	; 0x200
 800b5ea:	f005 fa4d 	bl	8010a88 <HAL_GPIO_DeInit>
    HAL_GPIO_DeInit(AUDIO_DFSDM1_DATIN2_GPIO_PORT, AUDIO_DFSDM1_DATIN2_GPIO_PIN);
 800b5ee:	480a      	ldr	r0, [pc, #40]	; (800b618 <DFSDM_ChannelMspDeInit.isra.0+0x4c>)
 800b5f0:	2180      	movs	r1, #128	; 0x80
 800b5f2:	f005 fa49 	bl	8010a88 <HAL_GPIO_DeInit>
    AUDIO_DFSDM1_CLK_DISABLE();
 800b5f6:	4a09      	ldr	r2, [pc, #36]	; (800b61c <DFSDM_ChannelMspDeInit.isra.0+0x50>)
 800b5f8:	6e13      	ldr	r3, [r2, #96]	; 0x60
 800b5fa:	f023 7380 	bic.w	r3, r3, #16777216	; 0x1000000
 800b5fe:	6613      	str	r3, [r2, #96]	; 0x60
}
 800b600:	bd08      	pop	{r3, pc}
  if (((hdfsdm_channel->Instance == DFSDM1_Channel2) && ((Audio_In_Ctx[0].Device & AUDIO_IN_DIGITAL_MIC1) != 0U)) || \
 800b602:	4b04      	ldr	r3, [pc, #16]	; (800b614 <DFSDM_ChannelMspDeInit.isra.0+0x48>)
 800b604:	681b      	ldr	r3, [r3, #0]
 800b606:	06db      	lsls	r3, r3, #27
 800b608:	d4ec      	bmi.n	800b5e4 <DFSDM_ChannelMspDeInit.isra.0+0x18>
 800b60a:	e7e6      	b.n	800b5da <DFSDM_ChannelMspDeInit.isra.0+0xe>
 800b60c:	40016040 	.word	0x40016040
 800b610:	40016020 	.word	0x40016020
 800b614:	20000000 	.word	0x20000000
 800b618:	48001000 	.word	0x48001000
 800b61c:	40021000 	.word	0x40021000

0800b620 <BSP_AUDIO_IN_DeInit>:
  if (Instance >= AUDIO_IN_INSTANCES_NBR)
 800b620:	2800      	cmp	r0, #0
 800b622:	d14b      	bne.n	800b6bc <BSP_AUDIO_IN_DeInit+0x9c>
{
 800b624:	b538      	push	{r3, r4, r5, lr}
  else if (Audio_In_Ctx[Instance].State != AUDIO_IN_STATE_RESET)
 800b626:	4c2c      	ldr	r4, [pc, #176]	; (800b6d8 <BSP_AUDIO_IN_DeInit+0xb8>)
 800b628:	69e0      	ldr	r0, [r4, #28]
 800b62a:	b300      	cbz	r0, 800b66e <BSP_AUDIO_IN_DeInit+0x4e>
    if ((Audio_In_Ctx[Instance].Device & AUDIO_IN_DIGITAL_MIC2) == AUDIO_IN_DIGITAL_MIC2)
 800b62c:	6823      	ldr	r3, [r4, #0]
 800b62e:	0699      	lsls	r1, r3, #26
 800b630:	d41e      	bmi.n	800b670 <BSP_AUDIO_IN_DeInit+0x50>
    if (((Audio_In_Ctx[Instance].Device & AUDIO_IN_DIGITAL_MIC1) == AUDIO_IN_DIGITAL_MIC1) && (status == BSP_ERROR_NONE))
 800b632:	06db      	lsls	r3, r3, #27
 800b634:	d519      	bpl.n	800b66a <BSP_AUDIO_IN_DeInit+0x4a>
 800b636:	4d29      	ldr	r5, [pc, #164]	; (800b6dc <BSP_AUDIO_IN_DeInit+0xbc>)
  if(HAL_DFSDM_FilterDeInit(hDfsdmFilter) != HAL_OK)
 800b638:	4829      	ldr	r0, [pc, #164]	; (800b6e0 <BSP_AUDIO_IN_DeInit+0xc0>)
 800b63a:	f004 fcc3 	bl	800ffc4 <HAL_DFSDM_FilterDeInit>
 800b63e:	2800      	cmp	r0, #0
 800b640:	d146      	bne.n	800b6d0 <BSP_AUDIO_IN_DeInit+0xb0>
    if(HAL_OK != HAL_DFSDM_ChannelDeInit(hDfsdmChannel))
 800b642:	4828      	ldr	r0, [pc, #160]	; (800b6e4 <BSP_AUDIO_IN_DeInit+0xc4>)
 800b644:	f004 fbc0 	bl	800fdc8 <HAL_DFSDM_ChannelDeInit>
 800b648:	2800      	cmp	r0, #0
 800b64a:	d141      	bne.n	800b6d0 <BSP_AUDIO_IN_DeInit+0xb0>
  * @param  hdfsdm_filter DFSDM filter handle.
  * @retval None.
  */
static void DFSDM_FilterMspDeInit(DFSDM_Filter_HandleTypeDef *hdfsdm_filter)
{
  if(hdfsdm_filter->Instance == DFSDM1_Filter0)
 800b64c:	4b26      	ldr	r3, [pc, #152]	; (800b6e8 <BSP_AUDIO_IN_DeInit+0xc8>)
 800b64e:	f8d5 2090 	ldr.w	r2, [r5, #144]	; 0x90
 800b652:	429a      	cmp	r2, r3
 800b654:	d02b      	beq.n	800b6ae <BSP_AUDIO_IN_DeInit+0x8e>
    }
  }
  else /* DFSDM1_Filter1 */
  {
    /* Disable DMA  Channel IRQ */
    HAL_NVIC_DisableIRQ(DMA1_Channel5_IRQn);
 800b656:	200f      	movs	r0, #15
 800b658:	f004 f95e 	bl	800f918 <HAL_NVIC_DisableIRQ>

    /* De-initialize the DMA Channel */
    if (HAL_DMA_DeInit(&hDmaDfsdm[1]) != HAL_OK)
 800b65c:	4823      	ldr	r0, [pc, #140]	; (800b6ec <BSP_AUDIO_IN_DeInit+0xcc>)
 800b65e:	f004 fe0b 	bl	8010278 <HAL_DMA_DeInit>
        DFSDM_ChannelMspDeInit(&haudio_in_dfsdm_channel[0]);
 800b662:	f8d5 0138 	ldr.w	r0, [r5, #312]	; 0x138
 800b666:	f7ff ffb1 	bl	800b5cc <DFSDM_ChannelMspDeInit.isra.0>
      Audio_In_Ctx[Instance].State = AUDIO_IN_STATE_RESET;
 800b66a:	2000      	movs	r0, #0
 800b66c:	61e0      	str	r0, [r4, #28]
}
 800b66e:	bd38      	pop	{r3, r4, r5, pc}
  if(HAL_DFSDM_FilterDeInit(hDfsdmFilter) != HAL_OK)
 800b670:	4d1a      	ldr	r5, [pc, #104]	; (800b6dc <BSP_AUDIO_IN_DeInit+0xbc>)
 800b672:	f105 00e4 	add.w	r0, r5, #228	; 0xe4
 800b676:	f004 fca5 	bl	800ffc4 <HAL_DFSDM_FilterDeInit>
 800b67a:	bb48      	cbnz	r0, 800b6d0 <BSP_AUDIO_IN_DeInit+0xb0>
    if(HAL_OK != HAL_DFSDM_ChannelDeInit(hDfsdmChannel))
 800b67c:	f505 70b8 	add.w	r0, r5, #368	; 0x170
 800b680:	f004 fba2 	bl	800fdc8 <HAL_DFSDM_ChannelDeInit>
 800b684:	bb20      	cbnz	r0, 800b6d0 <BSP_AUDIO_IN_DeInit+0xb0>
  if(hdfsdm_filter->Instance == DFSDM1_Filter0)
 800b686:	4b18      	ldr	r3, [pc, #96]	; (800b6e8 <BSP_AUDIO_IN_DeInit+0xc8>)
 800b688:	f8d5 20e4 	ldr.w	r2, [r5, #228]	; 0xe4
 800b68c:	429a      	cmp	r2, r3
 800b68e:	d018      	beq.n	800b6c2 <BSP_AUDIO_IN_DeInit+0xa2>
    HAL_NVIC_DisableIRQ(DMA1_Channel5_IRQn);
 800b690:	200f      	movs	r0, #15
 800b692:	f004 f941 	bl	800f918 <HAL_NVIC_DisableIRQ>
    if (HAL_DMA_DeInit(&hDmaDfsdm[1]) != HAL_OK)
 800b696:	f105 0048 	add.w	r0, r5, #72	; 0x48
 800b69a:	f004 fded 	bl	8010278 <HAL_DMA_DeInit>
        DFSDM_ChannelMspDeInit(&haudio_in_dfsdm_channel[1]);
 800b69e:	f8d5 0170 	ldr.w	r0, [r5, #368]	; 0x170
 800b6a2:	f7ff ff93 	bl	800b5cc <DFSDM_ChannelMspDeInit.isra.0>
    if (((Audio_In_Ctx[Instance].Device & AUDIO_IN_DIGITAL_MIC1) == AUDIO_IN_DIGITAL_MIC1) && (status == BSP_ERROR_NONE))
 800b6a6:	6823      	ldr	r3, [r4, #0]
 800b6a8:	06da      	lsls	r2, r3, #27
 800b6aa:	d5de      	bpl.n	800b66a <BSP_AUDIO_IN_DeInit+0x4a>
 800b6ac:	e7c4      	b.n	800b638 <BSP_AUDIO_IN_DeInit+0x18>
    HAL_NVIC_DisableIRQ(DMA1_Channel4_IRQn);
 800b6ae:	200e      	movs	r0, #14
 800b6b0:	f004 f932 	bl	800f918 <HAL_NVIC_DisableIRQ>
    if (HAL_DMA_DeInit(&hDmaDfsdm[0]) != HAL_OK)
 800b6b4:	4809      	ldr	r0, [pc, #36]	; (800b6dc <BSP_AUDIO_IN_DeInit+0xbc>)
 800b6b6:	f004 fddf 	bl	8010278 <HAL_DMA_DeInit>
    {
      /* Nothing to do */
    }
  }
}
 800b6ba:	e7d2      	b.n	800b662 <BSP_AUDIO_IN_DeInit+0x42>
    status = BSP_ERROR_WRONG_PARAM;
 800b6bc:	f06f 0001 	mvn.w	r0, #1
}
 800b6c0:	4770      	bx	lr
    HAL_NVIC_DisableIRQ(DMA1_Channel4_IRQn);
 800b6c2:	200e      	movs	r0, #14
 800b6c4:	f004 f928 	bl	800f918 <HAL_NVIC_DisableIRQ>
    if (HAL_DMA_DeInit(&hDmaDfsdm[0]) != HAL_OK)
 800b6c8:	4628      	mov	r0, r5
 800b6ca:	f004 fdd5 	bl	8010278 <HAL_DMA_DeInit>
}
 800b6ce:	e7e6      	b.n	800b69e <BSP_AUDIO_IN_DeInit+0x7e>
{
 800b6d0:	f06f 0003 	mvn.w	r0, #3
}
 800b6d4:	bd38      	pop	{r3, r4, r5, pc}
 800b6d6:	bf00      	nop
 800b6d8:	20000000 	.word	0x20000000
 800b6dc:	20002314 	.word	0x20002314
 800b6e0:	200023a4 	.word	0x200023a4
 800b6e4:	2000244c 	.word	0x2000244c
 800b6e8:	40016100 	.word	0x40016100
 800b6ec:	2000235c 	.word	0x2000235c

0800b6f0 <BSP_AUDIO_IN_Record>:
  if ((Instance >= AUDIO_IN_INSTANCES_NBR) || (pData == NULL) || (NbrOfBytes > 65535U))
 800b6f0:	2800      	cmp	r0, #0
 800b6f2:	d136      	bne.n	800b762 <BSP_AUDIO_IN_Record+0x72>
 800b6f4:	2900      	cmp	r1, #0
 800b6f6:	d034      	beq.n	800b762 <BSP_AUDIO_IN_Record+0x72>
  else if ((NbrOfBytes / 2U) > BSP_AUDIO_IN_DEFAULT_BUFFER_SIZE)
 800b6f8:	2a81      	cmp	r2, #129	; 0x81
 800b6fa:	d832      	bhi.n	800b762 <BSP_AUDIO_IN_Record+0x72>
{
 800b6fc:	b510      	push	{r4, lr}
  else if (Audio_In_Ctx[Instance].State != AUDIO_IN_STATE_STOP)
 800b6fe:	4c1c      	ldr	r4, [pc, #112]	; (800b770 <BSP_AUDIO_IN_Record+0x80>)
 800b700:	69e3      	ldr	r3, [r4, #28]
 800b702:	2b02      	cmp	r3, #2
 800b704:	d130      	bne.n	800b768 <BSP_AUDIO_IN_Record+0x78>
    Audio_DmaDigMic1RecHalfBuffCplt = 0;
 800b706:	4b1b      	ldr	r3, [pc, #108]	; (800b774 <BSP_AUDIO_IN_Record+0x84>)
    Audio_In_Ctx[Instance].Size  = NbrOfBytes;
 800b708:	e9c4 1204 	strd	r1, r2, [r4, #16]
    if ((Audio_In_Ctx[Instance].Device & AUDIO_IN_DIGITAL_MIC2) == AUDIO_IN_DIGITAL_MIC2)
 800b70c:	6821      	ldr	r1, [r4, #0]
    Audio_DmaDigMic1RecBuffCplt     = 0;
 800b70e:	e9c3 006a 	strd	r0, r0, [r3, #424]	; 0x1a8
    Audio_DmaDigMic2RecBuffCplt     = 0;
 800b712:	e9c3 006c 	strd	r0, r0, [r3, #432]	; 0x1b0
    if ((Audio_In_Ctx[Instance].Device & AUDIO_IN_DIGITAL_MIC2) == AUDIO_IN_DIGITAL_MIC2)
 800b716:	0688      	lsls	r0, r1, #26
 800b718:	d40f      	bmi.n	800b73a <BSP_AUDIO_IN_Record+0x4a>
    if (((Audio_In_Ctx[Instance].Device & AUDIO_IN_DIGITAL_MIC1) == AUDIO_IN_DIGITAL_MIC1) && (status == BSP_ERROR_NONE))
 800b71a:	06c9      	lsls	r1, r1, #27
 800b71c:	d509      	bpl.n	800b732 <BSP_AUDIO_IN_Record+0x42>
                                          (Audio_In_Ctx[Instance].Size / (2U * Audio_In_Ctx[Instance].ChannelsNbr))) != HAL_OK)
 800b71e:	68e3      	ldr	r3, [r4, #12]
      if(HAL_DFSDM_FilterRegularStart_DMA(&haudio_in_dfsdm_filter[0],
 800b720:	4915      	ldr	r1, [pc, #84]	; (800b778 <BSP_AUDIO_IN_Record+0x88>)
                                          (Audio_In_Ctx[Instance].Size / (2U * Audio_In_Ctx[Instance].ChannelsNbr))) != HAL_OK)
 800b722:	005b      	lsls	r3, r3, #1
      if(HAL_DFSDM_FilterRegularStart_DMA(&haudio_in_dfsdm_filter[0],
 800b724:	f5a1 700a 	sub.w	r0, r1, #552	; 0x228
 800b728:	fbb2 f2f3 	udiv	r2, r2, r3
 800b72c:	f004 fc82 	bl	8010034 <HAL_DFSDM_FilterRegularStart_DMA>
 800b730:	b9a0      	cbnz	r0, 800b75c <BSP_AUDIO_IN_Record+0x6c>
      Audio_In_Ctx[Instance].State = AUDIO_IN_STATE_RECORDING;
 800b732:	2301      	movs	r3, #1
 800b734:	61e3      	str	r3, [r4, #28]
 800b736:	2000      	movs	r0, #0
}
 800b738:	bd10      	pop	{r4, pc}
                                          (Audio_In_Ctx[Instance].Size / (2U * Audio_In_Ctx[Instance].ChannelsNbr))) != HAL_OK)
 800b73a:	68e0      	ldr	r0, [r4, #12]
      if(HAL_DFSDM_FilterRegularStart_DMA(&haudio_in_dfsdm_filter[1],
 800b73c:	f503 71dc 	add.w	r1, r3, #440	; 0x1b8
                                          (Audio_In_Ctx[Instance].Size / (2U * Audio_In_Ctx[Instance].ChannelsNbr))) != HAL_OK)
 800b740:	ea4f 0c40 	mov.w	ip, r0, lsl #1
      if(HAL_DFSDM_FilterRegularStart_DMA(&haudio_in_dfsdm_filter[1],
 800b744:	f103 00e4 	add.w	r0, r3, #228	; 0xe4
 800b748:	fbb2 f2fc 	udiv	r2, r2, ip
 800b74c:	f004 fc72 	bl	8010034 <HAL_DFSDM_FilterRegularStart_DMA>
 800b750:	b920      	cbnz	r0, 800b75c <BSP_AUDIO_IN_Record+0x6c>
    if (((Audio_In_Ctx[Instance].Device & AUDIO_IN_DIGITAL_MIC1) == AUDIO_IN_DIGITAL_MIC1) && (status == BSP_ERROR_NONE))
 800b752:	6823      	ldr	r3, [r4, #0]
 800b754:	06db      	lsls	r3, r3, #27
 800b756:	d5ec      	bpl.n	800b732 <BSP_AUDIO_IN_Record+0x42>
                                          (Audio_In_Ctx[Instance].Size / (2U * Audio_In_Ctx[Instance].ChannelsNbr))) != HAL_OK)
 800b758:	6962      	ldr	r2, [r4, #20]
 800b75a:	e7e0      	b.n	800b71e <BSP_AUDIO_IN_Record+0x2e>
        status = BSP_ERROR_PERIPH_FAILURE;
 800b75c:	f06f 0003 	mvn.w	r0, #3
}
 800b760:	bd10      	pop	{r4, pc}
    status = BSP_ERROR_WRONG_PARAM;
 800b762:	f06f 0001 	mvn.w	r0, #1
}
 800b766:	4770      	bx	lr
    status = BSP_ERROR_BUSY;
 800b768:	f06f 0002 	mvn.w	r0, #2
}
 800b76c:	bd10      	pop	{r4, pc}
 800b76e:	bf00      	nop
 800b770:	20000000 	.word	0x20000000
 800b774:	20002314 	.word	0x20002314
 800b778:	200025cc 	.word	0x200025cc

0800b77c <BSP_AUDIO_IN_Stop>:
  if (Instance >= AUDIO_IN_INSTANCES_NBR)
 800b77c:	bb18      	cbnz	r0, 800b7c6 <BSP_AUDIO_IN_Stop+0x4a>
{
 800b77e:	b510      	push	{r4, lr}
  else if (Audio_In_Ctx[Instance].State == AUDIO_IN_STATE_STOP)
 800b780:	4c12      	ldr	r4, [pc, #72]	; (800b7cc <BSP_AUDIO_IN_Stop+0x50>)
 800b782:	69e3      	ldr	r3, [r4, #28]
 800b784:	2b02      	cmp	r3, #2
 800b786:	d005      	beq.n	800b794 <BSP_AUDIO_IN_Stop+0x18>
  else if ((Audio_In_Ctx[Instance].State != AUDIO_IN_STATE_RECORDING) &&
 800b788:	f023 0302 	bic.w	r3, r3, #2
 800b78c:	2b01      	cmp	r3, #1
 800b78e:	d002      	beq.n	800b796 <BSP_AUDIO_IN_Stop+0x1a>
    status = BSP_ERROR_BUSY;
 800b790:	f06f 0002 	mvn.w	r0, #2
}
 800b794:	bd10      	pop	{r4, pc}
    if ((Audio_In_Ctx[Instance].Device & AUDIO_IN_DIGITAL_MIC2) == AUDIO_IN_DIGITAL_MIC2)
 800b796:	6823      	ldr	r3, [r4, #0]
 800b798:	0699      	lsls	r1, r3, #26
 800b79a:	d409      	bmi.n	800b7b0 <BSP_AUDIO_IN_Stop+0x34>
    if (((Audio_In_Ctx[Instance].Device & AUDIO_IN_DIGITAL_MIC1) == AUDIO_IN_DIGITAL_MIC1) && (status == BSP_ERROR_NONE))
 800b79c:	06da      	lsls	r2, r3, #27
 800b79e:	d503      	bpl.n	800b7a8 <BSP_AUDIO_IN_Stop+0x2c>
      if(HAL_DFSDM_FilterRegularStop_DMA(&haudio_in_dfsdm_filter[0]) != HAL_OK)
 800b7a0:	480b      	ldr	r0, [pc, #44]	; (800b7d0 <BSP_AUDIO_IN_Stop+0x54>)
 800b7a2:	f004 fc9d 	bl	80100e0 <HAL_DFSDM_FilterRegularStop_DMA>
 800b7a6:	b938      	cbnz	r0, 800b7b8 <BSP_AUDIO_IN_Stop+0x3c>
      Audio_In_Ctx[Instance].State = AUDIO_IN_STATE_STOP;
 800b7a8:	2302      	movs	r3, #2
 800b7aa:	61e3      	str	r3, [r4, #28]
 800b7ac:	2000      	movs	r0, #0
}
 800b7ae:	bd10      	pop	{r4, pc}
      if(HAL_DFSDM_FilterRegularStop_DMA(&haudio_in_dfsdm_filter[1]) != HAL_OK)
 800b7b0:	4808      	ldr	r0, [pc, #32]	; (800b7d4 <BSP_AUDIO_IN_Stop+0x58>)
 800b7b2:	f004 fc95 	bl	80100e0 <HAL_DFSDM_FilterRegularStop_DMA>
 800b7b6:	b110      	cbz	r0, 800b7be <BSP_AUDIO_IN_Stop+0x42>
        status = BSP_ERROR_PERIPH_FAILURE;
 800b7b8:	f06f 0003 	mvn.w	r0, #3
}
 800b7bc:	bd10      	pop	{r4, pc}
    if (((Audio_In_Ctx[Instance].Device & AUDIO_IN_DIGITAL_MIC1) == AUDIO_IN_DIGITAL_MIC1) && (status == BSP_ERROR_NONE))
 800b7be:	6823      	ldr	r3, [r4, #0]
 800b7c0:	06db      	lsls	r3, r3, #27
 800b7c2:	d4ed      	bmi.n	800b7a0 <BSP_AUDIO_IN_Stop+0x24>
 800b7c4:	e7f0      	b.n	800b7a8 <BSP_AUDIO_IN_Stop+0x2c>
    status = BSP_ERROR_WRONG_PARAM;
 800b7c6:	f06f 0001 	mvn.w	r0, #1
}
 800b7ca:	4770      	bx	lr
 800b7cc:	20000000 	.word	0x20000000
 800b7d0:	200023a4 	.word	0x200023a4
 800b7d4:	200023f8 	.word	0x200023f8

0800b7d8 <MX_DFSDM1_Init>:
{
 800b7d8:	b570      	push	{r4, r5, r6, lr}
  hDfsdmChannel->Instance                      = MXInit->ChannelInstance;
 800b7da:	6913      	ldr	r3, [r2, #16]
 800b7dc:	600b      	str	r3, [r1, #0]
  hDfsdmChannel->Init.OutputClock.Activation   = ENABLE;
 800b7de:	2601      	movs	r6, #1
 800b7e0:	710e      	strb	r6, [r1, #4]
  hDfsdmChannel->Init.OutputClock.Selection    = DFSDM_CHANNEL_OUTPUT_CLOCK_AUDIO;
 800b7e2:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
{
 800b7e6:	4614      	mov	r4, r2
  hDfsdmChannel->Init.OutputClock.Selection    = DFSDM_CHANNEL_OUTPUT_CLOCK_AUDIO;
 800b7e8:	608b      	str	r3, [r1, #8]
  hDfsdmChannel->Init.OutputClock.Divider      = MXInit->ClockDivider;
 800b7ea:	6a13      	ldr	r3, [r2, #32]
 800b7ec:	60cb      	str	r3, [r1, #12]
  hDfsdmChannel->Init.Input.Pins               = MXInit->DigitalMicPins;
 800b7ee:	6952      	ldr	r2, [r2, #20]
 800b7f0:	618a      	str	r2, [r1, #24]
  hDfsdmChannel->Init.Input.Multiplexer        = DFSDM_CHANNEL_EXTERNAL_INPUTS;
 800b7f2:	2300      	movs	r3, #0
  hDfsdmChannel->Init.SerialInterface.Type     = MXInit->DigitalMicType;
 800b7f4:	69a2      	ldr	r2, [r4, #24]
  hDfsdmChannel->Init.Offset                   = 0;
 800b7f6:	62cb      	str	r3, [r1, #44]	; 0x2c
  hDfsdmChannel->Init.Input.DataPacking        = DFSDM_CHANNEL_STANDARD_MODE;
 800b7f8:	e9c1 3304 	strd	r3, r3, [r1, #16]
  hDfsdmChannel->Init.RightBitShift            = MXInit->RightBitShift;
 800b7fc:	6a63      	ldr	r3, [r4, #36]	; 0x24
  hDfsdmChannel->Init.SerialInterface.Type     = MXInit->DigitalMicType;
 800b7fe:	61ca      	str	r2, [r1, #28]
  hDfsdmChannel->Init.RightBitShift            = MXInit->RightBitShift;
 800b800:	630b      	str	r3, [r1, #48]	; 0x30
  hDfsdmChannel->Init.Awd.FilterOrder          = DFSDM_CHANNEL_SINC1_ORDER;
 800b802:	2204      	movs	r2, #4
 800b804:	f44f 0380 	mov.w	r3, #4194304	; 0x400000
 800b808:	e9c1 2308 	strd	r2, r3, [r1, #32]
  hDfsdmChannel->Init.Awd.Oversampling         = 10;
 800b80c:	230a      	movs	r3, #10
{
 800b80e:	4605      	mov	r5, r0
  hDfsdmChannel->Init.Awd.Oversampling         = 10;
 800b810:	628b      	str	r3, [r1, #40]	; 0x28
  if(HAL_OK != HAL_DFSDM_ChannelInit(hDfsdmChannel))
 800b812:	4608      	mov	r0, r1
 800b814:	f004 fa08 	bl	800fc28 <HAL_DFSDM_ChannelInit>
 800b818:	b108      	cbz	r0, 800b81e <MX_DFSDM1_Init+0x46>
    status = HAL_ERROR;
 800b81a:	2001      	movs	r0, #1
}
 800b81c:	bd70      	pop	{r4, r5, r6, pc}
    hDfsdmFilter->Instance                          = MXInit->FilterInstance;
 800b81e:	6823      	ldr	r3, [r4, #0]
 800b820:	602b      	str	r3, [r5, #0]
    hDfsdmFilter->Init.RegularParam.Trigger         = MXInit->RegularTrigger;
 800b822:	6863      	ldr	r3, [r4, #4]
 800b824:	606b      	str	r3, [r5, #4]
    hDfsdmFilter->Init.RegularParam.FastMode        = ENABLE;
 800b826:	f240 1301 	movw	r3, #257	; 0x101
    hDfsdmFilter->Init.InjectedParam.ScanMode       = DISABLE;
 800b82a:	8228      	strh	r0, [r5, #16]
    hDfsdmFilter->Init.RegularParam.FastMode        = ENABLE;
 800b82c:	812b      	strh	r3, [r5, #8]
    hDfsdmFilter->Init.FilterParam.SincOrder        = MXInit->SincOrder;
 800b82e:	68a3      	ldr	r3, [r4, #8]
 800b830:	61eb      	str	r3, [r5, #28]
    hDfsdmFilter->Init.FilterParam.Oversampling     = MXInit->Oversampling;
 800b832:	68e3      	ldr	r3, [r4, #12]
    hDfsdmFilter->Init.InjectedParam.Trigger        = DFSDM_FILTER_SW_TRIGGER;
 800b834:	60e8      	str	r0, [r5, #12]
    hDfsdmFilter->Init.FilterParam.IntOversampling  = 1;
 800b836:	e9c5 3608 	strd	r3, r6, [r5, #32]
    hDfsdmFilter->Init.InjectedParam.ExtTrigger     = DFSDM_FILTER_EXT_TRIG_TIM8_TRGO;
 800b83a:	f44f 7200 	mov.w	r2, #512	; 0x200
    hDfsdmFilter->Init.InjectedParam.ExtTriggerEdge = DFSDM_FILTER_EXT_TRIG_BOTH_EDGES;
 800b83e:	f44f 43c0 	mov.w	r3, #24576	; 0x6000
    hDfsdmFilter->Init.InjectedParam.ExtTrigger     = DFSDM_FILTER_EXT_TRIG_TIM8_TRGO;
 800b842:	616a      	str	r2, [r5, #20]
    if(HAL_DFSDM_FilterInit(hDfsdmFilter) != HAL_OK)
 800b844:	4628      	mov	r0, r5
    hDfsdmFilter->Init.InjectedParam.ExtTriggerEdge = DFSDM_FILTER_EXT_TRIG_BOTH_EDGES;
 800b846:	61ab      	str	r3, [r5, #24]
    if(HAL_DFSDM_FilterInit(hDfsdmFilter) != HAL_OK)
 800b848:	f004 fb42 	bl	800fed0 <HAL_DFSDM_FilterInit>
 800b84c:	2800      	cmp	r0, #0
 800b84e:	d1e4      	bne.n	800b81a <MX_DFSDM1_Init+0x42>
      if(HAL_DFSDM_FilterConfigRegChannel(hDfsdmFilter, MXInit->Channel4Filter, DFSDM_CONTINUOUS_CONV_ON) != HAL_OK)
 800b850:	69e1      	ldr	r1, [r4, #28]
 800b852:	4632      	mov	r2, r6
 800b854:	4628      	mov	r0, r5
 800b856:	f004 fbc5 	bl	800ffe4 <HAL_DFSDM_FilterConfigRegChannel>
    status = HAL_ERROR;
 800b85a:	3800      	subs	r0, #0
 800b85c:	bf18      	it	ne
 800b85e:	2001      	movne	r0, #1
}
 800b860:	bd70      	pop	{r4, r5, r6, pc}
 800b862:	bf00      	nop

0800b864 <BSP_AUDIO_IN_Init>:
  if (Instance >= AUDIO_IN_INSTANCES_NBR)
 800b864:	2800      	cmp	r0, #0
 800b866:	f040 81bc 	bne.w	800bbe2 <BSP_AUDIO_IN_Init+0x37e>
{
 800b86a:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  else if (Audio_In_Ctx[Instance].State != AUDIO_IN_STATE_RESET)
 800b86e:	4ca1      	ldr	r4, [pc, #644]	; (800baf4 <BSP_AUDIO_IN_Init+0x290>)
 800b870:	69e3      	ldr	r3, [r4, #28]
{
 800b872:	b08c      	sub	sp, #48	; 0x30
  else if (Audio_In_Ctx[Instance].State != AUDIO_IN_STATE_RESET)
 800b874:	2b00      	cmp	r3, #0
 800b876:	f040 81b7 	bne.w	800bbe8 <BSP_AUDIO_IN_Init+0x384>
  else if (AudioInit->BitsPerSample != AUDIO_RESOLUTION_16b)
 800b87a:	688e      	ldr	r6, [r1, #8]
 800b87c:	2e10      	cmp	r6, #16
 800b87e:	f040 80a4 	bne.w	800b9ca <BSP_AUDIO_IN_Init+0x166>
  else if (((AudioInit->Device == AUDIO_IN_DIGITAL_MIC) && (AudioInit->ChannelsNbr != 2U)) ||
 800b882:	680b      	ldr	r3, [r1, #0]
 800b884:	68ca      	ldr	r2, [r1, #12]
 800b886:	2b30      	cmp	r3, #48	; 0x30
 800b888:	f000 809c 	beq.w	800b9c4 <BSP_AUDIO_IN_Init+0x160>
 800b88c:	2b10      	cmp	r3, #16
 800b88e:	d172      	bne.n	800b976 <BSP_AUDIO_IN_Init+0x112>
           ((AudioInit->Device == AUDIO_IN_DIGITAL_MIC2) && (AudioInit->ChannelsNbr != 1U)))
 800b890:	2a01      	cmp	r2, #1
 800b892:	f040 809a 	bne.w	800b9ca <BSP_AUDIO_IN_Init+0x166>
    Audio_In_Ctx[Instance].Device         = AudioInit->Device;
 800b896:	6023      	str	r3, [r4, #0]
    Audio_In_Ctx[Instance].SampleRate     = AudioInit->SampleRate;
 800b898:	684b      	ldr	r3, [r1, #4]
    haudio_in_dfsdm_channel[0].Instance = DFSDM1_Channel2;
 800b89a:	4d97      	ldr	r5, [pc, #604]	; (800baf8 <BSP_AUDIO_IN_Init+0x294>)
    Audio_In_Ctx[Instance].ChannelsNbr    = AudioInit->ChannelsNbr;
 800b89c:	60e2      	str	r2, [r4, #12]
    Audio_In_Ctx[Instance].SampleRate     = AudioInit->SampleRate;
 800b89e:	6063      	str	r3, [r4, #4]
    Audio_In_Ctx[Instance].Volume         = AudioInit->Volume;
 800b8a0:	690a      	ldr	r2, [r1, #16]
    haudio_in_dfsdm_channel[0].Instance = DFSDM1_Channel2;
 800b8a2:	4f96      	ldr	r7, [pc, #600]	; (800bafc <BSP_AUDIO_IN_Init+0x298>)
    haudio_in_dfsdm_channel[1].Instance = DFSDM1_Channel1;
 800b8a4:	f8df 825c 	ldr.w	r8, [pc, #604]	; 800bb04 <BSP_AUDIO_IN_Init+0x2a0>
    Audio_In_Ctx[Instance].Volume         = AudioInit->Volume;
 800b8a8:	61a2      	str	r2, [r4, #24]
    if (MX_DFSDM1_ClockConfig(&haudio_in_dfsdm_channel[0], AudioInit->SampleRate) != HAL_OK)
 800b8aa:	4619      	mov	r1, r3
    haudio_in_dfsdm_filter[0].Instance  = DFSDM1_Filter0;
 800b8ac:	4b94      	ldr	r3, [pc, #592]	; (800bb00 <BSP_AUDIO_IN_Init+0x29c>)
 800b8ae:	f8c5 3090 	str.w	r3, [r5, #144]	; 0x90
    haudio_in_dfsdm_filter[1].Instance  = DFSDM1_Filter1;
 800b8b2:	3380      	adds	r3, #128	; 0x80
 800b8b4:	f8c5 30e4 	str.w	r3, [r5, #228]	; 0xe4
    if (MX_DFSDM1_ClockConfig(&haudio_in_dfsdm_channel[0], AudioInit->SampleRate) != HAL_OK)
 800b8b8:	f505 709c 	add.w	r0, r5, #312	; 0x138
    Audio_In_Ctx[Instance].BitsPerSample  = AudioInit->BitsPerSample;
 800b8bc:	2310      	movs	r3, #16
    haudio_in_dfsdm_channel[0].Instance = DFSDM1_Channel2;
 800b8be:	f8c5 7138 	str.w	r7, [r5, #312]	; 0x138
    haudio_in_dfsdm_channel[1].Instance = DFSDM1_Channel1;
 800b8c2:	f8c5 8170 	str.w	r8, [r5, #368]	; 0x170
    Audio_In_Ctx[Instance].BitsPerSample  = AudioInit->BitsPerSample;
 800b8c6:	60a3      	str	r3, [r4, #8]
    if (MX_DFSDM1_ClockConfig(&haudio_in_dfsdm_channel[0], AudioInit->SampleRate) != HAL_OK)
 800b8c8:	f017 f84a 	bl	8022960 <MX_DFSDM1_ClockConfig>
 800b8cc:	2800      	cmp	r0, #0
 800b8ce:	f040 818e 	bne.w	800bbee <BSP_AUDIO_IN_Init+0x38a>
      if ((Audio_In_Ctx[Instance].Device & AUDIO_IN_DIGITAL_MIC1) == AUDIO_IN_DIGITAL_MIC1)
 800b8d2:	6823      	ldr	r3, [r4, #0]
 800b8d4:	06da      	lsls	r2, r3, #27
 800b8d6:	d47b      	bmi.n	800b9d0 <BSP_AUDIO_IN_Init+0x16c>
      if ((Audio_In_Ctx[Instance].Device & AUDIO_IN_DIGITAL_MIC2) == AUDIO_IN_DIGITAL_MIC2)
 800b8d8:	069a      	lsls	r2, r3, #26
 800b8da:	d569      	bpl.n	800b9b0 <BSP_AUDIO_IN_Init+0x14c>
        DFSDM_ChannelMspInit(&haudio_in_dfsdm_channel[1]);
 800b8dc:	f8d5 2170 	ldr.w	r2, [r5, #368]	; 0x170
  if (((hdfsdm_channel->Instance == DFSDM1_Channel2) && ((Audio_In_Ctx[0].Device & AUDIO_IN_DIGITAL_MIC1) != 0U)) || \
 800b8e0:	4986      	ldr	r1, [pc, #536]	; (800bafc <BSP_AUDIO_IN_Init+0x298>)
 800b8e2:	428a      	cmp	r2, r1
 800b8e4:	f000 80d7 	beq.w	800ba96 <BSP_AUDIO_IN_Init+0x232>
 800b8e8:	4986      	ldr	r1, [pc, #536]	; (800bb04 <BSP_AUDIO_IN_Init+0x2a0>)
 800b8ea:	428a      	cmp	r2, r1
 800b8ec:	f000 80eb 	beq.w	800bac6 <BSP_AUDIO_IN_Init+0x262>
        DFSDM_FilterMspInit(&haudio_in_dfsdm_filter[1]);
 800b8f0:	4885      	ldr	r0, [pc, #532]	; (800bb08 <BSP_AUDIO_IN_Init+0x2a4>)
 800b8f2:	9001      	str	r0, [sp, #4]
 800b8f4:	f7ff fdb2 	bl	800b45c <DFSDM_FilterMspInit>
        if ((Audio_In_Ctx[Instance].Device & AUDIO_IN_DIGITAL_MIC1) == AUDIO_IN_DIGITAL_MIC1)
 800b8f8:	6823      	ldr	r3, [r4, #0]
 800b8fa:	06da      	lsls	r2, r3, #27
 800b8fc:	d477      	bmi.n	800b9ee <BSP_AUDIO_IN_Init+0x18a>
        if (((Audio_In_Ctx[Instance].Device & AUDIO_IN_DIGITAL_MIC2) == AUDIO_IN_DIGITAL_MIC2) && (status == BSP_ERROR_NONE))
 800b8fe:	069f      	lsls	r7, r3, #26
 800b900:	d556      	bpl.n	800b9b0 <BSP_AUDIO_IN_Init+0x14c>
 800b902:	9801      	ldr	r0, [sp, #4]
 800b904:	aa02      	add	r2, sp, #8
          mxDfsdmInit.ClockDivider    = DFSDM_CLOCK_DIVIDER(Audio_In_Ctx[Instance].SampleRate);
 800b906:	6867      	ldr	r7, [r4, #4]
          mxDfsdmInit.ChannelInstance = DFSDM1_Channel1;
 800b908:	497e      	ldr	r1, [pc, #504]	; (800bb04 <BSP_AUDIO_IN_Init+0x2a0>)
 800b90a:	9106      	str	r1, [sp, #24]
          mxDfsdmInit.ClockDivider    = DFSDM_CLOCK_DIVIDER(Audio_In_Ctx[Instance].SampleRate);
 800b90c:	f5b7 5ffa 	cmp.w	r7, #8000	; 0x1f40
 800b910:	d034      	beq.n	800b97c <BSP_AUDIO_IN_Init+0x118>
 800b912:	f642 3111 	movw	r1, #11025	; 0x2b11
 800b916:	428f      	cmp	r7, r1
 800b918:	f000 812b 	beq.w	800bb72 <BSP_AUDIO_IN_Init+0x30e>
 800b91c:	f5b7 5f7a 	cmp.w	r7, #16000	; 0x3e80
 800b920:	f000 813f 	beq.w	800bba2 <BSP_AUDIO_IN_Init+0x33e>
 800b924:	f245 6122 	movw	r1, #22050	; 0x5622
 800b928:	428f      	cmp	r7, r1
 800b92a:	f000 80fb 	beq.w	800bb24 <BSP_AUDIO_IN_Init+0x2c0>
 800b92e:	f5b7 4ffa 	cmp.w	r7, #32000	; 0x7d00
 800b932:	f000 815f 	beq.w	800bbf4 <BSP_AUDIO_IN_Init+0x390>
 800b936:	f64a 4144 	movw	r1, #44100	; 0xac44
 800b93a:	428f      	cmp	r7, r1
 800b93c:	f000 817c 	beq.w	800bc38 <BSP_AUDIO_IN_Init+0x3d4>
          mxDfsdmInit.DigitalMicType  = DFSDM_CHANNEL_SPI_RISING;
 800b940:	f04f 0c00 	mov.w	ip, #0
 800b944:	f44f 7e80 	mov.w	lr, #256	; 0x100
 800b948:	e9cd ec07 	strd	lr, ip, [sp, #28]
          mxDfsdmInit.RightBitShift   = DFSDM_MIC_BIT_SHIFT(Audio_In_Ctx[Instance].SampleRate);
 800b94c:	f64b 3c80 	movw	ip, #48000	; 0xbb80
          mxDfsdmInit.ClockDivider    = DFSDM_CLOCK_DIVIDER(Audio_In_Ctx[Instance].SampleRate);
 800b950:	2120      	movs	r1, #32
          mxDfsdmInit.RightBitShift   = DFSDM_MIC_BIT_SHIFT(Audio_In_Ctx[Instance].SampleRate);
 800b952:	4567      	cmp	r7, ip
          mxDfsdmInit.ClockDivider    = DFSDM_CLOCK_DIVIDER(Audio_In_Ctx[Instance].SampleRate);
 800b954:	910a      	str	r1, [sp, #40]	; 0x28
          mxDfsdmInit.RightBitShift   = DFSDM_MIC_BIT_SHIFT(Audio_In_Ctx[Instance].SampleRate);
 800b956:	f000 8184 	beq.w	800bc62 <BSP_AUDIO_IN_Init+0x3fe>
          if (Audio_In_Ctx[Instance].Device == AUDIO_IN_DIGITAL_MIC2)
 800b95a:	3b20      	subs	r3, #32
 800b95c:	bf18      	it	ne
 800b95e:	2301      	movne	r3, #1
 800b960:	9303      	str	r3, [sp, #12]
          mxDfsdmInit.Channel4Filter  = DFSDM_CHANNEL_1;
 800b962:	4b6a      	ldr	r3, [pc, #424]	; (800bb0c <BSP_AUDIO_IN_Init+0x2a8>)
 800b964:	9309      	str	r3, [sp, #36]	; 0x24
          mxDfsdmInit.FilterInstance  = DFSDM1_Filter1;
 800b966:	4b6a      	ldr	r3, [pc, #424]	; (800bb10 <BSP_AUDIO_IN_Init+0x2ac>)
 800b968:	9302      	str	r3, [sp, #8]
          mxDfsdmInit.RightBitShift   = DFSDM_MIC_BIT_SHIFT(Audio_In_Ctx[Instance].SampleRate);
 800b96a:	2304      	movs	r3, #4
 800b96c:	930b      	str	r3, [sp, #44]	; 0x2c
          mxDfsdmInit.SincOrder       = DFSDM_FILTER_ORDER(Audio_In_Ctx[Instance].SampleRate);
 800b96e:	f04f 4320 	mov.w	r3, #2684354560	; 0xa0000000
 800b972:	9304      	str	r3, [sp, #16]
          mxDfsdmInit.Oversampling    = DFSDM_OVER_SAMPLING(Audio_In_Ctx[Instance].SampleRate);
 800b974:	e016      	b.n	800b9a4 <BSP_AUDIO_IN_Init+0x140>
           ((AudioInit->Device == AUDIO_IN_DIGITAL_MIC1) && (AudioInit->ChannelsNbr != 1U)) ||
 800b976:	2b20      	cmp	r3, #32
 800b978:	d08a      	beq.n	800b890 <BSP_AUDIO_IN_Init+0x2c>
 800b97a:	e78c      	b.n	800b896 <BSP_AUDIO_IN_Init+0x32>
          if (Audio_In_Ctx[Instance].Device == AUDIO_IN_DIGITAL_MIC2)
 800b97c:	3b20      	subs	r3, #32
 800b97e:	bf18      	it	ne
 800b980:	2301      	movne	r3, #1
 800b982:	9303      	str	r3, [sp, #12]
          mxDfsdmInit.SincOrder       = DFSDM_FILTER_ORDER(Audio_In_Ctx[Instance].SampleRate);
 800b984:	f04f 43c0 	mov.w	r3, #1610612736	; 0x60000000
 800b988:	9304      	str	r3, [sp, #16]
          mxDfsdmInit.Channel4Filter  = DFSDM_CHANNEL_1;
 800b98a:	4b60      	ldr	r3, [pc, #384]	; (800bb0c <BSP_AUDIO_IN_Init+0x2a8>)
 800b98c:	9309      	str	r3, [sp, #36]	; 0x24
          mxDfsdmInit.FilterInstance  = DFSDM1_Filter1;
 800b98e:	4b60      	ldr	r3, [pc, #384]	; (800bb10 <BSP_AUDIO_IN_Init+0x2ac>)
 800b990:	9302      	str	r3, [sp, #8]
          mxDfsdmInit.ClockDivider    = DFSDM_CLOCK_DIVIDER(Audio_In_Ctx[Instance].SampleRate);
 800b992:	2318      	movs	r3, #24
 800b994:	930a      	str	r3, [sp, #40]	; 0x28
          mxDfsdmInit.DigitalMicType  = DFSDM_CHANNEL_SPI_RISING;
 800b996:	2300      	movs	r3, #0
          mxDfsdmInit.DigitalMicPins  = DFSDM_CHANNEL_FOLLOWING_CHANNEL_PINS;
 800b998:	f44f 7680 	mov.w	r6, #256	; 0x100
          mxDfsdmInit.DigitalMicType  = DFSDM_CHANNEL_SPI_RISING;
 800b99c:	9308      	str	r3, [sp, #32]
          mxDfsdmInit.RightBitShift   = DFSDM_MIC_BIT_SHIFT(Audio_In_Ctx[Instance].SampleRate);
 800b99e:	2305      	movs	r3, #5
          mxDfsdmInit.DigitalMicPins  = DFSDM_CHANNEL_FOLLOWING_CHANNEL_PINS;
 800b9a0:	9607      	str	r6, [sp, #28]
          mxDfsdmInit.RightBitShift   = DFSDM_MIC_BIT_SHIFT(Audio_In_Ctx[Instance].SampleRate);
 800b9a2:	930b      	str	r3, [sp, #44]	; 0x2c
          if (MX_DFSDM1_Init(&haudio_in_dfsdm_filter[1], &haudio_in_dfsdm_channel[1], &mxDfsdmInit) != HAL_OK)
 800b9a4:	495b      	ldr	r1, [pc, #364]	; (800bb14 <BSP_AUDIO_IN_Init+0x2b0>)
          mxDfsdmInit.Oversampling    = DFSDM_OVER_SAMPLING(Audio_In_Ctx[Instance].SampleRate);
 800b9a6:	9605      	str	r6, [sp, #20]
          if (MX_DFSDM1_Init(&haudio_in_dfsdm_filter[1], &haudio_in_dfsdm_channel[1], &mxDfsdmInit) != HAL_OK)
 800b9a8:	f7ff ff16 	bl	800b7d8 <MX_DFSDM1_Init>
 800b9ac:	2800      	cmp	r0, #0
 800b9ae:	d17d      	bne.n	800baac <BSP_AUDIO_IN_Init+0x248>
          Audio_DmaDigMic1RecHalfBuffCplt = 0;
 800b9b0:	2000      	movs	r0, #0
          Audio_DmaDigMic1RecBuffCplt     = 0;
 800b9b2:	e9c5 006a 	strd	r0, r0, [r5, #424]	; 0x1a8
          Audio_DmaDigMic2RecBuffCplt     = 0;
 800b9b6:	e9c5 006c 	strd	r0, r0, [r5, #432]	; 0x1b0
          Audio_In_Ctx[Instance].State = AUDIO_IN_STATE_STOP;
 800b9ba:	2302      	movs	r3, #2
 800b9bc:	61e3      	str	r3, [r4, #28]
}
 800b9be:	b00c      	add	sp, #48	; 0x30
 800b9c0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  else if (((AudioInit->Device == AUDIO_IN_DIGITAL_MIC) && (AudioInit->ChannelsNbr != 2U)) ||
 800b9c4:	2a02      	cmp	r2, #2
 800b9c6:	f43f af66 	beq.w	800b896 <BSP_AUDIO_IN_Init+0x32>
    status = BSP_ERROR_FEATURE_NOT_SUPPORTED;
 800b9ca:	f06f 000a 	mvn.w	r0, #10
 800b9ce:	e7f6      	b.n	800b9be <BSP_AUDIO_IN_Init+0x15a>
        DFSDM_ChannelMspInit(&haudio_in_dfsdm_channel[0]);
 800b9d0:	f8d5 2138 	ldr.w	r2, [r5, #312]	; 0x138
  if (((hdfsdm_channel->Instance == DFSDM1_Channel2) && ((Audio_In_Ctx[0].Device & AUDIO_IN_DIGITAL_MIC1) != 0U)) || \
 800b9d4:	42ba      	cmp	r2, r7
 800b9d6:	d066      	beq.n	800baa6 <BSP_AUDIO_IN_Init+0x242>
 800b9d8:	4542      	cmp	r2, r8
 800b9da:	d062      	beq.n	800baa2 <BSP_AUDIO_IN_Init+0x23e>
        DFSDM_FilterMspInit(&haudio_in_dfsdm_filter[0]);
 800b9dc:	484e      	ldr	r0, [pc, #312]	; (800bb18 <BSP_AUDIO_IN_Init+0x2b4>)
 800b9de:	f7ff fd3d 	bl	800b45c <DFSDM_FilterMspInit>
      if ((Audio_In_Ctx[Instance].Device & AUDIO_IN_DIGITAL_MIC2) == AUDIO_IN_DIGITAL_MIC2)
 800b9e2:	6823      	ldr	r3, [r4, #0]
 800b9e4:	0698      	lsls	r0, r3, #26
 800b9e6:	f53f af79 	bmi.w	800b8dc <BSP_AUDIO_IN_Init+0x78>
        if ((Audio_In_Ctx[Instance].Device & AUDIO_IN_DIGITAL_MIC1) == AUDIO_IN_DIGITAL_MIC1)
 800b9ea:	06d9      	lsls	r1, r3, #27
 800b9ec:	d5e0      	bpl.n	800b9b0 <BSP_AUDIO_IN_Init+0x14c>
          mxDfsdmInit.ClockDivider    = DFSDM_CLOCK_DIVIDER(Audio_In_Ctx[Instance].SampleRate);
 800b9ee:	6863      	ldr	r3, [r4, #4]
          mxDfsdmInit.ChannelInstance = DFSDM1_Channel2;
 800b9f0:	4a42      	ldr	r2, [pc, #264]	; (800bafc <BSP_AUDIO_IN_Init+0x298>)
 800b9f2:	9206      	str	r2, [sp, #24]
          mxDfsdmInit.ClockDivider    = DFSDM_CLOCK_DIVIDER(Audio_In_Ctx[Instance].SampleRate);
 800b9f4:	f5b3 5ffa 	cmp.w	r3, #8000	; 0x1f40
 800b9f8:	d05d      	beq.n	800bab6 <BSP_AUDIO_IN_Init+0x252>
 800b9fa:	f642 3211 	movw	r2, #11025	; 0x2b11
 800b9fe:	4293      	cmp	r3, r2
 800ba00:	d028      	beq.n	800ba54 <BSP_AUDIO_IN_Init+0x1f0>
 800ba02:	f5b3 5f7a 	cmp.w	r3, #16000	; 0x3e80
 800ba06:	d062      	beq.n	800bace <BSP_AUDIO_IN_Init+0x26a>
 800ba08:	f245 6222 	movw	r2, #22050	; 0x5622
 800ba0c:	4293      	cmp	r3, r2
 800ba0e:	f000 80c5 	beq.w	800bb9c <BSP_AUDIO_IN_Init+0x338>
 800ba12:	f5b3 4ffa 	cmp.w	r3, #32000	; 0x7d00
 800ba16:	f000 80d2 	beq.w	800bbbe <BSP_AUDIO_IN_Init+0x35a>
 800ba1a:	f64a 4244 	movw	r2, #44100	; 0xac44
 800ba1e:	4293      	cmp	r3, r2
 800ba20:	f000 8096 	beq.w	800bb50 <BSP_AUDIO_IN_Init+0x2ec>
          mxDfsdmInit.DigitalMicType  = DFSDM_CHANNEL_SPI_FALLING;
 800ba24:	2001      	movs	r0, #1
 800ba26:	2100      	movs	r1, #0
 800ba28:	e9cd 1007 	strd	r1, r0, [sp, #28]
          mxDfsdmInit.RightBitShift   = DFSDM_MIC_BIT_SHIFT(Audio_In_Ctx[Instance].SampleRate);
 800ba2c:	f64b 3080 	movw	r0, #48000	; 0xbb80
          mxDfsdmInit.ClockDivider    = DFSDM_CLOCK_DIVIDER(Audio_In_Ctx[Instance].SampleRate);
 800ba30:	2220      	movs	r2, #32
          mxDfsdmInit.RightBitShift   = DFSDM_MIC_BIT_SHIFT(Audio_In_Ctx[Instance].SampleRate);
 800ba32:	4283      	cmp	r3, r0
          mxDfsdmInit.ClockDivider    = DFSDM_CLOCK_DIVIDER(Audio_In_Ctx[Instance].SampleRate);
 800ba34:	920a      	str	r2, [sp, #40]	; 0x28
          mxDfsdmInit.RightBitShift   = DFSDM_MIC_BIT_SHIFT(Audio_In_Ctx[Instance].SampleRate);
 800ba36:	f000 80f3 	beq.w	800bc20 <BSP_AUDIO_IN_Init+0x3bc>
 800ba3a:	2304      	movs	r3, #4
 800ba3c:	930b      	str	r3, [sp, #44]	; 0x2c
          mxDfsdmInit.Channel4Filter  = DFSDM_CHANNEL_2;
 800ba3e:	f503 3300 	add.w	r3, r3, #131072	; 0x20000
 800ba42:	9309      	str	r3, [sp, #36]	; 0x24
          mxDfsdmInit.FilterInstance  = DFSDM1_Filter0;
 800ba44:	4b2e      	ldr	r3, [pc, #184]	; (800bb00 <BSP_AUDIO_IN_Init+0x29c>)
 800ba46:	9302      	str	r3, [sp, #8]
          mxDfsdmInit.SincOrder       = DFSDM_FILTER_ORDER(Audio_In_Ctx[Instance].SampleRate);
 800ba48:	f04f 4320 	mov.w	r3, #2684354560	; 0xa0000000
 800ba4c:	e9cd 1303 	strd	r1, r3, [sp, #12]
          mxDfsdmInit.Oversampling    = DFSDM_OVER_SAMPLING(Audio_In_Ctx[Instance].SampleRate);
 800ba50:	2310      	movs	r3, #16
 800ba52:	e011      	b.n	800ba78 <BSP_AUDIO_IN_Init+0x214>
          mxDfsdmInit.ClockDivider    = DFSDM_CLOCK_DIVIDER(Audio_In_Ctx[Instance].SampleRate);
 800ba54:	2204      	movs	r2, #4
          mxDfsdmInit.DigitalMicPins  = DFSDM_CHANNEL_SAME_CHANNEL_PINS;
 800ba56:	2300      	movs	r3, #0
          mxDfsdmInit.ClockDivider    = DFSDM_CLOCK_DIVIDER(Audio_In_Ctx[Instance].SampleRate);
 800ba58:	920a      	str	r2, [sp, #40]	; 0x28
          mxDfsdmInit.DigitalMicType  = DFSDM_CHANNEL_SPI_FALLING;
 800ba5a:	2201      	movs	r2, #1
 800ba5c:	e9cd 3207 	strd	r3, r2, [sp, #28]
          mxDfsdmInit.RightBitShift   = DFSDM_MIC_BIT_SHIFT(Audio_In_Ctx[Instance].SampleRate);
 800ba60:	2206      	movs	r2, #6
 800ba62:	920b      	str	r2, [sp, #44]	; 0x2c
          mxDfsdmInit.Channel4Filter  = DFSDM_CHANNEL_2;
 800ba64:	4a2d      	ldr	r2, [pc, #180]	; (800bb1c <BSP_AUDIO_IN_Init+0x2b8>)
 800ba66:	9209      	str	r2, [sp, #36]	; 0x24
          mxDfsdmInit.FilterInstance  = DFSDM1_Filter0;
 800ba68:	4a25      	ldr	r2, [pc, #148]	; (800bb00 <BSP_AUDIO_IN_Init+0x29c>)
 800ba6a:	9202      	str	r2, [sp, #8]
          mxDfsdmInit.SincOrder       = DFSDM_FILTER_ORDER(Audio_In_Ctx[Instance].SampleRate);
 800ba6c:	f04f 42c0 	mov.w	r2, #1610612736	; 0x60000000
 800ba70:	e9cd 3203 	strd	r3, r2, [sp, #12]
          mxDfsdmInit.Oversampling    = DFSDM_OVER_SAMPLING(Audio_In_Ctx[Instance].SampleRate);
 800ba74:	f44f 7380 	mov.w	r3, #256	; 0x100
          if (MX_DFSDM1_Init(&haudio_in_dfsdm_filter[0], &haudio_in_dfsdm_channel[0], &mxDfsdmInit) != HAL_OK)
 800ba78:	4929      	ldr	r1, [pc, #164]	; (800bb20 <BSP_AUDIO_IN_Init+0x2bc>)
          mxDfsdmInit.Oversampling    = DFSDM_OVER_SAMPLING(Audio_In_Ctx[Instance].SampleRate);
 800ba7a:	9305      	str	r3, [sp, #20]
          if (MX_DFSDM1_Init(&haudio_in_dfsdm_filter[0], &haudio_in_dfsdm_channel[0], &mxDfsdmInit) != HAL_OK)
 800ba7c:	aa02      	add	r2, sp, #8
 800ba7e:	f1a1 00a8 	sub.w	r0, r1, #168	; 0xa8
 800ba82:	9201      	str	r2, [sp, #4]
 800ba84:	f7ff fea8 	bl	800b7d8 <MX_DFSDM1_Init>
 800ba88:	9a01      	ldr	r2, [sp, #4]
 800ba8a:	b978      	cbnz	r0, 800baac <BSP_AUDIO_IN_Init+0x248>
        if (((Audio_In_Ctx[Instance].Device & AUDIO_IN_DIGITAL_MIC2) == AUDIO_IN_DIGITAL_MIC2) && (status == BSP_ERROR_NONE))
 800ba8c:	6823      	ldr	r3, [r4, #0]
 800ba8e:	0698      	lsls	r0, r3, #26
 800ba90:	d58e      	bpl.n	800b9b0 <BSP_AUDIO_IN_Init+0x14c>
 800ba92:	481d      	ldr	r0, [pc, #116]	; (800bb08 <BSP_AUDIO_IN_Init+0x2a4>)
 800ba94:	e737      	b.n	800b906 <BSP_AUDIO_IN_Init+0xa2>
  if (((hdfsdm_channel->Instance == DFSDM1_Channel2) && ((Audio_In_Ctx[0].Device & AUDIO_IN_DIGITAL_MIC1) != 0U)) || \
 800ba96:	06d9      	lsls	r1, r3, #27
 800ba98:	f57f af2a 	bpl.w	800b8f0 <BSP_AUDIO_IN_Init+0x8c>
 800ba9c:	f7ff fd5c 	bl	800b558 <DFSDM_ChannelMspInit.part.0>
 800baa0:	e726      	b.n	800b8f0 <BSP_AUDIO_IN_Init+0x8c>
      ((hdfsdm_channel->Instance == DFSDM1_Channel1) && (Audio_In_Ctx[0].Device == AUDIO_IN_DIGITAL_MIC2)))
 800baa2:	2b20      	cmp	r3, #32
 800baa4:	d19a      	bne.n	800b9dc <BSP_AUDIO_IN_Init+0x178>
 800baa6:	f7ff fd57 	bl	800b558 <DFSDM_ChannelMspInit.part.0>
 800baaa:	e797      	b.n	800b9dc <BSP_AUDIO_IN_Init+0x178>
            status = BSP_ERROR_PERIPH_FAILURE;
 800baac:	f06f 0003 	mvn.w	r0, #3
}
 800bab0:	b00c      	add	sp, #48	; 0x30
 800bab2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
          mxDfsdmInit.ClockDivider    = DFSDM_CLOCK_DIVIDER(Audio_In_Ctx[Instance].SampleRate);
 800bab6:	2218      	movs	r2, #24
          mxDfsdmInit.DigitalMicPins  = DFSDM_CHANNEL_SAME_CHANNEL_PINS;
 800bab8:	2300      	movs	r3, #0
          mxDfsdmInit.ClockDivider    = DFSDM_CLOCK_DIVIDER(Audio_In_Ctx[Instance].SampleRate);
 800baba:	920a      	str	r2, [sp, #40]	; 0x28
          mxDfsdmInit.DigitalMicType  = DFSDM_CHANNEL_SPI_FALLING;
 800babc:	2201      	movs	r2, #1
 800babe:	e9cd 3207 	strd	r3, r2, [sp, #28]
          mxDfsdmInit.RightBitShift   = DFSDM_MIC_BIT_SHIFT(Audio_In_Ctx[Instance].SampleRate);
 800bac2:	2205      	movs	r2, #5
 800bac4:	e7cd      	b.n	800ba62 <BSP_AUDIO_IN_Init+0x1fe>
      ((hdfsdm_channel->Instance == DFSDM1_Channel1) && (Audio_In_Ctx[0].Device == AUDIO_IN_DIGITAL_MIC2)))
 800bac6:	2b20      	cmp	r3, #32
 800bac8:	f47f af12 	bne.w	800b8f0 <BSP_AUDIO_IN_Init+0x8c>
 800bacc:	e7e6      	b.n	800ba9c <BSP_AUDIO_IN_Init+0x238>
          mxDfsdmInit.DigitalMicPins  = DFSDM_CHANNEL_SAME_CHANNEL_PINS;
 800bace:	2300      	movs	r3, #0
          mxDfsdmInit.ClockDivider    = DFSDM_CLOCK_DIVIDER(Audio_In_Ctx[Instance].SampleRate);
 800bad0:	2218      	movs	r2, #24
 800bad2:	920a      	str	r2, [sp, #40]	; 0x28
          mxDfsdmInit.DigitalMicType  = DFSDM_CHANNEL_SPI_FALLING;
 800bad4:	2201      	movs	r2, #1
 800bad6:	e9cd 3207 	strd	r3, r2, [sp, #28]
          mxDfsdmInit.RightBitShift   = DFSDM_MIC_BIT_SHIFT(Audio_In_Ctx[Instance].SampleRate);
 800bada:	2203      	movs	r2, #3
 800badc:	920b      	str	r2, [sp, #44]	; 0x2c
          mxDfsdmInit.Channel4Filter  = DFSDM_CHANNEL_2;
 800bade:	4a0f      	ldr	r2, [pc, #60]	; (800bb1c <BSP_AUDIO_IN_Init+0x2b8>)
 800bae0:	9209      	str	r2, [sp, #36]	; 0x24
          mxDfsdmInit.FilterInstance  = DFSDM1_Filter0;
 800bae2:	4a07      	ldr	r2, [pc, #28]	; (800bb00 <BSP_AUDIO_IN_Init+0x29c>)
 800bae4:	9202      	str	r2, [sp, #8]
          mxDfsdmInit.SincOrder       = DFSDM_FILTER_ORDER(Audio_In_Ctx[Instance].SampleRate);
 800bae6:	f04f 42c0 	mov.w	r2, #1610612736	; 0x60000000
 800baea:	e9cd 3203 	strd	r3, r2, [sp, #12]
          mxDfsdmInit.Oversampling    = DFSDM_OVER_SAMPLING(Audio_In_Ctx[Instance].SampleRate);
 800baee:	2380      	movs	r3, #128	; 0x80
 800baf0:	e7c2      	b.n	800ba78 <BSP_AUDIO_IN_Init+0x214>
 800baf2:	bf00      	nop
 800baf4:	20000000 	.word	0x20000000
 800baf8:	20002314 	.word	0x20002314
 800bafc:	40016040 	.word	0x40016040
 800bb00:	40016100 	.word	0x40016100
 800bb04:	40016020 	.word	0x40016020
 800bb08:	200023f8 	.word	0x200023f8
 800bb0c:	00010002 	.word	0x00010002
 800bb10:	40016180 	.word	0x40016180
 800bb14:	20002484 	.word	0x20002484
 800bb18:	200023a4 	.word	0x200023a4
 800bb1c:	00020004 	.word	0x00020004
 800bb20:	2000244c 	.word	0x2000244c
          if (Audio_In_Ctx[Instance].Device == AUDIO_IN_DIGITAL_MIC2)
 800bb24:	3b20      	subs	r3, #32
 800bb26:	bf18      	it	ne
 800bb28:	2301      	movne	r3, #1
 800bb2a:	9303      	str	r3, [sp, #12]
          mxDfsdmInit.SincOrder       = DFSDM_FILTER_ORDER(Audio_In_Ctx[Instance].SampleRate);
 800bb2c:	f04f 43c0 	mov.w	r3, #1610612736	; 0x60000000
 800bb30:	9304      	str	r3, [sp, #16]
          mxDfsdmInit.Channel4Filter  = DFSDM_CHANNEL_1;
 800bb32:	4b53      	ldr	r3, [pc, #332]	; (800bc80 <BSP_AUDIO_IN_Init+0x41c>)
 800bb34:	9309      	str	r3, [sp, #36]	; 0x24
          mxDfsdmInit.FilterInstance  = DFSDM1_Filter1;
 800bb36:	4b53      	ldr	r3, [pc, #332]	; (800bc84 <BSP_AUDIO_IN_Init+0x420>)
 800bb38:	9302      	str	r3, [sp, #8]
          mxDfsdmInit.Oversampling    = DFSDM_OVER_SAMPLING(Audio_In_Ctx[Instance].SampleRate);
 800bb3a:	2680      	movs	r6, #128	; 0x80
          mxDfsdmInit.ClockDivider    = DFSDM_CLOCK_DIVIDER(Audio_In_Ctx[Instance].SampleRate);
 800bb3c:	2304      	movs	r3, #4
 800bb3e:	930a      	str	r3, [sp, #40]	; 0x28
          mxDfsdmInit.DigitalMicType  = DFSDM_CHANNEL_SPI_RISING;
 800bb40:	f44f 7180 	mov.w	r1, #256	; 0x100
 800bb44:	2300      	movs	r3, #0
 800bb46:	e9cd 1307 	strd	r1, r3, [sp, #28]
          mxDfsdmInit.RightBitShift   = DFSDM_MIC_BIT_SHIFT(Audio_In_Ctx[Instance].SampleRate);
 800bb4a:	2303      	movs	r3, #3
 800bb4c:	930b      	str	r3, [sp, #44]	; 0x2c
          mxDfsdmInit.Oversampling    = DFSDM_OVER_SAMPLING(Audio_In_Ctx[Instance].SampleRate);
 800bb4e:	e729      	b.n	800b9a4 <BSP_AUDIO_IN_Init+0x140>
          mxDfsdmInit.ClockDivider    = DFSDM_CLOCK_DIVIDER(Audio_In_Ctx[Instance].SampleRate);
 800bb50:	2204      	movs	r2, #4
          mxDfsdmInit.DigitalMicPins  = DFSDM_CHANNEL_SAME_CHANNEL_PINS;
 800bb52:	2300      	movs	r3, #0
          mxDfsdmInit.ClockDivider    = DFSDM_CLOCK_DIVIDER(Audio_In_Ctx[Instance].SampleRate);
 800bb54:	920a      	str	r2, [sp, #40]	; 0x28
          mxDfsdmInit.DigitalMicType  = DFSDM_CHANNEL_SPI_FALLING;
 800bb56:	2201      	movs	r2, #1
 800bb58:	e9cd 3207 	strd	r3, r2, [sp, #28]
          mxDfsdmInit.Channel4Filter  = DFSDM_CHANNEL_2;
 800bb5c:	4a4a      	ldr	r2, [pc, #296]	; (800bc88 <BSP_AUDIO_IN_Init+0x424>)
 800bb5e:	9209      	str	r2, [sp, #36]	; 0x24
          mxDfsdmInit.FilterInstance  = DFSDM1_Filter0;
 800bb60:	4a4a      	ldr	r2, [pc, #296]	; (800bc8c <BSP_AUDIO_IN_Init+0x428>)
 800bb62:	9202      	str	r2, [sp, #8]
          mxDfsdmInit.SincOrder       = DFSDM_FILTER_ORDER(Audio_In_Ctx[Instance].SampleRate);
 800bb64:	f04f 42c0 	mov.w	r2, #1610612736	; 0x60000000
 800bb68:	e9cd 3203 	strd	r3, r2, [sp, #12]
          mxDfsdmInit.RightBitShift   = DFSDM_MIC_BIT_SHIFT(Audio_In_Ctx[Instance].SampleRate);
 800bb6c:	930b      	str	r3, [sp, #44]	; 0x2c
          mxDfsdmInit.Oversampling    = DFSDM_OVER_SAMPLING(Audio_In_Ctx[Instance].SampleRate);
 800bb6e:	2340      	movs	r3, #64	; 0x40
 800bb70:	e782      	b.n	800ba78 <BSP_AUDIO_IN_Init+0x214>
          if (Audio_In_Ctx[Instance].Device == AUDIO_IN_DIGITAL_MIC2)
 800bb72:	3b20      	subs	r3, #32
 800bb74:	bf18      	it	ne
 800bb76:	2301      	movne	r3, #1
 800bb78:	9303      	str	r3, [sp, #12]
          mxDfsdmInit.SincOrder       = DFSDM_FILTER_ORDER(Audio_In_Ctx[Instance].SampleRate);
 800bb7a:	f04f 43c0 	mov.w	r3, #1610612736	; 0x60000000
 800bb7e:	9304      	str	r3, [sp, #16]
          mxDfsdmInit.Channel4Filter  = DFSDM_CHANNEL_1;
 800bb80:	4b3f      	ldr	r3, [pc, #252]	; (800bc80 <BSP_AUDIO_IN_Init+0x41c>)
 800bb82:	9309      	str	r3, [sp, #36]	; 0x24
          mxDfsdmInit.FilterInstance  = DFSDM1_Filter1;
 800bb84:	4b3f      	ldr	r3, [pc, #252]	; (800bc84 <BSP_AUDIO_IN_Init+0x420>)
 800bb86:	9302      	str	r3, [sp, #8]
          mxDfsdmInit.ClockDivider    = DFSDM_CLOCK_DIVIDER(Audio_In_Ctx[Instance].SampleRate);
 800bb88:	2304      	movs	r3, #4
 800bb8a:	930a      	str	r3, [sp, #40]	; 0x28
          mxDfsdmInit.DigitalMicType  = DFSDM_CHANNEL_SPI_RISING;
 800bb8c:	2300      	movs	r3, #0
          mxDfsdmInit.DigitalMicPins  = DFSDM_CHANNEL_FOLLOWING_CHANNEL_PINS;
 800bb8e:	f44f 7680 	mov.w	r6, #256	; 0x100
          mxDfsdmInit.DigitalMicType  = DFSDM_CHANNEL_SPI_RISING;
 800bb92:	9308      	str	r3, [sp, #32]
          mxDfsdmInit.RightBitShift   = DFSDM_MIC_BIT_SHIFT(Audio_In_Ctx[Instance].SampleRate);
 800bb94:	2306      	movs	r3, #6
          mxDfsdmInit.DigitalMicPins  = DFSDM_CHANNEL_FOLLOWING_CHANNEL_PINS;
 800bb96:	9607      	str	r6, [sp, #28]
          mxDfsdmInit.RightBitShift   = DFSDM_MIC_BIT_SHIFT(Audio_In_Ctx[Instance].SampleRate);
 800bb98:	930b      	str	r3, [sp, #44]	; 0x2c
          mxDfsdmInit.Oversampling    = DFSDM_OVER_SAMPLING(Audio_In_Ctx[Instance].SampleRate);
 800bb9a:	e703      	b.n	800b9a4 <BSP_AUDIO_IN_Init+0x140>
          mxDfsdmInit.DigitalMicPins  = DFSDM_CHANNEL_SAME_CHANNEL_PINS;
 800bb9c:	2300      	movs	r3, #0
          mxDfsdmInit.ClockDivider    = DFSDM_CLOCK_DIVIDER(Audio_In_Ctx[Instance].SampleRate);
 800bb9e:	2204      	movs	r2, #4
 800bba0:	e797      	b.n	800bad2 <BSP_AUDIO_IN_Init+0x26e>
          if (Audio_In_Ctx[Instance].Device == AUDIO_IN_DIGITAL_MIC2)
 800bba2:	3b20      	subs	r3, #32
 800bba4:	bf18      	it	ne
 800bba6:	2301      	movne	r3, #1
 800bba8:	9303      	str	r3, [sp, #12]
          mxDfsdmInit.SincOrder       = DFSDM_FILTER_ORDER(Audio_In_Ctx[Instance].SampleRate);
 800bbaa:	f04f 43c0 	mov.w	r3, #1610612736	; 0x60000000
 800bbae:	9304      	str	r3, [sp, #16]
          mxDfsdmInit.Channel4Filter  = DFSDM_CHANNEL_1;
 800bbb0:	4b33      	ldr	r3, [pc, #204]	; (800bc80 <BSP_AUDIO_IN_Init+0x41c>)
 800bbb2:	9309      	str	r3, [sp, #36]	; 0x24
          mxDfsdmInit.FilterInstance  = DFSDM1_Filter1;
 800bbb4:	4b33      	ldr	r3, [pc, #204]	; (800bc84 <BSP_AUDIO_IN_Init+0x420>)
 800bbb6:	9302      	str	r3, [sp, #8]
          mxDfsdmInit.Oversampling    = DFSDM_OVER_SAMPLING(Audio_In_Ctx[Instance].SampleRate);
 800bbb8:	2680      	movs	r6, #128	; 0x80
          mxDfsdmInit.ClockDivider    = DFSDM_CLOCK_DIVIDER(Audio_In_Ctx[Instance].SampleRate);
 800bbba:	2318      	movs	r3, #24
 800bbbc:	e7bf      	b.n	800bb3e <BSP_AUDIO_IN_Init+0x2da>
          mxDfsdmInit.ClockDivider    = DFSDM_CLOCK_DIVIDER(Audio_In_Ctx[Instance].SampleRate);
 800bbbe:	2218      	movs	r2, #24
          mxDfsdmInit.DigitalMicPins  = DFSDM_CHANNEL_SAME_CHANNEL_PINS;
 800bbc0:	2300      	movs	r3, #0
          mxDfsdmInit.ClockDivider    = DFSDM_CLOCK_DIVIDER(Audio_In_Ctx[Instance].SampleRate);
 800bbc2:	920a      	str	r2, [sp, #40]	; 0x28
          mxDfsdmInit.DigitalMicType  = DFSDM_CHANNEL_SPI_FALLING;
 800bbc4:	2201      	movs	r2, #1
 800bbc6:	e9cd 3207 	strd	r3, r2, [sp, #28]
          mxDfsdmInit.RightBitShift   = DFSDM_MIC_BIT_SHIFT(Audio_In_Ctx[Instance].SampleRate);
 800bbca:	2206      	movs	r2, #6
 800bbcc:	920b      	str	r2, [sp, #44]	; 0x2c
          mxDfsdmInit.Channel4Filter  = DFSDM_CHANNEL_2;
 800bbce:	4a2e      	ldr	r2, [pc, #184]	; (800bc88 <BSP_AUDIO_IN_Init+0x424>)
 800bbd0:	9209      	str	r2, [sp, #36]	; 0x24
          mxDfsdmInit.FilterInstance  = DFSDM1_Filter0;
 800bbd2:	4a2e      	ldr	r2, [pc, #184]	; (800bc8c <BSP_AUDIO_IN_Init+0x428>)
 800bbd4:	9202      	str	r2, [sp, #8]
          mxDfsdmInit.SincOrder       = DFSDM_FILTER_ORDER(Audio_In_Ctx[Instance].SampleRate);
 800bbd6:	f04f 4200 	mov.w	r2, #2147483648	; 0x80000000
 800bbda:	e9cd 3203 	strd	r3, r2, [sp, #12]
          mxDfsdmInit.Oversampling    = DFSDM_OVER_SAMPLING(Audio_In_Ctx[Instance].SampleRate);
 800bbde:	2340      	movs	r3, #64	; 0x40
 800bbe0:	e74a      	b.n	800ba78 <BSP_AUDIO_IN_Init+0x214>
    status = BSP_ERROR_WRONG_PARAM;
 800bbe2:	f06f 0001 	mvn.w	r0, #1
}
 800bbe6:	4770      	bx	lr
    status = BSP_ERROR_BUSY;
 800bbe8:	f06f 0002 	mvn.w	r0, #2
 800bbec:	e6e7      	b.n	800b9be <BSP_AUDIO_IN_Init+0x15a>
      status = BSP_ERROR_CLOCK_FAILURE;
 800bbee:	f06f 0008 	mvn.w	r0, #8
  return status;
 800bbf2:	e6e4      	b.n	800b9be <BSP_AUDIO_IN_Init+0x15a>
          if (Audio_In_Ctx[Instance].Device == AUDIO_IN_DIGITAL_MIC2)
 800bbf4:	3b20      	subs	r3, #32
 800bbf6:	bf18      	it	ne
 800bbf8:	2301      	movne	r3, #1
 800bbfa:	9303      	str	r3, [sp, #12]
          mxDfsdmInit.SincOrder       = DFSDM_FILTER_ORDER(Audio_In_Ctx[Instance].SampleRate);
 800bbfc:	f04f 4300 	mov.w	r3, #2147483648	; 0x80000000
 800bc00:	9304      	str	r3, [sp, #16]
          mxDfsdmInit.Channel4Filter  = DFSDM_CHANNEL_1;
 800bc02:	4b1f      	ldr	r3, [pc, #124]	; (800bc80 <BSP_AUDIO_IN_Init+0x41c>)
 800bc04:	9309      	str	r3, [sp, #36]	; 0x24
          mxDfsdmInit.FilterInstance  = DFSDM1_Filter1;
 800bc06:	4b1f      	ldr	r3, [pc, #124]	; (800bc84 <BSP_AUDIO_IN_Init+0x420>)
 800bc08:	9302      	str	r3, [sp, #8]
          mxDfsdmInit.ClockDivider    = DFSDM_CLOCK_DIVIDER(Audio_In_Ctx[Instance].SampleRate);
 800bc0a:	2318      	movs	r3, #24
 800bc0c:	930a      	str	r3, [sp, #40]	; 0x28
          mxDfsdmInit.DigitalMicType  = DFSDM_CHANNEL_SPI_RISING;
 800bc0e:	f44f 7c80 	mov.w	ip, #256	; 0x100
 800bc12:	2300      	movs	r3, #0
 800bc14:	e9cd c307 	strd	ip, r3, [sp, #28]
          mxDfsdmInit.RightBitShift   = DFSDM_MIC_BIT_SHIFT(Audio_In_Ctx[Instance].SampleRate);
 800bc18:	2306      	movs	r3, #6
          mxDfsdmInit.Oversampling    = DFSDM_OVER_SAMPLING(Audio_In_Ctx[Instance].SampleRate);
 800bc1a:	2640      	movs	r6, #64	; 0x40
          mxDfsdmInit.RightBitShift   = DFSDM_MIC_BIT_SHIFT(Audio_In_Ctx[Instance].SampleRate);
 800bc1c:	930b      	str	r3, [sp, #44]	; 0x2c
          mxDfsdmInit.Oversampling    = DFSDM_OVER_SAMPLING(Audio_In_Ctx[Instance].SampleRate);
 800bc1e:	e6c1      	b.n	800b9a4 <BSP_AUDIO_IN_Init+0x140>
          mxDfsdmInit.SincOrder       = DFSDM_FILTER_ORDER(Audio_In_Ctx[Instance].SampleRate);
 800bc20:	f04f 4300 	mov.w	r3, #2147483648	; 0x80000000
 800bc24:	9304      	str	r3, [sp, #16]
          mxDfsdmInit.Oversampling    = DFSDM_OVER_SAMPLING(Audio_In_Ctx[Instance].SampleRate);
 800bc26:	4613      	mov	r3, r2
          mxDfsdmInit.Channel4Filter  = DFSDM_CHANNEL_2;
 800bc28:	4a17      	ldr	r2, [pc, #92]	; (800bc88 <BSP_AUDIO_IN_Init+0x424>)
 800bc2a:	9209      	str	r2, [sp, #36]	; 0x24
          mxDfsdmInit.FilterInstance  = DFSDM1_Filter0;
 800bc2c:	4a17      	ldr	r2, [pc, #92]	; (800bc8c <BSP_AUDIO_IN_Init+0x428>)
 800bc2e:	9202      	str	r2, [sp, #8]
          mxDfsdmInit.RightBitShift   = DFSDM_MIC_BIT_SHIFT(Audio_In_Ctx[Instance].SampleRate);
 800bc30:	2202      	movs	r2, #2
          mxDfsdmInit.RegularTrigger  = DFSDM_FILTER_SW_TRIGGER;
 800bc32:	9103      	str	r1, [sp, #12]
          mxDfsdmInit.RightBitShift   = DFSDM_MIC_BIT_SHIFT(Audio_In_Ctx[Instance].SampleRate);
 800bc34:	920b      	str	r2, [sp, #44]	; 0x2c
          mxDfsdmInit.Oversampling    = DFSDM_OVER_SAMPLING(Audio_In_Ctx[Instance].SampleRate);
 800bc36:	e71f      	b.n	800ba78 <BSP_AUDIO_IN_Init+0x214>
          if (Audio_In_Ctx[Instance].Device == AUDIO_IN_DIGITAL_MIC2)
 800bc38:	3b20      	subs	r3, #32
 800bc3a:	bf18      	it	ne
 800bc3c:	2301      	movne	r3, #1
 800bc3e:	9303      	str	r3, [sp, #12]
          mxDfsdmInit.SincOrder       = DFSDM_FILTER_ORDER(Audio_In_Ctx[Instance].SampleRate);
 800bc40:	f04f 43c0 	mov.w	r3, #1610612736	; 0x60000000
 800bc44:	9304      	str	r3, [sp, #16]
          mxDfsdmInit.DigitalMicType  = DFSDM_CHANNEL_SPI_RISING;
 800bc46:	2300      	movs	r3, #0
 800bc48:	9308      	str	r3, [sp, #32]
          mxDfsdmInit.RightBitShift   = DFSDM_MIC_BIT_SHIFT(Audio_In_Ctx[Instance].SampleRate);
 800bc4a:	930b      	str	r3, [sp, #44]	; 0x2c
          mxDfsdmInit.Channel4Filter  = DFSDM_CHANNEL_1;
 800bc4c:	4b0c      	ldr	r3, [pc, #48]	; (800bc80 <BSP_AUDIO_IN_Init+0x41c>)
 800bc4e:	9309      	str	r3, [sp, #36]	; 0x24
          mxDfsdmInit.FilterInstance  = DFSDM1_Filter1;
 800bc50:	4b0c      	ldr	r3, [pc, #48]	; (800bc84 <BSP_AUDIO_IN_Init+0x420>)
 800bc52:	9302      	str	r3, [sp, #8]
          mxDfsdmInit.ClockDivider    = DFSDM_CLOCK_DIVIDER(Audio_In_Ctx[Instance].SampleRate);
 800bc54:	2304      	movs	r3, #4
 800bc56:	930a      	str	r3, [sp, #40]	; 0x28
          mxDfsdmInit.DigitalMicPins  = DFSDM_CHANNEL_FOLLOWING_CHANNEL_PINS;
 800bc58:	f44f 7380 	mov.w	r3, #256	; 0x100
          mxDfsdmInit.Oversampling    = DFSDM_OVER_SAMPLING(Audio_In_Ctx[Instance].SampleRate);
 800bc5c:	2640      	movs	r6, #64	; 0x40
          mxDfsdmInit.DigitalMicPins  = DFSDM_CHANNEL_FOLLOWING_CHANNEL_PINS;
 800bc5e:	9307      	str	r3, [sp, #28]
          mxDfsdmInit.Oversampling    = DFSDM_OVER_SAMPLING(Audio_In_Ctx[Instance].SampleRate);
 800bc60:	e6a0      	b.n	800b9a4 <BSP_AUDIO_IN_Init+0x140>
          if (Audio_In_Ctx[Instance].Device == AUDIO_IN_DIGITAL_MIC2)
 800bc62:	3b20      	subs	r3, #32
 800bc64:	bf18      	it	ne
 800bc66:	2301      	movne	r3, #1
 800bc68:	9303      	str	r3, [sp, #12]
          mxDfsdmInit.Channel4Filter  = DFSDM_CHANNEL_1;
 800bc6a:	4b05      	ldr	r3, [pc, #20]	; (800bc80 <BSP_AUDIO_IN_Init+0x41c>)
 800bc6c:	9309      	str	r3, [sp, #36]	; 0x24
          mxDfsdmInit.FilterInstance  = DFSDM1_Filter1;
 800bc6e:	4b05      	ldr	r3, [pc, #20]	; (800bc84 <BSP_AUDIO_IN_Init+0x420>)
 800bc70:	9302      	str	r3, [sp, #8]
          mxDfsdmInit.RightBitShift   = DFSDM_MIC_BIT_SHIFT(Audio_In_Ctx[Instance].SampleRate);
 800bc72:	2302      	movs	r3, #2
 800bc74:	930b      	str	r3, [sp, #44]	; 0x2c
          mxDfsdmInit.SincOrder       = DFSDM_FILTER_ORDER(Audio_In_Ctx[Instance].SampleRate);
 800bc76:	f04f 4300 	mov.w	r3, #2147483648	; 0x80000000
          mxDfsdmInit.Oversampling    = DFSDM_OVER_SAMPLING(Audio_In_Ctx[Instance].SampleRate);
 800bc7a:	460e      	mov	r6, r1
          mxDfsdmInit.SincOrder       = DFSDM_FILTER_ORDER(Audio_In_Ctx[Instance].SampleRate);
 800bc7c:	9304      	str	r3, [sp, #16]
          mxDfsdmInit.Oversampling    = DFSDM_OVER_SAMPLING(Audio_In_Ctx[Instance].SampleRate);
 800bc7e:	e691      	b.n	800b9a4 <BSP_AUDIO_IN_Init+0x140>
 800bc80:	00010002 	.word	0x00010002
 800bc84:	40016180 	.word	0x40016180
 800bc88:	00020004 	.word	0x00020004
 800bc8c:	40016100 	.word	0x40016100

0800bc90 <HAL_DFSDM_FilterRegConvCpltCallback>:
  * @retval None.
  */
void HAL_DFSDM_FilterRegConvCpltCallback(DFSDM_Filter_HandleTypeDef *hdfsdm_filter)
{
  uint32_t     index;
  uint32_t     recbufsize = (Audio_In_Ctx[0].Size / (2U * Audio_In_Ctx[0].ChannelsNbr));
 800bc90:	4b7b      	ldr	r3, [pc, #492]	; (800be80 <HAL_DFSDM_FilterRegConvCpltCallback+0x1f0>)
{
 800bc92:	b5f0      	push	{r4, r5, r6, r7, lr}
  __IO int32_t tmp;

  if (Audio_In_Ctx[0].Device == AUDIO_IN_DIGITAL_MIC)
 800bc94:	681c      	ldr	r4, [r3, #0]
  uint32_t     recbufsize = (Audio_In_Ctx[0].Size / (2U * Audio_In_Ctx[0].ChannelsNbr));
 800bc96:	68d9      	ldr	r1, [r3, #12]
 800bc98:	695a      	ldr	r2, [r3, #20]
  if (Audio_In_Ctx[0].Device == AUDIO_IN_DIGITAL_MIC)
 800bc9a:	2c30      	cmp	r4, #48	; 0x30
  uint32_t     recbufsize = (Audio_In_Ctx[0].Size / (2U * Audio_In_Ctx[0].ChannelsNbr));
 800bc9c:	ea4f 0c41 	mov.w	ip, r1, lsl #1
{
 800bca0:	b083      	sub	sp, #12
  uint32_t     recbufsize = (Audio_In_Ctx[0].Size / (2U * Audio_In_Ctx[0].ChannelsNbr));
 800bca2:	fbb2 fcfc 	udiv	ip, r2, ip
  if (Audio_In_Ctx[0].Device == AUDIO_IN_DIGITAL_MIC)
 800bca6:	d05f      	beq.n	800bd68 <HAL_DFSDM_FilterRegConvCpltCallback+0xd8>
      tmp = SaturaLH(tmp, -32768, 32767);
      Audio_In_Ctx[0].pBuff[(4U * index) + 2U] = (uint8_t) tmp;
      Audio_In_Ctx[0].pBuff[(4U * index) + 3U] = (uint8_t) ((uint32_t) tmp >> 8);
    }
  }
  else if (Audio_In_Ctx[0].Device == AUDIO_IN_DIGITAL_MIC1)
 800bca8:	2c10      	cmp	r4, #16
 800bcaa:	d014      	beq.n	800bcd6 <HAL_DFSDM_FilterRegConvCpltCallback+0x46>
      Audio_In_Ctx[0].pBuff[(2U * index) + 1U] = (uint8_t) ((uint32_t) tmp >> 8);
    }
  }
  else
  {
    if (Audio_In_Ctx[0].Device == AUDIO_IN_DIGITAL_MIC2)
 800bcac:	2c20      	cmp	r4, #32
 800bcae:	f000 80b5 	beq.w	800be1c <HAL_DFSDM_FilterRegConvCpltCallback+0x18c>
      }
    }
  }

  /* Invoke 'TransferCompete' callback function */
  if(hdfsdm_filter == &haudio_in_dfsdm_filter[0])
 800bcb2:	4c74      	ldr	r4, [pc, #464]	; (800be84 <HAL_DFSDM_FilterRegConvCpltCallback+0x1f4>)
 800bcb4:	f104 0290 	add.w	r2, r4, #144	; 0x90
 800bcb8:	4290      	cmp	r0, r2
 800bcba:	d041      	beq.n	800bd40 <HAL_DFSDM_FilterRegConvCpltCallback+0xb0>
  else
  {
    Audio_DmaDigMic2RecBuffCplt = 1;
  }

  if (((Audio_DmaDigMic1RecBuffCplt != 0U) && (Audio_DmaDigMic2RecBuffCplt != 0U) && (Audio_In_Ctx[0].Device == AUDIO_IN_DIGITAL_MIC)) ||
 800bcbc:	f8d4 21ac 	ldr.w	r2, [r4, #428]	; 0x1ac
    Audio_DmaDigMic2RecBuffCplt = 1;
 800bcc0:	2101      	movs	r1, #1
 800bcc2:	f8c4 11b4 	str.w	r1, [r4, #436]	; 0x1b4
  if (((Audio_DmaDigMic1RecBuffCplt != 0U) && (Audio_DmaDigMic2RecBuffCplt != 0U) && (Audio_In_Ctx[0].Device == AUDIO_IN_DIGITAL_MIC)) ||
 800bcc6:	2a00      	cmp	r2, #0
 800bcc8:	f040 80a1 	bne.w	800be0e <HAL_DFSDM_FilterRegConvCpltCallback+0x17e>
      ((Audio_DmaDigMic1RecBuffCplt != 0U) && (Audio_In_Ctx[0].Device == AUDIO_IN_DIGITAL_MIC1)) ||
 800bccc:	681b      	ldr	r3, [r3, #0]
      ((Audio_DmaDigMic2RecBuffCplt != 0U) && (Audio_In_Ctx[0].Device == AUDIO_IN_DIGITAL_MIC2)))
 800bcce:	2b20      	cmp	r3, #32
 800bcd0:	d040      	beq.n	800bd54 <HAL_DFSDM_FilterRegConvCpltCallback+0xc4>
  {
    BSP_AUDIO_IN_TransferComplete_CallBack(0);
    Audio_DmaDigMic1RecBuffCplt = 0;
    Audio_DmaDigMic2RecBuffCplt = 0;
  }
}
 800bcd2:	b003      	add	sp, #12
 800bcd4:	bdf0      	pop	{r4, r5, r6, r7, pc}
    for (index = (recbufsize / 2U); index < recbufsize; index++)
 800bcd6:	ebbc 0f5c 	cmp.w	ip, ip, lsr #1
 800bcda:	ea4f 015c 	mov.w	r1, ip, lsr #1
 800bcde:	d9e8      	bls.n	800bcb2 <HAL_DFSDM_FilterRegConvCpltCallback+0x22>
 800bce0:	4c69      	ldr	r4, [pc, #420]	; (800be88 <HAL_DFSDM_FilterRegConvCpltCallback+0x1f8>)
      tmp = SaturaLH(tmp, -32768, 32767);
 800bce2:	4e6a      	ldr	r6, [pc, #424]	; (800be8c <HAL_DFSDM_FilterRegConvCpltCallback+0x1fc>)
 800bce4:	eb04 0481 	add.w	r4, r4, r1, lsl #2
 800bce8:	ea4f 0c4c 	mov.w	ip, ip, lsl #1
 800bcec:	0049      	lsls	r1, r1, #1
 800bcee:	3c04      	subs	r4, #4
 800bcf0:	3101      	adds	r1, #1
 800bcf2:	f10c 0c01 	add.w	ip, ip, #1
      tmp = Audio_DigMic1RecBuff[index] / 256;
 800bcf6:	f854 2f04 	ldr.w	r2, [r4, #4]!
 800bcfa:	2a00      	cmp	r2, #0
 800bcfc:	bfb8      	it	lt
 800bcfe:	32ff      	addlt	r2, #255	; 0xff
 800bd00:	1212      	asrs	r2, r2, #8
 800bd02:	9201      	str	r2, [sp, #4]
      tmp = SaturaLH(tmp, -32768, 32767);
 800bd04:	9a01      	ldr	r2, [sp, #4]
 800bd06:	f512 4f00 	cmn.w	r2, #32768	; 0x8000
 800bd0a:	4635      	mov	r5, r6
 800bd0c:	db06      	blt.n	800bd1c <HAL_DFSDM_FilterRegConvCpltCallback+0x8c>
 800bd0e:	9a01      	ldr	r2, [sp, #4]
 800bd10:	f5b2 4f00 	cmp.w	r2, #32768	; 0x8000
 800bd14:	bfb4      	ite	lt
 800bd16:	9d01      	ldrlt	r5, [sp, #4]
 800bd18:	f647 75ff 	movwge	r5, #32767	; 0x7fff
      Audio_In_Ctx[0].pBuff[2U * index]        = (uint8_t) tmp;
 800bd1c:	691a      	ldr	r2, [r3, #16]
      tmp = SaturaLH(tmp, -32768, 32767);
 800bd1e:	9501      	str	r5, [sp, #4]
      Audio_In_Ctx[0].pBuff[2U * index]        = (uint8_t) tmp;
 800bd20:	440a      	add	r2, r1
 800bd22:	9d01      	ldr	r5, [sp, #4]
 800bd24:	f802 5c01 	strb.w	r5, [r2, #-1]
      Audio_In_Ctx[0].pBuff[(2U * index) + 1U] = (uint8_t) ((uint32_t) tmp >> 8);
 800bd28:	9a01      	ldr	r2, [sp, #4]
 800bd2a:	691d      	ldr	r5, [r3, #16]
 800bd2c:	0a12      	lsrs	r2, r2, #8
 800bd2e:	546a      	strb	r2, [r5, r1]
    for (index = (recbufsize / 2U); index < recbufsize; index++)
 800bd30:	3102      	adds	r1, #2
 800bd32:	4561      	cmp	r1, ip
 800bd34:	d1df      	bne.n	800bcf6 <HAL_DFSDM_FilterRegConvCpltCallback+0x66>
  if(hdfsdm_filter == &haudio_in_dfsdm_filter[0])
 800bd36:	4c53      	ldr	r4, [pc, #332]	; (800be84 <HAL_DFSDM_FilterRegConvCpltCallback+0x1f4>)
 800bd38:	f104 0290 	add.w	r2, r4, #144	; 0x90
 800bd3c:	4290      	cmp	r0, r2
 800bd3e:	d1bd      	bne.n	800bcbc <HAL_DFSDM_FilterRegConvCpltCallback+0x2c>
  if (((Audio_DmaDigMic1RecBuffCplt != 0U) && (Audio_DmaDigMic2RecBuffCplt != 0U) && (Audio_In_Ctx[0].Device == AUDIO_IN_DIGITAL_MIC)) ||
 800bd40:	f8d4 21b4 	ldr.w	r2, [r4, #436]	; 0x1b4
    Audio_DmaDigMic1RecBuffCplt = 1;
 800bd44:	2101      	movs	r1, #1
 800bd46:	f8c4 11ac 	str.w	r1, [r4, #428]	; 0x1ac
  if (((Audio_DmaDigMic1RecBuffCplt != 0U) && (Audio_DmaDigMic2RecBuffCplt != 0U) && (Audio_In_Ctx[0].Device == AUDIO_IN_DIGITAL_MIC)) ||
 800bd4a:	2a00      	cmp	r2, #0
 800bd4c:	d15f      	bne.n	800be0e <HAL_DFSDM_FilterRegConvCpltCallback+0x17e>
      ((Audio_DmaDigMic1RecBuffCplt != 0U) && (Audio_In_Ctx[0].Device == AUDIO_IN_DIGITAL_MIC1)) ||
 800bd4e:	681b      	ldr	r3, [r3, #0]
 800bd50:	2b10      	cmp	r3, #16
 800bd52:	d1be      	bne.n	800bcd2 <HAL_DFSDM_FilterRegConvCpltCallback+0x42>
    BSP_AUDIO_IN_TransferComplete_CallBack(0);
 800bd54:	2000      	movs	r0, #0
 800bd56:	f016 f89d 	bl	8021e94 <BSP_AUDIO_IN_TransferComplete_CallBack>
    Audio_DmaDigMic1RecBuffCplt = 0;
 800bd5a:	2300      	movs	r3, #0
 800bd5c:	f8c4 31ac 	str.w	r3, [r4, #428]	; 0x1ac
    Audio_DmaDigMic2RecBuffCplt = 0;
 800bd60:	f8c4 31b4 	str.w	r3, [r4, #436]	; 0x1b4
}
 800bd64:	b003      	add	sp, #12
 800bd66:	bdf0      	pop	{r4, r5, r6, r7, pc}
    for (index = (recbufsize / 2U); index < recbufsize; index++)
 800bd68:	ebbc 0f5c 	cmp.w	ip, ip, lsr #1
 800bd6c:	ea4f 025c 	mov.w	r2, ip, lsr #1
 800bd70:	d99f      	bls.n	800bcb2 <HAL_DFSDM_FilterRegConvCpltCallback+0x22>
 800bd72:	4c45      	ldr	r4, [pc, #276]	; (800be88 <HAL_DFSDM_FilterRegConvCpltCallback+0x1f8>)
      tmp = SaturaLH(tmp, -32768, 32767);
 800bd74:	4e45      	ldr	r6, [pc, #276]	; (800be8c <HAL_DFSDM_FilterRegConvCpltCallback+0x1fc>)
 800bd76:	0092      	lsls	r2, r2, #2
 800bd78:	1f11      	subs	r1, r2, #4
 800bd7a:	f5a4 7580 	sub.w	r5, r4, #256	; 0x100
 800bd7e:	ea4f 0c8c 	mov.w	ip, ip, lsl #2
 800bd82:	440c      	add	r4, r1
 800bd84:	440d      	add	r5, r1
 800bd86:	e02d      	b.n	800bde4 <HAL_DFSDM_FilterRegConvCpltCallback+0x154>
 800bd88:	9901      	ldr	r1, [sp, #4]
 800bd8a:	f5b1 4f00 	cmp.w	r1, #32768	; 0x8000
 800bd8e:	da3b      	bge.n	800be08 <HAL_DFSDM_FilterRegConvCpltCallback+0x178>
 800bd90:	9901      	ldr	r1, [sp, #4]
 800bd92:	9101      	str	r1, [sp, #4]
      Audio_In_Ctx[0].pBuff[4U * index]        = (uint8_t) tmp;
 800bd94:	6919      	ldr	r1, [r3, #16]
 800bd96:	9f01      	ldr	r7, [sp, #4]
 800bd98:	548f      	strb	r7, [r1, r2]
      Audio_In_Ctx[0].pBuff[(4U * index) + 1U] = (uint8_t) ((uint32_t) tmp >> 8);
 800bd9a:	6919      	ldr	r1, [r3, #16]
 800bd9c:	9f01      	ldr	r7, [sp, #4]
 800bd9e:	4411      	add	r1, r2
 800bda0:	0a3f      	lsrs	r7, r7, #8
 800bda2:	704f      	strb	r7, [r1, #1]
      tmp = Audio_DigMic2RecBuff[index] / 256;
 800bda4:	f855 1f04 	ldr.w	r1, [r5, #4]!
 800bda8:	2900      	cmp	r1, #0
 800bdaa:	bfb8      	it	lt
 800bdac:	31ff      	addlt	r1, #255	; 0xff
 800bdae:	1209      	asrs	r1, r1, #8
 800bdb0:	9101      	str	r1, [sp, #4]
      tmp = SaturaLH(tmp, -32768, 32767);
 800bdb2:	9901      	ldr	r1, [sp, #4]
 800bdb4:	f511 4f00 	cmn.w	r1, #32768	; 0x8000
 800bdb8:	db21      	blt.n	800bdfe <HAL_DFSDM_FilterRegConvCpltCallback+0x16e>
 800bdba:	9901      	ldr	r1, [sp, #4]
 800bdbc:	f5b1 4f00 	cmp.w	r1, #32768	; 0x8000
 800bdc0:	da1f      	bge.n	800be02 <HAL_DFSDM_FilterRegConvCpltCallback+0x172>
 800bdc2:	9f01      	ldr	r7, [sp, #4]
      Audio_In_Ctx[0].pBuff[(4U * index) + 2U] = (uint8_t) tmp;
 800bdc4:	6919      	ldr	r1, [r3, #16]
      tmp = SaturaLH(tmp, -32768, 32767);
 800bdc6:	9701      	str	r7, [sp, #4]
      Audio_In_Ctx[0].pBuff[(4U * index) + 2U] = (uint8_t) tmp;
 800bdc8:	4411      	add	r1, r2
 800bdca:	9f01      	ldr	r7, [sp, #4]
 800bdcc:	708f      	strb	r7, [r1, #2]
      Audio_In_Ctx[0].pBuff[(4U * index) + 3U] = (uint8_t) ((uint32_t) tmp >> 8);
 800bdce:	6919      	ldr	r1, [r3, #16]
 800bdd0:	9f01      	ldr	r7, [sp, #4]
 800bdd2:	4411      	add	r1, r2
    for (index = (recbufsize / 2U); index < recbufsize; index++)
 800bdd4:	3204      	adds	r2, #4
      Audio_In_Ctx[0].pBuff[(4U * index) + 3U] = (uint8_t) ((uint32_t) tmp >> 8);
 800bdd6:	ea4f 2e17 	mov.w	lr, r7, lsr #8
    for (index = (recbufsize / 2U); index < recbufsize; index++)
 800bdda:	4594      	cmp	ip, r2
      Audio_In_Ctx[0].pBuff[(4U * index) + 3U] = (uint8_t) ((uint32_t) tmp >> 8);
 800bddc:	f881 e003 	strb.w	lr, [r1, #3]
    for (index = (recbufsize / 2U); index < recbufsize; index++)
 800bde0:	f43f af67 	beq.w	800bcb2 <HAL_DFSDM_FilterRegConvCpltCallback+0x22>
      tmp = Audio_DigMic1RecBuff[index] / 256;
 800bde4:	f854 1f04 	ldr.w	r1, [r4, #4]!
 800bde8:	2900      	cmp	r1, #0
 800bdea:	bfb8      	it	lt
 800bdec:	31ff      	addlt	r1, #255	; 0xff
 800bdee:	1209      	asrs	r1, r1, #8
 800bdf0:	9101      	str	r1, [sp, #4]
      tmp = SaturaLH(tmp, -32768, 32767);
 800bdf2:	9901      	ldr	r1, [sp, #4]
 800bdf4:	f511 4f00 	cmn.w	r1, #32768	; 0x8000
 800bdf8:	dac6      	bge.n	800bd88 <HAL_DFSDM_FilterRegConvCpltCallback+0xf8>
 800bdfa:	4631      	mov	r1, r6
 800bdfc:	e7c9      	b.n	800bd92 <HAL_DFSDM_FilterRegConvCpltCallback+0x102>
      tmp = SaturaLH(tmp, -32768, 32767);
 800bdfe:	4637      	mov	r7, r6
 800be00:	e7e0      	b.n	800bdc4 <HAL_DFSDM_FilterRegConvCpltCallback+0x134>
 800be02:	f647 77ff 	movw	r7, #32767	; 0x7fff
 800be06:	e7dd      	b.n	800bdc4 <HAL_DFSDM_FilterRegConvCpltCallback+0x134>
      tmp = SaturaLH(tmp, -32768, 32767);
 800be08:	f647 71ff 	movw	r1, #32767	; 0x7fff
 800be0c:	e7c1      	b.n	800bd92 <HAL_DFSDM_FilterRegConvCpltCallback+0x102>
  if (((Audio_DmaDigMic1RecBuffCplt != 0U) && (Audio_DmaDigMic2RecBuffCplt != 0U) && (Audio_In_Ctx[0].Device == AUDIO_IN_DIGITAL_MIC)) ||
 800be0e:	681b      	ldr	r3, [r3, #0]
      ((Audio_DmaDigMic1RecBuffCplt != 0U) && (Audio_In_Ctx[0].Device == AUDIO_IN_DIGITAL_MIC1)) ||
 800be10:	f023 0220 	bic.w	r2, r3, #32
 800be14:	2a10      	cmp	r2, #16
 800be16:	f47f af5a 	bne.w	800bcce <HAL_DFSDM_FilterRegConvCpltCallback+0x3e>
 800be1a:	e79b      	b.n	800bd54 <HAL_DFSDM_FilterRegConvCpltCallback+0xc4>
      for (index = (recbufsize / 2U); index < recbufsize; index++)
 800be1c:	ebbc 0f5c 	cmp.w	ip, ip, lsr #1
 800be20:	ea4f 015c 	mov.w	r1, ip, lsr #1
 800be24:	f67f af45 	bls.w	800bcb2 <HAL_DFSDM_FilterRegConvCpltCallback+0x22>
 800be28:	4c19      	ldr	r4, [pc, #100]	; (800be90 <HAL_DFSDM_FilterRegConvCpltCallback+0x200>)
        tmp = SaturaLH(tmp, -32768, 32767);
 800be2a:	4e18      	ldr	r6, [pc, #96]	; (800be8c <HAL_DFSDM_FilterRegConvCpltCallback+0x1fc>)
 800be2c:	eb04 0481 	add.w	r4, r4, r1, lsl #2
 800be30:	ea4f 0c4c 	mov.w	ip, ip, lsl #1
 800be34:	0049      	lsls	r1, r1, #1
 800be36:	3c04      	subs	r4, #4
 800be38:	3101      	adds	r1, #1
 800be3a:	f10c 0c01 	add.w	ip, ip, #1
        tmp = Audio_DigMic2RecBuff[index] / 256;
 800be3e:	f854 2f04 	ldr.w	r2, [r4, #4]!
 800be42:	2a00      	cmp	r2, #0
 800be44:	bfb8      	it	lt
 800be46:	32ff      	addlt	r2, #255	; 0xff
 800be48:	1212      	asrs	r2, r2, #8
 800be4a:	9201      	str	r2, [sp, #4]
        tmp = SaturaLH(tmp, -32768, 32767);
 800be4c:	9a01      	ldr	r2, [sp, #4]
 800be4e:	f512 4f00 	cmn.w	r2, #32768	; 0x8000
 800be52:	4635      	mov	r5, r6
 800be54:	db06      	blt.n	800be64 <HAL_DFSDM_FilterRegConvCpltCallback+0x1d4>
 800be56:	9a01      	ldr	r2, [sp, #4]
 800be58:	f5b2 4f00 	cmp.w	r2, #32768	; 0x8000
 800be5c:	bfb4      	ite	lt
 800be5e:	9d01      	ldrlt	r5, [sp, #4]
 800be60:	f647 75ff 	movwge	r5, #32767	; 0x7fff
        Audio_In_Ctx[0].pBuff[2U * index]        = (uint8_t) tmp;
 800be64:	691a      	ldr	r2, [r3, #16]
        tmp = SaturaLH(tmp, -32768, 32767);
 800be66:	9501      	str	r5, [sp, #4]
        Audio_In_Ctx[0].pBuff[2U * index]        = (uint8_t) tmp;
 800be68:	440a      	add	r2, r1
 800be6a:	9d01      	ldr	r5, [sp, #4]
 800be6c:	f802 5c01 	strb.w	r5, [r2, #-1]
        Audio_In_Ctx[0].pBuff[(2U * index) + 1U] = (uint8_t) ((uint32_t) tmp >> 8);
 800be70:	9a01      	ldr	r2, [sp, #4]
 800be72:	691d      	ldr	r5, [r3, #16]
 800be74:	0a12      	lsrs	r2, r2, #8
 800be76:	546a      	strb	r2, [r5, r1]
      for (index = (recbufsize / 2U); index < recbufsize; index++)
 800be78:	3102      	adds	r1, #2
 800be7a:	4561      	cmp	r1, ip
 800be7c:	d1df      	bne.n	800be3e <HAL_DFSDM_FilterRegConvCpltCallback+0x1ae>
 800be7e:	e718      	b.n	800bcb2 <HAL_DFSDM_FilterRegConvCpltCallback+0x22>
 800be80:	20000000 	.word	0x20000000
 800be84:	20002314 	.word	0x20002314
 800be88:	200025cc 	.word	0x200025cc
 800be8c:	ffff8000 	.word	0xffff8000
 800be90:	200024cc 	.word	0x200024cc

0800be94 <HAL_DFSDM_FilterRegConvHalfCpltCallback>:
  * @retval None.
  */
void HAL_DFSDM_FilterRegConvHalfCpltCallback(DFSDM_Filter_HandleTypeDef *hdfsdm_filter)
{
  uint32_t     index;
  uint32_t     recbufsize = (Audio_In_Ctx[0].Size / (2U * Audio_In_Ctx[0].ChannelsNbr));
 800be94:	4b75      	ldr	r3, [pc, #468]	; (800c06c <HAL_DFSDM_FilterRegConvHalfCpltCallback+0x1d8>)
{
 800be96:	b5f0      	push	{r4, r5, r6, r7, lr}
  __IO int32_t tmp;

  if (Audio_In_Ctx[0].Device == AUDIO_IN_DIGITAL_MIC)
 800be98:	681c      	ldr	r4, [r3, #0]
  uint32_t     recbufsize = (Audio_In_Ctx[0].Size / (2U * Audio_In_Ctx[0].ChannelsNbr));
 800be9a:	68d9      	ldr	r1, [r3, #12]
 800be9c:	695a      	ldr	r2, [r3, #20]
  if (Audio_In_Ctx[0].Device == AUDIO_IN_DIGITAL_MIC)
 800be9e:	2c30      	cmp	r4, #48	; 0x30
  uint32_t     recbufsize = (Audio_In_Ctx[0].Size / (2U * Audio_In_Ctx[0].ChannelsNbr));
 800bea0:	ea4f 0c41 	mov.w	ip, r1, lsl #1
{
 800bea4:	b083      	sub	sp, #12
  uint32_t     recbufsize = (Audio_In_Ctx[0].Size / (2U * Audio_In_Ctx[0].ChannelsNbr));
 800bea6:	fbb2 fcfc 	udiv	ip, r2, ip
  if (Audio_In_Ctx[0].Device == AUDIO_IN_DIGITAL_MIC)
 800beaa:	d059      	beq.n	800bf60 <HAL_DFSDM_FilterRegConvHalfCpltCallback+0xcc>
      tmp = SaturaLH(tmp, -32768, 32767);
      Audio_In_Ctx[0].pBuff[(4U * index) + 2U] = (uint8_t) tmp;
      Audio_In_Ctx[0].pBuff[(4U * index) + 3U] = (uint8_t) ((uint32_t) tmp >> 8);
    }
  }
  else if (Audio_In_Ctx[0].Device == AUDIO_IN_DIGITAL_MIC1)
 800beac:	2c10      	cmp	r4, #16
 800beae:	d014      	beq.n	800beda <HAL_DFSDM_FilterRegConvHalfCpltCallback+0x46>
      Audio_In_Ctx[0].pBuff[(2U * index) + 1U] = (uint8_t) ((uint32_t) tmp >> 8);
    }
  }
  else
  {
    if (Audio_In_Ctx[0].Device == AUDIO_IN_DIGITAL_MIC2)
 800beb0:	2c20      	cmp	r4, #32
 800beb2:	f000 80ae 	beq.w	800c012 <HAL_DFSDM_FilterRegConvHalfCpltCallback+0x17e>
      }
    }
  }

  /* Invoke the 'HalfTransfer' callback function */
  if(hdfsdm_filter == &haudio_in_dfsdm_filter[0])
 800beb6:	4c6e      	ldr	r4, [pc, #440]	; (800c070 <HAL_DFSDM_FilterRegConvHalfCpltCallback+0x1dc>)
 800beb8:	f104 0290 	add.w	r2, r4, #144	; 0x90
 800bebc:	4290      	cmp	r0, r2
 800bebe:	d03b      	beq.n	800bf38 <HAL_DFSDM_FilterRegConvHalfCpltCallback+0xa4>
  else
  {
    Audio_DmaDigMic2RecHalfBuffCplt = 1;
  }

  if (((Audio_DmaDigMic1RecHalfBuffCplt != 0U) && (Audio_DmaDigMic2RecHalfBuffCplt != 0U) && (Audio_In_Ctx[0].Device == AUDIO_IN_DIGITAL_MIC)) ||
 800bec0:	f8d4 21a8 	ldr.w	r2, [r4, #424]	; 0x1a8
    Audio_DmaDigMic2RecHalfBuffCplt = 1;
 800bec4:	2101      	movs	r1, #1
 800bec6:	f8c4 11b0 	str.w	r1, [r4, #432]	; 0x1b0
  if (((Audio_DmaDigMic1RecHalfBuffCplt != 0U) && (Audio_DmaDigMic2RecHalfBuffCplt != 0U) && (Audio_In_Ctx[0].Device == AUDIO_IN_DIGITAL_MIC)) ||
 800beca:	2a00      	cmp	r2, #0
 800becc:	f040 809a 	bne.w	800c004 <HAL_DFSDM_FilterRegConvHalfCpltCallback+0x170>
      ((Audio_DmaDigMic1RecHalfBuffCplt != 0U) && (Audio_In_Ctx[0].Device == AUDIO_IN_DIGITAL_MIC1)) ||
 800bed0:	681b      	ldr	r3, [r3, #0]
      ((Audio_DmaDigMic2RecHalfBuffCplt != 0U) && (Audio_In_Ctx[0].Device == AUDIO_IN_DIGITAL_MIC2)))
 800bed2:	2b20      	cmp	r3, #32
 800bed4:	d03a      	beq.n	800bf4c <HAL_DFSDM_FilterRegConvHalfCpltCallback+0xb8>
  {
    BSP_AUDIO_IN_HalfTransfer_CallBack(0);
    Audio_DmaDigMic1RecHalfBuffCplt = 0;
    Audio_DmaDigMic2RecHalfBuffCplt = 0;
  }
}
 800bed6:	b003      	add	sp, #12
 800bed8:	bdf0      	pop	{r4, r5, r6, r7, pc}
    for (index = 0; index < (recbufsize / 2U); index++)
 800beda:	ea5f 0c5c 	movs.w	ip, ip, lsr #1
 800bede:	d0ea      	beq.n	800beb6 <HAL_DFSDM_FilterRegConvHalfCpltCallback+0x22>
 800bee0:	ea4f 0c4c 	mov.w	ip, ip, lsl #1
 800bee4:	4d63      	ldr	r5, [pc, #396]	; (800c074 <HAL_DFSDM_FilterRegConvHalfCpltCallback+0x1e0>)
      tmp = SaturaLH(tmp, -32768, 32767);
 800bee6:	4e64      	ldr	r6, [pc, #400]	; (800c078 <HAL_DFSDM_FilterRegConvHalfCpltCallback+0x1e4>)
 800bee8:	f10c 0c01 	add.w	ip, ip, #1
    for (index = 0; index < (recbufsize / 2U); index++)
 800beec:	2101      	movs	r1, #1
      tmp = Audio_DigMic1RecBuff[index] / 256;
 800beee:	f855 2b04 	ldr.w	r2, [r5], #4
 800bef2:	2a00      	cmp	r2, #0
 800bef4:	bfb8      	it	lt
 800bef6:	32ff      	addlt	r2, #255	; 0xff
 800bef8:	1212      	asrs	r2, r2, #8
 800befa:	9201      	str	r2, [sp, #4]
      tmp = SaturaLH(tmp, -32768, 32767);
 800befc:	9a01      	ldr	r2, [sp, #4]
 800befe:	f512 4f00 	cmn.w	r2, #32768	; 0x8000
 800bf02:	4634      	mov	r4, r6
 800bf04:	db06      	blt.n	800bf14 <HAL_DFSDM_FilterRegConvHalfCpltCallback+0x80>
 800bf06:	9a01      	ldr	r2, [sp, #4]
 800bf08:	f5b2 4f00 	cmp.w	r2, #32768	; 0x8000
 800bf0c:	bfb4      	ite	lt
 800bf0e:	9c01      	ldrlt	r4, [sp, #4]
 800bf10:	f647 74ff 	movwge	r4, #32767	; 0x7fff
      Audio_In_Ctx[0].pBuff[2U * index]        = (uint8_t) tmp;
 800bf14:	691a      	ldr	r2, [r3, #16]
      tmp = SaturaLH(tmp, -32768, 32767);
 800bf16:	9401      	str	r4, [sp, #4]
      Audio_In_Ctx[0].pBuff[2U * index]        = (uint8_t) tmp;
 800bf18:	440a      	add	r2, r1
 800bf1a:	9c01      	ldr	r4, [sp, #4]
 800bf1c:	f802 4c01 	strb.w	r4, [r2, #-1]
      Audio_In_Ctx[0].pBuff[(2U * index) + 1U] = (uint8_t) ((uint32_t) tmp >> 8);
 800bf20:	9a01      	ldr	r2, [sp, #4]
 800bf22:	691c      	ldr	r4, [r3, #16]
 800bf24:	0a12      	lsrs	r2, r2, #8
 800bf26:	5462      	strb	r2, [r4, r1]
    for (index = 0; index < (recbufsize / 2U); index++)
 800bf28:	3102      	adds	r1, #2
 800bf2a:	458c      	cmp	ip, r1
 800bf2c:	d1df      	bne.n	800beee <HAL_DFSDM_FilterRegConvHalfCpltCallback+0x5a>
  if(hdfsdm_filter == &haudio_in_dfsdm_filter[0])
 800bf2e:	4c50      	ldr	r4, [pc, #320]	; (800c070 <HAL_DFSDM_FilterRegConvHalfCpltCallback+0x1dc>)
 800bf30:	f104 0290 	add.w	r2, r4, #144	; 0x90
 800bf34:	4290      	cmp	r0, r2
 800bf36:	d1c3      	bne.n	800bec0 <HAL_DFSDM_FilterRegConvHalfCpltCallback+0x2c>
  if (((Audio_DmaDigMic1RecHalfBuffCplt != 0U) && (Audio_DmaDigMic2RecHalfBuffCplt != 0U) && (Audio_In_Ctx[0].Device == AUDIO_IN_DIGITAL_MIC)) ||
 800bf38:	f8d4 21b0 	ldr.w	r2, [r4, #432]	; 0x1b0
    Audio_DmaDigMic1RecHalfBuffCplt = 1;
 800bf3c:	2101      	movs	r1, #1
 800bf3e:	f8c4 11a8 	str.w	r1, [r4, #424]	; 0x1a8
  if (((Audio_DmaDigMic1RecHalfBuffCplt != 0U) && (Audio_DmaDigMic2RecHalfBuffCplt != 0U) && (Audio_In_Ctx[0].Device == AUDIO_IN_DIGITAL_MIC)) ||
 800bf42:	2a00      	cmp	r2, #0
 800bf44:	d15e      	bne.n	800c004 <HAL_DFSDM_FilterRegConvHalfCpltCallback+0x170>
      ((Audio_DmaDigMic1RecHalfBuffCplt != 0U) && (Audio_In_Ctx[0].Device == AUDIO_IN_DIGITAL_MIC1)) ||
 800bf46:	681b      	ldr	r3, [r3, #0]
 800bf48:	2b10      	cmp	r3, #16
 800bf4a:	d1c4      	bne.n	800bed6 <HAL_DFSDM_FilterRegConvHalfCpltCallback+0x42>
    BSP_AUDIO_IN_HalfTransfer_CallBack(0);
 800bf4c:	2000      	movs	r0, #0
 800bf4e:	f015 ff1f 	bl	8021d90 <BSP_AUDIO_IN_HalfTransfer_CallBack>
    Audio_DmaDigMic1RecHalfBuffCplt = 0;
 800bf52:	2300      	movs	r3, #0
 800bf54:	f8c4 31a8 	str.w	r3, [r4, #424]	; 0x1a8
    Audio_DmaDigMic2RecHalfBuffCplt = 0;
 800bf58:	f8c4 31b0 	str.w	r3, [r4, #432]	; 0x1b0
}
 800bf5c:	b003      	add	sp, #12
 800bf5e:	bdf0      	pop	{r4, r5, r6, r7, pc}
    for (index = 0; index < (recbufsize / 2U); index++)
 800bf60:	ea5f 0c5c 	movs.w	ip, ip, lsr #1
 800bf64:	d0a7      	beq.n	800beb6 <HAL_DFSDM_FilterRegConvHalfCpltCallback+0x22>
 800bf66:	4c43      	ldr	r4, [pc, #268]	; (800c074 <HAL_DFSDM_FilterRegConvHalfCpltCallback+0x1e0>)
      tmp = SaturaLH(tmp, -32768, 32767);
 800bf68:	4e43      	ldr	r6, [pc, #268]	; (800c078 <HAL_DFSDM_FilterRegConvHalfCpltCallback+0x1e4>)
 800bf6a:	ea4f 0c8c 	mov.w	ip, ip, lsl #2
 800bf6e:	f5a4 7580 	sub.w	r5, r4, #256	; 0x100
 800bf72:	f10c 0c02 	add.w	ip, ip, #2
    for (index = 0; index < (recbufsize / 2U); index++)
 800bf76:	2202      	movs	r2, #2
 800bf78:	e02f      	b.n	800bfda <HAL_DFSDM_FilterRegConvHalfCpltCallback+0x146>
      tmp = SaturaLH(tmp, -32768, 32767);
 800bf7a:	9901      	ldr	r1, [sp, #4]
 800bf7c:	f5b1 4f00 	cmp.w	r1, #32768	; 0x8000
 800bf80:	da3d      	bge.n	800bffe <HAL_DFSDM_FilterRegConvHalfCpltCallback+0x16a>
 800bf82:	9f01      	ldr	r7, [sp, #4]
      Audio_In_Ctx[0].pBuff[4U * index]        = (uint8_t) tmp;
 800bf84:	6919      	ldr	r1, [r3, #16]
      tmp = SaturaLH(tmp, -32768, 32767);
 800bf86:	9701      	str	r7, [sp, #4]
      Audio_In_Ctx[0].pBuff[4U * index]        = (uint8_t) tmp;
 800bf88:	4411      	add	r1, r2
 800bf8a:	9f01      	ldr	r7, [sp, #4]
 800bf8c:	f801 7c02 	strb.w	r7, [r1, #-2]
      Audio_In_Ctx[0].pBuff[(4U * index) + 1U] = (uint8_t) ((uint32_t) tmp >> 8);
 800bf90:	6919      	ldr	r1, [r3, #16]
 800bf92:	9f01      	ldr	r7, [sp, #4]
 800bf94:	4411      	add	r1, r2
 800bf96:	0a3f      	lsrs	r7, r7, #8
 800bf98:	f801 7c01 	strb.w	r7, [r1, #-1]
      tmp = Audio_DigMic2RecBuff[index] / 256;
 800bf9c:	f855 1b04 	ldr.w	r1, [r5], #4
 800bfa0:	2900      	cmp	r1, #0
 800bfa2:	bfb8      	it	lt
 800bfa4:	31ff      	addlt	r1, #255	; 0xff
 800bfa6:	1209      	asrs	r1, r1, #8
 800bfa8:	9101      	str	r1, [sp, #4]
      tmp = SaturaLH(tmp, -32768, 32767);
 800bfaa:	9901      	ldr	r1, [sp, #4]
 800bfac:	f511 4f00 	cmn.w	r1, #32768	; 0x8000
 800bfb0:	db20      	blt.n	800bff4 <HAL_DFSDM_FilterRegConvHalfCpltCallback+0x160>
 800bfb2:	9901      	ldr	r1, [sp, #4]
 800bfb4:	f5b1 4f00 	cmp.w	r1, #32768	; 0x8000
 800bfb8:	da1e      	bge.n	800bff8 <HAL_DFSDM_FilterRegConvHalfCpltCallback+0x164>
 800bfba:	9901      	ldr	r1, [sp, #4]
 800bfbc:	9101      	str	r1, [sp, #4]
      Audio_In_Ctx[0].pBuff[(4U * index) + 2U] = (uint8_t) tmp;
 800bfbe:	6919      	ldr	r1, [r3, #16]
 800bfc0:	9f01      	ldr	r7, [sp, #4]
 800bfc2:	548f      	strb	r7, [r1, r2]
      Audio_In_Ctx[0].pBuff[(4U * index) + 3U] = (uint8_t) ((uint32_t) tmp >> 8);
 800bfc4:	6919      	ldr	r1, [r3, #16]
 800bfc6:	9f01      	ldr	r7, [sp, #4]
 800bfc8:	4411      	add	r1, r2
    for (index = 0; index < (recbufsize / 2U); index++)
 800bfca:	3204      	adds	r2, #4
      Audio_In_Ctx[0].pBuff[(4U * index) + 3U] = (uint8_t) ((uint32_t) tmp >> 8);
 800bfcc:	ea4f 2e17 	mov.w	lr, r7, lsr #8
    for (index = 0; index < (recbufsize / 2U); index++)
 800bfd0:	4594      	cmp	ip, r2
      Audio_In_Ctx[0].pBuff[(4U * index) + 3U] = (uint8_t) ((uint32_t) tmp >> 8);
 800bfd2:	f881 e001 	strb.w	lr, [r1, #1]
    for (index = 0; index < (recbufsize / 2U); index++)
 800bfd6:	f43f af6e 	beq.w	800beb6 <HAL_DFSDM_FilterRegConvHalfCpltCallback+0x22>
      tmp = Audio_DigMic1RecBuff[index] / 256;
 800bfda:	f854 1b04 	ldr.w	r1, [r4], #4
 800bfde:	2900      	cmp	r1, #0
 800bfe0:	bfb8      	it	lt
 800bfe2:	31ff      	addlt	r1, #255	; 0xff
 800bfe4:	1209      	asrs	r1, r1, #8
 800bfe6:	9101      	str	r1, [sp, #4]
      tmp = SaturaLH(tmp, -32768, 32767);
 800bfe8:	9901      	ldr	r1, [sp, #4]
 800bfea:	f511 4f00 	cmn.w	r1, #32768	; 0x8000
 800bfee:	dac4      	bge.n	800bf7a <HAL_DFSDM_FilterRegConvHalfCpltCallback+0xe6>
 800bff0:	4637      	mov	r7, r6
 800bff2:	e7c7      	b.n	800bf84 <HAL_DFSDM_FilterRegConvHalfCpltCallback+0xf0>
      tmp = SaturaLH(tmp, -32768, 32767);
 800bff4:	4631      	mov	r1, r6
 800bff6:	e7e1      	b.n	800bfbc <HAL_DFSDM_FilterRegConvHalfCpltCallback+0x128>
 800bff8:	f647 71ff 	movw	r1, #32767	; 0x7fff
 800bffc:	e7de      	b.n	800bfbc <HAL_DFSDM_FilterRegConvHalfCpltCallback+0x128>
      tmp = SaturaLH(tmp, -32768, 32767);
 800bffe:	f647 77ff 	movw	r7, #32767	; 0x7fff
 800c002:	e7bf      	b.n	800bf84 <HAL_DFSDM_FilterRegConvHalfCpltCallback+0xf0>
  if (((Audio_DmaDigMic1RecHalfBuffCplt != 0U) && (Audio_DmaDigMic2RecHalfBuffCplt != 0U) && (Audio_In_Ctx[0].Device == AUDIO_IN_DIGITAL_MIC)) ||
 800c004:	681b      	ldr	r3, [r3, #0]
      ((Audio_DmaDigMic1RecHalfBuffCplt != 0U) && (Audio_In_Ctx[0].Device == AUDIO_IN_DIGITAL_MIC1)) ||
 800c006:	f023 0220 	bic.w	r2, r3, #32
 800c00a:	2a10      	cmp	r2, #16
 800c00c:	f47f af61 	bne.w	800bed2 <HAL_DFSDM_FilterRegConvHalfCpltCallback+0x3e>
 800c010:	e79c      	b.n	800bf4c <HAL_DFSDM_FilterRegConvHalfCpltCallback+0xb8>
      for (index = 0; index < (recbufsize / 2U); index++)
 800c012:	ea5f 0c5c 	movs.w	ip, ip, lsr #1
 800c016:	f43f af4e 	beq.w	800beb6 <HAL_DFSDM_FilterRegConvHalfCpltCallback+0x22>
 800c01a:	ea4f 0c4c 	mov.w	ip, ip, lsl #1
 800c01e:	4e17      	ldr	r6, [pc, #92]	; (800c07c <HAL_DFSDM_FilterRegConvHalfCpltCallback+0x1e8>)
        tmp = SaturaLH(tmp, -32768, 32767);
 800c020:	4f15      	ldr	r7, [pc, #84]	; (800c078 <HAL_DFSDM_FilterRegConvHalfCpltCallback+0x1e4>)
 800c022:	f10c 0201 	add.w	r2, ip, #1
      for (index = 0; index < (recbufsize / 2U); index++)
 800c026:	2401      	movs	r4, #1
        tmp = Audio_DigMic2RecBuff[index] / 256;
 800c028:	f856 1b04 	ldr.w	r1, [r6], #4
 800c02c:	2900      	cmp	r1, #0
 800c02e:	bfb8      	it	lt
 800c030:	31ff      	addlt	r1, #255	; 0xff
 800c032:	1209      	asrs	r1, r1, #8
 800c034:	9101      	str	r1, [sp, #4]
        tmp = SaturaLH(tmp, -32768, 32767);
 800c036:	9901      	ldr	r1, [sp, #4]
 800c038:	f511 4f00 	cmn.w	r1, #32768	; 0x8000
 800c03c:	463d      	mov	r5, r7
 800c03e:	db06      	blt.n	800c04e <HAL_DFSDM_FilterRegConvHalfCpltCallback+0x1ba>
 800c040:	9901      	ldr	r1, [sp, #4]
 800c042:	f5b1 4f00 	cmp.w	r1, #32768	; 0x8000
 800c046:	bfb4      	ite	lt
 800c048:	9d01      	ldrlt	r5, [sp, #4]
 800c04a:	f647 75ff 	movwge	r5, #32767	; 0x7fff
        Audio_In_Ctx[0].pBuff[2U * index]        = (uint8_t) tmp;
 800c04e:	6919      	ldr	r1, [r3, #16]
        tmp = SaturaLH(tmp, -32768, 32767);
 800c050:	9501      	str	r5, [sp, #4]
        Audio_In_Ctx[0].pBuff[2U * index]        = (uint8_t) tmp;
 800c052:	4421      	add	r1, r4
 800c054:	9d01      	ldr	r5, [sp, #4]
 800c056:	f801 5c01 	strb.w	r5, [r1, #-1]
        Audio_In_Ctx[0].pBuff[(2U * index) + 1U] = (uint8_t) ((uint32_t) tmp >> 8);
 800c05a:	9901      	ldr	r1, [sp, #4]
 800c05c:	691d      	ldr	r5, [r3, #16]
 800c05e:	0a09      	lsrs	r1, r1, #8
 800c060:	5529      	strb	r1, [r5, r4]
      for (index = 0; index < (recbufsize / 2U); index++)
 800c062:	3402      	adds	r4, #2
 800c064:	4294      	cmp	r4, r2
 800c066:	d1df      	bne.n	800c028 <HAL_DFSDM_FilterRegConvHalfCpltCallback+0x194>
 800c068:	e725      	b.n	800beb6 <HAL_DFSDM_FilterRegConvHalfCpltCallback+0x22>
 800c06a:	bf00      	nop
 800c06c:	20000000 	.word	0x20000000
 800c070:	20002314 	.word	0x20002314
 800c074:	200025cc 	.word	0x200025cc
 800c078:	ffff8000 	.word	0xffff8000
 800c07c:	200024cc 	.word	0x200024cc

0800c080 <HAL_DFSDM_FilterErrorCallback>:
  * @brief  DFSDM filter error callback.
  * @param  hdfsdm_filter DFSDM filter handle.
  * @retval None.
  */
void HAL_DFSDM_FilterErrorCallback(DFSDM_Filter_HandleTypeDef *hdfsdm_filter)
{
 800c080:	b508      	push	{r3, lr}
  UNUSED(hdfsdm_filter);

  BSP_AUDIO_IN_Error_CallBack(0);
 800c082:	2000      	movs	r0, #0
 800c084:	f016 fcb8 	bl	80229f8 <BSP_AUDIO_IN_Error_CallBack>
}
 800c088:	bd08      	pop	{r3, pc}
 800c08a:	bf00      	nop

0800c08c <BSP_I2C2_DeInit>:
/**
  * @brief  DeInitialize BSP I2C2.
  * @retval BSP status.
  */
int32_t BSP_I2C2_DeInit(void)
{
 800c08c:	b510      	push	{r4, lr}
  int32_t status = BSP_ERROR_NONE;

  if (I2c2InitCounter > 0U)
 800c08e:	4c0f      	ldr	r4, [pc, #60]	; (800c0cc <BSP_I2C2_DeInit+0x40>)
 800c090:	6823      	ldr	r3, [r4, #0]
 800c092:	b113      	cbz	r3, 800c09a <BSP_I2C2_DeInit+0xe>
  {
    I2c2InitCounter--;
 800c094:	3b01      	subs	r3, #1
 800c096:	6023      	str	r3, [r4, #0]
    if (I2c2InitCounter == 0U)
 800c098:	b10b      	cbz	r3, 800c09e <BSP_I2C2_DeInit+0x12>
  int32_t status = BSP_ERROR_NONE;
 800c09a:	2000      	movs	r0, #0
      }
    }
  }

  return status;
}
 800c09c:	bd10      	pop	{r4, pc}
{
  /* Prevent unused argument(s) compilation warning */
  UNUSED(hI2c);

  /* De-initialiaze I2C SCL and SDA */
  HAL_GPIO_DeInit(BUS_I2C2_SCL_GPIO_PORT, BUS_I2C2_SCL_GPIO_PIN);
 800c09e:	480c      	ldr	r0, [pc, #48]	; (800c0d0 <BSP_I2C2_DeInit+0x44>)
 800c0a0:	f44f 6180 	mov.w	r1, #1024	; 0x400
 800c0a4:	f004 fcf0 	bl	8010a88 <HAL_GPIO_DeInit>
  HAL_GPIO_DeInit(BUS_I2C2_SDA_GPIO_PORT, BUS_I2C2_SDA_GPIO_PIN);
 800c0a8:	4809      	ldr	r0, [pc, #36]	; (800c0d0 <BSP_I2C2_DeInit+0x44>)
 800c0aa:	f44f 6100 	mov.w	r1, #2048	; 0x800
 800c0ae:	f004 fceb 	bl	8010a88 <HAL_GPIO_DeInit>

  /* Disable I2C clock */
  BUS_I2C2_CLK_DISABLE();
 800c0b2:	4a08      	ldr	r2, [pc, #32]	; (800c0d4 <BSP_I2C2_DeInit+0x48>)
 800c0b4:	6d93      	ldr	r3, [r2, #88]	; 0x58
 800c0b6:	f423 0380 	bic.w	r3, r3, #4194304	; 0x400000
      if (HAL_I2C_DeInit(&hbus_i2c2) != HAL_OK)
 800c0ba:	1d20      	adds	r0, r4, #4
  BUS_I2C2_CLK_DISABLE();
 800c0bc:	6593      	str	r3, [r2, #88]	; 0x58
      if (HAL_I2C_DeInit(&hbus_i2c2) != HAL_OK)
 800c0be:	f004 ff43 	bl	8010f48 <HAL_I2C_DeInit>
 800c0c2:	2800      	cmp	r0, #0
 800c0c4:	d0e9      	beq.n	800c09a <BSP_I2C2_DeInit+0xe>
        status = BSP_ERROR_PERIPH_FAILURE;
 800c0c6:	f06f 0003 	mvn.w	r0, #3
}
 800c0ca:	bd10      	pop	{r4, pc}
 800c0cc:	200026cc 	.word	0x200026cc
 800c0d0:	48000400 	.word	0x48000400
 800c0d4:	40021000 	.word	0x40021000

0800c0d8 <BSP_I2C2_WriteReg>:
{
 800c0d8:	b500      	push	{lr}
 800c0da:	b085      	sub	sp, #20
 800c0dc:	4684      	mov	ip, r0
static int32_t I2C2_WriteReg(uint16_t DevAddr, uint16_t Reg, uint16_t MemAddSize, uint8_t *pData, uint16_t Length)
{
  int32_t  status = BSP_ERROR_NONE;
  uint32_t hal_error;

  if (HAL_I2C_Mem_Write(&hbus_i2c2, DevAddr, Reg, MemAddSize, pData, Length, BUS_I2C2_TIMEOUT) != HAL_OK)
 800c0de:	f242 7010 	movw	r0, #10000	; 0x2710
 800c0e2:	e9cd 2300 	strd	r2, r3, [sp]
 800c0e6:	9002      	str	r0, [sp, #8]
 800c0e8:	460a      	mov	r2, r1
 800c0ea:	4812      	ldr	r0, [pc, #72]	; (800c134 <BSP_I2C2_WriteReg+0x5c>)
 800c0ec:	2301      	movs	r3, #1
 800c0ee:	4661      	mov	r1, ip
 800c0f0:	f004 ff44 	bl	8010f7c <HAL_I2C_Mem_Write>
 800c0f4:	b910      	cbnz	r0, 800c0fc <BSP_I2C2_WriteReg+0x24>
}
 800c0f6:	b005      	add	sp, #20
 800c0f8:	f85d fb04 	ldr.w	pc, [sp], #4
  {
    hal_error = HAL_I2C_GetError(&hbus_i2c2);
 800c0fc:	480d      	ldr	r0, [pc, #52]	; (800c134 <BSP_I2C2_WriteReg+0x5c>)
 800c0fe:	f005 f937 	bl	8011370 <HAL_I2C_GetError>
    if ((hal_error & HAL_I2C_ERROR_BERR) != 0U)
 800c102:	07c1      	lsls	r1, r0, #31
 800c104:	d40d      	bmi.n	800c122 <BSP_I2C2_WriteReg+0x4a>
    {
      status = BSP_ERROR_BUS_PROTOCOL_FAILURE;
    }
    else if ((hal_error & HAL_I2C_ERROR_ARLO) != 0U)
 800c106:	0782      	lsls	r2, r0, #30
 800c108:	d40e      	bmi.n	800c128 <BSP_I2C2_WriteReg+0x50>
    {
      status = BSP_ERROR_BUS_ARBITRATION_LOSS;
    }
    else if ((hal_error & HAL_I2C_ERROR_AF) != 0U)
 800c10a:	0743      	lsls	r3, r0, #29
 800c10c:	d40f      	bmi.n	800c12e <BSP_I2C2_WriteReg+0x56>
    {
      status = BSP_ERROR_BUS_TRANSACTION_FAILURE;
    }
    else
    {
      status = BSP_ERROR_PERIPH_FAILURE;
 800c10e:	f010 0f60 	tst.w	r0, #96	; 0x60
 800c112:	bf14      	ite	ne
 800c114:	f06f 0063 	mvnne.w	r0, #99	; 0x63
 800c118:	f06f 0003 	mvneq.w	r0, #3
}
 800c11c:	b005      	add	sp, #20
 800c11e:	f85d fb04 	ldr.w	pc, [sp], #4
      status = BSP_ERROR_BUS_PROTOCOL_FAILURE;
 800c122:	f06f 0066 	mvn.w	r0, #102	; 0x66
 800c126:	e7e6      	b.n	800c0f6 <BSP_I2C2_WriteReg+0x1e>
      status = BSP_ERROR_BUS_ARBITRATION_LOSS;
 800c128:	f06f 0064 	mvn.w	r0, #100	; 0x64
 800c12c:	e7e3      	b.n	800c0f6 <BSP_I2C2_WriteReg+0x1e>
      status = BSP_ERROR_BUS_ACKNOWLEDGE_FAILURE;
 800c12e:	f06f 0065 	mvn.w	r0, #101	; 0x65
 800c132:	e7e0      	b.n	800c0f6 <BSP_I2C2_WriteReg+0x1e>
 800c134:	200026d0 	.word	0x200026d0

0800c138 <BSP_I2C2_ReadReg>:
{
 800c138:	b500      	push	{lr}
 800c13a:	b085      	sub	sp, #20
 800c13c:	4684      	mov	ip, r0
static int32_t I2C2_ReadReg(uint16_t DevAddr, uint16_t Reg, uint16_t MemAddSize, uint8_t *pData, uint16_t Length)
{
  int32_t  status = BSP_ERROR_NONE;
  uint32_t hal_error;

  if (HAL_I2C_Mem_Read(&hbus_i2c2, DevAddr, Reg, MemAddSize, pData, Length, BUS_I2C2_TIMEOUT) != HAL_OK)
 800c13e:	f242 7010 	movw	r0, #10000	; 0x2710
 800c142:	e9cd 2300 	strd	r2, r3, [sp]
 800c146:	9002      	str	r0, [sp, #8]
 800c148:	460a      	mov	r2, r1
 800c14a:	4812      	ldr	r0, [pc, #72]	; (800c194 <BSP_I2C2_ReadReg+0x5c>)
 800c14c:	2301      	movs	r3, #1
 800c14e:	4661      	mov	r1, ip
 800c150:	f005 f80e 	bl	8011170 <HAL_I2C_Mem_Read>
 800c154:	b910      	cbnz	r0, 800c15c <BSP_I2C2_ReadReg+0x24>
}
 800c156:	b005      	add	sp, #20
 800c158:	f85d fb04 	ldr.w	pc, [sp], #4
    hal_error = HAL_I2C_GetError(&hbus_i2c2);
 800c15c:	480d      	ldr	r0, [pc, #52]	; (800c194 <BSP_I2C2_ReadReg+0x5c>)
 800c15e:	f005 f907 	bl	8011370 <HAL_I2C_GetError>
    if ((hal_error & HAL_I2C_ERROR_BERR) != 0U)
 800c162:	07c1      	lsls	r1, r0, #31
 800c164:	d40d      	bmi.n	800c182 <BSP_I2C2_ReadReg+0x4a>
    else if ((hal_error & HAL_I2C_ERROR_ARLO) != 0U)
 800c166:	0782      	lsls	r2, r0, #30
 800c168:	d40e      	bmi.n	800c188 <BSP_I2C2_ReadReg+0x50>
    else if ((hal_error & HAL_I2C_ERROR_AF) != 0U)
 800c16a:	0743      	lsls	r3, r0, #29
 800c16c:	d40f      	bmi.n	800c18e <BSP_I2C2_ReadReg+0x56>
      status = BSP_ERROR_PERIPH_FAILURE;
 800c16e:	f010 0f60 	tst.w	r0, #96	; 0x60
 800c172:	bf14      	ite	ne
 800c174:	f06f 0063 	mvnne.w	r0, #99	; 0x63
 800c178:	f06f 0003 	mvneq.w	r0, #3
}
 800c17c:	b005      	add	sp, #20
 800c17e:	f85d fb04 	ldr.w	pc, [sp], #4
      status = BSP_ERROR_BUS_PROTOCOL_FAILURE;
 800c182:	f06f 0066 	mvn.w	r0, #102	; 0x66
 800c186:	e7e6      	b.n	800c156 <BSP_I2C2_ReadReg+0x1e>
      status = BSP_ERROR_BUS_ARBITRATION_LOSS;
 800c188:	f06f 0064 	mvn.w	r0, #100	; 0x64
 800c18c:	e7e3      	b.n	800c156 <BSP_I2C2_ReadReg+0x1e>
      status = BSP_ERROR_BUS_ACKNOWLEDGE_FAILURE;
 800c18e:	f06f 0065 	mvn.w	r0, #101	; 0x65
 800c192:	e7e0      	b.n	800c156 <BSP_I2C2_ReadReg+0x1e>
 800c194:	200026d0 	.word	0x200026d0

0800c198 <MX_I2C2_Init>:
  hI2c->Init.OwnAddress1      = 0;
 800c198:	2300      	movs	r3, #0
  hI2c->Init.AddressingMode   = I2C_ADDRESSINGMODE_7BIT;
 800c19a:	2201      	movs	r2, #1
{
 800c19c:	b510      	push	{r4, lr}
  hI2c->Init.OwnAddress1      = 0;
 800c19e:	e9c0 1301 	strd	r1, r3, [r0, #4]
  hI2c->Init.DualAddressMode  = I2C_DUALADDRESS_DISABLE;
 800c1a2:	e9c0 2303 	strd	r2, r3, [r0, #12]
  hI2c->Init.OwnAddress2Masks = I2C_OA2_NOMASK;
 800c1a6:	e9c0 3305 	strd	r3, r3, [r0, #20]
  hI2c->Init.NoStretchMode    = I2C_NOSTRETCH_DISABLE;
 800c1aa:	e9c0 3307 	strd	r3, r3, [r0, #28]
{
 800c1ae:	4604      	mov	r4, r0
  if (HAL_I2C_Init(hI2c) != HAL_OK)
 800c1b0:	f004 fe74 	bl	8010e9c <HAL_I2C_Init>
 800c1b4:	b108      	cbz	r0, 800c1ba <MX_I2C2_Init+0x22>
    status = HAL_ERROR;
 800c1b6:	2001      	movs	r0, #1
}
 800c1b8:	bd10      	pop	{r4, pc}
    if (HAL_I2CEx_ConfigAnalogFilter(hI2c, analog_filter) != HAL_OK)
 800c1ba:	4601      	mov	r1, r0
 800c1bc:	4620      	mov	r0, r4
 800c1be:	f005 f8d9 	bl	8011374 <HAL_I2CEx_ConfigAnalogFilter>
 800c1c2:	2800      	cmp	r0, #0
 800c1c4:	d1f7      	bne.n	800c1b6 <MX_I2C2_Init+0x1e>
      if (HAL_I2CEx_ConfigDigitalFilter(hI2c, I2C_DIGITAL_FILTER_COEF) != HAL_OK)
 800c1c6:	4601      	mov	r1, r0
 800c1c8:	4620      	mov	r0, r4
 800c1ca:	f005 f8fd 	bl	80113c8 <HAL_I2CEx_ConfigDigitalFilter>
    status = HAL_ERROR;
 800c1ce:	3800      	subs	r0, #0
 800c1d0:	bf18      	it	ne
 800c1d2:	2001      	movne	r0, #1
}
 800c1d4:	bd10      	pop	{r4, pc}
 800c1d6:	bf00      	nop

0800c1d8 <BSP_I2C2_Init>:
{
 800c1d8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  hbus_i2c2.Instance = BUS_I2C2;
 800c1dc:	f8df b2c4 	ldr.w	fp, [pc, #708]	; 800c4a4 <BSP_I2C2_Init+0x2cc>
 800c1e0:	4baa      	ldr	r3, [pc, #680]	; (800c48c <BSP_I2C2_Init+0x2b4>)
  if (I2c2InitCounter == 0U)
 800c1e2:	f8db 2000 	ldr.w	r2, [fp]
  hbus_i2c2.Instance = BUS_I2C2;
 800c1e6:	f8cb 3004 	str.w	r3, [fp, #4]
{
 800c1ea:	b095      	sub	sp, #84	; 0x54
  if (I2c2InitCounter == 0U)
 800c1ec:	9200      	str	r2, [sp, #0]
 800c1ee:	b14a      	cbz	r2, 800c204 <BSP_I2C2_Init+0x2c>
  int32_t status = BSP_ERROR_NONE;
 800c1f0:	2000      	movs	r0, #0
  if (I2c2InitCounter < 0xFFFFFFFFU)
 800c1f2:	9b00      	ldr	r3, [sp, #0]
 800c1f4:	1c5a      	adds	r2, r3, #1
    I2c2InitCounter++;
 800c1f6:	bf1c      	itt	ne
 800c1f8:	3301      	addne	r3, #1
 800c1fa:	f8cb 3000 	strne.w	r3, [fp]
}
 800c1fe:	b015      	add	sp, #84	; 0x54
 800c200:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    if (HAL_I2C_GetState(&hbus_i2c2) == HAL_I2C_STATE_RESET)
 800c204:	f10b 0004 	add.w	r0, fp, #4
 800c208:	f005 f8ae 	bl	8011368 <HAL_I2C_GetState>
 800c20c:	b120      	cbz	r0, 800c218 <BSP_I2C2_Init+0x40>
  if (I2c2InitCounter < 0xFFFFFFFFU)
 800c20e:	f8db 3000 	ldr.w	r3, [fp]
 800c212:	9300      	str	r3, [sp, #0]
  int32_t status = BSP_ERROR_NONE;
 800c214:	2000      	movs	r0, #0
 800c216:	e7ec      	b.n	800c1f2 <BSP_I2C2_Init+0x1a>
  BUS_I2C2_SDA_GPIO_CLK_ENABLE();
 800c218:	4c9d      	ldr	r4, [pc, #628]	; (800c490 <BSP_I2C2_Init+0x2b8>)
  gpio_init_structure.Pull      = GPIO_NOPULL;
 800c21a:	9e00      	ldr	r6, [sp, #0]
  BUS_I2C2_SDA_GPIO_CLK_ENABLE();
 800c21c:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
  HAL_GPIO_Init(BUS_I2C2_SCL_GPIO_PORT, &gpio_init_structure);
 800c21e:	489d      	ldr	r0, [pc, #628]	; (800c494 <BSP_I2C2_Init+0x2bc>)
  BUS_I2C2_SDA_GPIO_CLK_ENABLE();
 800c220:	f043 0302 	orr.w	r3, r3, #2
 800c224:	64e3      	str	r3, [r4, #76]	; 0x4c
 800c226:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
 800c228:	f003 0302 	and.w	r3, r3, #2
 800c22c:	930c      	str	r3, [sp, #48]	; 0x30
 800c22e:	9b0c      	ldr	r3, [sp, #48]	; 0x30
  BUS_I2C2_SCL_GPIO_CLK_ENABLE();
 800c230:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
 800c232:	f043 0302 	orr.w	r3, r3, #2
 800c236:	64e3      	str	r3, [r4, #76]	; 0x4c
 800c238:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
  gpio_init_structure.Pull      = GPIO_NOPULL;
 800c23a:	9611      	str	r6, [sp, #68]	; 0x44
  BUS_I2C2_SCL_GPIO_CLK_ENABLE();
 800c23c:	f003 0302 	and.w	r3, r3, #2
 800c240:	930d      	str	r3, [sp, #52]	; 0x34
  gpio_init_structure.Pin       = BUS_I2C2_SCL_GPIO_PIN;
 800c242:	f44f 6380 	mov.w	r3, #1024	; 0x400
 800c246:	930f      	str	r3, [sp, #60]	; 0x3c
  gpio_init_structure.Mode      = GPIO_MODE_AF_OD;
 800c248:	2312      	movs	r3, #18
 800c24a:	9310      	str	r3, [sp, #64]	; 0x40
  gpio_init_structure.Alternate = BUS_I2C2_SCL_GPIO_AF;
 800c24c:	2504      	movs	r5, #4
 800c24e:	2302      	movs	r3, #2
  HAL_GPIO_Init(BUS_I2C2_SCL_GPIO_PORT, &gpio_init_structure);
 800c250:	a90f      	add	r1, sp, #60	; 0x3c
  gpio_init_structure.Alternate = BUS_I2C2_SCL_GPIO_AF;
 800c252:	e9cd 3512 	strd	r3, r5, [sp, #72]	; 0x48
  BUS_I2C2_SCL_GPIO_CLK_ENABLE();
 800c256:	9a0d      	ldr	r2, [sp, #52]	; 0x34
  HAL_GPIO_Init(BUS_I2C2_SCL_GPIO_PORT, &gpio_init_structure);
 800c258:	f004 faf0 	bl	801083c <HAL_GPIO_Init>
  gpio_init_structure.Pin       = BUS_I2C2_SDA_GPIO_PIN;
 800c25c:	f44f 6300 	mov.w	r3, #2048	; 0x800
  HAL_GPIO_Init(BUS_I2C2_SDA_GPIO_PORT, &gpio_init_structure);
 800c260:	488c      	ldr	r0, [pc, #560]	; (800c494 <BSP_I2C2_Init+0x2bc>)
  gpio_init_structure.Pin       = BUS_I2C2_SDA_GPIO_PIN;
 800c262:	930f      	str	r3, [sp, #60]	; 0x3c
  HAL_GPIO_Init(BUS_I2C2_SDA_GPIO_PORT, &gpio_init_structure);
 800c264:	a90f      	add	r1, sp, #60	; 0x3c
  gpio_init_structure.Alternate = BUS_I2C2_SDA_GPIO_AF;
 800c266:	9513      	str	r5, [sp, #76]	; 0x4c
  HAL_GPIO_Init(BUS_I2C2_SDA_GPIO_PORT, &gpio_init_structure);
 800c268:	f004 fae8 	bl	801083c <HAL_GPIO_Init>
  BUS_I2C2_CLK_ENABLE();
 800c26c:	6da3      	ldr	r3, [r4, #88]	; 0x58
 800c26e:	f443 0380 	orr.w	r3, r3, #4194304	; 0x400000
 800c272:	65a3      	str	r3, [r4, #88]	; 0x58
 800c274:	6da3      	ldr	r3, [r4, #88]	; 0x58
 800c276:	f403 0380 	and.w	r3, r3, #4194304	; 0x400000
 800c27a:	930e      	str	r3, [sp, #56]	; 0x38
 800c27c:	9b0e      	ldr	r3, [sp, #56]	; 0x38
  BUS_I2C2_FORCE_RESET();
 800c27e:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 800c280:	f443 0380 	orr.w	r3, r3, #4194304	; 0x400000
 800c284:	63a3      	str	r3, [r4, #56]	; 0x38
  BUS_I2C2_RELEASE_RESET();
 800c286:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 800c288:	f423 0380 	bic.w	r3, r3, #4194304	; 0x400000
      if (MX_I2C2_Init(&hbus_i2c2, I2C_GetTiming(HAL_RCCEx_GetPeriphCLKFreq(RCC_PERIPHCLK_I2C2), BUS_I2C2_FREQUENCY)) != HAL_OK)
 800c28c:	2080      	movs	r0, #128	; 0x80
  BUS_I2C2_RELEASE_RESET();
 800c28e:	63a3      	str	r3, [r4, #56]	; 0x38
      if (MX_I2C2_Init(&hbus_i2c2, I2C_GetTiming(HAL_RCCEx_GetPeriphCLKFreq(RCC_PERIPHCLK_I2C2), BUS_I2C2_FREQUENCY)) != HAL_OK)
 800c290:	f007 f9ee 	bl	8013670 <HAL_RCCEx_GetPeriphCLKFreq>
{
  uint32_t ret = 0;
  uint32_t speed;
  uint32_t idx;

  if((clock_src_freq != 0U) && (i2c_freq != 0U))
 800c294:	2800      	cmp	r0, #0
 800c296:	d06b      	beq.n	800c370 <BSP_I2C2_Init+0x198>
  int32_t  tsdadel_min, tsdadel_max;
  int32_t  tscldel_min;
  uint32_t presc, scldel, sdadel;
  uint32_t tafdel_min, tafdel_max;

  ti2cclk   = (SEC2NSEC + (clock_src_freq / 2U))/ clock_src_freq;
 800c298:	4b7f      	ldr	r3, [pc, #508]	; (800c498 <BSP_I2C2_Init+0x2c0>)
 800c29a:	f8db 4050 	ldr.w	r4, [fp, #80]	; 0x50
 800c29e:	9408      	str	r4, [sp, #32]
 800c2a0:	eb03 0350 	add.w	r3, r3, r0, lsr #1
     SDADEL <= {tVD;DAT(max) - tr - tAF(max) - tDNF- [4 x tI2CCLK]} / {tPRESC} */

  tsdadel_min = (int32_t)I2C_Charac[I2C_speed].tfall + (int32_t)I2C_Charac[I2C_speed].hddat_min -
    (int32_t)tafdel_min - (int32_t)(((int32_t)I2C_Charac[I2C_speed].dnf + 3) * (int32_t)ti2cclk);

  tsdadel_max = (int32_t)I2C_Charac[I2C_speed].vddat_max - (int32_t)I2C_Charac[I2C_speed].trise -
 800c2a4:	f640 18f6 	movw	r8, #2550	; 0x9f6
  ti2cclk   = (SEC2NSEC + (clock_src_freq / 2U))/ clock_src_freq;
 800c2a8:	fbb3 faf0 	udiv	sl, r3, r0
  tsdadel_min = (int32_t)I2C_Charac[I2C_speed].tfall + (int32_t)I2C_Charac[I2C_speed].hddat_min -
 800c2ac:	f06f 001d 	mvn.w	r0, #29
    (int32_t)tafdel_min - (int32_t)(((int32_t)I2C_Charac[I2C_speed].dnf + 3) * (int32_t)ti2cclk);
 800c2b0:	eb0a 034a 	add.w	r3, sl, sl, lsl #1
  tsdadel_min = (int32_t)I2C_Charac[I2C_speed].tfall + (int32_t)I2C_Charac[I2C_speed].hddat_min -
 800c2b4:	1ac0      	subs	r0, r0, r3
  tsdadel_max = (int32_t)I2C_Charac[I2C_speed].vddat_max - (int32_t)I2C_Charac[I2C_speed].trise -
 800c2b6:	eba8 088a 	sub.w	r8, r8, sl, lsl #2
    (int32_t)tafdel_min - (int32_t)(((int32_t)I2C_Charac[I2C_speed].dnf + 3) * (int32_t)ti2cclk);
 800c2ba:	ea4f 094a 	mov.w	r9, sl, lsl #1
 800c2be:	ea20 70e0 	bic.w	r0, r0, r0, asr #31
  if (tsdadel_min <= 0)
  {
    tsdadel_min = 0;
  }

  if (tsdadel_max <= 0)
 800c2c2:	ea28 78e8 	bic.w	r8, r8, r8, asr #31
  ti2cclk   = (SEC2NSEC + (clock_src_freq / 2U))/ clock_src_freq;
 800c2c6:	4651      	mov	r1, sl
  tsdadel_max = (int32_t)I2C_Charac[I2C_speed].vddat_max - (int32_t)I2C_Charac[I2C_speed].trise -
 800c2c8:	9601      	str	r6, [sp, #4]
  uint32_t prev_presc = I2C_PRESC_MAX;
 800c2ca:	f04f 0c10 	mov.w	ip, #16
    for (scldel = 0; scldel < I2C_SCLDEL_MAX; scldel++)
    {
      /* TSCLDEL = (SCLDEL+1) * (PRESC+1) * TI2CCLK */
      uint32_t tscldel = (scldel + 1U) * (presc + 1U) * ti2cclk;

      if (tscldel >= (uint32_t)tscldel_min)
 800c2ce:	f240 3e79 	movw	lr, #889	; 0x379
 800c2d2:	f8cd 9008 	str.w	r9, [sp, #8]
{
 800c2d6:	460f      	mov	r7, r1
    for (scldel = 0; scldel < I2C_SCLDEL_MAX; scldel++)
 800c2d8:	2500      	movs	r5, #0
 800c2da:	e003      	b.n	800c2e4 <BSP_I2C2_Init+0x10c>
 800c2dc:	2d10      	cmp	r5, #16
 800c2de:	440f      	add	r7, r1
 800c2e0:	f000 80c3 	beq.w	800c46a <BSP_I2C2_Init+0x292>
      if (tscldel >= (uint32_t)tscldel_min)
 800c2e4:	4577      	cmp	r7, lr
 800c2e6:	46a9      	mov	r9, r5
      uint32_t tscldel = (scldel + 1U) * (presc + 1U) * ti2cclk;
 800c2e8:	f105 0501 	add.w	r5, r5, #1
      if (tscldel >= (uint32_t)tscldel_min)
 800c2ec:	d9f6      	bls.n	800c2dc <BSP_I2C2_Init+0x104>
        for (sdadel = 0; sdadel < I2C_SDADEL_MAX; sdadel++)
        {
          /* TSDADEL = SDADEL * (PRESC+1) * TI2CCLK */
          uint32_t tsdadel = (sdadel * (presc + 1U)) * ti2cclk;

          if ((tsdadel >= (uint32_t)tsdadel_min) && (tsdadel <= (uint32_t)tsdadel_max))
 800c2ee:	2300      	movs	r3, #0
        for (sdadel = 0; sdadel < I2C_SDADEL_MAX; sdadel++)
 800c2f0:	461a      	mov	r2, r3
 800c2f2:	9503      	str	r5, [sp, #12]
          if ((tsdadel >= (uint32_t)tsdadel_min) && (tsdadel <= (uint32_t)tsdadel_max))
 800c2f4:	4298      	cmp	r0, r3
 800c2f6:	d811      	bhi.n	800c31c <BSP_I2C2_Init+0x144>
 800c2f8:	4598      	cmp	r8, r3
 800c2fa:	d30f      	bcc.n	800c31c <BSP_I2C2_Init+0x144>
          {
            if(presc != prev_presc)
 800c2fc:	45b4      	cmp	ip, r6
 800c2fe:	d00d      	beq.n	800c31c <BSP_I2C2_Init+0x144>
            {
              I2c_valid_timing[I2c_valid_timing_nbr].presc = presc;
 800c300:	eb04 0c84 	add.w	ip, r4, r4, lsl #2
 800c304:	eb0b 0c8c 	add.w	ip, fp, ip, lsl #2
              I2c_valid_timing[I2c_valid_timing_nbr].tscldel = scldel;
              I2c_valid_timing[I2c_valid_timing_nbr].tsdadel = sdadel;
              prev_presc = presc;
              I2c_valid_timing_nbr ++;
 800c308:	3401      	adds	r4, #1

              if(I2c_valid_timing_nbr >= I2C_VALID_TIMING_NBR)
 800c30a:	2c7f      	cmp	r4, #127	; 0x7f
              I2c_valid_timing[I2c_valid_timing_nbr].tscldel = scldel;
 800c30c:	e9cc 6915 	strd	r6, r9, [ip, #84]	; 0x54
              I2c_valid_timing[I2c_valid_timing_nbr].tsdadel = sdadel;
 800c310:	f8cc 205c 	str.w	r2, [ip, #92]	; 0x5c
              if(I2c_valid_timing_nbr >= I2C_VALID_TIMING_NBR)
 800c314:	d839      	bhi.n	800c38a <BSP_I2C2_Init+0x1b2>
 800c316:	2501      	movs	r5, #1
 800c318:	46b4      	mov	ip, r6
 800c31a:	9501      	str	r5, [sp, #4]
        for (sdadel = 0; sdadel < I2C_SDADEL_MAX; sdadel++)
 800c31c:	3201      	adds	r2, #1
 800c31e:	2a10      	cmp	r2, #16
 800c320:	440b      	add	r3, r1
 800c322:	d1e7      	bne.n	800c2f4 <BSP_I2C2_Init+0x11c>
 800c324:	9d03      	ldr	r5, [sp, #12]
 800c326:	e7d9      	b.n	800c2dc <BSP_I2C2_Init+0x104>
  clk_max = SEC2NSEC / I2C_Charac[I2C_speed].freq_min;
  clk_min = SEC2NSEC / I2C_Charac[I2C_speed].freq_max;

  prev_error = ti2cspeed;

  for (uint32_t count = 0; count < I2c_valid_timing_nbr; count++)
 800c328:	9a05      	ldr	r2, [sp, #20]
 800c32a:	9b01      	ldr	r3, [sp, #4]
 800c32c:	3214      	adds	r2, #20
 800c32e:	9205      	str	r2, [sp, #20]
 800c330:	9a08      	ldr	r2, [sp, #32]
 800c332:	3301      	adds	r3, #1
 800c334:	429a      	cmp	r2, r3
 800c336:	9301      	str	r3, [sp, #4]
 800c338:	d143      	bne.n	800c3c2 <BSP_I2C2_Init+0x1ea>
        if (idx < I2C_VALID_TIMING_NBR)
 800c33a:	9b02      	ldr	r3, [sp, #8]
 800c33c:	2b7f      	cmp	r3, #127	; 0x7f
 800c33e:	d817      	bhi.n	800c370 <BSP_I2C2_Init+0x198>
          ret = ((I2c_valid_timing[idx].presc  & 0x0FU) << 28) |\
 800c340:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 800c344:	eb0b 0383 	add.w	r3, fp, r3, lsl #2
 800c348:	e9d3 0115 	ldrd	r0, r1, [r3, #84]	; 0x54
                ((I2c_valid_timing[idx].scll & 0xFFU) << 0);
 800c34c:	f893 2064 	ldrb.w	r2, [r3, #100]	; 0x64
                ((I2c_valid_timing[idx].tscldel & 0x0FU) << 20) |\
 800c350:	0509      	lsls	r1, r1, #20
          ret = ((I2c_valid_timing[idx].presc  & 0x0FU) << 28) |\
 800c352:	ea42 7200 	orr.w	r2, r2, r0, lsl #28
                ((I2c_valid_timing[idx].tscldel & 0x0FU) << 20) |\
 800c356:	f401 0170 	and.w	r1, r1, #15728640	; 0xf00000
          ret = ((I2c_valid_timing[idx].presc  & 0x0FU) << 28) |\
 800c35a:	430a      	orrs	r2, r1
                ((I2c_valid_timing[idx].sclh & 0xFFU) << 8) |\
 800c35c:	e9d3 0117 	ldrd	r0, r1, [r3, #92]	; 0x5c
                ((I2c_valid_timing[idx].tsdadel & 0x0FU) << 16) |\
 800c360:	0403      	lsls	r3, r0, #16
 800c362:	f403 2370 	and.w	r3, r3, #983040	; 0xf0000
                ((I2c_valid_timing[idx].sclh & 0xFFU) << 8) |\
 800c366:	0209      	lsls	r1, r1, #8
          ret = ((I2c_valid_timing[idx].presc  & 0x0FU) << 28) |\
 800c368:	4313      	orrs	r3, r2
                ((I2c_valid_timing[idx].sclh & 0xFFU) << 8) |\
 800c36a:	b28a      	uxth	r2, r1
          ret = ((I2c_valid_timing[idx].presc  & 0x0FU) << 28) |\
 800c36c:	4313      	orrs	r3, r2
 800c36e:	9300      	str	r3, [sp, #0]
      if (MX_I2C2_Init(&hbus_i2c2, I2C_GetTiming(HAL_RCCEx_GetPeriphCLKFreq(RCC_PERIPHCLK_I2C2), BUS_I2C2_FREQUENCY)) != HAL_OK)
 800c370:	484a      	ldr	r0, [pc, #296]	; (800c49c <BSP_I2C2_Init+0x2c4>)
 800c372:	9900      	ldr	r1, [sp, #0]
 800c374:	f7ff ff10 	bl	800c198 <MX_I2C2_Init>
  if (I2c2InitCounter < 0xFFFFFFFFU)
 800c378:	f8db 3000 	ldr.w	r3, [fp]
 800c37c:	9300      	str	r3, [sp, #0]
      if (MX_I2C2_Init(&hbus_i2c2, I2C_GetTiming(HAL_RCCEx_GetPeriphCLKFreq(RCC_PERIPHCLK_I2C2), BUS_I2C2_FREQUENCY)) != HAL_OK)
 800c37e:	2800      	cmp	r0, #0
 800c380:	f43f af37 	beq.w	800c1f2 <BSP_I2C2_Init+0x1a>
        status = BSP_ERROR_BUS_FAILURE;
 800c384:	f06f 0007 	mvn.w	r0, #7
 800c388:	e733      	b.n	800c1f2 <BSP_I2C2_Init+0x1a>
 800c38a:	f8dd 9008 	ldr.w	r9, [sp, #8]
 800c38e:	f8cb 4050 	str.w	r4, [fp, #80]	; 0x50
              I2c_valid_timing_nbr ++;
 800c392:	9408      	str	r4, [sp, #32]
 800c394:	f5c9 5390 	rsb	r3, r9, #4608	; 0x1200
 800c398:	330c      	adds	r3, #12
 800c39a:	9309      	str	r3, [sp, #36]	; 0x24
 800c39c:	f5a9 5311 	sub.w	r3, r9, #9280	; 0x2440
 800c3a0:	3b0a      	subs	r3, #10
 800c3a2:	930b      	str	r3, [sp, #44]	; 0x2c
 800c3a4:	4b3e      	ldr	r3, [pc, #248]	; (800c4a0 <BSP_I2C2_Init+0x2c8>)
 800c3a6:	9305      	str	r3, [sp, #20]
    uint32_t tpresc = (I2c_valid_timing[count].presc + 1U) * ti2cclk;

    for (scll = 0; scll < I2C_SCLL_MAX; scll++)
    {
      /* tLOW(min) <= tAF(min) + tDNF + 2 x tI2CCLK + [(SCLL+1) x tPRESC ] */
      uint32_t tscl_l = tafdel_min + dnf_delay + (2U * ti2cclk) + ((scll + 1U) * tpresc);
 800c3a8:	2300      	movs	r3, #0
 800c3aa:	9301      	str	r3, [sp, #4]
 800c3ac:	f242 7310 	movw	r3, #10000	; 0x2710
 800c3b0:	f109 0232 	add.w	r2, r9, #50	; 0x32
 800c3b4:	461e      	mov	r6, r3
 800c3b6:	f04f 33ff 	mov.w	r3, #4294967295
 800c3ba:	920a      	str	r2, [sp, #40]	; 0x28
 800c3bc:	9302      	str	r3, [sp, #8]
          uint32_t tscl_h = tafdel_min + dnf_delay + (2U * ti2cclk) + ((sclh + 1U) * tpresc);

          /* tSCL = tf + tLOW + tr + tHIGH */
          uint32_t tscl = tscl_l + tscl_h + I2C_Charac[I2C_speed].trise + I2C_Charac[I2C_speed].tfall;

          if ((tscl >= clk_min) && (tscl <= clk_max) && (tscl_h >= I2C_Charac[I2C_speed].hscl_min) && (ti2cclk < tscl_h))
 800c3be:	f241 0547 	movw	r5, #4167	; 0x1047
    uint32_t tpresc = (I2c_valid_timing[count].presc + 1U) * ti2cclk;
 800c3c2:	9b05      	ldr	r3, [sp, #20]
 800c3c4:	9909      	ldr	r1, [sp, #36]	; 0x24
 800c3c6:	681a      	ldr	r2, [r3, #0]
 800c3c8:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 800c3ca:	fb02 a20a 	mla	r2, r2, sl, sl
    for (scll = 0; scll < I2C_SCLL_MAX; scll++)
 800c3ce:	4413      	add	r3, r2
 800c3d0:	9306      	str	r3, [sp, #24]
    uint32_t tpresc = (I2c_valid_timing[count].presc + 1U) * ti2cclk;
 800c3d2:	469c      	mov	ip, r3
 800c3d4:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 800c3d6:	eba1 0802 	sub.w	r8, r1, r2
 800c3da:	4413      	add	r3, r2
 800c3dc:	ea4f 0848 	mov.w	r8, r8, lsl #1
    for (scll = 0; scll < I2C_SCLL_MAX; scll++)
 800c3e0:	f04f 0e00 	mov.w	lr, #0
 800c3e4:	9307      	str	r3, [sp, #28]
 800c3e6:	e005      	b.n	800c3f4 <BSP_I2C2_Init+0x21c>
 800c3e8:	f5be 7f80 	cmp.w	lr, #256	; 0x100
 800c3ec:	4494      	add	ip, r2
 800c3ee:	eba8 0802 	sub.w	r8, r8, r2
 800c3f2:	d099      	beq.n	800c328 <BSP_I2C2_Init+0x150>
      if ((tscl_l > I2C_Charac[I2C_speed].lscl_min) && (ti2cclk < ((tscl_l - tafdel_min - dnf_delay) / 4U)))
 800c3f4:	f241 215c 	movw	r1, #4700	; 0x125c
 800c3f8:	458c      	cmp	ip, r1
 800c3fa:	46f1      	mov	r9, lr
 800c3fc:	f1ac 0332 	sub.w	r3, ip, #50	; 0x32
      uint32_t tscl_l = tafdel_min + dnf_delay + (2U * ti2cclk) + ((scll + 1U) * tpresc);
 800c400:	f10e 0e01 	add.w	lr, lr, #1
      if ((tscl_l > I2C_Charac[I2C_speed].lscl_min) && (ti2cclk < ((tscl_l - tafdel_min - dnf_delay) / 4U)))
 800c404:	d9f0      	bls.n	800c3e8 <BSP_I2C2_Init+0x210>
 800c406:	ebba 0f93 	cmp.w	sl, r3, lsr #2
 800c40a:	d2ed      	bcs.n	800c3e8 <BSP_I2C2_Init+0x210>
 800c40c:	9b07      	ldr	r3, [sp, #28]
 800c40e:	9806      	ldr	r0, [sp, #24]
        for (sclh = 0; sclh < I2C_SCLH_MAX; sclh++)
 800c410:	e9cd 8c03 	strd	r8, ip, [sp, #12]
 800c414:	eb03 010c 	add.w	r1, r3, ip
 800c418:	f8dd c014 	ldr.w	ip, [sp, #20]
      if ((tscl_l > I2C_Charac[I2C_speed].lscl_min) && (ti2cclk < ((tscl_l - tafdel_min - dnf_delay) / 4U)))
 800c41c:	4644      	mov	r4, r8
        for (sclh = 0; sclh < I2C_SCLH_MAX; sclh++)
 800c41e:	2300      	movs	r3, #0
 800c420:	46b0      	mov	r8, r6
          if ((tscl >= clk_min) && (tscl <= clk_max) && (tscl_h >= I2C_Charac[I2C_speed].hscl_min) && (ti2cclk < tscl_h))
 800c422:	f201 6683 	addw	r6, r1, #1667	; 0x683
 800c426:	42ae      	cmp	r6, r5
 800c428:	461f      	mov	r7, r3
          uint32_t tscl_h = tafdel_min + dnf_delay + (2U * ti2cclk) + ((sclh + 1U) * tpresc);
 800c42a:	f103 0301 	add.w	r3, r3, #1
          if ((tscl >= clk_min) && (tscl <= clk_max) && (tscl_h >= I2C_Charac[I2C_speed].hscl_min) && (ti2cclk < tscl_h))
 800c42e:	d80f      	bhi.n	800c450 <BSP_I2C2_Init+0x278>
 800c430:	f5b0 6f7a 	cmp.w	r0, #4000	; 0xfa0
 800c434:	d30c      	bcc.n	800c450 <BSP_I2C2_Init+0x278>
 800c436:	4550      	cmp	r0, sl
 800c438:	d90a      	bls.n	800c450 <BSP_I2C2_Init+0x278>
          {
            int32_t error = (int32_t)tscl - (int32_t)ti2cspeed;

            if (error < 0)
 800c43a:	ea31 0621 	bics.w	r6, r1, r1, asr #32
 800c43e:	bf28      	it	cs
 800c440:	4626      	movcs	r6, r4
            {
              error = -error;
            }

            /* look for the timings with the lowest clock error */
            if ((uint32_t)error < prev_error)
 800c442:	4546      	cmp	r6, r8
 800c444:	d204      	bcs.n	800c450 <BSP_I2C2_Init+0x278>
            {
              prev_error = (uint32_t)error;
              I2c_valid_timing[count].scll = scll;
 800c446:	e9cc 7903 	strd	r7, r9, [ip, #12]
              I2c_valid_timing[count].sclh = sclh;
 800c44a:	46b0      	mov	r8, r6
 800c44c:	9e01      	ldr	r6, [sp, #4]
 800c44e:	9602      	str	r6, [sp, #8]
        for (sclh = 0; sclh < I2C_SCLH_MAX; sclh++)
 800c450:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 800c454:	4410      	add	r0, r2
 800c456:	eba4 0402 	sub.w	r4, r4, r2
 800c45a:	4411      	add	r1, r2
 800c45c:	d1e1      	bne.n	800c422 <BSP_I2C2_Init+0x24a>
 800c45e:	4646      	mov	r6, r8
 800c460:	f8dd c010 	ldr.w	ip, [sp, #16]
 800c464:	f8dd 800c 	ldr.w	r8, [sp, #12]
 800c468:	e7be      	b.n	800c3e8 <BSP_I2C2_Init+0x210>
  for (presc = 0; presc < I2C_PRESC_MAX; presc++)
 800c46a:	3601      	adds	r6, #1
 800c46c:	2e10      	cmp	r6, #16
 800c46e:	4451      	add	r1, sl
 800c470:	f47f af31 	bne.w	800c2d6 <BSP_I2C2_Init+0xfe>
 800c474:	e9dd 3901 	ldrd	r3, r9, [sp, #4]
 800c478:	b113      	cbz	r3, 800c480 <BSP_I2C2_Init+0x2a8>
 800c47a:	f8cb 4050 	str.w	r4, [fp, #80]	; 0x50
 800c47e:	9408      	str	r4, [sp, #32]
  for (uint32_t count = 0; count < I2c_valid_timing_nbr; count++)
 800c480:	9b08      	ldr	r3, [sp, #32]
 800c482:	2b00      	cmp	r3, #0
 800c484:	f43f af74 	beq.w	800c370 <BSP_I2C2_Init+0x198>
 800c488:	e784      	b.n	800c394 <BSP_I2C2_Init+0x1bc>
 800c48a:	bf00      	nop
 800c48c:	40005800 	.word	0x40005800
 800c490:	40021000 	.word	0x40021000
 800c494:	48000400 	.word	0x48000400
 800c498:	3b9aca00 	.word	0x3b9aca00
 800c49c:	200026d0 	.word	0x200026d0
 800c4a0:	20002720 	.word	0x20002720
 800c4a4:	200026cc 	.word	0x200026cc

0800c4a8 <BSP_GetTick>:
  ret = HAL_GetTick();
 800c4a8:	f003 b9c6 	b.w	800f838 <HAL_GetTick>

0800c4ac <BSP_ENV_SENSOR_Init>:
  */
int32_t BSP_ENV_SENSOR_Init(uint32_t Instance, uint32_t Functions)
{
  int32_t status = BSP_ERROR_NONE;

  if (Instance >= ENV_SENSOR_INSTANCES_NBR)
 800c4ac:	2801      	cmp	r0, #1
 800c4ae:	d879      	bhi.n	800c5a4 <BSP_ENV_SENSOR_Init+0xf8>
{
 800c4b0:	b5f0      	push	{r4, r5, r6, r7, lr}
 800c4b2:	4606      	mov	r6, r0
 800c4b4:	b089      	sub	sp, #36	; 0x24
 800c4b6:	460d      	mov	r5, r1
  {
    status = BSP_ERROR_WRONG_PARAM;
  }
  else if ((Instance == 0U) && ((Functions & ENV_PRESSURE) != 0U))
 800c4b8:	2800      	cmp	r0, #0
 800c4ba:	d13b      	bne.n	800c534 <BSP_ENV_SENSOR_Init+0x88>
 800c4bc:	078c      	lsls	r4, r1, #30
 800c4be:	d474      	bmi.n	800c5aa <BSP_ENV_SENSOR_Init+0xfe>
  static HTS221_Object_t HTS221_Obj;

  /* Configure the environmental sensor driver */
  IOCtx.BusType     = HTS221_I2C_BUS;
  IOCtx.Address     = HTS221_I2C_ADDRESS;
  IOCtx.Init        = BSP_I2C2_Init;
 800c4c0:	4b3b      	ldr	r3, [pc, #236]	; (800c5b0 <BSP_ENV_SENSOR_Init+0x104>)
  IOCtx.DeInit      = BSP_I2C2_DeInit;
  IOCtx.ReadReg     = BSP_I2C2_ReadReg;
  IOCtx.WriteReg    = BSP_I2C2_WriteReg;
  IOCtx.GetTick     = BSP_GetTick;

  if (HTS221_RegisterBusIO(&HTS221_Obj, &IOCtx) != HTS221_OK)
 800c4c2:	4c3c      	ldr	r4, [pc, #240]	; (800c5b4 <BSP_ENV_SENSOR_Init+0x108>)
  IOCtx.DeInit      = BSP_I2C2_DeInit;
 800c4c4:	4a3c      	ldr	r2, [pc, #240]	; (800c5b8 <BSP_ENV_SENSOR_Init+0x10c>)
  IOCtx.Init        = BSP_I2C2_Init;
 800c4c6:	9301      	str	r3, [sp, #4]
  IOCtx.Address     = HTS221_I2C_ADDRESS;
 800c4c8:	21bf      	movs	r1, #191	; 0xbf
  IOCtx.ReadReg     = BSP_I2C2_ReadReg;
 800c4ca:	4b3c      	ldr	r3, [pc, #240]	; (800c5bc <BSP_ENV_SENSOR_Init+0x110>)
  IOCtx.Address     = HTS221_I2C_ADDRESS;
 800c4cc:	f88d 1010 	strb.w	r1, [sp, #16]
  IOCtx.BusType     = HTS221_I2C_BUS;
 800c4d0:	9003      	str	r0, [sp, #12]
  IOCtx.DeInit      = BSP_I2C2_DeInit;
 800c4d2:	9202      	str	r2, [sp, #8]
  IOCtx.ReadReg     = BSP_I2C2_ReadReg;
 800c4d4:	9306      	str	r3, [sp, #24]
  IOCtx.WriteReg    = BSP_I2C2_WriteReg;
 800c4d6:	4a3a      	ldr	r2, [pc, #232]	; (800c5c0 <BSP_ENV_SENSOR_Init+0x114>)
  IOCtx.GetTick     = BSP_GetTick;
 800c4d8:	4b3a      	ldr	r3, [pc, #232]	; (800c5c4 <BSP_ENV_SENSOR_Init+0x118>)
  IOCtx.WriteReg    = BSP_I2C2_WriteReg;
 800c4da:	9205      	str	r2, [sp, #20]
  if (HTS221_RegisterBusIO(&HTS221_Obj, &IOCtx) != HTS221_OK)
 800c4dc:	a901      	add	r1, sp, #4
 800c4de:	4620      	mov	r0, r4
  IOCtx.GetTick     = BSP_GetTick;
 800c4e0:	9307      	str	r3, [sp, #28]
  if (HTS221_RegisterBusIO(&HTS221_Obj, &IOCtx) != HTS221_OK)
 800c4e2:	f000 ff95 	bl	800d410 <HTS221_RegisterBusIO>
 800c4e6:	2800      	cmp	r0, #0
 800c4e8:	d158      	bne.n	800c59c <BSP_ENV_SENSOR_Init+0xf0>
  {
    status = BSP_ERROR_BUS_FAILURE;
  }
  else if (HTS221_ReadID(&HTS221_Obj, &hts221_id) != HTS221_OK)
 800c4ea:	f10d 0103 	add.w	r1, sp, #3
 800c4ee:	4620      	mov	r0, r4
 800c4f0:	f000 fdac 	bl	800d04c <HTS221_ReadID>
 800c4f4:	2800      	cmp	r0, #0
 800c4f6:	d151      	bne.n	800c59c <BSP_ENV_SENSOR_Init+0xf0>
  {
    status = BSP_ERROR_COMPONENT_FAILURE;
  }
  else if (hts221_id != HTS221_ID)
 800c4f8:	f89d 3003 	ldrb.w	r3, [sp, #3]
 800c4fc:	2bbc      	cmp	r3, #188	; 0xbc
 800c4fe:	d14d      	bne.n	800c59c <BSP_ENV_SENSOR_Init+0xf0>
    status = BSP_ERROR_UNKNOWN_COMPONENT;
  }
  else
  {
    Env_Sensor_CompObj[0] = &HTS221_Obj;
    Env_Sensor_Drv[0]     = (ENV_SENSOR_CommonDrv_t *) &HTS221_COMMON_Driver;
 800c500:	4b31      	ldr	r3, [pc, #196]	; (800c5c8 <BSP_ENV_SENSOR_Init+0x11c>)
    Env_Sensor_CompObj[0] = &HTS221_Obj;
 800c502:	62e4      	str	r4, [r4, #44]	; 0x2c
    if (Env_Sensor_Drv[0]->Init(Env_Sensor_CompObj[0]) < 0)
 800c504:	681a      	ldr	r2, [r3, #0]
    Env_Sensor_Drv[0]     = (ENV_SENSOR_CommonDrv_t *) &HTS221_COMMON_Driver;
 800c506:	6363      	str	r3, [r4, #52]	; 0x34
    if (Env_Sensor_Drv[0]->Init(Env_Sensor_CompObj[0]) < 0)
 800c508:	4620      	mov	r0, r4
 800c50a:	4790      	blx	r2
 800c50c:	2800      	cmp	r0, #0
 800c50e:	db45      	blt.n	800c59c <BSP_ENV_SENSOR_Init+0xf0>
    {
      status = BSP_ERROR_COMPONENT_FAILURE;
    }
    else
    {
      if ((Functions & ENV_TEMPERATURE) != 0U)
 800c510:	07e8      	lsls	r0, r5, #31
      {
        Env_Sensor_FuncDrv[0][TemperatureIdx] = (ENV_SENSOR_FuncDrv_t *) &HTS221_TEMP_Driver;
 800c512:	bf44      	itt	mi
 800c514:	4b2d      	ldrmi	r3, [pc, #180]	; (800c5cc <BSP_ENV_SENSOR_Init+0x120>)
 800c516:	63e3      	strmi	r3, [r4, #60]	; 0x3c
      }
      if ((Functions & ENV_HUMIDITY) != 0U)
 800c518:	0769      	lsls	r1, r5, #29
 800c51a:	d501      	bpl.n	800c520 <BSP_ENV_SENSOR_Init+0x74>
      {
        Env_Sensor_FuncDrv[0][HumidityIdx] = (ENV_SENSOR_FuncDrv_t *) &HTS221_HUM_Driver;
 800c51c:	4b2c      	ldr	r3, [pc, #176]	; (800c5d0 <BSP_ENV_SENSOR_Init+0x124>)
 800c51e:	6463      	str	r3, [r4, #68]	; 0x44
      Env_Sensor_Ctx[Instance].Functions |= Functions;
 800c520:	eb04 0486 	add.w	r4, r4, r6, lsl #2
 800c524:	2000      	movs	r0, #0
 800c526:	f8d4 1080 	ldr.w	r1, [r4, #128]	; 0x80
 800c52a:	4329      	orrs	r1, r5
 800c52c:	f8c4 1080 	str.w	r1, [r4, #128]	; 0x80
}
 800c530:	b009      	add	sp, #36	; 0x24
 800c532:	bdf0      	pop	{r4, r5, r6, r7, pc}
  else if ((Instance == 1U) && ((Functions & ENV_HUMIDITY) != 0U))
 800c534:	f011 0104 	ands.w	r1, r1, #4
 800c538:	d137      	bne.n	800c5aa <BSP_ENV_SENSOR_Init+0xfe>
  static LPS22HB_Object_t LPS22HB_Obj;

  /* Configure the environmental sensor driver */
  IOCtx.BusType     = LPS22HB_I2C_BUS;
  IOCtx.Address     = LPS22HB_I2C_ADD_H;
  IOCtx.Init        = BSP_I2C2_Init;
 800c53a:	4b1d      	ldr	r3, [pc, #116]	; (800c5b0 <BSP_ENV_SENSOR_Init+0x104>)
  IOCtx.DeInit      = BSP_I2C2_DeInit;
  IOCtx.ReadReg     = BSP_I2C2_ReadReg;
  IOCtx.WriteReg    = BSP_I2C2_WriteReg;
  IOCtx.GetTick     = BSP_GetTick;

  if (LPS22HB_RegisterBusIO(&LPS22HB_Obj, &IOCtx) != LPS22HB_OK)
 800c53c:	4c1d      	ldr	r4, [pc, #116]	; (800c5b4 <BSP_ENV_SENSOR_Init+0x108>)
  IOCtx.Init        = BSP_I2C2_Init;
 800c53e:	9301      	str	r3, [sp, #4]
  IOCtx.DeInit      = BSP_I2C2_DeInit;
 800c540:	4b1d      	ldr	r3, [pc, #116]	; (800c5b8 <BSP_ENV_SENSOR_Init+0x10c>)
 800c542:	9302      	str	r3, [sp, #8]
  IOCtx.ReadReg     = BSP_I2C2_ReadReg;
 800c544:	4b1d      	ldr	r3, [pc, #116]	; (800c5bc <BSP_ENV_SENSOR_Init+0x110>)
 800c546:	9306      	str	r3, [sp, #24]
  if (LPS22HB_RegisterBusIO(&LPS22HB_Obj, &IOCtx) != LPS22HB_OK)
 800c548:	f104 0754 	add.w	r7, r4, #84	; 0x54
  IOCtx.WriteReg    = BSP_I2C2_WriteReg;
 800c54c:	4b1c      	ldr	r3, [pc, #112]	; (800c5c0 <BSP_ENV_SENSOR_Init+0x114>)
  IOCtx.BusType     = LPS22HB_I2C_BUS;
 800c54e:	9103      	str	r1, [sp, #12]
  IOCtx.Address     = LPS22HB_I2C_ADD_H;
 800c550:	22bb      	movs	r2, #187	; 0xbb
  IOCtx.WriteReg    = BSP_I2C2_WriteReg;
 800c552:	9305      	str	r3, [sp, #20]
  if (LPS22HB_RegisterBusIO(&LPS22HB_Obj, &IOCtx) != LPS22HB_OK)
 800c554:	a901      	add	r1, sp, #4
  IOCtx.GetTick     = BSP_GetTick;
 800c556:	4b1b      	ldr	r3, [pc, #108]	; (800c5c4 <BSP_ENV_SENSOR_Init+0x118>)
  IOCtx.Address     = LPS22HB_I2C_ADD_H;
 800c558:	f88d 2010 	strb.w	r2, [sp, #16]
  if (LPS22HB_RegisterBusIO(&LPS22HB_Obj, &IOCtx) != LPS22HB_OK)
 800c55c:	4638      	mov	r0, r7
  IOCtx.GetTick     = BSP_GetTick;
 800c55e:	9307      	str	r3, [sp, #28]
  if (LPS22HB_RegisterBusIO(&LPS22HB_Obj, &IOCtx) != LPS22HB_OK)
 800c560:	f001 fecc 	bl	800e2fc <LPS22HB_RegisterBusIO>
 800c564:	b9d0      	cbnz	r0, 800c59c <BSP_ENV_SENSOR_Init+0xf0>
  {
    status = BSP_ERROR_BUS_FAILURE;
  }
  else if (LPS22HB_ReadID(&LPS22HB_Obj, &lps22hb_id) != LPS22HB_OK)
 800c566:	f10d 0103 	add.w	r1, sp, #3
 800c56a:	4638      	mov	r0, r7
 800c56c:	f001 fc86 	bl	800de7c <LPS22HB_ReadID>
 800c570:	b9a0      	cbnz	r0, 800c59c <BSP_ENV_SENSOR_Init+0xf0>
  {
    status = BSP_ERROR_COMPONENT_FAILURE;
  }
  else if (lps22hb_id != LPS22HB_ID)
 800c572:	f89d 3003 	ldrb.w	r3, [sp, #3]
 800c576:	2bb1      	cmp	r3, #177	; 0xb1
 800c578:	d110      	bne.n	800c59c <BSP_ENV_SENSOR_Init+0xf0>
    status = BSP_ERROR_UNKNOWN_COMPONENT;
  }
  else
  {
    Env_Sensor_CompObj[1] = &LPS22HB_Obj;
    Env_Sensor_Drv[1]     = (ENV_SENSOR_CommonDrv_t *) &LPS22HB_COMMON_Driver;
 800c57a:	4b16      	ldr	r3, [pc, #88]	; (800c5d4 <BSP_ENV_SENSOR_Init+0x128>)
 800c57c:	63a3      	str	r3, [r4, #56]	; 0x38
    Env_Sensor_CompObj[1] = &LPS22HB_Obj;
 800c57e:	6327      	str	r7, [r4, #48]	; 0x30
    if (Env_Sensor_Drv[1]->Init(Env_Sensor_CompObj[1]) < 0)
 800c580:	681b      	ldr	r3, [r3, #0]
 800c582:	4638      	mov	r0, r7
 800c584:	4798      	blx	r3
 800c586:	2800      	cmp	r0, #0
 800c588:	db08      	blt.n	800c59c <BSP_ENV_SENSOR_Init+0xf0>
    {
      status = BSP_ERROR_COMPONENT_FAILURE;
    }
    else
    {
      if ((Functions & ENV_TEMPERATURE) != 0U)
 800c58a:	07ea      	lsls	r2, r5, #31
      {
        Env_Sensor_FuncDrv[1][TemperatureIdx] = (ENV_SENSOR_FuncDrv_t *) &LPS22HB_TEMP_Driver;
 800c58c:	bf44      	itt	mi
 800c58e:	4b12      	ldrmi	r3, [pc, #72]	; (800c5d8 <BSP_ENV_SENSOR_Init+0x12c>)
 800c590:	64a3      	strmi	r3, [r4, #72]	; 0x48
      }
      if ((Functions & ENV_PRESSURE) != 0U)
 800c592:	07ab      	lsls	r3, r5, #30
 800c594:	d5c4      	bpl.n	800c520 <BSP_ENV_SENSOR_Init+0x74>
      {
        Env_Sensor_FuncDrv[1][PressureIdx] = (ENV_SENSOR_FuncDrv_t *) &LPS22HB_PRESS_Driver;
 800c596:	4b11      	ldr	r3, [pc, #68]	; (800c5dc <BSP_ENV_SENSOR_Init+0x130>)
 800c598:	64e3      	str	r3, [r4, #76]	; 0x4c
      }
    }
  }

  return status;
 800c59a:	e7c1      	b.n	800c520 <BSP_ENV_SENSOR_Init+0x74>
        status = BSP_ERROR_COMPONENT_FAILURE;
 800c59c:	f06f 0004 	mvn.w	r0, #4
}
 800c5a0:	b009      	add	sp, #36	; 0x24
 800c5a2:	bdf0      	pop	{r4, r5, r6, r7, pc}
    status = BSP_ERROR_WRONG_PARAM;
 800c5a4:	f06f 0001 	mvn.w	r0, #1
}
 800c5a8:	4770      	bx	lr
    status = BSP_ERROR_FEATURE_NOT_SUPPORTED;
 800c5aa:	f06f 000a 	mvn.w	r0, #10
  return status;
 800c5ae:	e7bf      	b.n	800c530 <BSP_ENV_SENSOR_Init+0x84>
 800c5b0:	0800c1d9 	.word	0x0800c1d9
 800c5b4:	20003188 	.word	0x20003188
 800c5b8:	0800c08d 	.word	0x0800c08d
 800c5bc:	0800c139 	.word	0x0800c139
 800c5c0:	0800c0d9 	.word	0x0800c0d9
 800c5c4:	0800c4a9 	.word	0x0800c4a9
 800c5c8:	20000048 	.word	0x20000048
 800c5cc:	20000020 	.word	0x20000020
 800c5d0:	20000034 	.word	0x20000034
 800c5d4:	200000b4 	.word	0x200000b4
 800c5d8:	2000008c 	.word	0x2000008c
 800c5dc:	200000a0 	.word	0x200000a0

0800c5e0 <BSP_ENV_SENSOR_Enable>:
  if (Instance >= ENV_SENSOR_INSTANCES_NBR)
 800c5e0:	2801      	cmp	r0, #1
 800c5e2:	d829      	bhi.n	800c638 <BSP_ENV_SENSOR_Enable+0x58>
  else if ((Instance == 0U) && (Function == ENV_PRESSURE))
 800c5e4:	bb08      	cbnz	r0, 800c62a <BSP_ENV_SENSOR_Enable+0x4a>
 800c5e6:	2902      	cmp	r1, #2
 800c5e8:	d021      	beq.n	800c62e <BSP_ENV_SENSOR_Enable+0x4e>
{
 800c5ea:	b508      	push	{r3, lr}
  else if ((Env_Sensor_Ctx[Instance].Functions & Function) == 0U)
 800c5ec:	4b15      	ldr	r3, [pc, #84]	; (800c644 <BSP_ENV_SENSOR_Enable+0x64>)
 800c5ee:	eb03 0280 	add.w	r2, r3, r0, lsl #2
 800c5f2:	ea4f 0c80 	mov.w	ip, r0, lsl #2
 800c5f6:	f8d2 2080 	ldr.w	r2, [r2, #128]	; 0x80
 800c5fa:	4211      	tst	r1, r2
 800c5fc:	d01f      	beq.n	800c63e <BSP_ENV_SENSOR_Enable+0x5e>
    index = (Function == ENV_TEMPERATURE) ? TemperatureIdx : ((Function == ENV_PRESSURE) ? PressureIdx : HumidityIdx);
 800c5fe:	2901      	cmp	r1, #1
 800c600:	d018      	beq.n	800c634 <BSP_ENV_SENSOR_Enable+0x54>
 800c602:	2902      	cmp	r1, #2
 800c604:	bf0c      	ite	eq
 800c606:	2201      	moveq	r2, #1
 800c608:	2202      	movne	r2, #2
    if(Env_Sensor_FuncDrv[Instance][index]->Enable(Env_Sensor_CompObj[Instance]) < 0)
 800c60a:	eb00 0040 	add.w	r0, r0, r0, lsl #1
 800c60e:	4410      	add	r0, r2
 800c610:	eb03 0080 	add.w	r0, r3, r0, lsl #2
 800c614:	4463      	add	r3, ip
 800c616:	6bc2      	ldr	r2, [r0, #60]	; 0x3c
 800c618:	6ad8      	ldr	r0, [r3, #44]	; 0x2c
 800c61a:	6813      	ldr	r3, [r2, #0]
 800c61c:	4798      	blx	r3
      status = BSP_ERROR_COMPONENT_FAILURE;
 800c61e:	2800      	cmp	r0, #0
 800c620:	bfac      	ite	ge
 800c622:	2000      	movge	r0, #0
 800c624:	f06f 0004 	mvnlt.w	r0, #4
}
 800c628:	bd08      	pop	{r3, pc}
  else if ((Instance == 1U) && (Function == ENV_HUMIDITY))
 800c62a:	2904      	cmp	r1, #4
 800c62c:	d1dd      	bne.n	800c5ea <BSP_ENV_SENSOR_Enable+0xa>
    status = BSP_ERROR_FEATURE_NOT_SUPPORTED;
 800c62e:	f06f 000a 	mvn.w	r0, #10
}
 800c632:	4770      	bx	lr
 800c634:	2200      	movs	r2, #0
 800c636:	e7e8      	b.n	800c60a <BSP_ENV_SENSOR_Enable+0x2a>
    status = BSP_ERROR_WRONG_PARAM;
 800c638:	f06f 0001 	mvn.w	r0, #1
 800c63c:	4770      	bx	lr
    status = BSP_ERROR_NO_INIT;
 800c63e:	f04f 30ff 	mov.w	r0, #4294967295
}
 800c642:	bd08      	pop	{r3, pc}
 800c644:	20003188 	.word	0x20003188

0800c648 <BSP_ENV_SENSOR_Disable>:
  if (Instance >= ENV_SENSOR_INSTANCES_NBR)
 800c648:	2801      	cmp	r0, #1
 800c64a:	d829      	bhi.n	800c6a0 <BSP_ENV_SENSOR_Disable+0x58>
  else if ((Instance == 0U) && (Function == ENV_PRESSURE))
 800c64c:	bb08      	cbnz	r0, 800c692 <BSP_ENV_SENSOR_Disable+0x4a>
 800c64e:	2902      	cmp	r1, #2
 800c650:	d021      	beq.n	800c696 <BSP_ENV_SENSOR_Disable+0x4e>
{
 800c652:	b508      	push	{r3, lr}
  else if ((Env_Sensor_Ctx[Instance].Functions & Function) == 0U)
 800c654:	4b15      	ldr	r3, [pc, #84]	; (800c6ac <BSP_ENV_SENSOR_Disable+0x64>)
 800c656:	eb03 0280 	add.w	r2, r3, r0, lsl #2
 800c65a:	ea4f 0c80 	mov.w	ip, r0, lsl #2
 800c65e:	f8d2 2080 	ldr.w	r2, [r2, #128]	; 0x80
 800c662:	4211      	tst	r1, r2
 800c664:	d01f      	beq.n	800c6a6 <BSP_ENV_SENSOR_Disable+0x5e>
    index = (Function == ENV_TEMPERATURE) ? TemperatureIdx : ((Function == ENV_PRESSURE) ? PressureIdx : HumidityIdx);
 800c666:	2901      	cmp	r1, #1
 800c668:	d018      	beq.n	800c69c <BSP_ENV_SENSOR_Disable+0x54>
 800c66a:	2902      	cmp	r1, #2
 800c66c:	bf0c      	ite	eq
 800c66e:	2201      	moveq	r2, #1
 800c670:	2202      	movne	r2, #2
    if (Env_Sensor_FuncDrv[Instance][index]->Disable(Env_Sensor_CompObj[Instance]) < 0)
 800c672:	eb00 0040 	add.w	r0, r0, r0, lsl #1
 800c676:	4410      	add	r0, r2
 800c678:	eb03 0080 	add.w	r0, r3, r0, lsl #2
 800c67c:	4463      	add	r3, ip
 800c67e:	6bc2      	ldr	r2, [r0, #60]	; 0x3c
 800c680:	6ad8      	ldr	r0, [r3, #44]	; 0x2c
 800c682:	6853      	ldr	r3, [r2, #4]
 800c684:	4798      	blx	r3
      status = BSP_ERROR_COMPONENT_FAILURE;
 800c686:	2800      	cmp	r0, #0
 800c688:	bfac      	ite	ge
 800c68a:	2000      	movge	r0, #0
 800c68c:	f06f 0004 	mvnlt.w	r0, #4
}
 800c690:	bd08      	pop	{r3, pc}
  else if ((Instance == 1U) && (Function == ENV_HUMIDITY))
 800c692:	2904      	cmp	r1, #4
 800c694:	d1dd      	bne.n	800c652 <BSP_ENV_SENSOR_Disable+0xa>
    status = BSP_ERROR_FEATURE_NOT_SUPPORTED;
 800c696:	f06f 000a 	mvn.w	r0, #10
}
 800c69a:	4770      	bx	lr
 800c69c:	2200      	movs	r2, #0
 800c69e:	e7e8      	b.n	800c672 <BSP_ENV_SENSOR_Disable+0x2a>
    status = BSP_ERROR_WRONG_PARAM;
 800c6a0:	f06f 0001 	mvn.w	r0, #1
 800c6a4:	4770      	bx	lr
    status = BSP_ERROR_NO_INIT;
 800c6a6:	f04f 30ff 	mov.w	r0, #4294967295
}
 800c6aa:	bd08      	pop	{r3, pc}
 800c6ac:	20003188 	.word	0x20003188

0800c6b0 <BSP_ENV_SENSOR_GetValue>:
  if ((Instance >= ENV_SENSOR_INSTANCES_NBR) || (Value == NULL))
 800c6b0:	2801      	cmp	r0, #1
 800c6b2:	d82b      	bhi.n	800c70c <BSP_ENV_SENSOR_GetValue+0x5c>
 800c6b4:	b352      	cbz	r2, 800c70c <BSP_ENV_SENSOR_GetValue+0x5c>
  else if ((Instance == 0U) && (Function == ENV_PRESSURE))
 800c6b6:	bb10      	cbnz	r0, 800c6fe <BSP_ENV_SENSOR_GetValue+0x4e>
 800c6b8:	2902      	cmp	r1, #2
 800c6ba:	d022      	beq.n	800c702 <BSP_ENV_SENSOR_GetValue+0x52>
  else if ((Env_Sensor_Ctx[Instance].Functions & Function) == 0U)
 800c6bc:	4b16      	ldr	r3, [pc, #88]	; (800c718 <BSP_ENV_SENSOR_GetValue+0x68>)
{
 800c6be:	b510      	push	{r4, lr}
  else if ((Env_Sensor_Ctx[Instance].Functions & Function) == 0U)
 800c6c0:	eb03 0480 	add.w	r4, r3, r0, lsl #2
 800c6c4:	ea4f 0c80 	mov.w	ip, r0, lsl #2
 800c6c8:	f8d4 4080 	ldr.w	r4, [r4, #128]	; 0x80
 800c6cc:	4221      	tst	r1, r4
 800c6ce:	d020      	beq.n	800c712 <BSP_ENV_SENSOR_GetValue+0x62>
    index = (Function == ENV_TEMPERATURE) ? TemperatureIdx : ((Function == ENV_PRESSURE) ? PressureIdx : HumidityIdx);
 800c6d0:	2901      	cmp	r1, #1
 800c6d2:	d019      	beq.n	800c708 <BSP_ENV_SENSOR_GetValue+0x58>
 800c6d4:	2902      	cmp	r1, #2
 800c6d6:	bf0c      	ite	eq
 800c6d8:	2101      	moveq	r1, #1
 800c6da:	2102      	movne	r1, #2
    if (Env_Sensor_FuncDrv[Instance][index]->GetValue(Env_Sensor_CompObj[Instance], Value) < 0)
 800c6dc:	eb00 0040 	add.w	r0, r0, r0, lsl #1
 800c6e0:	4408      	add	r0, r1
 800c6e2:	eb03 0080 	add.w	r0, r3, r0, lsl #2
 800c6e6:	4463      	add	r3, ip
 800c6e8:	6bc1      	ldr	r1, [r0, #60]	; 0x3c
 800c6ea:	6ad8      	ldr	r0, [r3, #44]	; 0x2c
 800c6ec:	690b      	ldr	r3, [r1, #16]
 800c6ee:	4611      	mov	r1, r2
 800c6f0:	4798      	blx	r3
      status = BSP_ERROR_COMPONENT_FAILURE;
 800c6f2:	2800      	cmp	r0, #0
 800c6f4:	bfac      	ite	ge
 800c6f6:	2000      	movge	r0, #0
 800c6f8:	f06f 0004 	mvnlt.w	r0, #4
}
 800c6fc:	bd10      	pop	{r4, pc}
  else if ((Instance == 1U) && (Function == ENV_HUMIDITY))
 800c6fe:	2904      	cmp	r1, #4
 800c700:	d1dc      	bne.n	800c6bc <BSP_ENV_SENSOR_GetValue+0xc>
    status = BSP_ERROR_FEATURE_NOT_SUPPORTED;
 800c702:	f06f 000a 	mvn.w	r0, #10
}
 800c706:	4770      	bx	lr
 800c708:	2100      	movs	r1, #0
 800c70a:	e7e7      	b.n	800c6dc <BSP_ENV_SENSOR_GetValue+0x2c>
    status = BSP_ERROR_WRONG_PARAM;
 800c70c:	f06f 0001 	mvn.w	r0, #1
 800c710:	4770      	bx	lr
    status = BSP_ERROR_NO_INIT;
 800c712:	f04f 30ff 	mov.w	r0, #4294967295
}
 800c716:	bd10      	pop	{r4, pc}
 800c718:	20003188 	.word	0x20003188

0800c71c <BSP_MOTION_SENSOR_Init>:
  */
int32_t BSP_MOTION_SENSOR_Init(uint32_t Instance, uint32_t Functions)
{
  int32_t status = BSP_ERROR_NONE;

  if (Instance >= MOTION_SENSOR_INSTANCES_NBR)
 800c71c:	2801      	cmp	r0, #1
 800c71e:	d875      	bhi.n	800c80c <BSP_MOTION_SENSOR_Init+0xf0>
{
 800c720:	b5f0      	push	{r4, r5, r6, r7, lr}
 800c722:	4605      	mov	r5, r0
 800c724:	b089      	sub	sp, #36	; 0x24
 800c726:	460f      	mov	r7, r1
  {
    status = BSP_ERROR_WRONG_PARAM;
  }
  else if ((Instance == 0U) && ((Functions & MOTION_MAGNETO) != 0U))
 800c728:	2800      	cmp	r0, #0
 800c72a:	d13b      	bne.n	800c7a4 <BSP_MOTION_SENSOR_Init+0x88>
 800c72c:	0748      	lsls	r0, r1, #29
 800c72e:	d470      	bmi.n	800c812 <BSP_MOTION_SENSOR_Init+0xf6>
  static LSM6DSL_Object_t LSM6DSL_Obj;

  /* Configure the motion sensor driver */
  IOCtx.BusType     = LSM6DSL_I2C_BUS;
  IOCtx.Address     = LSM6DSL_I2C_ADD_L;
  IOCtx.Init        = BSP_I2C2_Init;
 800c730:	4b39      	ldr	r3, [pc, #228]	; (800c818 <BSP_MOTION_SENSOR_Init+0xfc>)
  IOCtx.DeInit      = BSP_I2C2_DeInit;
  IOCtx.ReadReg     = BSP_I2C2_ReadReg;
  IOCtx.WriteReg    = BSP_I2C2_WriteReg;
  IOCtx.GetTick     = BSP_GetTick;

  if (LSM6DSL_RegisterBusIO(&LSM6DSL_Obj, &IOCtx) != LSM6DSL_OK)
 800c732:	4c3a      	ldr	r4, [pc, #232]	; (800c81c <BSP_MOTION_SENSOR_Init+0x100>)
  IOCtx.DeInit      = BSP_I2C2_DeInit;
 800c734:	4a3a      	ldr	r2, [pc, #232]	; (800c820 <BSP_MOTION_SENSOR_Init+0x104>)
  IOCtx.Init        = BSP_I2C2_Init;
 800c736:	9301      	str	r3, [sp, #4]
  IOCtx.Address     = LSM6DSL_I2C_ADD_L;
 800c738:	21d5      	movs	r1, #213	; 0xd5
  IOCtx.ReadReg     = BSP_I2C2_ReadReg;
 800c73a:	4b3a      	ldr	r3, [pc, #232]	; (800c824 <BSP_MOTION_SENSOR_Init+0x108>)
  IOCtx.Address     = LSM6DSL_I2C_ADD_L;
 800c73c:	f88d 1010 	strb.w	r1, [sp, #16]
  IOCtx.DeInit      = BSP_I2C2_DeInit;
 800c740:	9202      	str	r2, [sp, #8]
  IOCtx.ReadReg     = BSP_I2C2_ReadReg;
 800c742:	9306      	str	r3, [sp, #24]
  IOCtx.WriteReg    = BSP_I2C2_WriteReg;
 800c744:	4a38      	ldr	r2, [pc, #224]	; (800c828 <BSP_MOTION_SENSOR_Init+0x10c>)
  IOCtx.GetTick     = BSP_GetTick;
 800c746:	4b39      	ldr	r3, [pc, #228]	; (800c82c <BSP_MOTION_SENSOR_Init+0x110>)
  IOCtx.BusType     = LSM6DSL_I2C_BUS;
 800c748:	9503      	str	r5, [sp, #12]
  if (LSM6DSL_RegisterBusIO(&LSM6DSL_Obj, &IOCtx) != LSM6DSL_OK)
 800c74a:	a901      	add	r1, sp, #4
 800c74c:	4620      	mov	r0, r4
  IOCtx.WriteReg    = BSP_I2C2_WriteReg;
 800c74e:	9205      	str	r2, [sp, #20]
  IOCtx.GetTick     = BSP_GetTick;
 800c750:	9307      	str	r3, [sp, #28]
  if (LSM6DSL_RegisterBusIO(&LSM6DSL_Obj, &IOCtx) != LSM6DSL_OK)
 800c752:	f002 fbc3 	bl	800eedc <LSM6DSL_RegisterBusIO>
 800c756:	2800      	cmp	r0, #0
 800c758:	d154      	bne.n	800c804 <BSP_MOTION_SENSOR_Init+0xe8>
  {
    status = BSP_ERROR_BUS_FAILURE;
  }
  else if (LSM6DSL_ReadID(&LSM6DSL_Obj, &lsm6dsl_id) != LSM6DSL_OK)
 800c75a:	f10d 0103 	add.w	r1, sp, #3
 800c75e:	4620      	mov	r0, r4
 800c760:	f002 f922 	bl	800e9a8 <LSM6DSL_ReadID>
 800c764:	2800      	cmp	r0, #0
 800c766:	d14d      	bne.n	800c804 <BSP_MOTION_SENSOR_Init+0xe8>
  {
    status = BSP_ERROR_COMPONENT_FAILURE;
  }
  else if (lsm6dsl_id != LSM6DSL_ID)
 800c768:	f89d 3003 	ldrb.w	r3, [sp, #3]
 800c76c:	2b6a      	cmp	r3, #106	; 0x6a
 800c76e:	d149      	bne.n	800c804 <BSP_MOTION_SENSOR_Init+0xe8>
    status = BSP_ERROR_UNKNOWN_COMPONENT;
  }
  else
  {
    Motion_Sensor_CompObj[0] = &LSM6DSL_Obj;
    Motion_Sensor_Drv[0]     = (MOTION_SENSOR_CommonDrv_t *) &LSM6DSL_COMMON_Driver;
 800c770:	4b2f      	ldr	r3, [pc, #188]	; (800c830 <BSP_MOTION_SENSOR_Init+0x114>)
    Motion_Sensor_CompObj[0] = &LSM6DSL_Obj;
 800c772:	6324      	str	r4, [r4, #48]	; 0x30
    if (Motion_Sensor_Drv[0]->Init(Motion_Sensor_CompObj[0]) < 0)
 800c774:	681a      	ldr	r2, [r3, #0]
    Motion_Sensor_Drv[0]     = (MOTION_SENSOR_CommonDrv_t *) &LSM6DSL_COMMON_Driver;
 800c776:	63a3      	str	r3, [r4, #56]	; 0x38
    if (Motion_Sensor_Drv[0]->Init(Motion_Sensor_CompObj[0]) < 0)
 800c778:	4620      	mov	r0, r4
 800c77a:	4790      	blx	r2
 800c77c:	2800      	cmp	r0, #0
 800c77e:	db41      	blt.n	800c804 <BSP_MOTION_SENSOR_Init+0xe8>
    {
      status = BSP_ERROR_COMPONENT_FAILURE;
    }
    else
    {
      if ((Functions & MOTION_GYRO) != 0U)
 800c780:	07f9      	lsls	r1, r7, #31
      {
        Motion_Sensor_FuncDrv[0][GyroIdx] = (MOTION_SENSOR_FuncDrv_t *) &LSM6DSL_GYRO_Driver;
 800c782:	bf44      	itt	mi
 800c784:	4b2b      	ldrmi	r3, [pc, #172]	; (800c834 <BSP_MOTION_SENSOR_Init+0x118>)
 800c786:	6423      	strmi	r3, [r4, #64]	; 0x40
      }
      if ((Functions & MOTION_ACCELERO) != 0U)
 800c788:	07ba      	lsls	r2, r7, #30
 800c78a:	d501      	bpl.n	800c790 <BSP_MOTION_SENSOR_Init+0x74>
      {
        Motion_Sensor_FuncDrv[0][AcceleroIdx] = (MOTION_SENSOR_FuncDrv_t *) &LSM6DSL_ACC_Driver;
 800c78c:	4b2a      	ldr	r3, [pc, #168]	; (800c838 <BSP_MOTION_SENSOR_Init+0x11c>)
 800c78e:	6463      	str	r3, [r4, #68]	; 0x44
      Motion_Sensor_Ctx[Instance].Functions |= Functions;
 800c790:	eb04 0485 	add.w	r4, r4, r5, lsl #2
 800c794:	2000      	movs	r0, #0
 800c796:	f8d4 3084 	ldr.w	r3, [r4, #132]	; 0x84
 800c79a:	433b      	orrs	r3, r7
 800c79c:	f8c4 3084 	str.w	r3, [r4, #132]	; 0x84
}
 800c7a0:	b009      	add	sp, #36	; 0x24
 800c7a2:	bdf0      	pop	{r4, r5, r6, r7, pc}
  else if ((Instance == 1U) && ((Functions & (MOTION_GYRO | MOTION_ACCELERO)) != 0U))
 800c7a4:	f011 0103 	ands.w	r1, r1, #3
 800c7a8:	d133      	bne.n	800c812 <BSP_MOTION_SENSOR_Init+0xf6>
  static LIS3MDL_Object_t LIS3MDL_Obj;

  /* Configure the motion sensor driver */
  IOCtx.BusType     = LIS3MDL_I2C_BUS;
  IOCtx.Address     = LIS3MDL_I2C_ADD_H;
  IOCtx.Init        = BSP_I2C2_Init;
 800c7aa:	4b1b      	ldr	r3, [pc, #108]	; (800c818 <BSP_MOTION_SENSOR_Init+0xfc>)
  IOCtx.DeInit      = BSP_I2C2_DeInit;
  IOCtx.ReadReg     = BSP_I2C2_ReadReg;
  IOCtx.WriteReg    = BSP_I2C2_WriteReg;
  IOCtx.GetTick     = BSP_GetTick;

  if (LIS3MDL_RegisterBusIO(&LIS3MDL_Obj, &IOCtx) != LIS3MDL_OK)
 800c7ac:	4c1b      	ldr	r4, [pc, #108]	; (800c81c <BSP_MOTION_SENSOR_Init+0x100>)
  IOCtx.Init        = BSP_I2C2_Init;
 800c7ae:	9301      	str	r3, [sp, #4]
  IOCtx.DeInit      = BSP_I2C2_DeInit;
 800c7b0:	4b1b      	ldr	r3, [pc, #108]	; (800c820 <BSP_MOTION_SENSOR_Init+0x104>)
 800c7b2:	9302      	str	r3, [sp, #8]
  IOCtx.ReadReg     = BSP_I2C2_ReadReg;
 800c7b4:	4b1b      	ldr	r3, [pc, #108]	; (800c824 <BSP_MOTION_SENSOR_Init+0x108>)
 800c7b6:	9306      	str	r3, [sp, #24]
  if (LIS3MDL_RegisterBusIO(&LIS3MDL_Obj, &IOCtx) != LIS3MDL_OK)
 800c7b8:	f104 0658 	add.w	r6, r4, #88	; 0x58
  IOCtx.WriteReg    = BSP_I2C2_WriteReg;
 800c7bc:	4b1a      	ldr	r3, [pc, #104]	; (800c828 <BSP_MOTION_SENSOR_Init+0x10c>)
  IOCtx.BusType     = LIS3MDL_I2C_BUS;
 800c7be:	9103      	str	r1, [sp, #12]
  IOCtx.Address     = LIS3MDL_I2C_ADD_H;
 800c7c0:	223d      	movs	r2, #61	; 0x3d
  IOCtx.WriteReg    = BSP_I2C2_WriteReg;
 800c7c2:	9305      	str	r3, [sp, #20]
  if (LIS3MDL_RegisterBusIO(&LIS3MDL_Obj, &IOCtx) != LIS3MDL_OK)
 800c7c4:	a901      	add	r1, sp, #4
  IOCtx.GetTick     = BSP_GetTick;
 800c7c6:	4b19      	ldr	r3, [pc, #100]	; (800c82c <BSP_MOTION_SENSOR_Init+0x110>)
  IOCtx.Address     = LIS3MDL_I2C_ADD_H;
 800c7c8:	f88d 2010 	strb.w	r2, [sp, #16]
  if (LIS3MDL_RegisterBusIO(&LIS3MDL_Obj, &IOCtx) != LIS3MDL_OK)
 800c7cc:	4630      	mov	r0, r6
  IOCtx.GetTick     = BSP_GetTick;
 800c7ce:	9307      	str	r3, [sp, #28]
  if (LIS3MDL_RegisterBusIO(&LIS3MDL_Obj, &IOCtx) != LIS3MDL_OK)
 800c7d0:	f001 f990 	bl	800daf4 <LIS3MDL_RegisterBusIO>
 800c7d4:	b9b0      	cbnz	r0, 800c804 <BSP_MOTION_SENSOR_Init+0xe8>
  {
    status = BSP_ERROR_BUS_FAILURE;
  }
  else if (LIS3MDL_ReadID(&LIS3MDL_Obj, &lis3mdl_id) != LIS3MDL_OK)
 800c7d6:	f10d 0103 	add.w	r1, sp, #3
 800c7da:	4630      	mov	r0, r6
 800c7dc:	f000 ff8e 	bl	800d6fc <LIS3MDL_ReadID>
 800c7e0:	b980      	cbnz	r0, 800c804 <BSP_MOTION_SENSOR_Init+0xe8>
  {
    status = BSP_ERROR_COMPONENT_FAILURE;
  }
  else if (lis3mdl_id != LIS3MDL_ID)
 800c7e2:	f89d 3003 	ldrb.w	r3, [sp, #3]
 800c7e6:	2b3d      	cmp	r3, #61	; 0x3d
 800c7e8:	d10c      	bne.n	800c804 <BSP_MOTION_SENSOR_Init+0xe8>
    status = BSP_ERROR_UNKNOWN_COMPONENT;
  }
  else
  {
    Motion_Sensor_CompObj[1] = &LIS3MDL_Obj;
    Motion_Sensor_Drv[1]     = (MOTION_SENSOR_CommonDrv_t *) &LIS3MDL_COMMON_Driver;
 800c7ea:	4b14      	ldr	r3, [pc, #80]	; (800c83c <BSP_MOTION_SENSOR_Init+0x120>)
 800c7ec:	63e3      	str	r3, [r4, #60]	; 0x3c
    Motion_Sensor_CompObj[1] = &LIS3MDL_Obj;
 800c7ee:	6366      	str	r6, [r4, #52]	; 0x34
    if (Motion_Sensor_Drv[1]->Init(Motion_Sensor_CompObj[1]) < 0)
 800c7f0:	681b      	ldr	r3, [r3, #0]
 800c7f2:	4630      	mov	r0, r6
 800c7f4:	4798      	blx	r3
 800c7f6:	2800      	cmp	r0, #0
 800c7f8:	db04      	blt.n	800c804 <BSP_MOTION_SENSOR_Init+0xe8>
    {
      status = BSP_ERROR_COMPONENT_FAILURE;
    }
    else
    {
      if ((Functions & MOTION_MAGNETO) != 0U)
 800c7fa:	077b      	lsls	r3, r7, #29
 800c7fc:	d5c8      	bpl.n	800c790 <BSP_MOTION_SENSOR_Init+0x74>
      {
        Motion_Sensor_FuncDrv[1][MagnetoIdx] = (MOTION_SENSOR_FuncDrv_t *) &LIS3MDL_MAG_Driver;
 800c7fe:	4b10      	ldr	r3, [pc, #64]	; (800c840 <BSP_MOTION_SENSOR_Init+0x124>)
 800c800:	6563      	str	r3, [r4, #84]	; 0x54
      }
    }
  }

  return status;
 800c802:	e7c5      	b.n	800c790 <BSP_MOTION_SENSOR_Init+0x74>
        status = BSP_ERROR_COMPONENT_FAILURE;
 800c804:	f06f 0004 	mvn.w	r0, #4
}
 800c808:	b009      	add	sp, #36	; 0x24
 800c80a:	bdf0      	pop	{r4, r5, r6, r7, pc}
    status = BSP_ERROR_WRONG_PARAM;
 800c80c:	f06f 0001 	mvn.w	r0, #1
}
 800c810:	4770      	bx	lr
    status = BSP_ERROR_FEATURE_NOT_SUPPORTED;
 800c812:	f06f 000a 	mvn.w	r0, #10
  return status;
 800c816:	e7c3      	b.n	800c7a0 <BSP_MOTION_SENSOR_Init+0x84>
 800c818:	0800c1d9 	.word	0x0800c1d9
 800c81c:	20003210 	.word	0x20003210
 800c820:	0800c08d 	.word	0x0800c08d
 800c824:	0800c139 	.word	0x0800c139
 800c828:	0800c0d9 	.word	0x0800c0d9
 800c82c:	0800c4a9 	.word	0x0800c4a9
 800c830:	2000010c 	.word	0x2000010c
 800c834:	200000c4 	.word	0x200000c4
 800c838:	200000e8 	.word	0x200000e8
 800c83c:	2000007c 	.word	0x2000007c
 800c840:	20000058 	.word	0x20000058

0800c844 <BSP_MOTION_SENSOR_Enable>:
  if (Instance >= MOTION_SENSOR_INSTANCES_NBR)
 800c844:	2801      	cmp	r0, #1
 800c846:	d829      	bhi.n	800c89c <BSP_MOTION_SENSOR_Enable+0x58>
  else if ((Instance == 0U) && ((Function & MOTION_MAGNETO) != 0U))
 800c848:	bb08      	cbnz	r0, 800c88e <BSP_MOTION_SENSOR_Enable+0x4a>
 800c84a:	074a      	lsls	r2, r1, #29
 800c84c:	d421      	bmi.n	800c892 <BSP_MOTION_SENSOR_Enable+0x4e>
{
 800c84e:	b508      	push	{r3, lr}
  else if ((Motion_Sensor_Ctx[Instance].Functions & Function) == 0U)
 800c850:	4b15      	ldr	r3, [pc, #84]	; (800c8a8 <BSP_MOTION_SENSOR_Enable+0x64>)
 800c852:	eb03 0280 	add.w	r2, r3, r0, lsl #2
 800c856:	ea4f 0c80 	mov.w	ip, r0, lsl #2
 800c85a:	f8d2 2084 	ldr.w	r2, [r2, #132]	; 0x84
 800c85e:	4211      	tst	r1, r2
 800c860:	d01f      	beq.n	800c8a2 <BSP_MOTION_SENSOR_Enable+0x5e>
    index = (Function == MOTION_GYRO) ? GyroIdx : ((Function == MOTION_ACCELERO) ? AcceleroIdx : MagnetoIdx);
 800c862:	2901      	cmp	r1, #1
 800c864:	d018      	beq.n	800c898 <BSP_MOTION_SENSOR_Enable+0x54>
 800c866:	2902      	cmp	r1, #2
 800c868:	bf0c      	ite	eq
 800c86a:	2201      	moveq	r2, #1
 800c86c:	2202      	movne	r2, #2
    if(Motion_Sensor_FuncDrv[Instance][index]->Enable(Motion_Sensor_CompObj[Instance]) < 0)
 800c86e:	eb00 0040 	add.w	r0, r0, r0, lsl #1
 800c872:	4410      	add	r0, r2
 800c874:	eb03 0080 	add.w	r0, r3, r0, lsl #2
 800c878:	4463      	add	r3, ip
 800c87a:	6c02      	ldr	r2, [r0, #64]	; 0x40
 800c87c:	6b18      	ldr	r0, [r3, #48]	; 0x30
 800c87e:	6813      	ldr	r3, [r2, #0]
 800c880:	4798      	blx	r3
      status = BSP_ERROR_COMPONENT_FAILURE;
 800c882:	2800      	cmp	r0, #0
 800c884:	bfac      	ite	ge
 800c886:	2000      	movge	r0, #0
 800c888:	f06f 0004 	mvnlt.w	r0, #4
}
 800c88c:	bd08      	pop	{r3, pc}
  else if ((Instance == 1U) && ((Function & (MOTION_GYRO | MOTION_ACCELERO)) != 0U))
 800c88e:	078a      	lsls	r2, r1, #30
 800c890:	d0dd      	beq.n	800c84e <BSP_MOTION_SENSOR_Enable+0xa>
    status = BSP_ERROR_FEATURE_NOT_SUPPORTED;
 800c892:	f06f 000a 	mvn.w	r0, #10
}
 800c896:	4770      	bx	lr
 800c898:	2200      	movs	r2, #0
 800c89a:	e7e8      	b.n	800c86e <BSP_MOTION_SENSOR_Enable+0x2a>
    status = BSP_ERROR_WRONG_PARAM;
 800c89c:	f06f 0001 	mvn.w	r0, #1
 800c8a0:	4770      	bx	lr
    status = BSP_ERROR_NO_INIT;
 800c8a2:	f04f 30ff 	mov.w	r0, #4294967295
}
 800c8a6:	bd08      	pop	{r3, pc}
 800c8a8:	20003210 	.word	0x20003210

0800c8ac <BSP_MOTION_SENSOR_Disable>:
  if (Instance >= MOTION_SENSOR_INSTANCES_NBR)
 800c8ac:	2801      	cmp	r0, #1
 800c8ae:	d829      	bhi.n	800c904 <BSP_MOTION_SENSOR_Disable+0x58>
  else if ((Instance == 0U) && ((Function & MOTION_MAGNETO) != 0U))
 800c8b0:	bb08      	cbnz	r0, 800c8f6 <BSP_MOTION_SENSOR_Disable+0x4a>
 800c8b2:	074a      	lsls	r2, r1, #29
 800c8b4:	d421      	bmi.n	800c8fa <BSP_MOTION_SENSOR_Disable+0x4e>
{
 800c8b6:	b508      	push	{r3, lr}
  else if ((Motion_Sensor_Ctx[Instance].Functions & Function) == 0U)
 800c8b8:	4b15      	ldr	r3, [pc, #84]	; (800c910 <BSP_MOTION_SENSOR_Disable+0x64>)
 800c8ba:	eb03 0280 	add.w	r2, r3, r0, lsl #2
 800c8be:	ea4f 0c80 	mov.w	ip, r0, lsl #2
 800c8c2:	f8d2 2084 	ldr.w	r2, [r2, #132]	; 0x84
 800c8c6:	4211      	tst	r1, r2
 800c8c8:	d01f      	beq.n	800c90a <BSP_MOTION_SENSOR_Disable+0x5e>
    index = (Function == MOTION_GYRO) ? GyroIdx : ((Function == MOTION_ACCELERO) ? AcceleroIdx : MagnetoIdx);
 800c8ca:	2901      	cmp	r1, #1
 800c8cc:	d018      	beq.n	800c900 <BSP_MOTION_SENSOR_Disable+0x54>
 800c8ce:	2902      	cmp	r1, #2
 800c8d0:	bf0c      	ite	eq
 800c8d2:	2201      	moveq	r2, #1
 800c8d4:	2202      	movne	r2, #2
    if (Motion_Sensor_FuncDrv[Instance][index]->Disable(Motion_Sensor_CompObj[Instance]) < 0)
 800c8d6:	eb00 0040 	add.w	r0, r0, r0, lsl #1
 800c8da:	4410      	add	r0, r2
 800c8dc:	eb03 0080 	add.w	r0, r3, r0, lsl #2
 800c8e0:	4463      	add	r3, ip
 800c8e2:	6c02      	ldr	r2, [r0, #64]	; 0x40
 800c8e4:	6b18      	ldr	r0, [r3, #48]	; 0x30
 800c8e6:	6853      	ldr	r3, [r2, #4]
 800c8e8:	4798      	blx	r3
      status = BSP_ERROR_COMPONENT_FAILURE;
 800c8ea:	2800      	cmp	r0, #0
 800c8ec:	bfac      	ite	ge
 800c8ee:	2000      	movge	r0, #0
 800c8f0:	f06f 0004 	mvnlt.w	r0, #4
}
 800c8f4:	bd08      	pop	{r3, pc}
  else if ((Instance == 1U) && ((Function & (MOTION_GYRO | MOTION_ACCELERO)) != 0U))
 800c8f6:	078a      	lsls	r2, r1, #30
 800c8f8:	d0dd      	beq.n	800c8b6 <BSP_MOTION_SENSOR_Disable+0xa>
    status = BSP_ERROR_FEATURE_NOT_SUPPORTED;
 800c8fa:	f06f 000a 	mvn.w	r0, #10
}
 800c8fe:	4770      	bx	lr
 800c900:	2200      	movs	r2, #0
 800c902:	e7e8      	b.n	800c8d6 <BSP_MOTION_SENSOR_Disable+0x2a>
    status = BSP_ERROR_WRONG_PARAM;
 800c904:	f06f 0001 	mvn.w	r0, #1
 800c908:	4770      	bx	lr
    status = BSP_ERROR_NO_INIT;
 800c90a:	f04f 30ff 	mov.w	r0, #4294967295
}
 800c90e:	bd08      	pop	{r3, pc}
 800c910:	20003210 	.word	0x20003210

0800c914 <BSP_MOTION_SENSOR_GetAxes>:
  if ((Instance >= MOTION_SENSOR_INSTANCES_NBR) || (Axes == NULL))
 800c914:	2801      	cmp	r0, #1
 800c916:	d82b      	bhi.n	800c970 <BSP_MOTION_SENSOR_GetAxes+0x5c>
 800c918:	b352      	cbz	r2, 800c970 <BSP_MOTION_SENSOR_GetAxes+0x5c>
  else if ((Instance == 0U) && ((Function & MOTION_MAGNETO) != 0U))
 800c91a:	bb10      	cbnz	r0, 800c962 <BSP_MOTION_SENSOR_GetAxes+0x4e>
 800c91c:	074b      	lsls	r3, r1, #29
 800c91e:	d422      	bmi.n	800c966 <BSP_MOTION_SENSOR_GetAxes+0x52>
  else if ((Motion_Sensor_Ctx[Instance].Functions & Function) == 0U)
 800c920:	4b16      	ldr	r3, [pc, #88]	; (800c97c <BSP_MOTION_SENSOR_GetAxes+0x68>)
{
 800c922:	b510      	push	{r4, lr}
  else if ((Motion_Sensor_Ctx[Instance].Functions & Function) == 0U)
 800c924:	eb03 0480 	add.w	r4, r3, r0, lsl #2
 800c928:	ea4f 0c80 	mov.w	ip, r0, lsl #2
 800c92c:	f8d4 4084 	ldr.w	r4, [r4, #132]	; 0x84
 800c930:	4221      	tst	r1, r4
 800c932:	d020      	beq.n	800c976 <BSP_MOTION_SENSOR_GetAxes+0x62>
    index = (Function == MOTION_GYRO) ? GyroIdx : ((Function == MOTION_ACCELERO) ? AcceleroIdx : MagnetoIdx);
 800c934:	2901      	cmp	r1, #1
 800c936:	d019      	beq.n	800c96c <BSP_MOTION_SENSOR_GetAxes+0x58>
 800c938:	2902      	cmp	r1, #2
 800c93a:	bf0c      	ite	eq
 800c93c:	2101      	moveq	r1, #1
 800c93e:	2102      	movne	r1, #2
    if (Motion_Sensor_FuncDrv[Instance][index]->GetAxes(Motion_Sensor_CompObj[Instance], Axes) < 0)
 800c940:	eb00 0040 	add.w	r0, r0, r0, lsl #1
 800c944:	4408      	add	r0, r1
 800c946:	eb03 0080 	add.w	r0, r3, r0, lsl #2
 800c94a:	4463      	add	r3, ip
 800c94c:	6c01      	ldr	r1, [r0, #64]	; 0x40
 800c94e:	6b18      	ldr	r0, [r3, #48]	; 0x30
 800c950:	69cb      	ldr	r3, [r1, #28]
 800c952:	4611      	mov	r1, r2
 800c954:	4798      	blx	r3
      status = BSP_ERROR_COMPONENT_FAILURE;
 800c956:	2800      	cmp	r0, #0
 800c958:	bfac      	ite	ge
 800c95a:	2000      	movge	r0, #0
 800c95c:	f06f 0004 	mvnlt.w	r0, #4
}
 800c960:	bd10      	pop	{r4, pc}
  else if ((Instance == 1U) && ((Function & (MOTION_GYRO | MOTION_ACCELERO)) != 0U))
 800c962:	078b      	lsls	r3, r1, #30
 800c964:	d0dc      	beq.n	800c920 <BSP_MOTION_SENSOR_GetAxes+0xc>
    status = BSP_ERROR_FEATURE_NOT_SUPPORTED;
 800c966:	f06f 000a 	mvn.w	r0, #10
}
 800c96a:	4770      	bx	lr
 800c96c:	2100      	movs	r1, #0
 800c96e:	e7e7      	b.n	800c940 <BSP_MOTION_SENSOR_GetAxes+0x2c>
    status = BSP_ERROR_WRONG_PARAM;
 800c970:	f06f 0001 	mvn.w	r0, #1
 800c974:	4770      	bx	lr
    status = BSP_ERROR_NO_INIT;
 800c976:	f04f 30ff 	mov.w	r0, #4294967295
}
 800c97a:	bd10      	pop	{r4, pc}
 800c97c:	20003210 	.word	0x20003210

0800c980 <BSP_MOTION_SENSOR_GetAxesRaw>:
  if ((Instance >= MOTION_SENSOR_INSTANCES_NBR) || (Axes == NULL))
 800c980:	2801      	cmp	r0, #1
 800c982:	d82b      	bhi.n	800c9dc <BSP_MOTION_SENSOR_GetAxesRaw+0x5c>
 800c984:	b352      	cbz	r2, 800c9dc <BSP_MOTION_SENSOR_GetAxesRaw+0x5c>
  else if ((Instance == 0U) && ((Function & MOTION_MAGNETO) != 0U))
 800c986:	bb10      	cbnz	r0, 800c9ce <BSP_MOTION_SENSOR_GetAxesRaw+0x4e>
 800c988:	074b      	lsls	r3, r1, #29
 800c98a:	d422      	bmi.n	800c9d2 <BSP_MOTION_SENSOR_GetAxesRaw+0x52>
  else if ((Motion_Sensor_Ctx[Instance].Functions & Function) == 0U)
 800c98c:	4b16      	ldr	r3, [pc, #88]	; (800c9e8 <BSP_MOTION_SENSOR_GetAxesRaw+0x68>)
{
 800c98e:	b510      	push	{r4, lr}
  else if ((Motion_Sensor_Ctx[Instance].Functions & Function) == 0U)
 800c990:	eb03 0480 	add.w	r4, r3, r0, lsl #2
 800c994:	ea4f 0c80 	mov.w	ip, r0, lsl #2
 800c998:	f8d4 4084 	ldr.w	r4, [r4, #132]	; 0x84
 800c99c:	4221      	tst	r1, r4
 800c99e:	d020      	beq.n	800c9e2 <BSP_MOTION_SENSOR_GetAxesRaw+0x62>
    index = (Function == MOTION_GYRO) ? GyroIdx : ((Function == MOTION_ACCELERO) ? AcceleroIdx : MagnetoIdx);
 800c9a0:	2901      	cmp	r1, #1
 800c9a2:	d019      	beq.n	800c9d8 <BSP_MOTION_SENSOR_GetAxesRaw+0x58>
 800c9a4:	2902      	cmp	r1, #2
 800c9a6:	bf0c      	ite	eq
 800c9a8:	2101      	moveq	r1, #1
 800c9aa:	2102      	movne	r1, #2
    if (Motion_Sensor_FuncDrv[Instance][index]->GetAxesRaw(Motion_Sensor_CompObj[Instance], Axes) < 0)
 800c9ac:	eb00 0040 	add.w	r0, r0, r0, lsl #1
 800c9b0:	4408      	add	r0, r1
 800c9b2:	eb03 0080 	add.w	r0, r3, r0, lsl #2
 800c9b6:	4463      	add	r3, ip
 800c9b8:	6c01      	ldr	r1, [r0, #64]	; 0x40
 800c9ba:	6b18      	ldr	r0, [r3, #48]	; 0x30
 800c9bc:	6a0b      	ldr	r3, [r1, #32]
 800c9be:	4611      	mov	r1, r2
 800c9c0:	4798      	blx	r3
      status = BSP_ERROR_COMPONENT_FAILURE;
 800c9c2:	2800      	cmp	r0, #0
 800c9c4:	bfac      	ite	ge
 800c9c6:	2000      	movge	r0, #0
 800c9c8:	f06f 0004 	mvnlt.w	r0, #4
}
 800c9cc:	bd10      	pop	{r4, pc}
  else if ((Instance == 1U) && ((Function & (MOTION_GYRO | MOTION_ACCELERO)) != 0U))
 800c9ce:	078b      	lsls	r3, r1, #30
 800c9d0:	d0dc      	beq.n	800c98c <BSP_MOTION_SENSOR_GetAxesRaw+0xc>
    status = BSP_ERROR_FEATURE_NOT_SUPPORTED;
 800c9d2:	f06f 000a 	mvn.w	r0, #10
}
 800c9d6:	4770      	bx	lr
 800c9d8:	2100      	movs	r1, #0
 800c9da:	e7e7      	b.n	800c9ac <BSP_MOTION_SENSOR_GetAxesRaw+0x2c>
    status = BSP_ERROR_WRONG_PARAM;
 800c9dc:	f06f 0001 	mvn.w	r0, #1
 800c9e0:	4770      	bx	lr
    status = BSP_ERROR_NO_INIT;
 800c9e2:	f04f 30ff 	mov.w	r0, #4294967295
}
 800c9e6:	bd10      	pop	{r4, pc}
 800c9e8:	20003210 	.word	0x20003210

0800c9ec <BSP_MOTION_SENSOR_GetSensitivity>:
  if ((Instance >= MOTION_SENSOR_INSTANCES_NBR) || (Sensitivity == NULL))
 800c9ec:	2801      	cmp	r0, #1
 800c9ee:	d82b      	bhi.n	800ca48 <BSP_MOTION_SENSOR_GetSensitivity+0x5c>
 800c9f0:	b352      	cbz	r2, 800ca48 <BSP_MOTION_SENSOR_GetSensitivity+0x5c>
  else if ((Instance == 0U) && ((Function & MOTION_MAGNETO) != 0U))
 800c9f2:	bb10      	cbnz	r0, 800ca3a <BSP_MOTION_SENSOR_GetSensitivity+0x4e>
 800c9f4:	074b      	lsls	r3, r1, #29
 800c9f6:	d422      	bmi.n	800ca3e <BSP_MOTION_SENSOR_GetSensitivity+0x52>
  else if ((Motion_Sensor_Ctx[Instance].Functions & Function) == 0U)
 800c9f8:	4b16      	ldr	r3, [pc, #88]	; (800ca54 <BSP_MOTION_SENSOR_GetSensitivity+0x68>)
{
 800c9fa:	b510      	push	{r4, lr}
  else if ((Motion_Sensor_Ctx[Instance].Functions & Function) == 0U)
 800c9fc:	eb03 0480 	add.w	r4, r3, r0, lsl #2
 800ca00:	ea4f 0c80 	mov.w	ip, r0, lsl #2
 800ca04:	f8d4 4084 	ldr.w	r4, [r4, #132]	; 0x84
 800ca08:	4221      	tst	r1, r4
 800ca0a:	d020      	beq.n	800ca4e <BSP_MOTION_SENSOR_GetSensitivity+0x62>
    index = (Function == MOTION_GYRO) ? GyroIdx : ((Function == MOTION_ACCELERO) ? AcceleroIdx : MagnetoIdx);
 800ca0c:	2901      	cmp	r1, #1
 800ca0e:	d019      	beq.n	800ca44 <BSP_MOTION_SENSOR_GetSensitivity+0x58>
 800ca10:	2902      	cmp	r1, #2
 800ca12:	bf0c      	ite	eq
 800ca14:	2101      	moveq	r1, #1
 800ca16:	2102      	movne	r1, #2
    if (Motion_Sensor_FuncDrv[Instance][index]->GetSensitivity(Motion_Sensor_CompObj[Instance], Sensitivity) < 0)
 800ca18:	eb00 0040 	add.w	r0, r0, r0, lsl #1
 800ca1c:	4408      	add	r0, r1
 800ca1e:	eb03 0080 	add.w	r0, r3, r0, lsl #2
 800ca22:	4463      	add	r3, ip
 800ca24:	6c01      	ldr	r1, [r0, #64]	; 0x40
 800ca26:	6b18      	ldr	r0, [r3, #48]	; 0x30
 800ca28:	688b      	ldr	r3, [r1, #8]
 800ca2a:	4611      	mov	r1, r2
 800ca2c:	4798      	blx	r3
      status = BSP_ERROR_COMPONENT_FAILURE;
 800ca2e:	2800      	cmp	r0, #0
 800ca30:	bfac      	ite	ge
 800ca32:	2000      	movge	r0, #0
 800ca34:	f06f 0004 	mvnlt.w	r0, #4
}
 800ca38:	bd10      	pop	{r4, pc}
  else if ((Instance == 1U) && ((Function & (MOTION_GYRO | MOTION_ACCELERO)) != 0U))
 800ca3a:	078b      	lsls	r3, r1, #30
 800ca3c:	d0dc      	beq.n	800c9f8 <BSP_MOTION_SENSOR_GetSensitivity+0xc>
    status = BSP_ERROR_FEATURE_NOT_SUPPORTED;
 800ca3e:	f06f 000a 	mvn.w	r0, #10
}
 800ca42:	4770      	bx	lr
 800ca44:	2100      	movs	r1, #0
 800ca46:	e7e7      	b.n	800ca18 <BSP_MOTION_SENSOR_GetSensitivity+0x2c>
    status = BSP_ERROR_WRONG_PARAM;
 800ca48:	f06f 0001 	mvn.w	r0, #1
 800ca4c:	4770      	bx	lr
    status = BSP_ERROR_NO_INIT;
 800ca4e:	f04f 30ff 	mov.w	r0, #4294967295
}
 800ca52:	bd10      	pop	{r4, pc}
 800ca54:	20003210 	.word	0x20003210

0800ca58 <BSP_MOTION_SENSOR_GetOutputDataRate>:
  if ((Instance >= MOTION_SENSOR_INSTANCES_NBR) || (Odr == NULL))
 800ca58:	2801      	cmp	r0, #1
 800ca5a:	d82b      	bhi.n	800cab4 <BSP_MOTION_SENSOR_GetOutputDataRate+0x5c>
 800ca5c:	b352      	cbz	r2, 800cab4 <BSP_MOTION_SENSOR_GetOutputDataRate+0x5c>
  else if ((Instance == 0U) && ((Function & MOTION_MAGNETO) != 0U))
 800ca5e:	bb10      	cbnz	r0, 800caa6 <BSP_MOTION_SENSOR_GetOutputDataRate+0x4e>
 800ca60:	074b      	lsls	r3, r1, #29
 800ca62:	d422      	bmi.n	800caaa <BSP_MOTION_SENSOR_GetOutputDataRate+0x52>
  else if ((Motion_Sensor_Ctx[Instance].Functions & Function) == 0U)
 800ca64:	4b16      	ldr	r3, [pc, #88]	; (800cac0 <BSP_MOTION_SENSOR_GetOutputDataRate+0x68>)
{
 800ca66:	b510      	push	{r4, lr}
  else if ((Motion_Sensor_Ctx[Instance].Functions & Function) == 0U)
 800ca68:	eb03 0480 	add.w	r4, r3, r0, lsl #2
 800ca6c:	ea4f 0c80 	mov.w	ip, r0, lsl #2
 800ca70:	f8d4 4084 	ldr.w	r4, [r4, #132]	; 0x84
 800ca74:	4221      	tst	r1, r4
 800ca76:	d020      	beq.n	800caba <BSP_MOTION_SENSOR_GetOutputDataRate+0x62>
    index = (Function == MOTION_GYRO) ? GyroIdx : ((Function == MOTION_ACCELERO) ? AcceleroIdx : MagnetoIdx);
 800ca78:	2901      	cmp	r1, #1
 800ca7a:	d019      	beq.n	800cab0 <BSP_MOTION_SENSOR_GetOutputDataRate+0x58>
 800ca7c:	2902      	cmp	r1, #2
 800ca7e:	bf0c      	ite	eq
 800ca80:	2101      	moveq	r1, #1
 800ca82:	2102      	movne	r1, #2
    if (Motion_Sensor_FuncDrv[Instance][index]->GetOutputDataRate(Motion_Sensor_CompObj[Instance], Odr) < 0)
 800ca84:	eb00 0040 	add.w	r0, r0, r0, lsl #1
 800ca88:	4408      	add	r0, r1
 800ca8a:	eb03 0080 	add.w	r0, r3, r0, lsl #2
 800ca8e:	4463      	add	r3, ip
 800ca90:	6c01      	ldr	r1, [r0, #64]	; 0x40
 800ca92:	6b18      	ldr	r0, [r3, #48]	; 0x30
 800ca94:	68cb      	ldr	r3, [r1, #12]
 800ca96:	4611      	mov	r1, r2
 800ca98:	4798      	blx	r3
      status = BSP_ERROR_COMPONENT_FAILURE;
 800ca9a:	2800      	cmp	r0, #0
 800ca9c:	bfac      	ite	ge
 800ca9e:	2000      	movge	r0, #0
 800caa0:	f06f 0004 	mvnlt.w	r0, #4
}
 800caa4:	bd10      	pop	{r4, pc}
  else if ((Instance == 1U) && ((Function & (MOTION_GYRO | MOTION_ACCELERO)) != 0U))
 800caa6:	078b      	lsls	r3, r1, #30
 800caa8:	d0dc      	beq.n	800ca64 <BSP_MOTION_SENSOR_GetOutputDataRate+0xc>
    status = BSP_ERROR_FEATURE_NOT_SUPPORTED;
 800caaa:	f06f 000a 	mvn.w	r0, #10
}
 800caae:	4770      	bx	lr
 800cab0:	2100      	movs	r1, #0
 800cab2:	e7e7      	b.n	800ca84 <BSP_MOTION_SENSOR_GetOutputDataRate+0x2c>
    status = BSP_ERROR_WRONG_PARAM;
 800cab4:	f06f 0001 	mvn.w	r0, #1
 800cab8:	4770      	bx	lr
    status = BSP_ERROR_NO_INIT;
 800caba:	f04f 30ff 	mov.w	r0, #4294967295
}
 800cabe:	bd10      	pop	{r4, pc}
 800cac0:	20003210 	.word	0x20003210

0800cac4 <BSP_MOTION_SENSOR_SetOutputDataRate>:
  if (Instance >= MOTION_SENSOR_INSTANCES_NBR)
 800cac4:	2801      	cmp	r0, #1
 800cac6:	d829      	bhi.n	800cb1c <BSP_MOTION_SENSOR_SetOutputDataRate+0x58>
  else if ((Instance == 0U) && ((Function & MOTION_MAGNETO) != 0U))
 800cac8:	bb08      	cbnz	r0, 800cb0e <BSP_MOTION_SENSOR_SetOutputDataRate+0x4a>
 800caca:	074a      	lsls	r2, r1, #29
 800cacc:	d421      	bmi.n	800cb12 <BSP_MOTION_SENSOR_SetOutputDataRate+0x4e>
{
 800cace:	b508      	push	{r3, lr}
  else if ((Motion_Sensor_Ctx[Instance].Functions & Function) == 0U)
 800cad0:	4b15      	ldr	r3, [pc, #84]	; (800cb28 <BSP_MOTION_SENSOR_SetOutputDataRate+0x64>)
 800cad2:	eb03 0280 	add.w	r2, r3, r0, lsl #2
 800cad6:	ea4f 0c80 	mov.w	ip, r0, lsl #2
 800cada:	f8d2 2084 	ldr.w	r2, [r2, #132]	; 0x84
 800cade:	4211      	tst	r1, r2
 800cae0:	d01f      	beq.n	800cb22 <BSP_MOTION_SENSOR_SetOutputDataRate+0x5e>
    index = (Function == MOTION_GYRO) ? GyroIdx : ((Function == MOTION_ACCELERO) ? AcceleroIdx : MagnetoIdx);
 800cae2:	2901      	cmp	r1, #1
 800cae4:	d018      	beq.n	800cb18 <BSP_MOTION_SENSOR_SetOutputDataRate+0x54>
 800cae6:	2902      	cmp	r1, #2
 800cae8:	bf0c      	ite	eq
 800caea:	2201      	moveq	r2, #1
 800caec:	2202      	movne	r2, #2
    if (Motion_Sensor_FuncDrv[Instance][index]->SetOutputDataRate(Motion_Sensor_CompObj[Instance], Odr) < 0)
 800caee:	eb00 0040 	add.w	r0, r0, r0, lsl #1
 800caf2:	4410      	add	r0, r2
 800caf4:	eb03 0080 	add.w	r0, r3, r0, lsl #2
 800caf8:	4463      	add	r3, ip
 800cafa:	6c02      	ldr	r2, [r0, #64]	; 0x40
 800cafc:	6b18      	ldr	r0, [r3, #48]	; 0x30
 800cafe:	6912      	ldr	r2, [r2, #16]
 800cb00:	4790      	blx	r2
      status = BSP_ERROR_COMPONENT_FAILURE;
 800cb02:	2800      	cmp	r0, #0
 800cb04:	bfac      	ite	ge
 800cb06:	2000      	movge	r0, #0
 800cb08:	f06f 0004 	mvnlt.w	r0, #4
}
 800cb0c:	bd08      	pop	{r3, pc}
  else if ((Instance == 1U) && ((Function & (MOTION_GYRO | MOTION_ACCELERO)) != 0U))
 800cb0e:	078a      	lsls	r2, r1, #30
 800cb10:	d0dd      	beq.n	800cace <BSP_MOTION_SENSOR_SetOutputDataRate+0xa>
    status = BSP_ERROR_FEATURE_NOT_SUPPORTED;
 800cb12:	f06f 000a 	mvn.w	r0, #10
}
 800cb16:	4770      	bx	lr
 800cb18:	2200      	movs	r2, #0
 800cb1a:	e7e8      	b.n	800caee <BSP_MOTION_SENSOR_SetOutputDataRate+0x2a>
    status = BSP_ERROR_WRONG_PARAM;
 800cb1c:	f06f 0001 	mvn.w	r0, #1
 800cb20:	4770      	bx	lr
    status = BSP_ERROR_NO_INIT;
 800cb22:	f04f 30ff 	mov.w	r0, #4294967295
}
 800cb26:	bd08      	pop	{r3, pc}
 800cb28:	20003210 	.word	0x20003210

0800cb2c <BSP_MOTION_SENSOR_SetFullScale>:
  if (Instance >= MOTION_SENSOR_INSTANCES_NBR)
 800cb2c:	2801      	cmp	r0, #1
 800cb2e:	d82a      	bhi.n	800cb86 <BSP_MOTION_SENSOR_SetFullScale+0x5a>
  else if ((Instance == 0U) && ((Function & MOTION_MAGNETO) != 0U))
 800cb30:	bb10      	cbnz	r0, 800cb78 <BSP_MOTION_SENSOR_SetFullScale+0x4c>
 800cb32:	074b      	lsls	r3, r1, #29
 800cb34:	d422      	bmi.n	800cb7c <BSP_MOTION_SENSOR_SetFullScale+0x50>
  else if ((Motion_Sensor_Ctx[Instance].Functions & Function) == 0U)
 800cb36:	4b17      	ldr	r3, [pc, #92]	; (800cb94 <BSP_MOTION_SENSOR_SetFullScale+0x68>)
{
 800cb38:	b510      	push	{r4, lr}
  else if ((Motion_Sensor_Ctx[Instance].Functions & Function) == 0U)
 800cb3a:	eb03 0480 	add.w	r4, r3, r0, lsl #2
 800cb3e:	ea4f 0c80 	mov.w	ip, r0, lsl #2
 800cb42:	f8d4 4084 	ldr.w	r4, [r4, #132]	; 0x84
 800cb46:	4221      	tst	r1, r4
 800cb48:	d020      	beq.n	800cb8c <BSP_MOTION_SENSOR_SetFullScale+0x60>
    index = (Function == MOTION_GYRO) ? GyroIdx : ((Function == MOTION_ACCELERO) ? AcceleroIdx : MagnetoIdx);
 800cb4a:	2901      	cmp	r1, #1
 800cb4c:	d019      	beq.n	800cb82 <BSP_MOTION_SENSOR_SetFullScale+0x56>
 800cb4e:	2902      	cmp	r1, #2
 800cb50:	bf0c      	ite	eq
 800cb52:	2101      	moveq	r1, #1
 800cb54:	2102      	movne	r1, #2
    if (Motion_Sensor_FuncDrv[Instance][index]->SetFullScale(Motion_Sensor_CompObj[Instance], Fullscale) < 0)
 800cb56:	eb00 0040 	add.w	r0, r0, r0, lsl #1
 800cb5a:	4408      	add	r0, r1
 800cb5c:	eb03 0080 	add.w	r0, r3, r0, lsl #2
 800cb60:	4463      	add	r3, ip
 800cb62:	6c01      	ldr	r1, [r0, #64]	; 0x40
 800cb64:	6b18      	ldr	r0, [r3, #48]	; 0x30
 800cb66:	698b      	ldr	r3, [r1, #24]
 800cb68:	4611      	mov	r1, r2
 800cb6a:	4798      	blx	r3
      status = BSP_ERROR_COMPONENT_FAILURE;
 800cb6c:	2800      	cmp	r0, #0
 800cb6e:	bfac      	ite	ge
 800cb70:	2000      	movge	r0, #0
 800cb72:	f06f 0004 	mvnlt.w	r0, #4
}
 800cb76:	bd10      	pop	{r4, pc}
  else if ((Instance == 1U) && ((Function & (MOTION_GYRO | MOTION_ACCELERO)) != 0U))
 800cb78:	078b      	lsls	r3, r1, #30
 800cb7a:	d0dc      	beq.n	800cb36 <BSP_MOTION_SENSOR_SetFullScale+0xa>
    status = BSP_ERROR_FEATURE_NOT_SUPPORTED;
 800cb7c:	f06f 000a 	mvn.w	r0, #10
}
 800cb80:	4770      	bx	lr
 800cb82:	2100      	movs	r1, #0
 800cb84:	e7e7      	b.n	800cb56 <BSP_MOTION_SENSOR_SetFullScale+0x2a>
    status = BSP_ERROR_WRONG_PARAM;
 800cb86:	f06f 0001 	mvn.w	r0, #1
 800cb8a:	4770      	bx	lr
    status = BSP_ERROR_NO_INIT;
 800cb8c:	f04f 30ff 	mov.w	r0, #4294967295
}
 800cb90:	bd10      	pop	{r4, pc}
 800cb92:	bf00      	nop
 800cb94:	20003210 	.word	0x20003210

0800cb98 <MX_QSPI_Init>:
  * @param  hQspi          QSPI handle
  * @param  Init           QSPI config structure
  * @retval BSP status
  */
__weak HAL_StatusTypeDef MX_QSPI_Init(QSPI_HandleTypeDef *hQspi, MX_QSPI_InitTypeDef *Init)
{
 800cb98:	b430      	push	{r4, r5}

  hQspi->Init.FifoThreshold      = 4;
  hQspi->Init.FlashSize          = Init->MemorySize; /* 64 MBits */
  hQspi->Init.ChipSelectHighTime = QSPI_CS_HIGH_TIME_2_CYCLE;
  hQspi->Init.ClockMode          = QSPI_CLOCK_MODE_0;
  hQspi->Init.ClockPrescaler     = Init->ClockPrescaler;
 800cb9a:	e9d1 2400 	ldrd	r2, r4, [r1]
  hQspi->Instance = QUADSPI;
 800cb9e:	4d08      	ldr	r5, [pc, #32]	; (800cbc0 <MX_QSPI_Init+0x28>)
  hQspi->Init.FlashSize          = Init->MemorySize; /* 64 MBits */
 800cba0:	6102      	str	r2, [r0, #16]
  hQspi->Init.SampleShifting     = Init->SampleShifting;
 800cba2:	688a      	ldr	r2, [r1, #8]
  hQspi->Instance = QUADSPI;
 800cba4:	6005      	str	r5, [r0, #0]
  hQspi->Init.ClockMode          = QSPI_CLOCK_MODE_0;
 800cba6:	2100      	movs	r1, #0
 800cba8:	f44f 7580 	mov.w	r5, #256	; 0x100
  hQspi->Init.SampleShifting     = Init->SampleShifting;
 800cbac:	60c2      	str	r2, [r0, #12]
  hQspi->Init.FifoThreshold      = 4;
 800cbae:	2204      	movs	r2, #4
  hQspi->Init.ClockMode          = QSPI_CLOCK_MODE_0;
 800cbb0:	e9c0 5105 	strd	r5, r1, [r0, #20]
  hQspi->Init.ClockPrescaler     = Init->ClockPrescaler;
 800cbb4:	6044      	str	r4, [r0, #4]
  hQspi->Init.FifoThreshold      = 4;
 800cbb6:	6082      	str	r2, [r0, #8]

  return HAL_QSPI_Init(hQspi);
}
 800cbb8:	bc30      	pop	{r4, r5}
  return HAL_QSPI_Init(hQspi);
 800cbba:	f005 ba4f 	b.w	801205c <HAL_QSPI_Init>
 800cbbe:	bf00      	nop
 800cbc0:	a0001000 	.word	0xa0001000

0800cbc4 <BSP_QSPI_Read>:
int32_t BSP_QSPI_Read(uint32_t Instance, uint8_t* pData, uint32_t ReadAddr, uint32_t Size)
{
  int32_t ret;

  /* Check if the instance is supported */
  if(Instance >= QSPI_INSTANCES_NUMBER)
 800cbc4:	b988      	cbnz	r0, 800cbea <BSP_QSPI_Read+0x26>
{
 800cbc6:	b500      	push	{lr}
 800cbc8:	b083      	sub	sp, #12
  {
    ret = BSP_ERROR_WRONG_PARAM;
  }
  else
  {
    if(MX25R6435F_Read(&(hqspi[Instance]), Qspi_Ctx[Instance].InterfaceMode, pData, ReadAddr, Size) != MX25R6435F_OK)
 800cbca:	4809      	ldr	r0, [pc, #36]	; (800cbf0 <BSP_QSPI_Read+0x2c>)
 800cbcc:	9300      	str	r3, [sp, #0]
 800cbce:	468c      	mov	ip, r1
 800cbd0:	4613      	mov	r3, r2
 800cbd2:	7841      	ldrb	r1, [r0, #1]
 800cbd4:	4662      	mov	r2, ip
 800cbd6:	3004      	adds	r0, #4
 800cbd8:	f002 fbae 	bl	800f338 <MX25R6435F_Read>
    {
      ret = BSP_ERROR_COMPONENT_FAILURE;
 800cbdc:	2800      	cmp	r0, #0
 800cbde:	bf18      	it	ne
 800cbe0:	f06f 0004 	mvnne.w	r0, #4
    }
  }

  /* Return BSP status */
  return ret;
}
 800cbe4:	b003      	add	sp, #12
 800cbe6:	f85d fb04 	ldr.w	pc, [sp], #4
    ret = BSP_ERROR_WRONG_PARAM;
 800cbea:	f06f 0001 	mvn.w	r0, #1
}
 800cbee:	4770      	bx	lr
 800cbf0:	2000329c 	.word	0x2000329c

0800cbf4 <BSP_QSPI_Write>:
  int32_t ret = BSP_ERROR_NONE;
  uint32_t end_addr, current_size, current_addr;
  uint32_t data_addr;

  /* Check if the instance is supported */
  if(Instance >= QSPI_INSTANCES_NUMBER)
 800cbf4:	2800      	cmp	r0, #0
 800cbf6:	d13e      	bne.n	800cc76 <BSP_QSPI_Write+0x82>
{
 800cbf8:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    ret = BSP_ERROR_WRONG_PARAM;
  }
  else
  {
    /* Calculation of the size between the write address and the end of the page */
    current_size = MX25R6435F_PAGE_SIZE - (WriteAddr % MX25R6435F_PAGE_SIZE);
 800cbfc:	fa5f f982 	uxtb.w	r9, r2
 800cc00:	f5c9 7980 	rsb	r9, r9, #256	; 0x100
 800cc04:	f8df 8074 	ldr.w	r8, [pc, #116]	; 800cc7c <BSP_QSPI_Write+0x88>
 800cc08:	4599      	cmp	r9, r3
{
 800cc0a:	b083      	sub	sp, #12
 800cc0c:	4615      	mov	r5, r2

    /* Check if the size of the data is less than the remaining place in the page */
    if (current_size > Size)
 800cc0e:	bf28      	it	cs
 800cc10:	4699      	movcs	r9, r3
      current_size = Size;
    }

    /* Initialize the address variables */
    current_addr = WriteAddr;
    end_addr = WriteAddr + Size;
 800cc12:	18d7      	adds	r7, r2, r3
    data_addr = (uint32_t)pData;
 800cc14:	460e      	mov	r6, r1

    /* Perform the write page by page */
    do
    {
      /* Check if Flash busy ? */
      if(MX25R6435F_AutoPollingMemReady(&(hqspi[Instance])) != MX25R6435F_OK)
 800cc16:	f108 0404 	add.w	r4, r8, #4
 800cc1a:	4620      	mov	r0, r4
 800cc1c:	f002 fb64 	bl	800f2e8 <MX25R6435F_AutoPollingMemReady>
 800cc20:	b120      	cbz	r0, 800cc2c <BSP_QSPI_Write+0x38>
      {
        ret = BSP_ERROR_COMPONENT_FAILURE;
 800cc22:	f06f 0004 	mvn.w	r0, #4
    } while ((current_addr < end_addr) && (ret == BSP_ERROR_NONE));
  }

  /* Return BSP status */
  return ret;
}
 800cc26:	b003      	add	sp, #12
 800cc28:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
      else if(MX25R6435F_WriteEnable(&(hqspi[Instance])) != MX25R6435F_OK)
 800cc2c:	4620      	mov	r0, r4
 800cc2e:	f002 fc4d 	bl	800f4cc <MX25R6435F_WriteEnable>
 800cc32:	2800      	cmp	r0, #0
 800cc34:	d1f5      	bne.n	800cc22 <BSP_QSPI_Write+0x2e>
        if(MX25R6435F_PageProgram(&(hqspi[Instance]), Qspi_Ctx[Instance].InterfaceMode, (uint8_t*)data_addr, current_addr, current_size) != MX25R6435F_OK)
 800cc36:	f898 1001 	ldrb.w	r1, [r8, #1]
 800cc3a:	f8cd 9000 	str.w	r9, [sp]
 800cc3e:	462b      	mov	r3, r5
 800cc40:	4632      	mov	r2, r6
 800cc42:	4620      	mov	r0, r4
 800cc44:	f002 fbd4 	bl	800f3f0 <MX25R6435F_PageProgram>
 800cc48:	2800      	cmp	r0, #0
 800cc4a:	d1ea      	bne.n	800cc22 <BSP_QSPI_Write+0x2e>
          if (MX25R6435F_AutoPollingMemReady(&(hqspi[Instance])) != MX25R6435F_OK)
 800cc4c:	4620      	mov	r0, r4
 800cc4e:	f002 fb4b 	bl	800f2e8 <MX25R6435F_AutoPollingMemReady>
            current_addr += current_size;
 800cc52:	444d      	add	r5, r9
            data_addr += current_size;
 800cc54:	444e      	add	r6, r9
            current_size = ((current_addr + MX25R6435F_PAGE_SIZE) > end_addr) ? (end_addr - current_addr) : MX25R6435F_PAGE_SIZE;
 800cc56:	f505 7380 	add.w	r3, r5, #256	; 0x100
          if (MX25R6435F_AutoPollingMemReady(&(hqspi[Instance])) != MX25R6435F_OK)
 800cc5a:	2800      	cmp	r0, #0
 800cc5c:	d1e1      	bne.n	800cc22 <BSP_QSPI_Write+0x2e>
            current_size = ((current_addr + MX25R6435F_PAGE_SIZE) > end_addr) ? (end_addr - current_addr) : MX25R6435F_PAGE_SIZE;
 800cc5e:	42bb      	cmp	r3, r7
 800cc60:	d804      	bhi.n	800cc6c <BSP_QSPI_Write+0x78>
    } while ((current_addr < end_addr) && (ret == BSP_ERROR_NONE));
 800cc62:	42af      	cmp	r7, r5
 800cc64:	d9df      	bls.n	800cc26 <BSP_QSPI_Write+0x32>
            current_size = ((current_addr + MX25R6435F_PAGE_SIZE) > end_addr) ? (end_addr - current_addr) : MX25R6435F_PAGE_SIZE;
 800cc66:	f44f 7980 	mov.w	r9, #256	; 0x100
 800cc6a:	e7d6      	b.n	800cc1a <BSP_QSPI_Write+0x26>
    } while ((current_addr < end_addr) && (ret == BSP_ERROR_NONE));
 800cc6c:	42af      	cmp	r7, r5
            current_size = ((current_addr + MX25R6435F_PAGE_SIZE) > end_addr) ? (end_addr - current_addr) : MX25R6435F_PAGE_SIZE;
 800cc6e:	eba7 0905 	sub.w	r9, r7, r5
    } while ((current_addr < end_addr) && (ret == BSP_ERROR_NONE));
 800cc72:	d8d2      	bhi.n	800cc1a <BSP_QSPI_Write+0x26>
 800cc74:	e7d7      	b.n	800cc26 <BSP_QSPI_Write+0x32>
    ret = BSP_ERROR_WRONG_PARAM;
 800cc76:	f06f 0001 	mvn.w	r0, #1
}
 800cc7a:	4770      	bx	lr
 800cc7c:	2000329c 	.word	0x2000329c

0800cc80 <BSP_QSPI_Erase_Block>:
int32_t BSP_QSPI_Erase_Block(uint32_t Instance, uint32_t BlockAddress, BSP_QSPI_Erase_t BlockSize)
{
  int32_t ret;

  /* Check if the instance is supported */
  if(Instance >= QSPI_INSTANCES_NUMBER)
 800cc80:	b9a0      	cbnz	r0, 800ccac <BSP_QSPI_Erase_Block+0x2c>
{
 800cc82:	b538      	push	{r3, r4, r5, lr}
    ret = BSP_ERROR_WRONG_PARAM;
  }
  else
  {
    /* Check Flash busy ? */
    if(MX25R6435F_AutoPollingMemReady(&(hqspi[Instance])) != MX25R6435F_OK)
 800cc84:	480b      	ldr	r0, [pc, #44]	; (800ccb4 <BSP_QSPI_Erase_Block+0x34>)
 800cc86:	460c      	mov	r4, r1
 800cc88:	4615      	mov	r5, r2
 800cc8a:	f002 fb2d 	bl	800f2e8 <MX25R6435F_AutoPollingMemReady>
 800cc8e:	b950      	cbnz	r0, 800cca6 <BSP_QSPI_Erase_Block+0x26>
    {
      ret = BSP_ERROR_COMPONENT_FAILURE;
    }/* Enable write operations */
    else if(MX25R6435F_WriteEnable(&(hqspi[Instance])) != MX25R6435F_OK)
 800cc90:	4808      	ldr	r0, [pc, #32]	; (800ccb4 <BSP_QSPI_Erase_Block+0x34>)
 800cc92:	f002 fc1b 	bl	800f4cc <MX25R6435F_WriteEnable>
 800cc96:	b930      	cbnz	r0, 800cca6 <BSP_QSPI_Erase_Block+0x26>
    {
      ret = BSP_ERROR_COMPONENT_FAILURE;
    }/* Issue Block Erase command */
    else if(MX25R6435F_BlockErase(&(hqspi[Instance]), BlockAddress, BlockSize) != MX25R6435F_OK)
 800cc98:	4806      	ldr	r0, [pc, #24]	; (800ccb4 <BSP_QSPI_Erase_Block+0x34>)
 800cc9a:	462a      	mov	r2, r5
 800cc9c:	4621      	mov	r1, r4
 800cc9e:	f002 fbe5 	bl	800f46c <MX25R6435F_BlockErase>
 800cca2:	b900      	cbnz	r0, 800cca6 <BSP_QSPI_Erase_Block+0x26>
    }
  }

  /* Return BSP status */
  return ret;
}
 800cca4:	bd38      	pop	{r3, r4, r5, pc}
      ret = BSP_ERROR_COMPONENT_FAILURE;
 800cca6:	f06f 0004 	mvn.w	r0, #4
}
 800ccaa:	bd38      	pop	{r3, r4, r5, pc}
    ret = BSP_ERROR_WRONG_PARAM;
 800ccac:	f06f 0001 	mvn.w	r0, #1
}
 800ccb0:	4770      	bx	lr
 800ccb2:	bf00      	nop
 800ccb4:	200032a0 	.word	0x200032a0

0800ccb8 <BSP_QSPI_GetStatus>:
{
  static uint8_t reg[2];
  int32_t ret;

  /* Check if the instance is supported */
  if(Instance >= QSPI_INSTANCES_NUMBER)
 800ccb8:	bb00      	cbnz	r0, 800ccfc <BSP_QSPI_GetStatus+0x44>
{
 800ccba:	b510      	push	{r4, lr}
  {
    ret = BSP_ERROR_WRONG_PARAM;
  }
  else
  {
    if(MX25R6435F_ReadSecurityRegister(&(hqspi[Instance]), reg) != MX25R6435F_OK)
 800ccbc:	4c12      	ldr	r4, [pc, #72]	; (800cd08 <BSP_QSPI_GetStatus+0x50>)
 800ccbe:	f104 0148 	add.w	r1, r4, #72	; 0x48
 800ccc2:	1d20      	adds	r0, r4, #4
 800ccc4:	f002 fcf0 	bl	800f6a8 <MX25R6435F_ReadSecurityRegister>
 800ccc8:	b9a8      	cbnz	r0, 800ccf6 <BSP_QSPI_GetStatus+0x3e>
    {
      ret = BSP_ERROR_COMPONENT_FAILURE;
    }/* Check the value of the register */
    else if ((reg[0] & (MX25R6435F_SECR_P_FAIL | MX25R6435F_SECR_E_FAIL)) != 0U)
 800ccca:	f894 3048 	ldrb.w	r3, [r4, #72]	; 0x48
 800ccce:	f013 0f60 	tst.w	r3, #96	; 0x60
 800ccd2:	d110      	bne.n	800ccf6 <BSP_QSPI_GetStatus+0x3e>
    {
      ret = BSP_ERROR_COMPONENT_FAILURE;
    }
    else if ((reg[0] & (MX25R6435F_SECR_PSB | MX25R6435F_SECR_ESB)) != 0U)
 800ccd4:	f013 0f0c 	tst.w	r3, #12
 800ccd8:	d113      	bne.n	800cd02 <BSP_QSPI_GetStatus+0x4a>
    {
      ret = BSP_ERROR_QSPI_SUSPENDED;
    }
    else if(MX25R6435F_ReadStatusRegister(&(hqspi[Instance]), reg) != MX25R6435F_OK)
 800ccda:	f104 0148 	add.w	r1, r4, #72	; 0x48
 800ccde:	1d20      	adds	r0, r4, #4
 800cce0:	f002 fc2c 	bl	800f53c <MX25R6435F_ReadStatusRegister>
 800cce4:	b938      	cbnz	r0, 800ccf6 <BSP_QSPI_GetStatus+0x3e>
    {
      ret = BSP_ERROR_COMPONENT_FAILURE;
    }/* Check the value of the register */
    else if ((reg[0] & MX25R6435F_SR_WIP) != 0U)
 800cce6:	f894 3048 	ldrb.w	r3, [r4, #72]	; 0x48
    {
      ret = BSP_ERROR_BUSY;
 800ccea:	f013 0f01 	tst.w	r3, #1
 800ccee:	bf18      	it	ne
 800ccf0:	f06f 0002 	mvnne.w	r0, #2
    }
  }

  /* Return BSP status */
  return ret;
}
 800ccf4:	bd10      	pop	{r4, pc}
      ret = BSP_ERROR_COMPONENT_FAILURE;
 800ccf6:	f06f 0004 	mvn.w	r0, #4
}
 800ccfa:	bd10      	pop	{r4, pc}
    ret = BSP_ERROR_WRONG_PARAM;
 800ccfc:	f06f 0001 	mvn.w	r0, #1
}
 800cd00:	4770      	bx	lr
      ret = BSP_ERROR_QSPI_SUSPENDED;
 800cd02:	f06f 0013 	mvn.w	r0, #19
}
 800cd06:	bd10      	pop	{r4, pc}
 800cd08:	2000329c 	.word	0x2000329c

0800cd0c <BSP_QSPI_ConfigFlash>:
int32_t BSP_QSPI_ConfigFlash(uint32_t Instance, BSP_QSPI_Interface_t Mode)
{
  int32_t ret = BSP_ERROR_NONE;

  /* Check if the instance is supported */
  if(Instance >= QSPI_INSTANCES_NUMBER)
 800cd0c:	2800      	cmp	r0, #0
 800cd0e:	d16f      	bne.n	800cdf0 <BSP_QSPI_ConfigFlash+0xe4>
{
 800cd10:	b570      	push	{r4, r5, r6, lr}
    ret = BSP_ERROR_WRONG_PARAM;
  }
  else
  {
    /* Check if MMP mode locked ************************************************/
    if(Qspi_Ctx[Instance].IsInitialized == QSPI_ACCESS_MMP)
 800cd12:	4c3a      	ldr	r4, [pc, #232]	; (800cdfc <BSP_QSPI_ConfigFlash+0xf0>)
 800cd14:	7823      	ldrb	r3, [r4, #0]
 800cd16:	2b02      	cmp	r3, #2
{
 800cd18:	b082      	sub	sp, #8
    if(Qspi_Ctx[Instance].IsInitialized == QSPI_ACCESS_MMP)
 800cd1a:	d06c      	beq.n	800cdf6 <BSP_QSPI_ConfigFlash+0xea>
      ret = BSP_ERROR_QSPI_MMP_LOCK_FAILURE;
    }
    else
    {
      /* Setup Flash interface ***************************************************/
      switch(Qspi_Ctx[Instance].InterfaceMode)
 800cd1c:	7863      	ldrb	r3, [r4, #1]
 800cd1e:	3b03      	subs	r3, #3
 800cd20:	2b01      	cmp	r3, #1
 800cd22:	460d      	mov	r5, r1
        
      case BSP_QSPI_SPI_MODE :       /* 1-1-1 commands, Power on H/W default setting */
      case BSP_QSPI_DUAL_OUT_MODE :  /* 1-1-2 commands */
      case BSP_QSPI_DUAL_IO_MODE :   /* 1-2-2 commands */
      default :
        if((Mode == BSP_QSPI_QUAD_OUT_MODE) || (Mode == BSP_QSPI_QUAD_IO_MODE))
 800cd24:	f1a1 0303 	sub.w	r3, r1, #3
      switch(Qspi_Ctx[Instance].InterfaceMode)
 800cd28:	d907      	bls.n	800cd3a <BSP_QSPI_ConfigFlash+0x2e>
        if((Mode == BSP_QSPI_QUAD_OUT_MODE) || (Mode == BSP_QSPI_QUAD_IO_MODE))
 800cd2a:	2b01      	cmp	r3, #1
 800cd2c:	d932      	bls.n	800cd94 <BSP_QSPI_ConfigFlash+0x88>
      
      /* Update QSPI context if all operations are well done */
      if(ret == BSP_ERROR_NONE)
      {
        /* Update current status parameter *****************************************/
        Qspi_Ctx[Instance].IsInitialized = QSPI_ACCESS_INDIRECT;
 800cd2e:	2301      	movs	r3, #1
 800cd30:	7023      	strb	r3, [r4, #0]
        Qspi_Ctx[Instance].InterfaceMode = Mode;
 800cd32:	7065      	strb	r5, [r4, #1]
 800cd34:	2000      	movs	r0, #0
    }
  }

  /* Return BSP status */
  return ret;
}
 800cd36:	b002      	add	sp, #8
 800cd38:	bd70      	pop	{r4, r5, r6, pc}
        if((Mode != BSP_QSPI_QUAD_OUT_MODE) && (Mode != BSP_QSPI_QUAD_IO_MODE))
 800cd3a:	2b01      	cmp	r3, #1
 800cd3c:	d9f7      	bls.n	800cd2e <BSP_QSPI_ConfigFlash+0x22>
  if(Instance >= QSPI_INSTANCES_NUMBER)
  {
    ret = BSP_ERROR_WRONG_PARAM;
  }
  /* Read Status register */
  else if (MX25R6435F_ReadStatusRegister(&(hqspi[Instance]), &reg) != MX25R6435F_OK)
 800cd3e:	f10d 0107 	add.w	r1, sp, #7
 800cd42:	1d20      	adds	r0, r4, #4
 800cd44:	f002 fbfa 	bl	800f53c <MX25R6435F_ReadStatusRegister>
 800cd48:	bb08      	cbnz	r0, 800cd8e <BSP_QSPI_ConfigFlash+0x82>
  {
    ret = BSP_ERROR_COMPONENT_FAILURE;
  }
  /* Enable write operations */
  else if (MX25R6435F_WriteEnable(&(hqspi[Instance])) != MX25R6435F_OK)
 800cd4a:	1d20      	adds	r0, r4, #4
 800cd4c:	f002 fbbe 	bl	800f4cc <MX25R6435F_WriteEnable>
 800cd50:	b9e8      	cbnz	r0, 800cd8e <BSP_QSPI_ConfigFlash+0x82>
    ret = BSP_ERROR_COMPONENT_FAILURE;
  }
  else
  {
    /* Write Status register (with SPI protocol) */
    reg &= ~(MX25R6435F_SR_QE);
 800cd52:	f89d 1007 	ldrb.w	r1, [sp, #7]
    if (MX25R6435F_WriteStatusRegister(&(hqspi[Instance]), reg) != MX25R6435F_OK)
 800cd56:	1d20      	adds	r0, r4, #4
    reg &= ~(MX25R6435F_SR_QE);
 800cd58:	f001 01bf 	and.w	r1, r1, #191	; 0xbf
 800cd5c:	f88d 1007 	strb.w	r1, [sp, #7]
    if (MX25R6435F_WriteStatusRegister(&(hqspi[Instance]), reg) != MX25R6435F_OK)
 800cd60:	f002 fc6a 	bl	800f638 <MX25R6435F_WriteStatusRegister>
 800cd64:	4606      	mov	r6, r0
 800cd66:	b990      	cbnz	r0, 800cd8e <BSP_QSPI_ConfigFlash+0x82>
      ret = BSP_ERROR_COMPONENT_FAILURE;
    }
    else
    {
      /* Wait that the configuration is effective and check that memory is ready */
      HAL_Delay(MX25R6435F_WRITE_REG_MAX_TIME);
 800cd68:	2028      	movs	r0, #40	; 0x28
 800cd6a:	f015 fe27 	bl	80229bc <HAL_Delay>
      reg = 0;

      /* Check Flash busy ? */
      if (MX25R6435F_AutoPollingMemReady(&(hqspi[Instance])) != MX25R6435F_OK)
 800cd6e:	1d20      	adds	r0, r4, #4
      reg = 0;
 800cd70:	f88d 6007 	strb.w	r6, [sp, #7]
      if (MX25R6435F_AutoPollingMemReady(&(hqspi[Instance])) != MX25R6435F_OK)
 800cd74:	f002 fab8 	bl	800f2e8 <MX25R6435F_AutoPollingMemReady>
 800cd78:	b948      	cbnz	r0, 800cd8e <BSP_QSPI_ConfigFlash+0x82>
      {
        ret = BSP_ERROR_COMPONENT_FAILURE;
      }
      /* Check the configuration has been correctly done */
      else if (MX25R6435F_ReadStatusRegister(&(hqspi[Instance]), &reg) != MX25R6435F_OK)
 800cd7a:	f10d 0107 	add.w	r1, sp, #7
 800cd7e:	1d20      	adds	r0, r4, #4
 800cd80:	f002 fbdc 	bl	800f53c <MX25R6435F_ReadStatusRegister>
 800cd84:	b918      	cbnz	r0, 800cd8e <BSP_QSPI_ConfigFlash+0x82>
      {
        ret = BSP_ERROR_COMPONENT_FAILURE;
      }
      else if ((reg & MX25R6435F_SR_QE) != 0U)
 800cd86:	f89d 3007 	ldrb.w	r3, [sp, #7]
 800cd8a:	065a      	lsls	r2, r3, #25
 800cd8c:	d5cf      	bpl.n	800cd2e <BSP_QSPI_ConfigFlash+0x22>
    ret = BSP_ERROR_COMPONENT_FAILURE;
 800cd8e:	f06f 0004 	mvn.w	r0, #4
 800cd92:	e7d0      	b.n	800cd36 <BSP_QSPI_ConfigFlash+0x2a>
  else if (MX25R6435F_ReadStatusRegister(&(hqspi[Instance]), &reg) != MX25R6435F_OK)
 800cd94:	f10d 0107 	add.w	r1, sp, #7
 800cd98:	1d20      	adds	r0, r4, #4
 800cd9a:	f002 fbcf 	bl	800f53c <MX25R6435F_ReadStatusRegister>
 800cd9e:	2800      	cmp	r0, #0
 800cda0:	d1f5      	bne.n	800cd8e <BSP_QSPI_ConfigFlash+0x82>
  else if (MX25R6435F_WriteEnable(&(hqspi[Instance])) != MX25R6435F_OK)
 800cda2:	1d20      	adds	r0, r4, #4
 800cda4:	f002 fb92 	bl	800f4cc <MX25R6435F_WriteEnable>
 800cda8:	2800      	cmp	r0, #0
 800cdaa:	d1f0      	bne.n	800cd8e <BSP_QSPI_ConfigFlash+0x82>
    reg |= MX25R6435F_SR_QE;
 800cdac:	f89d 1007 	ldrb.w	r1, [sp, #7]
    if (MX25R6435F_WriteStatusRegister(&(hqspi[Instance]), reg) != MX25R6435F_OK)
 800cdb0:	1d20      	adds	r0, r4, #4
    reg |= MX25R6435F_SR_QE;
 800cdb2:	f041 0140 	orr.w	r1, r1, #64	; 0x40
 800cdb6:	f88d 1007 	strb.w	r1, [sp, #7]
    if (MX25R6435F_WriteStatusRegister(&(hqspi[Instance]), reg) != MX25R6435F_OK)
 800cdba:	f002 fc3d 	bl	800f638 <MX25R6435F_WriteStatusRegister>
 800cdbe:	4606      	mov	r6, r0
 800cdc0:	2800      	cmp	r0, #0
 800cdc2:	d1e4      	bne.n	800cd8e <BSP_QSPI_ConfigFlash+0x82>
      HAL_Delay(MX25R6435F_WRITE_REG_MAX_TIME);
 800cdc4:	2028      	movs	r0, #40	; 0x28
 800cdc6:	f015 fdf9 	bl	80229bc <HAL_Delay>
      if (MX25R6435F_AutoPollingMemReady(&(hqspi[Instance])) != MX25R6435F_OK)
 800cdca:	1d20      	adds	r0, r4, #4
      reg = 0;
 800cdcc:	f88d 6007 	strb.w	r6, [sp, #7]
      if (MX25R6435F_AutoPollingMemReady(&(hqspi[Instance])) != MX25R6435F_OK)
 800cdd0:	f002 fa8a 	bl	800f2e8 <MX25R6435F_AutoPollingMemReady>
 800cdd4:	2800      	cmp	r0, #0
 800cdd6:	d1da      	bne.n	800cd8e <BSP_QSPI_ConfigFlash+0x82>
      else if (MX25R6435F_ReadStatusRegister(&(hqspi[Instance]), &reg) != MX25R6435F_OK)
 800cdd8:	f10d 0107 	add.w	r1, sp, #7
 800cddc:	1d20      	adds	r0, r4, #4
 800cdde:	f002 fbad 	bl	800f53c <MX25R6435F_ReadStatusRegister>
 800cde2:	2800      	cmp	r0, #0
 800cde4:	d1d3      	bne.n	800cd8e <BSP_QSPI_ConfigFlash+0x82>
      else if ((reg & MX25R6435F_SR_QE) == 0U)
 800cde6:	f89d 3007 	ldrb.w	r3, [sp, #7]
 800cdea:	065b      	lsls	r3, r3, #25
 800cdec:	d5cf      	bpl.n	800cd8e <BSP_QSPI_ConfigFlash+0x82>
 800cdee:	e79e      	b.n	800cd2e <BSP_QSPI_ConfigFlash+0x22>
    ret = BSP_ERROR_WRONG_PARAM;
 800cdf0:	f06f 0001 	mvn.w	r0, #1
}
 800cdf4:	4770      	bx	lr
      ret = BSP_ERROR_QSPI_MMP_LOCK_FAILURE;
 800cdf6:	f06f 0015 	mvn.w	r0, #21
  return ret;
 800cdfa:	e79c      	b.n	800cd36 <BSP_QSPI_ConfigFlash+0x2a>
 800cdfc:	2000329c 	.word	0x2000329c

0800ce00 <BSP_QSPI_Init>:
  if(Instance >= QSPI_INSTANCES_NUMBER)
 800ce00:	2800      	cmp	r0, #0
 800ce02:	f040 80b8 	bne.w	800cf76 <BSP_QSPI_Init+0x176>
{
 800ce06:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    if (Qspi_Ctx[Instance].IsInitialized == QSPI_ACCESS_NONE)
 800ce0a:	4c5e      	ldr	r4, [pc, #376]	; (800cf84 <BSP_QSPI_Init+0x184>)
 800ce0c:	7825      	ldrb	r5, [r4, #0]
{
 800ce0e:	b095      	sub	sp, #84	; 0x54
    if (Qspi_Ctx[Instance].IsInitialized == QSPI_ACCESS_NONE)
 800ce10:	b11d      	cbz	r5, 800ce1a <BSP_QSPI_Init+0x1a>
        ret = BSP_ERROR_NONE;
 800ce12:	2000      	movs	r0, #0
}
 800ce14:	b015      	add	sp, #84	; 0x54
 800ce16:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
  QSPI_CLK_ENABLE();
 800ce1a:	4b5b      	ldr	r3, [pc, #364]	; (800cf88 <BSP_QSPI_Init+0x188>)
  HAL_GPIO_Init(QSPI_CS_GPIO_PORT, &GPIO_InitStruct);
 800ce1c:	485b      	ldr	r0, [pc, #364]	; (800cf8c <BSP_QSPI_Init+0x18c>)
  QSPI_CLK_ENABLE();
 800ce1e:	6d1a      	ldr	r2, [r3, #80]	; 0x50
 800ce20:	f442 7280 	orr.w	r2, r2, #256	; 0x100
 800ce24:	651a      	str	r2, [r3, #80]	; 0x50
 800ce26:	6d1a      	ldr	r2, [r3, #80]	; 0x50
 800ce28:	f402 7280 	and.w	r2, r2, #256	; 0x100
 800ce2c:	9201      	str	r2, [sp, #4]
 800ce2e:	9a01      	ldr	r2, [sp, #4]
  QSPI_FORCE_RESET();
 800ce30:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 800ce32:	f442 7280 	orr.w	r2, r2, #256	; 0x100
 800ce36:	631a      	str	r2, [r3, #48]	; 0x30
  QSPI_RELEASE_RESET();
 800ce38:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 800ce3a:	f422 7280 	bic.w	r2, r2, #256	; 0x100
 800ce3e:	631a      	str	r2, [r3, #48]	; 0x30
  QSPI_CLK_GPIO_CLK_ENABLE();
 800ce40:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 800ce42:	f042 0210 	orr.w	r2, r2, #16
 800ce46:	64da      	str	r2, [r3, #76]	; 0x4c
 800ce48:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 800ce4a:	f002 0210 	and.w	r2, r2, #16
 800ce4e:	9202      	str	r2, [sp, #8]
 800ce50:	9a02      	ldr	r2, [sp, #8]
  QSPI_CS_GPIO_CLK_ENABLE();
 800ce52:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 800ce54:	f042 0210 	orr.w	r2, r2, #16
 800ce58:	64da      	str	r2, [r3, #76]	; 0x4c
 800ce5a:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 800ce5c:	f002 0210 	and.w	r2, r2, #16
 800ce60:	9203      	str	r2, [sp, #12]
 800ce62:	9a03      	ldr	r2, [sp, #12]
  QSPI_D0_GPIO_CLK_ENABLE();
 800ce64:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 800ce66:	f042 0210 	orr.w	r2, r2, #16
 800ce6a:	64da      	str	r2, [r3, #76]	; 0x4c
 800ce6c:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 800ce6e:	f002 0210 	and.w	r2, r2, #16
 800ce72:	9204      	str	r2, [sp, #16]
 800ce74:	9a04      	ldr	r2, [sp, #16]
  QSPI_D1_GPIO_CLK_ENABLE();
 800ce76:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 800ce78:	f042 0210 	orr.w	r2, r2, #16
 800ce7c:	64da      	str	r2, [r3, #76]	; 0x4c
 800ce7e:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 800ce80:	f002 0210 	and.w	r2, r2, #16
 800ce84:	9205      	str	r2, [sp, #20]
 800ce86:	9a05      	ldr	r2, [sp, #20]
  QSPI_D2_GPIO_CLK_ENABLE();
 800ce88:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 800ce8a:	f042 0210 	orr.w	r2, r2, #16
 800ce8e:	64da      	str	r2, [r3, #76]	; 0x4c
 800ce90:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 800ce92:	f002 0210 	and.w	r2, r2, #16
 800ce96:	9206      	str	r2, [sp, #24]
 800ce98:	9a06      	ldr	r2, [sp, #24]
  QSPI_D3_GPIO_CLK_ENABLE();
 800ce9a:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 800ce9c:	f042 0210 	orr.w	r2, r2, #16
 800cea0:	64da      	str	r2, [r3, #76]	; 0x4c
 800cea2:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 800cea4:	f003 0310 	and.w	r3, r3, #16
 800cea8:	9307      	str	r3, [sp, #28]
  GPIO_InitStruct.Pin       = QSPI_CS_PIN;
 800ceaa:	f44f 6300 	mov.w	r3, #2048	; 0x800
  GPIO_InitStruct.Alternate = QSPI_CS_PIN_AF;
 800ceae:	260a      	movs	r6, #10
  GPIO_InitStruct.Speed     = GPIO_SPEED_FREQ_VERY_HIGH;
 800ceb0:	f04f 0903 	mov.w	r9, #3
  GPIO_InitStruct.Pin       = QSPI_CS_PIN;
 800ceb4:	930b      	str	r3, [sp, #44]	; 0x2c
 800ceb6:	460f      	mov	r7, r1
  QSPI_D3_GPIO_CLK_ENABLE();
 800ceb8:	9b07      	ldr	r3, [sp, #28]
  HAL_GPIO_Init(QSPI_CS_GPIO_PORT, &GPIO_InitStruct);
 800ceba:	a90b      	add	r1, sp, #44	; 0x2c
  GPIO_InitStruct.Pull      = GPIO_PULLUP;
 800cebc:	2302      	movs	r3, #2
 800cebe:	f04f 0801 	mov.w	r8, #1
 800cec2:	e9cd 380c 	strd	r3, r8, [sp, #48]	; 0x30
  GPIO_InitStruct.Alternate = QSPI_CS_PIN_AF;
 800cec6:	e9cd 960e 	strd	r9, r6, [sp, #56]	; 0x38
  HAL_GPIO_Init(QSPI_CS_GPIO_PORT, &GPIO_InitStruct);
 800ceca:	f003 fcb7 	bl	801083c <HAL_GPIO_Init>
  HAL_GPIO_Init(QSPI_CLK_GPIO_PORT, &GPIO_InitStruct);
 800cece:	a90b      	add	r1, sp, #44	; 0x2c
  GPIO_InitStruct.Pin       = QSPI_CLK_PIN;
 800ced0:	f44f 6380 	mov.w	r3, #1024	; 0x400
  HAL_GPIO_Init(QSPI_CLK_GPIO_PORT, &GPIO_InitStruct);
 800ced4:	482d      	ldr	r0, [pc, #180]	; (800cf8c <BSP_QSPI_Init+0x18c>)
  GPIO_InitStruct.Pin       = QSPI_CLK_PIN;
 800ced6:	930b      	str	r3, [sp, #44]	; 0x2c
  GPIO_InitStruct.Pull      = GPIO_NOPULL;
 800ced8:	950d      	str	r5, [sp, #52]	; 0x34
  GPIO_InitStruct.Alternate = QSPI_CLK_PIN_AF;
 800ceda:	960f      	str	r6, [sp, #60]	; 0x3c
  HAL_GPIO_Init(QSPI_CLK_GPIO_PORT, &GPIO_InitStruct);
 800cedc:	f003 fcae 	bl	801083c <HAL_GPIO_Init>
  HAL_GPIO_Init(QSPI_D0_GPIO_PORT, &GPIO_InitStruct);
 800cee0:	a90b      	add	r1, sp, #44	; 0x2c
  GPIO_InitStruct.Pin       = QSPI_D0_PIN;
 800cee2:	f44f 5380 	mov.w	r3, #4096	; 0x1000
  HAL_GPIO_Init(QSPI_D0_GPIO_PORT, &GPIO_InitStruct);
 800cee6:	4829      	ldr	r0, [pc, #164]	; (800cf8c <BSP_QSPI_Init+0x18c>)
  GPIO_InitStruct.Pin       = QSPI_D0_PIN;
 800cee8:	930b      	str	r3, [sp, #44]	; 0x2c
  GPIO_InitStruct.Alternate = QSPI_D0_PIN_AF;
 800ceea:	960f      	str	r6, [sp, #60]	; 0x3c
  HAL_GPIO_Init(QSPI_D0_GPIO_PORT, &GPIO_InitStruct);
 800ceec:	f003 fca6 	bl	801083c <HAL_GPIO_Init>
  HAL_GPIO_Init(QSPI_D1_GPIO_PORT, &GPIO_InitStruct);
 800cef0:	a90b      	add	r1, sp, #44	; 0x2c
  GPIO_InitStruct.Pin       = QSPI_D1_PIN;
 800cef2:	f44f 5300 	mov.w	r3, #8192	; 0x2000
  HAL_GPIO_Init(QSPI_D1_GPIO_PORT, &GPIO_InitStruct);
 800cef6:	4825      	ldr	r0, [pc, #148]	; (800cf8c <BSP_QSPI_Init+0x18c>)
  GPIO_InitStruct.Pin       = QSPI_D1_PIN;
 800cef8:	930b      	str	r3, [sp, #44]	; 0x2c
  GPIO_InitStruct.Alternate = QSPI_D1_PIN_AF;
 800cefa:	960f      	str	r6, [sp, #60]	; 0x3c
  HAL_GPIO_Init(QSPI_D1_GPIO_PORT, &GPIO_InitStruct);
 800cefc:	f003 fc9e 	bl	801083c <HAL_GPIO_Init>
  HAL_GPIO_Init(QSPI_D2_GPIO_PORT, &GPIO_InitStruct);
 800cf00:	a90b      	add	r1, sp, #44	; 0x2c
  GPIO_InitStruct.Pin       = QSPI_D2_PIN;
 800cf02:	f44f 4380 	mov.w	r3, #16384	; 0x4000
  HAL_GPIO_Init(QSPI_D2_GPIO_PORT, &GPIO_InitStruct);
 800cf06:	4821      	ldr	r0, [pc, #132]	; (800cf8c <BSP_QSPI_Init+0x18c>)
  GPIO_InitStruct.Pin       = QSPI_D2_PIN;
 800cf08:	930b      	str	r3, [sp, #44]	; 0x2c
  GPIO_InitStruct.Alternate = QSPI_D2_PIN_AF;
 800cf0a:	960f      	str	r6, [sp, #60]	; 0x3c
  HAL_GPIO_Init(QSPI_D2_GPIO_PORT, &GPIO_InitStruct);
 800cf0c:	f003 fc96 	bl	801083c <HAL_GPIO_Init>
  GPIO_InitStruct.Pin       = QSPI_D3_PIN;
 800cf10:	f44f 4300 	mov.w	r3, #32768	; 0x8000
  HAL_GPIO_Init(QSPI_D3_GPIO_PORT, &GPIO_InitStruct);
 800cf14:	a90b      	add	r1, sp, #44	; 0x2c
 800cf16:	481d      	ldr	r0, [pc, #116]	; (800cf8c <BSP_QSPI_Init+0x18c>)
  GPIO_InitStruct.Pin       = QSPI_D3_PIN;
 800cf18:	930b      	str	r3, [sp, #44]	; 0x2c
  GPIO_InitStruct.Alternate = QSPI_D3_PIN_AF;
 800cf1a:	960f      	str	r6, [sp, #60]	; 0x3c
  HAL_GPIO_Init(QSPI_D3_GPIO_PORT, &GPIO_InitStruct);
 800cf1c:	f003 fc8e 	bl	801083c <HAL_GPIO_Init>
      (void)MX25R6435F_GetFlashInfo(&pInfo);
 800cf20:	a80b      	add	r0, sp, #44	; 0x2c
 800cf22:	f002 f9c5 	bl	800f2b0 <MX25R6435F_GetFlashInfo>
  uint32_t result;

#if ((defined (__ARM_ARCH_7M__      ) && (__ARM_ARCH_7M__      == 1)) || \
     (defined (__ARM_ARCH_7EM__     ) && (__ARM_ARCH_7EM__     == 1)) || \
     (defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1))    )
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 800cf26:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
      qspi_init.ClockPrescaler = 3; /* QuadSPI clock = 80MHz / ClockPrescaler = 20MHz */
 800cf28:	f8cd 9024 	str.w	r9, [sp, #36]	; 0x24
 800cf2c:	fa93 f3a3 	rbit	r3, r3
      qspi_init.MemorySize     = (uint32_t)POSITION_VAL((uint32_t)pInfo.FlashSize);
 800cf30:	fab3 f383 	clz	r3, r3
      if (MX_QSPI_Init(&(hqspi[Instance]), &qspi_init) != HAL_OK)
 800cf34:	a908      	add	r1, sp, #32
 800cf36:	1d20      	adds	r0, r4, #4
      qspi_init.MemorySize     = (uint32_t)POSITION_VAL((uint32_t)pInfo.FlashSize);
 800cf38:	9308      	str	r3, [sp, #32]
      qspi_init.SampleShifting = QSPI_SAMPLE_SHIFTING_NONE;
 800cf3a:	950a      	str	r5, [sp, #40]	; 0x28
      if (MX_QSPI_Init(&(hqspi[Instance]), &qspi_init) != HAL_OK)
 800cf3c:	f7ff fe2c 	bl	800cb98 <MX_QSPI_Init>
 800cf40:	b9e0      	cbnz	r0, 800cf7c <BSP_QSPI_Init+0x17c>
  else if(MX25R6435F_ResetEnable(&(hqspi[Instance])) != MX25R6435F_OK)
 800cf42:	1d20      	adds	r0, r4, #4
 800cf44:	f002 fbda 	bl	800f6fc <MX25R6435F_ResetEnable>
 800cf48:	b990      	cbnz	r0, 800cf70 <BSP_QSPI_Init+0x170>
  else if(MX25R6435F_ResetMemory(&(hqspi[Instance])) != MX25R6435F_OK)
 800cf4a:	1d20      	adds	r0, r4, #4
 800cf4c:	f002 fbf0 	bl	800f730 <MX25R6435F_ResetMemory>
 800cf50:	b970      	cbnz	r0, 800cf70 <BSP_QSPI_Init+0x170>
    HAL_Delay(MX25R6435F_RESET_MAX_TIME);
 800cf52:	2064      	movs	r0, #100	; 0x64
    Qspi_Ctx[Instance].IsInitialized = QSPI_ACCESS_INDIRECT;      /* After reset S/W setting to indirect access   */
 800cf54:	f8a4 8000 	strh.w	r8, [r4]
    HAL_Delay(MX25R6435F_RESET_MAX_TIME);
 800cf58:	f015 fd30 	bl	80229bc <HAL_Delay>
      else if (MX25R6435F_AutoPollingMemReady(&(hqspi[Instance])) != MX25R6435F_OK)
 800cf5c:	1d20      	adds	r0, r4, #4
 800cf5e:	f002 f9c3 	bl	800f2e8 <MX25R6435F_AutoPollingMemReady>
 800cf62:	b928      	cbnz	r0, 800cf70 <BSP_QSPI_Init+0x170>
      else if (BSP_QSPI_ConfigFlash(Instance, Init->InterfaceMode) != BSP_ERROR_NONE)
 800cf64:	7839      	ldrb	r1, [r7, #0]
 800cf66:	f7ff fed1 	bl	800cd0c <BSP_QSPI_ConfigFlash>
 800cf6a:	2800      	cmp	r0, #0
 800cf6c:	f43f af51 	beq.w	800ce12 <BSP_QSPI_Init+0x12>
        ret = BSP_ERROR_COMPONENT_FAILURE;
 800cf70:	f06f 0004 	mvn.w	r0, #4
 800cf74:	e74e      	b.n	800ce14 <BSP_QSPI_Init+0x14>
    ret = BSP_ERROR_WRONG_PARAM;
 800cf76:	f06f 0001 	mvn.w	r0, #1
}
 800cf7a:	4770      	bx	lr
        ret = BSP_ERROR_PERIPH_FAILURE;
 800cf7c:	f06f 0003 	mvn.w	r0, #3
  return ret;
 800cf80:	e748      	b.n	800ce14 <BSP_QSPI_Init+0x14>
 800cf82:	bf00      	nop
 800cf84:	2000329c 	.word	0x2000329c
 800cf88:	40021000 	.word	0x40021000
 800cf8c:	48001000 	.word	0x48001000

0800cf90 <HTS221_GetCapabilities>:

  Capabilities->Humidity    = 1;
  Capabilities->Pressure    = 0;
  Capabilities->Temperature = 1;
  Capabilities->LowPower    = 0;
  Capabilities->HumMaxOdr   = 12.5f;
 800cf90:	4b04      	ldr	r3, [pc, #16]	; (800cfa4 <HTS221_GetCapabilities+0x14>)
 800cf92:	604b      	str	r3, [r1, #4]
  Capabilities->TempMaxOdr  = 12.5f;
  Capabilities->PressMaxOdr = 0.0f;
 800cf94:	2200      	movs	r2, #0
  Capabilities->Temperature = 1;
 800cf96:	f04f 1001 	mov.w	r0, #65537	; 0x10001
 800cf9a:	6008      	str	r0, [r1, #0]
  Capabilities->TempMaxOdr  = 12.5f;
 800cf9c:	608b      	str	r3, [r1, #8]
  Capabilities->PressMaxOdr = 0.0f;
 800cf9e:	60ca      	str	r2, [r1, #12]
  return HTS221_OK;
}
 800cfa0:	2000      	movs	r0, #0
 800cfa2:	4770      	bx	lr
 800cfa4:	41480000 	.word	0x41480000

0800cfa8 <HTS221_HUM_Enable>:
 * @retval 0 in case of success, an error code otherwise
 */
int32_t HTS221_HUM_Enable(HTS221_Object_t *pObj)
{
  /* Check if the component is already enabled */
  if (pObj->hum_is_enabled == 1U)
 800cfa8:	f890 3029 	ldrb.w	r3, [r0, #41]	; 0x29
 800cfac:	2b01      	cmp	r3, #1
 800cfae:	d012      	beq.n	800cfd6 <HTS221_HUM_Enable+0x2e>
{
 800cfb0:	b510      	push	{r4, lr}
    return HTS221_OK;
  }

  /* Check if the HTS221 temperature sensor is already enabled. */
  /* If yes, skip the enable function, if not call enable function */
  if (pObj->temp_is_enabled == 0U)
 800cfb2:	f890 302a 	ldrb.w	r3, [r0, #42]	; 0x2a
 800cfb6:	4604      	mov	r4, r0
 800cfb8:	b123      	cbz	r3, 800cfc4 <HTS221_HUM_Enable+0x1c>
    {
      return HTS221_ERROR;
    }
  }

  pObj->hum_is_enabled = 1;
 800cfba:	2301      	movs	r3, #1
 800cfbc:	f884 3029 	strb.w	r3, [r4, #41]	; 0x29

  return HTS221_OK;
 800cfc0:	2000      	movs	r0, #0
}
 800cfc2:	bd10      	pop	{r4, pc}
    if (hts221_power_on_set(&(pObj->Ctx), PROPERTY_ENABLE) != HTS221_OK)
 800cfc4:	2101      	movs	r1, #1
 800cfc6:	301c      	adds	r0, #28
 800cfc8:	f000 faee 	bl	800d5a8 <hts221_power_on_set>
 800cfcc:	2800      	cmp	r0, #0
 800cfce:	d0f4      	beq.n	800cfba <HTS221_HUM_Enable+0x12>
      return HTS221_ERROR;
 800cfd0:	f04f 30ff 	mov.w	r0, #4294967295
}
 800cfd4:	bd10      	pop	{r4, pc}
    return HTS221_OK;
 800cfd6:	2000      	movs	r0, #0
}
 800cfd8:	4770      	bx	lr
 800cfda:	bf00      	nop

0800cfdc <HTS221_TEMP_Enable>:
 * @retval 0 in case of success, an error code otherwise
 */
int32_t HTS221_TEMP_Enable(HTS221_Object_t *pObj)
{
  /* Check if the component is already enabled */
  if (pObj->temp_is_enabled == 1U)
 800cfdc:	f890 302a 	ldrb.w	r3, [r0, #42]	; 0x2a
 800cfe0:	2b01      	cmp	r3, #1
 800cfe2:	d012      	beq.n	800d00a <HTS221_TEMP_Enable+0x2e>
{
 800cfe4:	b510      	push	{r4, lr}
    return HTS221_OK;
  }

  /* Check if the HTS221 humidity sensor is already enabled. */
  /* If yes, skip the enable function, if not call enable function */
  if (pObj->hum_is_enabled == 0U)
 800cfe6:	f890 3029 	ldrb.w	r3, [r0, #41]	; 0x29
 800cfea:	4604      	mov	r4, r0
 800cfec:	b123      	cbz	r3, 800cff8 <HTS221_TEMP_Enable+0x1c>
    {
      return HTS221_ERROR;
    }
  }

  pObj->temp_is_enabled = 1;
 800cfee:	2301      	movs	r3, #1
 800cff0:	f884 302a 	strb.w	r3, [r4, #42]	; 0x2a

  return HTS221_OK;
 800cff4:	2000      	movs	r0, #0
}
 800cff6:	bd10      	pop	{r4, pc}
    if (hts221_power_on_set(&(pObj->Ctx), PROPERTY_ENABLE) != HTS221_OK)
 800cff8:	2101      	movs	r1, #1
 800cffa:	301c      	adds	r0, #28
 800cffc:	f000 fad4 	bl	800d5a8 <hts221_power_on_set>
 800d000:	2800      	cmp	r0, #0
 800d002:	d0f4      	beq.n	800cfee <HTS221_TEMP_Enable+0x12>
      return HTS221_ERROR;
 800d004:	f04f 30ff 	mov.w	r0, #4294967295
}
 800d008:	bd10      	pop	{r4, pc}
    return HTS221_OK;
 800d00a:	2000      	movs	r0, #0
}
 800d00c:	4770      	bx	lr
 800d00e:	bf00      	nop

0800d010 <HTS221_Init>:
{
 800d010:	b538      	push	{r3, r4, r5, lr}
  if (pObj->is_initialized == 0U)
 800d012:	f890 1028 	ldrb.w	r1, [r0, #40]	; 0x28
{
 800d016:	4604      	mov	r4, r0
  if (pObj->is_initialized == 0U)
 800d018:	b121      	cbz	r1, 800d024 <HTS221_Init+0x14>
  pObj->is_initialized = 1;
 800d01a:	2301      	movs	r3, #1
 800d01c:	f884 3028 	strb.w	r3, [r4, #40]	; 0x28
  return HTS221_OK;
 800d020:	2000      	movs	r0, #0
}
 800d022:	bd38      	pop	{r3, r4, r5, pc}
 * @retval 0 in case of success, an error code otherwise
 */
static int32_t HTS221_Initialize(HTS221_Object_t *pObj)
{
  /* Power off the component. */
  if (hts221_power_on_set(&(pObj->Ctx), PROPERTY_DISABLE) != HTS221_OK)
 800d024:	f100 051c 	add.w	r5, r0, #28
 800d028:	4628      	mov	r0, r5
 800d02a:	f000 fabd 	bl	800d5a8 <hts221_power_on_set>
 800d02e:	b950      	cbnz	r0, 800d046 <HTS221_Init+0x36>
  {
    return HTS221_ERROR;
  }

  /* Enable BDU */
  if (hts221_block_data_update_set(&(pObj->Ctx), PROPERTY_ENABLE) != HTS221_OK)
 800d030:	2101      	movs	r1, #1
 800d032:	4628      	mov	r0, r5
 800d034:	f000 fa66 	bl	800d504 <hts221_block_data_update_set>
 800d038:	b928      	cbnz	r0, 800d046 <HTS221_Init+0x36>
  if (hts221_data_rate_set(&(pObj->Ctx), new_odr) != HTS221_OK)
 800d03a:	2101      	movs	r1, #1
 800d03c:	4628      	mov	r0, r5
 800d03e:	f000 fa21 	bl	800d484 <hts221_data_rate_set>
 800d042:	2800      	cmp	r0, #0
 800d044:	d0e9      	beq.n	800d01a <HTS221_Init+0xa>
      return HTS221_ERROR;
 800d046:	f04f 30ff 	mov.w	r0, #4294967295
}
 800d04a:	bd38      	pop	{r3, r4, r5, pc}

0800d04c <HTS221_ReadID>:
{
 800d04c:	b508      	push	{r3, lr}
  if (hts221_device_id_get(&(pObj->Ctx), Id) != HTS221_OK)
 800d04e:	301c      	adds	r0, #28
 800d050:	f000 faa0 	bl	800d594 <hts221_device_id_get>
 800d054:	3800      	subs	r0, #0
 800d056:	bf18      	it	ne
 800d058:	2001      	movne	r0, #1
}
 800d05a:	4240      	negs	r0, r0
 800d05c:	bd08      	pop	{r3, pc}
 800d05e:	bf00      	nop

0800d060 <HTS221_HUM_GetHumidity>:
{
 800d060:	b530      	push	{r4, r5, lr}
 800d062:	ed2d 8b04 	vpush	{d8-d9}
  if (hts221_hum_adc_point_0_get(&(pObj->Ctx), coeff.u8bit) != HTS221_OK)
 800d066:	f100 041c 	add.w	r4, r0, #28
{
 800d06a:	b083      	sub	sp, #12
 800d06c:	460d      	mov	r5, r1
  if (hts221_hum_adc_point_0_get(&(pObj->Ctx), coeff.u8bit) != HTS221_OK)
 800d06e:	4620      	mov	r0, r4
 800d070:	a901      	add	r1, sp, #4
 800d072:	f000 fb07 	bl	800d684 <hts221_hum_adc_point_0_get>
 800d076:	2800      	cmp	r0, #0
 800d078:	d161      	bne.n	800d13e <HTS221_HUM_GetHumidity+0xde>
  lin_hum.x0 = (float)coeff.i16bit;
 800d07a:	f9bd 3004 	ldrsh.w	r3, [sp, #4]
 800d07e:	ee08 3a90 	vmov	s17, r3
  if (hts221_hum_rh_point_0_get(&(pObj->Ctx), coeff.u8bit) != HTS221_OK)
 800d082:	a901      	add	r1, sp, #4
 800d084:	4620      	mov	r0, r4
  lin_hum.x0 = (float)coeff.i16bit;
 800d086:	eef8 9ae8 	vcvt.f32.s32	s19, s17
  if (hts221_hum_rh_point_0_get(&(pObj->Ctx), coeff.u8bit) != HTS221_OK)
 800d08a:	f000 faa7 	bl	800d5dc <hts221_hum_rh_point_0_get>
 800d08e:	2800      	cmp	r0, #0
 800d090:	d155      	bne.n	800d13e <HTS221_HUM_GetHumidity+0xde>
  lin_hum.y0 = (float)coeff.u8bit[0];
 800d092:	f89d 3004 	ldrb.w	r3, [sp, #4]
 800d096:	ee08 3a10 	vmov	s16, r3
  if (hts221_hum_adc_point_1_get(&(pObj->Ctx), coeff.u8bit) != HTS221_OK)
 800d09a:	a901      	add	r1, sp, #4
 800d09c:	4620      	mov	r0, r4
  lin_hum.y0 = (float)coeff.u8bit[0];
 800d09e:	eeb8 8a48 	vcvt.f32.u32	s16, s16
  if (hts221_hum_adc_point_1_get(&(pObj->Ctx), coeff.u8bit) != HTS221_OK)
 800d0a2:	f000 faf9 	bl	800d698 <hts221_hum_adc_point_1_get>
 800d0a6:	2800      	cmp	r0, #0
 800d0a8:	d149      	bne.n	800d13e <HTS221_HUM_GetHumidity+0xde>
  lin_hum.x1 = (float)coeff.i16bit;
 800d0aa:	f9bd 3004 	ldrsh.w	r3, [sp, #4]
  if (hts221_hum_rh_point_1_get(&(pObj->Ctx), coeff.u8bit) != HTS221_OK)
 800d0ae:	a901      	add	r1, sp, #4
 800d0b0:	4620      	mov	r0, r4
  lin_hum.x1 = (float)coeff.i16bit;
 800d0b2:	ee08 3a90 	vmov	s17, r3
  if (hts221_hum_rh_point_1_get(&(pObj->Ctx), coeff.u8bit) != HTS221_OK)
 800d0b6:	f000 fa9d 	bl	800d5f4 <hts221_hum_rh_point_1_get>
  lin_hum.x1 = (float)coeff.i16bit;
 800d0ba:	eef8 8ae8 	vcvt.f32.s32	s17, s17
  if (hts221_hum_rh_point_1_get(&(pObj->Ctx), coeff.u8bit) != HTS221_OK)
 800d0be:	4603      	mov	r3, r0
 800d0c0:	2800      	cmp	r0, #0
 800d0c2:	d13c      	bne.n	800d13e <HTS221_HUM_GetHumidity+0xde>
  lin_hum.y1 = (float)coeff.u8bit[0];
 800d0c4:	f89d 2004 	ldrb.w	r2, [sp, #4]
  (void)memset(data_raw_humidity.u8bit, 0x00, sizeof(int16_t));
 800d0c8:	f8ad 3000 	strh.w	r3, [sp]
  lin_hum.y1 = (float)coeff.u8bit[0];
 800d0cc:	ee09 2a10 	vmov	s18, r2
  if (hts221_humidity_raw_get(&(pObj->Ctx), data_raw_humidity.u8bit) != HTS221_OK)
 800d0d0:	4669      	mov	r1, sp
 800d0d2:	4620      	mov	r0, r4
  lin_hum.y1 = (float)coeff.u8bit[0];
 800d0d4:	eeb8 9a49 	vcvt.f32.u32	s18, s18
  if (hts221_humidity_raw_get(&(pObj->Ctx), data_raw_humidity.u8bit) != HTS221_OK)
 800d0d8:	f000 fa48 	bl	800d56c <hts221_humidity_raw_get>
 800d0dc:	bb78      	cbnz	r0, 800d13e <HTS221_HUM_GetHumidity+0xde>
  *Value = Linear_Interpolation(&lin_hum, (float)data_raw_humidity.i16bit);
 800d0de:	f9bd 3000 	ldrsh.w	r3, [sp]
 800d0e2:	ee07 3a90 	vmov	s15, r3
 * @param  Coeff the coefficient
 * @retval Calculation result
 */
static float Linear_Interpolation(lin_t *Lin, float Coeff)
{
  return (((Lin->y1 - Lin->y0) * Coeff) + ((Lin->x1 * Lin->y0) - (Lin->x0 * Lin->y1))) / (Lin->x1 - Lin->x0);
 800d0e6:	ee39 7a48 	vsub.f32	s14, s18, s16
  *Value = Linear_Interpolation(&lin_hum, (float)data_raw_humidity.i16bit);
 800d0ea:	eef8 7ae7 	vcvt.f32.s32	s15, s15
  return (((Lin->y1 - Lin->y0) * Coeff) + ((Lin->x1 * Lin->y0) - (Lin->x0 * Lin->y1))) / (Lin->x1 - Lin->x0);
 800d0ee:	ee28 8a28 	vmul.f32	s16, s16, s17
 800d0f2:	ee29 9a89 	vmul.f32	s18, s19, s18
 800d0f6:	ee67 7a87 	vmul.f32	s15, s15, s14
 800d0fa:	ee38 8a49 	vsub.f32	s16, s16, s18
 800d0fe:	ee78 8ae9 	vsub.f32	s17, s17, s19
 800d102:	ee37 8a88 	vadd.f32	s16, s15, s16
  if (*Value < 0.0f)
 800d106:	2300      	movs	r3, #0
  return (((Lin->y1 - Lin->y0) * Coeff) + ((Lin->x1 * Lin->y0) - (Lin->x0 * Lin->y1))) / (Lin->x1 - Lin->x0);
 800d108:	eec8 7a28 	vdiv.f32	s15, s16, s17
  if (*Value < 0.0f)
 800d10c:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 800d110:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800d114:	d40e      	bmi.n	800d134 <HTS221_HUM_GetHumidity+0xd4>
  if (*Value > 100.0f)
 800d116:	ed9f 7a0b 	vldr	s14, [pc, #44]	; 800d144 <HTS221_HUM_GetHumidity+0xe4>
 800d11a:	eef4 7ac7 	vcmpe.f32	s15, s14
 800d11e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800d122:	bfd4      	ite	le
 800d124:	edc5 7a00 	vstrle	s15, [r5]
    *Value = 100.0f;
 800d128:	ed85 7a00 	vstrgt	s14, [r5]
}
 800d12c:	b003      	add	sp, #12
 800d12e:	ecbd 8b04 	vpop	{d8-d9}
 800d132:	bd30      	pop	{r4, r5, pc}
 800d134:	602b      	str	r3, [r5, #0]
 800d136:	b003      	add	sp, #12
 800d138:	ecbd 8b04 	vpop	{d8-d9}
 800d13c:	bd30      	pop	{r4, r5, pc}
    return HTS221_ERROR;
 800d13e:	f04f 30ff 	mov.w	r0, #4294967295
 800d142:	e7f3      	b.n	800d12c <HTS221_HUM_GetHumidity+0xcc>
 800d144:	42c80000 	.word	0x42c80000

0800d148 <HTS221_TEMP_GetTemperature>:
{
 800d148:	b530      	push	{r4, r5, lr}
 800d14a:	ed2d 8b04 	vpush	{d8-d9}
  if (hts221_temp_adc_point_0_get(&(pObj->Ctx), coeff.u8bit) != HTS221_OK)
 800d14e:	f100 041c 	add.w	r4, r0, #28
{
 800d152:	b083      	sub	sp, #12
 800d154:	460d      	mov	r5, r1
  if (hts221_temp_adc_point_0_get(&(pObj->Ctx), coeff.u8bit) != HTS221_OK)
 800d156:	4620      	mov	r0, r4
 800d158:	a901      	add	r1, sp, #4
 800d15a:	f000 faa7 	bl	800d6ac <hts221_temp_adc_point_0_get>
 800d15e:	2800      	cmp	r0, #0
 800d160:	d14b      	bne.n	800d1fa <HTS221_TEMP_GetTemperature+0xb2>
  lin_temp.x0 = (float)coeff.i16bit;
 800d162:	f9bd 3004 	ldrsh.w	r3, [sp, #4]
 800d166:	ee08 3a90 	vmov	s17, r3
  if (hts221_temp_deg_point_0_get(&(pObj->Ctx), coeff.u8bit) != HTS221_OK)
 800d16a:	a901      	add	r1, sp, #4
 800d16c:	4620      	mov	r0, r4
  lin_temp.x0 = (float)coeff.i16bit;
 800d16e:	eef8 9ae8 	vcvt.f32.s32	s19, s17
  if (hts221_temp_deg_point_0_get(&(pObj->Ctx), coeff.u8bit) != HTS221_OK)
 800d172:	f000 fa4b 	bl	800d60c <hts221_temp_deg_point_0_get>
 800d176:	2800      	cmp	r0, #0
 800d178:	d13f      	bne.n	800d1fa <HTS221_TEMP_GetTemperature+0xb2>
  lin_temp.y0 = (float)coeff.u8bit[0];
 800d17a:	f89d 3004 	ldrb.w	r3, [sp, #4]
 800d17e:	ee08 3a10 	vmov	s16, r3
  if (hts221_temp_adc_point_1_get(&(pObj->Ctx), coeff.u8bit) != HTS221_OK)
 800d182:	a901      	add	r1, sp, #4
 800d184:	4620      	mov	r0, r4
  lin_temp.y0 = (float)coeff.u8bit[0];
 800d186:	eeb8 8a48 	vcvt.f32.u32	s16, s16
  if (hts221_temp_adc_point_1_get(&(pObj->Ctx), coeff.u8bit) != HTS221_OK)
 800d18a:	f000 fa99 	bl	800d6c0 <hts221_temp_adc_point_1_get>
 800d18e:	bba0      	cbnz	r0, 800d1fa <HTS221_TEMP_GetTemperature+0xb2>
  lin_temp.x1 = (float)coeff.i16bit;
 800d190:	f9bd 3004 	ldrsh.w	r3, [sp, #4]
  if (hts221_temp_deg_point_1_get(&(pObj->Ctx), coeff.u8bit) != HTS221_OK)
 800d194:	a901      	add	r1, sp, #4
 800d196:	4620      	mov	r0, r4
  lin_temp.x1 = (float)coeff.i16bit;
 800d198:	ee08 3a90 	vmov	s17, r3
  if (hts221_temp_deg_point_1_get(&(pObj->Ctx), coeff.u8bit) != HTS221_OK)
 800d19c:	f000 fa54 	bl	800d648 <hts221_temp_deg_point_1_get>
  lin_temp.x1 = (float)coeff.i16bit;
 800d1a0:	eef8 8ae8 	vcvt.f32.s32	s17, s17
  if (hts221_temp_deg_point_1_get(&(pObj->Ctx), coeff.u8bit) != HTS221_OK)
 800d1a4:	4603      	mov	r3, r0
 800d1a6:	bb40      	cbnz	r0, 800d1fa <HTS221_TEMP_GetTemperature+0xb2>
  lin_temp.y1 = (float)coeff.u8bit[0];
 800d1a8:	f89d 2004 	ldrb.w	r2, [sp, #4]
  (void)memset(data_raw_temperature.u8bit, 0x00, sizeof(int16_t));
 800d1ac:	f8ad 3000 	strh.w	r3, [sp]
  lin_temp.y1 = (float)coeff.u8bit[0];
 800d1b0:	ee09 2a10 	vmov	s18, r2
  if (hts221_temperature_raw_get(&(pObj->Ctx), data_raw_temperature.u8bit) != HTS221_OK)
 800d1b4:	4669      	mov	r1, sp
 800d1b6:	4620      	mov	r0, r4
  lin_temp.y1 = (float)coeff.u8bit[0];
 800d1b8:	eeb8 9a49 	vcvt.f32.u32	s18, s18
  if (hts221_temperature_raw_get(&(pObj->Ctx), data_raw_temperature.u8bit) != HTS221_OK)
 800d1bc:	f000 f9e0 	bl	800d580 <hts221_temperature_raw_get>
 800d1c0:	b9d8      	cbnz	r0, 800d1fa <HTS221_TEMP_GetTemperature+0xb2>
  *Value = Linear_Interpolation(&lin_temp, (float)data_raw_temperature.i16bit);
 800d1c2:	f9bd 3000 	ldrsh.w	r3, [sp]
 800d1c6:	ee07 3a90 	vmov	s15, r3
  return (((Lin->y1 - Lin->y0) * Coeff) + ((Lin->x1 * Lin->y0) - (Lin->x0 * Lin->y1))) / (Lin->x1 - Lin->x0);
 800d1ca:	ee39 7a48 	vsub.f32	s14, s18, s16
  *Value = Linear_Interpolation(&lin_temp, (float)data_raw_temperature.i16bit);
 800d1ce:	eef8 7ae7 	vcvt.f32.s32	s15, s15
  return (((Lin->y1 - Lin->y0) * Coeff) + ((Lin->x1 * Lin->y0) - (Lin->x0 * Lin->y1))) / (Lin->x1 - Lin->x0);
 800d1d2:	ee28 8a28 	vmul.f32	s16, s16, s17
 800d1d6:	ee29 9a89 	vmul.f32	s18, s19, s18
 800d1da:	ee67 7a87 	vmul.f32	s15, s15, s14
 800d1de:	ee38 8a49 	vsub.f32	s16, s16, s18
 800d1e2:	ee78 8ae9 	vsub.f32	s17, s17, s19
 800d1e6:	ee37 8a88 	vadd.f32	s16, s15, s16
 800d1ea:	eec8 7a28 	vdiv.f32	s15, s16, s17
  *Value = Linear_Interpolation(&lin_temp, (float)data_raw_temperature.i16bit);
 800d1ee:	edc5 7a00 	vstr	s15, [r5]
}
 800d1f2:	b003      	add	sp, #12
 800d1f4:	ecbd 8b04 	vpop	{d8-d9}
 800d1f8:	bd30      	pop	{r4, r5, pc}
    return HTS221_ERROR;
 800d1fa:	f04f 30ff 	mov.w	r0, #4294967295
 800d1fe:	e7f8      	b.n	800d1f2 <HTS221_TEMP_GetTemperature+0xaa>

0800d200 <ReadRegWrap>:
 * @param  pData the stored data pointer
 * @param  Length the length
 * @retval 0 in case of success, an error code otherwise
 */
static int32_t ReadRegWrap(void *Handle, uint8_t Reg, uint8_t *pData, uint16_t Length)
{
 800d200:	b410      	push	{r4}
  HTS221_Object_t *pObj = (HTS221_Object_t *)Handle;

  if (pObj->IO.BusType == (uint32_t)HTS221_I2C_BUS) /* I2C */
 800d202:	6884      	ldr	r4, [r0, #8]
 800d204:	b93c      	cbnz	r4, 800d216 <ReadRegWrap+0x16>
  {
    /* Enable Multi-byte read */
    return pObj->IO.ReadReg(pObj->IO.Address, (Reg | 0x80U), pData, Length);
 800d206:	6944      	ldr	r4, [r0, #20]
 800d208:	7b00      	ldrb	r0, [r0, #12]
 800d20a:	46a4      	mov	ip, r4
 800d20c:	f041 0180 	orr.w	r1, r1, #128	; 0x80
  else /* SPI 3-Wires */
  {
    /* Enable Multi-byte read */
    return pObj->IO.ReadReg(pObj->IO.Address, (Reg | 0x40U), pData, Length);
  }
}
 800d210:	f85d 4b04 	ldr.w	r4, [sp], #4
    return pObj->IO.ReadReg(pObj->IO.Address, (Reg | 0x80U), pData, Length);
 800d214:	4760      	bx	ip
    return pObj->IO.ReadReg(pObj->IO.Address, (Reg | 0x40U), pData, Length);
 800d216:	6944      	ldr	r4, [r0, #20]
 800d218:	7b00      	ldrb	r0, [r0, #12]
 800d21a:	46a4      	mov	ip, r4
 800d21c:	f041 0140 	orr.w	r1, r1, #64	; 0x40
}
 800d220:	f85d 4b04 	ldr.w	r4, [sp], #4
    return pObj->IO.ReadReg(pObj->IO.Address, (Reg | 0x40U), pData, Length);
 800d224:	4760      	bx	ip
 800d226:	bf00      	nop

0800d228 <WriteRegWrap>:
 * @param  pData the stored data pointer
 * @param  Length the length
 * @retval 0 in case of success, an error code otherwise
 */
static int32_t WriteRegWrap(void *Handle, uint8_t Reg, uint8_t *pData, uint16_t Length)
{
 800d228:	b410      	push	{r4}
  HTS221_Object_t *pObj = (HTS221_Object_t *)Handle;

  if (pObj->IO.BusType == (uint32_t)HTS221_I2C_BUS) /* I2C */
 800d22a:	6884      	ldr	r4, [r0, #8]
 800d22c:	b93c      	cbnz	r4, 800d23e <WriteRegWrap+0x16>
  {
    /* Enable Multi-byte write */
    return pObj->IO.WriteReg(pObj->IO.Address, (Reg | 0x80U), pData, Length);
 800d22e:	6904      	ldr	r4, [r0, #16]
 800d230:	7b00      	ldrb	r0, [r0, #12]
 800d232:	46a4      	mov	ip, r4
 800d234:	f041 0180 	orr.w	r1, r1, #128	; 0x80
  else /* SPI 3-Wires */
  {
    /* Enable Multi-byte write */
    return pObj->IO.WriteReg(pObj->IO.Address, (Reg | 0x40U), pData, Length);
  }
}
 800d238:	f85d 4b04 	ldr.w	r4, [sp], #4
    return pObj->IO.WriteReg(pObj->IO.Address, (Reg | 0x80U), pData, Length);
 800d23c:	4760      	bx	ip
    return pObj->IO.WriteReg(pObj->IO.Address, (Reg | 0x40U), pData, Length);
 800d23e:	6904      	ldr	r4, [r0, #16]
 800d240:	7b00      	ldrb	r0, [r0, #12]
 800d242:	46a4      	mov	ip, r4
 800d244:	f041 0140 	orr.w	r1, r1, #64	; 0x40
}
 800d248:	f85d 4b04 	ldr.w	r4, [sp], #4
    return pObj->IO.WriteReg(pObj->IO.Address, (Reg | 0x40U), pData, Length);
 800d24c:	4760      	bx	ip
 800d24e:	bf00      	nop

0800d250 <HTS221_DeInit>:
{
 800d250:	b510      	push	{r4, lr}
  if (pObj->is_initialized == 1U)
 800d252:	f890 3028 	ldrb.w	r3, [r0, #40]	; 0x28
 800d256:	2b01      	cmp	r3, #1
{
 800d258:	4604      	mov	r4, r0
  if (pObj->is_initialized == 1U)
 800d25a:	d003      	beq.n	800d264 <HTS221_DeInit+0x14>
  pObj->is_initialized = 0;
 800d25c:	2000      	movs	r0, #0
 800d25e:	f884 0028 	strb.w	r0, [r4, #40]	; 0x28
}
 800d262:	bd10      	pop	{r4, pc}
  if (pObj->hum_is_enabled == 0U)
 800d264:	f890 3029 	ldrb.w	r3, [r0, #41]	; 0x29
  if (pObj->temp_is_enabled == 0U)
 800d268:	f890 102a 	ldrb.w	r1, [r0, #42]	; 0x2a
  if (pObj->hum_is_enabled == 0U)
 800d26c:	b11b      	cbz	r3, 800d276 <HTS221_DeInit+0x26>
  if (pObj->temp_is_enabled == 0U)
 800d26e:	b169      	cbz	r1, 800d28c <HTS221_DeInit+0x3c>
  pObj->hum_is_enabled = 0;
 800d270:	2300      	movs	r3, #0
 800d272:	f884 3029 	strb.w	r3, [r4, #41]	; 0x29
  if (pObj->temp_is_enabled == 0U)
 800d276:	2900      	cmp	r1, #0
 800d278:	d0f0      	beq.n	800d25c <HTS221_DeInit+0xc>
    if (hts221_power_on_set(&(pObj->Ctx), PROPERTY_DISABLE) != HTS221_OK)
 800d27a:	2100      	movs	r1, #0
 800d27c:	f104 001c 	add.w	r0, r4, #28
 800d280:	f000 f992 	bl	800d5a8 <hts221_power_on_set>
 800d284:	b948      	cbnz	r0, 800d29a <HTS221_DeInit+0x4a>
  pObj->temp_is_enabled = 0;
 800d286:	f884 002a 	strb.w	r0, [r4, #42]	; 0x2a
  return HTS221_OK;
 800d28a:	e7e7      	b.n	800d25c <HTS221_DeInit+0xc>
    if (hts221_power_on_set(&(pObj->Ctx), PROPERTY_DISABLE) != HTS221_OK)
 800d28c:	301c      	adds	r0, #28
 800d28e:	f000 f98b 	bl	800d5a8 <hts221_power_on_set>
 800d292:	b910      	cbnz	r0, 800d29a <HTS221_DeInit+0x4a>
  if (pObj->temp_is_enabled == 0U)
 800d294:	f894 102a 	ldrb.w	r1, [r4, #42]	; 0x2a
 800d298:	e7ea      	b.n	800d270 <HTS221_DeInit+0x20>
      return HTS221_ERROR;
 800d29a:	f04f 30ff 	mov.w	r0, #4294967295
}
 800d29e:	bd10      	pop	{r4, pc}

0800d2a0 <HTS221_TEMP_SetOutputDataRate>:
 800d2a0:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
 800d2a4:	eeb4 0ae7 	vcmpe.f32	s0, s15
 800d2a8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800d2ac:	b508      	push	{r3, lr}
 800d2ae:	d910      	bls.n	800d2d2 <HTS221_TEMP_SetOutputDataRate+0x32>
 800d2b0:	eef1 7a0c 	vmov.f32	s15, #28	; 0x40e00000  7.0
 800d2b4:	eeb4 0ae7 	vcmpe.f32	s0, s15
 800d2b8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800d2bc:	bf94      	ite	ls
 800d2be:	2102      	movls	r1, #2
 800d2c0:	2103      	movhi	r1, #3
 800d2c2:	301c      	adds	r0, #28
 800d2c4:	f000 f8de 	bl	800d484 <hts221_data_rate_set>
 800d2c8:	3800      	subs	r0, #0
 800d2ca:	bf18      	it	ne
 800d2cc:	2001      	movne	r0, #1
 800d2ce:	4240      	negs	r0, r0
 800d2d0:	bd08      	pop	{r3, pc}
 800d2d2:	2101      	movs	r1, #1
 800d2d4:	e7f5      	b.n	800d2c2 <HTS221_TEMP_SetOutputDataRate+0x22>
 800d2d6:	bf00      	nop

0800d2d8 <HTS221_TEMP_GetOutputDataRate>:
 800d2d8:	b510      	push	{r4, lr}
 800d2da:	b082      	sub	sp, #8
 800d2dc:	460c      	mov	r4, r1
 800d2de:	301c      	adds	r0, #28
 800d2e0:	f10d 0107 	add.w	r1, sp, #7
 800d2e4:	f000 f8e8 	bl	800d4b8 <hts221_data_rate_get>
 800d2e8:	b9c0      	cbnz	r0, 800d31c <HTS221_TEMP_GetOutputDataRate+0x44>
 800d2ea:	f89d 3007 	ldrb.w	r3, [sp, #7]
 800d2ee:	2b03      	cmp	r3, #3
 800d2f0:	d814      	bhi.n	800d31c <HTS221_TEMP_GetOutputDataRate+0x44>
 800d2f2:	e8df f003 	tbb	[pc, r3]
 800d2f6:	0a06      	.short	0x0a06
 800d2f8:	020f      	.short	0x020f
 800d2fa:	4b0a      	ldr	r3, [pc, #40]	; (800d324 <HTS221_TEMP_GetOutputDataRate+0x4c>)
 800d2fc:	6023      	str	r3, [r4, #0]
 800d2fe:	b002      	add	sp, #8
 800d300:	bd10      	pop	{r4, pc}
 800d302:	2300      	movs	r3, #0
 800d304:	6023      	str	r3, [r4, #0]
 800d306:	b002      	add	sp, #8
 800d308:	bd10      	pop	{r4, pc}
 800d30a:	f04f 537e 	mov.w	r3, #1065353216	; 0x3f800000
 800d30e:	6023      	str	r3, [r4, #0]
 800d310:	b002      	add	sp, #8
 800d312:	bd10      	pop	{r4, pc}
 800d314:	4b04      	ldr	r3, [pc, #16]	; (800d328 <HTS221_TEMP_GetOutputDataRate+0x50>)
 800d316:	6023      	str	r3, [r4, #0]
 800d318:	b002      	add	sp, #8
 800d31a:	bd10      	pop	{r4, pc}
 800d31c:	f04f 30ff 	mov.w	r0, #4294967295
 800d320:	e7ed      	b.n	800d2fe <HTS221_TEMP_GetOutputDataRate+0x26>
 800d322:	bf00      	nop
 800d324:	41480000 	.word	0x41480000
 800d328:	40e00000 	.word	0x40e00000

0800d32c <HTS221_HUM_SetOutputDataRate>:
            : (Odr <= 7.0f) ? HTS221_ODR_7Hz
 800d32c:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
 800d330:	eeb4 0ae7 	vcmpe.f32	s0, s15
 800d334:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
{
 800d338:	b508      	push	{r3, lr}
            : (Odr <= 7.0f) ? HTS221_ODR_7Hz
 800d33a:	d910      	bls.n	800d35e <HTS221_HUM_SetOutputDataRate+0x32>
 800d33c:	eef1 7a0c 	vmov.f32	s15, #28	; 0x40e00000  7.0
 800d340:	eeb4 0ae7 	vcmpe.f32	s0, s15
 800d344:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800d348:	bf94      	ite	ls
 800d34a:	2102      	movls	r1, #2
 800d34c:	2103      	movhi	r1, #3
  if (hts221_data_rate_set(&(pObj->Ctx), new_odr) != HTS221_OK)
 800d34e:	301c      	adds	r0, #28
 800d350:	f000 f898 	bl	800d484 <hts221_data_rate_set>
 800d354:	3800      	subs	r0, #0
 800d356:	bf18      	it	ne
 800d358:	2001      	movne	r0, #1
}
 800d35a:	4240      	negs	r0, r0
 800d35c:	bd08      	pop	{r3, pc}
            : (Odr <= 7.0f) ? HTS221_ODR_7Hz
 800d35e:	2101      	movs	r1, #1
 800d360:	e7f5      	b.n	800d34e <HTS221_HUM_SetOutputDataRate+0x22>
 800d362:	bf00      	nop

0800d364 <HTS221_TEMP_Disable>:
{
 800d364:	b510      	push	{r4, lr}
 800d366:	4604      	mov	r4, r0
  if (pObj->temp_is_enabled == 0U)
 800d368:	f890 002a 	ldrb.w	r0, [r0, #42]	; 0x2a
 800d36c:	b130      	cbz	r0, 800d37c <HTS221_TEMP_Disable+0x18>
  if (pObj->hum_is_enabled == 0U)
 800d36e:	f894 1029 	ldrb.w	r1, [r4, #41]	; 0x29
 800d372:	b121      	cbz	r1, 800d37e <HTS221_TEMP_Disable+0x1a>
  pObj->temp_is_enabled = 0;
 800d374:	2300      	movs	r3, #0
 800d376:	f884 302a 	strb.w	r3, [r4, #42]	; 0x2a
  return HTS221_OK;
 800d37a:	4618      	mov	r0, r3
}
 800d37c:	bd10      	pop	{r4, pc}
    if (hts221_power_on_set(&(pObj->Ctx), PROPERTY_DISABLE) != HTS221_OK)
 800d37e:	f104 001c 	add.w	r0, r4, #28
 800d382:	f000 f911 	bl	800d5a8 <hts221_power_on_set>
 800d386:	2800      	cmp	r0, #0
 800d388:	d0f4      	beq.n	800d374 <HTS221_TEMP_Disable+0x10>
      return HTS221_ERROR;
 800d38a:	f04f 30ff 	mov.w	r0, #4294967295
}
 800d38e:	bd10      	pop	{r4, pc}

0800d390 <HTS221_HUM_Disable>:
{
 800d390:	b510      	push	{r4, lr}
 800d392:	4604      	mov	r4, r0
  if (pObj->hum_is_enabled == 0U)
 800d394:	f890 0029 	ldrb.w	r0, [r0, #41]	; 0x29
 800d398:	b130      	cbz	r0, 800d3a8 <HTS221_HUM_Disable+0x18>
  if (pObj->temp_is_enabled == 0U)
 800d39a:	f894 102a 	ldrb.w	r1, [r4, #42]	; 0x2a
 800d39e:	b121      	cbz	r1, 800d3aa <HTS221_HUM_Disable+0x1a>
  pObj->hum_is_enabled = 0;
 800d3a0:	2300      	movs	r3, #0
 800d3a2:	f884 3029 	strb.w	r3, [r4, #41]	; 0x29
  return HTS221_OK;
 800d3a6:	4618      	mov	r0, r3
}
 800d3a8:	bd10      	pop	{r4, pc}
    if (hts221_power_on_set(&(pObj->Ctx), PROPERTY_DISABLE) != HTS221_OK)
 800d3aa:	f104 001c 	add.w	r0, r4, #28
 800d3ae:	f000 f8fb 	bl	800d5a8 <hts221_power_on_set>
 800d3b2:	2800      	cmp	r0, #0
 800d3b4:	d0f4      	beq.n	800d3a0 <HTS221_HUM_Disable+0x10>
      return HTS221_ERROR;
 800d3b6:	f04f 30ff 	mov.w	r0, #4294967295
}
 800d3ba:	bd10      	pop	{r4, pc}

0800d3bc <HTS221_HUM_GetOutputDataRate>:
{
 800d3bc:	b510      	push	{r4, lr}
 800d3be:	b082      	sub	sp, #8
 800d3c0:	460c      	mov	r4, r1
  if (hts221_data_rate_get(&(pObj->Ctx), &odr_low_level) != HTS221_OK)
 800d3c2:	301c      	adds	r0, #28
 800d3c4:	f10d 0107 	add.w	r1, sp, #7
 800d3c8:	f000 f876 	bl	800d4b8 <hts221_data_rate_get>
 800d3cc:	b9c0      	cbnz	r0, 800d400 <HTS221_HUM_GetOutputDataRate+0x44>
  switch (odr_low_level)
 800d3ce:	f89d 3007 	ldrb.w	r3, [sp, #7]
 800d3d2:	2b03      	cmp	r3, #3
 800d3d4:	d814      	bhi.n	800d400 <HTS221_HUM_GetOutputDataRate+0x44>
 800d3d6:	e8df f003 	tbb	[pc, r3]
 800d3da:	0a06      	.short	0x0a06
 800d3dc:	020f      	.short	0x020f
      *Odr = 12.5f;
 800d3de:	4b0a      	ldr	r3, [pc, #40]	; (800d408 <HTS221_HUM_GetOutputDataRate+0x4c>)
 800d3e0:	6023      	str	r3, [r4, #0]
}
 800d3e2:	b002      	add	sp, #8
 800d3e4:	bd10      	pop	{r4, pc}
      *Odr = 0.0f;
 800d3e6:	2300      	movs	r3, #0
 800d3e8:	6023      	str	r3, [r4, #0]
}
 800d3ea:	b002      	add	sp, #8
 800d3ec:	bd10      	pop	{r4, pc}
      *Odr = 1.0f;
 800d3ee:	f04f 537e 	mov.w	r3, #1065353216	; 0x3f800000
 800d3f2:	6023      	str	r3, [r4, #0]
}
 800d3f4:	b002      	add	sp, #8
 800d3f6:	bd10      	pop	{r4, pc}
      *Odr = 7.0f;
 800d3f8:	4b04      	ldr	r3, [pc, #16]	; (800d40c <HTS221_HUM_GetOutputDataRate+0x50>)
 800d3fa:	6023      	str	r3, [r4, #0]
}
 800d3fc:	b002      	add	sp, #8
 800d3fe:	bd10      	pop	{r4, pc}
  switch (odr_low_level)
 800d400:	f04f 30ff 	mov.w	r0, #4294967295
  return HTS221_GetOutputDataRate(pObj, Odr);
 800d404:	e7ed      	b.n	800d3e2 <HTS221_HUM_GetOutputDataRate+0x26>
 800d406:	bf00      	nop
 800d408:	41480000 	.word	0x41480000
 800d40c:	40e00000 	.word	0x40e00000

0800d410 <HTS221_RegisterBusIO>:
  if (pObj == NULL)
 800d410:	b1e0      	cbz	r0, 800d44c <HTS221_RegisterBusIO+0x3c>
{
 800d412:	b410      	push	{r4}
    pObj->IO.DeInit    = pIO->DeInit;
 800d414:	e9d1 3400 	ldrd	r3, r4, [r1]
    pObj->IO.BusType   = pIO->BusType;
 800d418:	688a      	ldr	r2, [r1, #8]
 800d41a:	6082      	str	r2, [r0, #8]
    pObj->IO.DeInit    = pIO->DeInit;
 800d41c:	e9c0 3400 	strd	r3, r4, [r0]
    pObj->IO.Address   = pIO->Address;
 800d420:	7b0a      	ldrb	r2, [r1, #12]
 800d422:	7302      	strb	r2, [r0, #12]
    pObj->IO.ReadReg   = pIO->ReadReg;
 800d424:	e9d1 4204 	ldrd	r4, r2, [r1, #16]
    pObj->IO.GetTick   = pIO->GetTick;
 800d428:	6989      	ldr	r1, [r1, #24]
 800d42a:	6181      	str	r1, [r0, #24]
    pObj->IO.ReadReg   = pIO->ReadReg;
 800d42c:	e9c0 4204 	strd	r4, r2, [r0, #16]
    pObj->Ctx.read_reg  = ReadRegWrap;
 800d430:	4908      	ldr	r1, [pc, #32]	; (800d454 <HTS221_RegisterBusIO+0x44>)
    pObj->Ctx.write_reg = WriteRegWrap;
 800d432:	4a09      	ldr	r2, [pc, #36]	; (800d458 <HTS221_RegisterBusIO+0x48>)
    pObj->Ctx.handle   = pObj;
 800d434:	6240      	str	r0, [r0, #36]	; 0x24
    pObj->Ctx.write_reg = WriteRegWrap;
 800d436:	e9c0 2107 	strd	r2, r1, [r0, #28]
    if (pObj->IO.Init != NULL)
 800d43a:	b113      	cbz	r3, 800d442 <HTS221_RegisterBusIO+0x32>
}
 800d43c:	f85d 4b04 	ldr.w	r4, [sp], #4
      ret = pObj->IO.Init();
 800d440:	4718      	bx	r3
}
 800d442:	f04f 30ff 	mov.w	r0, #4294967295
 800d446:	f85d 4b04 	ldr.w	r4, [sp], #4
 800d44a:	4770      	bx	lr
 800d44c:	f04f 30ff 	mov.w	r0, #4294967295
 800d450:	4770      	bx	lr
 800d452:	bf00      	nop
 800d454:	0800d201 	.word	0x0800d201
 800d458:	0800d229 	.word	0x0800d229

0800d45c <HTS221_Set_One_Shot>:
{
 800d45c:	b510      	push	{r4, lr}
  if(hts221_data_rate_set(&(pObj->Ctx), HTS221_ONE_SHOT)!= HTS221_OK)
 800d45e:	f100 041c 	add.w	r4, r0, #28
 800d462:	2100      	movs	r1, #0
 800d464:	4620      	mov	r0, r4
 800d466:	f000 f80d 	bl	800d484 <hts221_data_rate_set>
 800d46a:	b940      	cbnz	r0, 800d47e <HTS221_Set_One_Shot+0x22>
  if(hts221_one_shoot_trigger_set(&(pObj->Ctx), 1) != HTS221_OK)
 800d46c:	2101      	movs	r1, #1
 800d46e:	4620      	mov	r0, r4
 800d470:	f000 f862 	bl	800d538 <hts221_one_shoot_trigger_set>
 800d474:	3800      	subs	r0, #0
 800d476:	bf18      	it	ne
 800d478:	2001      	movne	r0, #1
 800d47a:	4240      	negs	r0, r0
}
 800d47c:	bd10      	pop	{r4, pc}
    return HTS221_ERROR;
 800d47e:	f04f 30ff 	mov.w	r0, #4294967295
}
 800d482:	bd10      	pop	{r4, pc}

0800d484 <hts221_data_rate_set>:
  * @param  val     change the values of odr in reg CTRL_REG1
  * @retval         interface status (MANDATORY: return 0 -> no Error)
  *
  */
int32_t hts221_data_rate_set(hts221_ctx_t *ctx, hts221_odr_t val)
{
 800d484:	b570      	push	{r4, r5, r6, lr}
 800d486:	4604      	mov	r4, r0
 800d488:	b082      	sub	sp, #8
 800d48a:	460d      	mov	r5, r1
  ret = ctx->read_reg(ctx->handle, reg, data, len);
 800d48c:	6880      	ldr	r0, [r0, #8]
 800d48e:	6866      	ldr	r6, [r4, #4]
 800d490:	2301      	movs	r3, #1
 800d492:	aa01      	add	r2, sp, #4
 800d494:	2120      	movs	r1, #32
 800d496:	47b0      	blx	r6
  hts221_ctrl_reg1_t reg;
  int32_t ret;

  ret = hts221_read_reg(ctx, HTS221_CTRL_REG1, (uint8_t*) &reg, 1);

  if(ret == 0){
 800d498:	b958      	cbnz	r0, 800d4b2 <hts221_data_rate_set+0x2e>
    reg.odr = (uint8_t)val;
 800d49a:	f89d 3004 	ldrb.w	r3, [sp, #4]
  ret = ctx->write_reg(ctx->handle, reg, data, len);
 800d49e:	6826      	ldr	r6, [r4, #0]
 800d4a0:	68a0      	ldr	r0, [r4, #8]
    reg.odr = (uint8_t)val;
 800d4a2:	f365 0301 	bfi	r3, r5, #0, #2
 800d4a6:	f88d 3004 	strb.w	r3, [sp, #4]
  ret = ctx->write_reg(ctx->handle, reg, data, len);
 800d4aa:	aa01      	add	r2, sp, #4
 800d4ac:	2301      	movs	r3, #1
 800d4ae:	2120      	movs	r1, #32
 800d4b0:	47b0      	blx	r6
    ret = hts221_write_reg(ctx, HTS221_CTRL_REG1, (uint8_t*) &reg, 1);
  }

  return ret;
}
 800d4b2:	b002      	add	sp, #8
 800d4b4:	bd70      	pop	{r4, r5, r6, pc}
 800d4b6:	bf00      	nop

0800d4b8 <hts221_data_rate_get>:
  * @param  val     Get the values of odr in reg CTRL_REG1
  * @retval         interface status (MANDATORY: return 0 -> no Error)
  *
  */
int32_t hts221_data_rate_get(hts221_ctx_t *ctx, hts221_odr_t *val)
{
 800d4b8:	b530      	push	{r4, r5, lr}
 800d4ba:	b083      	sub	sp, #12
  ret = ctx->read_reg(ctx->handle, reg, data, len);
 800d4bc:	2301      	movs	r3, #1
 800d4be:	e9d0 4001 	ldrd	r4, r0, [r0, #4]
 800d4c2:	aa01      	add	r2, sp, #4
{
 800d4c4:	460d      	mov	r5, r1
  ret = ctx->read_reg(ctx->handle, reg, data, len);
 800d4c6:	2120      	movs	r1, #32
 800d4c8:	47a0      	blx	r4
  hts221_ctrl_reg1_t reg;
  int32_t ret;

  ret = hts221_read_reg(ctx, HTS221_CTRL_REG1, (uint8_t*) &reg, 1);

  switch (reg.odr) {
 800d4ca:	f89d 3004 	ldrb.w	r3, [sp, #4]
 800d4ce:	f003 0303 	and.w	r3, r3, #3
 800d4d2:	2b03      	cmp	r3, #3
 800d4d4:	d813      	bhi.n	800d4fe <hts221_data_rate_get+0x46>
 800d4d6:	e8df f003 	tbb	[pc, r3]
 800d4da:	0a0e      	.short	0x0a0e
 800d4dc:	0206      	.short	0x0206
      break;
    case HTS221_ODR_7Hz:
      *val = HTS221_ODR_7Hz;
      break;
    case HTS221_ODR_12Hz5:
      *val = HTS221_ODR_12Hz5;
 800d4de:	2303      	movs	r3, #3
 800d4e0:	702b      	strb	r3, [r5, #0]
      *val = HTS221_ODR_ND;
      break;
  }

  return ret;
}
 800d4e2:	b003      	add	sp, #12
 800d4e4:	bd30      	pop	{r4, r5, pc}
      *val = HTS221_ODR_7Hz;
 800d4e6:	2302      	movs	r3, #2
 800d4e8:	702b      	strb	r3, [r5, #0]
}
 800d4ea:	b003      	add	sp, #12
 800d4ec:	bd30      	pop	{r4, r5, pc}
      *val = HTS221_ODR_1Hz;
 800d4ee:	2301      	movs	r3, #1
 800d4f0:	702b      	strb	r3, [r5, #0]
}
 800d4f2:	b003      	add	sp, #12
 800d4f4:	bd30      	pop	{r4, r5, pc}
      *val = HTS221_ONE_SHOT;
 800d4f6:	2300      	movs	r3, #0
 800d4f8:	702b      	strb	r3, [r5, #0]
}
 800d4fa:	b003      	add	sp, #12
 800d4fc:	bd30      	pop	{r4, r5, pc}
      *val = HTS221_ODR_ND;
 800d4fe:	2304      	movs	r3, #4
 800d500:	702b      	strb	r3, [r5, #0]
  return ret;
 800d502:	e7ee      	b.n	800d4e2 <hts221_data_rate_get+0x2a>

0800d504 <hts221_block_data_update_set>:
  * @param  val     change the values of bdu in reg CTRL_REG1
  * @retval         interface status (MANDATORY: return 0 -> no Error)
  *
  */
int32_t hts221_block_data_update_set(hts221_ctx_t *ctx, uint8_t val)
{
 800d504:	b570      	push	{r4, r5, r6, lr}
 800d506:	4604      	mov	r4, r0
 800d508:	b082      	sub	sp, #8
 800d50a:	460d      	mov	r5, r1
  ret = ctx->read_reg(ctx->handle, reg, data, len);
 800d50c:	6880      	ldr	r0, [r0, #8]
 800d50e:	6866      	ldr	r6, [r4, #4]
 800d510:	2301      	movs	r3, #1
 800d512:	aa01      	add	r2, sp, #4
 800d514:	2120      	movs	r1, #32
 800d516:	47b0      	blx	r6
  hts221_ctrl_reg1_t reg;
  int32_t ret;

  ret = hts221_read_reg(ctx, HTS221_CTRL_REG1, (uint8_t*) &reg, 1);

  if(ret == 0){
 800d518:	b958      	cbnz	r0, 800d532 <hts221_block_data_update_set+0x2e>
    reg.bdu = val;
 800d51a:	f89d 3004 	ldrb.w	r3, [sp, #4]
  ret = ctx->write_reg(ctx->handle, reg, data, len);
 800d51e:	6826      	ldr	r6, [r4, #0]
 800d520:	68a0      	ldr	r0, [r4, #8]
    reg.bdu = val;
 800d522:	f365 0382 	bfi	r3, r5, #2, #1
 800d526:	f88d 3004 	strb.w	r3, [sp, #4]
  ret = ctx->write_reg(ctx->handle, reg, data, len);
 800d52a:	aa01      	add	r2, sp, #4
 800d52c:	2301      	movs	r3, #1
 800d52e:	2120      	movs	r1, #32
 800d530:	47b0      	blx	r6
    ret = hts221_write_reg(ctx, HTS221_CTRL_REG1, (uint8_t*) &reg, 1);
  }

  return ret;
}
 800d532:	b002      	add	sp, #8
 800d534:	bd70      	pop	{r4, r5, r6, pc}
 800d536:	bf00      	nop

0800d538 <hts221_one_shoot_trigger_set>:
  * @param  val     change the values of one_shot in reg CTRL_REG2
  * @retval         interface status (MANDATORY: return 0 -> no Error)
  *
  */
int32_t hts221_one_shoot_trigger_set(hts221_ctx_t *ctx, uint8_t val)
{
 800d538:	b570      	push	{r4, r5, r6, lr}
 800d53a:	4604      	mov	r4, r0
 800d53c:	b082      	sub	sp, #8
 800d53e:	460d      	mov	r5, r1
  ret = ctx->read_reg(ctx->handle, reg, data, len);
 800d540:	6880      	ldr	r0, [r0, #8]
 800d542:	6866      	ldr	r6, [r4, #4]
 800d544:	2301      	movs	r3, #1
 800d546:	aa01      	add	r2, sp, #4
 800d548:	2121      	movs	r1, #33	; 0x21
 800d54a:	47b0      	blx	r6
  hts221_ctrl_reg2_t reg;
  int32_t ret;

  ret = hts221_read_reg(ctx, HTS221_CTRL_REG2, (uint8_t*) &reg, 1);

  if(ret == 0){
 800d54c:	b958      	cbnz	r0, 800d566 <hts221_one_shoot_trigger_set+0x2e>
    reg.one_shot = val;
 800d54e:	f89d 3004 	ldrb.w	r3, [sp, #4]
  ret = ctx->write_reg(ctx->handle, reg, data, len);
 800d552:	6826      	ldr	r6, [r4, #0]
 800d554:	68a0      	ldr	r0, [r4, #8]
    reg.one_shot = val;
 800d556:	f365 0300 	bfi	r3, r5, #0, #1
 800d55a:	f88d 3004 	strb.w	r3, [sp, #4]
  ret = ctx->write_reg(ctx->handle, reg, data, len);
 800d55e:	aa01      	add	r2, sp, #4
 800d560:	2301      	movs	r3, #1
 800d562:	2121      	movs	r1, #33	; 0x21
 800d564:	47b0      	blx	r6
    ret = hts221_write_reg(ctx, HTS221_CTRL_REG2, (uint8_t*) &reg, 1);
  }

  return ret;
}
 800d566:	b002      	add	sp, #8
 800d568:	bd70      	pop	{r4, r5, r6, pc}
 800d56a:	bf00      	nop

0800d56c <hts221_humidity_raw_get>:
  * @param  buff    buffer that stores data read
  * @retval         interface status (MANDATORY: return 0 -> no Error)
  *
  */
int32_t hts221_humidity_raw_get(hts221_ctx_t *ctx, uint8_t *buff)
{
 800d56c:	b410      	push	{r4}
  ret = ctx->read_reg(ctx->handle, reg, data, len);
 800d56e:	e9d0 4001 	ldrd	r4, r0, [r0, #4]
{
 800d572:	460a      	mov	r2, r1
  ret = ctx->read_reg(ctx->handle, reg, data, len);
 800d574:	46a4      	mov	ip, r4
 800d576:	2302      	movs	r3, #2
  int32_t ret;
  ret = hts221_read_reg(ctx, HTS221_HUMIDITY_OUT_L, buff, 2);
  return ret;
}
 800d578:	f85d 4b04 	ldr.w	r4, [sp], #4
  ret = ctx->read_reg(ctx->handle, reg, data, len);
 800d57c:	2128      	movs	r1, #40	; 0x28
 800d57e:	4760      	bx	ip

0800d580 <hts221_temperature_raw_get>:
  * @param  buff    buffer that stores data read
  * @retval         interface status (MANDATORY: return 0 -> no Error)
  *
  */
int32_t hts221_temperature_raw_get(hts221_ctx_t *ctx, uint8_t *buff)
{
 800d580:	b410      	push	{r4}
  ret = ctx->read_reg(ctx->handle, reg, data, len);
 800d582:	e9d0 4001 	ldrd	r4, r0, [r0, #4]
{
 800d586:	460a      	mov	r2, r1
  ret = ctx->read_reg(ctx->handle, reg, data, len);
 800d588:	46a4      	mov	ip, r4
 800d58a:	2302      	movs	r3, #2
  int32_t ret;
  ret = hts221_read_reg(ctx, HTS221_TEMP_OUT_L, buff, 2);
  return ret;
}
 800d58c:	f85d 4b04 	ldr.w	r4, [sp], #4
  ret = ctx->read_reg(ctx->handle, reg, data, len);
 800d590:	212a      	movs	r1, #42	; 0x2a
 800d592:	4760      	bx	ip

0800d594 <hts221_device_id_get>:
  * @param  buff    buffer that stores data read
  * @retval         interface status (MANDATORY: return 0 -> no Error)
  *
  */
int32_t hts221_device_id_get(hts221_ctx_t *ctx, uint8_t *buff)
{
 800d594:	b410      	push	{r4}
  ret = ctx->read_reg(ctx->handle, reg, data, len);
 800d596:	e9d0 4001 	ldrd	r4, r0, [r0, #4]
{
 800d59a:	460a      	mov	r2, r1
  ret = ctx->read_reg(ctx->handle, reg, data, len);
 800d59c:	46a4      	mov	ip, r4
 800d59e:	2301      	movs	r3, #1
  int32_t ret;
  ret = hts221_read_reg(ctx, HTS221_WHO_AM_I, buff, 1);
  return ret;
}
 800d5a0:	f85d 4b04 	ldr.w	r4, [sp], #4
  ret = ctx->read_reg(ctx->handle, reg, data, len);
 800d5a4:	210f      	movs	r1, #15
 800d5a6:	4760      	bx	ip

0800d5a8 <hts221_power_on_set>:
  * @param  val     change the values of pd in reg CTRL_REG1
  * @retval         interface status (MANDATORY: return 0 -> no Error)
  *
  */
int32_t hts221_power_on_set(hts221_ctx_t *ctx, uint8_t val)
{
 800d5a8:	b570      	push	{r4, r5, r6, lr}
 800d5aa:	4604      	mov	r4, r0
 800d5ac:	b082      	sub	sp, #8
 800d5ae:	460d      	mov	r5, r1
  ret = ctx->read_reg(ctx->handle, reg, data, len);
 800d5b0:	6880      	ldr	r0, [r0, #8]
 800d5b2:	6866      	ldr	r6, [r4, #4]
 800d5b4:	2301      	movs	r3, #1
 800d5b6:	aa01      	add	r2, sp, #4
 800d5b8:	2120      	movs	r1, #32
 800d5ba:	47b0      	blx	r6
  hts221_ctrl_reg1_t reg;
  int32_t ret;

  ret = hts221_read_reg(ctx, HTS221_CTRL_REG1, (uint8_t*) &reg, 1);

  if(ret == 0){
 800d5bc:	b958      	cbnz	r0, 800d5d6 <hts221_power_on_set+0x2e>
    reg.pd = val;
 800d5be:	f89d 3004 	ldrb.w	r3, [sp, #4]
  ret = ctx->write_reg(ctx->handle, reg, data, len);
 800d5c2:	6826      	ldr	r6, [r4, #0]
 800d5c4:	68a0      	ldr	r0, [r4, #8]
    reg.pd = val;
 800d5c6:	f365 13c7 	bfi	r3, r5, #7, #1
 800d5ca:	f88d 3004 	strb.w	r3, [sp, #4]
  ret = ctx->write_reg(ctx->handle, reg, data, len);
 800d5ce:	aa01      	add	r2, sp, #4
 800d5d0:	2301      	movs	r3, #1
 800d5d2:	2120      	movs	r1, #32
 800d5d4:	47b0      	blx	r6
    ret = hts221_write_reg(ctx, HTS221_CTRL_REG1, (uint8_t*) &reg, 1);
  }
  return ret;
}
 800d5d6:	b002      	add	sp, #8
 800d5d8:	bd70      	pop	{r4, r5, r6, pc}
 800d5da:	bf00      	nop

0800d5dc <hts221_hum_rh_point_0_get>:
  * @param  buff    buffer that stores data read
  * @retval         interface status (MANDATORY: return 0 -> no Error)
  *
  */
int32_t hts221_hum_rh_point_0_get(hts221_ctx_t *ctx, uint8_t *buff)
{
 800d5dc:	b538      	push	{r3, r4, r5, lr}
 800d5de:	460c      	mov	r4, r1
  ret = ctx->read_reg(ctx->handle, reg, data, len);
 800d5e0:	460a      	mov	r2, r1
 800d5e2:	e9d0 5001 	ldrd	r5, r0, [r0, #4]
 800d5e6:	2301      	movs	r3, #1
 800d5e8:	2130      	movs	r1, #48	; 0x30
 800d5ea:	47a8      	blx	r5
  int32_t ret;

  ret = hts221_read_reg(ctx, HTS221_H0_RH_X2, buff, 1);
  *buff = (uint8_t)(((uint16_t)(*buff) >> 1) & 0x7FFFu);
 800d5ec:	7823      	ldrb	r3, [r4, #0]
 800d5ee:	085b      	lsrs	r3, r3, #1
 800d5f0:	7023      	strb	r3, [r4, #0]

  return ret;
}
 800d5f2:	bd38      	pop	{r3, r4, r5, pc}

0800d5f4 <hts221_hum_rh_point_1_get>:
  * @param  buff    buffer that stores data read
  * @retval         interface status (MANDATORY: return 0 -> no Error)
  *
  */
int32_t hts221_hum_rh_point_1_get(hts221_ctx_t *ctx, uint8_t *buff)
{
 800d5f4:	b538      	push	{r3, r4, r5, lr}
 800d5f6:	460c      	mov	r4, r1
  ret = ctx->read_reg(ctx->handle, reg, data, len);
 800d5f8:	460a      	mov	r2, r1
 800d5fa:	e9d0 5001 	ldrd	r5, r0, [r0, #4]
 800d5fe:	2301      	movs	r3, #1
 800d600:	2131      	movs	r1, #49	; 0x31
 800d602:	47a8      	blx	r5
  int32_t ret;

  ret = hts221_read_reg(ctx, HTS221_H1_RH_X2, buff, 1);
  *buff = (uint8_t)(((uint16_t)(*buff) >> 1) & 0x7FFFu);
 800d604:	7823      	ldrb	r3, [r4, #0]
 800d606:	085b      	lsrs	r3, r3, #1
 800d608:	7023      	strb	r3, [r4, #0]

  return ret;
}
 800d60a:	bd38      	pop	{r3, r4, r5, pc}

0800d60c <hts221_temp_deg_point_0_get>:
  * @param  buff    buffer that stores data read
  * @retval         interface status (MANDATORY: return 0 -> no Error)
  *
  */
int32_t hts221_temp_deg_point_0_get(hts221_ctx_t *ctx, uint8_t *buff)
{
 800d60c:	b570      	push	{r4, r5, r6, lr}
 800d60e:	4604      	mov	r4, r0
 800d610:	b082      	sub	sp, #8
 800d612:	460d      	mov	r5, r1
  ret = ctx->read_reg(ctx->handle, reg, data, len);
 800d614:	6880      	ldr	r0, [r0, #8]
 800d616:	6866      	ldr	r6, [r4, #4]
 800d618:	2301      	movs	r3, #1
 800d61a:	f10d 0207 	add.w	r2, sp, #7
 800d61e:	2132      	movs	r1, #50	; 0x32
 800d620:	47b0      	blx	r6
  uint8_t coeff_h, coeff_l;
  int32_t ret;

  ret = hts221_read_reg(ctx, HTS221_T0_DEGC_X8, &coeff_l, 1);

  if(ret == 0){
 800d622:	b978      	cbnz	r0, 800d644 <hts221_temp_deg_point_0_get+0x38>
  ret = ctx->read_reg(ctx->handle, reg, data, len);
 800d624:	2301      	movs	r3, #1
 800d626:	aa01      	add	r2, sp, #4
 800d628:	e9d4 6001 	ldrd	r6, r0, [r4, #4]
 800d62c:	2135      	movs	r1, #53	; 0x35
 800d62e:	47b0      	blx	r6
    ret = hts221_read_reg(ctx, HTS221_T1_T0_MSB, (uint8_t*) &reg, 1);
    coeff_h = reg.t0_msb;
 800d630:	f89d 2004 	ldrb.w	r2, [sp, #4]
    *(buff) = (uint8_t)(((coeff_h << 8) + coeff_l) >> 3);
 800d634:	f89d 3007 	ldrb.w	r3, [sp, #7]
 800d638:	f002 0203 	and.w	r2, r2, #3
 800d63c:	eb03 2302 	add.w	r3, r3, r2, lsl #8
 800d640:	10db      	asrs	r3, r3, #3
 800d642:	702b      	strb	r3, [r5, #0]
  }

  return ret;
}
 800d644:	b002      	add	sp, #8
 800d646:	bd70      	pop	{r4, r5, r6, pc}

0800d648 <hts221_temp_deg_point_1_get>:
  * @param  buff    buffer that stores data read
  * @retval         interface status (MANDATORY: return 0 -> no Error)
  *
  */
int32_t hts221_temp_deg_point_1_get(hts221_ctx_t *ctx, uint8_t *buff)
{
 800d648:	b570      	push	{r4, r5, r6, lr}
 800d64a:	4604      	mov	r4, r0
 800d64c:	b082      	sub	sp, #8
 800d64e:	460d      	mov	r5, r1
  ret = ctx->read_reg(ctx->handle, reg, data, len);
 800d650:	6880      	ldr	r0, [r0, #8]
 800d652:	6866      	ldr	r6, [r4, #4]
 800d654:	2301      	movs	r3, #1
 800d656:	f10d 0207 	add.w	r2, sp, #7
 800d65a:	2133      	movs	r1, #51	; 0x33
 800d65c:	47b0      	blx	r6
  uint8_t coeff_h, coeff_l;
  int32_t ret;

  ret = hts221_read_reg(ctx, HTS221_T1_DEGC_X8, &coeff_l, 1);

  if(ret == 0){
 800d65e:	b978      	cbnz	r0, 800d680 <hts221_temp_deg_point_1_get+0x38>
  ret = ctx->read_reg(ctx->handle, reg, data, len);
 800d660:	2301      	movs	r3, #1
 800d662:	aa01      	add	r2, sp, #4
 800d664:	e9d4 6001 	ldrd	r6, r0, [r4, #4]
 800d668:	2135      	movs	r1, #53	; 0x35
 800d66a:	47b0      	blx	r6
    ret = hts221_read_reg(ctx, HTS221_T1_T0_MSB, (uint8_t*) &reg, 1);
    coeff_h = reg.t1_msb;
 800d66c:	f89d 2004 	ldrb.w	r2, [sp, #4]
    *(buff) = (uint8_t)(((coeff_h << 8) + coeff_l) >> 3);
 800d670:	f89d 3007 	ldrb.w	r3, [sp, #7]
 800d674:	f3c2 0281 	ubfx	r2, r2, #2, #2
 800d678:	eb03 2302 	add.w	r3, r3, r2, lsl #8
 800d67c:	10db      	asrs	r3, r3, #3
 800d67e:	702b      	strb	r3, [r5, #0]
  }

  return ret;
}
 800d680:	b002      	add	sp, #8
 800d682:	bd70      	pop	{r4, r5, r6, pc}

0800d684 <hts221_hum_adc_point_0_get>:
  * @param  buff    buffer that stores data read
  * @retval         interface status (MANDATORY: return 0 -> no Error)
  *
  */
int32_t hts221_hum_adc_point_0_get(hts221_ctx_t *ctx, uint8_t *buff)
{
 800d684:	b410      	push	{r4}
  ret = ctx->read_reg(ctx->handle, reg, data, len);
 800d686:	e9d0 4001 	ldrd	r4, r0, [r0, #4]
{
 800d68a:	460a      	mov	r2, r1
  ret = ctx->read_reg(ctx->handle, reg, data, len);
 800d68c:	46a4      	mov	ip, r4
 800d68e:	2302      	movs	r3, #2
  int32_t ret;
  ret = hts221_read_reg(ctx, HTS221_H0_T0_OUT_L, buff, 2);
  return ret;
}
 800d690:	f85d 4b04 	ldr.w	r4, [sp], #4
  ret = ctx->read_reg(ctx->handle, reg, data, len);
 800d694:	2136      	movs	r1, #54	; 0x36
 800d696:	4760      	bx	ip

0800d698 <hts221_hum_adc_point_1_get>:
  * @param  buff    buffer that stores data read
  * @retval         interface status (MANDATORY: return 0 -> no Error)
  *
  */
int32_t hts221_hum_adc_point_1_get(hts221_ctx_t *ctx, uint8_t *buff)
{
 800d698:	b410      	push	{r4}
  ret = ctx->read_reg(ctx->handle, reg, data, len);
 800d69a:	e9d0 4001 	ldrd	r4, r0, [r0, #4]
{
 800d69e:	460a      	mov	r2, r1
  ret = ctx->read_reg(ctx->handle, reg, data, len);
 800d6a0:	46a4      	mov	ip, r4
 800d6a2:	2302      	movs	r3, #2
  int32_t ret;
  ret = hts221_read_reg(ctx, HTS221_H1_T0_OUT_L, buff, 2);
  return ret;
}
 800d6a4:	f85d 4b04 	ldr.w	r4, [sp], #4
  ret = ctx->read_reg(ctx->handle, reg, data, len);
 800d6a8:	213a      	movs	r1, #58	; 0x3a
 800d6aa:	4760      	bx	ip

0800d6ac <hts221_temp_adc_point_0_get>:
  * @param  buff    buffer that stores data read
  * @retval         interface status (MANDATORY: return 0 -> no Error)
  *
  */
int32_t hts221_temp_adc_point_0_get(hts221_ctx_t *ctx, uint8_t *buff)
{
 800d6ac:	b410      	push	{r4}
  ret = ctx->read_reg(ctx->handle, reg, data, len);
 800d6ae:	e9d0 4001 	ldrd	r4, r0, [r0, #4]
{
 800d6b2:	460a      	mov	r2, r1
  ret = ctx->read_reg(ctx->handle, reg, data, len);
 800d6b4:	46a4      	mov	ip, r4
 800d6b6:	2302      	movs	r3, #2
  int32_t ret;
  ret = hts221_read_reg(ctx, HTS221_T0_OUT_L, buff, 2);
  return ret;
}
 800d6b8:	f85d 4b04 	ldr.w	r4, [sp], #4
  ret = ctx->read_reg(ctx->handle, reg, data, len);
 800d6bc:	213c      	movs	r1, #60	; 0x3c
 800d6be:	4760      	bx	ip

0800d6c0 <hts221_temp_adc_point_1_get>:
  * @param  buff    buffer that stores data read
  * @retval         interface status (MANDATORY: return 0 -> no Error)
  *
  */
int32_t hts221_temp_adc_point_1_get(hts221_ctx_t *ctx, uint8_t *buff)
{
 800d6c0:	b410      	push	{r4}
  ret = ctx->read_reg(ctx->handle, reg, data, len);
 800d6c2:	e9d0 4001 	ldrd	r4, r0, [r0, #4]
{
 800d6c6:	460a      	mov	r2, r1
  ret = ctx->read_reg(ctx->handle, reg, data, len);
 800d6c8:	46a4      	mov	ip, r4
 800d6ca:	2302      	movs	r3, #2
  int32_t ret;
  ret = hts221_read_reg(ctx, HTS221_T1_OUT_L, buff, 2);
  return ret;
}
 800d6cc:	f85d 4b04 	ldr.w	r4, [sp], #4
  ret = ctx->read_reg(ctx->handle, reg, data, len);
 800d6d0:	213e      	movs	r1, #62	; 0x3e
 800d6d2:	4760      	bx	ip

0800d6d4 <LIS3MDL_GetCapabilities>:
  * @param  pObj pointer to Component object
  * @param  Capabilities pointer to LIS3MDL sensor capabilities
  * @retval Component status
  */
int32_t LIS3MDL_GetCapabilities(LIS3MDL_Object_t *pObj, LIS3MDL_Capabilities_t *Capabilities)
{
 800d6d4:	b410      	push	{r4}
  /* Prevent unused argument(s) compilation warning */
  (void)(pObj);

  Capabilities->Acc          = 0;
 800d6d6:	f44f 3480 	mov.w	r4, #65536	; 0x10000
  Capabilities->Magneto      = 1;
  Capabilities->LowPower     = 0;
  Capabilities->GyroMaxFS    = 0;
  Capabilities->AccMaxFS     = 0;
  Capabilities->MagMaxFS     = 16;
  Capabilities->GyroMaxOdr   = 0.0f;
 800d6da:	2300      	movs	r3, #0
  Capabilities->GyroMaxFS    = 0;
 800d6dc:	2000      	movs	r0, #0
  Capabilities->AccMaxOdr    = 0.0f;
  Capabilities->MagMaxOdr    = 80.0f;
 800d6de:	4a06      	ldr	r2, [pc, #24]	; (800d6f8 <LIS3MDL_GetCapabilities+0x24>)
  Capabilities->Acc          = 0;
 800d6e0:	600c      	str	r4, [r1, #0]
  Capabilities->MagMaxFS     = 16;
 800d6e2:	2410      	movs	r4, #16
 800d6e4:	60cc      	str	r4, [r1, #12]
  Capabilities->AccMaxFS     = 0;
 800d6e6:	e9c1 0001 	strd	r0, r0, [r1, #4]
  return LIS3MDL_OK;
}
 800d6ea:	f85d 4b04 	ldr.w	r4, [sp], #4
  Capabilities->GyroMaxOdr   = 0.0f;
 800d6ee:	610b      	str	r3, [r1, #16]
  Capabilities->AccMaxOdr    = 0.0f;
 800d6f0:	614b      	str	r3, [r1, #20]
  Capabilities->MagMaxOdr    = 80.0f;
 800d6f2:	618a      	str	r2, [r1, #24]
}
 800d6f4:	4770      	bx	lr
 800d6f6:	bf00      	nop
 800d6f8:	42a00000 	.word	0x42a00000

0800d6fc <LIS3MDL_ReadID>:
{
 800d6fc:	b508      	push	{r3, lr}
  if (lis3mdl_device_id_get(&(pObj->Ctx), Id) != LIS3MDL_OK)
 800d6fe:	301c      	adds	r0, #28
 800d700:	f000 fb76 	bl	800ddf0 <lis3mdl_device_id_get>
 800d704:	3800      	subs	r0, #0
 800d706:	bf18      	it	ne
 800d708:	2001      	movne	r0, #1
}
 800d70a:	4240      	negs	r0, r0
 800d70c:	bd08      	pop	{r3, pc}
 800d70e:	bf00      	nop

0800d710 <LIS3MDL_MAG_GetSensitivity>:
 * @param pObj the device pObj
 * @param Sensitivity pointer to Sensitivity value
 * @retval 0 in case of success, an error code otherwise
 */
int32_t LIS3MDL_MAG_GetSensitivity(LIS3MDL_Object_t *pObj, float *Sensitivity)
{
 800d710:	b510      	push	{r4, lr}
 800d712:	b082      	sub	sp, #8
 800d714:	460c      	mov	r4, r1
  lis3mdl_fs_t full_scale;

  /* Read actual full scale selection from sensor. */
  if (lis3mdl_full_scale_get(&(pObj->Ctx), &full_scale) != LIS3MDL_OK)
 800d716:	301c      	adds	r0, #28
 800d718:	f10d 0107 	add.w	r1, sp, #7
 800d71c:	f000 fb0e 	bl	800dd3c <lis3mdl_full_scale_get>
 800d720:	b9b8      	cbnz	r0, 800d752 <LIS3MDL_MAG_GetSensitivity+0x42>
  {
    return LIS3MDL_ERROR;
  }

  /* Store the sensitivity based on actual full scale. */
  switch (full_scale)
 800d722:	f89d 3007 	ldrb.w	r3, [sp, #7]
 800d726:	2b03      	cmp	r3, #3
 800d728:	d805      	bhi.n	800d736 <LIS3MDL_MAG_GetSensitivity+0x26>
 800d72a:	e8df f003 	tbb	[pc, r3]
 800d72e:	0e0a      	.short	0x0e0a
 800d730:	0602      	.short	0x0602
      break;
    case LIS3MDL_8_GAUSS:
      *Sensitivity = LIS3MDL_MAG_SENSITIVITY_FS_8GAUSS;
      break;
    case LIS3MDL_12_GAUSS:
      *Sensitivity = LIS3MDL_MAG_SENSITIVITY_FS_12GAUSS;
 800d732:	4b09      	ldr	r3, [pc, #36]	; (800d758 <LIS3MDL_MAG_GetSensitivity+0x48>)
 800d734:	6023      	str	r3, [r4, #0]
    default:
      break;
  }

  return LIS3MDL_OK;
}
 800d736:	b002      	add	sp, #8
 800d738:	bd10      	pop	{r4, pc}
      *Sensitivity = LIS3MDL_MAG_SENSITIVITY_FS_16GAUSS;
 800d73a:	4b08      	ldr	r3, [pc, #32]	; (800d75c <LIS3MDL_MAG_GetSensitivity+0x4c>)
 800d73c:	6023      	str	r3, [r4, #0]
}
 800d73e:	b002      	add	sp, #8
 800d740:	bd10      	pop	{r4, pc}
      *Sensitivity = LIS3MDL_MAG_SENSITIVITY_FS_4GAUSS;
 800d742:	4b07      	ldr	r3, [pc, #28]	; (800d760 <LIS3MDL_MAG_GetSensitivity+0x50>)
 800d744:	6023      	str	r3, [r4, #0]
}
 800d746:	b002      	add	sp, #8
 800d748:	bd10      	pop	{r4, pc}
      *Sensitivity = LIS3MDL_MAG_SENSITIVITY_FS_8GAUSS;
 800d74a:	4b06      	ldr	r3, [pc, #24]	; (800d764 <LIS3MDL_MAG_GetSensitivity+0x54>)
 800d74c:	6023      	str	r3, [r4, #0]
}
 800d74e:	b002      	add	sp, #8
 800d750:	bd10      	pop	{r4, pc}
    return LIS3MDL_ERROR;
 800d752:	f04f 30ff 	mov.w	r0, #4294967295
 800d756:	e7ee      	b.n	800d736 <LIS3MDL_MAG_GetSensitivity+0x26>
 800d758:	3ee04189 	.word	0x3ee04189
 800d75c:	3f158106 	.word	0x3f158106
 800d760:	3e158106 	.word	0x3e158106
 800d764:	3e958106 	.word	0x3e958106

0800d768 <LIS3MDL_MAG_GetFullScale>:
 * @param pObj the device pObj
 * @param FullScale pointer where the full scale is written
 * @retval 0 in case of success, an error code otherwise
 */
int32_t LIS3MDL_MAG_GetFullScale(LIS3MDL_Object_t *pObj, int32_t  *FullScale)
{
 800d768:	b510      	push	{r4, lr}
 800d76a:	b082      	sub	sp, #8
 800d76c:	460c      	mov	r4, r1
  lis3mdl_fs_t fs_low_level;

  /* Read actual full scale selection from sensor. */
  if (lis3mdl_full_scale_get(&(pObj->Ctx), &fs_low_level) != LIS3MDL_OK)
 800d76e:	301c      	adds	r0, #28
 800d770:	f10d 0107 	add.w	r1, sp, #7
 800d774:	f000 fae2 	bl	800dd3c <lis3mdl_full_scale_get>
 800d778:	b9b8      	cbnz	r0, 800d7aa <LIS3MDL_MAG_GetFullScale+0x42>
  {
    return LIS3MDL_ERROR;
  }

  switch (fs_low_level)
 800d77a:	f89d 3007 	ldrb.w	r3, [sp, #7]
 800d77e:	2b03      	cmp	r3, #3
 800d780:	d805      	bhi.n	800d78e <LIS3MDL_MAG_GetFullScale+0x26>
 800d782:	e8df f003 	tbb	[pc, r3]
 800d786:	0e0a      	.short	0x0e0a
 800d788:	0602      	.short	0x0602
      break;
    case LIS3MDL_8_GAUSS:
      *FullScale = 8;
      break;
    case LIS3MDL_12_GAUSS:
      *FullScale = 12;
 800d78a:	230c      	movs	r3, #12
 800d78c:	6023      	str	r3, [r4, #0]
    default:
      break;
  }

  return LIS3MDL_OK;
}
 800d78e:	b002      	add	sp, #8
 800d790:	bd10      	pop	{r4, pc}
      *FullScale = 16;
 800d792:	2310      	movs	r3, #16
 800d794:	6023      	str	r3, [r4, #0]
}
 800d796:	b002      	add	sp, #8
 800d798:	bd10      	pop	{r4, pc}
      *FullScale = 4;
 800d79a:	2304      	movs	r3, #4
 800d79c:	6023      	str	r3, [r4, #0]
}
 800d79e:	b002      	add	sp, #8
 800d7a0:	bd10      	pop	{r4, pc}
      *FullScale = 8;
 800d7a2:	2308      	movs	r3, #8
 800d7a4:	6023      	str	r3, [r4, #0]
}
 800d7a6:	b002      	add	sp, #8
 800d7a8:	bd10      	pop	{r4, pc}
    return LIS3MDL_ERROR;
 800d7aa:	f04f 30ff 	mov.w	r0, #4294967295
 800d7ae:	e7ee      	b.n	800d78e <LIS3MDL_MAG_GetFullScale+0x26>

0800d7b0 <LIS3MDL_MAG_GetOutputDataRate>:
{
 800d7b0:	b510      	push	{r4, lr}
 800d7b2:	b082      	sub	sp, #8
 800d7b4:	460c      	mov	r4, r1
  if (lis3mdl_data_rate_get(&(pObj->Ctx), &odr_low_level) != LIS3MDL_OK)
 800d7b6:	301c      	adds	r0, #28
 800d7b8:	f10d 0107 	add.w	r1, sp, #7
 800d7bc:	f000 fa10 	bl	800dbe0 <lis3mdl_data_rate_get>
 800d7c0:	2800      	cmp	r0, #0
 800d7c2:	d14a      	bne.n	800d85a <LIS3MDL_MAG_GetOutputDataRate+0xaa>
  switch (odr_low_level)
 800d7c4:	f89d 3007 	ldrb.w	r3, [sp, #7]
 800d7c8:	2b3e      	cmp	r3, #62	; 0x3e
 800d7ca:	d823      	bhi.n	800d814 <LIS3MDL_MAG_GetOutputDataRate+0x64>
 800d7cc:	e8df f003 	tbb	[pc, r3]
 800d7d0:	22273c39 	.word	0x22273c39
 800d7d4:	222d222a 	.word	0x222d222a
 800d7d8:	22332230 	.word	0x22332230
 800d7dc:	22242236 	.word	0x22242236
 800d7e0:	22272022 	.word	0x22272022
 800d7e4:	222d222a 	.word	0x222d222a
 800d7e8:	22332230 	.word	0x22332230
 800d7ec:	22242236 	.word	0x22242236
 800d7f0:	22273f22 	.word	0x22273f22
 800d7f4:	222d222a 	.word	0x222d222a
 800d7f8:	22332230 	.word	0x22332230
 800d7fc:	22242236 	.word	0x22242236
 800d800:	22274222 	.word	0x22274222
 800d804:	222d222a 	.word	0x222d222a
 800d808:	22332230 	.word	0x22332230
 800d80c:	2236      	.short	0x2236
 800d80e:	24          	.byte	0x24
 800d80f:	00          	.byte	0x00
      *Odr = 560.000f;
 800d810:	4b13      	ldr	r3, [pc, #76]	; (800d860 <LIS3MDL_MAG_GetOutputDataRate+0xb0>)
 800d812:	6023      	str	r3, [r4, #0]
}
 800d814:	b002      	add	sp, #8
 800d816:	bd10      	pop	{r4, pc}
      *Odr = 80.000f;
 800d818:	4b12      	ldr	r3, [pc, #72]	; (800d864 <LIS3MDL_MAG_GetOutputDataRate+0xb4>)
 800d81a:	6023      	str	r3, [r4, #0]
      break;
 800d81c:	e7fa      	b.n	800d814 <LIS3MDL_MAG_GetOutputDataRate+0x64>
      *Odr = 1.250f;
 800d81e:	4b12      	ldr	r3, [pc, #72]	; (800d868 <LIS3MDL_MAG_GetOutputDataRate+0xb8>)
 800d820:	6023      	str	r3, [r4, #0]
      break;
 800d822:	e7f7      	b.n	800d814 <LIS3MDL_MAG_GetOutputDataRate+0x64>
      *Odr = 2.500f;
 800d824:	4b11      	ldr	r3, [pc, #68]	; (800d86c <LIS3MDL_MAG_GetOutputDataRate+0xbc>)
 800d826:	6023      	str	r3, [r4, #0]
      break;
 800d828:	e7f4      	b.n	800d814 <LIS3MDL_MAG_GetOutputDataRate+0x64>
      *Odr = 5.000f;
 800d82a:	4b11      	ldr	r3, [pc, #68]	; (800d870 <LIS3MDL_MAG_GetOutputDataRate+0xc0>)
 800d82c:	6023      	str	r3, [r4, #0]
      break;
 800d82e:	e7f1      	b.n	800d814 <LIS3MDL_MAG_GetOutputDataRate+0x64>
      *Odr = 10.000f;
 800d830:	4b10      	ldr	r3, [pc, #64]	; (800d874 <LIS3MDL_MAG_GetOutputDataRate+0xc4>)
 800d832:	6023      	str	r3, [r4, #0]
      break;
 800d834:	e7ee      	b.n	800d814 <LIS3MDL_MAG_GetOutputDataRate+0x64>
      *Odr = 20.000f;
 800d836:	4b10      	ldr	r3, [pc, #64]	; (800d878 <LIS3MDL_MAG_GetOutputDataRate+0xc8>)
 800d838:	6023      	str	r3, [r4, #0]
      break;
 800d83a:	e7eb      	b.n	800d814 <LIS3MDL_MAG_GetOutputDataRate+0x64>
      *Odr = 40.000f;
 800d83c:	4b0f      	ldr	r3, [pc, #60]	; (800d87c <LIS3MDL_MAG_GetOutputDataRate+0xcc>)
 800d83e:	6023      	str	r3, [r4, #0]
      break;
 800d840:	e7e8      	b.n	800d814 <LIS3MDL_MAG_GetOutputDataRate+0x64>
      *Odr = 0.625f;
 800d842:	4b0f      	ldr	r3, [pc, #60]	; (800d880 <LIS3MDL_MAG_GetOutputDataRate+0xd0>)
 800d844:	6023      	str	r3, [r4, #0]
      break;
 800d846:	e7e5      	b.n	800d814 <LIS3MDL_MAG_GetOutputDataRate+0x64>
      *Odr = 1000.000f;
 800d848:	4b0e      	ldr	r3, [pc, #56]	; (800d884 <LIS3MDL_MAG_GetOutputDataRate+0xd4>)
 800d84a:	6023      	str	r3, [r4, #0]
      break;
 800d84c:	e7e2      	b.n	800d814 <LIS3MDL_MAG_GetOutputDataRate+0x64>
      *Odr = 300.000f;
 800d84e:	4b0e      	ldr	r3, [pc, #56]	; (800d888 <LIS3MDL_MAG_GetOutputDataRate+0xd8>)
 800d850:	6023      	str	r3, [r4, #0]
      break;
 800d852:	e7df      	b.n	800d814 <LIS3MDL_MAG_GetOutputDataRate+0x64>
      *Odr = 155.000f;
 800d854:	4b0d      	ldr	r3, [pc, #52]	; (800d88c <LIS3MDL_MAG_GetOutputDataRate+0xdc>)
 800d856:	6023      	str	r3, [r4, #0]
      break;
 800d858:	e7dc      	b.n	800d814 <LIS3MDL_MAG_GetOutputDataRate+0x64>
    return LIS3MDL_ERROR;
 800d85a:	f04f 30ff 	mov.w	r0, #4294967295
 800d85e:	e7d9      	b.n	800d814 <LIS3MDL_MAG_GetOutputDataRate+0x64>
 800d860:	440c0000 	.word	0x440c0000
 800d864:	42a00000 	.word	0x42a00000
 800d868:	3fa00000 	.word	0x3fa00000
 800d86c:	40200000 	.word	0x40200000
 800d870:	40a00000 	.word	0x40a00000
 800d874:	41200000 	.word	0x41200000
 800d878:	41a00000 	.word	0x41a00000
 800d87c:	42200000 	.word	0x42200000
 800d880:	3f200000 	.word	0x3f200000
 800d884:	447a0000 	.word	0x447a0000
 800d888:	43960000 	.word	0x43960000
 800d88c:	431b0000 	.word	0x431b0000

0800d890 <LIS3MDL_MAG_SetOutputDataRate>:
            : (Odr <=  1.250f) ? LIS3MDL_LP_1Hz25
 800d890:	eef6 7a04 	vmov.f32	s15, #100	; 0x3f200000  0.625
 800d894:	eeb4 0ae7 	vcmpe.f32	s0, s15
 800d898:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
{
 800d89c:	b508      	push	{r3, lr}
            : (Odr <=  1.250f) ? LIS3MDL_LP_1Hz25
 800d89e:	d908      	bls.n	800d8b2 <LIS3MDL_MAG_SetOutputDataRate+0x22>
 800d8a0:	eef7 7a04 	vmov.f32	s15, #116	; 0x3fa00000  1.250
 800d8a4:	eeb4 0ae7 	vcmpe.f32	s0, s15
 800d8a8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800d8ac:	d80a      	bhi.n	800d8c4 <LIS3MDL_MAG_SetOutputDataRate+0x34>
 800d8ae:	2102      	movs	r1, #2
 800d8b0:	e000      	b.n	800d8b4 <LIS3MDL_MAG_SetOutputDataRate+0x24>
 800d8b2:	2100      	movs	r1, #0
  if (lis3mdl_data_rate_set(&(pObj->Ctx), new_odr) != LIS3MDL_OK)
 800d8b4:	301c      	adds	r0, #28
 800d8b6:	f000 f965 	bl	800db84 <lis3mdl_data_rate_set>
 800d8ba:	3800      	subs	r0, #0
 800d8bc:	bf18      	it	ne
 800d8be:	2001      	movne	r0, #1
}
 800d8c0:	4240      	negs	r0, r0
 800d8c2:	bd08      	pop	{r3, pc}
            : (Odr <=  1.250f) ? LIS3MDL_LP_1Hz25
 800d8c4:	eef0 7a04 	vmov.f32	s15, #4	; 0x40200000  2.5
 800d8c8:	eeb4 0ae7 	vcmpe.f32	s0, s15
 800d8cc:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800d8d0:	d91e      	bls.n	800d910 <LIS3MDL_MAG_SetOutputDataRate+0x80>
 800d8d2:	eef1 7a04 	vmov.f32	s15, #20	; 0x40a00000  5.0
 800d8d6:	eeb4 0ae7 	vcmpe.f32	s0, s15
 800d8da:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800d8de:	d919      	bls.n	800d914 <LIS3MDL_MAG_SetOutputDataRate+0x84>
 800d8e0:	eef2 7a04 	vmov.f32	s15, #36	; 0x41200000  10.0
 800d8e4:	eeb4 0ae7 	vcmpe.f32	s0, s15
 800d8e8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800d8ec:	d914      	bls.n	800d918 <LIS3MDL_MAG_SetOutputDataRate+0x88>
 800d8ee:	eef3 7a04 	vmov.f32	s15, #52	; 0x41a00000  20.0
 800d8f2:	eeb4 0ae7 	vcmpe.f32	s0, s15
 800d8f6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800d8fa:	d90f      	bls.n	800d91c <LIS3MDL_MAG_SetOutputDataRate+0x8c>
 800d8fc:	eddf 7a08 	vldr	s15, [pc, #32]	; 800d920 <LIS3MDL_MAG_SetOutputDataRate+0x90>
 800d900:	eeb4 0ae7 	vcmpe.f32	s0, s15
 800d904:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800d908:	bf94      	ite	ls
 800d90a:	210c      	movls	r1, #12
 800d90c:	210e      	movhi	r1, #14
 800d90e:	e7d1      	b.n	800d8b4 <LIS3MDL_MAG_SetOutputDataRate+0x24>
 800d910:	2104      	movs	r1, #4
 800d912:	e7cf      	b.n	800d8b4 <LIS3MDL_MAG_SetOutputDataRate+0x24>
 800d914:	2106      	movs	r1, #6
 800d916:	e7cd      	b.n	800d8b4 <LIS3MDL_MAG_SetOutputDataRate+0x24>
 800d918:	2108      	movs	r1, #8
 800d91a:	e7cb      	b.n	800d8b4 <LIS3MDL_MAG_SetOutputDataRate+0x24>
 800d91c:	210a      	movs	r1, #10
 800d91e:	e7c9      	b.n	800d8b4 <LIS3MDL_MAG_SetOutputDataRate+0x24>
 800d920:	42200000 	.word	0x42200000

0800d924 <LIS3MDL_MAG_SetFullScale>:
int32_t LIS3MDL_MAG_SetFullScale(LIS3MDL_Object_t *pObj, int32_t FullScale)
{
  lis3mdl_fs_t new_fs;

  new_fs = (FullScale <= 4) ? LIS3MDL_4_GAUSS
           : (FullScale <= 8) ? LIS3MDL_8_GAUSS
 800d924:	2904      	cmp	r1, #4
{
 800d926:	b508      	push	{r3, lr}
           : (FullScale <= 8) ? LIS3MDL_8_GAUSS
 800d928:	dd06      	ble.n	800d938 <LIS3MDL_MAG_SetFullScale+0x14>
 800d92a:	2908      	cmp	r1, #8
 800d92c:	dd0d      	ble.n	800d94a <LIS3MDL_MAG_SetFullScale+0x26>
 800d92e:	290d      	cmp	r1, #13
 800d930:	bfb4      	ite	lt
 800d932:	2102      	movlt	r1, #2
 800d934:	2103      	movge	r1, #3
 800d936:	e000      	b.n	800d93a <LIS3MDL_MAG_SetFullScale+0x16>
 800d938:	2100      	movs	r1, #0
           : (FullScale <= 12) ? LIS3MDL_12_GAUSS
           :                       LIS3MDL_16_GAUSS;

  if (lis3mdl_full_scale_set(&(pObj->Ctx), new_fs) != LIS3MDL_OK)
 800d93a:	301c      	adds	r0, #28
 800d93c:	f000 f9e4 	bl	800dd08 <lis3mdl_full_scale_set>
 800d940:	3800      	subs	r0, #0
 800d942:	bf18      	it	ne
 800d944:	2001      	movne	r0, #1
  {
    return LIS3MDL_ERROR;
  }

  return LIS3MDL_OK;
}
 800d946:	4240      	negs	r0, r0
 800d948:	bd08      	pop	{r3, pc}
           : (FullScale <= 8) ? LIS3MDL_8_GAUSS
 800d94a:	2101      	movs	r1, #1
 800d94c:	e7f5      	b.n	800d93a <LIS3MDL_MAG_SetFullScale+0x16>
 800d94e:	bf00      	nop

0800d950 <LIS3MDL_Init>:
{
 800d950:	b538      	push	{r3, r4, r5, lr}
  if (lis3mdl_operating_mode_set(&(pObj->Ctx), LIS3MDL_POWER_DOWN) != LIS3MDL_OK)
 800d952:	f100 051c 	add.w	r5, r0, #28
{
 800d956:	4604      	mov	r4, r0
  if (lis3mdl_operating_mode_set(&(pObj->Ctx), LIS3MDL_POWER_DOWN) != LIS3MDL_OK)
 800d958:	2102      	movs	r1, #2
 800d95a:	4628      	mov	r0, r5
 800d95c:	f000 fa0a 	bl	800dd74 <lis3mdl_operating_mode_set>
 800d960:	b990      	cbnz	r0, 800d988 <LIS3MDL_Init+0x38>
  if (lis3mdl_block_data_update_set(&(pObj->Ctx), PROPERTY_ENABLE) != LIS3MDL_OK)
 800d962:	2101      	movs	r1, #1
 800d964:	4628      	mov	r0, r5
 800d966:	f000 fa1f 	bl	800dda8 <lis3mdl_block_data_update_set>
 800d96a:	b968      	cbnz	r0, 800d988 <LIS3MDL_Init+0x38>
  if (lis3mdl_data_rate_set(&(pObj->Ctx), new_odr) != LIS3MDL_OK)
 800d96c:	210e      	movs	r1, #14
 800d96e:	4628      	mov	r0, r5
 800d970:	f000 f908 	bl	800db84 <lis3mdl_data_rate_set>
 800d974:	4601      	mov	r1, r0
 800d976:	b938      	cbnz	r0, 800d988 <LIS3MDL_Init+0x38>
  if (lis3mdl_full_scale_set(&(pObj->Ctx), new_fs) != LIS3MDL_OK)
 800d978:	4628      	mov	r0, r5
 800d97a:	f000 f9c5 	bl	800dd08 <lis3mdl_full_scale_set>
 800d97e:	b918      	cbnz	r0, 800d988 <LIS3MDL_Init+0x38>
  pObj->is_initialized = 1;
 800d980:	2301      	movs	r3, #1
 800d982:	f884 3028 	strb.w	r3, [r4, #40]	; 0x28
}
 800d986:	bd38      	pop	{r3, r4, r5, pc}
    return LIS3MDL_ERROR;
 800d988:	f04f 30ff 	mov.w	r0, #4294967295
}
 800d98c:	bd38      	pop	{r3, r4, r5, pc}
 800d98e:	bf00      	nop

0800d990 <LIS3MDL_MAG_GetAxesRaw>:
 * @param pObj the device pObj
 * @param Value pointer where the raw values of the axes are written
 * @retval 0 in case of success, an error code otherwise
 */
int32_t LIS3MDL_MAG_GetAxesRaw(LIS3MDL_Object_t *pObj, LIS3MDL_AxesRaw_t *Value)
{
 800d990:	b510      	push	{r4, lr}
 800d992:	b082      	sub	sp, #8
 800d994:	460c      	mov	r4, r1
  axis3bit16_t data_raw;

  /* Read raw data values. */
  if (lis3mdl_magnetic_raw_get(&(pObj->Ctx), data_raw.u8bit) != LIS3MDL_OK)
 800d996:	301c      	adds	r0, #28
 800d998:	4669      	mov	r1, sp
 800d99a:	f000 fa1f 	bl	800dddc <lis3mdl_magnetic_raw_get>
 800d99e:	b950      	cbnz	r0, 800d9b6 <LIS3MDL_MAG_GetAxesRaw+0x26>
  {
    return LIS3MDL_ERROR;
  }

  /* Format the data. */
  Value->x = data_raw.i16bit[0];
 800d9a0:	f8bd 1000 	ldrh.w	r1, [sp]
  Value->y = data_raw.i16bit[1];
 800d9a4:	f8bd 2002 	ldrh.w	r2, [sp, #2]
  Value->z = data_raw.i16bit[2];
 800d9a8:	f8bd 3004 	ldrh.w	r3, [sp, #4]
  Value->x = data_raw.i16bit[0];
 800d9ac:	8021      	strh	r1, [r4, #0]
  Value->y = data_raw.i16bit[1];
 800d9ae:	8062      	strh	r2, [r4, #2]
  Value->z = data_raw.i16bit[2];
 800d9b0:	80a3      	strh	r3, [r4, #4]

  return LIS3MDL_OK;
}
 800d9b2:	b002      	add	sp, #8
 800d9b4:	bd10      	pop	{r4, pc}
    return LIS3MDL_ERROR;
 800d9b6:	f04f 30ff 	mov.w	r0, #4294967295
 800d9ba:	e7fa      	b.n	800d9b2 <LIS3MDL_MAG_GetAxesRaw+0x22>

0800d9bc <LIS3MDL_MAG_GetAxes>:
 * @param pObj the device pObj
 * @param MagneticField pointer where the values of the axes are written
 * @retval 0 in case of success, an error code otherwise
 */
int32_t LIS3MDL_MAG_GetAxes(LIS3MDL_Object_t *pObj, LIS3MDL_Axes_t *MagneticField)
{
 800d9bc:	b530      	push	{r4, r5, lr}
 800d9be:	b085      	sub	sp, #20
 800d9c0:	4605      	mov	r5, r0
 800d9c2:	460c      	mov	r4, r1
  axis3bit16_t data_raw;
  float sensitivity;

  /* Read raw data values. */
  if (lis3mdl_magnetic_raw_get(&(pObj->Ctx), data_raw.u8bit) != LIS3MDL_OK)
 800d9c4:	301c      	adds	r0, #28
 800d9c6:	a902      	add	r1, sp, #8
 800d9c8:	f000 fa08 	bl	800dddc <lis3mdl_magnetic_raw_get>
 800d9cc:	bb60      	cbnz	r0, 800da28 <LIS3MDL_MAG_GetAxes+0x6c>
  {
    return LIS3MDL_ERROR;
  }

  /* Get LIS3MDL actual sensitivity. */
  if (LIS3MDL_MAG_GetSensitivity(pObj, &sensitivity) != LIS3MDL_OK)
 800d9ce:	a901      	add	r1, sp, #4
 800d9d0:	4628      	mov	r0, r5
 800d9d2:	f7ff fe9d 	bl	800d710 <LIS3MDL_MAG_GetSensitivity>
 800d9d6:	bb38      	cbnz	r0, 800da28 <LIS3MDL_MAG_GetAxes+0x6c>
  {
    return LIS3MDL_ERROR;
  }

  /* Calculate the data. */
  MagneticField->x = (int32_t)((float)((float)data_raw.i16bit[0] * sensitivity));
 800d9d8:	f9bd 3008 	ldrsh.w	r3, [sp, #8]
 800d9dc:	ed9d 6a01 	vldr	s12, [sp, #4]
 800d9e0:	ee06 3a90 	vmov	s13, r3
  MagneticField->y = (int32_t)((float)((float)data_raw.i16bit[1] * sensitivity));
 800d9e4:	f9bd 300a 	ldrsh.w	r3, [sp, #10]
 800d9e8:	ee07 3a10 	vmov	s14, r3
  MagneticField->z = (int32_t)((float)((float)data_raw.i16bit[2] * sensitivity));
 800d9ec:	f9bd 300c 	ldrsh.w	r3, [sp, #12]
 800d9f0:	ee07 3a90 	vmov	s15, r3
  MagneticField->x = (int32_t)((float)((float)data_raw.i16bit[0] * sensitivity));
 800d9f4:	eef8 6ae6 	vcvt.f32.s32	s13, s13
  MagneticField->y = (int32_t)((float)((float)data_raw.i16bit[1] * sensitivity));
 800d9f8:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
  MagneticField->z = (int32_t)((float)((float)data_raw.i16bit[2] * sensitivity));
 800d9fc:	eef8 7ae7 	vcvt.f32.s32	s15, s15
  MagneticField->x = (int32_t)((float)((float)data_raw.i16bit[0] * sensitivity));
 800da00:	ee66 6a86 	vmul.f32	s13, s13, s12
  MagneticField->y = (int32_t)((float)((float)data_raw.i16bit[1] * sensitivity));
 800da04:	ee27 7a06 	vmul.f32	s14, s14, s12
  MagneticField->z = (int32_t)((float)((float)data_raw.i16bit[2] * sensitivity));
 800da08:	ee67 7a86 	vmul.f32	s15, s15, s12
  MagneticField->x = (int32_t)((float)((float)data_raw.i16bit[0] * sensitivity));
 800da0c:	eefd 6ae6 	vcvt.s32.f32	s13, s13
  MagneticField->y = (int32_t)((float)((float)data_raw.i16bit[1] * sensitivity));
 800da10:	eebd 7ac7 	vcvt.s32.f32	s14, s14
  MagneticField->z = (int32_t)((float)((float)data_raw.i16bit[2] * sensitivity));
 800da14:	eefd 7ae7 	vcvt.s32.f32	s15, s15
  MagneticField->x = (int32_t)((float)((float)data_raw.i16bit[0] * sensitivity));
 800da18:	edc4 6a00 	vstr	s13, [r4]
  MagneticField->y = (int32_t)((float)((float)data_raw.i16bit[1] * sensitivity));
 800da1c:	ed84 7a01 	vstr	s14, [r4, #4]
  MagneticField->z = (int32_t)((float)((float)data_raw.i16bit[2] * sensitivity));
 800da20:	edc4 7a02 	vstr	s15, [r4, #8]

  return LIS3MDL_OK;
}
 800da24:	b005      	add	sp, #20
 800da26:	bd30      	pop	{r4, r5, pc}
    return LIS3MDL_ERROR;
 800da28:	f04f 30ff 	mov.w	r0, #4294967295
 800da2c:	e7fa      	b.n	800da24 <LIS3MDL_MAG_GetAxes+0x68>
 800da2e:	bf00      	nop

0800da30 <ReadRegWrap>:
  * @brief  Wrap Read register component function to Bus IO function
  * @param  Component object pointer
  * @retval Component status
  */
static int32_t ReadRegWrap(void *handle, uint8_t Reg, uint8_t *pData, uint16_t Length)
{
 800da30:	b410      	push	{r4}
  LIS3MDL_Object_t *pObj = (LIS3MDL_Object_t *)handle;

  if (pObj->IO.BusType == LIS3MDL_I2C_BUS) /* I2C */
 800da32:	6884      	ldr	r4, [r0, #8]
 800da34:	b93c      	cbnz	r4, 800da46 <ReadRegWrap+0x16>
  {
    /* Enable Multi-byte read */
    return pObj->IO.ReadReg(pObj->IO.Address, (Reg | 0x80U), pData, Length);
 800da36:	6944      	ldr	r4, [r0, #20]
 800da38:	7b00      	ldrb	r0, [r0, #12]
 800da3a:	46a4      	mov	ip, r4
 800da3c:	f041 0180 	orr.w	r1, r1, #128	; 0x80
  else /* SPI 4-Wires or SPI 3-Wires */
  {
    /* Enable Multi-byte read */
    return pObj->IO.ReadReg(pObj->IO.Address, (Reg | 0x40U), pData, Length);
  }
}
 800da40:	f85d 4b04 	ldr.w	r4, [sp], #4
    return pObj->IO.ReadReg(pObj->IO.Address, (Reg | 0x80U), pData, Length);
 800da44:	4760      	bx	ip
    return pObj->IO.ReadReg(pObj->IO.Address, (Reg | 0x40U), pData, Length);
 800da46:	6944      	ldr	r4, [r0, #20]
 800da48:	7b00      	ldrb	r0, [r0, #12]
 800da4a:	46a4      	mov	ip, r4
 800da4c:	f041 0140 	orr.w	r1, r1, #64	; 0x40
}
 800da50:	f85d 4b04 	ldr.w	r4, [sp], #4
    return pObj->IO.ReadReg(pObj->IO.Address, (Reg | 0x40U), pData, Length);
 800da54:	4760      	bx	ip
 800da56:	bf00      	nop

0800da58 <WriteRegWrap>:
  * @brief  Wrap Write register component function to Bus IO function
  * @param  Component object pointer
  * @retval Component status
  */
static int32_t WriteRegWrap(void *handle, uint8_t Reg, uint8_t *pData, uint16_t Length)
{
 800da58:	b410      	push	{r4}
  LIS3MDL_Object_t *pObj = (LIS3MDL_Object_t *)handle;

  if (pObj->IO.BusType == LIS3MDL_I2C_BUS) /* I2C */
 800da5a:	6884      	ldr	r4, [r0, #8]
 800da5c:	b93c      	cbnz	r4, 800da6e <WriteRegWrap+0x16>
  {
    /* Enable Multi-byte write */
    return pObj->IO.WriteReg(pObj->IO.Address, (Reg | 0x80U), pData, Length);
 800da5e:	6904      	ldr	r4, [r0, #16]
 800da60:	7b00      	ldrb	r0, [r0, #12]
 800da62:	46a4      	mov	ip, r4
 800da64:	f041 0180 	orr.w	r1, r1, #128	; 0x80
  else   /* SPI 4-Wires or SPI 3-Wires */
  {
    /* Enable Multi-byte write */
    return pObj->IO.WriteReg(pObj->IO.Address, (Reg | 0x40U), pData, Length);
  }
}
 800da68:	f85d 4b04 	ldr.w	r4, [sp], #4
    return pObj->IO.WriteReg(pObj->IO.Address, (Reg | 0x80U), pData, Length);
 800da6c:	4760      	bx	ip
    return pObj->IO.WriteReg(pObj->IO.Address, (Reg | 0x40U), pData, Length);
 800da6e:	6904      	ldr	r4, [r0, #16]
 800da70:	7b00      	ldrb	r0, [r0, #12]
 800da72:	46a4      	mov	ip, r4
 800da74:	f041 0140 	orr.w	r1, r1, #64	; 0x40
}
 800da78:	f85d 4b04 	ldr.w	r4, [sp], #4
    return pObj->IO.WriteReg(pObj->IO.Address, (Reg | 0x40U), pData, Length);
 800da7c:	4760      	bx	ip
 800da7e:	bf00      	nop

0800da80 <LIS3MDL_MAG_Enable>:
  if (pObj->mag_is_enabled == 1U)
 800da80:	f890 3029 	ldrb.w	r3, [r0, #41]	; 0x29
 800da84:	2b01      	cmp	r3, #1
 800da86:	d00a      	beq.n	800da9e <LIS3MDL_MAG_Enable+0x1e>
{
 800da88:	b510      	push	{r4, lr}
  if (lis3mdl_operating_mode_set(&(pObj->Ctx), LIS3MDL_CONTINUOUS_MODE) != LIS3MDL_OK)
 800da8a:	2100      	movs	r1, #0
 800da8c:	4604      	mov	r4, r0
 800da8e:	301c      	adds	r0, #28
 800da90:	f000 f970 	bl	800dd74 <lis3mdl_operating_mode_set>
 800da94:	b928      	cbnz	r0, 800daa2 <LIS3MDL_MAG_Enable+0x22>
  pObj->mag_is_enabled = 1;
 800da96:	2301      	movs	r3, #1
 800da98:	f884 3029 	strb.w	r3, [r4, #41]	; 0x29
}
 800da9c:	bd10      	pop	{r4, pc}
    return LIS3MDL_OK;
 800da9e:	2000      	movs	r0, #0
}
 800daa0:	4770      	bx	lr
    return LIS3MDL_ERROR;
 800daa2:	f04f 30ff 	mov.w	r0, #4294967295
}
 800daa6:	bd10      	pop	{r4, pc}

0800daa8 <LIS3MDL_DeInit>:
{
 800daa8:	b510      	push	{r4, lr}
  if (pObj->mag_is_enabled == 0U)
 800daaa:	f890 3029 	ldrb.w	r3, [r0, #41]	; 0x29
{
 800daae:	4604      	mov	r4, r0
  if (pObj->mag_is_enabled == 0U)
 800dab0:	b91b      	cbnz	r3, 800daba <LIS3MDL_DeInit+0x12>
  pObj->is_initialized = 0;
 800dab2:	2000      	movs	r0, #0
 800dab4:	f884 0028 	strb.w	r0, [r4, #40]	; 0x28
}
 800dab8:	bd10      	pop	{r4, pc}
  if (lis3mdl_operating_mode_set(&(pObj->Ctx), LIS3MDL_POWER_DOWN) != LIS3MDL_OK)
 800daba:	2102      	movs	r1, #2
 800dabc:	301c      	adds	r0, #28
 800dabe:	f000 f959 	bl	800dd74 <lis3mdl_operating_mode_set>
 800dac2:	b910      	cbnz	r0, 800daca <LIS3MDL_DeInit+0x22>
  pObj->mag_is_enabled = 0;
 800dac4:	f884 0029 	strb.w	r0, [r4, #41]	; 0x29
  return LIS3MDL_OK;
 800dac8:	e7f3      	b.n	800dab2 <LIS3MDL_DeInit+0xa>
    return LIS3MDL_ERROR;
 800daca:	f04f 30ff 	mov.w	r0, #4294967295
}
 800dace:	bd10      	pop	{r4, pc}

0800dad0 <LIS3MDL_MAG_Disable>:
{
 800dad0:	b510      	push	{r4, lr}
 800dad2:	4604      	mov	r4, r0
  if (pObj->mag_is_enabled == 0U)
 800dad4:	f890 0029 	ldrb.w	r0, [r0, #41]	; 0x29
 800dad8:	b900      	cbnz	r0, 800dadc <LIS3MDL_MAG_Disable+0xc>
}
 800dada:	bd10      	pop	{r4, pc}
  if (lis3mdl_operating_mode_set(&(pObj->Ctx), LIS3MDL_POWER_DOWN) != LIS3MDL_OK)
 800dadc:	2102      	movs	r1, #2
 800dade:	f104 001c 	add.w	r0, r4, #28
 800dae2:	f000 f947 	bl	800dd74 <lis3mdl_operating_mode_set>
 800dae6:	b910      	cbnz	r0, 800daee <LIS3MDL_MAG_Disable+0x1e>
  pObj->mag_is_enabled = 0;
 800dae8:	f884 0029 	strb.w	r0, [r4, #41]	; 0x29
}
 800daec:	bd10      	pop	{r4, pc}
    return LIS3MDL_ERROR;
 800daee:	f04f 30ff 	mov.w	r0, #4294967295
}
 800daf2:	bd10      	pop	{r4, pc}

0800daf4 <LIS3MDL_RegisterBusIO>:
  if (pObj == NULL)
 800daf4:	2800      	cmp	r0, #0
 800daf6:	d035      	beq.n	800db64 <LIS3MDL_RegisterBusIO+0x70>
{
 800daf8:	b530      	push	{r4, r5, lr}
 800dafa:	4604      	mov	r4, r0
    pObj->IO.DeInit    = pIO->DeInit;
 800dafc:	e9d1 3000 	ldrd	r3, r0, [r1]
    pObj->IO.BusType   = pIO->BusType;
 800db00:	688a      	ldr	r2, [r1, #8]
 800db02:	60a2      	str	r2, [r4, #8]
    pObj->IO.DeInit    = pIO->DeInit;
 800db04:	e9c4 3000 	strd	r3, r0, [r4]
    pObj->IO.Address   = pIO->Address;
 800db08:	7b0a      	ldrb	r2, [r1, #12]
 800db0a:	7322      	strb	r2, [r4, #12]
    pObj->IO.ReadReg   = pIO->ReadReg;
 800db0c:	e9d1 5204 	ldrd	r5, r2, [r1, #16]
    pObj->IO.GetTick   = pIO->GetTick;
 800db10:	6988      	ldr	r0, [r1, #24]
    pObj->Ctx.read_reg  = ReadRegWrap;
 800db12:	4916      	ldr	r1, [pc, #88]	; (800db6c <LIS3MDL_RegisterBusIO+0x78>)
    pObj->IO.GetTick   = pIO->GetTick;
 800db14:	61a0      	str	r0, [r4, #24]
    pObj->IO.ReadReg   = pIO->ReadReg;
 800db16:	e9c4 5204 	strd	r5, r2, [r4, #16]
    pObj->Ctx.write_reg = WriteRegWrap;
 800db1a:	4a15      	ldr	r2, [pc, #84]	; (800db70 <LIS3MDL_RegisterBusIO+0x7c>)
    pObj->Ctx.handle   = pObj;
 800db1c:	6264      	str	r4, [r4, #36]	; 0x24
    pObj->Ctx.write_reg = WriteRegWrap;
 800db1e:	e9c4 2107 	strd	r2, r1, [r4, #28]
{
 800db22:	b083      	sub	sp, #12
    if (pObj->IO.Init == NULL)
 800db24:	b1db      	cbz	r3, 800db5e <LIS3MDL_RegisterBusIO+0x6a>
    else if (pObj->IO.Init() != LIS3MDL_OK)
 800db26:	4798      	blx	r3
 800db28:	b9c8      	cbnz	r0, 800db5e <LIS3MDL_RegisterBusIO+0x6a>
      if (pObj->IO.BusType == LIS3MDL_SPI_3WIRES_BUS) /* SPI 3-Wires */
 800db2a:	68a3      	ldr	r3, [r4, #8]
 800db2c:	2b02      	cmp	r3, #2
 800db2e:	d001      	beq.n	800db34 <LIS3MDL_RegisterBusIO+0x40>
}
 800db30:	b003      	add	sp, #12
 800db32:	bd30      	pop	{r4, r5, pc}
        if (pObj->is_initialized == 0U)
 800db34:	f894 3028 	ldrb.w	r3, [r4, #40]	; 0x28
 800db38:	2b00      	cmp	r3, #0
 800db3a:	d1f9      	bne.n	800db30 <LIS3MDL_RegisterBusIO+0x3c>
          if (LIS3MDL_Write_Reg(pObj, LIS3MDL_CTRL_REG3, data) != LIS3MDL_OK)
 800db3c:	2507      	movs	r5, #7
  if (lis3mdl_write_reg(&(pObj->Ctx), Reg, &Data, 1) != LIS3MDL_OK)
 800db3e:	2301      	movs	r3, #1
 800db40:	eb0d 0205 	add.w	r2, sp, r5
 800db44:	2122      	movs	r1, #34	; 0x22
 800db46:	f104 001c 	add.w	r0, r4, #28
 800db4a:	f88d 5007 	strb.w	r5, [sp, #7]
 800db4e:	f000 f811 	bl	800db74 <lis3mdl_write_reg>
            ret = LIS3MDL_ERROR;
 800db52:	2800      	cmp	r0, #0
 800db54:	bf18      	it	ne
 800db56:	f04f 30ff 	movne.w	r0, #4294967295
}
 800db5a:	b003      	add	sp, #12
 800db5c:	bd30      	pop	{r4, r5, pc}
    ret = LIS3MDL_ERROR;
 800db5e:	f04f 30ff 	mov.w	r0, #4294967295
 800db62:	e7e5      	b.n	800db30 <LIS3MDL_RegisterBusIO+0x3c>
 800db64:	f04f 30ff 	mov.w	r0, #4294967295
}
 800db68:	4770      	bx	lr
 800db6a:	bf00      	nop
 800db6c:	0800da31 	.word	0x0800da31
 800db70:	0800da59 	.word	0x0800da59

0800db74 <lis3mdl_write_reg>:
  * @retval       interface status (MANDATORY: return 0 -> no Error)
  *
  */
int32_t lis3mdl_write_reg(lis3mdl_ctx_t* ctx, uint8_t reg, uint8_t* data,
                          uint16_t len)
{
 800db74:	b410      	push	{r4}
  int32_t ret;
  ret = ctx->write_reg(ctx->handle, reg, data, len);
 800db76:	6804      	ldr	r4, [r0, #0]
 800db78:	6880      	ldr	r0, [r0, #8]
 800db7a:	46a4      	mov	ip, r4
  return ret;
}
 800db7c:	f85d 4b04 	ldr.w	r4, [sp], #4
  ret = ctx->write_reg(ctx->handle, reg, data, len);
 800db80:	4760      	bx	ip
 800db82:	bf00      	nop

0800db84 <lis3mdl_data_rate_set>:
  * @param  val         change the values of om in reg CTRL_REG1
  * @retval             interface status (MANDATORY: return 0 -> no Error)
  *
  */
int32_t lis3mdl_data_rate_set(lis3mdl_ctx_t *ctx, lis3mdl_om_t val)
{
 800db84:	b570      	push	{r4, r5, r6, lr}
 800db86:	4604      	mov	r4, r0
 800db88:	b082      	sub	sp, #8
 800db8a:	460d      	mov	r5, r1
  ret = ctx->read_reg(ctx->handle, reg, data, len);
 800db8c:	6880      	ldr	r0, [r0, #8]
 800db8e:	6866      	ldr	r6, [r4, #4]
 800db90:	2301      	movs	r3, #1
 800db92:	466a      	mov	r2, sp
 800db94:	2120      	movs	r1, #32
 800db96:	47b0      	blx	r6
  lis3mdl_ctrl_reg1_t ctrl_reg1;
  lis3mdl_ctrl_reg4_t ctrl_reg4;
  int32_t ret;

  ret = lis3mdl_read_reg(ctx, LIS3MDL_CTRL_REG1, (uint8_t*)&ctrl_reg1, 1);
  if (ret == 0)
 800db98:	bb00      	cbnz	r0, 800dbdc <lis3mdl_data_rate_set+0x58>
  {
    ctrl_reg1.om = (uint8_t)val;
 800db9a:	f89d 3000 	ldrb.w	r3, [sp]
  ret = ctx->write_reg(ctx->handle, reg, data, len);
 800db9e:	6826      	ldr	r6, [r4, #0]
 800dba0:	68a0      	ldr	r0, [r4, #8]
    ctrl_reg1.om = (uint8_t)val;
 800dba2:	f365 0346 	bfi	r3, r5, #1, #6
 800dba6:	f88d 3000 	strb.w	r3, [sp]
  ret = ctx->write_reg(ctx->handle, reg, data, len);
 800dbaa:	466a      	mov	r2, sp
 800dbac:	2301      	movs	r3, #1
 800dbae:	2120      	movs	r1, #32
 800dbb0:	47b0      	blx	r6
    ret = lis3mdl_write_reg(ctx, LIS3MDL_CTRL_REG1, (uint8_t*)&ctrl_reg1, 1);
  }
  
  if (ret == 0)
 800dbb2:	b998      	cbnz	r0, 800dbdc <lis3mdl_data_rate_set+0x58>
  ret = ctx->read_reg(ctx->handle, reg, data, len);
 800dbb4:	68a0      	ldr	r0, [r4, #8]
 800dbb6:	6866      	ldr	r6, [r4, #4]
 800dbb8:	2301      	movs	r3, #1
 800dbba:	aa01      	add	r2, sp, #4
 800dbbc:	2123      	movs	r1, #35	; 0x23
 800dbbe:	47b0      	blx	r6
  {
    /* set mode also for z axis, ctrl_reg4 -> omz */
    ret = lis3mdl_read_reg(ctx, LIS3MDL_CTRL_REG4, (uint8_t*)&ctrl_reg4, 1);
  }
  
  if (ret == 0)
 800dbc0:	b960      	cbnz	r0, 800dbdc <lis3mdl_data_rate_set+0x58>
  {
    ctrl_reg4.omz = (uint8_t)(((uint8_t) val >> 4) & 0x03U);
 800dbc2:	f89d 3004 	ldrb.w	r3, [sp, #4]
  ret = ctx->write_reg(ctx->handle, reg, data, len);
 800dbc6:	68a0      	ldr	r0, [r4, #8]
    ctrl_reg4.omz = (uint8_t)(((uint8_t) val >> 4) & 0x03U);
 800dbc8:	092d      	lsrs	r5, r5, #4
 800dbca:	f365 0383 	bfi	r3, r5, #2, #2
  ret = ctx->write_reg(ctx->handle, reg, data, len);
 800dbce:	aa01      	add	r2, sp, #4
 800dbd0:	6825      	ldr	r5, [r4, #0]
    ctrl_reg4.omz = (uint8_t)(((uint8_t) val >> 4) & 0x03U);
 800dbd2:	f88d 3004 	strb.w	r3, [sp, #4]
  ret = ctx->write_reg(ctx->handle, reg, data, len);
 800dbd6:	2123      	movs	r1, #35	; 0x23
 800dbd8:	2301      	movs	r3, #1
 800dbda:	47a8      	blx	r5
    ret = lis3mdl_write_reg(ctx, LIS3MDL_CTRL_REG4,
                            (uint8_t*)&ctrl_reg4, 1);
  }

  return ret;
}
 800dbdc:	b002      	add	sp, #8
 800dbde:	bd70      	pop	{r4, r5, r6, pc}

0800dbe0 <lis3mdl_data_rate_get>:
  * @param  val      Get the values of om in reg CTRL_REG1(ptr)
  * @retval          interface status (MANDATORY: return 0 -> no Error)
  *
  */
int32_t lis3mdl_data_rate_get(lis3mdl_ctx_t *ctx, lis3mdl_om_t *val)
{
 800dbe0:	b530      	push	{r4, r5, lr}
 800dbe2:	b083      	sub	sp, #12
  ret = ctx->read_reg(ctx->handle, reg, data, len);
 800dbe4:	2301      	movs	r3, #1
 800dbe6:	e9d0 4001 	ldrd	r4, r0, [r0, #4]
 800dbea:	aa01      	add	r2, sp, #4
{
 800dbec:	460d      	mov	r5, r1
  ret = ctx->read_reg(ctx->handle, reg, data, len);
 800dbee:	2120      	movs	r1, #32
 800dbf0:	47a0      	blx	r4
  lis3mdl_ctrl_reg1_t ctrl_reg1;
  int32_t ret;

  /* z axis, ctrl_reg4 -> omz is aligned with x/y axis ctrl_reg1 -> om*/
  ret = lis3mdl_read_reg(ctx, LIS3MDL_CTRL_REG1, (uint8_t*)&ctrl_reg1, 1);
  switch (ctrl_reg1.om)
 800dbf2:	f89d 3004 	ldrb.w	r3, [sp, #4]
 800dbf6:	f3c3 0345 	ubfx	r3, r3, #1, #6
 800dbfa:	2b3c      	cmp	r3, #60	; 0x3c
 800dbfc:	d820      	bhi.n	800dc40 <lis3mdl_data_rate_get+0x60>
 800dbfe:	e8df f003 	tbb	[pc, r3]
 800dc02:	8023      	.short	0x8023
 800dc04:	1f7a1f7d 	.word	0x1f7a1f7d
 800dc08:	1f741f77 	.word	0x1f741f77
 800dc0c:	1f6e1f71 	.word	0x1f6e1f71
 800dc10:	681f1f6b 	.word	0x681f1f6b
 800dc14:	1f621f65 	.word	0x1f621f65
 800dc18:	1f5c1f5f 	.word	0x1f5c1f5f
 800dc1c:	1f561f59 	.word	0x1f561f59
 800dc20:	501f1f53 	.word	0x501f1f53
 800dc24:	1f4a1f4d 	.word	0x1f4a1f4d
 800dc28:	1f441f47 	.word	0x1f441f47
 800dc2c:	1f3e1f41 	.word	0x1f3e1f41
 800dc30:	381f1f3b 	.word	0x381f1f3b
 800dc34:	1f321f35 	.word	0x1f321f35
 800dc38:	1f2c1f2f 	.word	0x1f2c1f2f
 800dc3c:	1f29      	.short	0x1f29
 800dc3e:	26          	.byte	0x26
 800dc3f:	00          	.byte	0x00
      break;
    case LIS3MDL_UHP_40Hz:
      *val = LIS3MDL_UHP_40Hz;
      break;
    case LIS3MDL_UHP_80Hz:
      *val = LIS3MDL_UHP_80Hz;
 800dc40:	233e      	movs	r3, #62	; 0x3e
 800dc42:	702b      	strb	r3, [r5, #0]
      *val = LIS3MDL_UHP_80Hz;
      break;
  }

  return ret;
}
 800dc44:	b003      	add	sp, #12
 800dc46:	bd30      	pop	{r4, r5, pc}
      *val = LIS3MDL_LP_Hz625;
 800dc48:	2300      	movs	r3, #0
 800dc4a:	702b      	strb	r3, [r5, #0]
      break;
 800dc4c:	e7fa      	b.n	800dc44 <lis3mdl_data_rate_get+0x64>
      *val = LIS3MDL_UHP_40Hz;
 800dc4e:	233c      	movs	r3, #60	; 0x3c
 800dc50:	702b      	strb	r3, [r5, #0]
      break;
 800dc52:	e7f7      	b.n	800dc44 <lis3mdl_data_rate_get+0x64>
      *val = LIS3MDL_UHP_20Hz;
 800dc54:	233a      	movs	r3, #58	; 0x3a
 800dc56:	702b      	strb	r3, [r5, #0]
      break;
 800dc58:	e7f4      	b.n	800dc44 <lis3mdl_data_rate_get+0x64>
      *val = LIS3MDL_UHP_10Hz;
 800dc5a:	2338      	movs	r3, #56	; 0x38
 800dc5c:	702b      	strb	r3, [r5, #0]
      break;
 800dc5e:	e7f1      	b.n	800dc44 <lis3mdl_data_rate_get+0x64>
      *val = LIS3MDL_UHP_5Hz;
 800dc60:	2336      	movs	r3, #54	; 0x36
 800dc62:	702b      	strb	r3, [r5, #0]
      break;
 800dc64:	e7ee      	b.n	800dc44 <lis3mdl_data_rate_get+0x64>
      *val = LIS3MDL_UHP_2Hz5;
 800dc66:	2334      	movs	r3, #52	; 0x34
 800dc68:	702b      	strb	r3, [r5, #0]
      break;
 800dc6a:	e7eb      	b.n	800dc44 <lis3mdl_data_rate_get+0x64>
      *val = LIS3MDL_UHP_1Hz25;
 800dc6c:	2332      	movs	r3, #50	; 0x32
 800dc6e:	702b      	strb	r3, [r5, #0]
      break;
 800dc70:	e7e8      	b.n	800dc44 <lis3mdl_data_rate_get+0x64>
      *val = LIS3MDL_UHP_155Hz;
 800dc72:	2331      	movs	r3, #49	; 0x31
 800dc74:	702b      	strb	r3, [r5, #0]
      break;
 800dc76:	e7e5      	b.n	800dc44 <lis3mdl_data_rate_get+0x64>
      *val = LIS3MDL_HP_80Hz;
 800dc78:	232e      	movs	r3, #46	; 0x2e
 800dc7a:	702b      	strb	r3, [r5, #0]
      break;
 800dc7c:	e7e2      	b.n	800dc44 <lis3mdl_data_rate_get+0x64>
      *val = LIS3MDL_HP_40Hz;
 800dc7e:	232c      	movs	r3, #44	; 0x2c
 800dc80:	702b      	strb	r3, [r5, #0]
      break;
 800dc82:	e7df      	b.n	800dc44 <lis3mdl_data_rate_get+0x64>
      *val = LIS3MDL_HP_20Hz;
 800dc84:	232a      	movs	r3, #42	; 0x2a
 800dc86:	702b      	strb	r3, [r5, #0]
      break;
 800dc88:	e7dc      	b.n	800dc44 <lis3mdl_data_rate_get+0x64>
      *val = LIS3MDL_HP_10Hz;
 800dc8a:	2328      	movs	r3, #40	; 0x28
 800dc8c:	702b      	strb	r3, [r5, #0]
      break;
 800dc8e:	e7d9      	b.n	800dc44 <lis3mdl_data_rate_get+0x64>
      *val = LIS3MDL_HP_5Hz;
 800dc90:	2326      	movs	r3, #38	; 0x26
 800dc92:	702b      	strb	r3, [r5, #0]
      break;
 800dc94:	e7d6      	b.n	800dc44 <lis3mdl_data_rate_get+0x64>
      *val = LIS3MDL_HP_2Hz5;
 800dc96:	2324      	movs	r3, #36	; 0x24
 800dc98:	702b      	strb	r3, [r5, #0]
      break;
 800dc9a:	e7d3      	b.n	800dc44 <lis3mdl_data_rate_get+0x64>
      *val = LIS3MDL_HP_1Hz25;
 800dc9c:	2322      	movs	r3, #34	; 0x22
 800dc9e:	702b      	strb	r3, [r5, #0]
      break;
 800dca0:	e7d0      	b.n	800dc44 <lis3mdl_data_rate_get+0x64>
      *val = LIS3MDL_HP_300Hz;
 800dca2:	2321      	movs	r3, #33	; 0x21
 800dca4:	702b      	strb	r3, [r5, #0]
      break;
 800dca6:	e7cd      	b.n	800dc44 <lis3mdl_data_rate_get+0x64>
      *val = LIS3MDL_MP_80Hz;
 800dca8:	231e      	movs	r3, #30
 800dcaa:	702b      	strb	r3, [r5, #0]
      break;
 800dcac:	e7ca      	b.n	800dc44 <lis3mdl_data_rate_get+0x64>
      *val = LIS3MDL_MP_40Hz;
 800dcae:	231c      	movs	r3, #28
 800dcb0:	702b      	strb	r3, [r5, #0]
      break;
 800dcb2:	e7c7      	b.n	800dc44 <lis3mdl_data_rate_get+0x64>
      *val = LIS3MDL_MP_20Hz;
 800dcb4:	231a      	movs	r3, #26
 800dcb6:	702b      	strb	r3, [r5, #0]
      break;
 800dcb8:	e7c4      	b.n	800dc44 <lis3mdl_data_rate_get+0x64>
      *val = LIS3MDL_MP_10Hz;
 800dcba:	2318      	movs	r3, #24
 800dcbc:	702b      	strb	r3, [r5, #0]
      break;
 800dcbe:	e7c1      	b.n	800dc44 <lis3mdl_data_rate_get+0x64>
      *val = LIS3MDL_MP_5Hz;
 800dcc0:	2316      	movs	r3, #22
 800dcc2:	702b      	strb	r3, [r5, #0]
      break;
 800dcc4:	e7be      	b.n	800dc44 <lis3mdl_data_rate_get+0x64>
      *val = LIS3MDL_MP_2Hz5;
 800dcc6:	2314      	movs	r3, #20
 800dcc8:	702b      	strb	r3, [r5, #0]
      break;
 800dcca:	e7bb      	b.n	800dc44 <lis3mdl_data_rate_get+0x64>
      *val = LIS3MDL_MP_1Hz25;
 800dccc:	2312      	movs	r3, #18
 800dcce:	702b      	strb	r3, [r5, #0]
      break;
 800dcd0:	e7b8      	b.n	800dc44 <lis3mdl_data_rate_get+0x64>
      *val = LIS3MDL_MP_560Hz;
 800dcd2:	2311      	movs	r3, #17
 800dcd4:	702b      	strb	r3, [r5, #0]
      break;
 800dcd6:	e7b5      	b.n	800dc44 <lis3mdl_data_rate_get+0x64>
      *val = LIS3MDL_LP_80Hz;
 800dcd8:	230e      	movs	r3, #14
 800dcda:	702b      	strb	r3, [r5, #0]
      break;
 800dcdc:	e7b2      	b.n	800dc44 <lis3mdl_data_rate_get+0x64>
      *val = LIS3MDL_LP_40Hz;
 800dcde:	230c      	movs	r3, #12
 800dce0:	702b      	strb	r3, [r5, #0]
      break;
 800dce2:	e7af      	b.n	800dc44 <lis3mdl_data_rate_get+0x64>
      *val = LIS3MDL_LP_20Hz;
 800dce4:	230a      	movs	r3, #10
 800dce6:	702b      	strb	r3, [r5, #0]
      break;
 800dce8:	e7ac      	b.n	800dc44 <lis3mdl_data_rate_get+0x64>
      *val = LIS3MDL_LP_10Hz;
 800dcea:	2308      	movs	r3, #8
 800dcec:	702b      	strb	r3, [r5, #0]
      break;
 800dcee:	e7a9      	b.n	800dc44 <lis3mdl_data_rate_get+0x64>
      *val = LIS3MDL_LP_5Hz;
 800dcf0:	2306      	movs	r3, #6
 800dcf2:	702b      	strb	r3, [r5, #0]
      break;
 800dcf4:	e7a6      	b.n	800dc44 <lis3mdl_data_rate_get+0x64>
      *val = LIS3MDL_LP_2Hz5;
 800dcf6:	2304      	movs	r3, #4
 800dcf8:	702b      	strb	r3, [r5, #0]
      break;
 800dcfa:	e7a3      	b.n	800dc44 <lis3mdl_data_rate_get+0x64>
      *val = LIS3MDL_LP_1Hz25;
 800dcfc:	2302      	movs	r3, #2
 800dcfe:	702b      	strb	r3, [r5, #0]
      break;
 800dd00:	e7a0      	b.n	800dc44 <lis3mdl_data_rate_get+0x64>
      *val = LIS3MDL_LP_1kHz;
 800dd02:	2301      	movs	r3, #1
 800dd04:	702b      	strb	r3, [r5, #0]
      break;
 800dd06:	e79d      	b.n	800dc44 <lis3mdl_data_rate_get+0x64>

0800dd08 <lis3mdl_full_scale_set>:
  * @param  val      change the values of fs in reg CTRL_REG2
  * @retval          interface status (MANDATORY: return 0 -> no Error)
  *
  */
int32_t lis3mdl_full_scale_set(lis3mdl_ctx_t *ctx, lis3mdl_fs_t val)
{
 800dd08:	b570      	push	{r4, r5, r6, lr}
 800dd0a:	4604      	mov	r4, r0
 800dd0c:	b082      	sub	sp, #8
 800dd0e:	460d      	mov	r5, r1
  ret = ctx->read_reg(ctx->handle, reg, data, len);
 800dd10:	6880      	ldr	r0, [r0, #8]
 800dd12:	6866      	ldr	r6, [r4, #4]
 800dd14:	2301      	movs	r3, #1
 800dd16:	aa01      	add	r2, sp, #4
 800dd18:	2121      	movs	r1, #33	; 0x21
 800dd1a:	47b0      	blx	r6
  lis3mdl_ctrl_reg2_t ctrl_reg2;
  int32_t ret;

  ret = lis3mdl_read_reg(ctx, LIS3MDL_CTRL_REG2, (uint8_t*)&ctrl_reg2, 1);
  if(ret == 0)
 800dd1c:	b958      	cbnz	r0, 800dd36 <lis3mdl_full_scale_set+0x2e>
  {
    ctrl_reg2.fs = (uint8_t)val;
 800dd1e:	f89d 3004 	ldrb.w	r3, [sp, #4]
  ret = ctx->write_reg(ctx->handle, reg, data, len);
 800dd22:	6826      	ldr	r6, [r4, #0]
 800dd24:	68a0      	ldr	r0, [r4, #8]
    ctrl_reg2.fs = (uint8_t)val;
 800dd26:	f365 1346 	bfi	r3, r5, #5, #2
 800dd2a:	f88d 3004 	strb.w	r3, [sp, #4]
  ret = ctx->write_reg(ctx->handle, reg, data, len);
 800dd2e:	aa01      	add	r2, sp, #4
 800dd30:	2301      	movs	r3, #1
 800dd32:	2121      	movs	r1, #33	; 0x21
 800dd34:	47b0      	blx	r6
    ret = lis3mdl_write_reg(ctx, LIS3MDL_CTRL_REG2, (uint8_t*)&ctrl_reg2, 1);
  }
  return ret;
}
 800dd36:	b002      	add	sp, #8
 800dd38:	bd70      	pop	{r4, r5, r6, pc}
 800dd3a:	bf00      	nop

0800dd3c <lis3mdl_full_scale_get>:
  * @param  val      get the values of fs in reg CTRL_REG2(ptr)
  * @retval          interface status (MANDATORY: return 0 -> no Error)
  *
  */
int32_t lis3mdl_full_scale_get(lis3mdl_ctx_t *ctx, lis3mdl_fs_t *val)
{
 800dd3c:	b530      	push	{r4, r5, lr}
 800dd3e:	b083      	sub	sp, #12
  ret = ctx->read_reg(ctx->handle, reg, data, len);
 800dd40:	2301      	movs	r3, #1
 800dd42:	aa01      	add	r2, sp, #4
 800dd44:	e9d0 5001 	ldrd	r5, r0, [r0, #4]
{
 800dd48:	460c      	mov	r4, r1
  ret = ctx->read_reg(ctx->handle, reg, data, len);
 800dd4a:	2121      	movs	r1, #33	; 0x21
 800dd4c:	47a8      	blx	r5
  lis3mdl_ctrl_reg2_t ctrl_reg2;
  int32_t ret;

  ret = lis3mdl_read_reg(ctx, LIS3MDL_CTRL_REG2, (uint8_t*)&ctrl_reg2, 1);
  switch (ctrl_reg2.fs)
 800dd4e:	f89d 3004 	ldrb.w	r3, [sp, #4]
 800dd52:	f3c3 1241 	ubfx	r2, r3, #5, #2
 800dd56:	2a02      	cmp	r2, #2
 800dd58:	4613      	mov	r3, r2
 800dd5a:	d007      	beq.n	800dd6c <lis3mdl_full_scale_get+0x30>
 800dd5c:	2a03      	cmp	r2, #3
 800dd5e:	d005      	beq.n	800dd6c <lis3mdl_full_scale_get+0x30>
 800dd60:	2a01      	cmp	r2, #1
 800dd62:	d003      	beq.n	800dd6c <lis3mdl_full_scale_get+0x30>
  {
    case LIS3MDL_4_GAUSS:
      *val = LIS3MDL_4_GAUSS;
 800dd64:	2300      	movs	r3, #0
 800dd66:	7023      	strb	r3, [r4, #0]
      *val = LIS3MDL_4_GAUSS;
      break;
  }

  return ret;
}
 800dd68:	b003      	add	sp, #12
 800dd6a:	bd30      	pop	{r4, r5, pc}
      *val = LIS3MDL_16_GAUSS;
 800dd6c:	7023      	strb	r3, [r4, #0]
}
 800dd6e:	b003      	add	sp, #12
 800dd70:	bd30      	pop	{r4, r5, pc}
 800dd72:	bf00      	nop

0800dd74 <lis3mdl_operating_mode_set>:
  * @param  val      change the values of md in reg CTRL_REG3
  * @retval          interface status (MANDATORY: return 0 -> no Error)
  *
  */
int32_t lis3mdl_operating_mode_set(lis3mdl_ctx_t *ctx, lis3mdl_md_t val)
{
 800dd74:	b570      	push	{r4, r5, r6, lr}
 800dd76:	4604      	mov	r4, r0
 800dd78:	b082      	sub	sp, #8
 800dd7a:	460d      	mov	r5, r1
  ret = ctx->read_reg(ctx->handle, reg, data, len);
 800dd7c:	6880      	ldr	r0, [r0, #8]
 800dd7e:	6866      	ldr	r6, [r4, #4]
 800dd80:	2301      	movs	r3, #1
 800dd82:	aa01      	add	r2, sp, #4
 800dd84:	2122      	movs	r1, #34	; 0x22
 800dd86:	47b0      	blx	r6
  lis3mdl_ctrl_reg3_t ctrl_reg3;
  int32_t ret;

  ret = lis3mdl_read_reg(ctx, LIS3MDL_CTRL_REG3, (uint8_t*)&ctrl_reg3, 1);
  if(ret == 0)
 800dd88:	b958      	cbnz	r0, 800dda2 <lis3mdl_operating_mode_set+0x2e>
  {
    ctrl_reg3.md = (uint8_t)val;
 800dd8a:	f89d 3004 	ldrb.w	r3, [sp, #4]
  ret = ctx->write_reg(ctx->handle, reg, data, len);
 800dd8e:	6826      	ldr	r6, [r4, #0]
 800dd90:	68a0      	ldr	r0, [r4, #8]
    ctrl_reg3.md = (uint8_t)val;
 800dd92:	f365 0301 	bfi	r3, r5, #0, #2
 800dd96:	f88d 3004 	strb.w	r3, [sp, #4]
  ret = ctx->write_reg(ctx->handle, reg, data, len);
 800dd9a:	aa01      	add	r2, sp, #4
 800dd9c:	2301      	movs	r3, #1
 800dd9e:	2122      	movs	r1, #34	; 0x22
 800dda0:	47b0      	blx	r6
    ret = lis3mdl_write_reg(ctx, LIS3MDL_CTRL_REG3, (uint8_t*)&ctrl_reg3, 1);
  }

  return ret;
}
 800dda2:	b002      	add	sp, #8
 800dda4:	bd70      	pop	{r4, r5, r6, pc}
 800dda6:	bf00      	nop

0800dda8 <lis3mdl_block_data_update_set>:
  * @param  val      change the values of bdu in reg CTRL_REG5
  * @retval          interface status (MANDATORY: return 0 -> no Error)
  *
  */
int32_t lis3mdl_block_data_update_set(lis3mdl_ctx_t *ctx, uint8_t val)
{
 800dda8:	b570      	push	{r4, r5, r6, lr}
 800ddaa:	4604      	mov	r4, r0
 800ddac:	b082      	sub	sp, #8
 800ddae:	460d      	mov	r5, r1
  ret = ctx->read_reg(ctx->handle, reg, data, len);
 800ddb0:	6880      	ldr	r0, [r0, #8]
 800ddb2:	6866      	ldr	r6, [r4, #4]
 800ddb4:	2301      	movs	r3, #1
 800ddb6:	aa01      	add	r2, sp, #4
 800ddb8:	2124      	movs	r1, #36	; 0x24
 800ddba:	47b0      	blx	r6
  lis3mdl_ctrl_reg5_t ctrl_reg5;
  int32_t ret;

  ret = lis3mdl_read_reg(ctx, LIS3MDL_CTRL_REG5, (uint8_t*)&ctrl_reg5, 1);
  if(ret == 0)
 800ddbc:	b958      	cbnz	r0, 800ddd6 <lis3mdl_block_data_update_set+0x2e>
  {
    ctrl_reg5.bdu = val;
 800ddbe:	f89d 3004 	ldrb.w	r3, [sp, #4]
  ret = ctx->write_reg(ctx->handle, reg, data, len);
 800ddc2:	6826      	ldr	r6, [r4, #0]
 800ddc4:	68a0      	ldr	r0, [r4, #8]
    ctrl_reg5.bdu = val;
 800ddc6:	f365 1386 	bfi	r3, r5, #6, #1
 800ddca:	f88d 3004 	strb.w	r3, [sp, #4]
  ret = ctx->write_reg(ctx->handle, reg, data, len);
 800ddce:	aa01      	add	r2, sp, #4
 800ddd0:	2301      	movs	r3, #1
 800ddd2:	2124      	movs	r1, #36	; 0x24
 800ddd4:	47b0      	blx	r6
    ret = lis3mdl_write_reg(ctx, LIS3MDL_CTRL_REG5, (uint8_t*)&ctrl_reg5, 1);
  }
  return ret;
}
 800ddd6:	b002      	add	sp, #8
 800ddd8:	bd70      	pop	{r4, r5, r6, pc}
 800ddda:	bf00      	nop

0800dddc <lis3mdl_magnetic_raw_get>:
  * @param  val      buffer that stores data read(ptr)
  * @retval          interface status (MANDATORY: return 0 -> no Error)
  *
  */
int32_t lis3mdl_magnetic_raw_get(lis3mdl_ctx_t *ctx, uint8_t *buff)
{
 800dddc:	b410      	push	{r4}
  ret = ctx->read_reg(ctx->handle, reg, data, len);
 800ddde:	e9d0 4001 	ldrd	r4, r0, [r0, #4]
{
 800dde2:	460a      	mov	r2, r1
  ret = ctx->read_reg(ctx->handle, reg, data, len);
 800dde4:	46a4      	mov	ip, r4
 800dde6:	2306      	movs	r3, #6
  int32_t ret;
  ret = lis3mdl_read_reg(ctx, LIS3MDL_OUT_X_L, (uint8_t*) buff, 6);
  return ret;
}
 800dde8:	f85d 4b04 	ldr.w	r4, [sp], #4
  ret = ctx->read_reg(ctx->handle, reg, data, len);
 800ddec:	2128      	movs	r1, #40	; 0x28
 800ddee:	4760      	bx	ip

0800ddf0 <lis3mdl_device_id_get>:
  * @param  val      buffer that stores data read(ptr)
  * @retval          interface status (MANDATORY: return 0 -> no Error)
  *
  */
int32_t lis3mdl_device_id_get(lis3mdl_ctx_t *ctx, uint8_t *buff)
{
 800ddf0:	b410      	push	{r4}
  ret = ctx->read_reg(ctx->handle, reg, data, len);
 800ddf2:	e9d0 4001 	ldrd	r4, r0, [r0, #4]
{
 800ddf6:	460a      	mov	r2, r1
  ret = ctx->read_reg(ctx->handle, reg, data, len);
 800ddf8:	46a4      	mov	ip, r4
 800ddfa:	2301      	movs	r3, #1
  int32_t ret;  
  ret = lis3mdl_read_reg(ctx, LIS3MDL_WHO_AM_I, (uint8_t*) buff, 1);
  return ret;
}
 800ddfc:	f85d 4b04 	ldr.w	r4, [sp], #4
  ret = ctx->read_reg(ctx->handle, reg, data, len);
 800de00:	210f      	movs	r1, #15
 800de02:	4760      	bx	ip

0800de04 <LPS22HB_GetCapabilities>:
  Capabilities->Humidity    = 0;
  Capabilities->Pressure    = 1;
  Capabilities->Temperature = 1;
  Capabilities->LowPower    = 0;
  Capabilities->HumMaxOdr   = 0.0f;
  Capabilities->TempMaxOdr  = 75.0f;
 800de04:	4b04      	ldr	r3, [pc, #16]	; (800de18 <LPS22HB_GetCapabilities+0x14>)
 800de06:	608b      	str	r3, [r1, #8]
  Capabilities->HumMaxOdr   = 0.0f;
 800de08:	2200      	movs	r2, #0
  Capabilities->Temperature = 1;
 800de0a:	f240 1001 	movw	r0, #257	; 0x101
 800de0e:	6008      	str	r0, [r1, #0]
  Capabilities->HumMaxOdr   = 0.0f;
 800de10:	604a      	str	r2, [r1, #4]
  Capabilities->PressMaxOdr = 75.0f;
 800de12:	60cb      	str	r3, [r1, #12]
  return LPS22HB_OK;
}
 800de14:	2000      	movs	r0, #0
 800de16:	4770      	bx	lr
 800de18:	42960000 	.word	0x42960000

0800de1c <LPS22HB_Init>:
{
 800de1c:	b538      	push	{r3, r4, r5, lr}
  if (pObj->is_initialized == 0U)
 800de1e:	f890 3028 	ldrb.w	r3, [r0, #40]	; 0x28
{
 800de22:	4604      	mov	r4, r0
  if (pObj->is_initialized == 0U)
 800de24:	b123      	cbz	r3, 800de30 <LPS22HB_Init+0x14>
  pObj->is_initialized = 1U;
 800de26:	2301      	movs	r3, #1
 800de28:	f884 3028 	strb.w	r3, [r4, #40]	; 0x28
  return LPS22HB_OK;
 800de2c:	2000      	movs	r0, #0
}
 800de2e:	bd38      	pop	{r3, r4, r5, pc}
 * @retval 0 in case of success, an error code otherwise
 */
static int32_t LPS22HB_Initialize(LPS22HB_Object_t *pObj)
{
  /* Set Power mode */
  if (lps22hb_low_power_set(&(pObj->Ctx), PROPERTY_ENABLE) != LPS22HB_OK)
 800de30:	f100 051c 	add.w	r5, r0, #28
 800de34:	2101      	movs	r1, #1
 800de36:	4628      	mov	r0, r5
 800de38:	f000 fb7e 	bl	800e538 <lps22hb_low_power_set>
 800de3c:	4601      	mov	r1, r0
 800de3e:	b9c8      	cbnz	r0, 800de74 <LPS22HB_Init+0x58>
  {
    return LPS22HB_ERROR;
  }

  /* Power down the device */
  if (lps22hb_data_rate_set(&(pObj->Ctx), LPS22HB_POWER_DOWN) != LPS22HB_OK)
 800de40:	4628      	mov	r0, r5
 800de42:	f000 fafb 	bl	800e43c <lps22hb_data_rate_set>
 800de46:	b9a8      	cbnz	r0, 800de74 <LPS22HB_Init+0x58>
  {
    return LPS22HB_ERROR;
  }

  /* Disable low-pass filter on LPS22HB pressure data */
  if (lps22hb_low_pass_filter_mode_set(&(pObj->Ctx), LPS22HB_LPF_ODR_DIV_9) != LPS22HB_OK)
 800de48:	2102      	movs	r1, #2
 800de4a:	4628      	mov	r0, r5
 800de4c:	f000 fadc 	bl	800e408 <lps22hb_low_pass_filter_mode_set>
 800de50:	b980      	cbnz	r0, 800de74 <LPS22HB_Init+0x58>
  {
    return LPS22HB_ERROR;
  }

  if (lps22hb_block_data_update_set(&(pObj->Ctx), PROPERTY_ENABLE) != LPS22HB_OK)
 800de52:	2101      	movs	r1, #1
 800de54:	4628      	mov	r0, r5
 800de56:	f000 fabd 	bl	800e3d4 <lps22hb_block_data_update_set>
 800de5a:	b958      	cbnz	r0, 800de74 <LPS22HB_Init+0x58>
  {
    return LPS22HB_ERROR;
  }

  if (pObj->IO.BusType == LPS22HB_I2C_BUS) /* I2C */
 800de5c:	68a1      	ldr	r1, [r4, #8]
 800de5e:	b939      	cbnz	r1, 800de70 <LPS22HB_Init+0x54>
      return LPS22HB_ERROR;
    }
  }
  else /* SPI 4-Wires or SPI 3-Wires */
  {
    if (lps22hb_auto_add_inc_set(&(pObj->Ctx), PROPERTY_ENABLE) != LPS22HB_OK)
 800de60:	4628      	mov	r0, r5
 800de62:	f000 fb83 	bl	800e56c <lps22hb_auto_add_inc_set>
 800de66:	b928      	cbnz	r0, 800de74 <LPS22HB_Init+0x58>
    {
      return LPS22HB_ERROR;
    }
  }

  pObj->last_odr = LPS22HB_ODR_25_Hz;
 800de68:	2303      	movs	r3, #3
 800de6a:	f884 302b 	strb.w	r3, [r4, #43]	; 0x2b

  return LPS22HB_OK;
 800de6e:	e7da      	b.n	800de26 <LPS22HB_Init+0xa>
    if (lps22hb_auto_add_inc_set(&(pObj->Ctx), PROPERTY_ENABLE) != LPS22HB_OK)
 800de70:	2101      	movs	r1, #1
 800de72:	e7f5      	b.n	800de60 <LPS22HB_Init+0x44>
      return LPS22HB_ERROR;
 800de74:	f04f 30ff 	mov.w	r0, #4294967295
}
 800de78:	bd38      	pop	{r3, r4, r5, pc}
 800de7a:	bf00      	nop

0800de7c <LPS22HB_ReadID>:
{
 800de7c:	b508      	push	{r3, lr}
  if (lps22hb_device_id_get(&(pObj->Ctx), Id) != LPS22HB_OK)
 800de7e:	301c      	adds	r0, #28
 800de80:	f000 fb50 	bl	800e524 <lps22hb_device_id_get>
 800de84:	3800      	subs	r0, #0
 800de86:	bf18      	it	ne
 800de88:	2001      	movne	r0, #1
}
 800de8a:	4240      	negs	r0, r0
 800de8c:	bd08      	pop	{r3, pc}
 800de8e:	bf00      	nop

0800de90 <LPS22HB_PRESS_GetOutputDataRate>:
{
 800de90:	b510      	push	{r4, lr}
 800de92:	b082      	sub	sp, #8
 800de94:	460c      	mov	r4, r1
  if (lps22hb_data_rate_get(&(pObj->Ctx), &odr_low_level) != LPS22HB_OK)
 800de96:	301c      	adds	r0, #28
 800de98:	f10d 0107 	add.w	r1, sp, #7
 800de9c:	f000 fae8 	bl	800e470 <lps22hb_data_rate_get>
 800dea0:	bb08      	cbnz	r0, 800dee6 <LPS22HB_PRESS_GetOutputDataRate+0x56>
  switch (odr_low_level)
 800dea2:	f89d 3007 	ldrb.w	r3, [sp, #7]
 800dea6:	2b05      	cmp	r3, #5
 800dea8:	d81d      	bhi.n	800dee6 <LPS22HB_PRESS_GetOutputDataRate+0x56>
 800deaa:	e8df f003 	tbb	[pc, r3]
 800deae:	0b07      	.short	0x0b07
 800deb0:	03181410 	.word	0x03181410
      *Odr = 75.0f;
 800deb4:	4b0d      	ldr	r3, [pc, #52]	; (800deec <LPS22HB_PRESS_GetOutputDataRate+0x5c>)
 800deb6:	6023      	str	r3, [r4, #0]
}
 800deb8:	b002      	add	sp, #8
 800deba:	bd10      	pop	{r4, pc}
      *Odr = 0.0f;
 800debc:	2300      	movs	r3, #0
 800debe:	6023      	str	r3, [r4, #0]
}
 800dec0:	b002      	add	sp, #8
 800dec2:	bd10      	pop	{r4, pc}
      *Odr = 1.0f;
 800dec4:	f04f 537e 	mov.w	r3, #1065353216	; 0x3f800000
 800dec8:	6023      	str	r3, [r4, #0]
}
 800deca:	b002      	add	sp, #8
 800decc:	bd10      	pop	{r4, pc}
      *Odr = 10.0f;
 800dece:	4b08      	ldr	r3, [pc, #32]	; (800def0 <LPS22HB_PRESS_GetOutputDataRate+0x60>)
 800ded0:	6023      	str	r3, [r4, #0]
}
 800ded2:	b002      	add	sp, #8
 800ded4:	bd10      	pop	{r4, pc}
      *Odr = 25.0f;
 800ded6:	4b07      	ldr	r3, [pc, #28]	; (800def4 <LPS22HB_PRESS_GetOutputDataRate+0x64>)
 800ded8:	6023      	str	r3, [r4, #0]
}
 800deda:	b002      	add	sp, #8
 800dedc:	bd10      	pop	{r4, pc}
      *Odr = 50.0f;
 800dede:	4b06      	ldr	r3, [pc, #24]	; (800def8 <LPS22HB_PRESS_GetOutputDataRate+0x68>)
 800dee0:	6023      	str	r3, [r4, #0]
}
 800dee2:	b002      	add	sp, #8
 800dee4:	bd10      	pop	{r4, pc}
  switch (odr_low_level)
 800dee6:	f04f 30ff 	mov.w	r0, #4294967295
  return LPS22HB_GetOutputDataRate(pObj, Odr);
 800deea:	e7e5      	b.n	800deb8 <LPS22HB_PRESS_GetOutputDataRate+0x28>
 800deec:	42960000 	.word	0x42960000
 800def0:	41200000 	.word	0x41200000
 800def4:	41c80000 	.word	0x41c80000
 800def8:	42480000 	.word	0x42480000

0800defc <LPS22HB_SetOutputDataRate_When_Enabled>:
            : (Odr <= 10.0f) ? LPS22HB_ODR_10_Hz
 800defc:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
 800df00:	eeb4 0ae7 	vcmpe.f32	s0, s15
 800df04:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
{
 800df08:	b538      	push	{r3, r4, r5, lr}
 800df0a:	4604      	mov	r4, r0
            : (Odr <= 10.0f) ? LPS22HB_ODR_10_Hz
 800df0c:	d920      	bls.n	800df50 <LPS22HB_SetOutputDataRate_When_Enabled+0x54>
 800df0e:	eef2 7a04 	vmov.f32	s15, #36	; 0x41200000  10.0
 800df12:	eeb4 0ae7 	vcmpe.f32	s0, s15
 800df16:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800df1a:	d810      	bhi.n	800df3e <LPS22HB_SetOutputDataRate_When_Enabled+0x42>
 800df1c:	2102      	movs	r1, #2
  if (lps22hb_data_rate_set(&(pObj->Ctx), new_odr) != LPS22HB_OK)
 800df1e:	f104 051c 	add.w	r5, r4, #28
 800df22:	4628      	mov	r0, r5
 800df24:	f000 fa8a 	bl	800e43c <lps22hb_data_rate_set>
 800df28:	b9f0      	cbnz	r0, 800df68 <LPS22HB_SetOutputDataRate_When_Enabled+0x6c>
  if (lps22hb_data_rate_get(&(pObj->Ctx), &pObj->last_odr) != LPS22HB_OK)
 800df2a:	f104 012b 	add.w	r1, r4, #43	; 0x2b
 800df2e:	4628      	mov	r0, r5
 800df30:	f000 fa9e 	bl	800e470 <lps22hb_data_rate_get>
 800df34:	3800      	subs	r0, #0
 800df36:	bf18      	it	ne
 800df38:	2001      	movne	r0, #1
 800df3a:	4240      	negs	r0, r0
}
 800df3c:	bd38      	pop	{r3, r4, r5, pc}
            : (Odr <= 10.0f) ? LPS22HB_ODR_10_Hz
 800df3e:	eef3 7a09 	vmov.f32	s15, #57	; 0x41c80000  25.0
 800df42:	eeb4 0ae7 	vcmpe.f32	s0, s15
 800df46:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800df4a:	d803      	bhi.n	800df54 <LPS22HB_SetOutputDataRate_When_Enabled+0x58>
 800df4c:	2103      	movs	r1, #3
 800df4e:	e7e6      	b.n	800df1e <LPS22HB_SetOutputDataRate_When_Enabled+0x22>
 800df50:	2101      	movs	r1, #1
 800df52:	e7e4      	b.n	800df1e <LPS22HB_SetOutputDataRate_When_Enabled+0x22>
 800df54:	eddf 7a06 	vldr	s15, [pc, #24]	; 800df70 <LPS22HB_SetOutputDataRate_When_Enabled+0x74>
 800df58:	eeb4 0ae7 	vcmpe.f32	s0, s15
 800df5c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800df60:	bf94      	ite	ls
 800df62:	2104      	movls	r1, #4
 800df64:	2105      	movhi	r1, #5
 800df66:	e7da      	b.n	800df1e <LPS22HB_SetOutputDataRate_When_Enabled+0x22>
    return LPS22HB_ERROR;
 800df68:	f04f 30ff 	mov.w	r0, #4294967295
}
 800df6c:	bd38      	pop	{r3, r4, r5, pc}
 800df6e:	bf00      	nop
 800df70:	42480000 	.word	0x42480000

0800df74 <LPS22HB_PRESS_SetOutputDataRate>:
  if (pObj->press_is_enabled == 1U)
 800df74:	f890 2029 	ldrb.w	r2, [r0, #41]	; 0x29
 800df78:	2a01      	cmp	r2, #1
{
 800df7a:	4603      	mov	r3, r0
  if (pObj->press_is_enabled == 1U)
 800df7c:	d023      	beq.n	800dfc6 <LPS22HB_PRESS_SetOutputDataRate+0x52>
                   : (Odr <= 10.0f) ? LPS22HB_ODR_10_Hz
 800df7e:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
 800df82:	eeb4 0ac7 	vcmpe.f32	s0, s14
 800df86:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800df8a:	d912      	bls.n	800dfb2 <LPS22HB_PRESS_SetOutputDataRate+0x3e>
 800df8c:	eeb2 7a04 	vmov.f32	s14, #36	; 0x41200000  10.0
 800df90:	eeb4 0ac7 	vcmpe.f32	s0, s14
 800df94:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800df98:	d910      	bls.n	800dfbc <LPS22HB_PRESS_SetOutputDataRate+0x48>
 800df9a:	eeb3 7a09 	vmov.f32	s14, #57	; 0x41c80000  25.0
 800df9e:	eeb4 0ac7 	vcmpe.f32	s0, s14
 800dfa2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800dfa6:	d810      	bhi.n	800dfca <LPS22HB_PRESS_SetOutputDataRate+0x56>
 800dfa8:	2203      	movs	r2, #3
  pObj->last_odr = (Odr <=  1.0f) ? LPS22HB_ODR_1_Hz
 800dfaa:	f883 202b 	strb.w	r2, [r3, #43]	; 0x2b
}
 800dfae:	2000      	movs	r0, #0
 800dfb0:	4770      	bx	lr
                   : (Odr <= 10.0f) ? LPS22HB_ODR_10_Hz
 800dfb2:	2201      	movs	r2, #1
  pObj->last_odr = (Odr <=  1.0f) ? LPS22HB_ODR_1_Hz
 800dfb4:	f883 202b 	strb.w	r2, [r3, #43]	; 0x2b
}
 800dfb8:	2000      	movs	r0, #0
 800dfba:	4770      	bx	lr
                   : (Odr <= 10.0f) ? LPS22HB_ODR_10_Hz
 800dfbc:	2202      	movs	r2, #2
  pObj->last_odr = (Odr <=  1.0f) ? LPS22HB_ODR_1_Hz
 800dfbe:	f883 202b 	strb.w	r2, [r3, #43]	; 0x2b
}
 800dfc2:	2000      	movs	r0, #0
 800dfc4:	4770      	bx	lr
    return LPS22HB_SetOutputDataRate_When_Enabled(pObj, Odr);
 800dfc6:	f7ff bf99 	b.w	800defc <LPS22HB_SetOutputDataRate_When_Enabled>
                   : (Odr <= 10.0f) ? LPS22HB_ODR_10_Hz
 800dfca:	ed9f 7a06 	vldr	s14, [pc, #24]	; 800dfe4 <LPS22HB_PRESS_SetOutputDataRate+0x70>
 800dfce:	eeb4 0ac7 	vcmpe.f32	s0, s14
 800dfd2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800dfd6:	bf94      	ite	ls
 800dfd8:	2204      	movls	r2, #4
 800dfda:	2205      	movhi	r2, #5
  pObj->last_odr = (Odr <=  1.0f) ? LPS22HB_ODR_1_Hz
 800dfdc:	f883 202b 	strb.w	r2, [r3, #43]	; 0x2b
}
 800dfe0:	2000      	movs	r0, #0
 800dfe2:	4770      	bx	lr
 800dfe4:	42480000 	.word	0x42480000

0800dfe8 <LPS22HB_TEMP_SetOutputDataRate>:
  if (pObj->temp_is_enabled == 1U)
 800dfe8:	f890 202a 	ldrb.w	r2, [r0, #42]	; 0x2a
 800dfec:	2a01      	cmp	r2, #1
{
 800dfee:	4603      	mov	r3, r0
  if (pObj->temp_is_enabled == 1U)
 800dff0:	d023      	beq.n	800e03a <LPS22HB_TEMP_SetOutputDataRate+0x52>
                   : (Odr <= 10.0f) ? LPS22HB_ODR_10_Hz
 800dff2:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
 800dff6:	eeb4 0ac7 	vcmpe.f32	s0, s14
 800dffa:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800dffe:	d912      	bls.n	800e026 <LPS22HB_TEMP_SetOutputDataRate+0x3e>
 800e000:	eeb2 7a04 	vmov.f32	s14, #36	; 0x41200000  10.0
 800e004:	eeb4 0ac7 	vcmpe.f32	s0, s14
 800e008:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800e00c:	d910      	bls.n	800e030 <LPS22HB_TEMP_SetOutputDataRate+0x48>
 800e00e:	eeb3 7a09 	vmov.f32	s14, #57	; 0x41c80000  25.0
 800e012:	eeb4 0ac7 	vcmpe.f32	s0, s14
 800e016:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800e01a:	d810      	bhi.n	800e03e <LPS22HB_TEMP_SetOutputDataRate+0x56>
 800e01c:	2203      	movs	r2, #3
  pObj->last_odr = (Odr <=  1.0f) ? LPS22HB_ODR_1_Hz
 800e01e:	f883 202b 	strb.w	r2, [r3, #43]	; 0x2b
}
 800e022:	2000      	movs	r0, #0
 800e024:	4770      	bx	lr
                   : (Odr <= 10.0f) ? LPS22HB_ODR_10_Hz
 800e026:	2201      	movs	r2, #1
  pObj->last_odr = (Odr <=  1.0f) ? LPS22HB_ODR_1_Hz
 800e028:	f883 202b 	strb.w	r2, [r3, #43]	; 0x2b
}
 800e02c:	2000      	movs	r0, #0
 800e02e:	4770      	bx	lr
                   : (Odr <= 10.0f) ? LPS22HB_ODR_10_Hz
 800e030:	2202      	movs	r2, #2
  pObj->last_odr = (Odr <=  1.0f) ? LPS22HB_ODR_1_Hz
 800e032:	f883 202b 	strb.w	r2, [r3, #43]	; 0x2b
}
 800e036:	2000      	movs	r0, #0
 800e038:	4770      	bx	lr
    return LPS22HB_SetOutputDataRate_When_Enabled(pObj, Odr);
 800e03a:	f7ff bf5f 	b.w	800defc <LPS22HB_SetOutputDataRate_When_Enabled>
                   : (Odr <= 10.0f) ? LPS22HB_ODR_10_Hz
 800e03e:	ed9f 7a06 	vldr	s14, [pc, #24]	; 800e058 <LPS22HB_TEMP_SetOutputDataRate+0x70>
 800e042:	eeb4 0ac7 	vcmpe.f32	s0, s14
 800e046:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800e04a:	bf94      	ite	ls
 800e04c:	2204      	movls	r2, #4
 800e04e:	2205      	movhi	r2, #5
  pObj->last_odr = (Odr <=  1.0f) ? LPS22HB_ODR_1_Hz
 800e050:	f883 202b 	strb.w	r2, [r3, #43]	; 0x2b
}
 800e054:	2000      	movs	r0, #0
 800e056:	4770      	bx	lr
 800e058:	42480000 	.word	0x42480000

0800e05c <LPS22HB_PRESS_GetPressure>:
{
 800e05c:	b530      	push	{r4, r5, lr}
 800e05e:	b083      	sub	sp, #12
 800e060:	460d      	mov	r5, r1
  (void)memset(data_raw_pressure.u8bit, 0x00, sizeof(int32_t));
 800e062:	2200      	movs	r2, #0
  if (lps22hb_pressure_raw_get(&(pObj->Ctx), data_raw_pressure.u8bit) != LPS22HB_OK)
 800e064:	a901      	add	r1, sp, #4
 800e066:	301c      	adds	r0, #28
  (void)memset(data_raw_pressure.u8bit, 0x00, sizeof(int32_t));
 800e068:	9201      	str	r2, [sp, #4]
  if (lps22hb_pressure_raw_get(&(pObj->Ctx), data_raw_pressure.u8bit) != LPS22HB_OK)
 800e06a:	f000 fa47 	bl	800e4fc <lps22hb_pressure_raw_get>
 800e06e:	b940      	cbnz	r0, 800e082 <LPS22HB_PRESS_GetPressure+0x26>
  *Value = lps22hb_from_lsb_to_hpa(data_raw_pressure.i32bit);
 800e070:	4604      	mov	r4, r0
 800e072:	9801      	ldr	r0, [sp, #4]
 800e074:	f000 f99c 	bl	800e3b0 <lps22hb_from_lsb_to_hpa>
 800e078:	ed85 0a00 	vstr	s0, [r5]
}
 800e07c:	4620      	mov	r0, r4
 800e07e:	b003      	add	sp, #12
 800e080:	bd30      	pop	{r4, r5, pc}
    return LPS22HB_ERROR;
 800e082:	f04f 34ff 	mov.w	r4, #4294967295
 800e086:	e7f9      	b.n	800e07c <LPS22HB_PRESS_GetPressure+0x20>

0800e088 <LPS22HB_TEMP_GetTemperature>:
{
 800e088:	b530      	push	{r4, r5, lr}
 800e08a:	b083      	sub	sp, #12
 800e08c:	460d      	mov	r5, r1
  (void)memset(data_raw_temperature.u8bit, 0x00, sizeof(int16_t));
 800e08e:	2200      	movs	r2, #0
  if (lps22hb_temperature_raw_get(&(pObj->Ctx), data_raw_temperature.u8bit) != LPS22HB_OK)
 800e090:	a901      	add	r1, sp, #4
 800e092:	301c      	adds	r0, #28
  (void)memset(data_raw_temperature.u8bit, 0x00, sizeof(int16_t));
 800e094:	f8ad 2004 	strh.w	r2, [sp, #4]
  if (lps22hb_temperature_raw_get(&(pObj->Ctx), data_raw_temperature.u8bit) != LPS22HB_OK)
 800e098:	f000 fa3a 	bl	800e510 <lps22hb_temperature_raw_get>
 800e09c:	b948      	cbnz	r0, 800e0b2 <LPS22HB_TEMP_GetTemperature+0x2a>
  *Value = lps22hb_from_lsb_to_degc(data_raw_temperature.i16bit);
 800e09e:	4604      	mov	r4, r0
 800e0a0:	f9bd 0004 	ldrsh.w	r0, [sp, #4]
 800e0a4:	f000 f98a 	bl	800e3bc <lps22hb_from_lsb_to_degc>
 800e0a8:	ed85 0a00 	vstr	s0, [r5]
}
 800e0ac:	4620      	mov	r0, r4
 800e0ae:	b003      	add	sp, #12
 800e0b0:	bd30      	pop	{r4, r5, pc}
    return LPS22HB_ERROR;
 800e0b2:	f04f 34ff 	mov.w	r4, #4294967295
 800e0b6:	e7f9      	b.n	800e0ac <LPS22HB_TEMP_GetTemperature+0x24>

0800e0b8 <ReadRegWrap>:
 * @param  pData the stored data pointer
 * @param  Length the length
 * @retval 0 in case of success, an error code otherwise
 */
static int32_t ReadRegWrap(void *Handle, uint8_t Reg, uint8_t *pData, uint16_t Length)
{
 800e0b8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  uint16_t i;
  int32_t ret = LPS22HB_OK;
  LPS22HB_Object_t *pObj = (LPS22HB_Object_t *)Handle;

  if (pObj->IO.BusType == LPS22HB_I2C_BUS) /* I2C */
 800e0bc:	6884      	ldr	r4, [r0, #8]
{
 800e0be:	4605      	mov	r5, r0
  if (pObj->IO.BusType == LPS22HB_I2C_BUS) /* I2C */
 800e0c0:	b9bc      	cbnz	r4, 800e0f2 <ReadRegWrap+0x3a>
  {
    for (i = 0; i < Length; i++)
 800e0c2:	b1e3      	cbz	r3, 800e0fe <ReadRegWrap+0x46>
 800e0c4:	1e58      	subs	r0, r3, #1
    {
      ret = pObj->IO.ReadReg(pObj->IO.Address, (Reg + i), &pData[i], 1);
 800e0c6:	4614      	mov	r4, r2
 800e0c8:	fa12 f880 	uxtah	r8, r2, r0
 800e0cc:	1a8f      	subs	r7, r1, r2
 800e0ce:	e002      	b.n	800e0d6 <ReadRegWrap+0x1e>
    for (i = 0; i < Length; i++)
 800e0d0:	4544      	cmp	r4, r8
 800e0d2:	d014      	beq.n	800e0fe <ReadRegWrap+0x46>
 800e0d4:	461c      	mov	r4, r3
      ret = pObj->IO.ReadReg(pObj->IO.Address, (Reg + i), &pData[i], 1);
 800e0d6:	1939      	adds	r1, r7, r4
 800e0d8:	2301      	movs	r3, #1
 800e0da:	7b28      	ldrb	r0, [r5, #12]
 800e0dc:	696e      	ldr	r6, [r5, #20]
 800e0de:	4622      	mov	r2, r4
 800e0e0:	b289      	uxth	r1, r1
 800e0e2:	47b0      	blx	r6
    for (i = 0; i < Length; i++)
 800e0e4:	1c63      	adds	r3, r4, #1
      if (ret != LPS22HB_OK)
 800e0e6:	2800      	cmp	r0, #0
 800e0e8:	d0f2      	beq.n	800e0d0 <ReadRegWrap+0x18>
      {
        return LPS22HB_ERROR;
 800e0ea:	f04f 30ff 	mov.w	r0, #4294967295
  }
  else /* SPI 4-Wires or SPI 3-Wires */
  {
    return pObj->IO.ReadReg(pObj->IO.Address, Reg, pData, Length);
  }
}
 800e0ee:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    return pObj->IO.ReadReg(pObj->IO.Address, Reg, pData, Length);
 800e0f2:	6944      	ldr	r4, [r0, #20]
 800e0f4:	7b00      	ldrb	r0, [r0, #12]
 800e0f6:	46a4      	mov	ip, r4
}
 800e0f8:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    return pObj->IO.ReadReg(pObj->IO.Address, Reg, pData, Length);
 800e0fc:	4760      	bx	ip
 800e0fe:	2000      	movs	r0, #0
}
 800e100:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

0800e104 <WriteRegWrap>:
 * @param  pData the stored data pointer
 * @param  Length the length
 * @retval 0 in case of success, an error code otherwise
 */
static int32_t WriteRegWrap(void *Handle, uint8_t Reg, uint8_t *pData, uint16_t Length)
{
 800e104:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  uint16_t i;
  int32_t ret = LPS22HB_OK;
  LPS22HB_Object_t *pObj = (LPS22HB_Object_t *)Handle;

  if (pObj->IO.BusType == LPS22HB_I2C_BUS) /* I2C */
 800e108:	6884      	ldr	r4, [r0, #8]
{
 800e10a:	4605      	mov	r5, r0
  if (pObj->IO.BusType == LPS22HB_I2C_BUS) /* I2C */
 800e10c:	b9bc      	cbnz	r4, 800e13e <WriteRegWrap+0x3a>
  {
    for (i = 0; i < Length; i++)
 800e10e:	b1e3      	cbz	r3, 800e14a <WriteRegWrap+0x46>
 800e110:	1e58      	subs	r0, r3, #1
    {
      ret = pObj->IO.WriteReg(pObj->IO.Address, (Reg + i), &pData[i], 1);
 800e112:	4614      	mov	r4, r2
 800e114:	fa12 f880 	uxtah	r8, r2, r0
 800e118:	1a8f      	subs	r7, r1, r2
 800e11a:	e002      	b.n	800e122 <WriteRegWrap+0x1e>
    for (i = 0; i < Length; i++)
 800e11c:	4544      	cmp	r4, r8
 800e11e:	d014      	beq.n	800e14a <WriteRegWrap+0x46>
 800e120:	461c      	mov	r4, r3
      ret = pObj->IO.WriteReg(pObj->IO.Address, (Reg + i), &pData[i], 1);
 800e122:	1939      	adds	r1, r7, r4
 800e124:	2301      	movs	r3, #1
 800e126:	7b28      	ldrb	r0, [r5, #12]
 800e128:	692e      	ldr	r6, [r5, #16]
 800e12a:	4622      	mov	r2, r4
 800e12c:	b289      	uxth	r1, r1
 800e12e:	47b0      	blx	r6
    for (i = 0; i < Length; i++)
 800e130:	1c63      	adds	r3, r4, #1
      if (ret != LPS22HB_OK)
 800e132:	2800      	cmp	r0, #0
 800e134:	d0f2      	beq.n	800e11c <WriteRegWrap+0x18>
      {
        return LPS22HB_ERROR;
 800e136:	f04f 30ff 	mov.w	r0, #4294967295
  }
  else /* SPI 4-Wires or SPI 3-Wires */
  {
    return pObj->IO.WriteReg(pObj->IO.Address, Reg, pData, Length);
  }
}
 800e13a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    return pObj->IO.WriteReg(pObj->IO.Address, Reg, pData, Length);
 800e13e:	6904      	ldr	r4, [r0, #16]
 800e140:	7b00      	ldrb	r0, [r0, #12]
 800e142:	46a4      	mov	ip, r4
}
 800e144:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    return pObj->IO.WriteReg(pObj->IO.Address, Reg, pData, Length);
 800e148:	4760      	bx	ip
 800e14a:	2000      	movs	r0, #0
}
 800e14c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

0800e150 <LPS22HB_PRESS_Enable>:
  if (pObj->press_is_enabled == 1U)
 800e150:	f890 3029 	ldrb.w	r3, [r0, #41]	; 0x29
 800e154:	2b01      	cmp	r3, #1
 800e156:	d00b      	beq.n	800e170 <LPS22HB_PRESS_Enable+0x20>
{
 800e158:	b510      	push	{r4, lr}
 800e15a:	4604      	mov	r4, r0
  if (lps22hb_data_rate_set(&(pObj->Ctx), pObj->last_odr) != LPS22HB_OK)
 800e15c:	f890 102b 	ldrb.w	r1, [r0, #43]	; 0x2b
 800e160:	301c      	adds	r0, #28
 800e162:	f000 f96b 	bl	800e43c <lps22hb_data_rate_set>
 800e166:	b928      	cbnz	r0, 800e174 <LPS22HB_PRESS_Enable+0x24>
  pObj->press_is_enabled = 1;
 800e168:	2301      	movs	r3, #1
 800e16a:	f884 3029 	strb.w	r3, [r4, #41]	; 0x29
}
 800e16e:	bd10      	pop	{r4, pc}
    return LPS22HB_OK;
 800e170:	2000      	movs	r0, #0
}
 800e172:	4770      	bx	lr
    return LPS22HB_ERROR;
 800e174:	f04f 30ff 	mov.w	r0, #4294967295
}
 800e178:	bd10      	pop	{r4, pc}
 800e17a:	bf00      	nop

0800e17c <LPS22HB_TEMP_Enable>:
  if (pObj->temp_is_enabled == 1U)
 800e17c:	f890 302a 	ldrb.w	r3, [r0, #42]	; 0x2a
 800e180:	2b01      	cmp	r3, #1
 800e182:	d00b      	beq.n	800e19c <LPS22HB_TEMP_Enable+0x20>
{
 800e184:	b510      	push	{r4, lr}
 800e186:	4604      	mov	r4, r0
  if (lps22hb_data_rate_set(&(pObj->Ctx), pObj->last_odr) != LPS22HB_OK)
 800e188:	f890 102b 	ldrb.w	r1, [r0, #43]	; 0x2b
 800e18c:	301c      	adds	r0, #28
 800e18e:	f000 f955 	bl	800e43c <lps22hb_data_rate_set>
 800e192:	b928      	cbnz	r0, 800e1a0 <LPS22HB_TEMP_Enable+0x24>
  pObj->temp_is_enabled = 1;
 800e194:	2301      	movs	r3, #1
 800e196:	f884 302a 	strb.w	r3, [r4, #42]	; 0x2a
}
 800e19a:	bd10      	pop	{r4, pc}
    return LPS22HB_OK;
 800e19c:	2000      	movs	r0, #0
}
 800e19e:	4770      	bx	lr
    return LPS22HB_ERROR;
 800e1a0:	f04f 30ff 	mov.w	r0, #4294967295
}
 800e1a4:	bd10      	pop	{r4, pc}
 800e1a6:	bf00      	nop

0800e1a8 <LPS22HB_DeInit>:
{
 800e1a8:	b570      	push	{r4, r5, r6, lr}
  if (pObj->is_initialized == 1U)
 800e1aa:	f890 3028 	ldrb.w	r3, [r0, #40]	; 0x28
 800e1ae:	2b01      	cmp	r3, #1
{
 800e1b0:	4604      	mov	r4, r0
  if (pObj->is_initialized == 1U)
 800e1b2:	d003      	beq.n	800e1bc <LPS22HB_DeInit+0x14>
  pObj->is_initialized = 0;
 800e1b4:	2000      	movs	r0, #0
 800e1b6:	f884 0028 	strb.w	r0, [r4, #40]	; 0x28
}
 800e1ba:	bd70      	pop	{r4, r5, r6, pc}
  if (pObj->press_is_enabled == 0U)
 800e1bc:	f890 3029 	ldrb.w	r3, [r0, #41]	; 0x29
  if (pObj->temp_is_enabled == 0U)
 800e1c0:	f890 502a 	ldrb.w	r5, [r0, #42]	; 0x2a
  if (pObj->press_is_enabled == 0U)
 800e1c4:	b11b      	cbz	r3, 800e1ce <LPS22HB_DeInit+0x26>
  if (pObj->temp_is_enabled == 0U)
 800e1c6:	b1a5      	cbz	r5, 800e1f2 <LPS22HB_DeInit+0x4a>
  pObj->press_is_enabled = 0;
 800e1c8:	2300      	movs	r3, #0
 800e1ca:	f884 3029 	strb.w	r3, [r4, #41]	; 0x29
  if (pObj->temp_is_enabled == 0U)
 800e1ce:	2d00      	cmp	r5, #0
 800e1d0:	d0f0      	beq.n	800e1b4 <LPS22HB_DeInit+0xc>
    if (lps22hb_data_rate_get(&(pObj->Ctx), &pObj->last_odr) != LPS22HB_OK)
 800e1d2:	f104 051c 	add.w	r5, r4, #28
 800e1d6:	f104 012b 	add.w	r1, r4, #43	; 0x2b
 800e1da:	4628      	mov	r0, r5
 800e1dc:	f000 f948 	bl	800e470 <lps22hb_data_rate_get>
 800e1e0:	4601      	mov	r1, r0
 800e1e2:	b9b0      	cbnz	r0, 800e212 <LPS22HB_DeInit+0x6a>
    if (lps22hb_data_rate_set(&(pObj->Ctx), LPS22HB_POWER_DOWN) != LPS22HB_OK)
 800e1e4:	4628      	mov	r0, r5
 800e1e6:	f000 f929 	bl	800e43c <lps22hb_data_rate_set>
 800e1ea:	b990      	cbnz	r0, 800e212 <LPS22HB_DeInit+0x6a>
  pObj->temp_is_enabled = 0;
 800e1ec:	f884 002a 	strb.w	r0, [r4, #42]	; 0x2a
  return LPS22HB_OK;
 800e1f0:	e7e0      	b.n	800e1b4 <LPS22HB_DeInit+0xc>
    if (lps22hb_data_rate_get(&(pObj->Ctx), &pObj->last_odr) != LPS22HB_OK)
 800e1f2:	f100 061c 	add.w	r6, r0, #28
 800e1f6:	f100 012b 	add.w	r1, r0, #43	; 0x2b
 800e1fa:	4630      	mov	r0, r6
 800e1fc:	f000 f938 	bl	800e470 <lps22hb_data_rate_get>
 800e200:	b938      	cbnz	r0, 800e212 <LPS22HB_DeInit+0x6a>
    if (lps22hb_data_rate_set(&(pObj->Ctx), LPS22HB_POWER_DOWN) != LPS22HB_OK)
 800e202:	4629      	mov	r1, r5
 800e204:	4630      	mov	r0, r6
 800e206:	f000 f919 	bl	800e43c <lps22hb_data_rate_set>
 800e20a:	b910      	cbnz	r0, 800e212 <LPS22HB_DeInit+0x6a>
  if (pObj->temp_is_enabled == 0U)
 800e20c:	f894 502a 	ldrb.w	r5, [r4, #42]	; 0x2a
 800e210:	e7da      	b.n	800e1c8 <LPS22HB_DeInit+0x20>
      return LPS22HB_ERROR;
 800e212:	f04f 30ff 	mov.w	r0, #4294967295
}
 800e216:	bd70      	pop	{r4, r5, r6, pc}

0800e218 <LPS22HB_TEMP_GetOutputDataRate>:
 800e218:	b510      	push	{r4, lr}
 800e21a:	b082      	sub	sp, #8
 800e21c:	460c      	mov	r4, r1
 800e21e:	301c      	adds	r0, #28
 800e220:	f10d 0107 	add.w	r1, sp, #7
 800e224:	f000 f924 	bl	800e470 <lps22hb_data_rate_get>
 800e228:	bb08      	cbnz	r0, 800e26e <LPS22HB_TEMP_GetOutputDataRate+0x56>
 800e22a:	f89d 3007 	ldrb.w	r3, [sp, #7]
 800e22e:	2b05      	cmp	r3, #5
 800e230:	d81d      	bhi.n	800e26e <LPS22HB_TEMP_GetOutputDataRate+0x56>
 800e232:	e8df f003 	tbb	[pc, r3]
 800e236:	0b07      	.short	0x0b07
 800e238:	03181410 	.word	0x03181410
 800e23c:	4b0d      	ldr	r3, [pc, #52]	; (800e274 <LPS22HB_TEMP_GetOutputDataRate+0x5c>)
 800e23e:	6023      	str	r3, [r4, #0]
 800e240:	b002      	add	sp, #8
 800e242:	bd10      	pop	{r4, pc}
 800e244:	2300      	movs	r3, #0
 800e246:	6023      	str	r3, [r4, #0]
 800e248:	b002      	add	sp, #8
 800e24a:	bd10      	pop	{r4, pc}
 800e24c:	f04f 537e 	mov.w	r3, #1065353216	; 0x3f800000
 800e250:	6023      	str	r3, [r4, #0]
 800e252:	b002      	add	sp, #8
 800e254:	bd10      	pop	{r4, pc}
 800e256:	4b08      	ldr	r3, [pc, #32]	; (800e278 <LPS22HB_TEMP_GetOutputDataRate+0x60>)
 800e258:	6023      	str	r3, [r4, #0]
 800e25a:	b002      	add	sp, #8
 800e25c:	bd10      	pop	{r4, pc}
 800e25e:	4b07      	ldr	r3, [pc, #28]	; (800e27c <LPS22HB_TEMP_GetOutputDataRate+0x64>)
 800e260:	6023      	str	r3, [r4, #0]
 800e262:	b002      	add	sp, #8
 800e264:	bd10      	pop	{r4, pc}
 800e266:	4b06      	ldr	r3, [pc, #24]	; (800e280 <LPS22HB_TEMP_GetOutputDataRate+0x68>)
 800e268:	6023      	str	r3, [r4, #0]
 800e26a:	b002      	add	sp, #8
 800e26c:	bd10      	pop	{r4, pc}
 800e26e:	f04f 30ff 	mov.w	r0, #4294967295
 800e272:	e7e5      	b.n	800e240 <LPS22HB_TEMP_GetOutputDataRate+0x28>
 800e274:	42960000 	.word	0x42960000
 800e278:	41200000 	.word	0x41200000
 800e27c:	41c80000 	.word	0x41c80000
 800e280:	42480000 	.word	0x42480000

0800e284 <LPS22HB_PRESS_Disable>:
{
 800e284:	b538      	push	{r3, r4, r5, lr}
 800e286:	4604      	mov	r4, r0
  if (pObj->press_is_enabled == 0U)
 800e288:	f890 0029 	ldrb.w	r0, [r0, #41]	; 0x29
 800e28c:	b130      	cbz	r0, 800e29c <LPS22HB_PRESS_Disable+0x18>
  if (pObj->temp_is_enabled == 0U)
 800e28e:	f894 302a 	ldrb.w	r3, [r4, #42]	; 0x2a
 800e292:	b123      	cbz	r3, 800e29e <LPS22HB_PRESS_Disable+0x1a>
  pObj->press_is_enabled = 0;
 800e294:	2300      	movs	r3, #0
 800e296:	f884 3029 	strb.w	r3, [r4, #41]	; 0x29
  return LPS22HB_OK;
 800e29a:	4618      	mov	r0, r3
}
 800e29c:	bd38      	pop	{r3, r4, r5, pc}
    if (lps22hb_data_rate_get(&(pObj->Ctx), &pObj->last_odr) != LPS22HB_OK)
 800e29e:	f104 051c 	add.w	r5, r4, #28
 800e2a2:	f104 012b 	add.w	r1, r4, #43	; 0x2b
 800e2a6:	4628      	mov	r0, r5
 800e2a8:	f000 f8e2 	bl	800e470 <lps22hb_data_rate_get>
 800e2ac:	4601      	mov	r1, r0
 800e2ae:	b920      	cbnz	r0, 800e2ba <LPS22HB_PRESS_Disable+0x36>
    if (lps22hb_data_rate_set(&(pObj->Ctx), LPS22HB_POWER_DOWN) != LPS22HB_OK)
 800e2b0:	4628      	mov	r0, r5
 800e2b2:	f000 f8c3 	bl	800e43c <lps22hb_data_rate_set>
 800e2b6:	2800      	cmp	r0, #0
 800e2b8:	d0ec      	beq.n	800e294 <LPS22HB_PRESS_Disable+0x10>
      return LPS22HB_ERROR;
 800e2ba:	f04f 30ff 	mov.w	r0, #4294967295
}
 800e2be:	bd38      	pop	{r3, r4, r5, pc}

0800e2c0 <LPS22HB_TEMP_Disable>:
{
 800e2c0:	b538      	push	{r3, r4, r5, lr}
 800e2c2:	4604      	mov	r4, r0
  if (pObj->temp_is_enabled == 0U)
 800e2c4:	f890 002a 	ldrb.w	r0, [r0, #42]	; 0x2a
 800e2c8:	b130      	cbz	r0, 800e2d8 <LPS22HB_TEMP_Disable+0x18>
  if (pObj->press_is_enabled == 0U)
 800e2ca:	f894 3029 	ldrb.w	r3, [r4, #41]	; 0x29
 800e2ce:	b123      	cbz	r3, 800e2da <LPS22HB_TEMP_Disable+0x1a>
  pObj->temp_is_enabled = 0;
 800e2d0:	2300      	movs	r3, #0
 800e2d2:	f884 302a 	strb.w	r3, [r4, #42]	; 0x2a
  return LPS22HB_OK;
 800e2d6:	4618      	mov	r0, r3
}
 800e2d8:	bd38      	pop	{r3, r4, r5, pc}
    if (lps22hb_data_rate_get(&(pObj->Ctx), &pObj->last_odr) != LPS22HB_OK)
 800e2da:	f104 051c 	add.w	r5, r4, #28
 800e2de:	f104 012b 	add.w	r1, r4, #43	; 0x2b
 800e2e2:	4628      	mov	r0, r5
 800e2e4:	f000 f8c4 	bl	800e470 <lps22hb_data_rate_get>
 800e2e8:	4601      	mov	r1, r0
 800e2ea:	b920      	cbnz	r0, 800e2f6 <LPS22HB_TEMP_Disable+0x36>
    if (lps22hb_data_rate_set(&(pObj->Ctx), LPS22HB_POWER_DOWN) != LPS22HB_OK)
 800e2ec:	4628      	mov	r0, r5
 800e2ee:	f000 f8a5 	bl	800e43c <lps22hb_data_rate_set>
 800e2f2:	2800      	cmp	r0, #0
 800e2f4:	d0ec      	beq.n	800e2d0 <LPS22HB_TEMP_Disable+0x10>
      return LPS22HB_ERROR;
 800e2f6:	f04f 30ff 	mov.w	r0, #4294967295
}
 800e2fa:	bd38      	pop	{r3, r4, r5, pc}

0800e2fc <LPS22HB_RegisterBusIO>:
  if (pObj == NULL)
 800e2fc:	2800      	cmp	r0, #0
 800e2fe:	d034      	beq.n	800e36a <LPS22HB_RegisterBusIO+0x6e>
{
 800e300:	b530      	push	{r4, r5, lr}
 800e302:	4604      	mov	r4, r0
    pObj->IO.DeInit    = pIO->DeInit;
 800e304:	e9d1 3000 	ldrd	r3, r0, [r1]
    pObj->IO.BusType   = pIO->BusType;
 800e308:	688a      	ldr	r2, [r1, #8]
 800e30a:	60a2      	str	r2, [r4, #8]
    pObj->IO.DeInit    = pIO->DeInit;
 800e30c:	e9c4 3000 	strd	r3, r0, [r4]
    pObj->IO.Address   = pIO->Address;
 800e310:	7b0a      	ldrb	r2, [r1, #12]
 800e312:	7322      	strb	r2, [r4, #12]
    pObj->IO.ReadReg   = pIO->ReadReg;
 800e314:	e9d1 5204 	ldrd	r5, r2, [r1, #16]
    pObj->IO.GetTick   = pIO->GetTick;
 800e318:	6988      	ldr	r0, [r1, #24]
    pObj->Ctx.read_reg  = ReadRegWrap;
 800e31a:	4915      	ldr	r1, [pc, #84]	; (800e370 <LPS22HB_RegisterBusIO+0x74>)
    pObj->IO.GetTick   = pIO->GetTick;
 800e31c:	61a0      	str	r0, [r4, #24]
    pObj->IO.ReadReg   = pIO->ReadReg;
 800e31e:	e9c4 5204 	strd	r5, r2, [r4, #16]
    pObj->Ctx.write_reg = WriteRegWrap;
 800e322:	4a14      	ldr	r2, [pc, #80]	; (800e374 <LPS22HB_RegisterBusIO+0x78>)
    pObj->Ctx.handle   = pObj;
 800e324:	6264      	str	r4, [r4, #36]	; 0x24
    pObj->Ctx.write_reg = WriteRegWrap;
 800e326:	e9c4 2107 	strd	r2, r1, [r4, #28]
{
 800e32a:	b083      	sub	sp, #12
    if (pObj->IO.Init == NULL)
 800e32c:	b1d3      	cbz	r3, 800e364 <LPS22HB_RegisterBusIO+0x68>
    else if (pObj->IO.Init() != LPS22HB_OK)
 800e32e:	4798      	blx	r3
 800e330:	b9c0      	cbnz	r0, 800e364 <LPS22HB_RegisterBusIO+0x68>
      if (pObj->IO.BusType == LPS22HB_SPI_3WIRES_BUS) /* SPI 3-Wires */
 800e332:	68a3      	ldr	r3, [r4, #8]
 800e334:	2b02      	cmp	r3, #2
 800e336:	d001      	beq.n	800e33c <LPS22HB_RegisterBusIO+0x40>
}
 800e338:	b003      	add	sp, #12
 800e33a:	bd30      	pop	{r4, r5, pc}
        if (pObj->is_initialized == 0U)
 800e33c:	f894 3028 	ldrb.w	r3, [r4, #40]	; 0x28
 800e340:	2b00      	cmp	r3, #0
 800e342:	d1f9      	bne.n	800e338 <LPS22HB_RegisterBusIO+0x3c>
          if (LPS22HB_Write_Reg(pObj, LPS22HB_CTRL_REG1, data) != LPS22HB_OK)
 800e344:	2301      	movs	r3, #1
  if (lps22hb_write_reg(&(pObj->Ctx), Reg, &Data, 1) != LPS22HB_OK)
 800e346:	f10d 0207 	add.w	r2, sp, #7
 800e34a:	2110      	movs	r1, #16
 800e34c:	f104 001c 	add.w	r0, r4, #28
 800e350:	f88d 3007 	strb.w	r3, [sp, #7]
 800e354:	f000 f824 	bl	800e3a0 <lps22hb_write_reg>
            ret = LPS22HB_ERROR;
 800e358:	2800      	cmp	r0, #0
 800e35a:	bf18      	it	ne
 800e35c:	f04f 30ff 	movne.w	r0, #4294967295
}
 800e360:	b003      	add	sp, #12
 800e362:	bd30      	pop	{r4, r5, pc}
    ret = LPS22HB_ERROR;
 800e364:	f04f 30ff 	mov.w	r0, #4294967295
 800e368:	e7e6      	b.n	800e338 <LPS22HB_RegisterBusIO+0x3c>
 800e36a:	f04f 30ff 	mov.w	r0, #4294967295
}
 800e36e:	4770      	bx	lr
 800e370:	0800e0b9 	.word	0x0800e0b9
 800e374:	0800e105 	.word	0x0800e105

0800e378 <LPS22HB_Set_One_Shot>:
{
 800e378:	b510      	push	{r4, lr}
  if(lps22hb_data_rate_set(&(pObj->Ctx), LPS22HB_POWER_DOWN) != LPS22HB_OK)
 800e37a:	f100 041c 	add.w	r4, r0, #28
 800e37e:	2100      	movs	r1, #0
 800e380:	4620      	mov	r0, r4
 800e382:	f000 f85b 	bl	800e43c <lps22hb_data_rate_set>
 800e386:	b940      	cbnz	r0, 800e39a <LPS22HB_Set_One_Shot+0x22>
  if(lps22hb_one_shoot_trigger_set(&(pObj->Ctx), 1) != LPS22HB_OK)
 800e388:	2101      	movs	r1, #1
 800e38a:	4620      	mov	r0, r4
 800e38c:	f000 f89c 	bl	800e4c8 <lps22hb_one_shoot_trigger_set>
 800e390:	3800      	subs	r0, #0
 800e392:	bf18      	it	ne
 800e394:	2001      	movne	r0, #1
 800e396:	4240      	negs	r0, r0
}
 800e398:	bd10      	pop	{r4, pc}
    return LPS22HB_ERROR;
 800e39a:	f04f 30ff 	mov.w	r0, #4294967295
}
 800e39e:	bd10      	pop	{r4, pc}

0800e3a0 <lps22hb_write_reg>:
  * @retval       interface status (MANDATORY: return 0 -> no Error)
  *
  */
int32_t lps22hb_write_reg(lps22hb_ctx_t* ctx, uint8_t reg, uint8_t* data,
                          uint16_t len)
{
 800e3a0:	b410      	push	{r4}
  int32_t ret;
  ret = ctx->write_reg(ctx->handle, reg, data, len);
 800e3a2:	6804      	ldr	r4, [r0, #0]
 800e3a4:	6880      	ldr	r0, [r0, #8]
 800e3a6:	46a4      	mov	ip, r4
  return ret;
}
 800e3a8:	f85d 4b04 	ldr.w	r4, [sp], #4
  ret = ctx->write_reg(ctx->handle, reg, data, len);
 800e3ac:	4760      	bx	ip
 800e3ae:	bf00      	nop

0800e3b0 <lps22hb_from_lsb_to_hpa>:
  * @{
  *
  */

float_t lps22hb_from_lsb_to_hpa(int32_t lsb)
{
 800e3b0:	ee00 0a10 	vmov	s0, r0
  return ( (float_t)lsb / 4096.0f );
}
 800e3b4:	eeba 0aca 	vcvt.f32.s32	s0, s0, #12
 800e3b8:	4770      	bx	lr
 800e3ba:	bf00      	nop

0800e3bc <lps22hb_from_lsb_to_degc>:

float_t lps22hb_from_lsb_to_degc(int16_t lsb)
{
  return ( (float_t)lsb / 100.0f );
 800e3bc:	ee07 0a90 	vmov	s15, r0
 800e3c0:	ed9f 0a03 	vldr	s0, [pc, #12]	; 800e3d0 <lps22hb_from_lsb_to_degc+0x14>
 800e3c4:	eef8 7ae7 	vcvt.f32.s32	s15, s15
}
 800e3c8:	ee87 0a80 	vdiv.f32	s0, s15, s0
 800e3cc:	4770      	bx	lr
 800e3ce:	bf00      	nop
 800e3d0:	42c80000 	.word	0x42c80000

0800e3d4 <lps22hb_block_data_update_set>:
  * @param  val    Change the values of bdu in reg CTRL_REG1
  * @retval        Interface status (MANDATORY: return 0 -> no Error).
  *
  */
int32_t lps22hb_block_data_update_set(lps22hb_ctx_t *ctx, uint8_t val)
{
 800e3d4:	b570      	push	{r4, r5, r6, lr}
 800e3d6:	4604      	mov	r4, r0
 800e3d8:	b082      	sub	sp, #8
 800e3da:	460d      	mov	r5, r1
  ret = ctx->read_reg(ctx->handle, reg, data, len);
 800e3dc:	6880      	ldr	r0, [r0, #8]
 800e3de:	6866      	ldr	r6, [r4, #4]
 800e3e0:	2301      	movs	r3, #1
 800e3e2:	aa01      	add	r2, sp, #4
 800e3e4:	2110      	movs	r1, #16
 800e3e6:	47b0      	blx	r6
  lps22hb_ctrl_reg1_t ctrl_reg1;
  int32_t ret;

  ret = lps22hb_read_reg(ctx, LPS22HB_CTRL_REG1, (uint8_t*)&ctrl_reg1, 1);
  if(ret == 0){
 800e3e8:	b958      	cbnz	r0, 800e402 <lps22hb_block_data_update_set+0x2e>
    ctrl_reg1.bdu = val;
 800e3ea:	f89d 3004 	ldrb.w	r3, [sp, #4]
  ret = ctx->write_reg(ctx->handle, reg, data, len);
 800e3ee:	6826      	ldr	r6, [r4, #0]
 800e3f0:	68a0      	ldr	r0, [r4, #8]
    ctrl_reg1.bdu = val;
 800e3f2:	f365 0341 	bfi	r3, r5, #1, #1
 800e3f6:	f88d 3004 	strb.w	r3, [sp, #4]
  ret = ctx->write_reg(ctx->handle, reg, data, len);
 800e3fa:	aa01      	add	r2, sp, #4
 800e3fc:	2301      	movs	r3, #1
 800e3fe:	2110      	movs	r1, #16
 800e400:	47b0      	blx	r6
    ret = lps22hb_write_reg(ctx, LPS22HB_CTRL_REG1, (uint8_t*)&ctrl_reg1, 1);
  }
  return ret;
}
 800e402:	b002      	add	sp, #8
 800e404:	bd70      	pop	{r4, r5, r6, pc}
 800e406:	bf00      	nop

0800e408 <lps22hb_low_pass_filter_mode_set>:
  * @retval        Interface status (MANDATORY: return 0 -> no Error).
  *
  */
int32_t lps22hb_low_pass_filter_mode_set(lps22hb_ctx_t *ctx,
                                          lps22hb_lpfp_t val)
{
 800e408:	b570      	push	{r4, r5, r6, lr}
 800e40a:	4604      	mov	r4, r0
 800e40c:	b082      	sub	sp, #8
 800e40e:	460d      	mov	r5, r1
  ret = ctx->read_reg(ctx->handle, reg, data, len);
 800e410:	6880      	ldr	r0, [r0, #8]
 800e412:	6866      	ldr	r6, [r4, #4]
 800e414:	2301      	movs	r3, #1
 800e416:	aa01      	add	r2, sp, #4
 800e418:	2110      	movs	r1, #16
 800e41a:	47b0      	blx	r6
  lps22hb_ctrl_reg1_t ctrl_reg1;
  int32_t ret;

  ret = lps22hb_read_reg(ctx, LPS22HB_CTRL_REG1, (uint8_t*)&ctrl_reg1, 1);
  if(ret == 0){
 800e41c:	b958      	cbnz	r0, 800e436 <lps22hb_low_pass_filter_mode_set+0x2e>
    ctrl_reg1.lpfp = (uint8_t)val;
 800e41e:	f89d 3004 	ldrb.w	r3, [sp, #4]
  ret = ctx->write_reg(ctx->handle, reg, data, len);
 800e422:	6826      	ldr	r6, [r4, #0]
 800e424:	68a0      	ldr	r0, [r4, #8]
    ctrl_reg1.lpfp = (uint8_t)val;
 800e426:	f365 0383 	bfi	r3, r5, #2, #2
 800e42a:	f88d 3004 	strb.w	r3, [sp, #4]
  ret = ctx->write_reg(ctx->handle, reg, data, len);
 800e42e:	aa01      	add	r2, sp, #4
 800e430:	2301      	movs	r3, #1
 800e432:	2110      	movs	r1, #16
 800e434:	47b0      	blx	r6
    ret = lps22hb_write_reg(ctx, LPS22HB_CTRL_REG1, (uint8_t*)&ctrl_reg1, 1);
  }
  return ret;
}
 800e436:	b002      	add	sp, #8
 800e438:	bd70      	pop	{r4, r5, r6, pc}
 800e43a:	bf00      	nop

0800e43c <lps22hb_data_rate_set>:
  * @param  val    Change the values of odr in reg CTRL_REG1
  * @retval        Interface status (MANDATORY: return 0 -> no Error).
  *
  */
int32_t lps22hb_data_rate_set(lps22hb_ctx_t *ctx, lps22hb_odr_t val)
{
 800e43c:	b570      	push	{r4, r5, r6, lr}
 800e43e:	4604      	mov	r4, r0
 800e440:	b082      	sub	sp, #8
 800e442:	460d      	mov	r5, r1
  ret = ctx->read_reg(ctx->handle, reg, data, len);
 800e444:	6880      	ldr	r0, [r0, #8]
 800e446:	6866      	ldr	r6, [r4, #4]
 800e448:	2301      	movs	r3, #1
 800e44a:	aa01      	add	r2, sp, #4
 800e44c:	2110      	movs	r1, #16
 800e44e:	47b0      	blx	r6
  lps22hb_ctrl_reg1_t ctrl_reg1;
  int32_t ret;

  ret = lps22hb_read_reg(ctx, LPS22HB_CTRL_REG1, (uint8_t*)&ctrl_reg1, 1);
  if(ret == 0){
 800e450:	b958      	cbnz	r0, 800e46a <lps22hb_data_rate_set+0x2e>
    ctrl_reg1.odr = (uint8_t)val;
 800e452:	f89d 3004 	ldrb.w	r3, [sp, #4]
  ret = ctx->write_reg(ctx->handle, reg, data, len);
 800e456:	6826      	ldr	r6, [r4, #0]
 800e458:	68a0      	ldr	r0, [r4, #8]
    ctrl_reg1.odr = (uint8_t)val;
 800e45a:	f365 1306 	bfi	r3, r5, #4, #3
 800e45e:	f88d 3004 	strb.w	r3, [sp, #4]
  ret = ctx->write_reg(ctx->handle, reg, data, len);
 800e462:	aa01      	add	r2, sp, #4
 800e464:	2301      	movs	r3, #1
 800e466:	2110      	movs	r1, #16
 800e468:	47b0      	blx	r6
    ret = lps22hb_write_reg(ctx, LPS22HB_CTRL_REG1, (uint8_t*)&ctrl_reg1, 1);
  }
  return ret;
}
 800e46a:	b002      	add	sp, #8
 800e46c:	bd70      	pop	{r4, r5, r6, pc}
 800e46e:	bf00      	nop

0800e470 <lps22hb_data_rate_get>:
  * @param  val    Get the values of odr in reg CTRL_REG1
  * @retval        Interface status (MANDATORY: return 0 -> no Error).
  *
  */
int32_t lps22hb_data_rate_get(lps22hb_ctx_t *ctx, lps22hb_odr_t *val)
{
 800e470:	b530      	push	{r4, r5, lr}
 800e472:	b083      	sub	sp, #12
  ret = ctx->read_reg(ctx->handle, reg, data, len);
 800e474:	2301      	movs	r3, #1
 800e476:	e9d0 4001 	ldrd	r4, r0, [r0, #4]
 800e47a:	aa01      	add	r2, sp, #4
{
 800e47c:	460d      	mov	r5, r1
  ret = ctx->read_reg(ctx->handle, reg, data, len);
 800e47e:	2110      	movs	r1, #16
 800e480:	47a0      	blx	r4
  lps22hb_ctrl_reg1_t ctrl_reg1;
  int32_t ret;

  ret = lps22hb_read_reg(ctx, LPS22HB_CTRL_REG1, (uint8_t*)&ctrl_reg1, 1);
  switch (ctrl_reg1.odr){
 800e482:	f89d 3004 	ldrb.w	r3, [sp, #4]
 800e486:	f3c3 1302 	ubfx	r3, r3, #4, #3
 800e48a:	2b05      	cmp	r3, #5
 800e48c:	d804      	bhi.n	800e498 <lps22hb_data_rate_get+0x28>
 800e48e:	e8df f003 	tbb	[pc, r3]
 800e492:	030b      	.short	0x030b
 800e494:	0717130f 	.word	0x0717130f
    case LPS22HB_POWER_DOWN:
      *val = LPS22HB_POWER_DOWN;
      break;
    case LPS22HB_ODR_1_Hz:
      *val = LPS22HB_ODR_1_Hz;
 800e498:	2301      	movs	r3, #1
 800e49a:	702b      	strb	r3, [r5, #0]
      *val = LPS22HB_ODR_1_Hz;
      break;
  }

  return ret;
}
 800e49c:	b003      	add	sp, #12
 800e49e:	bd30      	pop	{r4, r5, pc}
      *val = LPS22HB_ODR_75_Hz;
 800e4a0:	2305      	movs	r3, #5
 800e4a2:	702b      	strb	r3, [r5, #0]
}
 800e4a4:	b003      	add	sp, #12
 800e4a6:	bd30      	pop	{r4, r5, pc}
      *val = LPS22HB_POWER_DOWN;
 800e4a8:	2300      	movs	r3, #0
 800e4aa:	702b      	strb	r3, [r5, #0]
}
 800e4ac:	b003      	add	sp, #12
 800e4ae:	bd30      	pop	{r4, r5, pc}
      *val = LPS22HB_ODR_10_Hz;
 800e4b0:	2302      	movs	r3, #2
 800e4b2:	702b      	strb	r3, [r5, #0]
}
 800e4b4:	b003      	add	sp, #12
 800e4b6:	bd30      	pop	{r4, r5, pc}
      *val = LPS22HB_ODR_25_Hz;
 800e4b8:	2303      	movs	r3, #3
 800e4ba:	702b      	strb	r3, [r5, #0]
}
 800e4bc:	b003      	add	sp, #12
 800e4be:	bd30      	pop	{r4, r5, pc}
      *val = LPS22HB_ODR_50_Hz;
 800e4c0:	2304      	movs	r3, #4
 800e4c2:	702b      	strb	r3, [r5, #0]
}
 800e4c4:	b003      	add	sp, #12
 800e4c6:	bd30      	pop	{r4, r5, pc}

0800e4c8 <lps22hb_one_shoot_trigger_set>:
  * @param  val    Change the values of one_shot in reg CTRL_REG2
  * @retval        Interface status (MANDATORY: return 0 -> no Error).
  *
  */
int32_t lps22hb_one_shoot_trigger_set(lps22hb_ctx_t *ctx, uint8_t val)
{
 800e4c8:	b570      	push	{r4, r5, r6, lr}
 800e4ca:	4604      	mov	r4, r0
 800e4cc:	b082      	sub	sp, #8
 800e4ce:	460d      	mov	r5, r1
  ret = ctx->read_reg(ctx->handle, reg, data, len);
 800e4d0:	6880      	ldr	r0, [r0, #8]
 800e4d2:	6866      	ldr	r6, [r4, #4]
 800e4d4:	2301      	movs	r3, #1
 800e4d6:	aa01      	add	r2, sp, #4
 800e4d8:	2111      	movs	r1, #17
 800e4da:	47b0      	blx	r6
  lps22hb_ctrl_reg2_t ctrl_reg2;
  int32_t ret;

  ret = lps22hb_read_reg(ctx, LPS22HB_CTRL_REG2, (uint8_t*)&ctrl_reg2, 1);
  if(ret == 0){
 800e4dc:	b958      	cbnz	r0, 800e4f6 <lps22hb_one_shoot_trigger_set+0x2e>
    ctrl_reg2.one_shot = val;
 800e4de:	f89d 3004 	ldrb.w	r3, [sp, #4]
  ret = ctx->write_reg(ctx->handle, reg, data, len);
 800e4e2:	6826      	ldr	r6, [r4, #0]
 800e4e4:	68a0      	ldr	r0, [r4, #8]
    ctrl_reg2.one_shot = val;
 800e4e6:	f365 0300 	bfi	r3, r5, #0, #1
 800e4ea:	f88d 3004 	strb.w	r3, [sp, #4]
  ret = ctx->write_reg(ctx->handle, reg, data, len);
 800e4ee:	aa01      	add	r2, sp, #4
 800e4f0:	2301      	movs	r3, #1
 800e4f2:	2111      	movs	r1, #17
 800e4f4:	47b0      	blx	r6
    ret = lps22hb_write_reg(ctx, LPS22HB_CTRL_REG2, (uint8_t*)&ctrl_reg2, 1);
  }
  return ret;
}
 800e4f6:	b002      	add	sp, #8
 800e4f8:	bd70      	pop	{r4, r5, r6, pc}
 800e4fa:	bf00      	nop

0800e4fc <lps22hb_pressure_raw_get>:
  * @param  buff   Buffer that stores data read
  * @retval        Interface status (MANDATORY: return 0 -> no Error).
  *
  */
int32_t lps22hb_pressure_raw_get(lps22hb_ctx_t *ctx, uint8_t *buff)
{
 800e4fc:	b410      	push	{r4}
  ret = ctx->read_reg(ctx->handle, reg, data, len);
 800e4fe:	e9d0 4001 	ldrd	r4, r0, [r0, #4]
{
 800e502:	460a      	mov	r2, r1
  ret = ctx->read_reg(ctx->handle, reg, data, len);
 800e504:	46a4      	mov	ip, r4
 800e506:	2303      	movs	r3, #3
  int32_t ret;
  ret =  lps22hb_read_reg(ctx, LPS22HB_PRESS_OUT_XL, buff, 3);
  return ret;
}
 800e508:	f85d 4b04 	ldr.w	r4, [sp], #4
  ret = ctx->read_reg(ctx->handle, reg, data, len);
 800e50c:	2128      	movs	r1, #40	; 0x28
 800e50e:	4760      	bx	ip

0800e510 <lps22hb_temperature_raw_get>:
  * @param  buff   Buffer that stores data read.
  * @retval        Interface status (MANDATORY: return 0 -> no Error).
  *
  */
int32_t lps22hb_temperature_raw_get(lps22hb_ctx_t *ctx, uint8_t *buff)
{
 800e510:	b410      	push	{r4}
  ret = ctx->read_reg(ctx->handle, reg, data, len);
 800e512:	e9d0 4001 	ldrd	r4, r0, [r0, #4]
{
 800e516:	460a      	mov	r2, r1
  ret = ctx->read_reg(ctx->handle, reg, data, len);
 800e518:	46a4      	mov	ip, r4
 800e51a:	2302      	movs	r3, #2
  int32_t ret;
  ret =  lps22hb_read_reg(ctx, LPS22HB_TEMP_OUT_L, (uint8_t*) buff, 2);
  return ret;
}
 800e51c:	f85d 4b04 	ldr.w	r4, [sp], #4
  ret = ctx->read_reg(ctx->handle, reg, data, len);
 800e520:	212b      	movs	r1, #43	; 0x2b
 800e522:	4760      	bx	ip

0800e524 <lps22hb_device_id_get>:
  * @param  buff   Buffer that stores data read
  * @retval        Interface status (MANDATORY: return 0 -> no Error).
  *
  */
int32_t lps22hb_device_id_get(lps22hb_ctx_t *ctx, uint8_t *buff)
{
 800e524:	b410      	push	{r4}
  ret = ctx->read_reg(ctx->handle, reg, data, len);
 800e526:	e9d0 4001 	ldrd	r4, r0, [r0, #4]
{
 800e52a:	460a      	mov	r2, r1
  ret = ctx->read_reg(ctx->handle, reg, data, len);
 800e52c:	46a4      	mov	ip, r4
 800e52e:	2301      	movs	r3, #1
  int32_t ret;
  ret =  lps22hb_read_reg(ctx, LPS22HB_WHO_AM_I, (uint8_t*) buff, 1);
  return ret;
}
 800e530:	f85d 4b04 	ldr.w	r4, [sp], #4
  ret = ctx->read_reg(ctx->handle, reg, data, len);
 800e534:	210f      	movs	r1, #15
 800e536:	4760      	bx	ip

0800e538 <lps22hb_low_power_set>:
  * @param  val    Change the values of lc_en in reg RES_CONF
  * @retval        Interface status (MANDATORY: return 0 -> no Error).
  *
  */
int32_t lps22hb_low_power_set(lps22hb_ctx_t *ctx, uint8_t val)
{
 800e538:	b570      	push	{r4, r5, r6, lr}
 800e53a:	4604      	mov	r4, r0
 800e53c:	b082      	sub	sp, #8
 800e53e:	460d      	mov	r5, r1
  ret = ctx->read_reg(ctx->handle, reg, data, len);
 800e540:	6880      	ldr	r0, [r0, #8]
 800e542:	6866      	ldr	r6, [r4, #4]
 800e544:	2301      	movs	r3, #1
 800e546:	aa01      	add	r2, sp, #4
 800e548:	211a      	movs	r1, #26
 800e54a:	47b0      	blx	r6
  lps22hb_res_conf_t res_conf;
  int32_t ret;

  ret = lps22hb_read_reg(ctx, LPS22HB_RES_CONF, (uint8_t*)&res_conf, 1);
  if(ret == 0){
 800e54c:	b958      	cbnz	r0, 800e566 <lps22hb_low_power_set+0x2e>
    res_conf.lc_en = val;
 800e54e:	f89d 3004 	ldrb.w	r3, [sp, #4]
  ret = ctx->write_reg(ctx->handle, reg, data, len);
 800e552:	6826      	ldr	r6, [r4, #0]
 800e554:	68a0      	ldr	r0, [r4, #8]
    res_conf.lc_en = val;
 800e556:	f365 0300 	bfi	r3, r5, #0, #1
 800e55a:	f88d 3004 	strb.w	r3, [sp, #4]
  ret = ctx->write_reg(ctx->handle, reg, data, len);
 800e55e:	aa01      	add	r2, sp, #4
 800e560:	2301      	movs	r3, #1
 800e562:	211a      	movs	r1, #26
 800e564:	47b0      	blx	r6
    ret = lps22hb_write_reg(ctx, LPS22HB_RES_CONF, (uint8_t*)&res_conf, 1);
  }
  return ret;
}
 800e566:	b002      	add	sp, #8
 800e568:	bd70      	pop	{r4, r5, r6, pc}
 800e56a:	bf00      	nop

0800e56c <lps22hb_auto_add_inc_set>:
  * @param  val    Change the values of if_add_inc in reg CTRL_REG2
  * @retval        Interface status (MANDATORY: return 0 -> no Error).
  *
  */
int32_t lps22hb_auto_add_inc_set(lps22hb_ctx_t *ctx, uint8_t val)
{
 800e56c:	b570      	push	{r4, r5, r6, lr}
 800e56e:	4604      	mov	r4, r0
 800e570:	b082      	sub	sp, #8
 800e572:	460d      	mov	r5, r1
  ret = ctx->read_reg(ctx->handle, reg, data, len);
 800e574:	6880      	ldr	r0, [r0, #8]
 800e576:	6866      	ldr	r6, [r4, #4]
 800e578:	2301      	movs	r3, #1
 800e57a:	aa01      	add	r2, sp, #4
 800e57c:	2111      	movs	r1, #17
 800e57e:	47b0      	blx	r6
  lps22hb_ctrl_reg2_t ctrl_reg2;
  int32_t ret;

  ret = lps22hb_read_reg(ctx, LPS22HB_CTRL_REG2, (uint8_t*)&ctrl_reg2, 1);
  if(ret == 0){
 800e580:	b958      	cbnz	r0, 800e59a <lps22hb_auto_add_inc_set+0x2e>
    ctrl_reg2.if_add_inc = val;
 800e582:	f89d 3004 	ldrb.w	r3, [sp, #4]
  ret = ctx->write_reg(ctx->handle, reg, data, len);
 800e586:	6826      	ldr	r6, [r4, #0]
 800e588:	68a0      	ldr	r0, [r4, #8]
    ctrl_reg2.if_add_inc = val;
 800e58a:	f365 1304 	bfi	r3, r5, #4, #1
 800e58e:	f88d 3004 	strb.w	r3, [sp, #4]
  ret = ctx->write_reg(ctx->handle, reg, data, len);
 800e592:	aa01      	add	r2, sp, #4
 800e594:	2301      	movs	r3, #1
 800e596:	2111      	movs	r1, #17
 800e598:	47b0      	blx	r6
    ret = lps22hb_write_reg(ctx, LPS22HB_CTRL_REG2, (uint8_t*)&ctrl_reg2, 1);
  }
  return ret;
}
 800e59a:	b002      	add	sp, #8
 800e59c:	bd70      	pop	{r4, r5, r6, pc}
 800e59e:	bf00      	nop

0800e5a0 <LSM6DSL_GetCapabilities>:
 * @param  pObj Component object pointer
 * @param  Capabilities pointer to LSM6DSL sensor capabilities
 * @retval 0 in case of success, an error code otherwise
 */
int32_t LSM6DSL_GetCapabilities(LSM6DSL_Object_t *pObj, LSM6DSL_Capabilities_t *Capabilities)
{
 800e5a0:	b410      	push	{r4}

  Capabilities->Acc          = 1;
  Capabilities->Gyro         = 1;
  Capabilities->Magneto      = 0;
  Capabilities->LowPower     = 0;
  Capabilities->GyroMaxFS    = 2000;
 800e5a2:	f240 1c01 	movw	ip, #257	; 0x101
 800e5a6:	f44f 64fa 	mov.w	r4, #2000	; 0x7d0
  Capabilities->AccMaxFS     = 16;
  Capabilities->MagMaxFS     = 0;
  Capabilities->GyroMaxOdr   = 6660.0f;
 800e5aa:	4b07      	ldr	r3, [pc, #28]	; (800e5c8 <LSM6DSL_GetCapabilities+0x28>)
 800e5ac:	610b      	str	r3, [r1, #16]
  Capabilities->MagMaxFS     = 0;
 800e5ae:	2000      	movs	r0, #0
  Capabilities->GyroMaxFS    = 2000;
 800e5b0:	e9c1 c400 	strd	ip, r4, [r1]
  Capabilities->AccMaxFS     = 16;
 800e5b4:	2410      	movs	r4, #16
  Capabilities->AccMaxOdr    = 6660.0f;
  Capabilities->MagMaxOdr    = 0.0f;
 800e5b6:	2200      	movs	r2, #0
  Capabilities->MagMaxFS     = 0;
 800e5b8:	e9c1 4002 	strd	r4, r0, [r1, #8]
  Capabilities->AccMaxOdr    = 6660.0f;
 800e5bc:	614b      	str	r3, [r1, #20]
  return LSM6DSL_OK;
}
 800e5be:	f85d 4b04 	ldr.w	r4, [sp], #4
  Capabilities->MagMaxOdr    = 0.0f;
 800e5c2:	618a      	str	r2, [r1, #24]
}
 800e5c4:	4770      	bx	lr
 800e5c6:	bf00      	nop
 800e5c8:	45d02000 	.word	0x45d02000

0800e5cc <ReadRegWrap>:
 * @param  pData the stored data pointer
 * @param  Length the length
 * @retval 0 in case of success, an error code otherwise
 */
static int32_t ReadRegWrap(void *Handle, uint8_t Reg, uint8_t *pData, uint16_t Length)
{
 800e5cc:	b410      	push	{r4}
  LSM6DSL_Object_t *pObj = (LSM6DSL_Object_t *)Handle;

  return pObj->IO.ReadReg(pObj->IO.Address, Reg, pData, Length);
 800e5ce:	6944      	ldr	r4, [r0, #20]
 800e5d0:	7b00      	ldrb	r0, [r0, #12]
 800e5d2:	46a4      	mov	ip, r4
}
 800e5d4:	f85d 4b04 	ldr.w	r4, [sp], #4
  return pObj->IO.ReadReg(pObj->IO.Address, Reg, pData, Length);
 800e5d8:	4760      	bx	ip
 800e5da:	bf00      	nop

0800e5dc <WriteRegWrap>:
 * @param  pData the stored data pointer
 * @param  Length the length
 * @retval 0 in case of success, an error code otherwise
 */
static int32_t WriteRegWrap(void *Handle, uint8_t Reg, uint8_t *pData, uint16_t Length)
{
 800e5dc:	b410      	push	{r4}
  LSM6DSL_Object_t *pObj = (LSM6DSL_Object_t *)Handle;

  return pObj->IO.WriteReg(pObj->IO.Address, Reg, pData, Length);
 800e5de:	6904      	ldr	r4, [r0, #16]
 800e5e0:	7b00      	ldrb	r0, [r0, #12]
 800e5e2:	46a4      	mov	ip, r4
}
 800e5e4:	f85d 4b04 	ldr.w	r4, [sp], #4
  return pObj->IO.WriteReg(pObj->IO.Address, Reg, pData, Length);
 800e5e8:	4760      	bx	ip
 800e5ea:	bf00      	nop

0800e5ec <LSM6DSL_ACC_SetOutputDataRate>:
{
 800e5ec:	b508      	push	{r3, lr}
  if (pObj->acc_is_enabled == 1U)
 800e5ee:	f890 1029 	ldrb.w	r1, [r0, #41]	; 0x29
          : (Odr <=   26.0f) ? LSM6DSL_XL_ODR_26Hz
 800e5f2:	eef2 7a09 	vmov.f32	s15, #41	; 0x41480000  12.5
  if (pObj->acc_is_enabled == 1U)
 800e5f6:	2901      	cmp	r1, #1
          : (Odr <=   26.0f) ? LSM6DSL_XL_ODR_26Hz
 800e5f8:	eeb4 0ae7 	vcmpe.f32	s0, s15
  if (pObj->acc_is_enabled == 1U)
 800e5fc:	d042      	beq.n	800e684 <LSM6DSL_ACC_SetOutputDataRate+0x98>
                : (Odr <=   26.0f) ? LSM6DSL_XL_ODR_26Hz
 800e5fe:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800e602:	d804      	bhi.n	800e60e <LSM6DSL_ACC_SetOutputDataRate+0x22>
 800e604:	2301      	movs	r3, #1
  pObj->acc_odr = (Odr <=   12.5f) ? LSM6DSL_XL_ODR_12Hz5
 800e606:	f880 302b 	strb.w	r3, [r0, #43]	; 0x2b
    return LSM6DSL_ACC_SetOutputDataRate_When_Disabled(pObj, Odr);
 800e60a:	2000      	movs	r0, #0
}
 800e60c:	bd08      	pop	{r3, pc}
                : (Odr <=   26.0f) ? LSM6DSL_XL_ODR_26Hz
 800e60e:	eef3 7a0a 	vmov.f32	s15, #58	; 0x41d00000  26.0
 800e612:	eeb4 0ae7 	vcmpe.f32	s0, s15
 800e616:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800e61a:	d978      	bls.n	800e70e <LSM6DSL_ACC_SetOutputDataRate+0x122>
 800e61c:	eddf 7a4a 	vldr	s15, [pc, #296]	; 800e748 <LSM6DSL_ACC_SetOutputDataRate+0x15c>
 800e620:	eeb4 0ae7 	vcmpe.f32	s0, s15
 800e624:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800e628:	d975      	bls.n	800e716 <LSM6DSL_ACC_SetOutputDataRate+0x12a>
 800e62a:	eddf 7a48 	vldr	s15, [pc, #288]	; 800e74c <LSM6DSL_ACC_SetOutputDataRate+0x160>
 800e62e:	eeb4 0ae7 	vcmpe.f32	s0, s15
 800e632:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800e636:	d972      	bls.n	800e71e <LSM6DSL_ACC_SetOutputDataRate+0x132>
 800e638:	eddf 7a45 	vldr	s15, [pc, #276]	; 800e750 <LSM6DSL_ACC_SetOutputDataRate+0x164>
 800e63c:	eeb4 0ae7 	vcmpe.f32	s0, s15
 800e640:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800e644:	d96f      	bls.n	800e726 <LSM6DSL_ACC_SetOutputDataRate+0x13a>
 800e646:	eddf 7a43 	vldr	s15, [pc, #268]	; 800e754 <LSM6DSL_ACC_SetOutputDataRate+0x168>
 800e64a:	eeb4 0ae7 	vcmpe.f32	s0, s15
 800e64e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800e652:	d96c      	bls.n	800e72e <LSM6DSL_ACC_SetOutputDataRate+0x142>
 800e654:	eddf 7a40 	vldr	s15, [pc, #256]	; 800e758 <LSM6DSL_ACC_SetOutputDataRate+0x16c>
 800e658:	eeb4 0ae7 	vcmpe.f32	s0, s15
 800e65c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800e660:	d969      	bls.n	800e736 <LSM6DSL_ACC_SetOutputDataRate+0x14a>
 800e662:	eddf 7a3e 	vldr	s15, [pc, #248]	; 800e75c <LSM6DSL_ACC_SetOutputDataRate+0x170>
 800e666:	eeb4 0ae7 	vcmpe.f32	s0, s15
 800e66a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800e66e:	d966      	bls.n	800e73e <LSM6DSL_ACC_SetOutputDataRate+0x152>
 800e670:	eddf 7a3b 	vldr	s15, [pc, #236]	; 800e760 <LSM6DSL_ACC_SetOutputDataRate+0x174>
 800e674:	eeb4 0ae7 	vcmpe.f32	s0, s15
 800e678:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800e67c:	bf94      	ite	ls
 800e67e:	2309      	movls	r3, #9
 800e680:	230a      	movhi	r3, #10
 800e682:	e7c0      	b.n	800e606 <LSM6DSL_ACC_SetOutputDataRate+0x1a>
          : (Odr <=   26.0f) ? LSM6DSL_XL_ODR_26Hz
 800e684:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800e688:	d939      	bls.n	800e6fe <LSM6DSL_ACC_SetOutputDataRate+0x112>
 800e68a:	eef3 7a0a 	vmov.f32	s15, #58	; 0x41d00000  26.0
 800e68e:	eeb4 0ae7 	vcmpe.f32	s0, s15
 800e692:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800e696:	d93c      	bls.n	800e712 <LSM6DSL_ACC_SetOutputDataRate+0x126>
 800e698:	eddf 7a2b 	vldr	s15, [pc, #172]	; 800e748 <LSM6DSL_ACC_SetOutputDataRate+0x15c>
 800e69c:	eeb4 0ae7 	vcmpe.f32	s0, s15
 800e6a0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800e6a4:	d939      	bls.n	800e71a <LSM6DSL_ACC_SetOutputDataRate+0x12e>
 800e6a6:	eddf 7a29 	vldr	s15, [pc, #164]	; 800e74c <LSM6DSL_ACC_SetOutputDataRate+0x160>
 800e6aa:	eeb4 0ae7 	vcmpe.f32	s0, s15
 800e6ae:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800e6b2:	d936      	bls.n	800e722 <LSM6DSL_ACC_SetOutputDataRate+0x136>
 800e6b4:	eddf 7a26 	vldr	s15, [pc, #152]	; 800e750 <LSM6DSL_ACC_SetOutputDataRate+0x164>
 800e6b8:	eeb4 0ae7 	vcmpe.f32	s0, s15
 800e6bc:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800e6c0:	d933      	bls.n	800e72a <LSM6DSL_ACC_SetOutputDataRate+0x13e>
 800e6c2:	eddf 7a24 	vldr	s15, [pc, #144]	; 800e754 <LSM6DSL_ACC_SetOutputDataRate+0x168>
 800e6c6:	eeb4 0ae7 	vcmpe.f32	s0, s15
 800e6ca:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800e6ce:	d930      	bls.n	800e732 <LSM6DSL_ACC_SetOutputDataRate+0x146>
 800e6d0:	eddf 7a21 	vldr	s15, [pc, #132]	; 800e758 <LSM6DSL_ACC_SetOutputDataRate+0x16c>
 800e6d4:	eeb4 0ae7 	vcmpe.f32	s0, s15
 800e6d8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800e6dc:	d92d      	bls.n	800e73a <LSM6DSL_ACC_SetOutputDataRate+0x14e>
 800e6de:	eddf 7a1f 	vldr	s15, [pc, #124]	; 800e75c <LSM6DSL_ACC_SetOutputDataRate+0x170>
 800e6e2:	eeb4 0ae7 	vcmpe.f32	s0, s15
 800e6e6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800e6ea:	d92a      	bls.n	800e742 <LSM6DSL_ACC_SetOutputDataRate+0x156>
 800e6ec:	eddf 7a1c 	vldr	s15, [pc, #112]	; 800e760 <LSM6DSL_ACC_SetOutputDataRate+0x174>
 800e6f0:	eeb4 0ae7 	vcmpe.f32	s0, s15
 800e6f4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800e6f8:	bf94      	ite	ls
 800e6fa:	2109      	movls	r1, #9
 800e6fc:	210a      	movhi	r1, #10
  if (lsm6dsl_xl_data_rate_set(&(pObj->Ctx), new_odr) != LSM6DSL_OK)
 800e6fe:	301c      	adds	r0, #28
 800e700:	f000 fc74 	bl	800efec <lsm6dsl_xl_data_rate_set>
 800e704:	3800      	subs	r0, #0
 800e706:	bf18      	it	ne
 800e708:	2001      	movne	r0, #1
 800e70a:	4240      	negs	r0, r0
}
 800e70c:	bd08      	pop	{r3, pc}
                : (Odr <=   26.0f) ? LSM6DSL_XL_ODR_26Hz
 800e70e:	2302      	movs	r3, #2
 800e710:	e779      	b.n	800e606 <LSM6DSL_ACC_SetOutputDataRate+0x1a>
          : (Odr <=   26.0f) ? LSM6DSL_XL_ODR_26Hz
 800e712:	2102      	movs	r1, #2
 800e714:	e7f3      	b.n	800e6fe <LSM6DSL_ACC_SetOutputDataRate+0x112>
                : (Odr <=   26.0f) ? LSM6DSL_XL_ODR_26Hz
 800e716:	2303      	movs	r3, #3
 800e718:	e775      	b.n	800e606 <LSM6DSL_ACC_SetOutputDataRate+0x1a>
          : (Odr <=   26.0f) ? LSM6DSL_XL_ODR_26Hz
 800e71a:	2103      	movs	r1, #3
 800e71c:	e7ef      	b.n	800e6fe <LSM6DSL_ACC_SetOutputDataRate+0x112>
                : (Odr <=   26.0f) ? LSM6DSL_XL_ODR_26Hz
 800e71e:	2304      	movs	r3, #4
 800e720:	e771      	b.n	800e606 <LSM6DSL_ACC_SetOutputDataRate+0x1a>
          : (Odr <=   26.0f) ? LSM6DSL_XL_ODR_26Hz
 800e722:	2104      	movs	r1, #4
 800e724:	e7eb      	b.n	800e6fe <LSM6DSL_ACC_SetOutputDataRate+0x112>
                : (Odr <=   26.0f) ? LSM6DSL_XL_ODR_26Hz
 800e726:	2305      	movs	r3, #5
 800e728:	e76d      	b.n	800e606 <LSM6DSL_ACC_SetOutputDataRate+0x1a>
          : (Odr <=   26.0f) ? LSM6DSL_XL_ODR_26Hz
 800e72a:	2105      	movs	r1, #5
 800e72c:	e7e7      	b.n	800e6fe <LSM6DSL_ACC_SetOutputDataRate+0x112>
                : (Odr <=   26.0f) ? LSM6DSL_XL_ODR_26Hz
 800e72e:	2306      	movs	r3, #6
 800e730:	e769      	b.n	800e606 <LSM6DSL_ACC_SetOutputDataRate+0x1a>
          : (Odr <=   26.0f) ? LSM6DSL_XL_ODR_26Hz
 800e732:	2106      	movs	r1, #6
 800e734:	e7e3      	b.n	800e6fe <LSM6DSL_ACC_SetOutputDataRate+0x112>
                : (Odr <=   26.0f) ? LSM6DSL_XL_ODR_26Hz
 800e736:	2307      	movs	r3, #7
 800e738:	e765      	b.n	800e606 <LSM6DSL_ACC_SetOutputDataRate+0x1a>
          : (Odr <=   26.0f) ? LSM6DSL_XL_ODR_26Hz
 800e73a:	2107      	movs	r1, #7
 800e73c:	e7df      	b.n	800e6fe <LSM6DSL_ACC_SetOutputDataRate+0x112>
                : (Odr <=   26.0f) ? LSM6DSL_XL_ODR_26Hz
 800e73e:	2308      	movs	r3, #8
 800e740:	e761      	b.n	800e606 <LSM6DSL_ACC_SetOutputDataRate+0x1a>
          : (Odr <=   26.0f) ? LSM6DSL_XL_ODR_26Hz
 800e742:	2108      	movs	r1, #8
 800e744:	e7db      	b.n	800e6fe <LSM6DSL_ACC_SetOutputDataRate+0x112>
 800e746:	bf00      	nop
 800e748:	42500000 	.word	0x42500000
 800e74c:	42d00000 	.word	0x42d00000
 800e750:	43500000 	.word	0x43500000
 800e754:	43d00000 	.word	0x43d00000
 800e758:	44504000 	.word	0x44504000
 800e75c:	44cf8000 	.word	0x44cf8000
 800e760:	45502000 	.word	0x45502000

0800e764 <LSM6DSL_ACC_SetFullScale>:
           : (FullScale <= 4) ? LSM6DSL_4g
 800e764:	2902      	cmp	r1, #2
{
 800e766:	b508      	push	{r3, lr}
           : (FullScale <= 4) ? LSM6DSL_4g
 800e768:	dd06      	ble.n	800e778 <LSM6DSL_ACC_SetFullScale+0x14>
 800e76a:	2904      	cmp	r1, #4
 800e76c:	dd0d      	ble.n	800e78a <LSM6DSL_ACC_SetFullScale+0x26>
 800e76e:	2909      	cmp	r1, #9
 800e770:	bfb4      	ite	lt
 800e772:	2103      	movlt	r1, #3
 800e774:	2101      	movge	r1, #1
 800e776:	e000      	b.n	800e77a <LSM6DSL_ACC_SetFullScale+0x16>
 800e778:	2100      	movs	r1, #0
  if (lsm6dsl_xl_full_scale_set(&(pObj->Ctx), new_fs) != LSM6DSL_OK)
 800e77a:	301c      	adds	r0, #28
 800e77c:	f000 fbf6 	bl	800ef6c <lsm6dsl_xl_full_scale_set>
 800e780:	3800      	subs	r0, #0
 800e782:	bf18      	it	ne
 800e784:	2001      	movne	r0, #1
}
 800e786:	4240      	negs	r0, r0
 800e788:	bd08      	pop	{r3, pc}
           : (FullScale <= 4) ? LSM6DSL_4g
 800e78a:	2102      	movs	r1, #2
 800e78c:	e7f5      	b.n	800e77a <LSM6DSL_ACC_SetFullScale+0x16>
 800e78e:	bf00      	nop

0800e790 <LSM6DSL_GYRO_SetOutputDataRate>:
{
 800e790:	b508      	push	{r3, lr}
  if (pObj->gyro_is_enabled == 1U)
 800e792:	f890 102a 	ldrb.w	r1, [r0, #42]	; 0x2a
          : (Odr <=   26.0f) ? LSM6DSL_GY_ODR_26Hz
 800e796:	eef2 7a09 	vmov.f32	s15, #41	; 0x41480000  12.5
  if (pObj->gyro_is_enabled == 1U)
 800e79a:	2901      	cmp	r1, #1
          : (Odr <=   26.0f) ? LSM6DSL_GY_ODR_26Hz
 800e79c:	eeb4 0ae7 	vcmpe.f32	s0, s15
  if (pObj->gyro_is_enabled == 1U)
 800e7a0:	d042      	beq.n	800e828 <LSM6DSL_GYRO_SetOutputDataRate+0x98>
                 : (Odr <=   26.0f) ? LSM6DSL_GY_ODR_26Hz
 800e7a2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800e7a6:	d804      	bhi.n	800e7b2 <LSM6DSL_GYRO_SetOutputDataRate+0x22>
 800e7a8:	2301      	movs	r3, #1
  pObj->gyro_odr = (Odr <=   12.5f) ? LSM6DSL_GY_ODR_12Hz5
 800e7aa:	f880 302c 	strb.w	r3, [r0, #44]	; 0x2c
    return LSM6DSL_GYRO_SetOutputDataRate_When_Disabled(pObj, Odr);
 800e7ae:	2000      	movs	r0, #0
}
 800e7b0:	bd08      	pop	{r3, pc}
                 : (Odr <=   26.0f) ? LSM6DSL_GY_ODR_26Hz
 800e7b2:	eef3 7a0a 	vmov.f32	s15, #58	; 0x41d00000  26.0
 800e7b6:	eeb4 0ae7 	vcmpe.f32	s0, s15
 800e7ba:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800e7be:	d978      	bls.n	800e8b2 <LSM6DSL_GYRO_SetOutputDataRate+0x122>
 800e7c0:	eddf 7a4a 	vldr	s15, [pc, #296]	; 800e8ec <LSM6DSL_GYRO_SetOutputDataRate+0x15c>
 800e7c4:	eeb4 0ae7 	vcmpe.f32	s0, s15
 800e7c8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800e7cc:	d975      	bls.n	800e8ba <LSM6DSL_GYRO_SetOutputDataRate+0x12a>
 800e7ce:	eddf 7a48 	vldr	s15, [pc, #288]	; 800e8f0 <LSM6DSL_GYRO_SetOutputDataRate+0x160>
 800e7d2:	eeb4 0ae7 	vcmpe.f32	s0, s15
 800e7d6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800e7da:	d972      	bls.n	800e8c2 <LSM6DSL_GYRO_SetOutputDataRate+0x132>
 800e7dc:	eddf 7a45 	vldr	s15, [pc, #276]	; 800e8f4 <LSM6DSL_GYRO_SetOutputDataRate+0x164>
 800e7e0:	eeb4 0ae7 	vcmpe.f32	s0, s15
 800e7e4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800e7e8:	d96f      	bls.n	800e8ca <LSM6DSL_GYRO_SetOutputDataRate+0x13a>
 800e7ea:	eddf 7a43 	vldr	s15, [pc, #268]	; 800e8f8 <LSM6DSL_GYRO_SetOutputDataRate+0x168>
 800e7ee:	eeb4 0ae7 	vcmpe.f32	s0, s15
 800e7f2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800e7f6:	d96c      	bls.n	800e8d2 <LSM6DSL_GYRO_SetOutputDataRate+0x142>
 800e7f8:	eddf 7a40 	vldr	s15, [pc, #256]	; 800e8fc <LSM6DSL_GYRO_SetOutputDataRate+0x16c>
 800e7fc:	eeb4 0ae7 	vcmpe.f32	s0, s15
 800e800:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800e804:	d969      	bls.n	800e8da <LSM6DSL_GYRO_SetOutputDataRate+0x14a>
 800e806:	eddf 7a3e 	vldr	s15, [pc, #248]	; 800e900 <LSM6DSL_GYRO_SetOutputDataRate+0x170>
 800e80a:	eeb4 0ae7 	vcmpe.f32	s0, s15
 800e80e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800e812:	d966      	bls.n	800e8e2 <LSM6DSL_GYRO_SetOutputDataRate+0x152>
 800e814:	eddf 7a3b 	vldr	s15, [pc, #236]	; 800e904 <LSM6DSL_GYRO_SetOutputDataRate+0x174>
 800e818:	eeb4 0ae7 	vcmpe.f32	s0, s15
 800e81c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800e820:	bf94      	ite	ls
 800e822:	2309      	movls	r3, #9
 800e824:	230a      	movhi	r3, #10
 800e826:	e7c0      	b.n	800e7aa <LSM6DSL_GYRO_SetOutputDataRate+0x1a>
          : (Odr <=   26.0f) ? LSM6DSL_GY_ODR_26Hz
 800e828:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800e82c:	d939      	bls.n	800e8a2 <LSM6DSL_GYRO_SetOutputDataRate+0x112>
 800e82e:	eef3 7a0a 	vmov.f32	s15, #58	; 0x41d00000  26.0
 800e832:	eeb4 0ae7 	vcmpe.f32	s0, s15
 800e836:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800e83a:	d93c      	bls.n	800e8b6 <LSM6DSL_GYRO_SetOutputDataRate+0x126>
 800e83c:	eddf 7a2b 	vldr	s15, [pc, #172]	; 800e8ec <LSM6DSL_GYRO_SetOutputDataRate+0x15c>
 800e840:	eeb4 0ae7 	vcmpe.f32	s0, s15
 800e844:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800e848:	d939      	bls.n	800e8be <LSM6DSL_GYRO_SetOutputDataRate+0x12e>
 800e84a:	eddf 7a29 	vldr	s15, [pc, #164]	; 800e8f0 <LSM6DSL_GYRO_SetOutputDataRate+0x160>
 800e84e:	eeb4 0ae7 	vcmpe.f32	s0, s15
 800e852:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800e856:	d936      	bls.n	800e8c6 <LSM6DSL_GYRO_SetOutputDataRate+0x136>
 800e858:	eddf 7a26 	vldr	s15, [pc, #152]	; 800e8f4 <LSM6DSL_GYRO_SetOutputDataRate+0x164>
 800e85c:	eeb4 0ae7 	vcmpe.f32	s0, s15
 800e860:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800e864:	d933      	bls.n	800e8ce <LSM6DSL_GYRO_SetOutputDataRate+0x13e>
 800e866:	eddf 7a24 	vldr	s15, [pc, #144]	; 800e8f8 <LSM6DSL_GYRO_SetOutputDataRate+0x168>
 800e86a:	eeb4 0ae7 	vcmpe.f32	s0, s15
 800e86e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800e872:	d930      	bls.n	800e8d6 <LSM6DSL_GYRO_SetOutputDataRate+0x146>
 800e874:	eddf 7a21 	vldr	s15, [pc, #132]	; 800e8fc <LSM6DSL_GYRO_SetOutputDataRate+0x16c>
 800e878:	eeb4 0ae7 	vcmpe.f32	s0, s15
 800e87c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800e880:	d92d      	bls.n	800e8de <LSM6DSL_GYRO_SetOutputDataRate+0x14e>
 800e882:	eddf 7a1f 	vldr	s15, [pc, #124]	; 800e900 <LSM6DSL_GYRO_SetOutputDataRate+0x170>
 800e886:	eeb4 0ae7 	vcmpe.f32	s0, s15
 800e88a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800e88e:	d92a      	bls.n	800e8e6 <LSM6DSL_GYRO_SetOutputDataRate+0x156>
 800e890:	eddf 7a1c 	vldr	s15, [pc, #112]	; 800e904 <LSM6DSL_GYRO_SetOutputDataRate+0x174>
 800e894:	eeb4 0ae7 	vcmpe.f32	s0, s15
 800e898:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800e89c:	bf94      	ite	ls
 800e89e:	2109      	movls	r1, #9
 800e8a0:	210a      	movhi	r1, #10
  if (lsm6dsl_gy_data_rate_set(&(pObj->Ctx), new_odr) != LSM6DSL_OK)
 800e8a2:	301c      	adds	r0, #28
 800e8a4:	f000 fc42 	bl	800f12c <lsm6dsl_gy_data_rate_set>
 800e8a8:	3800      	subs	r0, #0
 800e8aa:	bf18      	it	ne
 800e8ac:	2001      	movne	r0, #1
 800e8ae:	4240      	negs	r0, r0
}
 800e8b0:	bd08      	pop	{r3, pc}
                 : (Odr <=   26.0f) ? LSM6DSL_GY_ODR_26Hz
 800e8b2:	2302      	movs	r3, #2
 800e8b4:	e779      	b.n	800e7aa <LSM6DSL_GYRO_SetOutputDataRate+0x1a>
          : (Odr <=   26.0f) ? LSM6DSL_GY_ODR_26Hz
 800e8b6:	2102      	movs	r1, #2
 800e8b8:	e7f3      	b.n	800e8a2 <LSM6DSL_GYRO_SetOutputDataRate+0x112>
                 : (Odr <=   26.0f) ? LSM6DSL_GY_ODR_26Hz
 800e8ba:	2303      	movs	r3, #3
 800e8bc:	e775      	b.n	800e7aa <LSM6DSL_GYRO_SetOutputDataRate+0x1a>
          : (Odr <=   26.0f) ? LSM6DSL_GY_ODR_26Hz
 800e8be:	2103      	movs	r1, #3
 800e8c0:	e7ef      	b.n	800e8a2 <LSM6DSL_GYRO_SetOutputDataRate+0x112>
                 : (Odr <=   26.0f) ? LSM6DSL_GY_ODR_26Hz
 800e8c2:	2304      	movs	r3, #4
 800e8c4:	e771      	b.n	800e7aa <LSM6DSL_GYRO_SetOutputDataRate+0x1a>
          : (Odr <=   26.0f) ? LSM6DSL_GY_ODR_26Hz
 800e8c6:	2104      	movs	r1, #4
 800e8c8:	e7eb      	b.n	800e8a2 <LSM6DSL_GYRO_SetOutputDataRate+0x112>
                 : (Odr <=   26.0f) ? LSM6DSL_GY_ODR_26Hz
 800e8ca:	2305      	movs	r3, #5
 800e8cc:	e76d      	b.n	800e7aa <LSM6DSL_GYRO_SetOutputDataRate+0x1a>
          : (Odr <=   26.0f) ? LSM6DSL_GY_ODR_26Hz
 800e8ce:	2105      	movs	r1, #5
 800e8d0:	e7e7      	b.n	800e8a2 <LSM6DSL_GYRO_SetOutputDataRate+0x112>
                 : (Odr <=   26.0f) ? LSM6DSL_GY_ODR_26Hz
 800e8d2:	2306      	movs	r3, #6
 800e8d4:	e769      	b.n	800e7aa <LSM6DSL_GYRO_SetOutputDataRate+0x1a>
          : (Odr <=   26.0f) ? LSM6DSL_GY_ODR_26Hz
 800e8d6:	2106      	movs	r1, #6
 800e8d8:	e7e3      	b.n	800e8a2 <LSM6DSL_GYRO_SetOutputDataRate+0x112>
                 : (Odr <=   26.0f) ? LSM6DSL_GY_ODR_26Hz
 800e8da:	2307      	movs	r3, #7
 800e8dc:	e765      	b.n	800e7aa <LSM6DSL_GYRO_SetOutputDataRate+0x1a>
          : (Odr <=   26.0f) ? LSM6DSL_GY_ODR_26Hz
 800e8de:	2107      	movs	r1, #7
 800e8e0:	e7df      	b.n	800e8a2 <LSM6DSL_GYRO_SetOutputDataRate+0x112>
                 : (Odr <=   26.0f) ? LSM6DSL_GY_ODR_26Hz
 800e8e2:	2308      	movs	r3, #8
 800e8e4:	e761      	b.n	800e7aa <LSM6DSL_GYRO_SetOutputDataRate+0x1a>
          : (Odr <=   26.0f) ? LSM6DSL_GY_ODR_26Hz
 800e8e6:	2108      	movs	r1, #8
 800e8e8:	e7db      	b.n	800e8a2 <LSM6DSL_GYRO_SetOutputDataRate+0x112>
 800e8ea:	bf00      	nop
 800e8ec:	42500000 	.word	0x42500000
 800e8f0:	42d00000 	.word	0x42d00000
 800e8f4:	43500000 	.word	0x43500000
 800e8f8:	43d00000 	.word	0x43d00000
 800e8fc:	44504000 	.word	0x44504000
 800e900:	44cf8000 	.word	0x44cf8000
 800e904:	45502000 	.word	0x45502000

0800e908 <LSM6DSL_Init>:
{
 800e908:	b570      	push	{r4, r5, r6, lr}
  if (lsm6dsl_auto_increment_set(&(pObj->Ctx), PROPERTY_ENABLE) != LSM6DSL_OK)
 800e90a:	f100 041c 	add.w	r4, r0, #28
{
 800e90e:	4605      	mov	r5, r0
  if (lsm6dsl_auto_increment_set(&(pObj->Ctx), PROPERTY_ENABLE) != LSM6DSL_OK)
 800e910:	2101      	movs	r1, #1
 800e912:	4620      	mov	r0, r4
 800e914:	f000 fc98 	bl	800f248 <lsm6dsl_auto_increment_set>
 800e918:	bb30      	cbnz	r0, 800e968 <LSM6DSL_Init+0x60>
  if (lsm6dsl_block_data_update_set(&(pObj->Ctx), PROPERTY_ENABLE) != LSM6DSL_OK)
 800e91a:	2101      	movs	r1, #1
 800e91c:	4620      	mov	r0, r4
 800e91e:	f000 fc5b 	bl	800f1d8 <lsm6dsl_block_data_update_set>
 800e922:	4601      	mov	r1, r0
 800e924:	bb00      	cbnz	r0, 800e968 <LSM6DSL_Init+0x60>
  if (lsm6dsl_fifo_mode_set(&(pObj->Ctx), LSM6DSL_BYPASS_MODE) != LSM6DSL_OK)
 800e926:	4620      	mov	r0, r4
 800e928:	f000 fca8 	bl	800f27c <lsm6dsl_fifo_mode_set>
 800e92c:	4601      	mov	r1, r0
 800e92e:	b9d8      	cbnz	r0, 800e968 <LSM6DSL_Init+0x60>
  pObj->acc_odr = LSM6DSL_XL_ODR_104Hz;
 800e930:	2604      	movs	r6, #4
 800e932:	f885 602b 	strb.w	r6, [r5, #43]	; 0x2b
  if (lsm6dsl_xl_data_rate_set(&(pObj->Ctx), LSM6DSL_XL_ODR_OFF) != LSM6DSL_OK)
 800e936:	4620      	mov	r0, r4
 800e938:	f000 fb58 	bl	800efec <lsm6dsl_xl_data_rate_set>
 800e93c:	4601      	mov	r1, r0
 800e93e:	b998      	cbnz	r0, 800e968 <LSM6DSL_Init+0x60>
  if (lsm6dsl_xl_full_scale_set(&(pObj->Ctx), LSM6DSL_2g) != LSM6DSL_OK)
 800e940:	4620      	mov	r0, r4
 800e942:	f000 fb13 	bl	800ef6c <lsm6dsl_xl_full_scale_set>
 800e946:	4601      	mov	r1, r0
 800e948:	b970      	cbnz	r0, 800e968 <LSM6DSL_Init+0x60>
  pObj->gyro_odr = LSM6DSL_GY_ODR_104Hz;
 800e94a:	f885 602c 	strb.w	r6, [r5, #44]	; 0x2c
  if (lsm6dsl_gy_data_rate_set(&(pObj->Ctx), LSM6DSL_GY_ODR_OFF) != LSM6DSL_OK)
 800e94e:	4620      	mov	r0, r4
 800e950:	f000 fbec 	bl	800f12c <lsm6dsl_gy_data_rate_set>
 800e954:	b940      	cbnz	r0, 800e968 <LSM6DSL_Init+0x60>
  if (lsm6dsl_gy_full_scale_set(&(pObj->Ctx), LSM6DSL_2000dps) != LSM6DSL_OK)
 800e956:	2106      	movs	r1, #6
 800e958:	4620      	mov	r0, r4
 800e95a:	f000 fb9f 	bl	800f09c <lsm6dsl_gy_full_scale_set>
 800e95e:	b918      	cbnz	r0, 800e968 <LSM6DSL_Init+0x60>
  pObj->is_initialized = 1;
 800e960:	2301      	movs	r3, #1
 800e962:	f885 3028 	strb.w	r3, [r5, #40]	; 0x28
}
 800e966:	bd70      	pop	{r4, r5, r6, pc}
    return LSM6DSL_ERROR;
 800e968:	f04f 30ff 	mov.w	r0, #4294967295
}
 800e96c:	bd70      	pop	{r4, r5, r6, pc}
 800e96e:	bf00      	nop

0800e970 <LSM6DSL_GYRO_SetFullScale>:
           : (FullScale <= 250)  ? LSM6DSL_250dps
 800e970:	297d      	cmp	r1, #125	; 0x7d
{
 800e972:	b508      	push	{r3, lr}
           : (FullScale <= 250)  ? LSM6DSL_250dps
 800e974:	dd0a      	ble.n	800e98c <LSM6DSL_GYRO_SetFullScale+0x1c>
 800e976:	29fa      	cmp	r1, #250	; 0xfa
 800e978:	dd11      	ble.n	800e99e <LSM6DSL_GYRO_SetFullScale+0x2e>
 800e97a:	f5b1 7ffa 	cmp.w	r1, #500	; 0x1f4
 800e97e:	dd10      	ble.n	800e9a2 <LSM6DSL_GYRO_SetFullScale+0x32>
 800e980:	f5b1 7f7a 	cmp.w	r1, #1000	; 0x3e8
 800e984:	bfd4      	ite	le
 800e986:	2104      	movle	r1, #4
 800e988:	2106      	movgt	r1, #6
 800e98a:	e000      	b.n	800e98e <LSM6DSL_GYRO_SetFullScale+0x1e>
 800e98c:	2101      	movs	r1, #1
  if (lsm6dsl_gy_full_scale_set(&(pObj->Ctx), new_fs) != LSM6DSL_OK)
 800e98e:	301c      	adds	r0, #28
 800e990:	f000 fb84 	bl	800f09c <lsm6dsl_gy_full_scale_set>
 800e994:	3800      	subs	r0, #0
 800e996:	bf18      	it	ne
 800e998:	2001      	movne	r0, #1
}
 800e99a:	4240      	negs	r0, r0
 800e99c:	bd08      	pop	{r3, pc}
           : (FullScale <= 250)  ? LSM6DSL_250dps
 800e99e:	2100      	movs	r1, #0
 800e9a0:	e7f5      	b.n	800e98e <LSM6DSL_GYRO_SetFullScale+0x1e>
 800e9a2:	2102      	movs	r1, #2
 800e9a4:	e7f3      	b.n	800e98e <LSM6DSL_GYRO_SetFullScale+0x1e>
 800e9a6:	bf00      	nop

0800e9a8 <LSM6DSL_ReadID>:
{
 800e9a8:	b508      	push	{r3, lr}
  if (lsm6dsl_device_id_get(&(pObj->Ctx), Id) != LSM6DSL_OK)
 800e9aa:	301c      	adds	r0, #28
 800e9ac:	f000 fc42 	bl	800f234 <lsm6dsl_device_id_get>
 800e9b0:	3800      	subs	r0, #0
 800e9b2:	bf18      	it	ne
 800e9b4:	2001      	movne	r0, #1
}
 800e9b6:	4240      	negs	r0, r0
 800e9b8:	bd08      	pop	{r3, pc}
 800e9ba:	bf00      	nop

0800e9bc <LSM6DSL_ACC_GetOutputDataRate>:
{
 800e9bc:	b510      	push	{r4, lr}
 800e9be:	b082      	sub	sp, #8
 800e9c0:	460c      	mov	r4, r1
  if (lsm6dsl_xl_data_rate_get(&(pObj->Ctx), &odr_low_level) != LSM6DSL_OK)
 800e9c2:	301c      	adds	r0, #28
 800e9c4:	f10d 0107 	add.w	r1, sp, #7
 800e9c8:	f000 fb2a 	bl	800f020 <lsm6dsl_xl_data_rate_get>
 800e9cc:	2800      	cmp	r0, #0
 800e9ce:	d130      	bne.n	800ea32 <LSM6DSL_ACC_GetOutputDataRate+0x76>
  switch (odr_low_level)
 800e9d0:	f89d 3007 	ldrb.w	r3, [sp, #7]
 800e9d4:	2b0b      	cmp	r3, #11
 800e9d6:	d82c      	bhi.n	800ea32 <LSM6DSL_ACC_GetOutputDataRate+0x76>
 800e9d8:	e8df f003 	tbb	[pc, r3]
 800e9dc:	13100d0a 	.word	0x13100d0a
 800e9e0:	1f1c1916 	.word	0x1f1c1916
 800e9e4:	06282522 	.word	0x06282522
      *Odr = 1.6f;
 800e9e8:	4b13      	ldr	r3, [pc, #76]	; (800ea38 <LSM6DSL_ACC_GetOutputDataRate+0x7c>)
 800e9ea:	6023      	str	r3, [r4, #0]
}
 800e9ec:	b002      	add	sp, #8
 800e9ee:	bd10      	pop	{r4, pc}
      *Odr = 0.0f;
 800e9f0:	2300      	movs	r3, #0
 800e9f2:	6023      	str	r3, [r4, #0]
      break;
 800e9f4:	e7fa      	b.n	800e9ec <LSM6DSL_ACC_GetOutputDataRate+0x30>
      *Odr = 12.5f;
 800e9f6:	4b11      	ldr	r3, [pc, #68]	; (800ea3c <LSM6DSL_ACC_GetOutputDataRate+0x80>)
 800e9f8:	6023      	str	r3, [r4, #0]
      break;
 800e9fa:	e7f7      	b.n	800e9ec <LSM6DSL_ACC_GetOutputDataRate+0x30>
      *Odr = 26.0f;
 800e9fc:	4b10      	ldr	r3, [pc, #64]	; (800ea40 <LSM6DSL_ACC_GetOutputDataRate+0x84>)
 800e9fe:	6023      	str	r3, [r4, #0]
      break;
 800ea00:	e7f4      	b.n	800e9ec <LSM6DSL_ACC_GetOutputDataRate+0x30>
      *Odr = 52.0f;
 800ea02:	4b10      	ldr	r3, [pc, #64]	; (800ea44 <LSM6DSL_ACC_GetOutputDataRate+0x88>)
 800ea04:	6023      	str	r3, [r4, #0]
      break;
 800ea06:	e7f1      	b.n	800e9ec <LSM6DSL_ACC_GetOutputDataRate+0x30>
      *Odr = 104.0f;
 800ea08:	4b0f      	ldr	r3, [pc, #60]	; (800ea48 <LSM6DSL_ACC_GetOutputDataRate+0x8c>)
 800ea0a:	6023      	str	r3, [r4, #0]
      break;
 800ea0c:	e7ee      	b.n	800e9ec <LSM6DSL_ACC_GetOutputDataRate+0x30>
      *Odr = 208.0f;
 800ea0e:	4b0f      	ldr	r3, [pc, #60]	; (800ea4c <LSM6DSL_ACC_GetOutputDataRate+0x90>)
 800ea10:	6023      	str	r3, [r4, #0]
      break;
 800ea12:	e7eb      	b.n	800e9ec <LSM6DSL_ACC_GetOutputDataRate+0x30>
      *Odr = 416.0f;
 800ea14:	4b0e      	ldr	r3, [pc, #56]	; (800ea50 <LSM6DSL_ACC_GetOutputDataRate+0x94>)
 800ea16:	6023      	str	r3, [r4, #0]
      break;
 800ea18:	e7e8      	b.n	800e9ec <LSM6DSL_ACC_GetOutputDataRate+0x30>
      *Odr = 833.0f;
 800ea1a:	4b0e      	ldr	r3, [pc, #56]	; (800ea54 <LSM6DSL_ACC_GetOutputDataRate+0x98>)
 800ea1c:	6023      	str	r3, [r4, #0]
      break;
 800ea1e:	e7e5      	b.n	800e9ec <LSM6DSL_ACC_GetOutputDataRate+0x30>
      *Odr = 1660.0f;
 800ea20:	4b0d      	ldr	r3, [pc, #52]	; (800ea58 <LSM6DSL_ACC_GetOutputDataRate+0x9c>)
 800ea22:	6023      	str	r3, [r4, #0]
      break;
 800ea24:	e7e2      	b.n	800e9ec <LSM6DSL_ACC_GetOutputDataRate+0x30>
      *Odr = 3330.0f;
 800ea26:	4b0d      	ldr	r3, [pc, #52]	; (800ea5c <LSM6DSL_ACC_GetOutputDataRate+0xa0>)
 800ea28:	6023      	str	r3, [r4, #0]
      break;
 800ea2a:	e7df      	b.n	800e9ec <LSM6DSL_ACC_GetOutputDataRate+0x30>
      *Odr = 6660.0f;
 800ea2c:	4b0c      	ldr	r3, [pc, #48]	; (800ea60 <LSM6DSL_ACC_GetOutputDataRate+0xa4>)
 800ea2e:	6023      	str	r3, [r4, #0]
      break;
 800ea30:	e7dc      	b.n	800e9ec <LSM6DSL_ACC_GetOutputDataRate+0x30>
  switch (odr_low_level)
 800ea32:	f04f 30ff 	mov.w	r0, #4294967295
 800ea36:	e7d9      	b.n	800e9ec <LSM6DSL_ACC_GetOutputDataRate+0x30>
 800ea38:	3fcccccd 	.word	0x3fcccccd
 800ea3c:	41480000 	.word	0x41480000
 800ea40:	41d00000 	.word	0x41d00000
 800ea44:	42500000 	.word	0x42500000
 800ea48:	42d00000 	.word	0x42d00000
 800ea4c:	43500000 	.word	0x43500000
 800ea50:	43d00000 	.word	0x43d00000
 800ea54:	44504000 	.word	0x44504000
 800ea58:	44cf8000 	.word	0x44cf8000
 800ea5c:	45502000 	.word	0x45502000
 800ea60:	45d02000 	.word	0x45d02000

0800ea64 <LSM6DSL_ACC_GetSensitivity>:
{
 800ea64:	b510      	push	{r4, lr}
 800ea66:	b082      	sub	sp, #8
 800ea68:	460c      	mov	r4, r1
  if (lsm6dsl_xl_full_scale_get(&(pObj->Ctx), &full_scale) != LSM6DSL_OK)
 800ea6a:	301c      	adds	r0, #28
 800ea6c:	f10d 0107 	add.w	r1, sp, #7
 800ea70:	f000 fa96 	bl	800efa0 <lsm6dsl_xl_full_scale_get>
 800ea74:	b9b8      	cbnz	r0, 800eaa6 <LSM6DSL_ACC_GetSensitivity+0x42>
  switch (full_scale)
 800ea76:	f89d 3007 	ldrb.w	r3, [sp, #7]
 800ea7a:	2b03      	cmp	r3, #3
 800ea7c:	d813      	bhi.n	800eaa6 <LSM6DSL_ACC_GetSensitivity+0x42>
 800ea7e:	e8df f003 	tbb	[pc, r3]
 800ea82:	0a06      	.short	0x0a06
 800ea84:	020e      	.short	0x020e
      *Sensitivity = LSM6DSL_ACC_SENSITIVITY_FS_8G;
 800ea86:	4b09      	ldr	r3, [pc, #36]	; (800eaac <LSM6DSL_ACC_GetSensitivity+0x48>)
 800ea88:	6023      	str	r3, [r4, #0]
}
 800ea8a:	b002      	add	sp, #8
 800ea8c:	bd10      	pop	{r4, pc}
      *Sensitivity = LSM6DSL_ACC_SENSITIVITY_FS_2G;
 800ea8e:	4b08      	ldr	r3, [pc, #32]	; (800eab0 <LSM6DSL_ACC_GetSensitivity+0x4c>)
 800ea90:	6023      	str	r3, [r4, #0]
}
 800ea92:	b002      	add	sp, #8
 800ea94:	bd10      	pop	{r4, pc}
      *Sensitivity = LSM6DSL_ACC_SENSITIVITY_FS_16G;
 800ea96:	4b07      	ldr	r3, [pc, #28]	; (800eab4 <LSM6DSL_ACC_GetSensitivity+0x50>)
 800ea98:	6023      	str	r3, [r4, #0]
}
 800ea9a:	b002      	add	sp, #8
 800ea9c:	bd10      	pop	{r4, pc}
      *Sensitivity = LSM6DSL_ACC_SENSITIVITY_FS_4G;
 800ea9e:	4b06      	ldr	r3, [pc, #24]	; (800eab8 <LSM6DSL_ACC_GetSensitivity+0x54>)
 800eaa0:	6023      	str	r3, [r4, #0]
}
 800eaa2:	b002      	add	sp, #8
 800eaa4:	bd10      	pop	{r4, pc}
  switch (full_scale)
 800eaa6:	f04f 30ff 	mov.w	r0, #4294967295
 800eaaa:	e7ee      	b.n	800ea8a <LSM6DSL_ACC_GetSensitivity+0x26>
 800eaac:	3e79db23 	.word	0x3e79db23
 800eab0:	3d79db23 	.word	0x3d79db23
 800eab4:	3ef9db23 	.word	0x3ef9db23
 800eab8:	3df9db23 	.word	0x3df9db23

0800eabc <LSM6DSL_ACC_GetFullScale>:
{
 800eabc:	b510      	push	{r4, lr}
 800eabe:	b082      	sub	sp, #8
 800eac0:	460c      	mov	r4, r1
  if (lsm6dsl_xl_full_scale_get(&(pObj->Ctx), &fs_low_level) != LSM6DSL_OK)
 800eac2:	301c      	adds	r0, #28
 800eac4:	f10d 0107 	add.w	r1, sp, #7
 800eac8:	f000 fa6a 	bl	800efa0 <lsm6dsl_xl_full_scale_get>
 800eacc:	b9b8      	cbnz	r0, 800eafe <LSM6DSL_ACC_GetFullScale+0x42>
  switch (fs_low_level)
 800eace:	f89d 3007 	ldrb.w	r3, [sp, #7]
 800ead2:	2b03      	cmp	r3, #3
 800ead4:	d813      	bhi.n	800eafe <LSM6DSL_ACC_GetFullScale+0x42>
 800ead6:	e8df f003 	tbb	[pc, r3]
 800eada:	0a06      	.short	0x0a06
 800eadc:	020e      	.short	0x020e
      *FullScale =  8;
 800eade:	2308      	movs	r3, #8
 800eae0:	6023      	str	r3, [r4, #0]
}
 800eae2:	b002      	add	sp, #8
 800eae4:	bd10      	pop	{r4, pc}
      *FullScale =  2;
 800eae6:	2302      	movs	r3, #2
 800eae8:	6023      	str	r3, [r4, #0]
}
 800eaea:	b002      	add	sp, #8
 800eaec:	bd10      	pop	{r4, pc}
      *FullScale = 16;
 800eaee:	2310      	movs	r3, #16
 800eaf0:	6023      	str	r3, [r4, #0]
}
 800eaf2:	b002      	add	sp, #8
 800eaf4:	bd10      	pop	{r4, pc}
      *FullScale =  4;
 800eaf6:	2304      	movs	r3, #4
 800eaf8:	6023      	str	r3, [r4, #0]
}
 800eafa:	b002      	add	sp, #8
 800eafc:	bd10      	pop	{r4, pc}
  switch (fs_low_level)
 800eafe:	f04f 30ff 	mov.w	r0, #4294967295
 800eb02:	e7ee      	b.n	800eae2 <LSM6DSL_ACC_GetFullScale+0x26>

0800eb04 <LSM6DSL_ACC_GetAxesRaw>:
{
 800eb04:	b510      	push	{r4, lr}
 800eb06:	b082      	sub	sp, #8
 800eb08:	460c      	mov	r4, r1
  if (lsm6dsl_acceleration_raw_get(&(pObj->Ctx), data_raw.u8bit) != LSM6DSL_OK)
 800eb0a:	301c      	adds	r0, #28
 800eb0c:	4669      	mov	r1, sp
 800eb0e:	f000 fb87 	bl	800f220 <lsm6dsl_acceleration_raw_get>
 800eb12:	b950      	cbnz	r0, 800eb2a <LSM6DSL_ACC_GetAxesRaw+0x26>
  Value->x = data_raw.i16bit[0];
 800eb14:	f8bd 1000 	ldrh.w	r1, [sp]
  Value->y = data_raw.i16bit[1];
 800eb18:	f8bd 2002 	ldrh.w	r2, [sp, #2]
  Value->z = data_raw.i16bit[2];
 800eb1c:	f8bd 3004 	ldrh.w	r3, [sp, #4]
  Value->x = data_raw.i16bit[0];
 800eb20:	8021      	strh	r1, [r4, #0]
  Value->y = data_raw.i16bit[1];
 800eb22:	8062      	strh	r2, [r4, #2]
  Value->z = data_raw.i16bit[2];
 800eb24:	80a3      	strh	r3, [r4, #4]
}
 800eb26:	b002      	add	sp, #8
 800eb28:	bd10      	pop	{r4, pc}
    return LSM6DSL_ERROR;
 800eb2a:	f04f 30ff 	mov.w	r0, #4294967295
 800eb2e:	e7fa      	b.n	800eb26 <LSM6DSL_ACC_GetAxesRaw+0x22>

0800eb30 <LSM6DSL_ACC_GetAxes>:
{
 800eb30:	b530      	push	{r4, r5, lr}
 800eb32:	b085      	sub	sp, #20
 800eb34:	4605      	mov	r5, r0
  float sensitivity = 0.0f;
 800eb36:	2300      	movs	r3, #0
{
 800eb38:	460c      	mov	r4, r1
  if (lsm6dsl_acceleration_raw_get(&(pObj->Ctx), data_raw.u8bit) != LSM6DSL_OK)
 800eb3a:	301c      	adds	r0, #28
 800eb3c:	a902      	add	r1, sp, #8
  float sensitivity = 0.0f;
 800eb3e:	9301      	str	r3, [sp, #4]
  if (lsm6dsl_acceleration_raw_get(&(pObj->Ctx), data_raw.u8bit) != LSM6DSL_OK)
 800eb40:	f000 fb6e 	bl	800f220 <lsm6dsl_acceleration_raw_get>
 800eb44:	bb60      	cbnz	r0, 800eba0 <LSM6DSL_ACC_GetAxes+0x70>
  if (LSM6DSL_ACC_GetSensitivity(pObj, &sensitivity) != LSM6DSL_OK)
 800eb46:	a901      	add	r1, sp, #4
 800eb48:	4628      	mov	r0, r5
 800eb4a:	f7ff ff8b 	bl	800ea64 <LSM6DSL_ACC_GetSensitivity>
 800eb4e:	bb38      	cbnz	r0, 800eba0 <LSM6DSL_ACC_GetAxes+0x70>
  Acceleration->x = (int32_t)((float)((float)data_raw.i16bit[0] * sensitivity));
 800eb50:	f9bd 3008 	ldrsh.w	r3, [sp, #8]
 800eb54:	ed9d 6a01 	vldr	s12, [sp, #4]
 800eb58:	ee06 3a90 	vmov	s13, r3
  Acceleration->y = (int32_t)((float)((float)data_raw.i16bit[1] * sensitivity));
 800eb5c:	f9bd 300a 	ldrsh.w	r3, [sp, #10]
 800eb60:	ee07 3a10 	vmov	s14, r3
  Acceleration->z = (int32_t)((float)((float)data_raw.i16bit[2] * sensitivity));
 800eb64:	f9bd 300c 	ldrsh.w	r3, [sp, #12]
 800eb68:	ee07 3a90 	vmov	s15, r3
  Acceleration->x = (int32_t)((float)((float)data_raw.i16bit[0] * sensitivity));
 800eb6c:	eef8 6ae6 	vcvt.f32.s32	s13, s13
  Acceleration->y = (int32_t)((float)((float)data_raw.i16bit[1] * sensitivity));
 800eb70:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
  Acceleration->z = (int32_t)((float)((float)data_raw.i16bit[2] * sensitivity));
 800eb74:	eef8 7ae7 	vcvt.f32.s32	s15, s15
  Acceleration->x = (int32_t)((float)((float)data_raw.i16bit[0] * sensitivity));
 800eb78:	ee66 6a86 	vmul.f32	s13, s13, s12
  Acceleration->y = (int32_t)((float)((float)data_raw.i16bit[1] * sensitivity));
 800eb7c:	ee27 7a06 	vmul.f32	s14, s14, s12
  Acceleration->z = (int32_t)((float)((float)data_raw.i16bit[2] * sensitivity));
 800eb80:	ee67 7a86 	vmul.f32	s15, s15, s12
  Acceleration->x = (int32_t)((float)((float)data_raw.i16bit[0] * sensitivity));
 800eb84:	eefd 6ae6 	vcvt.s32.f32	s13, s13
  Acceleration->y = (int32_t)((float)((float)data_raw.i16bit[1] * sensitivity));
 800eb88:	eebd 7ac7 	vcvt.s32.f32	s14, s14
  Acceleration->z = (int32_t)((float)((float)data_raw.i16bit[2] * sensitivity));
 800eb8c:	eefd 7ae7 	vcvt.s32.f32	s15, s15
  Acceleration->x = (int32_t)((float)((float)data_raw.i16bit[0] * sensitivity));
 800eb90:	edc4 6a00 	vstr	s13, [r4]
  Acceleration->y = (int32_t)((float)((float)data_raw.i16bit[1] * sensitivity));
 800eb94:	ed84 7a01 	vstr	s14, [r4, #4]
  Acceleration->z = (int32_t)((float)((float)data_raw.i16bit[2] * sensitivity));
 800eb98:	edc4 7a02 	vstr	s15, [r4, #8]
}
 800eb9c:	b005      	add	sp, #20
 800eb9e:	bd30      	pop	{r4, r5, pc}
    return LSM6DSL_ERROR;
 800eba0:	f04f 30ff 	mov.w	r0, #4294967295
 800eba4:	e7fa      	b.n	800eb9c <LSM6DSL_ACC_GetAxes+0x6c>
 800eba6:	bf00      	nop

0800eba8 <LSM6DSL_GYRO_GetOutputDataRate>:
{
 800eba8:	b510      	push	{r4, lr}
 800ebaa:	b082      	sub	sp, #8
 800ebac:	460c      	mov	r4, r1
  if (lsm6dsl_gy_data_rate_get(&(pObj->Ctx), &odr_low_level) != LSM6DSL_OK)
 800ebae:	301c      	adds	r0, #28
 800ebb0:	f10d 0107 	add.w	r1, sp, #7
 800ebb4:	f000 fad4 	bl	800f160 <lsm6dsl_gy_data_rate_get>
 800ebb8:	2800      	cmp	r0, #0
 800ebba:	d12d      	bne.n	800ec18 <LSM6DSL_GYRO_GetOutputDataRate+0x70>
  switch (odr_low_level)
 800ebbc:	f89d 3007 	ldrb.w	r3, [sp, #7]
 800ebc0:	2b0a      	cmp	r3, #10
 800ebc2:	d829      	bhi.n	800ec18 <LSM6DSL_GYRO_GetOutputDataRate+0x70>
 800ebc4:	e8df f003 	tbb	[pc, r3]
 800ebc8:	13100d0a 	.word	0x13100d0a
 800ebcc:	1f1c1916 	.word	0x1f1c1916
 800ebd0:	2522      	.short	0x2522
 800ebd2:	06          	.byte	0x06
 800ebd3:	00          	.byte	0x00
      *Odr =  6660.0f;
 800ebd4:	4b12      	ldr	r3, [pc, #72]	; (800ec20 <LSM6DSL_GYRO_GetOutputDataRate+0x78>)
 800ebd6:	6023      	str	r3, [r4, #0]
}
 800ebd8:	b002      	add	sp, #8
 800ebda:	bd10      	pop	{r4, pc}
      *Odr = 0.0f;
 800ebdc:	2300      	movs	r3, #0
 800ebde:	6023      	str	r3, [r4, #0]
      break;
 800ebe0:	e7fa      	b.n	800ebd8 <LSM6DSL_GYRO_GetOutputDataRate+0x30>
      *Odr = 12.5f;
 800ebe2:	4b10      	ldr	r3, [pc, #64]	; (800ec24 <LSM6DSL_GYRO_GetOutputDataRate+0x7c>)
 800ebe4:	6023      	str	r3, [r4, #0]
      break;
 800ebe6:	e7f7      	b.n	800ebd8 <LSM6DSL_GYRO_GetOutputDataRate+0x30>
      *Odr = 26.0f;
 800ebe8:	4b0f      	ldr	r3, [pc, #60]	; (800ec28 <LSM6DSL_GYRO_GetOutputDataRate+0x80>)
 800ebea:	6023      	str	r3, [r4, #0]
      break;
 800ebec:	e7f4      	b.n	800ebd8 <LSM6DSL_GYRO_GetOutputDataRate+0x30>
      *Odr = 52.0f;
 800ebee:	4b0f      	ldr	r3, [pc, #60]	; (800ec2c <LSM6DSL_GYRO_GetOutputDataRate+0x84>)
 800ebf0:	6023      	str	r3, [r4, #0]
      break;
 800ebf2:	e7f1      	b.n	800ebd8 <LSM6DSL_GYRO_GetOutputDataRate+0x30>
      *Odr = 104.0f;
 800ebf4:	4b0e      	ldr	r3, [pc, #56]	; (800ec30 <LSM6DSL_GYRO_GetOutputDataRate+0x88>)
 800ebf6:	6023      	str	r3, [r4, #0]
      break;
 800ebf8:	e7ee      	b.n	800ebd8 <LSM6DSL_GYRO_GetOutputDataRate+0x30>
      *Odr = 208.0f;
 800ebfa:	4b0e      	ldr	r3, [pc, #56]	; (800ec34 <LSM6DSL_GYRO_GetOutputDataRate+0x8c>)
 800ebfc:	6023      	str	r3, [r4, #0]
      break;
 800ebfe:	e7eb      	b.n	800ebd8 <LSM6DSL_GYRO_GetOutputDataRate+0x30>
      *Odr = 416.0f;
 800ec00:	4b0d      	ldr	r3, [pc, #52]	; (800ec38 <LSM6DSL_GYRO_GetOutputDataRate+0x90>)
 800ec02:	6023      	str	r3, [r4, #0]
      break;
 800ec04:	e7e8      	b.n	800ebd8 <LSM6DSL_GYRO_GetOutputDataRate+0x30>
      *Odr = 833.0f;
 800ec06:	4b0d      	ldr	r3, [pc, #52]	; (800ec3c <LSM6DSL_GYRO_GetOutputDataRate+0x94>)
 800ec08:	6023      	str	r3, [r4, #0]
      break;
 800ec0a:	e7e5      	b.n	800ebd8 <LSM6DSL_GYRO_GetOutputDataRate+0x30>
      *Odr =  1660.0f;
 800ec0c:	4b0c      	ldr	r3, [pc, #48]	; (800ec40 <LSM6DSL_GYRO_GetOutputDataRate+0x98>)
 800ec0e:	6023      	str	r3, [r4, #0]
      break;
 800ec10:	e7e2      	b.n	800ebd8 <LSM6DSL_GYRO_GetOutputDataRate+0x30>
      *Odr =  3330.0f;
 800ec12:	4b0c      	ldr	r3, [pc, #48]	; (800ec44 <LSM6DSL_GYRO_GetOutputDataRate+0x9c>)
 800ec14:	6023      	str	r3, [r4, #0]
      break;
 800ec16:	e7df      	b.n	800ebd8 <LSM6DSL_GYRO_GetOutputDataRate+0x30>
  switch (odr_low_level)
 800ec18:	f04f 30ff 	mov.w	r0, #4294967295
 800ec1c:	e7dc      	b.n	800ebd8 <LSM6DSL_GYRO_GetOutputDataRate+0x30>
 800ec1e:	bf00      	nop
 800ec20:	45d02000 	.word	0x45d02000
 800ec24:	41480000 	.word	0x41480000
 800ec28:	41d00000 	.word	0x41d00000
 800ec2c:	42500000 	.word	0x42500000
 800ec30:	42d00000 	.word	0x42d00000
 800ec34:	43500000 	.word	0x43500000
 800ec38:	43d00000 	.word	0x43d00000
 800ec3c:	44504000 	.word	0x44504000
 800ec40:	44cf8000 	.word	0x44cf8000
 800ec44:	45502000 	.word	0x45502000

0800ec48 <LSM6DSL_GYRO_GetSensitivity>:
{
 800ec48:	b510      	push	{r4, lr}
 800ec4a:	b082      	sub	sp, #8
 800ec4c:	460c      	mov	r4, r1
  if (lsm6dsl_gy_full_scale_get(&(pObj->Ctx), &full_scale) != LSM6DSL_OK)
 800ec4e:	301c      	adds	r0, #28
 800ec50:	f10d 0107 	add.w	r1, sp, #7
 800ec54:	f000 fa3c 	bl	800f0d0 <lsm6dsl_gy_full_scale_get>
 800ec58:	b948      	cbnz	r0, 800ec6e <LSM6DSL_GYRO_GetSensitivity+0x26>
  switch (full_scale)
 800ec5a:	f89d 3007 	ldrb.w	r3, [sp, #7]
 800ec5e:	2b06      	cmp	r3, #6
 800ec60:	d805      	bhi.n	800ec6e <LSM6DSL_GYRO_GetSensitivity+0x26>
 800ec62:	e8df f003 	tbb	[pc, r3]
 800ec66:	0c08      	.short	0x0c08
 800ec68:	04140410 	.word	0x04140410
 800ec6c:	18          	.byte	0x18
 800ec6d:	00          	.byte	0x00
 800ec6e:	f04f 30ff 	mov.w	r0, #4294967295
}
 800ec72:	b002      	add	sp, #8
 800ec74:	bd10      	pop	{r4, pc}
      *Sensitivity = LSM6DSL_GYRO_SENSITIVITY_FS_250DPS;
 800ec76:	4b0a      	ldr	r3, [pc, #40]	; (800eca0 <LSM6DSL_GYRO_GetSensitivity+0x58>)
 800ec78:	6023      	str	r3, [r4, #0]
}
 800ec7a:	b002      	add	sp, #8
 800ec7c:	bd10      	pop	{r4, pc}
      *Sensitivity = LSM6DSL_GYRO_SENSITIVITY_FS_125DPS;
 800ec7e:	4b09      	ldr	r3, [pc, #36]	; (800eca4 <LSM6DSL_GYRO_GetSensitivity+0x5c>)
 800ec80:	6023      	str	r3, [r4, #0]
}
 800ec82:	b002      	add	sp, #8
 800ec84:	bd10      	pop	{r4, pc}
      *Sensitivity = LSM6DSL_GYRO_SENSITIVITY_FS_500DPS;
 800ec86:	4b08      	ldr	r3, [pc, #32]	; (800eca8 <LSM6DSL_GYRO_GetSensitivity+0x60>)
 800ec88:	6023      	str	r3, [r4, #0]
}
 800ec8a:	b002      	add	sp, #8
 800ec8c:	bd10      	pop	{r4, pc}
      *Sensitivity = LSM6DSL_GYRO_SENSITIVITY_FS_1000DPS;
 800ec8e:	4b07      	ldr	r3, [pc, #28]	; (800ecac <LSM6DSL_GYRO_GetSensitivity+0x64>)
 800ec90:	6023      	str	r3, [r4, #0]
}
 800ec92:	b002      	add	sp, #8
 800ec94:	bd10      	pop	{r4, pc}
      *Sensitivity = LSM6DSL_GYRO_SENSITIVITY_FS_2000DPS;
 800ec96:	4b06      	ldr	r3, [pc, #24]	; (800ecb0 <LSM6DSL_GYRO_GetSensitivity+0x68>)
 800ec98:	6023      	str	r3, [r4, #0]
}
 800ec9a:	b002      	add	sp, #8
 800ec9c:	bd10      	pop	{r4, pc}
 800ec9e:	bf00      	nop
 800eca0:	410c0000 	.word	0x410c0000
 800eca4:	408c0000 	.word	0x408c0000
 800eca8:	418c0000 	.word	0x418c0000
 800ecac:	420c0000 	.word	0x420c0000
 800ecb0:	428c0000 	.word	0x428c0000

0800ecb4 <LSM6DSL_GYRO_GetFullScale>:
{
 800ecb4:	b510      	push	{r4, lr}
 800ecb6:	b082      	sub	sp, #8
 800ecb8:	460c      	mov	r4, r1
  if (lsm6dsl_gy_full_scale_get(&(pObj->Ctx), &fs_low_level) != LSM6DSL_OK)
 800ecba:	301c      	adds	r0, #28
 800ecbc:	f10d 0107 	add.w	r1, sp, #7
 800ecc0:	f000 fa06 	bl	800f0d0 <lsm6dsl_gy_full_scale_get>
 800ecc4:	b948      	cbnz	r0, 800ecda <LSM6DSL_GYRO_GetFullScale+0x26>
  switch (fs_low_level)
 800ecc6:	f89d 3007 	ldrb.w	r3, [sp, #7]
 800ecca:	2b06      	cmp	r3, #6
 800eccc:	d805      	bhi.n	800ecda <LSM6DSL_GYRO_GetFullScale+0x26>
 800ecce:	e8df f003 	tbb	[pc, r3]
 800ecd2:	0c08      	.short	0x0c08
 800ecd4:	04150410 	.word	0x04150410
 800ecd8:	1a          	.byte	0x1a
 800ecd9:	00          	.byte	0x00
 800ecda:	f04f 30ff 	mov.w	r0, #4294967295
}
 800ecde:	b002      	add	sp, #8
 800ece0:	bd10      	pop	{r4, pc}
      *FullScale =  250;
 800ece2:	23fa      	movs	r3, #250	; 0xfa
 800ece4:	6023      	str	r3, [r4, #0]
}
 800ece6:	b002      	add	sp, #8
 800ece8:	bd10      	pop	{r4, pc}
      *FullScale =  125;
 800ecea:	237d      	movs	r3, #125	; 0x7d
 800ecec:	6023      	str	r3, [r4, #0]
}
 800ecee:	b002      	add	sp, #8
 800ecf0:	bd10      	pop	{r4, pc}
      *FullScale =  500;
 800ecf2:	f44f 73fa 	mov.w	r3, #500	; 0x1f4
 800ecf6:	6023      	str	r3, [r4, #0]
}
 800ecf8:	b002      	add	sp, #8
 800ecfa:	bd10      	pop	{r4, pc}
      *FullScale = 1000;
 800ecfc:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 800ed00:	6023      	str	r3, [r4, #0]
}
 800ed02:	b002      	add	sp, #8
 800ed04:	bd10      	pop	{r4, pc}
      *FullScale = 2000;
 800ed06:	f44f 63fa 	mov.w	r3, #2000	; 0x7d0
 800ed0a:	6023      	str	r3, [r4, #0]
}
 800ed0c:	b002      	add	sp, #8
 800ed0e:	bd10      	pop	{r4, pc}

0800ed10 <LSM6DSL_GYRO_GetAxesRaw>:
{
 800ed10:	b510      	push	{r4, lr}
 800ed12:	b082      	sub	sp, #8
 800ed14:	460c      	mov	r4, r1
  if (lsm6dsl_angular_rate_raw_get(&(pObj->Ctx), data_raw.u8bit) != LSM6DSL_OK)
 800ed16:	301c      	adds	r0, #28
 800ed18:	4669      	mov	r1, sp
 800ed1a:	f000 fa77 	bl	800f20c <lsm6dsl_angular_rate_raw_get>
 800ed1e:	b950      	cbnz	r0, 800ed36 <LSM6DSL_GYRO_GetAxesRaw+0x26>
  Value->x = data_raw.i16bit[0];
 800ed20:	f8bd 1000 	ldrh.w	r1, [sp]
  Value->y = data_raw.i16bit[1];
 800ed24:	f8bd 2002 	ldrh.w	r2, [sp, #2]
  Value->z = data_raw.i16bit[2];
 800ed28:	f8bd 3004 	ldrh.w	r3, [sp, #4]
  Value->x = data_raw.i16bit[0];
 800ed2c:	8021      	strh	r1, [r4, #0]
  Value->y = data_raw.i16bit[1];
 800ed2e:	8062      	strh	r2, [r4, #2]
  Value->z = data_raw.i16bit[2];
 800ed30:	80a3      	strh	r3, [r4, #4]
}
 800ed32:	b002      	add	sp, #8
 800ed34:	bd10      	pop	{r4, pc}
    return LSM6DSL_ERROR;
 800ed36:	f04f 30ff 	mov.w	r0, #4294967295
 800ed3a:	e7fa      	b.n	800ed32 <LSM6DSL_GYRO_GetAxesRaw+0x22>

0800ed3c <LSM6DSL_GYRO_GetAxes>:
{
 800ed3c:	b530      	push	{r4, r5, lr}
 800ed3e:	b085      	sub	sp, #20
 800ed40:	4605      	mov	r5, r0
 800ed42:	460c      	mov	r4, r1
  if (lsm6dsl_angular_rate_raw_get(&(pObj->Ctx), data_raw.u8bit) != LSM6DSL_OK)
 800ed44:	301c      	adds	r0, #28
 800ed46:	a902      	add	r1, sp, #8
 800ed48:	f000 fa60 	bl	800f20c <lsm6dsl_angular_rate_raw_get>
 800ed4c:	bb60      	cbnz	r0, 800eda8 <LSM6DSL_GYRO_GetAxes+0x6c>
  if (LSM6DSL_GYRO_GetSensitivity(pObj, &sensitivity) != LSM6DSL_OK)
 800ed4e:	a901      	add	r1, sp, #4
 800ed50:	4628      	mov	r0, r5
 800ed52:	f7ff ff79 	bl	800ec48 <LSM6DSL_GYRO_GetSensitivity>
 800ed56:	bb38      	cbnz	r0, 800eda8 <LSM6DSL_GYRO_GetAxes+0x6c>
  AngularRate->x = (int32_t)((float)((float)data_raw.i16bit[0] * sensitivity));
 800ed58:	f9bd 3008 	ldrsh.w	r3, [sp, #8]
 800ed5c:	ed9d 6a01 	vldr	s12, [sp, #4]
 800ed60:	ee06 3a90 	vmov	s13, r3
  AngularRate->y = (int32_t)((float)((float)data_raw.i16bit[1] * sensitivity));
 800ed64:	f9bd 300a 	ldrsh.w	r3, [sp, #10]
 800ed68:	ee07 3a10 	vmov	s14, r3
  AngularRate->z = (int32_t)((float)((float)data_raw.i16bit[2] * sensitivity));
 800ed6c:	f9bd 300c 	ldrsh.w	r3, [sp, #12]
 800ed70:	ee07 3a90 	vmov	s15, r3
  AngularRate->x = (int32_t)((float)((float)data_raw.i16bit[0] * sensitivity));
 800ed74:	eef8 6ae6 	vcvt.f32.s32	s13, s13
  AngularRate->y = (int32_t)((float)((float)data_raw.i16bit[1] * sensitivity));
 800ed78:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
  AngularRate->z = (int32_t)((float)((float)data_raw.i16bit[2] * sensitivity));
 800ed7c:	eef8 7ae7 	vcvt.f32.s32	s15, s15
  AngularRate->x = (int32_t)((float)((float)data_raw.i16bit[0] * sensitivity));
 800ed80:	ee66 6a86 	vmul.f32	s13, s13, s12
  AngularRate->y = (int32_t)((float)((float)data_raw.i16bit[1] * sensitivity));
 800ed84:	ee27 7a06 	vmul.f32	s14, s14, s12
  AngularRate->z = (int32_t)((float)((float)data_raw.i16bit[2] * sensitivity));
 800ed88:	ee67 7a86 	vmul.f32	s15, s15, s12
  AngularRate->x = (int32_t)((float)((float)data_raw.i16bit[0] * sensitivity));
 800ed8c:	eefd 6ae6 	vcvt.s32.f32	s13, s13
  AngularRate->y = (int32_t)((float)((float)data_raw.i16bit[1] * sensitivity));
 800ed90:	eebd 7ac7 	vcvt.s32.f32	s14, s14
  AngularRate->z = (int32_t)((float)((float)data_raw.i16bit[2] * sensitivity));
 800ed94:	eefd 7ae7 	vcvt.s32.f32	s15, s15
  AngularRate->x = (int32_t)((float)((float)data_raw.i16bit[0] * sensitivity));
 800ed98:	edc4 6a00 	vstr	s13, [r4]
  AngularRate->y = (int32_t)((float)((float)data_raw.i16bit[1] * sensitivity));
 800ed9c:	ed84 7a01 	vstr	s14, [r4, #4]
  AngularRate->z = (int32_t)((float)((float)data_raw.i16bit[2] * sensitivity));
 800eda0:	edc4 7a02 	vstr	s15, [r4, #8]
}
 800eda4:	b005      	add	sp, #20
 800eda6:	bd30      	pop	{r4, r5, pc}
    return LSM6DSL_ERROR;
 800eda8:	f04f 30ff 	mov.w	r0, #4294967295
 800edac:	e7fa      	b.n	800eda4 <LSM6DSL_GYRO_GetAxes+0x68>
 800edae:	bf00      	nop

0800edb0 <LSM6DSL_ACC_Enable>:
  if (pObj->acc_is_enabled == 1U)
 800edb0:	f890 3029 	ldrb.w	r3, [r0, #41]	; 0x29
 800edb4:	2b01      	cmp	r3, #1
 800edb6:	d00b      	beq.n	800edd0 <LSM6DSL_ACC_Enable+0x20>
{
 800edb8:	b510      	push	{r4, lr}
 800edba:	4604      	mov	r4, r0
  if (lsm6dsl_xl_data_rate_set(&(pObj->Ctx), pObj->acc_odr) != LSM6DSL_OK)
 800edbc:	f890 102b 	ldrb.w	r1, [r0, #43]	; 0x2b
 800edc0:	301c      	adds	r0, #28
 800edc2:	f000 f913 	bl	800efec <lsm6dsl_xl_data_rate_set>
 800edc6:	b928      	cbnz	r0, 800edd4 <LSM6DSL_ACC_Enable+0x24>
  pObj->acc_is_enabled = 1;
 800edc8:	2301      	movs	r3, #1
 800edca:	f884 3029 	strb.w	r3, [r4, #41]	; 0x29
}
 800edce:	bd10      	pop	{r4, pc}
    return LSM6DSL_OK;
 800edd0:	2000      	movs	r0, #0
}
 800edd2:	4770      	bx	lr
    return LSM6DSL_ERROR;
 800edd4:	f04f 30ff 	mov.w	r0, #4294967295
}
 800edd8:	bd10      	pop	{r4, pc}
 800edda:	bf00      	nop

0800eddc <LSM6DSL_GYRO_Enable>:
  if (pObj->gyro_is_enabled == 1U)
 800eddc:	f890 302a 	ldrb.w	r3, [r0, #42]	; 0x2a
 800ede0:	2b01      	cmp	r3, #1
 800ede2:	d00b      	beq.n	800edfc <LSM6DSL_GYRO_Enable+0x20>
{
 800ede4:	b510      	push	{r4, lr}
 800ede6:	4604      	mov	r4, r0
  if (lsm6dsl_gy_data_rate_set(&(pObj->Ctx), pObj->gyro_odr) != LSM6DSL_OK)
 800ede8:	f890 102c 	ldrb.w	r1, [r0, #44]	; 0x2c
 800edec:	301c      	adds	r0, #28
 800edee:	f000 f99d 	bl	800f12c <lsm6dsl_gy_data_rate_set>
 800edf2:	b928      	cbnz	r0, 800ee00 <LSM6DSL_GYRO_Enable+0x24>
  pObj->gyro_is_enabled = 1;
 800edf4:	2301      	movs	r3, #1
 800edf6:	f884 302a 	strb.w	r3, [r4, #42]	; 0x2a
}
 800edfa:	bd10      	pop	{r4, pc}
    return LSM6DSL_OK;
 800edfc:	2000      	movs	r0, #0
}
 800edfe:	4770      	bx	lr
    return LSM6DSL_ERROR;
 800ee00:	f04f 30ff 	mov.w	r0, #4294967295
}
 800ee04:	bd10      	pop	{r4, pc}
 800ee06:	bf00      	nop

0800ee08 <LSM6DSL_DeInit>:
{
 800ee08:	b538      	push	{r3, r4, r5, lr}
  if (pObj->acc_is_enabled == 0U)
 800ee0a:	f890 3029 	ldrb.w	r3, [r0, #41]	; 0x29
{
 800ee0e:	4604      	mov	r4, r0
  if (pObj->acc_is_enabled == 0U)
 800ee10:	b953      	cbnz	r3, 800ee28 <LSM6DSL_DeInit+0x20>
  if (pObj->gyro_is_enabled == 0U)
 800ee12:	f894 302a 	ldrb.w	r3, [r4, #42]	; 0x2a
 800ee16:	b9d3      	cbnz	r3, 800ee4e <LSM6DSL_DeInit+0x46>
  pObj->acc_odr = LSM6DSL_XL_ODR_OFF;
 800ee18:	2000      	movs	r0, #0
 800ee1a:	f884 002b 	strb.w	r0, [r4, #43]	; 0x2b
  pObj->gyro_odr = LSM6DSL_GY_ODR_OFF;
 800ee1e:	f884 002c 	strb.w	r0, [r4, #44]	; 0x2c
  pObj->is_initialized = 0;
 800ee22:	f884 0028 	strb.w	r0, [r4, #40]	; 0x28
}
 800ee26:	bd38      	pop	{r3, r4, r5, pc}
  if (lsm6dsl_xl_data_rate_get(&(pObj->Ctx), &pObj->acc_odr) != LSM6DSL_OK)
 800ee28:	f100 051c 	add.w	r5, r0, #28
 800ee2c:	f100 012b 	add.w	r1, r0, #43	; 0x2b
 800ee30:	4628      	mov	r0, r5
 800ee32:	f000 f8f5 	bl	800f020 <lsm6dsl_xl_data_rate_get>
 800ee36:	4601      	mov	r1, r0
 800ee38:	b9c8      	cbnz	r0, 800ee6e <LSM6DSL_DeInit+0x66>
  if (lsm6dsl_xl_data_rate_set(&(pObj->Ctx), LSM6DSL_XL_ODR_OFF) != LSM6DSL_OK)
 800ee3a:	4628      	mov	r0, r5
 800ee3c:	f000 f8d6 	bl	800efec <lsm6dsl_xl_data_rate_set>
 800ee40:	b9a8      	cbnz	r0, 800ee6e <LSM6DSL_DeInit+0x66>
  if (pObj->gyro_is_enabled == 0U)
 800ee42:	f894 302a 	ldrb.w	r3, [r4, #42]	; 0x2a
  pObj->acc_is_enabled = 0;
 800ee46:	f884 0029 	strb.w	r0, [r4, #41]	; 0x29
  if (pObj->gyro_is_enabled == 0U)
 800ee4a:	2b00      	cmp	r3, #0
 800ee4c:	d0e4      	beq.n	800ee18 <LSM6DSL_DeInit+0x10>
  if (lsm6dsl_gy_data_rate_get(&(pObj->Ctx), &pObj->gyro_odr) != LSM6DSL_OK)
 800ee4e:	f104 051c 	add.w	r5, r4, #28
 800ee52:	f104 012c 	add.w	r1, r4, #44	; 0x2c
 800ee56:	4628      	mov	r0, r5
 800ee58:	f000 f982 	bl	800f160 <lsm6dsl_gy_data_rate_get>
 800ee5c:	4601      	mov	r1, r0
 800ee5e:	b930      	cbnz	r0, 800ee6e <LSM6DSL_DeInit+0x66>
  if (lsm6dsl_gy_data_rate_set(&(pObj->Ctx), LSM6DSL_GY_ODR_OFF) != LSM6DSL_OK)
 800ee60:	4628      	mov	r0, r5
 800ee62:	f000 f963 	bl	800f12c <lsm6dsl_gy_data_rate_set>
 800ee66:	b910      	cbnz	r0, 800ee6e <LSM6DSL_DeInit+0x66>
  pObj->gyro_is_enabled = 0;
 800ee68:	f884 002a 	strb.w	r0, [r4, #42]	; 0x2a
  return LSM6DSL_OK;
 800ee6c:	e7d4      	b.n	800ee18 <LSM6DSL_DeInit+0x10>
    return LSM6DSL_ERROR;
 800ee6e:	f04f 30ff 	mov.w	r0, #4294967295
}
 800ee72:	bd38      	pop	{r3, r4, r5, pc}

0800ee74 <LSM6DSL_GYRO_Disable>:
{
 800ee74:	b538      	push	{r3, r4, r5, lr}
 800ee76:	4604      	mov	r4, r0
  if (pObj->gyro_is_enabled == 0U)
 800ee78:	f890 002a 	ldrb.w	r0, [r0, #42]	; 0x2a
 800ee7c:	b900      	cbnz	r0, 800ee80 <LSM6DSL_GYRO_Disable+0xc>
}
 800ee7e:	bd38      	pop	{r3, r4, r5, pc}
  if (lsm6dsl_gy_data_rate_get(&(pObj->Ctx), &pObj->gyro_odr) != LSM6DSL_OK)
 800ee80:	f104 051c 	add.w	r5, r4, #28
 800ee84:	f104 012c 	add.w	r1, r4, #44	; 0x2c
 800ee88:	4628      	mov	r0, r5
 800ee8a:	f000 f969 	bl	800f160 <lsm6dsl_gy_data_rate_get>
 800ee8e:	4601      	mov	r1, r0
 800ee90:	b930      	cbnz	r0, 800eea0 <LSM6DSL_GYRO_Disable+0x2c>
  if (lsm6dsl_gy_data_rate_set(&(pObj->Ctx), LSM6DSL_GY_ODR_OFF) != LSM6DSL_OK)
 800ee92:	4628      	mov	r0, r5
 800ee94:	f000 f94a 	bl	800f12c <lsm6dsl_gy_data_rate_set>
 800ee98:	b910      	cbnz	r0, 800eea0 <LSM6DSL_GYRO_Disable+0x2c>
  pObj->gyro_is_enabled = 0;
 800ee9a:	f884 002a 	strb.w	r0, [r4, #42]	; 0x2a
}
 800ee9e:	bd38      	pop	{r3, r4, r5, pc}
    return LSM6DSL_ERROR;
 800eea0:	f04f 30ff 	mov.w	r0, #4294967295
}
 800eea4:	bd38      	pop	{r3, r4, r5, pc}
 800eea6:	bf00      	nop

0800eea8 <LSM6DSL_ACC_Disable>:
{
 800eea8:	b538      	push	{r3, r4, r5, lr}
 800eeaa:	4604      	mov	r4, r0
  if (pObj->acc_is_enabled == 0U)
 800eeac:	f890 0029 	ldrb.w	r0, [r0, #41]	; 0x29
 800eeb0:	b900      	cbnz	r0, 800eeb4 <LSM6DSL_ACC_Disable+0xc>
}
 800eeb2:	bd38      	pop	{r3, r4, r5, pc}
  if (lsm6dsl_xl_data_rate_get(&(pObj->Ctx), &pObj->acc_odr) != LSM6DSL_OK)
 800eeb4:	f104 051c 	add.w	r5, r4, #28
 800eeb8:	f104 012b 	add.w	r1, r4, #43	; 0x2b
 800eebc:	4628      	mov	r0, r5
 800eebe:	f000 f8af 	bl	800f020 <lsm6dsl_xl_data_rate_get>
 800eec2:	4601      	mov	r1, r0
 800eec4:	b930      	cbnz	r0, 800eed4 <LSM6DSL_ACC_Disable+0x2c>
  if (lsm6dsl_xl_data_rate_set(&(pObj->Ctx), LSM6DSL_XL_ODR_OFF) != LSM6DSL_OK)
 800eec6:	4628      	mov	r0, r5
 800eec8:	f000 f890 	bl	800efec <lsm6dsl_xl_data_rate_set>
 800eecc:	b910      	cbnz	r0, 800eed4 <LSM6DSL_ACC_Disable+0x2c>
  pObj->acc_is_enabled = 0;
 800eece:	f884 0029 	strb.w	r0, [r4, #41]	; 0x29
}
 800eed2:	bd38      	pop	{r3, r4, r5, pc}
    return LSM6DSL_ERROR;
 800eed4:	f04f 30ff 	mov.w	r0, #4294967295
}
 800eed8:	bd38      	pop	{r3, r4, r5, pc}
 800eeda:	bf00      	nop

0800eedc <LSM6DSL_RegisterBusIO>:
  if (pObj == NULL)
 800eedc:	2800      	cmp	r0, #0
 800eede:	d035      	beq.n	800ef4c <LSM6DSL_RegisterBusIO+0x70>
{
 800eee0:	b530      	push	{r4, r5, lr}
 800eee2:	4604      	mov	r4, r0
    pObj->IO.DeInit    = pIO->DeInit;
 800eee4:	e9d1 3000 	ldrd	r3, r0, [r1]
    pObj->IO.BusType   = pIO->BusType;
 800eee8:	688a      	ldr	r2, [r1, #8]
 800eeea:	60a2      	str	r2, [r4, #8]
    pObj->IO.DeInit    = pIO->DeInit;
 800eeec:	e9c4 3000 	strd	r3, r0, [r4]
    pObj->IO.Address   = pIO->Address;
 800eef0:	7b0a      	ldrb	r2, [r1, #12]
 800eef2:	7322      	strb	r2, [r4, #12]
    pObj->IO.ReadReg   = pIO->ReadReg;
 800eef4:	e9d1 5204 	ldrd	r5, r2, [r1, #16]
    pObj->IO.GetTick   = pIO->GetTick;
 800eef8:	6988      	ldr	r0, [r1, #24]
    pObj->Ctx.read_reg  = ReadRegWrap;
 800eefa:	4916      	ldr	r1, [pc, #88]	; (800ef54 <LSM6DSL_RegisterBusIO+0x78>)
    pObj->IO.GetTick   = pIO->GetTick;
 800eefc:	61a0      	str	r0, [r4, #24]
    pObj->IO.ReadReg   = pIO->ReadReg;
 800eefe:	e9c4 5204 	strd	r5, r2, [r4, #16]
    pObj->Ctx.write_reg = WriteRegWrap;
 800ef02:	4a15      	ldr	r2, [pc, #84]	; (800ef58 <LSM6DSL_RegisterBusIO+0x7c>)
    pObj->Ctx.handle   = pObj;
 800ef04:	6264      	str	r4, [r4, #36]	; 0x24
    pObj->Ctx.write_reg = WriteRegWrap;
 800ef06:	e9c4 2107 	strd	r2, r1, [r4, #28]
{
 800ef0a:	b083      	sub	sp, #12
    if (pObj->IO.Init == NULL)
 800ef0c:	b1db      	cbz	r3, 800ef46 <LSM6DSL_RegisterBusIO+0x6a>
    else if (pObj->IO.Init() != LSM6DSL_OK)
 800ef0e:	4798      	blx	r3
 800ef10:	b9c8      	cbnz	r0, 800ef46 <LSM6DSL_RegisterBusIO+0x6a>
      if (pObj->IO.BusType == LSM6DSL_SPI_3WIRES_BUS) /* SPI 3-Wires */
 800ef12:	68a3      	ldr	r3, [r4, #8]
 800ef14:	2b02      	cmp	r3, #2
 800ef16:	d001      	beq.n	800ef1c <LSM6DSL_RegisterBusIO+0x40>
}
 800ef18:	b003      	add	sp, #12
 800ef1a:	bd30      	pop	{r4, r5, pc}
        if (pObj->is_initialized == 0U)
 800ef1c:	f894 3028 	ldrb.w	r3, [r4, #40]	; 0x28
 800ef20:	2b00      	cmp	r3, #0
 800ef22:	d1f9      	bne.n	800ef18 <LSM6DSL_RegisterBusIO+0x3c>
          if (LSM6DSL_Write_Reg(pObj, LSM6DSL_CTRL3_C, data) != LSM6DSL_OK)
 800ef24:	250c      	movs	r5, #12
  if (lsm6dsl_write_reg(&(pObj->Ctx), Reg, &Data, 1) != LSM6DSL_OK)
 800ef26:	2301      	movs	r3, #1
 800ef28:	f10d 0207 	add.w	r2, sp, #7
 800ef2c:	2112      	movs	r1, #18
 800ef2e:	f104 001c 	add.w	r0, r4, #28
 800ef32:	f88d 5007 	strb.w	r5, [sp, #7]
 800ef36:	f000 f811 	bl	800ef5c <lsm6dsl_write_reg>
            ret = LSM6DSL_ERROR;
 800ef3a:	2800      	cmp	r0, #0
 800ef3c:	bf18      	it	ne
 800ef3e:	f04f 30ff 	movne.w	r0, #4294967295
}
 800ef42:	b003      	add	sp, #12
 800ef44:	bd30      	pop	{r4, r5, pc}
    ret = LSM6DSL_ERROR;
 800ef46:	f04f 30ff 	mov.w	r0, #4294967295
 800ef4a:	e7e5      	b.n	800ef18 <LSM6DSL_RegisterBusIO+0x3c>
 800ef4c:	f04f 30ff 	mov.w	r0, #4294967295
}
 800ef50:	4770      	bx	lr
 800ef52:	bf00      	nop
 800ef54:	0800e5cd 	.word	0x0800e5cd
 800ef58:	0800e5dd 	.word	0x0800e5dd

0800ef5c <lsm6dsl_write_reg>:
  * @retval       interface status (MANDATORY: return 0 -> no Error)
  *
  */
int32_t lsm6dsl_write_reg(lsm6dsl_ctx_t* ctx, uint8_t reg, uint8_t* data,
                          uint16_t len)
{
 800ef5c:	b410      	push	{r4}
  int32_t ret;
  ret = ctx->write_reg(ctx->handle, reg, data, len);
 800ef5e:	6804      	ldr	r4, [r0, #0]
 800ef60:	6880      	ldr	r0, [r0, #8]
 800ef62:	46a4      	mov	ip, r4
  return ret;
}
 800ef64:	f85d 4b04 	ldr.w	r4, [sp], #4
  ret = ctx->write_reg(ctx->handle, reg, data, len);
 800ef68:	4760      	bx	ip
 800ef6a:	bf00      	nop

0800ef6c <lsm6dsl_xl_full_scale_set>:
  * @param  val    Change the values of fs_xl in reg CTRL1_XL
  * @retval        Interface status (MANDATORY: return 0 -> no Error).
  *
  */
int32_t lsm6dsl_xl_full_scale_set(lsm6dsl_ctx_t *ctx, lsm6dsl_fs_xl_t val)
{
 800ef6c:	b570      	push	{r4, r5, r6, lr}
 800ef6e:	4604      	mov	r4, r0
 800ef70:	b082      	sub	sp, #8
 800ef72:	460d      	mov	r5, r1
  ret = ctx->read_reg(ctx->handle, reg, data, len);
 800ef74:	6880      	ldr	r0, [r0, #8]
 800ef76:	6866      	ldr	r6, [r4, #4]
 800ef78:	2301      	movs	r3, #1
 800ef7a:	aa01      	add	r2, sp, #4
 800ef7c:	2110      	movs	r1, #16
 800ef7e:	47b0      	blx	r6
  lsm6dsl_ctrl1_xl_t ctrl1_xl;
  int32_t ret;

  ret = lsm6dsl_read_reg(ctx, LSM6DSL_CTRL1_XL, (uint8_t*)&ctrl1_xl, 1);
  if(ret == 0){
 800ef80:	b958      	cbnz	r0, 800ef9a <lsm6dsl_xl_full_scale_set+0x2e>
    ctrl1_xl.fs_xl = (uint8_t) val;
 800ef82:	f89d 3004 	ldrb.w	r3, [sp, #4]
  ret = ctx->write_reg(ctx->handle, reg, data, len);
 800ef86:	6826      	ldr	r6, [r4, #0]
 800ef88:	68a0      	ldr	r0, [r4, #8]
    ctrl1_xl.fs_xl = (uint8_t) val;
 800ef8a:	f365 0383 	bfi	r3, r5, #2, #2
 800ef8e:	f88d 3004 	strb.w	r3, [sp, #4]
  ret = ctx->write_reg(ctx->handle, reg, data, len);
 800ef92:	aa01      	add	r2, sp, #4
 800ef94:	2301      	movs	r3, #1
 800ef96:	2110      	movs	r1, #16
 800ef98:	47b0      	blx	r6
    ret = lsm6dsl_write_reg(ctx, LSM6DSL_CTRL1_XL, (uint8_t*)&ctrl1_xl, 1);
  }
  return ret;
}
 800ef9a:	b002      	add	sp, #8
 800ef9c:	bd70      	pop	{r4, r5, r6, pc}
 800ef9e:	bf00      	nop

0800efa0 <lsm6dsl_xl_full_scale_get>:
  * @param  val    Get the values of fs_xl in reg CTRL1_XL
  * @retval        Interface status (MANDATORY: return 0 -> no Error).
  *
  */
int32_t lsm6dsl_xl_full_scale_get(lsm6dsl_ctx_t *ctx, lsm6dsl_fs_xl_t *val)
{
 800efa0:	b530      	push	{r4, r5, lr}
 800efa2:	b083      	sub	sp, #12
  ret = ctx->read_reg(ctx->handle, reg, data, len);
 800efa4:	2301      	movs	r3, #1
 800efa6:	e9d0 4001 	ldrd	r4, r0, [r0, #4]
 800efaa:	aa01      	add	r2, sp, #4
{
 800efac:	460d      	mov	r5, r1
  ret = ctx->read_reg(ctx->handle, reg, data, len);
 800efae:	2110      	movs	r1, #16
 800efb0:	47a0      	blx	r4
  lsm6dsl_ctrl1_xl_t ctrl1_xl;
  int32_t ret;

  ret = lsm6dsl_read_reg(ctx, LSM6DSL_CTRL1_XL, (uint8_t*)&ctrl1_xl, 1);
  switch (ctrl1_xl.fs_xl) {
 800efb2:	f89d 3004 	ldrb.w	r3, [sp, #4]
 800efb6:	f3c3 0381 	ubfx	r3, r3, #2, #2
 800efba:	2b03      	cmp	r3, #3
 800efbc:	d813      	bhi.n	800efe6 <lsm6dsl_xl_full_scale_get+0x46>
 800efbe:	e8df f003 	tbb	[pc, r3]
 800efc2:	0a0e      	.short	0x0a0e
 800efc4:	0206      	.short	0x0206
      break;
    case LSM6DSL_4g:
      *val = LSM6DSL_4g;
      break;
    case LSM6DSL_8g:
      *val = LSM6DSL_8g;
 800efc6:	2303      	movs	r3, #3
 800efc8:	702b      	strb	r3, [r5, #0]
      *val = LSM6DSL_XL_FS_ND;
      break;
  }

  return ret;
}
 800efca:	b003      	add	sp, #12
 800efcc:	bd30      	pop	{r4, r5, pc}
      *val = LSM6DSL_4g;
 800efce:	2302      	movs	r3, #2
 800efd0:	702b      	strb	r3, [r5, #0]
}
 800efd2:	b003      	add	sp, #12
 800efd4:	bd30      	pop	{r4, r5, pc}
      *val = LSM6DSL_16g;
 800efd6:	2301      	movs	r3, #1
 800efd8:	702b      	strb	r3, [r5, #0]
}
 800efda:	b003      	add	sp, #12
 800efdc:	bd30      	pop	{r4, r5, pc}
      *val = LSM6DSL_2g;
 800efde:	2300      	movs	r3, #0
 800efe0:	702b      	strb	r3, [r5, #0]
}
 800efe2:	b003      	add	sp, #12
 800efe4:	bd30      	pop	{r4, r5, pc}
      *val = LSM6DSL_XL_FS_ND;
 800efe6:	2304      	movs	r3, #4
 800efe8:	702b      	strb	r3, [r5, #0]
  return ret;
 800efea:	e7ee      	b.n	800efca <lsm6dsl_xl_full_scale_get+0x2a>

0800efec <lsm6dsl_xl_data_rate_set>:
  * @param  val    Change the values of odr_xl in reg CTRL1_XL
  * @retval        Interface status (MANDATORY: return 0 -> no Error).
  *
  */
int32_t lsm6dsl_xl_data_rate_set(lsm6dsl_ctx_t *ctx, lsm6dsl_odr_xl_t val)
{
 800efec:	b570      	push	{r4, r5, r6, lr}
 800efee:	4604      	mov	r4, r0
 800eff0:	b082      	sub	sp, #8
 800eff2:	460d      	mov	r5, r1
  ret = ctx->read_reg(ctx->handle, reg, data, len);
 800eff4:	6880      	ldr	r0, [r0, #8]
 800eff6:	6866      	ldr	r6, [r4, #4]
 800eff8:	2301      	movs	r3, #1
 800effa:	aa01      	add	r2, sp, #4
 800effc:	2110      	movs	r1, #16
 800effe:	47b0      	blx	r6
  lsm6dsl_ctrl1_xl_t ctrl1_xl;
  int32_t ret;

  ret = lsm6dsl_read_reg(ctx, LSM6DSL_CTRL1_XL, (uint8_t*)&ctrl1_xl, 1);
  if(ret == 0){
 800f000:	b958      	cbnz	r0, 800f01a <lsm6dsl_xl_data_rate_set+0x2e>
    ctrl1_xl.odr_xl = (uint8_t) val;
 800f002:	f89d 3004 	ldrb.w	r3, [sp, #4]
  ret = ctx->write_reg(ctx->handle, reg, data, len);
 800f006:	6826      	ldr	r6, [r4, #0]
 800f008:	68a0      	ldr	r0, [r4, #8]
    ctrl1_xl.odr_xl = (uint8_t) val;
 800f00a:	f365 1307 	bfi	r3, r5, #4, #4
 800f00e:	f88d 3004 	strb.w	r3, [sp, #4]
  ret = ctx->write_reg(ctx->handle, reg, data, len);
 800f012:	aa01      	add	r2, sp, #4
 800f014:	2301      	movs	r3, #1
 800f016:	2110      	movs	r1, #16
 800f018:	47b0      	blx	r6
    ret = lsm6dsl_write_reg(ctx, LSM6DSL_CTRL1_XL, (uint8_t*)&ctrl1_xl, 1);
  }
  return ret;
}
 800f01a:	b002      	add	sp, #8
 800f01c:	bd70      	pop	{r4, r5, r6, pc}
 800f01e:	bf00      	nop

0800f020 <lsm6dsl_xl_data_rate_get>:
  * @param  val    Get the values of odr_xl in reg CTRL1_XL
  * @retval        Interface status (MANDATORY: return 0 -> no Error).
  *
  */
int32_t lsm6dsl_xl_data_rate_get(lsm6dsl_ctx_t *ctx, lsm6dsl_odr_xl_t *val)
{
 800f020:	b530      	push	{r4, r5, lr}
 800f022:	b083      	sub	sp, #12
  ret = ctx->read_reg(ctx->handle, reg, data, len);
 800f024:	2301      	movs	r3, #1
 800f026:	e9d0 4001 	ldrd	r4, r0, [r0, #4]
 800f02a:	aa01      	add	r2, sp, #4
{
 800f02c:	460d      	mov	r5, r1
  ret = ctx->read_reg(ctx->handle, reg, data, len);
 800f02e:	2110      	movs	r1, #16
 800f030:	47a0      	blx	r4
  lsm6dsl_ctrl1_xl_t ctrl1_xl;
  int32_t ret;

  ret = lsm6dsl_read_reg(ctx, LSM6DSL_CTRL1_XL, (uint8_t*)&ctrl1_xl, 1);
  switch (ctrl1_xl.odr_xl) {
 800f032:	f89d 3004 	ldrb.w	r3, [sp, #4]
 800f036:	091b      	lsrs	r3, r3, #4
 800f038:	2b0b      	cmp	r3, #11
 800f03a:	d82c      	bhi.n	800f096 <lsm6dsl_xl_data_rate_get+0x76>
 800f03c:	e8df f003 	tbb	[pc, r3]
 800f040:	13100d0a 	.word	0x13100d0a
 800f044:	1f1c1916 	.word	0x1f1c1916
 800f048:	06282522 	.word	0x06282522
      break;
    case LSM6DSL_XL_ODR_6k66Hz:
      *val = LSM6DSL_XL_ODR_6k66Hz;
      break;
    case LSM6DSL_XL_ODR_1Hz6:
      *val = LSM6DSL_XL_ODR_1Hz6;
 800f04c:	230b      	movs	r3, #11
 800f04e:	702b      	strb	r3, [r5, #0]
      *val = LSM6DSL_XL_ODR_ND;
      break;
  }

  return ret;
}
 800f050:	b003      	add	sp, #12
 800f052:	bd30      	pop	{r4, r5, pc}
      *val = LSM6DSL_XL_ODR_OFF;
 800f054:	2300      	movs	r3, #0
 800f056:	702b      	strb	r3, [r5, #0]
      break;
 800f058:	e7fa      	b.n	800f050 <lsm6dsl_xl_data_rate_get+0x30>
      *val = LSM6DSL_XL_ODR_12Hz5;
 800f05a:	2301      	movs	r3, #1
 800f05c:	702b      	strb	r3, [r5, #0]
      break;
 800f05e:	e7f7      	b.n	800f050 <lsm6dsl_xl_data_rate_get+0x30>
      *val = LSM6DSL_XL_ODR_26Hz;
 800f060:	2302      	movs	r3, #2
 800f062:	702b      	strb	r3, [r5, #0]
      break;
 800f064:	e7f4      	b.n	800f050 <lsm6dsl_xl_data_rate_get+0x30>
      *val = LSM6DSL_XL_ODR_52Hz;
 800f066:	2303      	movs	r3, #3
 800f068:	702b      	strb	r3, [r5, #0]
      break;
 800f06a:	e7f1      	b.n	800f050 <lsm6dsl_xl_data_rate_get+0x30>
      *val = LSM6DSL_XL_ODR_104Hz;
 800f06c:	2304      	movs	r3, #4
 800f06e:	702b      	strb	r3, [r5, #0]
      break;
 800f070:	e7ee      	b.n	800f050 <lsm6dsl_xl_data_rate_get+0x30>
      *val = LSM6DSL_XL_ODR_208Hz;
 800f072:	2305      	movs	r3, #5
 800f074:	702b      	strb	r3, [r5, #0]
      break;
 800f076:	e7eb      	b.n	800f050 <lsm6dsl_xl_data_rate_get+0x30>
      *val = LSM6DSL_XL_ODR_416Hz;
 800f078:	2306      	movs	r3, #6
 800f07a:	702b      	strb	r3, [r5, #0]
      break;
 800f07c:	e7e8      	b.n	800f050 <lsm6dsl_xl_data_rate_get+0x30>
      *val = LSM6DSL_XL_ODR_833Hz;
 800f07e:	2307      	movs	r3, #7
 800f080:	702b      	strb	r3, [r5, #0]
      break;
 800f082:	e7e5      	b.n	800f050 <lsm6dsl_xl_data_rate_get+0x30>
      *val = LSM6DSL_XL_ODR_1k66Hz;
 800f084:	2308      	movs	r3, #8
 800f086:	702b      	strb	r3, [r5, #0]
      break;
 800f088:	e7e2      	b.n	800f050 <lsm6dsl_xl_data_rate_get+0x30>
      *val = LSM6DSL_XL_ODR_3k33Hz;
 800f08a:	2309      	movs	r3, #9
 800f08c:	702b      	strb	r3, [r5, #0]
      break;
 800f08e:	e7df      	b.n	800f050 <lsm6dsl_xl_data_rate_get+0x30>
      *val = LSM6DSL_XL_ODR_6k66Hz;
 800f090:	230a      	movs	r3, #10
 800f092:	702b      	strb	r3, [r5, #0]
      break;
 800f094:	e7dc      	b.n	800f050 <lsm6dsl_xl_data_rate_get+0x30>
      *val = LSM6DSL_XL_ODR_ND;
 800f096:	230c      	movs	r3, #12
 800f098:	702b      	strb	r3, [r5, #0]
  return ret;
 800f09a:	e7d9      	b.n	800f050 <lsm6dsl_xl_data_rate_get+0x30>

0800f09c <lsm6dsl_gy_full_scale_set>:
  * @param  val    Change the values of fs_g in reg CTRL2_G
  * @retval        Interface status (MANDATORY: return 0 -> no Error).
  *
  */
int32_t lsm6dsl_gy_full_scale_set(lsm6dsl_ctx_t *ctx, lsm6dsl_fs_g_t val)
{
 800f09c:	b570      	push	{r4, r5, r6, lr}
 800f09e:	4604      	mov	r4, r0
 800f0a0:	b082      	sub	sp, #8
 800f0a2:	460d      	mov	r5, r1
  ret = ctx->read_reg(ctx->handle, reg, data, len);
 800f0a4:	6880      	ldr	r0, [r0, #8]
 800f0a6:	6866      	ldr	r6, [r4, #4]
 800f0a8:	2301      	movs	r3, #1
 800f0aa:	aa01      	add	r2, sp, #4
 800f0ac:	2111      	movs	r1, #17
 800f0ae:	47b0      	blx	r6
  lsm6dsl_ctrl2_g_t ctrl2_g;
  int32_t ret;

  ret = lsm6dsl_read_reg(ctx, LSM6DSL_CTRL2_G, (uint8_t*)&ctrl2_g, 1);
  if(ret == 0){
 800f0b0:	b958      	cbnz	r0, 800f0ca <lsm6dsl_gy_full_scale_set+0x2e>
    ctrl2_g.fs_g = (uint8_t) val;
 800f0b2:	f89d 3004 	ldrb.w	r3, [sp, #4]
  ret = ctx->write_reg(ctx->handle, reg, data, len);
 800f0b6:	6826      	ldr	r6, [r4, #0]
 800f0b8:	68a0      	ldr	r0, [r4, #8]
    ctrl2_g.fs_g = (uint8_t) val;
 800f0ba:	f365 0343 	bfi	r3, r5, #1, #3
 800f0be:	f88d 3004 	strb.w	r3, [sp, #4]
  ret = ctx->write_reg(ctx->handle, reg, data, len);
 800f0c2:	aa01      	add	r2, sp, #4
 800f0c4:	2301      	movs	r3, #1
 800f0c6:	2111      	movs	r1, #17
 800f0c8:	47b0      	blx	r6
    ret = lsm6dsl_write_reg(ctx, LSM6DSL_CTRL2_G, (uint8_t*)&ctrl2_g, 1);
  }
  return ret;
}
 800f0ca:	b002      	add	sp, #8
 800f0cc:	bd70      	pop	{r4, r5, r6, pc}
 800f0ce:	bf00      	nop

0800f0d0 <lsm6dsl_gy_full_scale_get>:
  * @param  val    Get the values of fs_g in reg CTRL2_G
  * @retval        Interface status (MANDATORY: return 0 -> no Error).
  *
  */
int32_t lsm6dsl_gy_full_scale_get(lsm6dsl_ctx_t *ctx, lsm6dsl_fs_g_t *val)
{
 800f0d0:	b530      	push	{r4, r5, lr}
 800f0d2:	b083      	sub	sp, #12
  ret = ctx->read_reg(ctx->handle, reg, data, len);
 800f0d4:	2301      	movs	r3, #1
 800f0d6:	e9d0 4001 	ldrd	r4, r0, [r0, #4]
 800f0da:	aa01      	add	r2, sp, #4
{
 800f0dc:	460d      	mov	r5, r1
  ret = ctx->read_reg(ctx->handle, reg, data, len);
 800f0de:	2111      	movs	r1, #17
 800f0e0:	47a0      	blx	r4
  lsm6dsl_ctrl2_g_t ctrl2_g;
  int32_t ret;

  ret = lsm6dsl_read_reg(ctx, LSM6DSL_CTRL2_G, (uint8_t*)&ctrl2_g, 1);
  switch (ctrl2_g.fs_g) {
 800f0e2:	f89d 3004 	ldrb.w	r3, [sp, #4]
 800f0e6:	f3c3 0342 	ubfx	r3, r3, #1, #3
 800f0ea:	2b06      	cmp	r3, #6
 800f0ec:	d809      	bhi.n	800f102 <lsm6dsl_gy_full_scale_get+0x32>
 800f0ee:	e8df f003 	tbb	[pc, r3]
 800f0f2:	100c      	.short	0x100c
 800f0f4:	08180814 	.word	0x08180814
 800f0f8:	04          	.byte	0x04
 800f0f9:	00          	.byte	0x00
      break;
    case LSM6DSL_1000dps:
      *val = LSM6DSL_1000dps;
      break;
    case LSM6DSL_2000dps:
      *val = LSM6DSL_2000dps;
 800f0fa:	2306      	movs	r3, #6
 800f0fc:	702b      	strb	r3, [r5, #0]
      *val = LSM6DSL_GY_FS_ND;
      break;
  }

  return ret;
}
 800f0fe:	b003      	add	sp, #12
 800f100:	bd30      	pop	{r4, r5, pc}
      *val = LSM6DSL_GY_FS_ND;
 800f102:	2307      	movs	r3, #7
 800f104:	702b      	strb	r3, [r5, #0]
}
 800f106:	b003      	add	sp, #12
 800f108:	bd30      	pop	{r4, r5, pc}
      *val = LSM6DSL_250dps;
 800f10a:	2300      	movs	r3, #0
 800f10c:	702b      	strb	r3, [r5, #0]
}
 800f10e:	b003      	add	sp, #12
 800f110:	bd30      	pop	{r4, r5, pc}
      *val = LSM6DSL_125dps;
 800f112:	2301      	movs	r3, #1
 800f114:	702b      	strb	r3, [r5, #0]
}
 800f116:	b003      	add	sp, #12
 800f118:	bd30      	pop	{r4, r5, pc}
      *val = LSM6DSL_500dps;
 800f11a:	2302      	movs	r3, #2
 800f11c:	702b      	strb	r3, [r5, #0]
}
 800f11e:	b003      	add	sp, #12
 800f120:	bd30      	pop	{r4, r5, pc}
      *val = LSM6DSL_1000dps;
 800f122:	2304      	movs	r3, #4
 800f124:	702b      	strb	r3, [r5, #0]
}
 800f126:	b003      	add	sp, #12
 800f128:	bd30      	pop	{r4, r5, pc}
 800f12a:	bf00      	nop

0800f12c <lsm6dsl_gy_data_rate_set>:
  * @param  val    Change the values of odr_g in reg CTRL2_G
  * @retval        Interface status (MANDATORY: return 0 -> no Error).
  *
  */
int32_t lsm6dsl_gy_data_rate_set(lsm6dsl_ctx_t *ctx, lsm6dsl_odr_g_t val)
{
 800f12c:	b570      	push	{r4, r5, r6, lr}
 800f12e:	4604      	mov	r4, r0
 800f130:	b082      	sub	sp, #8
 800f132:	460d      	mov	r5, r1
  ret = ctx->read_reg(ctx->handle, reg, data, len);
 800f134:	6880      	ldr	r0, [r0, #8]
 800f136:	6866      	ldr	r6, [r4, #4]
 800f138:	2301      	movs	r3, #1
 800f13a:	aa01      	add	r2, sp, #4
 800f13c:	2111      	movs	r1, #17
 800f13e:	47b0      	blx	r6
  lsm6dsl_ctrl2_g_t ctrl2_g;
  int32_t ret;

  ret = lsm6dsl_read_reg(ctx, LSM6DSL_CTRL2_G, (uint8_t*)&ctrl2_g, 1);
  if(ret == 0){
 800f140:	b958      	cbnz	r0, 800f15a <lsm6dsl_gy_data_rate_set+0x2e>
    ctrl2_g.odr_g = (uint8_t) val;
 800f142:	f89d 3004 	ldrb.w	r3, [sp, #4]
  ret = ctx->write_reg(ctx->handle, reg, data, len);
 800f146:	6826      	ldr	r6, [r4, #0]
 800f148:	68a0      	ldr	r0, [r4, #8]
    ctrl2_g.odr_g = (uint8_t) val;
 800f14a:	f365 1307 	bfi	r3, r5, #4, #4
 800f14e:	f88d 3004 	strb.w	r3, [sp, #4]
  ret = ctx->write_reg(ctx->handle, reg, data, len);
 800f152:	aa01      	add	r2, sp, #4
 800f154:	2301      	movs	r3, #1
 800f156:	2111      	movs	r1, #17
 800f158:	47b0      	blx	r6
    ret = lsm6dsl_write_reg(ctx, LSM6DSL_CTRL2_G, (uint8_t*)&ctrl2_g, 1);
  }
  return ret;
}
 800f15a:	b002      	add	sp, #8
 800f15c:	bd70      	pop	{r4, r5, r6, pc}
 800f15e:	bf00      	nop

0800f160 <lsm6dsl_gy_data_rate_get>:
  * @param  val    Get the values of odr_g in reg CTRL2_G
  * @retval        Interface status (MANDATORY: return 0 -> no Error).
  *
  */
int32_t lsm6dsl_gy_data_rate_get(lsm6dsl_ctx_t *ctx, lsm6dsl_odr_g_t *val)
{
 800f160:	b530      	push	{r4, r5, lr}
 800f162:	b083      	sub	sp, #12
  ret = ctx->read_reg(ctx->handle, reg, data, len);
 800f164:	2301      	movs	r3, #1
 800f166:	e9d0 4001 	ldrd	r4, r0, [r0, #4]
 800f16a:	aa01      	add	r2, sp, #4
{
 800f16c:	460d      	mov	r5, r1
  ret = ctx->read_reg(ctx->handle, reg, data, len);
 800f16e:	2111      	movs	r1, #17
 800f170:	47a0      	blx	r4
  lsm6dsl_ctrl2_g_t ctrl2_g;
  int32_t ret;

  ret = lsm6dsl_read_reg(ctx, LSM6DSL_CTRL2_G, (uint8_t*)&ctrl2_g, 1);
  switch (ctrl2_g.odr_g) {
 800f172:	f89d 3004 	ldrb.w	r3, [sp, #4]
 800f176:	091b      	lsrs	r3, r3, #4
 800f178:	2b0a      	cmp	r3, #10
 800f17a:	d829      	bhi.n	800f1d0 <lsm6dsl_gy_data_rate_get+0x70>
 800f17c:	e8df f003 	tbb	[pc, r3]
 800f180:	13100d0a 	.word	0x13100d0a
 800f184:	1f1c1916 	.word	0x1f1c1916
 800f188:	2522      	.short	0x2522
 800f18a:	06          	.byte	0x06
 800f18b:	00          	.byte	0x00
      break;
    case LSM6DSL_GY_ODR_3k33Hz:
      *val = LSM6DSL_GY_ODR_3k33Hz;
      break;
    case LSM6DSL_GY_ODR_6k66Hz:
      *val = LSM6DSL_GY_ODR_6k66Hz;
 800f18c:	230a      	movs	r3, #10
 800f18e:	702b      	strb	r3, [r5, #0]
      *val = LSM6DSL_GY_ODR_ND;
      break;
  }

  return ret;
}
 800f190:	b003      	add	sp, #12
 800f192:	bd30      	pop	{r4, r5, pc}
      *val = LSM6DSL_GY_ODR_OFF;
 800f194:	2300      	movs	r3, #0
 800f196:	702b      	strb	r3, [r5, #0]
      break;
 800f198:	e7fa      	b.n	800f190 <lsm6dsl_gy_data_rate_get+0x30>
      *val = LSM6DSL_GY_ODR_12Hz5;
 800f19a:	2301      	movs	r3, #1
 800f19c:	702b      	strb	r3, [r5, #0]
      break;
 800f19e:	e7f7      	b.n	800f190 <lsm6dsl_gy_data_rate_get+0x30>
      *val = LSM6DSL_GY_ODR_26Hz;
 800f1a0:	2302      	movs	r3, #2
 800f1a2:	702b      	strb	r3, [r5, #0]
      break;
 800f1a4:	e7f4      	b.n	800f190 <lsm6dsl_gy_data_rate_get+0x30>
      *val = LSM6DSL_GY_ODR_52Hz;
 800f1a6:	2303      	movs	r3, #3
 800f1a8:	702b      	strb	r3, [r5, #0]
      break;
 800f1aa:	e7f1      	b.n	800f190 <lsm6dsl_gy_data_rate_get+0x30>
      *val = LSM6DSL_GY_ODR_104Hz;
 800f1ac:	2304      	movs	r3, #4
 800f1ae:	702b      	strb	r3, [r5, #0]
      break;
 800f1b0:	e7ee      	b.n	800f190 <lsm6dsl_gy_data_rate_get+0x30>
      *val = LSM6DSL_GY_ODR_208Hz;
 800f1b2:	2305      	movs	r3, #5
 800f1b4:	702b      	strb	r3, [r5, #0]
      break;
 800f1b6:	e7eb      	b.n	800f190 <lsm6dsl_gy_data_rate_get+0x30>
      *val = LSM6DSL_GY_ODR_416Hz;
 800f1b8:	2306      	movs	r3, #6
 800f1ba:	702b      	strb	r3, [r5, #0]
      break;
 800f1bc:	e7e8      	b.n	800f190 <lsm6dsl_gy_data_rate_get+0x30>
      *val = LSM6DSL_GY_ODR_833Hz;
 800f1be:	2307      	movs	r3, #7
 800f1c0:	702b      	strb	r3, [r5, #0]
      break;
 800f1c2:	e7e5      	b.n	800f190 <lsm6dsl_gy_data_rate_get+0x30>
      *val = LSM6DSL_GY_ODR_1k66Hz;
 800f1c4:	2308      	movs	r3, #8
 800f1c6:	702b      	strb	r3, [r5, #0]
      break;
 800f1c8:	e7e2      	b.n	800f190 <lsm6dsl_gy_data_rate_get+0x30>
      *val = LSM6DSL_GY_ODR_3k33Hz;
 800f1ca:	2309      	movs	r3, #9
 800f1cc:	702b      	strb	r3, [r5, #0]
      break;
 800f1ce:	e7df      	b.n	800f190 <lsm6dsl_gy_data_rate_get+0x30>
      *val = LSM6DSL_GY_ODR_ND;
 800f1d0:	230b      	movs	r3, #11
 800f1d2:	702b      	strb	r3, [r5, #0]
  return ret;
 800f1d4:	e7dc      	b.n	800f190 <lsm6dsl_gy_data_rate_get+0x30>
 800f1d6:	bf00      	nop

0800f1d8 <lsm6dsl_block_data_update_set>:
  * @param  val    Change the values of bdu in reg CTRL3_C
  * @retval        Interface status (MANDATORY: return 0 -> no Error).
  *
  */
int32_t lsm6dsl_block_data_update_set(lsm6dsl_ctx_t *ctx, uint8_t val)
{
 800f1d8:	b570      	push	{r4, r5, r6, lr}
 800f1da:	4604      	mov	r4, r0
 800f1dc:	b082      	sub	sp, #8
 800f1de:	460d      	mov	r5, r1
  ret = ctx->read_reg(ctx->handle, reg, data, len);
 800f1e0:	6880      	ldr	r0, [r0, #8]
 800f1e2:	6866      	ldr	r6, [r4, #4]
 800f1e4:	2301      	movs	r3, #1
 800f1e6:	aa01      	add	r2, sp, #4
 800f1e8:	2112      	movs	r1, #18
 800f1ea:	47b0      	blx	r6
  lsm6dsl_ctrl3_c_t ctrl3_c;
  int32_t ret;

  ret = lsm6dsl_read_reg(ctx, LSM6DSL_CTRL3_C, (uint8_t*)&ctrl3_c, 1);
  if(ret == 0){
 800f1ec:	b958      	cbnz	r0, 800f206 <lsm6dsl_block_data_update_set+0x2e>
    ctrl3_c.bdu = val;
 800f1ee:	f89d 3004 	ldrb.w	r3, [sp, #4]
  ret = ctx->write_reg(ctx->handle, reg, data, len);
 800f1f2:	6826      	ldr	r6, [r4, #0]
 800f1f4:	68a0      	ldr	r0, [r4, #8]
    ctrl3_c.bdu = val;
 800f1f6:	f365 1386 	bfi	r3, r5, #6, #1
 800f1fa:	f88d 3004 	strb.w	r3, [sp, #4]
  ret = ctx->write_reg(ctx->handle, reg, data, len);
 800f1fe:	aa01      	add	r2, sp, #4
 800f200:	2301      	movs	r3, #1
 800f202:	2112      	movs	r1, #18
 800f204:	47b0      	blx	r6
    ret = lsm6dsl_write_reg(ctx, LSM6DSL_CTRL3_C, (uint8_t*)&ctrl3_c, 1);
  }
  return ret;
}
 800f206:	b002      	add	sp, #8
 800f208:	bd70      	pop	{r4, r5, r6, pc}
 800f20a:	bf00      	nop

0800f20c <lsm6dsl_angular_rate_raw_get>:
  * @param  buff   Buffer that stores data read
  * @retval        Interface status (MANDATORY: return 0 -> no Error).
  *
  */
int32_t lsm6dsl_angular_rate_raw_get(lsm6dsl_ctx_t *ctx, uint8_t *buff)
{
 800f20c:	b410      	push	{r4}
  ret = ctx->read_reg(ctx->handle, reg, data, len);
 800f20e:	e9d0 4001 	ldrd	r4, r0, [r0, #4]
{
 800f212:	460a      	mov	r2, r1
  ret = ctx->read_reg(ctx->handle, reg, data, len);
 800f214:	46a4      	mov	ip, r4
 800f216:	2306      	movs	r3, #6
  int32_t ret;
  ret = lsm6dsl_read_reg(ctx, LSM6DSL_OUTX_L_G, buff, 6);
  return ret;
}
 800f218:	f85d 4b04 	ldr.w	r4, [sp], #4
  ret = ctx->read_reg(ctx->handle, reg, data, len);
 800f21c:	2122      	movs	r1, #34	; 0x22
 800f21e:	4760      	bx	ip

0800f220 <lsm6dsl_acceleration_raw_get>:
  * @param  buff   Buffer that stores data read
  * @retval        Interface status (MANDATORY: return 0 -> no Error).
  *
  */
int32_t lsm6dsl_acceleration_raw_get(lsm6dsl_ctx_t *ctx, uint8_t *buff)
{
 800f220:	b410      	push	{r4}
  ret = ctx->read_reg(ctx->handle, reg, data, len);
 800f222:	e9d0 4001 	ldrd	r4, r0, [r0, #4]
{
 800f226:	460a      	mov	r2, r1
  ret = ctx->read_reg(ctx->handle, reg, data, len);
 800f228:	46a4      	mov	ip, r4
 800f22a:	2306      	movs	r3, #6
  int32_t ret;
  ret = lsm6dsl_read_reg(ctx, LSM6DSL_OUTX_L_XL, buff, 6);
  return ret;
}
 800f22c:	f85d 4b04 	ldr.w	r4, [sp], #4
  ret = ctx->read_reg(ctx->handle, reg, data, len);
 800f230:	2128      	movs	r1, #40	; 0x28
 800f232:	4760      	bx	ip

0800f234 <lsm6dsl_device_id_get>:
  * @param  buff   Buffer that stores data read
  * @retval        Interface status (MANDATORY: return 0 -> no Error).
  *
  */
int32_t lsm6dsl_device_id_get(lsm6dsl_ctx_t *ctx, uint8_t *buff)
{
 800f234:	b410      	push	{r4}
  ret = ctx->read_reg(ctx->handle, reg, data, len);
 800f236:	e9d0 4001 	ldrd	r4, r0, [r0, #4]
{
 800f23a:	460a      	mov	r2, r1
  ret = ctx->read_reg(ctx->handle, reg, data, len);
 800f23c:	46a4      	mov	ip, r4
 800f23e:	2301      	movs	r3, #1
  int32_t ret;
  ret = lsm6dsl_read_reg(ctx, LSM6DSL_WHO_AM_I, buff, 1);
  return ret;
}
 800f240:	f85d 4b04 	ldr.w	r4, [sp], #4
  ret = ctx->read_reg(ctx->handle, reg, data, len);
 800f244:	210f      	movs	r1, #15
 800f246:	4760      	bx	ip

0800f248 <lsm6dsl_auto_increment_set>:
  * @param  val    Change the values of if_inc in reg CTRL3_C
  * @retval        Interface status (MANDATORY: return 0 -> no Error).
  *
  */
int32_t lsm6dsl_auto_increment_set(lsm6dsl_ctx_t *ctx, uint8_t val)
{
 800f248:	b570      	push	{r4, r5, r6, lr}
 800f24a:	4604      	mov	r4, r0
 800f24c:	b082      	sub	sp, #8
 800f24e:	460d      	mov	r5, r1
  ret = ctx->read_reg(ctx->handle, reg, data, len);
 800f250:	6880      	ldr	r0, [r0, #8]
 800f252:	6866      	ldr	r6, [r4, #4]
 800f254:	2301      	movs	r3, #1
 800f256:	aa01      	add	r2, sp, #4
 800f258:	2112      	movs	r1, #18
 800f25a:	47b0      	blx	r6
  lsm6dsl_ctrl3_c_t ctrl3_c;
  int32_t ret;

  ret = lsm6dsl_read_reg(ctx, LSM6DSL_CTRL3_C, (uint8_t*)&ctrl3_c, 1);
  if(ret == 0){
 800f25c:	b958      	cbnz	r0, 800f276 <lsm6dsl_auto_increment_set+0x2e>
    ctrl3_c.if_inc = val;
 800f25e:	f89d 3004 	ldrb.w	r3, [sp, #4]
  ret = ctx->write_reg(ctx->handle, reg, data, len);
 800f262:	6826      	ldr	r6, [r4, #0]
 800f264:	68a0      	ldr	r0, [r4, #8]
    ctrl3_c.if_inc = val;
 800f266:	f365 0382 	bfi	r3, r5, #2, #1
 800f26a:	f88d 3004 	strb.w	r3, [sp, #4]
  ret = ctx->write_reg(ctx->handle, reg, data, len);
 800f26e:	aa01      	add	r2, sp, #4
 800f270:	2301      	movs	r3, #1
 800f272:	2112      	movs	r1, #18
 800f274:	47b0      	blx	r6
    ret = lsm6dsl_write_reg(ctx, LSM6DSL_CTRL3_C, (uint8_t*)&ctrl3_c, 1);
  }
  return ret;
}
 800f276:	b002      	add	sp, #8
 800f278:	bd70      	pop	{r4, r5, r6, pc}
 800f27a:	bf00      	nop

0800f27c <lsm6dsl_fifo_mode_set>:
  * @param  val    Change the values of fifo_mode in reg FIFO_CTRL5
  * @retval        Interface status (MANDATORY: return 0 -> no Error).
  *
  */
int32_t lsm6dsl_fifo_mode_set(lsm6dsl_ctx_t *ctx, lsm6dsl_fifo_mode_t val)
{
 800f27c:	b570      	push	{r4, r5, r6, lr}
 800f27e:	4604      	mov	r4, r0
 800f280:	b082      	sub	sp, #8
 800f282:	460d      	mov	r5, r1
  ret = ctx->read_reg(ctx->handle, reg, data, len);
 800f284:	6880      	ldr	r0, [r0, #8]
 800f286:	6866      	ldr	r6, [r4, #4]
 800f288:	2301      	movs	r3, #1
 800f28a:	aa01      	add	r2, sp, #4
 800f28c:	210a      	movs	r1, #10
 800f28e:	47b0      	blx	r6
  lsm6dsl_fifo_ctrl5_t fifo_ctrl5;
  int32_t ret;

  ret = lsm6dsl_read_reg(ctx, LSM6DSL_FIFO_CTRL5, (uint8_t*)&fifo_ctrl5, 1);
  if(ret == 0){
 800f290:	b958      	cbnz	r0, 800f2aa <lsm6dsl_fifo_mode_set+0x2e>
    fifo_ctrl5.fifo_mode = (uint8_t)val;
 800f292:	f89d 3004 	ldrb.w	r3, [sp, #4]
  ret = ctx->write_reg(ctx->handle, reg, data, len);
 800f296:	6826      	ldr	r6, [r4, #0]
 800f298:	68a0      	ldr	r0, [r4, #8]
    fifo_ctrl5.fifo_mode = (uint8_t)val;
 800f29a:	f365 0302 	bfi	r3, r5, #0, #3
 800f29e:	f88d 3004 	strb.w	r3, [sp, #4]
  ret = ctx->write_reg(ctx->handle, reg, data, len);
 800f2a2:	aa01      	add	r2, sp, #4
 800f2a4:	2301      	movs	r3, #1
 800f2a6:	210a      	movs	r1, #10
 800f2a8:	47b0      	blx	r6
    ret = lsm6dsl_write_reg(ctx, LSM6DSL_FIFO_CTRL5, (uint8_t*)&fifo_ctrl5, 1);
  }
  return ret;
}
 800f2aa:	b002      	add	sp, #8
 800f2ac:	bd70      	pop	{r4, r5, r6, pc}
 800f2ae:	bf00      	nop

0800f2b0 <MX25R6435F_GetFlashInfo>:
  * @brief  Get Flash information
  * @param  pInfo pointer to information structure
  * @retval error status
  */
int32_t MX25R6435F_GetFlashInfo(MX25R6435F_Info_t *pInfo)
{
 800f2b0:	b410      	push	{r4}
  /* Configure the structure with the memory configuration */
  pInfo->FlashSize              = MX25R6435F_FLASH_SIZE;
  pInfo->EraseBlockSize         = MX25R6435F_BLOCK_64K;
 800f2b2:	f44f 3180 	mov.w	r1, #65536	; 0x10000
 800f2b6:	f44f 0400 	mov.w	r4, #8388608	; 0x800000
 800f2ba:	e9c0 4100 	strd	r4, r1, [r0]
  pInfo->EraseBlocksNumber      = (MX25R6435F_FLASH_SIZE/MX25R6435F_BLOCK_64K);
  pInfo->EraseSubBlockSize      = MX25R6435F_BLOCK_32K;
  pInfo->EraseSubBlocksNumber   = (MX25R6435F_FLASH_SIZE/MX25R6435F_BLOCK_32K);
 800f2be:	f44f 7280 	mov.w	r2, #256	; 0x100
  pInfo->EraseSectorSize        = MX25R6435F_SECTOR_4K;
 800f2c2:	f44f 5180 	mov.w	r1, #4096	; 0x1000
 800f2c6:	e9c0 2104 	strd	r2, r1, [r0, #16]
  pInfo->EraseSubBlockSize      = MX25R6435F_BLOCK_32K;
 800f2ca:	f44f 4300 	mov.w	r3, #32768	; 0x8000
  pInfo->EraseBlocksNumber      = (MX25R6435F_FLASH_SIZE/MX25R6435F_BLOCK_64K);
 800f2ce:	2480      	movs	r4, #128	; 0x80
  pInfo->EraseSectorsNumber     = (MX25R6435F_FLASH_SIZE/MX25R6435F_SECTOR_4K);
 800f2d0:	f44f 6100 	mov.w	r1, #2048	; 0x800
  pInfo->EraseSubBlockSize      = MX25R6435F_BLOCK_32K;
 800f2d4:	e9c0 4302 	strd	r4, r3, [r0, #8]
  pInfo->ProgPageSize           = MX25R6435F_PAGE_SIZE;
 800f2d8:	e9c0 1206 	strd	r1, r2, [r0, #24]
  pInfo->ProgPagesNumber        = (MX25R6435F_FLASH_SIZE/MX25R6435F_PAGE_SIZE);
 800f2dc:	6203      	str	r3, [r0, #32]

  return MX25R6435F_OK;
};
 800f2de:	f85d 4b04 	ldr.w	r4, [sp], #4
 800f2e2:	2000      	movs	r0, #0
 800f2e4:	4770      	bx	lr
 800f2e6:	bf00      	nop

0800f2e8 <MX25R6435F_AutoPollingMemReady>:
  * @param  Mode Interface mode
  * @param  Rate Transfer rate
  * @retval error status
  */
int32_t MX25R6435F_AutoPollingMemReady(QSPI_HandleTypeDef *Ctx)
{
 800f2e8:	b510      	push	{r4, lr}
 800f2ea:	b094      	sub	sp, #80	; 0x50
  QSPI_CommandTypeDef     s_command;
  QSPI_AutoPollingTypeDef s_config;

  /* Configure automatic polling mode to wait for memory ready */
  s_command.InstructionMode    = QSPI_INSTRUCTION_1_LINE;
  s_command.Instruction        = MX25R6435F_READ_STATUS_REG_CMD;
 800f2ec:	2205      	movs	r2, #5
 800f2ee:	9206      	str	r2, [sp, #24]
  s_command.InstructionMode    = QSPI_INSTRUCTION_1_LINE;
 800f2f0:	f44f 7180 	mov.w	r1, #256	; 0x100
  s_command.AddressMode        = QSPI_ADDRESS_NONE;
  s_command.AlternateByteMode  = QSPI_ALTERNATE_BYTES_NONE;
  s_command.DataMode           = QSPI_DATA_1_LINE;
 800f2f4:	f04f 7280 	mov.w	r2, #16777216	; 0x1000000
  s_command.AddressMode        = QSPI_ADDRESS_NONE;
 800f2f8:	2300      	movs	r3, #0
  s_command.DdrHoldHalfCycle   = QSPI_DDR_HHC_ANALOG_DELAY;
#endif
  s_command.SIOOMode           = QSPI_SIOO_INST_EVERY_CMD;

  s_config.Match           = 0U;
  s_config.Mask            = MX25R6435F_SR_WIP;
 800f2fa:	2401      	movs	r4, #1
  s_command.InstructionMode    = QSPI_INSTRUCTION_1_LINE;
 800f2fc:	910c      	str	r1, [sp, #48]	; 0x30
  s_command.DataMode           = QSPI_DATA_1_LINE;
 800f2fe:	920f      	str	r2, [sp, #60]	; 0x3c
  s_config.MatchMode       = QSPI_MATCH_MODE_AND;
  s_config.Interval        = MX25R6435F_AUTOPOLLING_INTERVAL_TIME;
 800f300:	2110      	movs	r1, #16
  s_config.AutomaticStop   = QSPI_AUTOMATIC_STOP_ENABLE;
 800f302:	f44f 0280 	mov.w	r2, #4194304	; 0x400000
  s_command.AlternateByteMode  = QSPI_ALTERNATE_BYTES_NONE;
 800f306:	e9cd 330d 	strd	r3, r3, [sp, #52]	; 0x34
  s_command.DdrHoldHalfCycle   = QSPI_DDR_HHC_ANALOG_DELAY;
 800f30a:	e9cd 3311 	strd	r3, r3, [sp, #68]	; 0x44
  s_config.Mask            = MX25R6435F_SR_WIP;
 800f30e:	e9cd 3400 	strd	r3, r4, [sp]
  s_command.DummyCycles        = 0U;
 800f312:	930b      	str	r3, [sp, #44]	; 0x2c
  s_command.SIOOMode           = QSPI_SIOO_INST_EVERY_CMD;
 800f314:	9313      	str	r3, [sp, #76]	; 0x4c
  s_config.MatchMode       = QSPI_MATCH_MODE_AND;
 800f316:	9304      	str	r3, [sp, #16]
  s_config.Interval        = MX25R6435F_AUTOPOLLING_INTERVAL_TIME;
 800f318:	9102      	str	r1, [sp, #8]
  s_config.AutomaticStop   = QSPI_AUTOMATIC_STOP_ENABLE;
 800f31a:	9205      	str	r2, [sp, #20]
  s_config.StatusBytesSize = 1;

  if (HAL_QSPI_AutoPolling(Ctx, &s_command, &s_config, HAL_QPSI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
 800f31c:	f241 3388 	movw	r3, #5000	; 0x1388
 800f320:	466a      	mov	r2, sp
 800f322:	a906      	add	r1, sp, #24
  s_config.StatusBytesSize = 1;
 800f324:	9403      	str	r4, [sp, #12]
  if (HAL_QSPI_AutoPolling(Ctx, &s_command, &s_config, HAL_QPSI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
 800f326:	f002 ff61 	bl	80121ec <HAL_QSPI_AutoPolling>
 800f32a:	3800      	subs	r0, #0
 800f32c:	bf18      	it	ne
 800f32e:	2001      	movne	r0, #1
  {
    return MX25R6435F_ERROR;
  }

  return MX25R6435F_OK;
}
 800f330:	4240      	negs	r0, r0
 800f332:	b014      	add	sp, #80	; 0x50
 800f334:	bd10      	pop	{r4, pc}
 800f336:	bf00      	nop

0800f338 <MX25R6435F_Read>:
  * @param  ReadAddr Read start address
  * @param  Size Size of data to read
  * @retval QSPI memory status
  */
int32_t MX25R6435F_Read(QSPI_HandleTypeDef *Ctx, MX25R6435F_Interface_t Mode, uint8_t *pData, uint32_t ReadAddr, uint32_t Size)
{
 800f338:	b530      	push	{r4, r5, lr}
 800f33a:	b08f      	sub	sp, #60	; 0x3c
 800f33c:	4615      	mov	r5, r2
 800f33e:	9c12      	ldr	r4, [sp, #72]	; 0x48
  QSPI_CommandTypeDef s_command;

  /* Initialize the read command */
  s_command.InstructionMode    = QSPI_INSTRUCTION_1_LINE;
  s_command.AddressSize        = QSPI_ADDRESS_24_BITS;
  s_command.Address            = ReadAddr;
 800f340:	9301      	str	r3, [sp, #4]
  s_command.AlternateByteMode  = QSPI_ALTERNATE_BYTES_NONE;
 800f342:	2300      	movs	r3, #0
  s_command.NbData             = Size;
  s_command.DdrMode            = QSPI_DDR_MODE_DISABLE;
#if defined(QUADSPI_CCR_DHHC) || defined(QSPI_DDR_HHC_ANALOG_DELAY)
  s_command.DdrHoldHalfCycle   = QSPI_DDR_HHC_ANALOG_DELAY;
 800f344:	e9cd 330b 	strd	r3, r3, [sp, #44]	; 0x2c
  s_command.NbData             = Size;
 800f348:	940a      	str	r4, [sp, #40]	; 0x28
  s_command.AlternateByteMode  = QSPI_ALTERNATE_BYTES_NONE;
 800f34a:	9308      	str	r3, [sp, #32]
{
 800f34c:	4604      	mov	r4, r0
#endif
  s_command.SIOOMode           = QSPI_SIOO_INST_EVERY_CMD;
 800f34e:	930d      	str	r3, [sp, #52]	; 0x34
  s_command.InstructionMode    = QSPI_INSTRUCTION_1_LINE;
 800f350:	f44f 7080 	mov.w	r0, #256	; 0x100
  s_command.AddressSize        = QSPI_ADDRESS_24_BITS;
 800f354:	f44f 5300 	mov.w	r3, #8192	; 0x2000
  s_command.InstructionMode    = QSPI_INSTRUCTION_1_LINE;
 800f358:	9006      	str	r0, [sp, #24]
  s_command.AddressSize        = QSPI_ADDRESS_24_BITS;
 800f35a:	9303      	str	r3, [sp, #12]
  
  switch(Mode)
 800f35c:	2904      	cmp	r1, #4
 800f35e:	d843      	bhi.n	800f3e8 <MX25R6435F_Read+0xb0>
 800f360:	e8df f001 	tbb	[pc, r1]
 800f364:	3c312b20 	.word	0x3c312b20
 800f368:	03          	.byte	0x03
 800f369:	00          	.byte	0x00
    s_command.DummyCycles = DUMMY_CYCLES_READ;
    break;
    
  case MX25R6435F_QUAD_IO_MODE :
    s_command.Instruction = MX25R6435F_QUAD_INOUT_READ_CMD;
    s_command.AddressMode = QSPI_ADDRESS_4_LINES;
 800f36a:	f44f 6340 	mov.w	r3, #3072	; 0xc00
    s_command.Instruction = MX25R6435F_QUAD_INOUT_READ_CMD;
 800f36e:	21eb      	movs	r1, #235	; 0xeb
    s_command.DataMode    = QSPI_DATA_4_LINES;
 800f370:	f04f 7240 	mov.w	r2, #50331648	; 0x3000000
    s_command.AddressMode = QSPI_ADDRESS_4_LINES;
 800f374:	9307      	str	r3, [sp, #28]
    s_command.DummyCycles = DUMMY_CYCLES_READ_QUAD;
 800f376:	2306      	movs	r3, #6
    s_command.Instruction = MX25R6435F_QUAD_INOUT_READ_CMD;
 800f378:	9100      	str	r1, [sp, #0]
    s_command.DataMode    = QSPI_DATA_4_LINES;
 800f37a:	9209      	str	r2, [sp, #36]	; 0x24
    s_command.DummyCycles = DUMMY_CYCLES_READ_QUAD;
 800f37c:	9305      	str	r3, [sp, #20]
  default :
    return MX25R6435F_ERROR;	  
  }
  
  /* Send the command */
  if (HAL_QSPI_Command(Ctx, &s_command, HAL_QPSI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
 800f37e:	f241 3288 	movw	r2, #5000	; 0x1388
 800f382:	4669      	mov	r1, sp
 800f384:	4620      	mov	r0, r4
 800f386:	f002 fecf 	bl	8012128 <HAL_QSPI_Command>
 800f38a:	bb68      	cbnz	r0, 800f3e8 <MX25R6435F_Read+0xb0>
  {
    return MX25R6435F_ERROR;
  }

  /* Reception of the data */
  if (HAL_QSPI_Receive(Ctx, pData, HAL_QPSI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
 800f38c:	f241 3288 	movw	r2, #5000	; 0x1388
 800f390:	4629      	mov	r1, r5
 800f392:	4620      	mov	r0, r4
 800f394:	f003 f86c 	bl	8012470 <HAL_QSPI_Receive>
 800f398:	3800      	subs	r0, #0
 800f39a:	bf18      	it	ne
 800f39c:	2001      	movne	r0, #1
 800f39e:	4240      	negs	r0, r0
  {
    return MX25R6435F_ERROR;
  }

  return MX25R6435F_OK;
}
 800f3a0:	b00f      	add	sp, #60	; 0x3c
 800f3a2:	bd30      	pop	{r4, r5, pc}
    s_command.Instruction = MX25R6435F_FAST_READ_CMD;
 800f3a4:	210b      	movs	r1, #11
    s_command.AddressMode = QSPI_ADDRESS_1_LINE;
 800f3a6:	f44f 6380 	mov.w	r3, #1024	; 0x400
    s_command.DataMode    = QSPI_DATA_1_LINE;
 800f3aa:	f04f 7280 	mov.w	r2, #16777216	; 0x1000000
    s_command.AddressMode = QSPI_ADDRESS_1_LINE;
 800f3ae:	9307      	str	r3, [sp, #28]
    s_command.DummyCycles = DUMMY_CYCLES_READ;
 800f3b0:	2308      	movs	r3, #8
    s_command.Instruction = MX25R6435F_DUAL_OUT_READ_CMD;
 800f3b2:	9100      	str	r1, [sp, #0]
    s_command.DataMode    = QSPI_DATA_2_LINES;
 800f3b4:	9209      	str	r2, [sp, #36]	; 0x24
    s_command.DummyCycles = DUMMY_CYCLES_READ;
 800f3b6:	9305      	str	r3, [sp, #20]
    break;
 800f3b8:	e7e1      	b.n	800f37e <MX25R6435F_Read+0x46>
    s_command.Instruction = MX25R6435F_DUAL_OUT_READ_CMD;
 800f3ba:	213b      	movs	r1, #59	; 0x3b
    s_command.AddressMode = QSPI_ADDRESS_1_LINE;
 800f3bc:	f44f 6380 	mov.w	r3, #1024	; 0x400
    s_command.DataMode    = QSPI_DATA_2_LINES;
 800f3c0:	f04f 7200 	mov.w	r2, #33554432	; 0x2000000
 800f3c4:	e7f3      	b.n	800f3ae <MX25R6435F_Read+0x76>
    s_command.AddressMode = QSPI_ADDRESS_2_LINES;
 800f3c6:	f44f 6300 	mov.w	r3, #2048	; 0x800
    s_command.Instruction = MX25R6435F_DUAL_INOUT_READ_CMD;
 800f3ca:	21bb      	movs	r1, #187	; 0xbb
    s_command.DataMode    = QSPI_DATA_2_LINES;
 800f3cc:	f04f 7200 	mov.w	r2, #33554432	; 0x2000000
    s_command.AddressMode = QSPI_ADDRESS_2_LINES;
 800f3d0:	9307      	str	r3, [sp, #28]
    s_command.DummyCycles = DUMMY_CYCLES_READ_DUAL;
 800f3d2:	2304      	movs	r3, #4
    s_command.Instruction = MX25R6435F_DUAL_INOUT_READ_CMD;
 800f3d4:	9100      	str	r1, [sp, #0]
    s_command.DataMode    = QSPI_DATA_2_LINES;
 800f3d6:	9209      	str	r2, [sp, #36]	; 0x24
    s_command.DummyCycles = DUMMY_CYCLES_READ_DUAL;
 800f3d8:	9305      	str	r3, [sp, #20]
    break;
 800f3da:	e7d0      	b.n	800f37e <MX25R6435F_Read+0x46>
    s_command.Instruction = MX25R6435F_QUAD_OUT_READ_CMD;
 800f3dc:	216b      	movs	r1, #107	; 0x6b
    s_command.AddressMode = QSPI_ADDRESS_1_LINE;
 800f3de:	f44f 6380 	mov.w	r3, #1024	; 0x400
    s_command.DataMode    = QSPI_DATA_4_LINES;
 800f3e2:	f04f 7240 	mov.w	r2, #50331648	; 0x3000000
 800f3e6:	e7e2      	b.n	800f3ae <MX25R6435F_Read+0x76>
    return MX25R6435F_ERROR;
 800f3e8:	f04f 30ff 	mov.w	r0, #4294967295
 800f3ec:	e7d8      	b.n	800f3a0 <MX25R6435F_Read+0x68>
 800f3ee:	bf00      	nop

0800f3f0 <MX25R6435F_PageProgram>:
  * @note   Address size is forced to 3 Bytes when the 4 Bytes address size
  *         command is not available for the specified interface mode
  * @retval QSPI memory status
  */
int32_t MX25R6435F_PageProgram(QSPI_HandleTypeDef *Ctx, MX25R6435F_Interface_t Mode, uint8_t *pData, uint32_t WriteAddr, uint32_t Size)
{
 800f3f0:	b530      	push	{r4, r5, lr}
 800f3f2:	b08f      	sub	sp, #60	; 0x3c
 800f3f4:	4615      	mov	r5, r2
  QSPI_CommandTypeDef s_command;

  /* Initialize the program command */
  s_command.InstructionMode    = QSPI_INSTRUCTION_1_LINE;
  s_command.AddressSize        = QSPI_ADDRESS_24_BITS;
  s_command.Address            = WriteAddr;
 800f3f6:	9301      	str	r3, [sp, #4]
  s_command.AlternateByteMode  = QSPI_ALTERNATE_BYTES_NONE;
 800f3f8:	2300      	movs	r3, #0
  s_command.NbData             = Size;
  s_command.DummyCycles        = 0U;
  s_command.DdrMode            = QSPI_DDR_MODE_DISABLE;
#if defined(QUADSPI_CCR_DHHC) || defined(QSPI_DDR_HHC_ANALOG_DELAY)
  s_command.DdrHoldHalfCycle   = QSPI_DDR_HHC_ANALOG_DELAY;
 800f3fa:	e9cd 330b 	strd	r3, r3, [sp, #44]	; 0x2c
  s_command.AlternateByteMode  = QSPI_ALTERNATE_BYTES_NONE;
 800f3fe:	9308      	str	r3, [sp, #32]
  s_command.DummyCycles        = 0U;
 800f400:	9305      	str	r3, [sp, #20]
#endif
  s_command.SIOOMode           = QSPI_SIOO_INST_EVERY_CMD;
 800f402:	930d      	str	r3, [sp, #52]	; 0x34
  s_command.InstructionMode    = QSPI_INSTRUCTION_1_LINE;
 800f404:	f44f 7380 	mov.w	r3, #256	; 0x100
{
 800f408:	9c12      	ldr	r4, [sp, #72]	; 0x48
  s_command.InstructionMode    = QSPI_INSTRUCTION_1_LINE;
 800f40a:	9306      	str	r3, [sp, #24]
  s_command.AddressSize        = QSPI_ADDRESS_24_BITS;
 800f40c:	f44f 5300 	mov.w	r3, #8192	; 0x2000
  s_command.NbData             = Size;
 800f410:	940a      	str	r4, [sp, #40]	; 0x28
  s_command.AddressSize        = QSPI_ADDRESS_24_BITS;
 800f412:	9303      	str	r3, [sp, #12]
{
 800f414:	4604      	mov	r4, r0
  
  switch(Mode)
 800f416:	b301      	cbz	r1, 800f45a <MX25R6435F_PageProgram+0x6a>
 800f418:	2904      	cmp	r1, #4
 800f41a:	d11a      	bne.n	800f452 <MX25R6435F_PageProgram+0x62>
    s_command.AddressMode = QSPI_ADDRESS_1_LINE;
    s_command.DataMode    = QSPI_DATA_1_LINE;
    break;
    
  case MX25R6435F_QUAD_IO_MODE :
    s_command.Instruction = MX25R6435F_QUAD_PAGE_PROG_CMD;
 800f41c:	2138      	movs	r1, #56	; 0x38
    s_command.AddressMode = QSPI_ADDRESS_4_LINES;
 800f41e:	f44f 6240 	mov.w	r2, #3072	; 0xc00
    s_command.DataMode    = QSPI_DATA_4_LINES;
 800f422:	f04f 7340 	mov.w	r3, #50331648	; 0x3000000
    s_command.Instruction = MX25R6435F_QUAD_PAGE_PROG_CMD;
 800f426:	9100      	str	r1, [sp, #0]
    s_command.AddressMode = QSPI_ADDRESS_4_LINES;
 800f428:	9207      	str	r2, [sp, #28]
    s_command.DataMode    = QSPI_DATA_4_LINES;
 800f42a:	9309      	str	r3, [sp, #36]	; 0x24
  default :
    return MX25R6435F_ERROR;	  
  }
  
  /* Configure the command */
  if (HAL_QSPI_Command(Ctx, &s_command, HAL_QPSI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
 800f42c:	f241 3288 	movw	r2, #5000	; 0x1388
 800f430:	4669      	mov	r1, sp
 800f432:	4620      	mov	r0, r4
 800f434:	f002 fe78 	bl	8012128 <HAL_QSPI_Command>
 800f438:	b958      	cbnz	r0, 800f452 <MX25R6435F_PageProgram+0x62>
  {
    return MX25R6435F_ERROR;
  }

  /* Transmission of the data */
  if (HAL_QSPI_Transmit(Ctx, pData, HAL_QPSI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
 800f43a:	f241 3288 	movw	r2, #5000	; 0x1388
 800f43e:	4629      	mov	r1, r5
 800f440:	4620      	mov	r0, r4
 800f442:	f002 ff99 	bl	8012378 <HAL_QSPI_Transmit>
 800f446:	3800      	subs	r0, #0
 800f448:	bf18      	it	ne
 800f44a:	2001      	movne	r0, #1
 800f44c:	4240      	negs	r0, r0
  {
    return MX25R6435F_ERROR;
  }

  return MX25R6435F_OK;
}
 800f44e:	b00f      	add	sp, #60	; 0x3c
 800f450:	bd30      	pop	{r4, r5, pc}
    return MX25R6435F_ERROR;
 800f452:	f04f 30ff 	mov.w	r0, #4294967295
}
 800f456:	b00f      	add	sp, #60	; 0x3c
 800f458:	bd30      	pop	{r4, r5, pc}
    s_command.Instruction = MX25R6435F_PAGE_PROG_CMD;
 800f45a:	2102      	movs	r1, #2
    s_command.AddressMode = QSPI_ADDRESS_1_LINE;
 800f45c:	f44f 6280 	mov.w	r2, #1024	; 0x400
    s_command.DataMode    = QSPI_DATA_1_LINE;
 800f460:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
    s_command.Instruction = MX25R6435F_PAGE_PROG_CMD;
 800f464:	9100      	str	r1, [sp, #0]
    s_command.AddressMode = QSPI_ADDRESS_1_LINE;
 800f466:	9207      	str	r2, [sp, #28]
    s_command.DataMode    = QSPI_DATA_1_LINE;
 800f468:	9309      	str	r3, [sp, #36]	; 0x24
    break;
 800f46a:	e7df      	b.n	800f42c <MX25R6435F_PageProgram+0x3c>

0800f46c <MX25R6435F_BlockErase>:
  * @param  BlockAddress Block address to erase
  * @param  BlockSize Block size to erase
  * @retval QSPI memory status
  */
int32_t MX25R6435F_BlockErase(QSPI_HandleTypeDef *Ctx, uint32_t BlockAddress, MX25R6435F_Erase_t BlockSize)
{
 800f46c:	b510      	push	{r4, lr}
  QSPI_CommandTypeDef s_command;

  /* Initialize the erase command */
  s_command.InstructionMode    = QSPI_INSTRUCTION_1_LINE;
  s_command.AddressMode        = QSPI_ADDRESS_1_LINE;
 800f46e:	f44f 7c80 	mov.w	ip, #256	; 0x100
{
 800f472:	b08e      	sub	sp, #56	; 0x38
  s_command.AddressMode        = QSPI_ADDRESS_1_LINE;
 800f474:	f44f 6480 	mov.w	r4, #1024	; 0x400
  s_command.AddressSize        = QSPI_ADDRESS_24_BITS;
  s_command.Address            = BlockAddress;
  s_command.AlternateByteMode  = QSPI_ALTERNATE_BYTES_NONE;
 800f478:	2300      	movs	r3, #0
  s_command.AddressMode        = QSPI_ADDRESS_1_LINE;
 800f47a:	e9cd c406 	strd	ip, r4, [sp, #24]
#if defined(QUADSPI_CCR_DHHC) || defined(QSPI_DDR_HHC_ANALOG_DELAY)
  s_command.DdrHoldHalfCycle   = QSPI_DDR_HHC_ANALOG_DELAY;
#endif
  s_command.SIOOMode           = QSPI_SIOO_INST_EVERY_CMD;
  
  switch(BlockSize)
 800f47e:	2a01      	cmp	r2, #1
  s_command.AddressSize        = QSPI_ADDRESS_24_BITS;
 800f480:	f44f 5400 	mov.w	r4, #8192	; 0x2000
  s_command.DataMode           = QSPI_DATA_NONE;
 800f484:	e9cd 3308 	strd	r3, r3, [sp, #32]
  s_command.DdrHoldHalfCycle   = QSPI_DDR_HHC_ANALOG_DELAY;
 800f488:	e9cd 330b 	strd	r3, r3, [sp, #44]	; 0x2c
  s_command.AddressSize        = QSPI_ADDRESS_24_BITS;
 800f48c:	9403      	str	r4, [sp, #12]
  s_command.Address            = BlockAddress;
 800f48e:	9101      	str	r1, [sp, #4]
  s_command.DummyCycles        = 0U;
 800f490:	9305      	str	r3, [sp, #20]
  s_command.SIOOMode           = QSPI_SIOO_INST_EVERY_CMD;
 800f492:	930d      	str	r3, [sp, #52]	; 0x34
  switch(BlockSize)
 800f494:	d006      	beq.n	800f4a4 <MX25R6435F_BlockErase+0x38>
 800f496:	2a02      	cmp	r2, #2
 800f498:	d014      	beq.n	800f4c4 <MX25R6435F_BlockErase+0x58>
 800f49a:	b182      	cbz	r2, 800f4be <MX25R6435F_BlockErase+0x52>
 800f49c:	f04f 30ff 	mov.w	r0, #4294967295
  {
    return MX25R6435F_ERROR;
  }

  return MX25R6435F_OK;
}
 800f4a0:	b00e      	add	sp, #56	; 0x38
 800f4a2:	bd10      	pop	{r4, pc}
    s_command.Instruction = MX25R6435F_SUBBLOCK_ERASE_CMD;
 800f4a4:	2352      	movs	r3, #82	; 0x52
 800f4a6:	9300      	str	r3, [sp, #0]
  if(HAL_QSPI_Command(Ctx, &s_command, HAL_QPSI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
 800f4a8:	f241 3288 	movw	r2, #5000	; 0x1388
 800f4ac:	4669      	mov	r1, sp
 800f4ae:	f002 fe3b 	bl	8012128 <HAL_QSPI_Command>
 800f4b2:	3800      	subs	r0, #0
 800f4b4:	bf18      	it	ne
 800f4b6:	2001      	movne	r0, #1
 800f4b8:	4240      	negs	r0, r0
}
 800f4ba:	b00e      	add	sp, #56	; 0x38
 800f4bc:	bd10      	pop	{r4, pc}
    s_command.Instruction = MX25R6435F_SECTOR_ERASE_CMD;
 800f4be:	2320      	movs	r3, #32
 800f4c0:	9300      	str	r3, [sp, #0]
    break;
 800f4c2:	e7f1      	b.n	800f4a8 <MX25R6435F_BlockErase+0x3c>
    s_command.Instruction = MX25R6435F_BLOCK_ERASE_CMD;
 800f4c4:	23d8      	movs	r3, #216	; 0xd8
 800f4c6:	9300      	str	r3, [sp, #0]
    break;
 800f4c8:	e7ee      	b.n	800f4a8 <MX25R6435F_BlockErase+0x3c>
 800f4ca:	bf00      	nop

0800f4cc <MX25R6435F_WriteEnable>:
  * @brief  This function send a Write Enable and wait it is effective.
  * @param  Ctx Component object pointer
  * @retval error status
  */
int32_t MX25R6435F_WriteEnable(QSPI_HandleTypeDef *Ctx)
{
 800f4cc:	b530      	push	{r4, r5, lr}
 800f4ce:	b095      	sub	sp, #84	; 0x54
  QSPI_CommandTypeDef     s_command;
  QSPI_AutoPollingTypeDef s_config;

  /* Initialize the write enable command */
  s_command.InstructionMode    = QSPI_INSTRUCTION_1_LINE;
 800f4d0:	f44f 7280 	mov.w	r2, #256	; 0x100
 800f4d4:	920c      	str	r2, [sp, #48]	; 0x30
  s_command.Instruction        = MX25R6435F_WRITE_ENABLE_CMD;
 800f4d6:	2206      	movs	r2, #6
  s_command.AddressMode        = QSPI_ADDRESS_NONE;
 800f4d8:	2300      	movs	r3, #0
  s_command.Instruction        = MX25R6435F_WRITE_ENABLE_CMD;
 800f4da:	9206      	str	r2, [sp, #24]
  s_command.DdrHoldHalfCycle   = QSPI_DDR_HHC_ANALOG_DELAY;
#endif
  s_command.SIOOMode           = QSPI_SIOO_INST_EVERY_CMD;

  /* Send the command */
  if (HAL_QSPI_Command(Ctx, &s_command, HAL_QPSI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
 800f4dc:	a906      	add	r1, sp, #24
 800f4de:	f241 3288 	movw	r2, #5000	; 0x1388
  s_command.AlternateByteMode  = QSPI_ALTERNATE_BYTES_NONE;
 800f4e2:	e9cd 330d 	strd	r3, r3, [sp, #52]	; 0x34
  s_command.DdrHoldHalfCycle   = QSPI_DDR_HHC_ANALOG_DELAY;
 800f4e6:	e9cd 3311 	strd	r3, r3, [sp, #68]	; 0x44
{
 800f4ea:	4604      	mov	r4, r0
  s_command.DataMode           = QSPI_DATA_NONE;
 800f4ec:	930f      	str	r3, [sp, #60]	; 0x3c
  s_command.DummyCycles        = 0U;
 800f4ee:	930b      	str	r3, [sp, #44]	; 0x2c
  s_command.SIOOMode           = QSPI_SIOO_INST_EVERY_CMD;
 800f4f0:	9313      	str	r3, [sp, #76]	; 0x4c
  if (HAL_QSPI_Command(Ctx, &s_command, HAL_QPSI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
 800f4f2:	f002 fe19 	bl	8012128 <HAL_QSPI_Command>
 800f4f6:	b9e8      	cbnz	r0, 800f534 <MX25R6435F_WriteEnable+0x68>
  {
    return MX25R6435F_ERROR;
  }

  /* Configure automatic polling mode to wait for write enabling */
  s_command.Instruction = MX25R6435F_READ_STATUS_REG_CMD;
 800f4f8:	4603      	mov	r3, r0
  s_command.DataMode    = QSPI_DATA_1_LINE;

  s_config.Match           = MX25R6435F_SR_WEL;
 800f4fa:	2202      	movs	r2, #2
  s_command.Instruction = MX25R6435F_READ_STATUS_REG_CMD;
 800f4fc:	2505      	movs	r5, #5
  s_config.MatchMode       = QSPI_MATCH_MODE_AND;
  s_config.Interval        = MX25R6435F_AUTOPOLLING_INTERVAL_TIME;
  s_config.AutomaticStop   = QSPI_AUTOMATIC_STOP_ENABLE;
  s_config.StatusBytesSize = 1;

  if (HAL_QSPI_AutoPolling(Ctx, &s_command, &s_config, HAL_QPSI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
 800f4fe:	4620      	mov	r0, r4
  s_config.MatchMode       = QSPI_MATCH_MODE_AND;
 800f500:	9304      	str	r3, [sp, #16]
  s_command.DataMode    = QSPI_DATA_1_LINE;
 800f502:	f04f 7480 	mov.w	r4, #16777216	; 0x1000000
  s_config.AutomaticStop   = QSPI_AUTOMATIC_STOP_ENABLE;
 800f506:	f44f 0380 	mov.w	r3, #4194304	; 0x400000
  s_config.Mask            = MX25R6435F_SR_WEL;
 800f50a:	e9cd 2200 	strd	r2, r2, [sp]
  s_command.Instruction = MX25R6435F_READ_STATUS_REG_CMD;
 800f50e:	9506      	str	r5, [sp, #24]
  s_command.DataMode    = QSPI_DATA_1_LINE;
 800f510:	940f      	str	r4, [sp, #60]	; 0x3c
  s_config.AutomaticStop   = QSPI_AUTOMATIC_STOP_ENABLE;
 800f512:	9305      	str	r3, [sp, #20]
  if (HAL_QSPI_AutoPolling(Ctx, &s_command, &s_config, HAL_QPSI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
 800f514:	a906      	add	r1, sp, #24
  s_config.Interval        = MX25R6435F_AUTOPOLLING_INTERVAL_TIME;
 800f516:	2510      	movs	r5, #16
  s_config.StatusBytesSize = 1;
 800f518:	2401      	movs	r4, #1
  if (HAL_QSPI_AutoPolling(Ctx, &s_command, &s_config, HAL_QPSI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
 800f51a:	f241 3388 	movw	r3, #5000	; 0x1388
 800f51e:	466a      	mov	r2, sp
  s_config.Interval        = MX25R6435F_AUTOPOLLING_INTERVAL_TIME;
 800f520:	9502      	str	r5, [sp, #8]
  s_config.StatusBytesSize = 1;
 800f522:	9403      	str	r4, [sp, #12]
  if (HAL_QSPI_AutoPolling(Ctx, &s_command, &s_config, HAL_QPSI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
 800f524:	f002 fe62 	bl	80121ec <HAL_QSPI_AutoPolling>
 800f528:	3800      	subs	r0, #0
 800f52a:	bf18      	it	ne
 800f52c:	2001      	movne	r0, #1
 800f52e:	4240      	negs	r0, r0
  {
    return MX25R6435F_ERROR;
  }

  return MX25R6435F_OK;
}
 800f530:	b015      	add	sp, #84	; 0x54
 800f532:	bd30      	pop	{r4, r5, pc}
    return MX25R6435F_ERROR;
 800f534:	f04f 30ff 	mov.w	r0, #4294967295
 800f538:	e7fa      	b.n	800f530 <MX25R6435F_WriteEnable+0x64>
 800f53a:	bf00      	nop

0800f53c <MX25R6435F_ReadStatusRegister>:
  * @param  Ctx Component object pointer
  * @param  Value Status register value pointer
  * @retval error status
  */
int32_t MX25R6435F_ReadStatusRegister(QSPI_HandleTypeDef *Ctx, uint8_t *Value)
{
 800f53c:	b530      	push	{r4, r5, lr}
 800f53e:	b08f      	sub	sp, #60	; 0x3c
  QSPI_CommandTypeDef s_command;

  /* Initialize the reading of status register */
  s_command.InstructionMode    = QSPI_INSTRUCTION_1_LINE;
 800f540:	f44f 7280 	mov.w	r2, #256	; 0x100
 800f544:	9206      	str	r2, [sp, #24]
  s_command.Instruction        = MX25R6435F_READ_STATUS_REG_CMD;
 800f546:	2205      	movs	r2, #5
 800f548:	9200      	str	r2, [sp, #0]
  s_command.AddressMode        = QSPI_ADDRESS_NONE;
  s_command.AlternateByteMode  = QSPI_ALTERNATE_BYTES_NONE;
  s_command.DataMode           = QSPI_DATA_1_LINE;
 800f54a:	f04f 7280 	mov.w	r2, #16777216	; 0x1000000
 800f54e:	9209      	str	r2, [sp, #36]	; 0x24
  s_command.DummyCycles        = 0U;
  s_command.NbData             = 1U;
 800f550:	2201      	movs	r2, #1
  s_command.AddressMode        = QSPI_ADDRESS_NONE;
 800f552:	2300      	movs	r3, #0
{
 800f554:	460d      	mov	r5, r1
  s_command.NbData             = 1U;
 800f556:	920a      	str	r2, [sp, #40]	; 0x28
  s_command.DdrHoldHalfCycle   = QSPI_DDR_HHC_ANALOG_DELAY;
#endif
  s_command.SIOOMode           = QSPI_SIOO_INST_EVERY_CMD;

  /* Send the command */
  if (HAL_QSPI_Command(Ctx, &s_command, HAL_QPSI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
 800f558:	4669      	mov	r1, sp
 800f55a:	f241 3288 	movw	r2, #5000	; 0x1388
  s_command.AlternateByteMode  = QSPI_ALTERNATE_BYTES_NONE;
 800f55e:	e9cd 3307 	strd	r3, r3, [sp, #28]
  s_command.DdrHoldHalfCycle   = QSPI_DDR_HHC_ANALOG_DELAY;
 800f562:	e9cd 330b 	strd	r3, r3, [sp, #44]	; 0x2c
{
 800f566:	4604      	mov	r4, r0
  s_command.DummyCycles        = 0U;
 800f568:	9305      	str	r3, [sp, #20]
  s_command.SIOOMode           = QSPI_SIOO_INST_EVERY_CMD;
 800f56a:	930d      	str	r3, [sp, #52]	; 0x34
  if (HAL_QSPI_Command(Ctx, &s_command, HAL_QPSI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
 800f56c:	f002 fddc 	bl	8012128 <HAL_QSPI_Command>
 800f570:	b958      	cbnz	r0, 800f58a <MX25R6435F_ReadStatusRegister+0x4e>
  {
    return MX25R6435F_ERROR;
  }

  /* Reception of the data */
  if (HAL_QSPI_Receive(Ctx, Value, HAL_QPSI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
 800f572:	f241 3288 	movw	r2, #5000	; 0x1388
 800f576:	4629      	mov	r1, r5
 800f578:	4620      	mov	r0, r4
 800f57a:	f002 ff79 	bl	8012470 <HAL_QSPI_Receive>
 800f57e:	3800      	subs	r0, #0
 800f580:	bf18      	it	ne
 800f582:	2001      	movne	r0, #1
 800f584:	4240      	negs	r0, r0
  {
    return MX25R6435F_ERROR;
  }

  return MX25R6435F_OK;
}
 800f586:	b00f      	add	sp, #60	; 0x3c
 800f588:	bd30      	pop	{r4, r5, pc}
    return MX25R6435F_ERROR;
 800f58a:	f04f 30ff 	mov.w	r0, #4294967295
 800f58e:	e7fa      	b.n	800f586 <MX25R6435F_ReadStatusRegister+0x4a>

0800f590 <MX25R6435F_ReadCfgRegister>:
  * @param  Ctx Component object pointer
  * @param  Value configuration register value pointer
  * @retval error status
  */
int32_t MX25R6435F_ReadCfgRegister(QSPI_HandleTypeDef *Ctx, uint8_t *Value)
{
 800f590:	b530      	push	{r4, r5, lr}
 800f592:	b091      	sub	sp, #68	; 0x44
  QSPI_CommandTypeDef s_command;
  uint8_t reg[2];

  /* Initialize the reading of configuration register */
  s_command.InstructionMode    = QSPI_INSTRUCTION_1_LINE;
 800f594:	f44f 7280 	mov.w	r2, #256	; 0x100
 800f598:	9208      	str	r2, [sp, #32]
  s_command.Instruction        = MX25R6435F_READ_CFG_REG_CMD;
 800f59a:	2215      	movs	r2, #21
 800f59c:	9202      	str	r2, [sp, #8]
  s_command.AddressMode        = QSPI_ADDRESS_NONE;
  s_command.AlternateByteMode  = QSPI_ALTERNATE_BYTES_NONE;
  s_command.DataMode           = QSPI_DATA_1_LINE;
 800f59e:	f04f 7280 	mov.w	r2, #16777216	; 0x1000000
 800f5a2:	920b      	str	r2, [sp, #44]	; 0x2c
  s_command.DummyCycles        = 0U;
  s_command.NbData             = 2U;
 800f5a4:	2202      	movs	r2, #2
  s_command.AddressMode        = QSPI_ADDRESS_NONE;
 800f5a6:	2300      	movs	r3, #0
{
 800f5a8:	460d      	mov	r5, r1
  s_command.NbData             = 2U;
 800f5aa:	920c      	str	r2, [sp, #48]	; 0x30
  s_command.DdrHoldHalfCycle   = QSPI_DDR_HHC_ANALOG_DELAY;
#endif
  s_command.SIOOMode           = QSPI_SIOO_INST_EVERY_CMD;

  /* Send the command */
  if (HAL_QSPI_Command(Ctx, &s_command, HAL_QPSI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
 800f5ac:	a902      	add	r1, sp, #8
 800f5ae:	f241 3288 	movw	r2, #5000	; 0x1388
  s_command.AlternateByteMode  = QSPI_ALTERNATE_BYTES_NONE;
 800f5b2:	e9cd 3309 	strd	r3, r3, [sp, #36]	; 0x24
  s_command.DdrHoldHalfCycle   = QSPI_DDR_HHC_ANALOG_DELAY;
 800f5b6:	e9cd 330d 	strd	r3, r3, [sp, #52]	; 0x34
{
 800f5ba:	4604      	mov	r4, r0
  s_command.DummyCycles        = 0U;
 800f5bc:	9307      	str	r3, [sp, #28]
  s_command.SIOOMode           = QSPI_SIOO_INST_EVERY_CMD;
 800f5be:	930f      	str	r3, [sp, #60]	; 0x3c
  if (HAL_QSPI_Command(Ctx, &s_command, HAL_QPSI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
 800f5c0:	f002 fdb2 	bl	8012128 <HAL_QSPI_Command>
 800f5c4:	b958      	cbnz	r0, 800f5de <MX25R6435F_ReadCfgRegister+0x4e>
  {
    return MX25R6435F_ERROR;
  }

  /* Reception of the data */
  if (HAL_QSPI_Receive(Ctx, reg, HAL_QPSI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
 800f5c6:	f241 3288 	movw	r2, #5000	; 0x1388
 800f5ca:	a901      	add	r1, sp, #4
 800f5cc:	4620      	mov	r0, r4
 800f5ce:	f002 ff4f 	bl	8012470 <HAL_QSPI_Receive>
 800f5d2:	b920      	cbnz	r0, 800f5de <MX25R6435F_ReadCfgRegister+0x4e>
  {
    return MX25R6435F_ERROR;
  }
  
  *Value = reg[0];
 800f5d4:	f89d 3004 	ldrb.w	r3, [sp, #4]
 800f5d8:	702b      	strb	r3, [r5, #0]

  return MX25R6435F_OK;
}
 800f5da:	b011      	add	sp, #68	; 0x44
 800f5dc:	bd30      	pop	{r4, r5, pc}
    return MX25R6435F_ERROR;
 800f5de:	f04f 30ff 	mov.w	r0, #4294967295
 800f5e2:	e7fa      	b.n	800f5da <MX25R6435F_ReadCfgRegister+0x4a>

0800f5e4 <MX25R6435F_ReadCfg2Register>:
  * @param  Ctx Component object pointer
  * @param  Value configuration register 2 value pointer
  * @retval error status
  */
int32_t MX25R6435F_ReadCfg2Register(QSPI_HandleTypeDef *Ctx, uint8_t *Value)
{
 800f5e4:	b530      	push	{r4, r5, lr}
 800f5e6:	b091      	sub	sp, #68	; 0x44
  QSPI_CommandTypeDef s_command;
  uint8_t reg[2];

  /* Initialize the reading of status register */
  s_command.InstructionMode    = QSPI_INSTRUCTION_1_LINE;
 800f5e8:	f44f 7280 	mov.w	r2, #256	; 0x100
 800f5ec:	9208      	str	r2, [sp, #32]
  s_command.Instruction        = MX25R6435F_READ_CFG_REG_CMD;
 800f5ee:	2215      	movs	r2, #21
 800f5f0:	9202      	str	r2, [sp, #8]
  s_command.AddressMode        = QSPI_ADDRESS_NONE;
  s_command.AlternateByteMode  = QSPI_ALTERNATE_BYTES_NONE;
  s_command.DataMode           = QSPI_DATA_1_LINE;
 800f5f2:	f04f 7280 	mov.w	r2, #16777216	; 0x1000000
 800f5f6:	920b      	str	r2, [sp, #44]	; 0x2c
  s_command.DummyCycles        = 0U;
  s_command.NbData             = 2U;
 800f5f8:	2202      	movs	r2, #2
  s_command.AddressMode        = QSPI_ADDRESS_NONE;
 800f5fa:	2300      	movs	r3, #0
{
 800f5fc:	460d      	mov	r5, r1
  s_command.NbData             = 2U;
 800f5fe:	920c      	str	r2, [sp, #48]	; 0x30
  s_command.DdrHoldHalfCycle   = QSPI_DDR_HHC_ANALOG_DELAY;
#endif
  s_command.SIOOMode           = QSPI_SIOO_INST_EVERY_CMD;

  /* Send the command */
  if (HAL_QSPI_Command(Ctx, &s_command, HAL_QPSI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
 800f600:	a902      	add	r1, sp, #8
 800f602:	f241 3288 	movw	r2, #5000	; 0x1388
  s_command.AlternateByteMode  = QSPI_ALTERNATE_BYTES_NONE;
 800f606:	e9cd 3309 	strd	r3, r3, [sp, #36]	; 0x24
  s_command.DdrHoldHalfCycle   = QSPI_DDR_HHC_ANALOG_DELAY;
 800f60a:	e9cd 330d 	strd	r3, r3, [sp, #52]	; 0x34
{
 800f60e:	4604      	mov	r4, r0
  s_command.DummyCycles        = 0U;
 800f610:	9307      	str	r3, [sp, #28]
  s_command.SIOOMode           = QSPI_SIOO_INST_EVERY_CMD;
 800f612:	930f      	str	r3, [sp, #60]	; 0x3c
  if (HAL_QSPI_Command(Ctx, &s_command, HAL_QPSI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
 800f614:	f002 fd88 	bl	8012128 <HAL_QSPI_Command>
 800f618:	b958      	cbnz	r0, 800f632 <MX25R6435F_ReadCfg2Register+0x4e>
  {
    return MX25R6435F_ERROR;
  }

  /* Reception of the data */
  if (HAL_QSPI_Receive(Ctx, reg, HAL_QPSI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
 800f61a:	f241 3288 	movw	r2, #5000	; 0x1388
 800f61e:	a901      	add	r1, sp, #4
 800f620:	4620      	mov	r0, r4
 800f622:	f002 ff25 	bl	8012470 <HAL_QSPI_Receive>
 800f626:	b920      	cbnz	r0, 800f632 <MX25R6435F_ReadCfg2Register+0x4e>
  {
    return MX25R6435F_ERROR;
  }

  *Value = reg[1];
 800f628:	f89d 3005 	ldrb.w	r3, [sp, #5]
 800f62c:	702b      	strb	r3, [r5, #0]

  return MX25R6435F_OK;
}
 800f62e:	b011      	add	sp, #68	; 0x44
 800f630:	bd30      	pop	{r4, r5, pc}
    return MX25R6435F_ERROR;
 800f632:	f04f 30ff 	mov.w	r0, #4294967295
 800f636:	e7fa      	b.n	800f62e <MX25R6435F_ReadCfg2Register+0x4a>

0800f638 <MX25R6435F_WriteStatusRegister>:
{
 800f638:	b530      	push	{r4, r5, lr}
 800f63a:	b091      	sub	sp, #68	; 0x44
 800f63c:	460d      	mov	r5, r1
  if (MX25R6435F_ReadCfgRegister(Ctx, &reg[1]) != MX25R6435F_OK)
 800f63e:	f10d 0105 	add.w	r1, sp, #5
{
 800f642:	4604      	mov	r4, r0
  if (MX25R6435F_ReadCfgRegister(Ctx, &reg[1]) != MX25R6435F_OK)
 800f644:	f7ff ffa4 	bl	800f590 <MX25R6435F_ReadCfgRegister>
 800f648:	bb50      	cbnz	r0, 800f6a0 <MX25R6435F_WriteStatusRegister+0x68>
  if (MX25R6435F_ReadCfg2Register(Ctx, &reg[2]) != MX25R6435F_OK)
 800f64a:	f10d 0106 	add.w	r1, sp, #6
 800f64e:	4620      	mov	r0, r4
 800f650:	f7ff ffc8 	bl	800f5e4 <MX25R6435F_ReadCfg2Register>
 800f654:	bb20      	cbnz	r0, 800f6a0 <MX25R6435F_WriteStatusRegister+0x68>
  s_command.InstructionMode    = QSPI_INSTRUCTION_1_LINE;
 800f656:	f44f 7380 	mov.w	r3, #256	; 0x100
 800f65a:	9308      	str	r3, [sp, #32]
  s_command.DataMode           = QSPI_DATA_1_LINE;
 800f65c:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
  s_command.Instruction        = MX25R6435F_WRITE_STATUS_CFG_REG_CMD;
 800f660:	2201      	movs	r2, #1
  s_command.DataMode           = QSPI_DATA_1_LINE;
 800f662:	930b      	str	r3, [sp, #44]	; 0x2c
  s_command.NbData             = 3U;
 800f664:	2303      	movs	r3, #3
  s_command.AlternateByteMode  = QSPI_ALTERNATE_BYTES_NONE;
 800f666:	e9cd 0009 	strd	r0, r0, [sp, #36]	; 0x24
  s_command.DdrMode            = QSPI_DDR_MODE_DISABLE;
 800f66a:	e9cd 300c 	strd	r3, r0, [sp, #48]	; 0x30
  s_command.SIOOMode           = QSPI_SIOO_INST_EVERY_CMD;
 800f66e:	e9cd 000e 	strd	r0, r0, [sp, #56]	; 0x38
  s_command.Instruction        = MX25R6435F_WRITE_STATUS_CFG_REG_CMD;
 800f672:	9202      	str	r2, [sp, #8]
  s_command.DummyCycles        = 0U;
 800f674:	9007      	str	r0, [sp, #28]
  if (HAL_QSPI_Command(Ctx, &s_command, HAL_QPSI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
 800f676:	f241 3288 	movw	r2, #5000	; 0x1388
 800f67a:	a902      	add	r1, sp, #8
 800f67c:	4620      	mov	r0, r4
  reg[0] = Value;
 800f67e:	f88d 5004 	strb.w	r5, [sp, #4]
  if (HAL_QSPI_Command(Ctx, &s_command, HAL_QPSI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
 800f682:	f002 fd51 	bl	8012128 <HAL_QSPI_Command>
 800f686:	b958      	cbnz	r0, 800f6a0 <MX25R6435F_WriteStatusRegister+0x68>
  if (HAL_QSPI_Transmit(Ctx, reg, HAL_QPSI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
 800f688:	f241 3288 	movw	r2, #5000	; 0x1388
 800f68c:	a901      	add	r1, sp, #4
 800f68e:	4620      	mov	r0, r4
 800f690:	f002 fe72 	bl	8012378 <HAL_QSPI_Transmit>
 800f694:	3800      	subs	r0, #0
 800f696:	bf18      	it	ne
 800f698:	2001      	movne	r0, #1
 800f69a:	4240      	negs	r0, r0
}
 800f69c:	b011      	add	sp, #68	; 0x44
 800f69e:	bd30      	pop	{r4, r5, pc}
    return MX25R6435F_ERROR;
 800f6a0:	f04f 30ff 	mov.w	r0, #4294967295
 800f6a4:	e7fa      	b.n	800f69c <MX25R6435F_WriteStatusRegister+0x64>
 800f6a6:	bf00      	nop

0800f6a8 <MX25R6435F_ReadSecurityRegister>:
  * @param  Ctx Component object pointer
  * @param  Value Security register value pointer
  * @retval error status
  */
int32_t MX25R6435F_ReadSecurityRegister(QSPI_HandleTypeDef *Ctx, uint8_t *Value)
{
 800f6a8:	b530      	push	{r4, r5, lr}
 800f6aa:	b08f      	sub	sp, #60	; 0x3c
  QSPI_CommandTypeDef s_command;

  /* Initialize the reading of security register */
  s_command.InstructionMode    = QSPI_INSTRUCTION_1_LINE;
 800f6ac:	f44f 7280 	mov.w	r2, #256	; 0x100
 800f6b0:	9206      	str	r2, [sp, #24]
  s_command.Instruction        = MX25R6435F_READ_SEC_REG_CMD;
 800f6b2:	222b      	movs	r2, #43	; 0x2b
 800f6b4:	9200      	str	r2, [sp, #0]
  s_command.AddressMode        = QSPI_ADDRESS_NONE;
  s_command.AlternateByteMode  = QSPI_ALTERNATE_BYTES_NONE;
  s_command.DataMode           = QSPI_DATA_1_LINE;
 800f6b6:	f04f 7280 	mov.w	r2, #16777216	; 0x1000000
 800f6ba:	9209      	str	r2, [sp, #36]	; 0x24
  s_command.DummyCycles        = 0U;
  s_command.NbData             = 1U;
 800f6bc:	2201      	movs	r2, #1
  s_command.AddressMode        = QSPI_ADDRESS_NONE;
 800f6be:	2300      	movs	r3, #0
{
 800f6c0:	460d      	mov	r5, r1
  s_command.NbData             = 1U;
 800f6c2:	920a      	str	r2, [sp, #40]	; 0x28
  s_command.DdrHoldHalfCycle   = QSPI_DDR_HHC_ANALOG_DELAY;
#endif
  s_command.SIOOMode           = QSPI_SIOO_INST_EVERY_CMD;

  /* Send the command */
  if (HAL_QSPI_Command(Ctx, &s_command, HAL_QPSI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
 800f6c4:	4669      	mov	r1, sp
 800f6c6:	f241 3288 	movw	r2, #5000	; 0x1388
  s_command.AlternateByteMode  = QSPI_ALTERNATE_BYTES_NONE;
 800f6ca:	e9cd 3307 	strd	r3, r3, [sp, #28]
  s_command.DdrHoldHalfCycle   = QSPI_DDR_HHC_ANALOG_DELAY;
 800f6ce:	e9cd 330b 	strd	r3, r3, [sp, #44]	; 0x2c
{
 800f6d2:	4604      	mov	r4, r0
  s_command.DummyCycles        = 0U;
 800f6d4:	9305      	str	r3, [sp, #20]
  s_command.SIOOMode           = QSPI_SIOO_INST_EVERY_CMD;
 800f6d6:	930d      	str	r3, [sp, #52]	; 0x34
  if (HAL_QSPI_Command(Ctx, &s_command, HAL_QPSI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
 800f6d8:	f002 fd26 	bl	8012128 <HAL_QSPI_Command>
 800f6dc:	b958      	cbnz	r0, 800f6f6 <MX25R6435F_ReadSecurityRegister+0x4e>
  {
    return MX25R6435F_ERROR;
  }

  /* Reception of the data */
  if (HAL_QSPI_Receive(Ctx, Value, HAL_QPSI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
 800f6de:	f241 3288 	movw	r2, #5000	; 0x1388
 800f6e2:	4629      	mov	r1, r5
 800f6e4:	4620      	mov	r0, r4
 800f6e6:	f002 fec3 	bl	8012470 <HAL_QSPI_Receive>
 800f6ea:	3800      	subs	r0, #0
 800f6ec:	bf18      	it	ne
 800f6ee:	2001      	movne	r0, #1
 800f6f0:	4240      	negs	r0, r0
  {
    return MX25R6435F_ERROR;
  }

  return MX25R6435F_OK;
}
 800f6f2:	b00f      	add	sp, #60	; 0x3c
 800f6f4:	bd30      	pop	{r4, r5, pc}
    return MX25R6435F_ERROR;
 800f6f6:	f04f 30ff 	mov.w	r0, #4294967295
 800f6fa:	e7fa      	b.n	800f6f2 <MX25R6435F_ReadSecurityRegister+0x4a>

0800f6fc <MX25R6435F_ResetEnable>:
  * @brief  Flash reset enable command
  * @param  Ctx Component object pointer
  * @retval error status
  */
int32_t MX25R6435F_ResetEnable(QSPI_HandleTypeDef *Ctx)
{
 800f6fc:	b510      	push	{r4, lr}
 800f6fe:	b08e      	sub	sp, #56	; 0x38
  QSPI_CommandTypeDef s_command;

  /* Initialize the reset enable command */
  s_command.InstructionMode    = QSPI_INSTRUCTION_1_LINE;
  s_command.Instruction        = MX25R6435F_RESET_ENABLE_CMD;
 800f700:	2166      	movs	r1, #102	; 0x66
  s_command.AddressMode        = QSPI_ADDRESS_NONE;
 800f702:	2300      	movs	r3, #0
  s_command.Instruction        = MX25R6435F_RESET_ENABLE_CMD;
 800f704:	9100      	str	r1, [sp, #0]
  s_command.InstructionMode    = QSPI_INSTRUCTION_1_LINE;
 800f706:	f44f 7480 	mov.w	r4, #256	; 0x100
  s_command.DdrHoldHalfCycle   = QSPI_DDR_HHC_ANALOG_DELAY;
#endif
  s_command.SIOOMode           = QSPI_SIOO_INST_EVERY_CMD;

  /* Send the command */
  if (HAL_QSPI_Command(Ctx, &s_command, HAL_QPSI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
 800f70a:	f241 3288 	movw	r2, #5000	; 0x1388
 800f70e:	4669      	mov	r1, sp
  s_command.AlternateByteMode  = QSPI_ALTERNATE_BYTES_NONE;
 800f710:	e9cd 3307 	strd	r3, r3, [sp, #28]
  s_command.DdrHoldHalfCycle   = QSPI_DDR_HHC_ANALOG_DELAY;
 800f714:	e9cd 330b 	strd	r3, r3, [sp, #44]	; 0x2c
  s_command.InstructionMode    = QSPI_INSTRUCTION_1_LINE;
 800f718:	9406      	str	r4, [sp, #24]
  s_command.DataMode           = QSPI_DATA_NONE;
 800f71a:	9309      	str	r3, [sp, #36]	; 0x24
  s_command.DummyCycles        = 0U;
 800f71c:	9305      	str	r3, [sp, #20]
  s_command.SIOOMode           = QSPI_SIOO_INST_EVERY_CMD;
 800f71e:	930d      	str	r3, [sp, #52]	; 0x34
  if (HAL_QSPI_Command(Ctx, &s_command, HAL_QPSI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
 800f720:	f002 fd02 	bl	8012128 <HAL_QSPI_Command>
 800f724:	3800      	subs	r0, #0
 800f726:	bf18      	it	ne
 800f728:	2001      	movne	r0, #1
  {
    return MX25R6435F_ERROR;
  }

  return MX25R6435F_OK;
}
 800f72a:	4240      	negs	r0, r0
 800f72c:	b00e      	add	sp, #56	; 0x38
 800f72e:	bd10      	pop	{r4, pc}

0800f730 <MX25R6435F_ResetMemory>:
  * @brief  Flash reset memory command
  * @param  Ctx Component object pointer
  * @retval error status
  */
int32_t MX25R6435F_ResetMemory(QSPI_HandleTypeDef *Ctx)
{
 800f730:	b510      	push	{r4, lr}
 800f732:	b08e      	sub	sp, #56	; 0x38
  QSPI_CommandTypeDef s_command;

  /* Initialize the reset command */
  s_command.InstructionMode    = QSPI_INSTRUCTION_1_LINE;
  s_command.Instruction        = MX25R6435F_RESET_MEMORY_CMD;
 800f734:	2199      	movs	r1, #153	; 0x99
  s_command.AddressMode        = QSPI_ADDRESS_NONE;
 800f736:	2300      	movs	r3, #0
  s_command.Instruction        = MX25R6435F_RESET_MEMORY_CMD;
 800f738:	9100      	str	r1, [sp, #0]
  s_command.InstructionMode    = QSPI_INSTRUCTION_1_LINE;
 800f73a:	f44f 7480 	mov.w	r4, #256	; 0x100
  s_command.DdrHoldHalfCycle   = QSPI_DDR_HHC_ANALOG_DELAY;
#endif
  s_command.SIOOMode           = QSPI_SIOO_INST_EVERY_CMD;

  /* Send the command */
  if (HAL_QSPI_Command(Ctx, &s_command, HAL_QPSI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
 800f73e:	f241 3288 	movw	r2, #5000	; 0x1388
 800f742:	4669      	mov	r1, sp
  s_command.AlternateByteMode  = QSPI_ALTERNATE_BYTES_NONE;
 800f744:	e9cd 3307 	strd	r3, r3, [sp, #28]
  s_command.DdrHoldHalfCycle   = QSPI_DDR_HHC_ANALOG_DELAY;
 800f748:	e9cd 330b 	strd	r3, r3, [sp, #44]	; 0x2c
  s_command.InstructionMode    = QSPI_INSTRUCTION_1_LINE;
 800f74c:	9406      	str	r4, [sp, #24]
  s_command.DataMode           = QSPI_DATA_NONE;
 800f74e:	9309      	str	r3, [sp, #36]	; 0x24
  s_command.DummyCycles        = 0U;
 800f750:	9305      	str	r3, [sp, #20]
  s_command.SIOOMode           = QSPI_SIOO_INST_EVERY_CMD;
 800f752:	930d      	str	r3, [sp, #52]	; 0x34
  if (HAL_QSPI_Command(Ctx, &s_command, HAL_QPSI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
 800f754:	f002 fce8 	bl	8012128 <HAL_QSPI_Command>
 800f758:	3800      	subs	r0, #0
 800f75a:	bf18      	it	ne
 800f75c:	2001      	movne	r0, #1
  {
    return MX25R6435F_ERROR;
  }

  return MX25R6435F_OK;
}
 800f75e:	4240      	negs	r0, r0
 800f760:	b00e      	add	sp, #56	; 0x38
 800f762:	bd10      	pop	{r4, pc}

0800f764 <SystemInit>:

void SystemInit(void)
{
  /* FPU settings ------------------------------------------------------------*/
  #if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
    SCB->CPACR |= ((3UL << 10*2)|(3UL << 11*2));  /* set CP10 and CP11 Full Access */
 800f764:	4910      	ldr	r1, [pc, #64]	; (800f7a8 <SystemInit+0x44>)
  #endif

  /* Reset the RCC clock configuration to the default reset state ------------*/
  /* Set MSION bit */
  RCC->CR |= RCC_CR_MSION;
 800f766:	4b11      	ldr	r3, [pc, #68]	; (800f7ac <SystemInit+0x48>)
    SCB->CPACR |= ((3UL << 10*2)|(3UL << 11*2));  /* set CP10 and CP11 Full Access */
 800f768:	f8d1 2088 	ldr.w	r2, [r1, #136]	; 0x88
 800f76c:	f442 0270 	orr.w	r2, r2, #15728640	; 0xf00000
{
 800f770:	b410      	push	{r4}
    SCB->CPACR |= ((3UL << 10*2)|(3UL << 11*2));  /* set CP10 and CP11 Full Access */
 800f772:	f8c1 2088 	str.w	r2, [r1, #136]	; 0x88
  RCC->CR |= RCC_CR_MSION;
 800f776:	681a      	ldr	r2, [r3, #0]

  /* Reset CFGR register */
  RCC->CFGR = 0x00000000U;
 800f778:	2000      	movs	r0, #0
  RCC->CR |= RCC_CR_MSION;
 800f77a:	f042 0201 	orr.w	r2, r2, #1
 800f77e:	601a      	str	r2, [r3, #0]
  RCC->CFGR = 0x00000000U;
 800f780:	6098      	str	r0, [r3, #8]

  /* Reset HSEON, CSSON , HSION, and PLLON bits */
  RCC->CR &= 0xEAF6FFFFU;
 800f782:	681a      	ldr	r2, [r3, #0]
 800f784:	f022 52a8 	bic.w	r2, r2, #352321536	; 0x15000000

  /* Reset PLLCFGR register */
  RCC->PLLCFGR = 0x00001000U;
 800f788:	f44f 5480 	mov.w	r4, #4096	; 0x1000
  RCC->CR &= 0xEAF6FFFFU;
 800f78c:	f422 2210 	bic.w	r2, r2, #589824	; 0x90000
 800f790:	601a      	str	r2, [r3, #0]
  RCC->PLLCFGR = 0x00001000U;
 800f792:	60dc      	str	r4, [r3, #12]

  /* Reset HSEBYP bit */
  RCC->CR &= 0xFFFBFFFFU;
 800f794:	681a      	ldr	r2, [r3, #0]

  /* Configure the Vector Table location add offset address ------------------*/
#ifdef VECT_TAB_SRAM
  SCB->VTOR = SRAM_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal SRAM */
#else
  SCB->VTOR = FLASH_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal FLASH */
 800f796:	4c06      	ldr	r4, [pc, #24]	; (800f7b0 <SystemInit+0x4c>)
  RCC->CR &= 0xFFFBFFFFU;
 800f798:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
 800f79c:	601a      	str	r2, [r3, #0]
  RCC->CIER = 0x00000000U;
 800f79e:	6198      	str	r0, [r3, #24]
  SCB->VTOR = FLASH_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal FLASH */
 800f7a0:	608c      	str	r4, [r1, #8]
#endif
}
 800f7a2:	f85d 4b04 	ldr.w	r4, [sp], #4
 800f7a6:	4770      	bx	lr
 800f7a8:	e000ed00 	.word	0xe000ed00
 800f7ac:	40021000 	.word	0x40021000
 800f7b0:	08004000 	.word	0x08004000

0800f7b4 <HAL_MspInit>:
__weak void HAL_MspInit(void)
{
  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_MspInit could be implemented in the user file
   */
}
 800f7b4:	4770      	bx	lr
 800f7b6:	bf00      	nop

0800f7b8 <HAL_InitTick>:
  *       implementation  in user file.
  * @param TickPriority  Tick interrupt priority.
  * @retval HAL status
  */
__weak HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)
{
 800f7b8:	b570      	push	{r4, r5, r6, lr}
  HAL_StatusTypeDef  status = HAL_OK;

  if (uwTickFreq != 0U)
 800f7ba:	4e0f      	ldr	r6, [pc, #60]	; (800f7f8 <HAL_InitTick+0x40>)
 800f7bc:	6833      	ldr	r3, [r6, #0]
 800f7be:	b90b      	cbnz	r3, 800f7c4 <HAL_InitTick+0xc>
      status = HAL_ERROR;
    }
  }
  else
  {
    status = HAL_ERROR;
 800f7c0:	2001      	movs	r0, #1
  }

  /* Return function status */
  return status;
}
 800f7c2:	bd70      	pop	{r4, r5, r6, pc}
    if (HAL_SYSTICK_Config(SystemCoreClock / (1000U / uwTickFreq)) == 0U)
 800f7c4:	490d      	ldr	r1, [pc, #52]	; (800f7fc <HAL_InitTick+0x44>)
 800f7c6:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 800f7ca:	4605      	mov	r5, r0
 800f7cc:	fbb2 f3f3 	udiv	r3, r2, r3
 800f7d0:	6808      	ldr	r0, [r1, #0]
 800f7d2:	fbb0 f0f3 	udiv	r0, r0, r3
 800f7d6:	f000 f8c5 	bl	800f964 <HAL_SYSTICK_Config>
 800f7da:	4604      	mov	r4, r0
 800f7dc:	2800      	cmp	r0, #0
 800f7de:	d1ef      	bne.n	800f7c0 <HAL_InitTick+0x8>
      if (TickPriority < (1UL << __NVIC_PRIO_BITS))
 800f7e0:	2d0f      	cmp	r5, #15
 800f7e2:	d8ed      	bhi.n	800f7c0 <HAL_InitTick+0x8>
        HAL_NVIC_SetPriority(SysTick_IRQn, TickPriority, 0U);
 800f7e4:	4602      	mov	r2, r0
 800f7e6:	4629      	mov	r1, r5
 800f7e8:	f04f 30ff 	mov.w	r0, #4294967295
 800f7ec:	f000 f848 	bl	800f880 <HAL_NVIC_SetPriority>
        uwTickPrio = TickPriority;
 800f7f0:	6075      	str	r5, [r6, #4]
 800f7f2:	4620      	mov	r0, r4
}
 800f7f4:	bd70      	pop	{r4, r5, r6, pc}
 800f7f6:	bf00      	nop
 800f7f8:	20000120 	.word	0x20000120
 800f7fc:	2000011c 	.word	0x2000011c

0800f800 <HAL_Init>:
{
 800f800:	b510      	push	{r4, lr}
  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
 800f802:	2003      	movs	r0, #3
 800f804:	f000 f82a 	bl	800f85c <HAL_NVIC_SetPriorityGrouping>
  if (HAL_InitTick(TICK_INT_PRIORITY) != HAL_OK)
 800f808:	200f      	movs	r0, #15
 800f80a:	f7ff ffd5 	bl	800f7b8 <HAL_InitTick>
 800f80e:	b110      	cbz	r0, 800f816 <HAL_Init+0x16>
    status = HAL_ERROR;
 800f810:	2401      	movs	r4, #1
}
 800f812:	4620      	mov	r0, r4
 800f814:	bd10      	pop	{r4, pc}
 800f816:	4604      	mov	r4, r0
    HAL_MspInit();
 800f818:	f7ff ffcc 	bl	800f7b4 <HAL_MspInit>
}
 800f81c:	4620      	mov	r0, r4
 800f81e:	bd10      	pop	{r4, pc}

0800f820 <HAL_IncTick>:
  *      implementations in user file.
  * @retval None
  */
__weak void HAL_IncTick(void)
{
  uwTick += uwTickFreq;
 800f820:	4a03      	ldr	r2, [pc, #12]	; (800f830 <HAL_IncTick+0x10>)
 800f822:	4904      	ldr	r1, [pc, #16]	; (800f834 <HAL_IncTick+0x14>)
 800f824:	6813      	ldr	r3, [r2, #0]
 800f826:	6809      	ldr	r1, [r1, #0]
 800f828:	440b      	add	r3, r1
 800f82a:	6013      	str	r3, [r2, #0]
}
 800f82c:	4770      	bx	lr
 800f82e:	bf00      	nop
 800f830:	200032e8 	.word	0x200032e8
 800f834:	20000120 	.word	0x20000120

0800f838 <HAL_GetTick>:
  *       implementations in user file.
  * @retval tick value
  */
__weak uint32_t HAL_GetTick(void)
{
  return uwTick;
 800f838:	4b01      	ldr	r3, [pc, #4]	; (800f840 <HAL_GetTick+0x8>)
 800f83a:	6818      	ldr	r0, [r3, #0]
}
 800f83c:	4770      	bx	lr
 800f83e:	bf00      	nop
 800f840:	200032e8 	.word	0x200032e8

0800f844 <HAL_GetHalVersion>:
  * @retval version : 0xXYZR (8bits for each decimal, R for RC)
  */
uint32_t HAL_GetHalVersion(void)
{
  return STM32L4XX_HAL_VERSION;
}
 800f844:	f04f 7085 	mov.w	r0, #17432576	; 0x10a0000
 800f848:	4770      	bx	lr
 800f84a:	bf00      	nop

0800f84c <HAL_GetDEVID>:
  * @brief  Return the device identifier.
  * @retval Device identifier
  */
uint32_t HAL_GetDEVID(void)
{
  return(DBGMCU->IDCODE & DBGMCU_IDCODE_DEV_ID);
 800f84c:	4b02      	ldr	r3, [pc, #8]	; (800f858 <HAL_GetDEVID+0xc>)
 800f84e:	6818      	ldr	r0, [r3, #0]
}
 800f850:	f3c0 000b 	ubfx	r0, r0, #0, #12
 800f854:	4770      	bx	lr
 800f856:	bf00      	nop
 800f858:	e0042000 	.word	0xe0042000

0800f85c <HAL_NVIC_SetPriorityGrouping>:
__STATIC_INLINE void __NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 800f85c:	4907      	ldr	r1, [pc, #28]	; (800f87c <HAL_NVIC_SetPriorityGrouping+0x20>)
 800f85e:	68ca      	ldr	r2, [r1, #12]
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
  reg_value  =  (reg_value                                   |
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << SCB_AIRCR_PRIGROUP_Pos)  );              /* Insert write key and priority group */
 800f860:	0203      	lsls	r3, r0, #8
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
 800f862:	f64f 00ff 	movw	r0, #63743	; 0xf8ff
                (PriorityGroupTmp << SCB_AIRCR_PRIGROUP_Pos)  );              /* Insert write key and priority group */
 800f866:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
 800f86a:	4002      	ands	r2, r0
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
 800f86c:	4313      	orrs	r3, r2
  reg_value  =  (reg_value                                   |
 800f86e:	f043 63bf 	orr.w	r3, r3, #100139008	; 0x5f80000
 800f872:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
  SCB->AIRCR =  reg_value;
 800f876:	60cb      	str	r3, [r1, #12]
  /* Check the parameters */
  assert_param(IS_NVIC_PRIORITY_GROUP(PriorityGroup));

  /* Set the PRIGROUP[10:8] bits according to the PriorityGroup parameter value */
  NVIC_SetPriorityGrouping(PriorityGroup);
}
 800f878:	4770      	bx	lr
 800f87a:	bf00      	nop
 800f87c:	e000ed00 	.word	0xe000ed00

0800f880 <HAL_NVIC_SetPriority>:
  \details Reads the priority grouping field from the NVIC Interrupt Controller.
  \return                Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field).
 */
__STATIC_INLINE uint32_t __NVIC_GetPriorityGrouping(void)
{
  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
 800f880:	4b1c      	ldr	r3, [pc, #112]	; (800f8f4 <HAL_NVIC_SetPriority+0x74>)
 800f882:	68db      	ldr	r3, [r3, #12]
 800f884:	f3c3 2302 	ubfx	r3, r3, #8, #3
  *         This parameter can be a value between 0 and 15
  *         A lower priority value indicates a higher priority.
  * @retval None
  */
void HAL_NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority)
{
 800f888:	b500      	push	{lr}
{
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 800f88a:	f1c3 0e07 	rsb	lr, r3, #7
 800f88e:	f1be 0f04 	cmp.w	lr, #4
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 800f892:	f103 0c04 	add.w	ip, r3, #4
  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 800f896:	bf28      	it	cs
 800f898:	f04f 0e04 	movcs.w	lr, #4
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 800f89c:	f1bc 0f06 	cmp.w	ip, #6
 800f8a0:	d91b      	bls.n	800f8da <HAL_NVIC_SetPriority+0x5a>
 800f8a2:	3b03      	subs	r3, #3

  return (
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
           ((SubPriority     & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL)))
 800f8a4:	f04f 3cff 	mov.w	ip, #4294967295
 800f8a8:	fa0c fc03 	lsl.w	ip, ip, r3
 800f8ac:	ea22 020c 	bic.w	r2, r2, ip
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 800f8b0:	f04f 3cff 	mov.w	ip, #4294967295
 800f8b4:	fa0c fc0e 	lsl.w	ip, ip, lr
 800f8b8:	ea21 010c 	bic.w	r1, r1, ip
 800f8bc:	4099      	lsls	r1, r3
  if ((int32_t)(IRQn) >= 0)
 800f8be:	2800      	cmp	r0, #0
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 800f8c0:	ea41 0102 	orr.w	r1, r1, r2
  if ((int32_t)(IRQn) >= 0)
 800f8c4:	db0c      	blt.n	800f8e0 <HAL_NVIC_SetPriority+0x60>
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 800f8c6:	f100 4060 	add.w	r0, r0, #3758096384	; 0xe0000000
 800f8ca:	0109      	lsls	r1, r1, #4
 800f8cc:	f500 4061 	add.w	r0, r0, #57600	; 0xe100
 800f8d0:	b2c9      	uxtb	r1, r1
 800f8d2:	f880 1300 	strb.w	r1, [r0, #768]	; 0x300
  assert_param(IS_NVIC_PREEMPTION_PRIORITY(PreemptPriority));

  prioritygroup = NVIC_GetPriorityGrouping();

  NVIC_SetPriority(IRQn, NVIC_EncodePriority(prioritygroup, PreemptPriority, SubPriority));
}
 800f8d6:	f85d fb04 	ldr.w	pc, [sp], #4
 800f8da:	2200      	movs	r2, #0
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 800f8dc:	4613      	mov	r3, r2
 800f8de:	e7e7      	b.n	800f8b0 <HAL_NVIC_SetPriority+0x30>
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 800f8e0:	4b05      	ldr	r3, [pc, #20]	; (800f8f8 <HAL_NVIC_SetPriority+0x78>)
 800f8e2:	f000 000f 	and.w	r0, r0, #15
 800f8e6:	0109      	lsls	r1, r1, #4
 800f8e8:	4403      	add	r3, r0
 800f8ea:	b2c9      	uxtb	r1, r1
 800f8ec:	7619      	strb	r1, [r3, #24]
 800f8ee:	f85d fb04 	ldr.w	pc, [sp], #4
 800f8f2:	bf00      	nop
 800f8f4:	e000ed00 	.word	0xe000ed00
 800f8f8:	e000ecfc 	.word	0xe000ecfc

0800f8fc <HAL_NVIC_EnableIRQ>:
  if ((int32_t)(IRQn) >= 0)
 800f8fc:	2800      	cmp	r0, #0
 800f8fe:	db08      	blt.n	800f912 <HAL_NVIC_EnableIRQ+0x16>
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 800f900:	0941      	lsrs	r1, r0, #5
 800f902:	4a04      	ldr	r2, [pc, #16]	; (800f914 <HAL_NVIC_EnableIRQ+0x18>)
 800f904:	f000 001f 	and.w	r0, r0, #31
 800f908:	2301      	movs	r3, #1
 800f90a:	fa03 f000 	lsl.w	r0, r3, r0
 800f90e:	f842 0021 	str.w	r0, [r2, r1, lsl #2]
  /* Check the parameters */
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));

  /* Enable interrupt */
  NVIC_EnableIRQ(IRQn);
}
 800f912:	4770      	bx	lr
 800f914:	e000e100 	.word	0xe000e100

0800f918 <HAL_NVIC_DisableIRQ>:
  if ((int32_t)(IRQn) >= 0)
 800f918:	2800      	cmp	r0, #0
 800f91a:	db0d      	blt.n	800f938 <HAL_NVIC_DisableIRQ+0x20>
    NVIC->ICER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 800f91c:	0943      	lsrs	r3, r0, #5
 800f91e:	4907      	ldr	r1, [pc, #28]	; (800f93c <HAL_NVIC_DisableIRQ+0x24>)
 800f920:	2201      	movs	r2, #1
 800f922:	3320      	adds	r3, #32
 800f924:	f000 001f 	and.w	r0, r0, #31
 800f928:	fa02 f000 	lsl.w	r0, r2, r0
 800f92c:	f841 0023 	str.w	r0, [r1, r3, lsl #2]
  __ASM volatile ("dsb 0xF":::"memory");
 800f930:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
 800f934:	f3bf 8f6f 	isb	sy
  /* Check the parameters */
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));

  /* Disable interrupt */
  NVIC_DisableIRQ(IRQn);
}
 800f938:	4770      	bx	lr
 800f93a:	bf00      	nop
 800f93c:	e000e100 	.word	0xe000e100

0800f940 <HAL_NVIC_SystemReset>:
  __ASM volatile ("dsb 0xF":::"memory");
 800f940:	f3bf 8f4f 	dsb	sy
__NO_RETURN __STATIC_INLINE void __NVIC_SystemReset(void)
{
  __DSB();                                                          /* Ensure all outstanding memory accesses included
                                                                       buffered write are completed before reset */
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
                           (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
 800f944:	4905      	ldr	r1, [pc, #20]	; (800f95c <HAL_NVIC_SystemReset+0x1c>)
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
 800f946:	4b06      	ldr	r3, [pc, #24]	; (800f960 <HAL_NVIC_SystemReset+0x20>)
                           (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
 800f948:	68ca      	ldr	r2, [r1, #12]
 800f94a:	f402 62e0 	and.w	r2, r2, #1792	; 0x700
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
 800f94e:	4313      	orrs	r3, r2
 800f950:	60cb      	str	r3, [r1, #12]
 800f952:	f3bf 8f4f 	dsb	sy
                            SCB_AIRCR_SYSRESETREQ_Msk    );         /* Keep priority group unchanged */
  __DSB();                                                          /* Ensure completion of memory access */

  for(;;)                                                           /* wait until reset */
  {
    __NOP();
 800f956:	bf00      	nop
  for(;;)                                                           /* wait until reset */
 800f958:	e7fd      	b.n	800f956 <HAL_NVIC_SystemReset+0x16>
 800f95a:	bf00      	nop
 800f95c:	e000ed00 	.word	0xe000ed00
 800f960:	05fa0004 	.word	0x05fa0004

0800f964 <HAL_SYSTICK_Config>:
           function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
           must contain a vendor-specific implementation of this function.
 */
__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
{
  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
 800f964:	3801      	subs	r0, #1
 800f966:	f1b0 7f80 	cmp.w	r0, #16777216	; 0x1000000
 800f96a:	d210      	bcs.n	800f98e <HAL_SYSTICK_Config+0x2a>
  * @param  TicksNumb: Specifies the ticks Number of ticks between two interrupts.
  * @retval status:  - 0  Function succeeded.
  *                  - 1  Function failed.
  */
uint32_t HAL_SYSTICK_Config(uint32_t TicksNumb)
{
 800f96c:	b410      	push	{r4}
  {
    return (1UL);                                                   /* Reload value impossible */
  }

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
 800f96e:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 800f972:	4c08      	ldr	r4, [pc, #32]	; (800f994 <HAL_SYSTICK_Config+0x30>)
  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
 800f974:	6158      	str	r0, [r3, #20]
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 800f976:	f04f 0cf0 	mov.w	ip, #240	; 0xf0
 800f97a:	f884 c023 	strb.w	ip, [r4, #35]	; 0x23
  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
 800f97e:	2200      	movs	r2, #0
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 800f980:	2107      	movs	r1, #7
                   SysTick_CTRL_TICKINT_Msk   |
                   SysTick_CTRL_ENABLE_Msk;                         /* Enable SysTick IRQ and SysTick Timer */
  return (0UL);                                                     /* Function successful */
 800f982:	4610      	mov	r0, r2
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
 800f984:	619a      	str	r2, [r3, #24]
   return SysTick_Config(TicksNumb);
}
 800f986:	f85d 4b04 	ldr.w	r4, [sp], #4
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 800f98a:	6119      	str	r1, [r3, #16]
 800f98c:	4770      	bx	lr
    return (1UL);                                                   /* Reload value impossible */
 800f98e:	2001      	movs	r0, #1
 800f990:	4770      	bx	lr
 800f992:	bf00      	nop
 800f994:	e000ed00 	.word	0xe000ed00

0800f998 <CRC_Handle_8>:
  * @param  pBuffer pointer to the input data buffer
  * @param  BufferLength input data buffer length
  * @retval uint32_t CRC (returned value LSBs for CRC shorter than 32 bits)
  */
static uint32_t CRC_Handle_8(CRC_HandleTypeDef *hcrc, uint8_t pBuffer[], uint32_t BufferLength)
{
 800f998:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  __IO uint16_t *pReg;

  /* Processing time optimization: 4 bytes are entered in a row with a single word write,
   * last bytes must be carefully fed to the CRC calculator to ensure a correct type
   * handling by the peripheral */
  for (i = 0U; i < (BufferLength / 4U); i++)
 800f99c:	0897      	lsrs	r7, r2, #2
  {
    hcrc->Instance->DR = ((uint32_t)pBuffer[4U * i] << 24U) | \
 800f99e:	6805      	ldr	r5, [r0, #0]
  for (i = 0U; i < (BufferLength / 4U); i++)
 800f9a0:	d015      	beq.n	800f9ce <CRC_Handle_8+0x36>
 800f9a2:	468c      	mov	ip, r1
 800f9a4:	eb01 0687 	add.w	r6, r1, r7, lsl #2
                         ((uint32_t)pBuffer[(4U * i) + 1U] << 16U) | \
 800f9a8:	f89c 3001 	ldrb.w	r3, [ip, #1]
    hcrc->Instance->DR = ((uint32_t)pBuffer[4U * i] << 24U) | \
 800f9ac:	f89c 8000 	ldrb.w	r8, [ip]
                         ((uint32_t)pBuffer[(4U * i) + 2U] << 8U)  | \
                         (uint32_t)pBuffer[(4U * i) + 3U];
 800f9b0:	f89c 4003 	ldrb.w	r4, [ip, #3]
                         ((uint32_t)pBuffer[(4U * i) + 2U] << 8U)  | \
 800f9b4:	f89c e002 	ldrb.w	lr, [ip, #2]
                         ((uint32_t)pBuffer[(4U * i) + 1U] << 16U) | \
 800f9b8:	041b      	lsls	r3, r3, #16
                         ((uint32_t)pBuffer[(4U * i) + 2U] << 8U)  | \
 800f9ba:	ea43 6308 	orr.w	r3, r3, r8, lsl #24
 800f9be:	4323      	orrs	r3, r4
  for (i = 0U; i < (BufferLength / 4U); i++)
 800f9c0:	f10c 0c04 	add.w	ip, ip, #4
                         ((uint32_t)pBuffer[(4U * i) + 2U] << 8U)  | \
 800f9c4:	ea43 230e 	orr.w	r3, r3, lr, lsl #8
  for (i = 0U; i < (BufferLength / 4U); i++)
 800f9c8:	4566      	cmp	r6, ip
    hcrc->Instance->DR = ((uint32_t)pBuffer[4U * i] << 24U) | \
 800f9ca:	602b      	str	r3, [r5, #0]
  for (i = 0U; i < (BufferLength / 4U); i++)
 800f9cc:	d1ec      	bne.n	800f9a8 <CRC_Handle_8+0x10>
  }
  /* last bytes specific handling */
  if ((BufferLength % 4U) != 0U)
 800f9ce:	f012 0203 	ands.w	r2, r2, #3
 800f9d2:	d00b      	beq.n	800f9ec <CRC_Handle_8+0x54>
  {
    if ((BufferLength % 4U) == 1U)
 800f9d4:	2a01      	cmp	r2, #1
 800f9d6:	d00c      	beq.n	800f9f2 <CRC_Handle_8+0x5a>
    {
      *(__IO uint8_t *)(__IO void *)(&hcrc->Instance->DR) = pBuffer[4U * i];         /* Derogation MisraC2012 R.11.5 */
    }
    if ((BufferLength % 4U) == 2U)
 800f9d8:	2a02      	cmp	r2, #2
 800f9da:	d111      	bne.n	800fa00 <CRC_Handle_8+0x68>
    {
      data = ((uint16_t)(pBuffer[4U * i]) << 8U) | (uint16_t)pBuffer[(4U * i) + 1U];
 800f9dc:	eb01 0387 	add.w	r3, r1, r7, lsl #2
 800f9e0:	f811 2027 	ldrb.w	r2, [r1, r7, lsl #2]
 800f9e4:	785b      	ldrb	r3, [r3, #1]
 800f9e6:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
      pReg = (__IO uint16_t *)(__IO void *)(&hcrc->Instance->DR);                    /* Derogation MisraC2012 R.11.5 */
      *pReg = data;
 800f9ea:	802b      	strh	r3, [r5, #0]
      *(__IO uint8_t *)(__IO void *)(&hcrc->Instance->DR) = pBuffer[(4U * i) + 2U];  /* Derogation MisraC2012 R.11.5 */
    }
  }

  /* Return the CRC computed value */
  return hcrc->Instance->DR;
 800f9ec:	6828      	ldr	r0, [r5, #0]
}
 800f9ee:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      *(__IO uint8_t *)(__IO void *)(&hcrc->Instance->DR) = pBuffer[4U * i];         /* Derogation MisraC2012 R.11.5 */
 800f9f2:	f811 3027 	ldrb.w	r3, [r1, r7, lsl #2]
 800f9f6:	702b      	strb	r3, [r5, #0]
      pReg = (__IO uint16_t *)(__IO void *)(&hcrc->Instance->DR);                    /* Derogation MisraC2012 R.11.5 */
 800f9f8:	6805      	ldr	r5, [r0, #0]
  return hcrc->Instance->DR;
 800f9fa:	6828      	ldr	r0, [r5, #0]
}
 800f9fc:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      data = ((uint16_t)(pBuffer[4U * i]) << 8U) | (uint16_t)pBuffer[(4U * i) + 1U];
 800fa00:	f811 2027 	ldrb.w	r2, [r1, r7, lsl #2]
 800fa04:	eb01 0187 	add.w	r1, r1, r7, lsl #2
 800fa08:	784b      	ldrb	r3, [r1, #1]
 800fa0a:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
      *pReg = data;
 800fa0e:	802b      	strh	r3, [r5, #0]
      *(__IO uint8_t *)(__IO void *)(&hcrc->Instance->DR) = pBuffer[(4U * i) + 2U];  /* Derogation MisraC2012 R.11.5 */
 800fa10:	788b      	ldrb	r3, [r1, #2]
 800fa12:	702b      	strb	r3, [r5, #0]
  return hcrc->Instance->DR;
 800fa14:	6805      	ldr	r5, [r0, #0]
 800fa16:	6828      	ldr	r0, [r5, #0]
}
 800fa18:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

0800fa1c <CRC_Handle_16>:
  * @param  pBuffer pointer to the input data buffer
  * @param  BufferLength input data buffer length
  * @retval uint32_t CRC (returned value LSBs for CRC shorter than 32 bits)
  */
static uint32_t CRC_Handle_16(CRC_HandleTypeDef *hcrc, uint16_t pBuffer[], uint32_t BufferLength)
{
 800fa1c:	b530      	push	{r4, r5, lr}
  __IO uint16_t *pReg;

  /* Processing time optimization: 2 HalfWords are entered in a row with a single word write,
   * in case of odd length, last HalfWord must be carefully fed to the CRC calculator to ensure
   * a correct type handling by the peripheral */
  for (i = 0U; i < (BufferLength / 2U); i++)
 800fa1e:	ea5f 0e52 	movs.w	lr, r2, lsr #1
  {
    hcrc->Instance->DR = ((uint32_t)pBuffer[2U * i] << 16U) | (uint32_t)pBuffer[(2U * i) + 1U];
 800fa22:	6804      	ldr	r4, [r0, #0]
  for (i = 0U; i < (BufferLength / 2U); i++)
 800fa24:	d00b      	beq.n	800fa3e <CRC_Handle_16+0x22>
 800fa26:	2300      	movs	r3, #0
 800fa28:	1c8d      	adds	r5, r1, #2
    hcrc->Instance->DR = ((uint32_t)pBuffer[2U * i] << 16U) | (uint32_t)pBuffer[(2U * i) + 1U];
 800fa2a:	f831 c023 	ldrh.w	ip, [r1, r3, lsl #2]
 800fa2e:	f835 0023 	ldrh.w	r0, [r5, r3, lsl #2]
  for (i = 0U; i < (BufferLength / 2U); i++)
 800fa32:	3301      	adds	r3, #1
    hcrc->Instance->DR = ((uint32_t)pBuffer[2U * i] << 16U) | (uint32_t)pBuffer[(2U * i) + 1U];
 800fa34:	ea40 400c 	orr.w	r0, r0, ip, lsl #16
  for (i = 0U; i < (BufferLength / 2U); i++)
 800fa38:	4573      	cmp	r3, lr
    hcrc->Instance->DR = ((uint32_t)pBuffer[2U * i] << 16U) | (uint32_t)pBuffer[(2U * i) + 1U];
 800fa3a:	6020      	str	r0, [r4, #0]
  for (i = 0U; i < (BufferLength / 2U); i++)
 800fa3c:	d1f5      	bne.n	800fa2a <CRC_Handle_16+0xe>
  }
  if ((BufferLength % 2U) != 0U)
 800fa3e:	07d3      	lsls	r3, r2, #31
  {
    pReg = (__IO uint16_t *)(__IO void *)(&hcrc->Instance->DR);                 /* Derogation MisraC2012 R.11.5 */
    *pReg = pBuffer[2U * i];
 800fa40:	bf44      	itt	mi
 800fa42:	f831 302e 	ldrhmi.w	r3, [r1, lr, lsl #2]
 800fa46:	8023      	strhmi	r3, [r4, #0]
  }

  /* Return the CRC computed value */
  return hcrc->Instance->DR;
 800fa48:	6820      	ldr	r0, [r4, #0]
}
 800fa4a:	bd30      	pop	{r4, r5, pc}

0800fa4c <HAL_CRC_Init>:
  if (hcrc == NULL)
 800fa4c:	2800      	cmp	r0, #0
 800fa4e:	d036      	beq.n	800fabe <HAL_CRC_Init+0x72>
{
 800fa50:	b510      	push	{r4, lr}
  if (hcrc->State == HAL_CRC_STATE_RESET)
 800fa52:	7f43      	ldrb	r3, [r0, #29]
 800fa54:	4604      	mov	r4, r0
 800fa56:	f003 02ff 	and.w	r2, r3, #255	; 0xff
 800fa5a:	b363      	cbz	r3, 800fab6 <HAL_CRC_Init+0x6a>
  if (hcrc->Init.DefaultPolynomialUse == DEFAULT_POLYNOMIAL_ENABLE)
 800fa5c:	7923      	ldrb	r3, [r4, #4]
  hcrc->State = HAL_CRC_STATE_BUSY;
 800fa5e:	2202      	movs	r2, #2
 800fa60:	7762      	strb	r2, [r4, #29]
  if (hcrc->Init.DefaultPolynomialUse == DEFAULT_POLYNOMIAL_ENABLE)
 800fa62:	b9f3      	cbnz	r3, 800faa2 <HAL_CRC_Init+0x56>
    WRITE_REG(hcrc->Instance->POL, DEFAULT_CRC32_POLY);
 800fa64:	6823      	ldr	r3, [r4, #0]
 800fa66:	4a17      	ldr	r2, [pc, #92]	; (800fac4 <HAL_CRC_Init+0x78>)
 800fa68:	615a      	str	r2, [r3, #20]
    MODIFY_REG(hcrc->Instance->CR, CRC_CR_POLYSIZE, CRC_POLYLENGTH_32B);
 800fa6a:	689a      	ldr	r2, [r3, #8]
 800fa6c:	f022 0218 	bic.w	r2, r2, #24
 800fa70:	609a      	str	r2, [r3, #8]
  if (hcrc->Init.DefaultInitValueUse == DEFAULT_INIT_VALUE_ENABLE)
 800fa72:	7962      	ldrb	r2, [r4, #5]
 800fa74:	b18a      	cbz	r2, 800fa9a <HAL_CRC_Init+0x4e>
    WRITE_REG(hcrc->Instance->INIT, hcrc->Init.InitValue);
 800fa76:	6922      	ldr	r2, [r4, #16]
 800fa78:	611a      	str	r2, [r3, #16]
  MODIFY_REG(hcrc->Instance->CR, CRC_CR_REV_IN, hcrc->Init.InputDataInversionMode);
 800fa7a:	689a      	ldr	r2, [r3, #8]
 800fa7c:	6961      	ldr	r1, [r4, #20]
 800fa7e:	f022 0260 	bic.w	r2, r2, #96	; 0x60
 800fa82:	430a      	orrs	r2, r1
 800fa84:	609a      	str	r2, [r3, #8]
  MODIFY_REG(hcrc->Instance->CR, CRC_CR_REV_OUT, hcrc->Init.OutputDataInversionMode);
 800fa86:	689a      	ldr	r2, [r3, #8]
 800fa88:	69a1      	ldr	r1, [r4, #24]
 800fa8a:	f022 0280 	bic.w	r2, r2, #128	; 0x80
 800fa8e:	430a      	orrs	r2, r1
  hcrc->State = HAL_CRC_STATE_READY;
 800fa90:	2101      	movs	r1, #1
  MODIFY_REG(hcrc->Instance->CR, CRC_CR_REV_OUT, hcrc->Init.OutputDataInversionMode);
 800fa92:	609a      	str	r2, [r3, #8]
  hcrc->State = HAL_CRC_STATE_READY;
 800fa94:	7761      	strb	r1, [r4, #29]
  return HAL_OK;
 800fa96:	2000      	movs	r0, #0
}
 800fa98:	bd10      	pop	{r4, pc}
    WRITE_REG(hcrc->Instance->INIT, DEFAULT_CRC_INITVALUE);
 800fa9a:	f04f 32ff 	mov.w	r2, #4294967295
 800fa9e:	611a      	str	r2, [r3, #16]
 800faa0:	e7eb      	b.n	800fa7a <HAL_CRC_Init+0x2e>
    if (HAL_CRCEx_Polynomial_Set(hcrc, hcrc->Init.GeneratingPolynomial, hcrc->Init.CRCLength) != HAL_OK)
 800faa2:	e9d4 1202 	ldrd	r1, r2, [r4, #8]
 800faa6:	4620      	mov	r0, r4
 800faa8:	f000 f856 	bl	800fb58 <HAL_CRCEx_Polynomial_Set>
 800faac:	b908      	cbnz	r0, 800fab2 <HAL_CRC_Init+0x66>
    WRITE_REG(hcrc->Instance->INIT, DEFAULT_CRC_INITVALUE);
 800faae:	6823      	ldr	r3, [r4, #0]
 800fab0:	e7df      	b.n	800fa72 <HAL_CRC_Init+0x26>
    return HAL_ERROR;
 800fab2:	2001      	movs	r0, #1
}
 800fab4:	bd10      	pop	{r4, pc}
    hcrc->Lock = HAL_UNLOCKED;
 800fab6:	7702      	strb	r2, [r0, #28]
    HAL_CRC_MspInit(hcrc);
 800fab8:	f015 f82a 	bl	8024b10 <HAL_CRC_MspInit>
 800fabc:	e7ce      	b.n	800fa5c <HAL_CRC_Init+0x10>
    return HAL_ERROR;
 800fabe:	2001      	movs	r0, #1
}
 800fac0:	4770      	bx	lr
 800fac2:	bf00      	nop
 800fac4:	04c11db7 	.word	0x04c11db7

0800fac8 <HAL_CRC_DeInit>:
{
 800fac8:	b538      	push	{r3, r4, r5, lr}
  if (hcrc == NULL)
 800faca:	b1a0      	cbz	r0, 800faf6 <HAL_CRC_DeInit+0x2e>
  if (hcrc->State == HAL_CRC_STATE_BUSY)
 800facc:	7f43      	ldrb	r3, [r0, #29]
 800face:	2b02      	cmp	r3, #2
 800fad0:	4604      	mov	r4, r0
 800fad2:	b2dd      	uxtb	r5, r3
 800fad4:	d00d      	beq.n	800faf2 <HAL_CRC_DeInit+0x2a>
  __HAL_CRC_DR_RESET(hcrc);
 800fad6:	6803      	ldr	r3, [r0, #0]
  hcrc->State = HAL_CRC_STATE_BUSY;
 800fad8:	2202      	movs	r2, #2
 800fada:	7742      	strb	r2, [r0, #29]
  __HAL_CRC_DR_RESET(hcrc);
 800fadc:	689a      	ldr	r2, [r3, #8]
 800fade:	f042 0201 	orr.w	r2, r2, #1
  CLEAR_BIT(hcrc->Instance->IDR, CRC_IDR_IDR);
 800fae2:	2500      	movs	r5, #0
  __HAL_CRC_DR_RESET(hcrc);
 800fae4:	609a      	str	r2, [r3, #8]
  CLEAR_BIT(hcrc->Instance->IDR, CRC_IDR_IDR);
 800fae6:	791a      	ldrb	r2, [r3, #4]
 800fae8:	711d      	strb	r5, [r3, #4]
  HAL_CRC_MspDeInit(hcrc);
 800faea:	f015 f821 	bl	8024b30 <HAL_CRC_MspDeInit>
  hcrc->State = HAL_CRC_STATE_RESET;
 800faee:	7765      	strb	r5, [r4, #29]
  __HAL_UNLOCK(hcrc);
 800faf0:	7725      	strb	r5, [r4, #28]
}
 800faf2:	4628      	mov	r0, r5
 800faf4:	bd38      	pop	{r3, r4, r5, pc}
    return HAL_ERROR;
 800faf6:	2501      	movs	r5, #1
}
 800faf8:	4628      	mov	r0, r5
 800fafa:	bd38      	pop	{r3, r4, r5, pc}

0800fafc <HAL_CRC_Calculate>:
{
 800fafc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  __HAL_CRC_DR_RESET(hcrc);
 800fafe:	6806      	ldr	r6, [r0, #0]
  switch (hcrc->InputDataFormat)
 800fb00:	6a07      	ldr	r7, [r0, #32]
  hcrc->State = HAL_CRC_STATE_BUSY;
 800fb02:	2502      	movs	r5, #2
 800fb04:	7745      	strb	r5, [r0, #29]
  __HAL_CRC_DR_RESET(hcrc);
 800fb06:	68b5      	ldr	r5, [r6, #8]
  switch (hcrc->InputDataFormat)
 800fb08:	2f02      	cmp	r7, #2
  __HAL_CRC_DR_RESET(hcrc);
 800fb0a:	f045 0501 	orr.w	r5, r5, #1
{
 800fb0e:	4604      	mov	r4, r0
  __HAL_CRC_DR_RESET(hcrc);
 800fb10:	60b5      	str	r5, [r6, #8]
  switch (hcrc->InputDataFormat)
 800fb12:	d007      	beq.n	800fb24 <HAL_CRC_Calculate+0x28>
 800fb14:	2f03      	cmp	r7, #3
 800fb16:	d00f      	beq.n	800fb38 <HAL_CRC_Calculate+0x3c>
 800fb18:	2f01      	cmp	r7, #1
 800fb1a:	d008      	beq.n	800fb2e <HAL_CRC_Calculate+0x32>
  hcrc->State = HAL_CRC_STATE_READY;
 800fb1c:	2301      	movs	r3, #1
 800fb1e:	7763      	strb	r3, [r4, #29]
  switch (hcrc->InputDataFormat)
 800fb20:	2000      	movs	r0, #0
}
 800fb22:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      temp = CRC_Handle_16(hcrc, (uint16_t *)(void *)pBuffer, BufferLength);    /* Derogation MisraC2012 R.11.5 */
 800fb24:	f7ff ff7a 	bl	800fa1c <CRC_Handle_16>
  hcrc->State = HAL_CRC_STATE_READY;
 800fb28:	2301      	movs	r3, #1
 800fb2a:	7763      	strb	r3, [r4, #29]
}
 800fb2c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      temp = CRC_Handle_8(hcrc, (uint8_t *)pBuffer, BufferLength);
 800fb2e:	f7ff ff33 	bl	800f998 <CRC_Handle_8>
  hcrc->State = HAL_CRC_STATE_READY;
 800fb32:	2301      	movs	r3, #1
 800fb34:	7763      	strb	r3, [r4, #29]
}
 800fb36:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      for (index = 0U; index < BufferLength; index++)
 800fb38:	b13a      	cbz	r2, 800fb4a <HAL_CRC_Calculate+0x4e>
 800fb3a:	3904      	subs	r1, #4
 800fb3c:	eb01 0282 	add.w	r2, r1, r2, lsl #2
        hcrc->Instance->DR = pBuffer[index];
 800fb40:	f851 3f04 	ldr.w	r3, [r1, #4]!
 800fb44:	6033      	str	r3, [r6, #0]
      for (index = 0U; index < BufferLength; index++)
 800fb46:	4291      	cmp	r1, r2
 800fb48:	d1fa      	bne.n	800fb40 <HAL_CRC_Calculate+0x44>
  hcrc->State = HAL_CRC_STATE_READY;
 800fb4a:	2301      	movs	r3, #1
      temp = hcrc->Instance->DR;
 800fb4c:	6830      	ldr	r0, [r6, #0]
  hcrc->State = HAL_CRC_STATE_READY;
 800fb4e:	7763      	strb	r3, [r4, #29]
}
 800fb50:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800fb52:	bf00      	nop

0800fb54 <HAL_CRC_GetState>:
  return hcrc->State;
 800fb54:	7f40      	ldrb	r0, [r0, #29]
}
 800fb56:	4770      	bx	lr

0800fb58 <HAL_CRCEx_Polynomial_Set>:
  *          @arg @ref CRC_POLYLENGTH_16B 16-bit long CRC (generating polynomial of degree 16)
  *          @arg @ref CRC_POLYLENGTH_32B 32-bit long CRC (generating polynomial of degree 32)
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_CRCEx_Polynomial_Set(CRC_HandleTypeDef *hcrc, uint32_t Pol, uint32_t PolyLength)
{
 800fb58:	b410      	push	{r4}
   * definition. HAL_ERROR is reported if Pol degree is
   * larger than that indicated by PolyLength.
   * Look for MSB position: msb will contain the degree of
   *  the second to the largest polynomial member. E.g., for
   *  X^7 + X^6 + X^5 + X^2 + 1, msb = 6. */
  while ((msb-- > 0U) && ((Pol & ((uint32_t)(0x1U) << (msb & 0x1FU))) == 0U))
 800fb5a:	231e      	movs	r3, #30
 800fb5c:	e001      	b.n	800fb62 <HAL_CRCEx_Polynomial_Set+0xa>
 800fb5e:	3b01      	subs	r3, #1
 800fb60:	d315      	bcc.n	800fb8e <HAL_CRCEx_Polynomial_Set+0x36>
 800fb62:	fa21 fc03 	lsr.w	ip, r1, r3
 800fb66:	f01c 0f01 	tst.w	ip, #1
 800fb6a:	d0f8      	beq.n	800fb5e <HAL_CRCEx_Polynomial_Set+0x6>
  {
  }

  switch (PolyLength)
 800fb6c:	2a18      	cmp	r2, #24
 800fb6e:	d80f      	bhi.n	800fb90 <HAL_CRCEx_Polynomial_Set+0x38>
 800fb70:	e8df f002 	tbb	[pc, r2]
 800fb74:	0e0e0e14 	.word	0x0e0e0e14
 800fb78:	0e0e0e0e 	.word	0x0e0e0e0e
 800fb7c:	0e0e0e1f 	.word	0x0e0e0e1f
 800fb80:	0e0e0e0e 	.word	0x0e0e0e0e
 800fb84:	0e0e0e22 	.word	0x0e0e0e22
 800fb88:	0e0e0e0e 	.word	0x0e0e0e0e
 800fb8c:	12          	.byte	0x12
 800fb8d:	00          	.byte	0x00
 800fb8e:	b12a      	cbz	r2, 800fb9c <HAL_CRCEx_Polynomial_Set+0x44>

    case CRC_POLYLENGTH_32B:
      /* no polynomial definition vs. polynomial length issue possible */
      break;
    default:
      status =  HAL_ERROR;
 800fb90:	2001      	movs	r0, #1
    /* set generating polynomial size */
    MODIFY_REG(hcrc->Instance->CR, CRC_CR_POLYSIZE, PolyLength);
  }
  /* Return function status */
  return status;
}
 800fb92:	f85d 4b04 	ldr.w	r4, [sp], #4
 800fb96:	4770      	bx	lr
      if (msb >= HAL_CRC_LENGTH_7B)
 800fb98:	2b06      	cmp	r3, #6
 800fb9a:	d8f9      	bhi.n	800fb90 <HAL_CRCEx_Polynomial_Set+0x38>
    WRITE_REG(hcrc->Instance->POL, Pol);
 800fb9c:	6804      	ldr	r4, [r0, #0]
 800fb9e:	6161      	str	r1, [r4, #20]
    MODIFY_REG(hcrc->Instance->CR, CRC_CR_POLYSIZE, PolyLength);
 800fba0:	68a3      	ldr	r3, [r4, #8]
 800fba2:	f023 0318 	bic.w	r3, r3, #24
 800fba6:	431a      	orrs	r2, r3
 800fba8:	2000      	movs	r0, #0
 800fbaa:	60a2      	str	r2, [r4, #8]
}
 800fbac:	f85d 4b04 	ldr.w	r4, [sp], #4
 800fbb0:	4770      	bx	lr
      if (msb >= HAL_CRC_LENGTH_16B)
 800fbb2:	2b0f      	cmp	r3, #15
 800fbb4:	d9f2      	bls.n	800fb9c <HAL_CRCEx_Polynomial_Set+0x44>
 800fbb6:	e7eb      	b.n	800fb90 <HAL_CRCEx_Polynomial_Set+0x38>
      if (msb >= HAL_CRC_LENGTH_8B)
 800fbb8:	2b07      	cmp	r3, #7
 800fbba:	d9ef      	bls.n	800fb9c <HAL_CRCEx_Polynomial_Set+0x44>
 800fbbc:	e7e8      	b.n	800fb90 <HAL_CRCEx_Polynomial_Set+0x38>
 800fbbe:	bf00      	nop

0800fbc0 <DFSDM_RegConvStart>:
  * @retval None
  */
static void DFSDM_RegConvStart(DFSDM_Filter_HandleTypeDef *hdfsdm_filter)
{
  /* Check regular trigger */
  if (hdfsdm_filter->RegularTrigger == DFSDM_FILTER_SW_TRIGGER)
 800fbc0:	6b43      	ldr	r3, [r0, #52]	; 0x34
 800fbc2:	b96b      	cbnz	r3, 800fbe0 <DFSDM_RegConvStart+0x20>
  {
    /* Software start of regular conversion */
    hdfsdm_filter->Instance->FLTCR1 |= DFSDM_FLTCR1_RSWSTART;
 800fbc4:	6802      	ldr	r2, [r0, #0]
 800fbc6:	6813      	ldr	r3, [r2, #0]
 800fbc8:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 800fbcc:	6013      	str	r3, [r2, #0]

    /* Enable DFSDM  filter */
    hdfsdm_filter->Instance->FLTCR1 |= DFSDM_FLTCR1_DFEN;

    /* If injected conversion was in progress, restart it */
    if (hdfsdm_filter->State == HAL_DFSDM_FILTER_STATE_INJ)
 800fbce:	f890 204c 	ldrb.w	r2, [r0, #76]	; 0x4c
                                        hdfsdm_filter->InjectedChannelsNbr : 1U;
    }
  }
  /* Update DFSDM filter state */
  hdfsdm_filter->State = (hdfsdm_filter->State == HAL_DFSDM_FILTER_STATE_READY) ? \
                         HAL_DFSDM_FILTER_STATE_REG : HAL_DFSDM_FILTER_STATE_REG_INJ;
 800fbd2:	2a01      	cmp	r2, #1
 800fbd4:	bf0c      	ite	eq
 800fbd6:	2302      	moveq	r3, #2
 800fbd8:	2304      	movne	r3, #4
  hdfsdm_filter->State = (hdfsdm_filter->State == HAL_DFSDM_FILTER_STATE_READY) ? \
 800fbda:	f880 304c 	strb.w	r3, [r0, #76]	; 0x4c
}
 800fbde:	4770      	bx	lr
    hdfsdm_filter->Instance->FLTCR1 &= ~(DFSDM_FLTCR1_DFEN);
 800fbe0:	6803      	ldr	r3, [r0, #0]
 800fbe2:	681a      	ldr	r2, [r3, #0]
 800fbe4:	f022 0201 	bic.w	r2, r2, #1
 800fbe8:	601a      	str	r2, [r3, #0]
    hdfsdm_filter->Instance->FLTCR1 |= DFSDM_FLTCR1_RSYNC;
 800fbea:	681a      	ldr	r2, [r3, #0]
 800fbec:	f442 2200 	orr.w	r2, r2, #524288	; 0x80000
 800fbf0:	601a      	str	r2, [r3, #0]
    hdfsdm_filter->Instance->FLTCR1 |= DFSDM_FLTCR1_DFEN;
 800fbf2:	681a      	ldr	r2, [r3, #0]
 800fbf4:	f042 0201 	orr.w	r2, r2, #1
 800fbf8:	601a      	str	r2, [r3, #0]
    if (hdfsdm_filter->State == HAL_DFSDM_FILTER_STATE_INJ)
 800fbfa:	f890 204c 	ldrb.w	r2, [r0, #76]	; 0x4c
 800fbfe:	2a03      	cmp	r2, #3
 800fc00:	d1e7      	bne.n	800fbd2 <DFSDM_RegConvStart+0x12>
      if (hdfsdm_filter->InjectedTrigger == DFSDM_FILTER_SW_TRIGGER)
 800fc02:	6b82      	ldr	r2, [r0, #56]	; 0x38
 800fc04:	b91a      	cbnz	r2, 800fc0e <DFSDM_RegConvStart+0x4e>
        hdfsdm_filter->Instance->FLTCR1 |= DFSDM_FLTCR1_JSWSTART;
 800fc06:	681a      	ldr	r2, [r3, #0]
 800fc08:	f042 0202 	orr.w	r2, r2, #2
 800fc0c:	601a      	str	r2, [r3, #0]
                                        hdfsdm_filter->InjectedChannelsNbr : 1U;
 800fc0e:	f890 3040 	ldrb.w	r3, [r0, #64]	; 0x40
 800fc12:	2b01      	cmp	r3, #1
 800fc14:	bf0c      	ite	eq
 800fc16:	6c43      	ldreq	r3, [r0, #68]	; 0x44
 800fc18:	2301      	movne	r3, #1
      hdfsdm_filter->InjConvRemaining = (hdfsdm_filter->InjectedScanMode == ENABLE) ? \
 800fc1a:	6483      	str	r3, [r0, #72]	; 0x48
                         HAL_DFSDM_FILTER_STATE_REG : HAL_DFSDM_FILTER_STATE_REG_INJ;
 800fc1c:	2304      	movs	r3, #4
  hdfsdm_filter->State = (hdfsdm_filter->State == HAL_DFSDM_FILTER_STATE_READY) ? \
 800fc1e:	f880 304c 	strb.w	r3, [r0, #76]	; 0x4c
}
 800fc22:	4770      	bx	lr

0800fc24 <HAL_DFSDM_ChannelMspInit>:
}
 800fc24:	4770      	bx	lr
 800fc26:	bf00      	nop

0800fc28 <HAL_DFSDM_ChannelInit>:
  if (hdfsdm_channel == NULL)
 800fc28:	2800      	cmp	r0, #0
 800fc2a:	f000 80ac 	beq.w	800fd86 <HAL_DFSDM_ChannelInit+0x15e>
{
 800fc2e:	b538      	push	{r3, r4, r5, lr}
  if (Instance == DFSDM1_Channel0)
 800fc30:	4a60      	ldr	r2, [pc, #384]	; (800fdb4 <HAL_DFSDM_ChannelInit+0x18c>)
  if (a_dfsdm1ChannelHandle[DFSDM_GetChannelFromInstance(hdfsdm_channel->Instance)] != NULL)
 800fc32:	6803      	ldr	r3, [r0, #0]
  if (Instance == DFSDM1_Channel0)
 800fc34:	4293      	cmp	r3, r2
 800fc36:	4604      	mov	r4, r0
 800fc38:	d07a      	beq.n	800fd30 <HAL_DFSDM_ChannelInit+0x108>
  else if (Instance == DFSDM1_Channel1)
 800fc3a:	3220      	adds	r2, #32
 800fc3c:	4293      	cmp	r3, r2
 800fc3e:	d07f      	beq.n	800fd40 <HAL_DFSDM_ChannelInit+0x118>
  else if (Instance == DFSDM1_Channel2)
 800fc40:	3220      	adds	r2, #32
 800fc42:	4293      	cmp	r3, r2
 800fc44:	f000 80a1 	beq.w	800fd8a <HAL_DFSDM_ChannelInit+0x162>
  else if (Instance == DFSDM1_Channel3)
 800fc48:	3220      	adds	r2, #32
 800fc4a:	4293      	cmp	r3, r2
 800fc4c:	f000 809f 	beq.w	800fd8e <HAL_DFSDM_ChannelInit+0x166>
  else if (Instance == DFSDM1_Channel4)
 800fc50:	3220      	adds	r2, #32
 800fc52:	4293      	cmp	r3, r2
 800fc54:	f000 80a1 	beq.w	800fd9a <HAL_DFSDM_ChannelInit+0x172>
  else if (Instance == DFSDM1_Channel5)
 800fc58:	3220      	adds	r2, #32
 800fc5a:	4293      	cmp	r3, r2
 800fc5c:	f000 8099 	beq.w	800fd92 <HAL_DFSDM_ChannelInit+0x16a>
  else if (Instance == DFSDM1_Channel6)
 800fc60:	3220      	adds	r2, #32
 800fc62:	4293      	cmp	r3, r2
 800fc64:	f000 809b 	beq.w	800fd9e <HAL_DFSDM_ChannelInit+0x176>
  else if (Instance == DFSDM1_Channel7)
 800fc68:	3220      	adds	r2, #32
  if (a_dfsdm1ChannelHandle[DFSDM_GetChannelFromInstance(hdfsdm_channel->Instance)] != NULL)
 800fc6a:	4d53      	ldr	r5, [pc, #332]	; (800fdb8 <HAL_DFSDM_ChannelInit+0x190>)
    channel = 7;
 800fc6c:	4293      	cmp	r3, r2
 800fc6e:	bf0c      	ite	eq
 800fc70:	2307      	moveq	r3, #7
 800fc72:	2300      	movne	r3, #0
  if (a_dfsdm1ChannelHandle[DFSDM_GetChannelFromInstance(hdfsdm_channel->Instance)] != NULL)
 800fc74:	f855 3023 	ldr.w	r3, [r5, r3, lsl #2]
 800fc78:	2b00      	cmp	r3, #0
 800fc7a:	d15f      	bne.n	800fd3c <HAL_DFSDM_ChannelInit+0x114>
  HAL_DFSDM_ChannelMspInit(hdfsdm_channel);
 800fc7c:	4620      	mov	r0, r4
 800fc7e:	f7ff ffd1 	bl	800fc24 <HAL_DFSDM_ChannelMspInit>
  v_dfsdm1ChannelCounter++;
 800fc82:	6a2b      	ldr	r3, [r5, #32]
 800fc84:	3301      	adds	r3, #1
 800fc86:	622b      	str	r3, [r5, #32]
  if (v_dfsdm1ChannelCounter == 1U)
 800fc88:	6a2b      	ldr	r3, [r5, #32]
 800fc8a:	2b01      	cmp	r3, #1
 800fc8c:	d05a      	beq.n	800fd44 <HAL_DFSDM_ChannelInit+0x11c>
  hdfsdm_channel->Instance->CHCFGR1 &= ~(DFSDM_CHCFGR1_DATPACK | DFSDM_CHCFGR1_DATMPX |
 800fc8e:	6823      	ldr	r3, [r4, #0]
  hdfsdm_channel->Instance->CHCFGR1 |= (hdfsdm_channel->Init.Input.Multiplexer |
 800fc90:	6922      	ldr	r2, [r4, #16]
  hdfsdm_channel->Instance->CHCFGR1 &= ~(DFSDM_CHCFGR1_DATPACK | DFSDM_CHCFGR1_DATMPX |
 800fc92:	6819      	ldr	r1, [r3, #0]
  hdfsdm_channel->Instance->CHCFGR1 |= (hdfsdm_channel->Init.Input.Multiplexer |
 800fc94:	6960      	ldr	r0, [r4, #20]
  hdfsdm_channel->Instance->CHCFGR1 &= ~(DFSDM_CHCFGR1_DATPACK | DFSDM_CHCFGR1_DATMPX |
 800fc96:	f421 4171 	bic.w	r1, r1, #61696	; 0xf100
 800fc9a:	6019      	str	r1, [r3, #0]
  hdfsdm_channel->Instance->CHCFGR1 |= (hdfsdm_channel->Init.Input.Multiplexer |
 800fc9c:	4302      	orrs	r2, r0
                                        hdfsdm_channel->Init.Input.DataPacking |
 800fc9e:	69a0      	ldr	r0, [r4, #24]
  hdfsdm_channel->Instance->CHCFGR1 |= (hdfsdm_channel->Init.Input.Multiplexer |
 800fca0:	6819      	ldr	r1, [r3, #0]
                                        hdfsdm_channel->Init.Input.DataPacking |
 800fca2:	4302      	orrs	r2, r0
  hdfsdm_channel->Instance->CHCFGR1 |= (hdfsdm_channel->Init.Input.Multiplexer |
 800fca4:	430a      	orrs	r2, r1
 800fca6:	601a      	str	r2, [r3, #0]
  hdfsdm_channel->Instance->CHCFGR1 &= ~(DFSDM_CHCFGR1_SITP | DFSDM_CHCFGR1_SPICKSEL);
 800fca8:	6819      	ldr	r1, [r3, #0]
  hdfsdm_channel->Instance->CHCFGR1 |= (hdfsdm_channel->Init.SerialInterface.Type |
 800fcaa:	69e2      	ldr	r2, [r4, #28]
 800fcac:	6a20      	ldr	r0, [r4, #32]
  hdfsdm_channel->Instance->CHCFGR1 &= ~(DFSDM_CHCFGR1_SITP | DFSDM_CHCFGR1_SPICKSEL);
 800fcae:	f021 010f 	bic.w	r1, r1, #15
 800fcb2:	6019      	str	r1, [r3, #0]
  hdfsdm_channel->Instance->CHCFGR1 |= (hdfsdm_channel->Init.SerialInterface.Type |
 800fcb4:	6819      	ldr	r1, [r3, #0]
 800fcb6:	4302      	orrs	r2, r0
 800fcb8:	430a      	orrs	r2, r1
 800fcba:	601a      	str	r2, [r3, #0]
  hdfsdm_channel->Instance->CHAWSCDR &= ~(DFSDM_CHAWSCDR_AWFORD | DFSDM_CHAWSCDR_AWFOSR);
 800fcbc:	689a      	ldr	r2, [r3, #8]
                                         ((hdfsdm_channel->Init.Awd.Oversampling - 1U) << DFSDM_CHAWSCDR_AWFOSR_Pos));
 800fcbe:	6aa1      	ldr	r1, [r4, #40]	; 0x28
  hdfsdm_channel->Instance->CHAWSCDR |= (hdfsdm_channel->Init.Awd.FilterOrder |
 800fcc0:	6a60      	ldr	r0, [r4, #36]	; 0x24
  hdfsdm_channel->Instance->CHAWSCDR &= ~(DFSDM_CHAWSCDR_AWFORD | DFSDM_CHAWSCDR_AWFOSR);
 800fcc2:	f422 025f 	bic.w	r2, r2, #14614528	; 0xdf0000
 800fcc6:	609a      	str	r2, [r3, #8]
  hdfsdm_channel->Instance->CHAWSCDR |= (hdfsdm_channel->Init.Awd.FilterOrder |
 800fcc8:	689a      	ldr	r2, [r3, #8]
                                         ((hdfsdm_channel->Init.Awd.Oversampling - 1U) << DFSDM_CHAWSCDR_AWFOSR_Pos));
 800fcca:	3901      	subs	r1, #1
  hdfsdm_channel->Instance->CHAWSCDR |= (hdfsdm_channel->Init.Awd.FilterOrder |
 800fccc:	4302      	orrs	r2, r0
 800fcce:	ea42 4201 	orr.w	r2, r2, r1, lsl #16
 800fcd2:	609a      	str	r2, [r3, #8]
  hdfsdm_channel->Instance->CHCFGR2 &= ~(DFSDM_CHCFGR2_OFFSET | DFSDM_CHCFGR2_DTRBS);
 800fcd4:	6859      	ldr	r1, [r3, #4]
                                        (hdfsdm_channel->Init.RightBitShift << DFSDM_CHCFGR2_DTRBS_Pos));
 800fcd6:	6b20      	ldr	r0, [r4, #48]	; 0x30
  hdfsdm_channel->Instance->CHCFGR2 &= ~(DFSDM_CHCFGR2_OFFSET | DFSDM_CHCFGR2_DTRBS);
 800fcd8:	f001 0107 	and.w	r1, r1, #7
 800fcdc:	6059      	str	r1, [r3, #4]
  hdfsdm_channel->Instance->CHCFGR2 |= (((uint32_t) hdfsdm_channel->Init.Offset << DFSDM_CHCFGR2_OFFSET_Pos) |
 800fcde:	685a      	ldr	r2, [r3, #4]
 800fce0:	6ae1      	ldr	r1, [r4, #44]	; 0x2c
 800fce2:	ea42 02c0 	orr.w	r2, r2, r0, lsl #3
 800fce6:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
 800fcea:	605a      	str	r2, [r3, #4]
  hdfsdm_channel->Instance->CHCFGR1 |= DFSDM_CHCFGR1_CHEN;
 800fcec:	6819      	ldr	r1, [r3, #0]
  if (Instance == DFSDM1_Channel0)
 800fcee:	4831      	ldr	r0, [pc, #196]	; (800fdb4 <HAL_DFSDM_ChannelInit+0x18c>)
  hdfsdm_channel->Instance->CHCFGR1 |= DFSDM_CHCFGR1_CHEN;
 800fcf0:	f041 0180 	orr.w	r1, r1, #128	; 0x80
  hdfsdm_channel->State = HAL_DFSDM_CHANNEL_STATE_READY;
 800fcf4:	2201      	movs	r2, #1
  if (Instance == DFSDM1_Channel0)
 800fcf6:	4283      	cmp	r3, r0
  hdfsdm_channel->Instance->CHCFGR1 |= DFSDM_CHCFGR1_CHEN;
 800fcf8:	6019      	str	r1, [r3, #0]
  hdfsdm_channel->State = HAL_DFSDM_CHANNEL_STATE_READY;
 800fcfa:	f884 2034 	strb.w	r2, [r4, #52]	; 0x34
  if (Instance == DFSDM1_Channel0)
 800fcfe:	d03d      	beq.n	800fd7c <HAL_DFSDM_ChannelInit+0x154>
  else if (Instance == DFSDM1_Channel1)
 800fd00:	492e      	ldr	r1, [pc, #184]	; (800fdbc <HAL_DFSDM_ChannelInit+0x194>)
 800fd02:	428b      	cmp	r3, r1
 800fd04:	d03b      	beq.n	800fd7e <HAL_DFSDM_ChannelInit+0x156>
  else if (Instance == DFSDM1_Channel2)
 800fd06:	4a2e      	ldr	r2, [pc, #184]	; (800fdc0 <HAL_DFSDM_ChannelInit+0x198>)
 800fd08:	4293      	cmp	r3, r2
 800fd0a:	d04a      	beq.n	800fda2 <HAL_DFSDM_ChannelInit+0x17a>
  else if (Instance == DFSDM1_Channel3)
 800fd0c:	3220      	adds	r2, #32
 800fd0e:	4293      	cmp	r3, r2
 800fd10:	d049      	beq.n	800fda6 <HAL_DFSDM_ChannelInit+0x17e>
  else if (Instance == DFSDM1_Channel4)
 800fd12:	3220      	adds	r2, #32
 800fd14:	4293      	cmp	r3, r2
 800fd16:	d048      	beq.n	800fdaa <HAL_DFSDM_ChannelInit+0x182>
  else if (Instance == DFSDM1_Channel5)
 800fd18:	3220      	adds	r2, #32
 800fd1a:	4293      	cmp	r3, r2
 800fd1c:	d047      	beq.n	800fdae <HAL_DFSDM_ChannelInit+0x186>
  else if (Instance == DFSDM1_Channel6)
 800fd1e:	3220      	adds	r2, #32
 800fd20:	4293      	cmp	r3, r2
 800fd22:	d038      	beq.n	800fd96 <HAL_DFSDM_ChannelInit+0x16e>
  else if (Instance == DFSDM1_Channel7)
 800fd24:	3220      	adds	r2, #32
    channel = 7;
 800fd26:	4293      	cmp	r3, r2
 800fd28:	bf0c      	ite	eq
 800fd2a:	2207      	moveq	r2, #7
 800fd2c:	2200      	movne	r2, #0
 800fd2e:	e026      	b.n	800fd7e <HAL_DFSDM_ChannelInit+0x156>
    channel = 0;
 800fd30:	2300      	movs	r3, #0
  if (a_dfsdm1ChannelHandle[DFSDM_GetChannelFromInstance(hdfsdm_channel->Instance)] != NULL)
 800fd32:	4d21      	ldr	r5, [pc, #132]	; (800fdb8 <HAL_DFSDM_ChannelInit+0x190>)
 800fd34:	f855 3023 	ldr.w	r3, [r5, r3, lsl #2]
 800fd38:	2b00      	cmp	r3, #0
 800fd3a:	d09f      	beq.n	800fc7c <HAL_DFSDM_ChannelInit+0x54>
    return HAL_ERROR;
 800fd3c:	2001      	movs	r0, #1
}
 800fd3e:	bd38      	pop	{r3, r4, r5, pc}
    channel = 1;
 800fd40:	2301      	movs	r3, #1
 800fd42:	e7f6      	b.n	800fd32 <HAL_DFSDM_ChannelInit+0x10a>
    DFSDM1_Channel0->CHCFGR1 &= ~(DFSDM_CHCFGR1_CKOUTSRC);
 800fd44:	4b1b      	ldr	r3, [pc, #108]	; (800fdb4 <HAL_DFSDM_ChannelInit+0x18c>)
 800fd46:	681a      	ldr	r2, [r3, #0]
 800fd48:	f022 4280 	bic.w	r2, r2, #1073741824	; 0x40000000
 800fd4c:	601a      	str	r2, [r3, #0]
    DFSDM1_Channel0->CHCFGR1 |= hdfsdm_channel->Init.OutputClock.Selection;
 800fd4e:	681a      	ldr	r2, [r3, #0]
 800fd50:	68a1      	ldr	r1, [r4, #8]
 800fd52:	430a      	orrs	r2, r1
 800fd54:	601a      	str	r2, [r3, #0]
    DFSDM1_Channel0->CHCFGR1 &= ~(DFSDM_CHCFGR1_CKOUTDIV);
 800fd56:	681a      	ldr	r2, [r3, #0]
 800fd58:	f422 027f 	bic.w	r2, r2, #16711680	; 0xff0000
 800fd5c:	601a      	str	r2, [r3, #0]
    if (hdfsdm_channel->Init.OutputClock.Activation == ENABLE)
 800fd5e:	7922      	ldrb	r2, [r4, #4]
 800fd60:	2a01      	cmp	r2, #1
 800fd62:	d105      	bne.n	800fd70 <HAL_DFSDM_ChannelInit+0x148>
      DFSDM1_Channel0->CHCFGR1 |= (uint32_t)((hdfsdm_channel->Init.OutputClock.Divider - 1U) <<
 800fd64:	68e1      	ldr	r1, [r4, #12]
 800fd66:	681a      	ldr	r2, [r3, #0]
 800fd68:	3901      	subs	r1, #1
 800fd6a:	ea42 4201 	orr.w	r2, r2, r1, lsl #16
 800fd6e:	601a      	str	r2, [r3, #0]
    DFSDM1_Channel0->CHCFGR1 |= DFSDM_CHCFGR1_DFSDMEN;
 800fd70:	4a10      	ldr	r2, [pc, #64]	; (800fdb4 <HAL_DFSDM_ChannelInit+0x18c>)
 800fd72:	6813      	ldr	r3, [r2, #0]
 800fd74:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 800fd78:	6013      	str	r3, [r2, #0]
 800fd7a:	e788      	b.n	800fc8e <HAL_DFSDM_ChannelInit+0x66>
    channel = 0;
 800fd7c:	2200      	movs	r2, #0
  a_dfsdm1ChannelHandle[DFSDM_GetChannelFromInstance(hdfsdm_channel->Instance)] = hdfsdm_channel;
 800fd7e:	f845 4022 	str.w	r4, [r5, r2, lsl #2]
  return HAL_OK;
 800fd82:	2000      	movs	r0, #0
}
 800fd84:	bd38      	pop	{r3, r4, r5, pc}
    return HAL_ERROR;
 800fd86:	2001      	movs	r0, #1
}
 800fd88:	4770      	bx	lr
    channel = 2;
 800fd8a:	2302      	movs	r3, #2
 800fd8c:	e7d1      	b.n	800fd32 <HAL_DFSDM_ChannelInit+0x10a>
    channel = 3;
 800fd8e:	2303      	movs	r3, #3
 800fd90:	e7cf      	b.n	800fd32 <HAL_DFSDM_ChannelInit+0x10a>
    channel = 5;
 800fd92:	2305      	movs	r3, #5
 800fd94:	e7cd      	b.n	800fd32 <HAL_DFSDM_ChannelInit+0x10a>
    channel = 6;
 800fd96:	2206      	movs	r2, #6
 800fd98:	e7f1      	b.n	800fd7e <HAL_DFSDM_ChannelInit+0x156>
    channel = 4;
 800fd9a:	2304      	movs	r3, #4
 800fd9c:	e7c9      	b.n	800fd32 <HAL_DFSDM_ChannelInit+0x10a>
    channel = 6;
 800fd9e:	2306      	movs	r3, #6
 800fda0:	e7c7      	b.n	800fd32 <HAL_DFSDM_ChannelInit+0x10a>
    channel = 2;
 800fda2:	2202      	movs	r2, #2
 800fda4:	e7eb      	b.n	800fd7e <HAL_DFSDM_ChannelInit+0x156>
    channel = 3;
 800fda6:	2203      	movs	r2, #3
 800fda8:	e7e9      	b.n	800fd7e <HAL_DFSDM_ChannelInit+0x156>
    channel = 4;
 800fdaa:	2204      	movs	r2, #4
 800fdac:	e7e7      	b.n	800fd7e <HAL_DFSDM_ChannelInit+0x156>
    channel = 5;
 800fdae:	2205      	movs	r2, #5
 800fdb0:	e7e5      	b.n	800fd7e <HAL_DFSDM_ChannelInit+0x156>
 800fdb2:	bf00      	nop
 800fdb4:	40016000 	.word	0x40016000
 800fdb8:	200032ec 	.word	0x200032ec
 800fdbc:	40016020 	.word	0x40016020
 800fdc0:	40016040 	.word	0x40016040

0800fdc4 <HAL_DFSDM_ChannelMspDeInit>:
 800fdc4:	4770      	bx	lr
 800fdc6:	bf00      	nop

0800fdc8 <HAL_DFSDM_ChannelDeInit>:
  if (hdfsdm_channel == NULL)
 800fdc8:	2800      	cmp	r0, #0
 800fdca:	d05d      	beq.n	800fe88 <HAL_DFSDM_ChannelDeInit+0xc0>
{
 800fdcc:	b538      	push	{r3, r4, r5, lr}
  if (Instance == DFSDM1_Channel0)
 800fdce:	4a3c      	ldr	r2, [pc, #240]	; (800fec0 <HAL_DFSDM_ChannelDeInit+0xf8>)
  if (a_dfsdm1ChannelHandle[DFSDM_GetChannelFromInstance(hdfsdm_channel->Instance)] == NULL)
 800fdd0:	6803      	ldr	r3, [r0, #0]
  if (Instance == DFSDM1_Channel0)
 800fdd2:	4293      	cmp	r3, r2
 800fdd4:	4604      	mov	r4, r0
 800fdd6:	d01c      	beq.n	800fe12 <HAL_DFSDM_ChannelDeInit+0x4a>
  else if (Instance == DFSDM1_Channel1)
 800fdd8:	3220      	adds	r2, #32
 800fdda:	4293      	cmp	r3, r2
 800fddc:	d052      	beq.n	800fe84 <HAL_DFSDM_ChannelDeInit+0xbc>
  else if (Instance == DFSDM1_Channel2)
 800fdde:	3220      	adds	r2, #32
 800fde0:	4293      	cmp	r3, r2
 800fde2:	d058      	beq.n	800fe96 <HAL_DFSDM_ChannelDeInit+0xce>
  else if (Instance == DFSDM1_Channel3)
 800fde4:	3220      	adds	r2, #32
 800fde6:	4293      	cmp	r3, r2
 800fde8:	d059      	beq.n	800fe9e <HAL_DFSDM_ChannelDeInit+0xd6>
  else if (Instance == DFSDM1_Channel4)
 800fdea:	3220      	adds	r2, #32
 800fdec:	4293      	cmp	r3, r2
 800fdee:	d05e      	beq.n	800feae <HAL_DFSDM_ChannelDeInit+0xe6>
  else if (Instance == DFSDM1_Channel5)
 800fdf0:	3220      	adds	r2, #32
 800fdf2:	4293      	cmp	r3, r2
 800fdf4:	d059      	beq.n	800feaa <HAL_DFSDM_ChannelDeInit+0xe2>
  else if (Instance == DFSDM1_Channel6)
 800fdf6:	3220      	adds	r2, #32
 800fdf8:	4293      	cmp	r3, r2
 800fdfa:	d05c      	beq.n	800feb6 <HAL_DFSDM_ChannelDeInit+0xee>
  else if (Instance == DFSDM1_Channel7)
 800fdfc:	3220      	adds	r2, #32
  if (a_dfsdm1ChannelHandle[DFSDM_GetChannelFromInstance(hdfsdm_channel->Instance)] == NULL)
 800fdfe:	4d31      	ldr	r5, [pc, #196]	; (800fec4 <HAL_DFSDM_ChannelDeInit+0xfc>)
    channel = 0;
 800fe00:	4293      	cmp	r3, r2
 800fe02:	bf0c      	ite	eq
 800fe04:	2207      	moveq	r2, #7
 800fe06:	2200      	movne	r2, #0
  if (a_dfsdm1ChannelHandle[DFSDM_GetChannelFromInstance(hdfsdm_channel->Instance)] == NULL)
 800fe08:	f855 2022 	ldr.w	r2, [r5, r2, lsl #2]
 800fe0c:	b93a      	cbnz	r2, 800fe1e <HAL_DFSDM_ChannelDeInit+0x56>
    return HAL_ERROR;
 800fe0e:	2001      	movs	r0, #1
}
 800fe10:	bd38      	pop	{r3, r4, r5, pc}
    channel = 0;
 800fe12:	2200      	movs	r2, #0
  if (a_dfsdm1ChannelHandle[DFSDM_GetChannelFromInstance(hdfsdm_channel->Instance)] == NULL)
 800fe14:	4d2b      	ldr	r5, [pc, #172]	; (800fec4 <HAL_DFSDM_ChannelDeInit+0xfc>)
 800fe16:	f855 2022 	ldr.w	r2, [r5, r2, lsl #2]
 800fe1a:	2a00      	cmp	r2, #0
 800fe1c:	d0f7      	beq.n	800fe0e <HAL_DFSDM_ChannelDeInit+0x46>
  hdfsdm_channel->Instance->CHCFGR1 &= ~(DFSDM_CHCFGR1_CHEN);
 800fe1e:	681a      	ldr	r2, [r3, #0]
 800fe20:	f022 0280 	bic.w	r2, r2, #128	; 0x80
 800fe24:	601a      	str	r2, [r3, #0]
  v_dfsdm1ChannelCounter--;
 800fe26:	6a2b      	ldr	r3, [r5, #32]
 800fe28:	3b01      	subs	r3, #1
 800fe2a:	622b      	str	r3, [r5, #32]
  if (v_dfsdm1ChannelCounter == 0U)
 800fe2c:	6a2b      	ldr	r3, [r5, #32]
 800fe2e:	b923      	cbnz	r3, 800fe3a <HAL_DFSDM_ChannelDeInit+0x72>
    DFSDM1_Channel0->CHCFGR1 &= ~(DFSDM_CHCFGR1_DFSDMEN);
 800fe30:	4a23      	ldr	r2, [pc, #140]	; (800fec0 <HAL_DFSDM_ChannelDeInit+0xf8>)
 800fe32:	6813      	ldr	r3, [r2, #0]
 800fe34:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
 800fe38:	6013      	str	r3, [r2, #0]
  HAL_DFSDM_ChannelMspDeInit(hdfsdm_channel);
 800fe3a:	4620      	mov	r0, r4
 800fe3c:	f7ff ffc2 	bl	800fdc4 <HAL_DFSDM_ChannelMspDeInit>
  a_dfsdm1ChannelHandle[DFSDM_GetChannelFromInstance(hdfsdm_channel->Instance)] = (DFSDM_Channel_HandleTypeDef *) NULL;
 800fe40:	6822      	ldr	r2, [r4, #0]
  if (Instance == DFSDM1_Channel0)
 800fe42:	491f      	ldr	r1, [pc, #124]	; (800fec0 <HAL_DFSDM_ChannelDeInit+0xf8>)
  hdfsdm_channel->State = HAL_DFSDM_CHANNEL_STATE_RESET;
 800fe44:	2300      	movs	r3, #0
  if (Instance == DFSDM1_Channel0)
 800fe46:	428a      	cmp	r2, r1
  hdfsdm_channel->State = HAL_DFSDM_CHANNEL_STATE_RESET;
 800fe48:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
  if (Instance == DFSDM1_Channel0)
 800fe4c:	d016      	beq.n	800fe7c <HAL_DFSDM_ChannelDeInit+0xb4>
  else if (Instance == DFSDM1_Channel1)
 800fe4e:	4b1e      	ldr	r3, [pc, #120]	; (800fec8 <HAL_DFSDM_ChannelDeInit+0x100>)
 800fe50:	429a      	cmp	r2, r3
 800fe52:	d01b      	beq.n	800fe8c <HAL_DFSDM_ChannelDeInit+0xc4>
  else if (Instance == DFSDM1_Channel2)
 800fe54:	3320      	adds	r3, #32
 800fe56:	429a      	cmp	r2, r3
 800fe58:	d01f      	beq.n	800fe9a <HAL_DFSDM_ChannelDeInit+0xd2>
  else if (Instance == DFSDM1_Channel3)
 800fe5a:	3320      	adds	r3, #32
 800fe5c:	429a      	cmp	r2, r3
 800fe5e:	d020      	beq.n	800fea2 <HAL_DFSDM_ChannelDeInit+0xda>
  else if (Instance == DFSDM1_Channel4)
 800fe60:	3320      	adds	r3, #32
 800fe62:	429a      	cmp	r2, r3
 800fe64:	d01f      	beq.n	800fea6 <HAL_DFSDM_ChannelDeInit+0xde>
  else if (Instance == DFSDM1_Channel5)
 800fe66:	3320      	adds	r3, #32
 800fe68:	429a      	cmp	r2, r3
 800fe6a:	d022      	beq.n	800feb2 <HAL_DFSDM_ChannelDeInit+0xea>
  else if (Instance == DFSDM1_Channel6)
 800fe6c:	3320      	adds	r3, #32
 800fe6e:	429a      	cmp	r2, r3
 800fe70:	d023      	beq.n	800feba <HAL_DFSDM_ChannelDeInit+0xf2>
  else if (Instance == DFSDM1_Channel7)
 800fe72:	3320      	adds	r3, #32
    channel = 7;
 800fe74:	429a      	cmp	r2, r3
 800fe76:	bf0c      	ite	eq
 800fe78:	2307      	moveq	r3, #7
 800fe7a:	2300      	movne	r3, #0
  a_dfsdm1ChannelHandle[DFSDM_GetChannelFromInstance(hdfsdm_channel->Instance)] = (DFSDM_Channel_HandleTypeDef *) NULL;
 800fe7c:	2000      	movs	r0, #0
 800fe7e:	f845 0023 	str.w	r0, [r5, r3, lsl #2]
}
 800fe82:	bd38      	pop	{r3, r4, r5, pc}
    channel = 1;
 800fe84:	2201      	movs	r2, #1
 800fe86:	e7c5      	b.n	800fe14 <HAL_DFSDM_ChannelDeInit+0x4c>
    return HAL_ERROR;
 800fe88:	2001      	movs	r0, #1
}
 800fe8a:	4770      	bx	lr
    channel = 1;
 800fe8c:	2301      	movs	r3, #1
  a_dfsdm1ChannelHandle[DFSDM_GetChannelFromInstance(hdfsdm_channel->Instance)] = (DFSDM_Channel_HandleTypeDef *) NULL;
 800fe8e:	2000      	movs	r0, #0
 800fe90:	f845 0023 	str.w	r0, [r5, r3, lsl #2]
  return HAL_OK;
 800fe94:	e7f5      	b.n	800fe82 <HAL_DFSDM_ChannelDeInit+0xba>
    channel = 2;
 800fe96:	2202      	movs	r2, #2
 800fe98:	e7bc      	b.n	800fe14 <HAL_DFSDM_ChannelDeInit+0x4c>
 800fe9a:	2302      	movs	r3, #2
 800fe9c:	e7ee      	b.n	800fe7c <HAL_DFSDM_ChannelDeInit+0xb4>
    channel = 3;
 800fe9e:	2203      	movs	r2, #3
 800fea0:	e7b8      	b.n	800fe14 <HAL_DFSDM_ChannelDeInit+0x4c>
 800fea2:	2303      	movs	r3, #3
 800fea4:	e7ea      	b.n	800fe7c <HAL_DFSDM_ChannelDeInit+0xb4>
    channel = 4;
 800fea6:	2304      	movs	r3, #4
 800fea8:	e7e8      	b.n	800fe7c <HAL_DFSDM_ChannelDeInit+0xb4>
    channel = 5;
 800feaa:	2205      	movs	r2, #5
 800feac:	e7b2      	b.n	800fe14 <HAL_DFSDM_ChannelDeInit+0x4c>
    channel = 4;
 800feae:	2204      	movs	r2, #4
 800feb0:	e7b0      	b.n	800fe14 <HAL_DFSDM_ChannelDeInit+0x4c>
    channel = 5;
 800feb2:	2305      	movs	r3, #5
 800feb4:	e7e2      	b.n	800fe7c <HAL_DFSDM_ChannelDeInit+0xb4>
    channel = 6;
 800feb6:	2206      	movs	r2, #6
 800feb8:	e7ac      	b.n	800fe14 <HAL_DFSDM_ChannelDeInit+0x4c>
 800feba:	2306      	movs	r3, #6
 800febc:	e7de      	b.n	800fe7c <HAL_DFSDM_ChannelDeInit+0xb4>
 800febe:	bf00      	nop
 800fec0:	40016000 	.word	0x40016000
 800fec4:	200032ec 	.word	0x200032ec
 800fec8:	40016020 	.word	0x40016020

0800fecc <HAL_DFSDM_FilterMspInit>:
 800fecc:	4770      	bx	lr
 800fece:	bf00      	nop

0800fed0 <HAL_DFSDM_FilterInit>:
  if (hdfsdm_filter == NULL)
 800fed0:	2800      	cmp	r0, #0
 800fed2:	d070      	beq.n	800ffb6 <HAL_DFSDM_FilterInit+0xe6>
  if ((hdfsdm_filter->Instance == DFSDM1_Filter0) &&
 800fed4:	4b39      	ldr	r3, [pc, #228]	; (800ffbc <HAL_DFSDM_FilterInit+0xec>)
 800fed6:	6802      	ldr	r2, [r0, #0]
 800fed8:	429a      	cmp	r2, r3
{
 800feda:	b510      	push	{r4, lr}
 800fedc:	4604      	mov	r4, r0
  if ((hdfsdm_filter->Instance == DFSDM1_Filter0) &&
 800fede:	d05e      	beq.n	800ff9e <HAL_DFSDM_FilterInit+0xce>
  hdfsdm_filter->RegularContMode     = DFSDM_CONTINUOUS_CONV_OFF;
 800fee0:	2300      	movs	r3, #0
  hdfsdm_filter->InjectedChannelsNbr = 1;
 800fee2:	2201      	movs	r2, #1
  hdfsdm_filter->InjConvRemaining    = 1;
 800fee4:	e9c4 2211 	strd	r2, r2, [r4, #68]	; 0x44
  hdfsdm_filter->RegularContMode     = DFSDM_CONTINUOUS_CONV_OFF;
 800fee8:	6323      	str	r3, [r4, #48]	; 0x30
  hdfsdm_filter->ErrorCode           = DFSDM_FILTER_ERROR_NONE;
 800feea:	6523      	str	r3, [r4, #80]	; 0x50
  HAL_DFSDM_FilterMspInit(hdfsdm_filter);
 800feec:	4620      	mov	r0, r4
 800feee:	f7ff ffed 	bl	800fecc <HAL_DFSDM_FilterMspInit>
  hdfsdm_filter->Instance->FLTCR1 &= ~(DFSDM_FLTCR1_RSYNC);
 800fef2:	6823      	ldr	r3, [r4, #0]
 800fef4:	681a      	ldr	r2, [r3, #0]
 800fef6:	f422 2200 	bic.w	r2, r2, #524288	; 0x80000
 800fefa:	601a      	str	r2, [r3, #0]
  if (hdfsdm_filter->Init.RegularParam.FastMode == ENABLE)
 800fefc:	7a22      	ldrb	r2, [r4, #8]
 800fefe:	2a01      	cmp	r2, #1
    hdfsdm_filter->Instance->FLTCR1 |= DFSDM_FLTCR1_FAST;
 800ff00:	681a      	ldr	r2, [r3, #0]
 800ff02:	bf0c      	ite	eq
 800ff04:	f042 5200 	orreq.w	r2, r2, #536870912	; 0x20000000
    hdfsdm_filter->Instance->FLTCR1 &= ~(DFSDM_FLTCR1_FAST);
 800ff08:	f022 5200 	bicne.w	r2, r2, #536870912	; 0x20000000
 800ff0c:	601a      	str	r2, [r3, #0]
  if (hdfsdm_filter->Init.RegularParam.DmaMode == ENABLE)
 800ff0e:	7a62      	ldrb	r2, [r4, #9]
 800ff10:	2a01      	cmp	r2, #1
    hdfsdm_filter->Instance->FLTCR1 |= DFSDM_FLTCR1_RDMAEN;
 800ff12:	681a      	ldr	r2, [r3, #0]
 800ff14:	bf0c      	ite	eq
 800ff16:	f442 1200 	orreq.w	r2, r2, #2097152	; 0x200000
    hdfsdm_filter->Instance->FLTCR1 &= ~(DFSDM_FLTCR1_RDMAEN);
 800ff1a:	f422 1200 	bicne.w	r2, r2, #2097152	; 0x200000
 800ff1e:	601a      	str	r2, [r3, #0]
  hdfsdm_filter->Instance->FLTCR1 &= ~(DFSDM_FLTCR1_JSYNC | DFSDM_FLTCR1_JEXTEN | DFSDM_FLTCR1_JEXTSEL);
 800ff20:	681a      	ldr	r2, [r3, #0]
  if (hdfsdm_filter->Init.InjectedParam.Trigger == DFSDM_FILTER_EXT_TRIGGER)
 800ff22:	68e1      	ldr	r1, [r4, #12]
  hdfsdm_filter->Instance->FLTCR1 &= ~(DFSDM_FLTCR1_JSYNC | DFSDM_FLTCR1_JEXTEN | DFSDM_FLTCR1_JEXTSEL);
 800ff24:	f422 42ce 	bic.w	r2, r2, #26368	; 0x6700
 800ff28:	f022 0208 	bic.w	r2, r2, #8
  if (hdfsdm_filter->Init.InjectedParam.Trigger == DFSDM_FILTER_EXT_TRIGGER)
 800ff2c:	2902      	cmp	r1, #2
  hdfsdm_filter->Instance->FLTCR1 &= ~(DFSDM_FLTCR1_JSYNC | DFSDM_FLTCR1_JEXTEN | DFSDM_FLTCR1_JEXTSEL);
 800ff2e:	601a      	str	r2, [r3, #0]
  if (hdfsdm_filter->Init.InjectedParam.Trigger == DFSDM_FILTER_EXT_TRIGGER)
 800ff30:	d03c      	beq.n	800ffac <HAL_DFSDM_FilterInit+0xdc>
  if (hdfsdm_filter->Init.InjectedParam.ScanMode == ENABLE)
 800ff32:	f894 c010 	ldrb.w	ip, [r4, #16]
    hdfsdm_filter->Instance->FLTCR1 |= DFSDM_FLTCR1_JSCAN;
 800ff36:	681a      	ldr	r2, [r3, #0]
  if (hdfsdm_filter->Init.InjectedParam.ScanMode == ENABLE)
 800ff38:	f1bc 0f01 	cmp.w	ip, #1
    hdfsdm_filter->Instance->FLTCR1 |= DFSDM_FLTCR1_JSCAN;
 800ff3c:	bf0c      	ite	eq
 800ff3e:	f042 0210 	orreq.w	r2, r2, #16
    hdfsdm_filter->Instance->FLTCR1 &= ~(DFSDM_FLTCR1_JSCAN);
 800ff42:	f022 0210 	bicne.w	r2, r2, #16
 800ff46:	601a      	str	r2, [r3, #0]
  if (hdfsdm_filter->Init.InjectedParam.DmaMode == ENABLE)
 800ff48:	7c62      	ldrb	r2, [r4, #17]
 800ff4a:	2a01      	cmp	r2, #1
    hdfsdm_filter->Instance->FLTCR1 |= DFSDM_FLTCR1_JDMAEN;
 800ff4c:	681a      	ldr	r2, [r3, #0]
 800ff4e:	bf0c      	ite	eq
 800ff50:	f042 0220 	orreq.w	r2, r2, #32
    hdfsdm_filter->Instance->FLTCR1 &= ~(DFSDM_FLTCR1_JDMAEN);
 800ff54:	f022 0220 	bicne.w	r2, r2, #32
 800ff58:	601a      	str	r2, [r3, #0]
  hdfsdm_filter->Instance->FLTFCR &= ~(DFSDM_FLTFCR_FORD | DFSDM_FLTFCR_FOSR | DFSDM_FLTFCR_IOSR);
 800ff5a:	695a      	ldr	r2, [r3, #20]
 800ff5c:	f022 4263 	bic.w	r2, r2, #3808428032	; 0xe3000000
 800ff60:	f002 22ff 	and.w	r2, r2, #4278255360	; 0xff00ff00
 800ff64:	615a      	str	r2, [r3, #20]
                                      (hdfsdm_filter->Init.FilterParam.IntOversampling - 1U));
 800ff66:	6a62      	ldr	r2, [r4, #36]	; 0x24
  hdfsdm_filter->Instance->FLTFCR |= (hdfsdm_filter->Init.FilterParam.SincOrder |
 800ff68:	6958      	ldr	r0, [r3, #20]
                                      (hdfsdm_filter->Init.FilterParam.IntOversampling - 1U));
 800ff6a:	3a01      	subs	r2, #1
  hdfsdm_filter->Instance->FLTFCR |= (hdfsdm_filter->Init.FilterParam.SincOrder |
 800ff6c:	4302      	orrs	r2, r0
 800ff6e:	69e0      	ldr	r0, [r4, #28]
 800ff70:	4302      	orrs	r2, r0
                                      ((hdfsdm_filter->Init.FilterParam.Oversampling - 1U) << DFSDM_FLTFCR_FOSR_Pos) |
 800ff72:	6a20      	ldr	r0, [r4, #32]
 800ff74:	3801      	subs	r0, #1
  hdfsdm_filter->Instance->FLTFCR |= (hdfsdm_filter->Init.FilterParam.SincOrder |
 800ff76:	ea42 4200 	orr.w	r2, r2, r0, lsl #16
 800ff7a:	615a      	str	r2, [r3, #20]
  hdfsdm_filter->InjectedScanMode = hdfsdm_filter->Init.InjectedParam.ScanMode;
 800ff7c:	f884 c040 	strb.w	ip, [r4, #64]	; 0x40
  hdfsdm_filter->Instance->FLTCR1 |= DFSDM_FLTCR1_DFEN;
 800ff80:	681a      	ldr	r2, [r3, #0]
  hdfsdm_filter->RegularTrigger   = hdfsdm_filter->Init.RegularParam.Trigger;
 800ff82:	6860      	ldr	r0, [r4, #4]
  hdfsdm_filter->Instance->FLTCR1 |= DFSDM_FLTCR1_DFEN;
 800ff84:	f042 0201 	orr.w	r2, r2, #1
  hdfsdm_filter->InjectedTrigger  = hdfsdm_filter->Init.InjectedParam.Trigger;
 800ff88:	e9c4 010d 	strd	r0, r1, [r4, #52]	; 0x34
  hdfsdm_filter->State = HAL_DFSDM_FILTER_STATE_READY;
 800ff8c:	f04f 0c01 	mov.w	ip, #1
  hdfsdm_filter->ExtTriggerEdge   = hdfsdm_filter->Init.InjectedParam.ExtTriggerEdge;
 800ff90:	69a1      	ldr	r1, [r4, #24]
 800ff92:	63e1      	str	r1, [r4, #60]	; 0x3c
  return HAL_OK;
 800ff94:	2000      	movs	r0, #0
  hdfsdm_filter->Instance->FLTCR1 |= DFSDM_FLTCR1_DFEN;
 800ff96:	601a      	str	r2, [r3, #0]
  hdfsdm_filter->State = HAL_DFSDM_FILTER_STATE_READY;
 800ff98:	f884 c04c 	strb.w	ip, [r4, #76]	; 0x4c
}
 800ff9c:	bd10      	pop	{r4, pc}
  if ((hdfsdm_filter->Instance == DFSDM1_Filter0) &&
 800ff9e:	6840      	ldr	r0, [r0, #4]
 800ffa0:	2801      	cmp	r0, #1
 800ffa2:	d0fb      	beq.n	800ff9c <HAL_DFSDM_FilterInit+0xcc>
      ((hdfsdm_filter->Init.RegularParam.Trigger  == DFSDM_FILTER_SYNC_TRIGGER) ||
 800ffa4:	68e0      	ldr	r0, [r4, #12]
 800ffa6:	2801      	cmp	r0, #1
 800ffa8:	d19a      	bne.n	800fee0 <HAL_DFSDM_FilterInit+0x10>
 800ffaa:	e7f7      	b.n	800ff9c <HAL_DFSDM_FilterInit+0xcc>
    hdfsdm_filter->Instance->FLTCR1 |= (hdfsdm_filter->Init.InjectedParam.ExtTrigger);
 800ffac:	681a      	ldr	r2, [r3, #0]
 800ffae:	6960      	ldr	r0, [r4, #20]
 800ffb0:	4302      	orrs	r2, r0
 800ffb2:	601a      	str	r2, [r3, #0]
 800ffb4:	e7bd      	b.n	800ff32 <HAL_DFSDM_FilterInit+0x62>
    return HAL_ERROR;
 800ffb6:	2001      	movs	r0, #1
}
 800ffb8:	4770      	bx	lr
 800ffba:	bf00      	nop
 800ffbc:	40016100 	.word	0x40016100

0800ffc0 <HAL_DFSDM_FilterMspDeInit>:
 800ffc0:	4770      	bx	lr
 800ffc2:	bf00      	nop

0800ffc4 <HAL_DFSDM_FilterDeInit>:
  if (hdfsdm_filter == NULL)
 800ffc4:	b160      	cbz	r0, 800ffe0 <HAL_DFSDM_FilterDeInit+0x1c>
  hdfsdm_filter->Instance->FLTCR1 &= ~(DFSDM_FLTCR1_DFEN);
 800ffc6:	6802      	ldr	r2, [r0, #0]
 800ffc8:	6813      	ldr	r3, [r2, #0]
{
 800ffca:	b510      	push	{r4, lr}
  hdfsdm_filter->Instance->FLTCR1 &= ~(DFSDM_FLTCR1_DFEN);
 800ffcc:	f023 0301 	bic.w	r3, r3, #1
 800ffd0:	4604      	mov	r4, r0
 800ffd2:	6013      	str	r3, [r2, #0]
  HAL_DFSDM_FilterMspDeInit(hdfsdm_filter);
 800ffd4:	f7ff fff4 	bl	800ffc0 <HAL_DFSDM_FilterMspDeInit>
  hdfsdm_filter->State = HAL_DFSDM_FILTER_STATE_RESET;
 800ffd8:	2000      	movs	r0, #0
 800ffda:	f884 004c 	strb.w	r0, [r4, #76]	; 0x4c
}
 800ffde:	bd10      	pop	{r4, pc}
    return HAL_ERROR;
 800ffe0:	2001      	movs	r0, #1
}
 800ffe2:	4770      	bx	lr

0800ffe4 <HAL_DFSDM_FilterConfigRegChannel>:
  if ((hdfsdm_filter->State != HAL_DFSDM_FILTER_STATE_RESET) &&
 800ffe4:	f890 304c 	ldrb.w	r3, [r0, #76]	; 0x4c
 800ffe8:	3b01      	subs	r3, #1
 800ffea:	b2db      	uxtb	r3, r3
 800ffec:	2bfd      	cmp	r3, #253	; 0xfd
 800ffee:	d813      	bhi.n	8010018 <HAL_DFSDM_FilterConfigRegChannel+0x34>
{
 800fff0:	b430      	push	{r4, r5}
    hdfsdm_filter->Instance->FLTCR1 &= ~(DFSDM_FLTCR1_RCH | DFSDM_FLTCR1_RCONT);
 800fff2:	6804      	ldr	r4, [r0, #0]
 800fff4:	6823      	ldr	r3, [r4, #0]
 800fff6:	f023 63e0 	bic.w	r3, r3, #117440512	; 0x7000000
 800fffa:	f423 2380 	bic.w	r3, r3, #262144	; 0x40000
    if (ContinuousMode == DFSDM_CONTINUOUS_CONV_ON)
 800fffe:	2a01      	cmp	r2, #1
    hdfsdm_filter->Instance->FLTCR1 &= ~(DFSDM_FLTCR1_RCH | DFSDM_FLTCR1_RCONT);
 8010000:	6023      	str	r3, [r4, #0]
    if (ContinuousMode == DFSDM_CONTINUOUS_CONV_ON)
 8010002:	d00b      	beq.n	801001c <HAL_DFSDM_FilterConfigRegChannel+0x38>
      hdfsdm_filter->Instance->FLTCR1 |= (uint32_t)((Channel & DFSDM_MSB_MASK) << DFSDM_FLTCR1_MSB_RCH_OFFSET);
 8010004:	6823      	ldr	r3, [r4, #0]
 8010006:	0209      	lsls	r1, r1, #8
 8010008:	f001 417f 	and.w	r1, r1, #4278190080	; 0xff000000
 801000c:	4319      	orrs	r1, r3
 801000e:	6021      	str	r1, [r4, #0]
    hdfsdm_filter->RegularContMode = ContinuousMode;
 8010010:	6302      	str	r2, [r0, #48]	; 0x30
}
 8010012:	bc30      	pop	{r4, r5}
  HAL_StatusTypeDef status = HAL_OK;
 8010014:	2000      	movs	r0, #0
}
 8010016:	4770      	bx	lr
    status = HAL_ERROR;
 8010018:	2001      	movs	r0, #1
}
 801001a:	4770      	bx	lr
      hdfsdm_filter->Instance->FLTCR1 |= (uint32_t)(((Channel & DFSDM_MSB_MASK) << DFSDM_FLTCR1_MSB_RCH_OFFSET) |
 801001c:	6825      	ldr	r5, [r4, #0]
 801001e:	0209      	lsls	r1, r1, #8
 8010020:	f001 437f 	and.w	r3, r1, #4278190080	; 0xff000000
 8010024:	432b      	orrs	r3, r5
 8010026:	f443 2380 	orr.w	r3, r3, #262144	; 0x40000
 801002a:	6023      	str	r3, [r4, #0]
    hdfsdm_filter->RegularContMode = ContinuousMode;
 801002c:	6302      	str	r2, [r0, #48]	; 0x30
}
 801002e:	bc30      	pop	{r4, r5}
  HAL_StatusTypeDef status = HAL_OK;
 8010030:	2000      	movs	r0, #0
}
 8010032:	4770      	bx	lr

08010034 <HAL_DFSDM_FilterRegularStart_DMA>:
  if ((pData == NULL) || (Length == 0U))
 8010034:	b101      	cbz	r1, 8010038 <HAL_DFSDM_FilterRegularStart_DMA+0x4>
 8010036:	b912      	cbnz	r2, 801003e <HAL_DFSDM_FilterRegularStart_DMA+0xa>
    status = HAL_ERROR;
 8010038:	2101      	movs	r1, #1
}
 801003a:	4608      	mov	r0, r1
 801003c:	4770      	bx	lr
{
 801003e:	b570      	push	{r4, r5, r6, lr}
  else if ((hdfsdm_filter->Instance->FLTCR1 & DFSDM_FLTCR1_RDMAEN) != DFSDM_FLTCR1_RDMAEN)
 8010040:	6805      	ldr	r5, [r0, #0]
 8010042:	682b      	ldr	r3, [r5, #0]
 8010044:	029b      	lsls	r3, r3, #10
 8010046:	4604      	mov	r4, r0
 8010048:	d402      	bmi.n	8010050 <HAL_DFSDM_FilterRegularStart_DMA+0x1c>
    status = HAL_ERROR;
 801004a:	2101      	movs	r1, #1
}
 801004c:	4608      	mov	r0, r1
 801004e:	bd70      	pop	{r4, r5, r6, pc}
  else if ((hdfsdm_filter->RegularTrigger == DFSDM_FILTER_SW_TRIGGER) && \
 8010050:	6b43      	ldr	r3, [r0, #52]	; 0x34
 8010052:	b9a3      	cbnz	r3, 801007e <HAL_DFSDM_FilterRegularStart_DMA+0x4a>
 8010054:	6b03      	ldr	r3, [r0, #48]	; 0x30
 8010056:	b993      	cbnz	r3, 801007e <HAL_DFSDM_FilterRegularStart_DMA+0x4a>
           (hdfsdm_filter->hdmaReg->Init.Mode == DMA_NORMAL) && \
 8010058:	6a83      	ldr	r3, [r0, #40]	; 0x28
 801005a:	69de      	ldr	r6, [r3, #28]
 801005c:	4618      	mov	r0, r3
           (hdfsdm_filter->RegularContMode == DFSDM_CONTINUOUS_CONV_OFF) && \
 801005e:	bb66      	cbnz	r6, 80100ba <HAL_DFSDM_FilterRegularStart_DMA+0x86>
           (hdfsdm_filter->hdmaReg->Init.Mode == DMA_NORMAL) && \
 8010060:	2a01      	cmp	r2, #1
 8010062:	d1f2      	bne.n	801004a <HAL_DFSDM_FilterRegularStart_DMA+0x16>
  else if ((hdfsdm_filter->State == HAL_DFSDM_FILTER_STATE_READY) || \
 8010064:	f894 604c 	ldrb.w	r6, [r4, #76]	; 0x4c
 8010068:	2e01      	cmp	r6, #1
 801006a:	d02d      	beq.n	80100c8 <HAL_DFSDM_FilterRegularStart_DMA+0x94>
 801006c:	2e03      	cmp	r6, #3
 801006e:	d1ec      	bne.n	801004a <HAL_DFSDM_FilterRegularStart_DMA+0x16>
    hdfsdm_filter->hdmaReg->XferCpltCallback = DFSDM_DMARegularConvCplt;
 8010070:	4618      	mov	r0, r3
 8010072:	4b18      	ldr	r3, [pc, #96]	; (80100d4 <HAL_DFSDM_FilterRegularStart_DMA+0xa0>)
 8010074:	62c3      	str	r3, [r0, #44]	; 0x2c
    hdfsdm_filter->hdmaReg->XferErrorCallback = DFSDM_DMAError;
 8010076:	4b18      	ldr	r3, [pc, #96]	; (80100d8 <HAL_DFSDM_FilterRegularStart_DMA+0xa4>)
 8010078:	6343      	str	r3, [r0, #52]	; 0x34
                                                   DFSDM_DMARegularHalfConvCplt : NULL;
 801007a:	2300      	movs	r3, #0
 801007c:	e00f      	b.n	801009e <HAL_DFSDM_FilterRegularStart_DMA+0x6a>
  else if ((hdfsdm_filter->State == HAL_DFSDM_FILTER_STATE_READY) || \
 801007e:	f894 304c 	ldrb.w	r3, [r4, #76]	; 0x4c
 8010082:	2b01      	cmp	r3, #1
 8010084:	d001      	beq.n	801008a <HAL_DFSDM_FilterRegularStart_DMA+0x56>
 8010086:	2b03      	cmp	r3, #3
 8010088:	d1df      	bne.n	801004a <HAL_DFSDM_FilterRegularStart_DMA+0x16>
    hdfsdm_filter->hdmaReg->XferCpltCallback = DFSDM_DMARegularConvCplt;
 801008a:	6aa0      	ldr	r0, [r4, #40]	; 0x28
                                                   DFSDM_DMARegularHalfConvCplt : NULL;
 801008c:	4b13      	ldr	r3, [pc, #76]	; (80100dc <HAL_DFSDM_FilterRegularStart_DMA+0xa8>)
 801008e:	69c6      	ldr	r6, [r0, #28]
 8010090:	2e20      	cmp	r6, #32
    hdfsdm_filter->hdmaReg->XferCpltCallback = DFSDM_DMARegularConvCplt;
 8010092:	4e10      	ldr	r6, [pc, #64]	; (80100d4 <HAL_DFSDM_FilterRegularStart_DMA+0xa0>)
 8010094:	62c6      	str	r6, [r0, #44]	; 0x2c
    hdfsdm_filter->hdmaReg->XferErrorCallback = DFSDM_DMAError;
 8010096:	4e10      	ldr	r6, [pc, #64]	; (80100d8 <HAL_DFSDM_FilterRegularStart_DMA+0xa4>)
 8010098:	6346      	str	r6, [r0, #52]	; 0x34
                                                   DFSDM_DMARegularHalfConvCplt : NULL;
 801009a:	bf18      	it	ne
 801009c:	2300      	movne	r3, #0
    hdfsdm_filter->hdmaReg->XferHalfCpltCallback = (hdfsdm_filter->hdmaReg->Init.Mode == DMA_CIRCULAR) ? \
 801009e:	6303      	str	r3, [r0, #48]	; 0x30
    if (HAL_DMA_Start_IT(hdfsdm_filter->hdmaReg, (uint32_t)&hdfsdm_filter->Instance->FLTRDATAR, \
 80100a0:	4613      	mov	r3, r2
 80100a2:	460a      	mov	r2, r1
 80100a4:	f105 011c 	add.w	r1, r5, #28
 80100a8:	f000 f944 	bl	8010334 <HAL_DMA_Start_IT>
 80100ac:	4601      	mov	r1, r0
 80100ae:	b138      	cbz	r0, 80100c0 <HAL_DFSDM_FilterRegularStart_DMA+0x8c>
      hdfsdm_filter->State = HAL_DFSDM_FILTER_STATE_ERROR;
 80100b0:	23ff      	movs	r3, #255	; 0xff
 80100b2:	f884 304c 	strb.w	r3, [r4, #76]	; 0x4c
      status = HAL_ERROR;
 80100b6:	2101      	movs	r1, #1
 80100b8:	e7c8      	b.n	801004c <HAL_DFSDM_FilterRegularStart_DMA+0x18>
           (hdfsdm_filter->RegularContMode == DFSDM_CONTINUOUS_CONV_OFF) && \
 80100ba:	2e20      	cmp	r6, #32
 80100bc:	d1d2      	bne.n	8010064 <HAL_DFSDM_FilterRegularStart_DMA+0x30>
 80100be:	e7c4      	b.n	801004a <HAL_DFSDM_FilterRegularStart_DMA+0x16>
      DFSDM_RegConvStart(hdfsdm_filter);
 80100c0:	4620      	mov	r0, r4
 80100c2:	f7ff fd7d 	bl	800fbc0 <DFSDM_RegConvStart>
 80100c6:	e7c1      	b.n	801004c <HAL_DFSDM_FilterRegularStart_DMA+0x18>
    hdfsdm_filter->hdmaReg->XferCpltCallback = DFSDM_DMARegularConvCplt;
 80100c8:	4e02      	ldr	r6, [pc, #8]	; (80100d4 <HAL_DFSDM_FilterRegularStart_DMA+0xa0>)
 80100ca:	62de      	str	r6, [r3, #44]	; 0x2c
    hdfsdm_filter->hdmaReg->XferErrorCallback = DFSDM_DMAError;
 80100cc:	4e02      	ldr	r6, [pc, #8]	; (80100d8 <HAL_DFSDM_FilterRegularStart_DMA+0xa4>)
 80100ce:	635e      	str	r6, [r3, #52]	; 0x34
                                                   DFSDM_DMARegularHalfConvCplt : NULL;
 80100d0:	2300      	movs	r3, #0
 80100d2:	e7e4      	b.n	801009e <HAL_DFSDM_FilterRegularStart_DMA+0x6a>
 80100d4:	0801015d 	.word	0x0801015d
 80100d8:	08010175 	.word	0x08010175
 80100dc:	08010169 	.word	0x08010169

080100e0 <HAL_DFSDM_FilterRegularStop_DMA>:
{
 80100e0:	b510      	push	{r4, lr}
  if ((hdfsdm_filter->State != HAL_DFSDM_FILTER_STATE_REG) && \
 80100e2:	f890 304c 	ldrb.w	r3, [r0, #76]	; 0x4c
 80100e6:	2b02      	cmp	r3, #2
{
 80100e8:	4604      	mov	r4, r0
  if ((hdfsdm_filter->State != HAL_DFSDM_FILTER_STATE_REG) && \
 80100ea:	d003      	beq.n	80100f4 <HAL_DFSDM_FilterRegularStop_DMA+0x14>
 80100ec:	2b04      	cmp	r3, #4
 80100ee:	d001      	beq.n	80100f4 <HAL_DFSDM_FilterRegularStop_DMA+0x14>
    status = HAL_ERROR;
 80100f0:	2001      	movs	r0, #1
}
 80100f2:	bd10      	pop	{r4, pc}
    if (HAL_DMA_Abort(hdfsdm_filter->hdmaReg) != HAL_OK)
 80100f4:	6aa0      	ldr	r0, [r4, #40]	; 0x28
 80100f6:	f000 f961 	bl	80103bc <HAL_DMA_Abort>
 80100fa:	b120      	cbz	r0, 8010106 <HAL_DFSDM_FilterRegularStop_DMA+0x26>
      hdfsdm_filter->State = HAL_DFSDM_FILTER_STATE_ERROR;
 80100fc:	23ff      	movs	r3, #255	; 0xff
 80100fe:	f884 304c 	strb.w	r3, [r4, #76]	; 0x4c
      status = HAL_ERROR;
 8010102:	2001      	movs	r0, #1
}
 8010104:	bd10      	pop	{r4, pc}
  * @retval None
  */
static void DFSDM_RegConvStop(DFSDM_Filter_HandleTypeDef *hdfsdm_filter)
{
  /* Disable DFSDM filter */
  hdfsdm_filter->Instance->FLTCR1 &= ~(DFSDM_FLTCR1_DFEN);
 8010106:	6823      	ldr	r3, [r4, #0]

  /* If regular trigger was synchronous, reset RSYNC bit in DFSDM_FLTCR1 register */
  if (hdfsdm_filter->RegularTrigger == DFSDM_FILTER_SYNC_TRIGGER)
 8010108:	6b61      	ldr	r1, [r4, #52]	; 0x34
  hdfsdm_filter->Instance->FLTCR1 &= ~(DFSDM_FLTCR1_DFEN);
 801010a:	681a      	ldr	r2, [r3, #0]
  if (hdfsdm_filter->RegularTrigger == DFSDM_FILTER_SYNC_TRIGGER)
 801010c:	2901      	cmp	r1, #1
  hdfsdm_filter->Instance->FLTCR1 &= ~(DFSDM_FLTCR1_DFEN);
 801010e:	f022 0201 	bic.w	r2, r2, #1
 8010112:	601a      	str	r2, [r3, #0]
  if (hdfsdm_filter->RegularTrigger == DFSDM_FILTER_SYNC_TRIGGER)
 8010114:	d103      	bne.n	801011e <HAL_DFSDM_FilterRegularStop_DMA+0x3e>
  {
    hdfsdm_filter->Instance->FLTCR1 &= ~(DFSDM_FLTCR1_RSYNC);
 8010116:	681a      	ldr	r2, [r3, #0]
 8010118:	f422 2200 	bic.w	r2, r2, #524288	; 0x80000
 801011c:	601a      	str	r2, [r3, #0]
  }

  /* Enable DFSDM filter */
  hdfsdm_filter->Instance->FLTCR1 |= DFSDM_FLTCR1_DFEN;
 801011e:	681a      	ldr	r2, [r3, #0]
 8010120:	f042 0201 	orr.w	r2, r2, #1
 8010124:	601a      	str	r2, [r3, #0]

  /* If injected conversion was in progress, restart it */
  if (hdfsdm_filter->State == HAL_DFSDM_FILTER_STATE_REG_INJ)
 8010126:	f894 204c 	ldrb.w	r2, [r4, #76]	; 0x4c
 801012a:	2a04      	cmp	r2, #4
 801012c:	d006      	beq.n	801013c <HAL_DFSDM_FilterRegularStop_DMA+0x5c>
                                      hdfsdm_filter->InjectedChannelsNbr : 1U;
  }

  /* Update DFSDM filter state */
  hdfsdm_filter->State = (hdfsdm_filter->State == HAL_DFSDM_FILTER_STATE_REG) ? \
                         HAL_DFSDM_FILTER_STATE_READY : HAL_DFSDM_FILTER_STATE_INJ;
 801012e:	2a02      	cmp	r2, #2
 8010130:	bf0c      	ite	eq
 8010132:	2301      	moveq	r3, #1
 8010134:	2303      	movne	r3, #3
  hdfsdm_filter->State = (hdfsdm_filter->State == HAL_DFSDM_FILTER_STATE_REG) ? \
 8010136:	f884 304c 	strb.w	r3, [r4, #76]	; 0x4c
}
 801013a:	bd10      	pop	{r4, pc}
    if (hdfsdm_filter->InjectedTrigger == DFSDM_FILTER_SW_TRIGGER)
 801013c:	6ba2      	ldr	r2, [r4, #56]	; 0x38
 801013e:	b91a      	cbnz	r2, 8010148 <HAL_DFSDM_FilterRegularStop_DMA+0x68>
      hdfsdm_filter->Instance->FLTCR1 |= DFSDM_FLTCR1_JSWSTART;
 8010140:	681a      	ldr	r2, [r3, #0]
 8010142:	f042 0202 	orr.w	r2, r2, #2
 8010146:	601a      	str	r2, [r3, #0]
                                      hdfsdm_filter->InjectedChannelsNbr : 1U;
 8010148:	f894 3040 	ldrb.w	r3, [r4, #64]	; 0x40
 801014c:	2b01      	cmp	r3, #1
 801014e:	bf0c      	ite	eq
 8010150:	6c63      	ldreq	r3, [r4, #68]	; 0x44
 8010152:	2301      	movne	r3, #1
    hdfsdm_filter->InjConvRemaining = (hdfsdm_filter->InjectedScanMode == ENABLE) ? \
 8010154:	64a3      	str	r3, [r4, #72]	; 0x48
                         HAL_DFSDM_FILTER_STATE_READY : HAL_DFSDM_FILTER_STATE_INJ;
 8010156:	2303      	movs	r3, #3
 8010158:	e7ed      	b.n	8010136 <HAL_DFSDM_FilterRegularStop_DMA+0x56>
 801015a:	bf00      	nop

0801015c <DFSDM_DMARegularConvCplt>:
{
 801015c:	b508      	push	{r3, lr}
  HAL_DFSDM_FilterRegConvCpltCallback(hdfsdm_filter);
 801015e:	6a80      	ldr	r0, [r0, #40]	; 0x28
 8010160:	f7fb fd96 	bl	800bc90 <HAL_DFSDM_FilterRegConvCpltCallback>
}
 8010164:	bd08      	pop	{r3, pc}
 8010166:	bf00      	nop

08010168 <DFSDM_DMARegularHalfConvCplt>:
{
 8010168:	b508      	push	{r3, lr}
  HAL_DFSDM_FilterRegConvHalfCpltCallback(hdfsdm_filter);
 801016a:	6a80      	ldr	r0, [r0, #40]	; 0x28
 801016c:	f7fb fe92 	bl	800be94 <HAL_DFSDM_FilterRegConvHalfCpltCallback>
}
 8010170:	bd08      	pop	{r3, pc}
 8010172:	bf00      	nop

08010174 <DFSDM_DMAError>:
{
 8010174:	b508      	push	{r3, lr}
  DFSDM_Filter_HandleTypeDef *hdfsdm_filter = (DFSDM_Filter_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
 8010176:	6a80      	ldr	r0, [r0, #40]	; 0x28
  hdfsdm_filter->ErrorCode = DFSDM_FILTER_ERROR_DMA;
 8010178:	2303      	movs	r3, #3
 801017a:	6503      	str	r3, [r0, #80]	; 0x50
  HAL_DFSDM_FilterErrorCallback(hdfsdm_filter);
 801017c:	f7fb ff80 	bl	800c080 <HAL_DFSDM_FilterErrorCallback>
}
 8010180:	bd08      	pop	{r3, pc}
 8010182:	bf00      	nop

08010184 <HAL_DMA_Init>:
HAL_StatusTypeDef HAL_DMA_Init(DMA_HandleTypeDef *hdma)
{
  uint32_t tmp;

  /* Check the DMA handle allocation */
  if(hdma == NULL)
 8010184:	2800      	cmp	r0, #0
 8010186:	d055      	beq.n	8010234 <HAL_DMA_Init+0xb0>
  assert_param(IS_DMA_PRIORITY(hdma->Init.Priority));

  assert_param(IS_DMA_ALL_REQUEST(hdma->Init.Request));

  /* Compute the channel index */
  if ((uint32_t)(hdma->Instance) < (uint32_t)(DMA2_Channel1))
 8010188:	6801      	ldr	r1, [r0, #0]
 801018a:	4b35      	ldr	r3, [pc, #212]	; (8010260 <HAL_DMA_Init+0xdc>)
 801018c:	4299      	cmp	r1, r3
{
 801018e:	b410      	push	{r4}
  if ((uint32_t)(hdma->Instance) < (uint32_t)(DMA2_Channel1))
 8010190:	d945      	bls.n	801021e <HAL_DMA_Init+0x9a>
    hdma->DmaBaseAddress = DMA1;
  }
  else
  {
    /* DMA2 */
    hdma->ChannelIndex = (((uint32_t)hdma->Instance - (uint32_t)DMA2_Channel1) / ((uint32_t)DMA2_Channel2 - (uint32_t)DMA2_Channel1)) << 2U;
 8010192:	4b34      	ldr	r3, [pc, #208]	; (8010264 <HAL_DMA_Init+0xe0>)
 8010194:	4a34      	ldr	r2, [pc, #208]	; (8010268 <HAL_DMA_Init+0xe4>)
 8010196:	440b      	add	r3, r1
 8010198:	fba2 2303 	umull	r2, r3, r2, r3
 801019c:	091b      	lsrs	r3, r3, #4
    hdma->DmaBaseAddress = DMA2;
 801019e:	4a33      	ldr	r2, [pc, #204]	; (801026c <HAL_DMA_Init+0xe8>)
    hdma->ChannelIndex = (((uint32_t)hdma->Instance - (uint32_t)DMA2_Channel1) / ((uint32_t)DMA2_Channel2 - (uint32_t)DMA2_Channel1)) << 2U;
 80101a0:	009b      	lsls	r3, r3, #2
    hdma->DmaBaseAddress = DMA2;
 80101a2:	e9c0 2310 	strd	r2, r3, [r0, #64]	; 0x40
  tmp &= ((uint32_t)~(DMA_CCR_PL    | DMA_CCR_MSIZE  | DMA_CCR_PSIZE  |
                      DMA_CCR_MINC  | DMA_CCR_PINC   | DMA_CCR_CIRC   |
                      DMA_CCR_DIR   | DMA_CCR_MEM2MEM));

  /* Prepare the DMA Channel configuration */
  tmp |=  hdma->Init.Direction        |
 80101a6:	e9d0 4302 	ldrd	r4, r3, [r0, #8]
          hdma->Init.PeriphInc           | hdma->Init.MemInc           |
 80101aa:	6902      	ldr	r2, [r0, #16]
  tmp |=  hdma->Init.Direction        |
 80101ac:	4323      	orrs	r3, r4
          hdma->Init.PeriphInc           | hdma->Init.MemInc           |
 80101ae:	4313      	orrs	r3, r2
 80101b0:	6942      	ldr	r2, [r0, #20]
 80101b2:	4313      	orrs	r3, r2
          hdma->Init.PeriphDataAlignment | hdma->Init.MemDataAlignment |
 80101b4:	6982      	ldr	r2, [r0, #24]
 80101b6:	4313      	orrs	r3, r2
 80101b8:	69c2      	ldr	r2, [r0, #28]
  hdma->State = HAL_DMA_STATE_BUSY;
 80101ba:	f04f 0c02 	mov.w	ip, #2
          hdma->Init.PeriphDataAlignment | hdma->Init.MemDataAlignment |
 80101be:	4313      	orrs	r3, r2
          hdma->Init.Mode                | hdma->Init.Priority;
 80101c0:	6a02      	ldr	r2, [r0, #32]
  hdma->State = HAL_DMA_STATE_BUSY;
 80101c2:	f880 c025 	strb.w	ip, [r0, #37]	; 0x25
          hdma->Init.Mode                | hdma->Init.Priority;
 80101c6:	4313      	orrs	r3, r2
  tmp = hdma->Instance->CCR;
 80101c8:	680a      	ldr	r2, [r1, #0]
  tmp &= ((uint32_t)~(DMA_CCR_PL    | DMA_CCR_MSIZE  | DMA_CCR_PSIZE  |
 80101ca:	f422 42ff 	bic.w	r2, r2, #32640	; 0x7f80
 80101ce:	f022 0270 	bic.w	r2, r2, #112	; 0x70
  tmp |=  hdma->Init.Direction        |
 80101d2:	4313      	orrs	r3, r2
#endif /* DMAMUX1 */

#if !defined (DMAMUX1)

  /* Set request selection */
  if(hdma->Init.Direction != DMA_MEMORY_TO_MEMORY)
 80101d4:	f5b4 4f80 	cmp.w	r4, #16384	; 0x4000
  hdma->Instance->CCR = tmp;
 80101d8:	600b      	str	r3, [r1, #0]
  if(hdma->Init.Direction != DMA_MEMORY_TO_MEMORY)
 80101da:	d015      	beq.n	8010208 <HAL_DMA_Init+0x84>
  {
    /* Write to DMA channel selection register */
    if (DMA1 == hdma->DmaBaseAddress)
 80101dc:	4b24      	ldr	r3, [pc, #144]	; (8010270 <HAL_DMA_Init+0xec>)
 80101de:	6c02      	ldr	r2, [r0, #64]	; 0x40
 80101e0:	429a      	cmp	r2, r3
 80101e2:	d029      	beq.n	8010238 <HAL_DMA_Init+0xb4>
      DMA1_CSELR->CSELR |= (uint32_t) (hdma->Init.Request << (hdma->ChannelIndex & 0x1cU));
    }
    else /* DMA2 */
    {
      /* Reset request selection for DMA2 Channelx */
      DMA2_CSELR->CSELR &= ~(DMA_CSELR_C1S << (hdma->ChannelIndex & 0x1cU));
 80101e4:	6c42      	ldr	r2, [r0, #68]	; 0x44
 80101e6:	f8d3 44a8 	ldr.w	r4, [r3, #1192]	; 0x4a8
 80101ea:	f002 011c 	and.w	r1, r2, #28
 80101ee:	220f      	movs	r2, #15
 80101f0:	408a      	lsls	r2, r1
 80101f2:	ea24 0202 	bic.w	r2, r4, r2
 80101f6:	f8c3 24a8 	str.w	r2, [r3, #1192]	; 0x4a8

      /* Configure request selection for DMA2 Channelx */
      DMA2_CSELR->CSELR |= (uint32_t) (hdma->Init.Request << (hdma->ChannelIndex & 0x1cU));
 80101fa:	6842      	ldr	r2, [r0, #4]
 80101fc:	f8d3 44a8 	ldr.w	r4, [r3, #1192]	; 0x4a8
 8010200:	408a      	lsls	r2, r1
 8010202:	4322      	orrs	r2, r4
 8010204:	f8c3 24a8 	str.w	r2, [r3, #1192]	; 0x4a8
#endif /* STM32L431xx || STM32L432xx || STM32L433xx || STM32L442xx || STM32L443xx */
       /* STM32L471xx || STM32L475xx || STM32L476xx || STM32L442xx || STM32L486xx */
       /* STM32L496xx || STM32L4A6xx                                              */

  /* Initialise the error code */
  hdma->ErrorCode = HAL_DMA_ERROR_NONE;
 8010208:	2300      	movs	r3, #0

  /* Initialize the DMA state*/
  hdma->State = HAL_DMA_STATE_READY;
 801020a:	2201      	movs	r2, #1
  hdma->ErrorCode = HAL_DMA_ERROR_NONE;
 801020c:	63c3      	str	r3, [r0, #60]	; 0x3c

  /* Allocate lock resource and initialize it */
  hdma->Lock = HAL_UNLOCKED;
 801020e:	f880 3024 	strb.w	r3, [r0, #36]	; 0x24
  hdma->State = HAL_DMA_STATE_READY;
 8010212:	f880 2025 	strb.w	r2, [r0, #37]	; 0x25

  return HAL_OK;
}
 8010216:	f85d 4b04 	ldr.w	r4, [sp], #4
  return HAL_OK;
 801021a:	4618      	mov	r0, r3
}
 801021c:	4770      	bx	lr
    hdma->ChannelIndex = (((uint32_t)hdma->Instance - (uint32_t)DMA1_Channel1) / ((uint32_t)DMA1_Channel2 - (uint32_t)DMA1_Channel1)) << 2U;
 801021e:	4b15      	ldr	r3, [pc, #84]	; (8010274 <HAL_DMA_Init+0xf0>)
 8010220:	4a11      	ldr	r2, [pc, #68]	; (8010268 <HAL_DMA_Init+0xe4>)
 8010222:	440b      	add	r3, r1
 8010224:	fba2 2303 	umull	r2, r3, r2, r3
 8010228:	091b      	lsrs	r3, r3, #4
    hdma->DmaBaseAddress = DMA1;
 801022a:	4a11      	ldr	r2, [pc, #68]	; (8010270 <HAL_DMA_Init+0xec>)
    hdma->ChannelIndex = (((uint32_t)hdma->Instance - (uint32_t)DMA1_Channel1) / ((uint32_t)DMA1_Channel2 - (uint32_t)DMA1_Channel1)) << 2U;
 801022c:	009b      	lsls	r3, r3, #2
    hdma->DmaBaseAddress = DMA1;
 801022e:	e9c0 2310 	strd	r2, r3, [r0, #64]	; 0x40
 8010232:	e7b8      	b.n	80101a6 <HAL_DMA_Init+0x22>
    return HAL_ERROR;
 8010234:	2001      	movs	r0, #1
}
 8010236:	4770      	bx	lr
      DMA1_CSELR->CSELR &= ~(DMA_CSELR_C1S << (hdma->ChannelIndex & 0x1cU));
 8010238:	6c43      	ldr	r3, [r0, #68]	; 0x44
 801023a:	f8d2 40a8 	ldr.w	r4, [r2, #168]	; 0xa8
 801023e:	f003 011c 	and.w	r1, r3, #28
 8010242:	230f      	movs	r3, #15
 8010244:	408b      	lsls	r3, r1
 8010246:	ea24 0303 	bic.w	r3, r4, r3
 801024a:	f8c2 30a8 	str.w	r3, [r2, #168]	; 0xa8
      DMA1_CSELR->CSELR |= (uint32_t) (hdma->Init.Request << (hdma->ChannelIndex & 0x1cU));
 801024e:	6843      	ldr	r3, [r0, #4]
 8010250:	f8d2 40a8 	ldr.w	r4, [r2, #168]	; 0xa8
 8010254:	408b      	lsls	r3, r1
 8010256:	4323      	orrs	r3, r4
 8010258:	f8c2 30a8 	str.w	r3, [r2, #168]	; 0xa8
 801025c:	e7d4      	b.n	8010208 <HAL_DMA_Init+0x84>
 801025e:	bf00      	nop
 8010260:	40020407 	.word	0x40020407
 8010264:	bffdfbf8 	.word	0xbffdfbf8
 8010268:	cccccccd 	.word	0xcccccccd
 801026c:	40020400 	.word	0x40020400
 8010270:	40020000 	.word	0x40020000
 8010274:	bffdfff8 	.word	0xbffdfff8

08010278 <HAL_DMA_DeInit>:
  */
HAL_StatusTypeDef HAL_DMA_DeInit(DMA_HandleTypeDef *hdma)
{

  /* Check the DMA handle allocation */
  if (NULL == hdma )
 8010278:	2800      	cmp	r0, #0
 801027a:	d04c      	beq.n	8010316 <HAL_DMA_DeInit+0x9e>

  /* Check the parameters */
  assert_param(IS_DMA_ALL_INSTANCE(hdma->Instance));

  /* Disable the selected DMA Channelx */
  __HAL_DMA_DISABLE(hdma);
 801027c:	6802      	ldr	r2, [r0, #0]

  /* Compute the channel index */
  if ((uint32_t)(hdma->Instance) < (uint32_t)(DMA2_Channel1))
 801027e:	4927      	ldr	r1, [pc, #156]	; (801031c <HAL_DMA_DeInit+0xa4>)
  __HAL_DMA_DISABLE(hdma);
 8010280:	6813      	ldr	r3, [r2, #0]
  if ((uint32_t)(hdma->Instance) < (uint32_t)(DMA2_Channel1))
 8010282:	428a      	cmp	r2, r1
  __HAL_DMA_DISABLE(hdma);
 8010284:	f023 0301 	bic.w	r3, r3, #1
{
 8010288:	b410      	push	{r4}
  __HAL_DMA_DISABLE(hdma);
 801028a:	6013      	str	r3, [r2, #0]
  if ((uint32_t)(hdma->Instance) < (uint32_t)(DMA2_Channel1))
 801028c:	d928      	bls.n	80102e0 <HAL_DMA_DeInit+0x68>
    hdma->DmaBaseAddress = DMA1;
  }
  else
  {
    /* DMA2 */
    hdma->ChannelIndex = (((uint32_t)hdma->Instance - (uint32_t)DMA2_Channel1) / ((uint32_t)DMA2_Channel2 - (uint32_t)DMA2_Channel1)) << 2U;
 801028e:	4b24      	ldr	r3, [pc, #144]	; (8010320 <HAL_DMA_DeInit+0xa8>)
 8010290:	4924      	ldr	r1, [pc, #144]	; (8010324 <HAL_DMA_DeInit+0xac>)
 8010292:	4413      	add	r3, r2
 8010294:	fba1 1303 	umull	r1, r3, r1, r3
 8010298:	091b      	lsrs	r3, r3, #4
    hdma->DmaBaseAddress = DMA2;
 801029a:	4923      	ldr	r1, [pc, #140]	; (8010328 <HAL_DMA_DeInit+0xb0>)
 801029c:	6401      	str	r1, [r0, #64]	; 0x40
    hdma->ChannelIndex = (((uint32_t)hdma->Instance - (uint32_t)DMA2_Channel1) / ((uint32_t)DMA2_Channel2 - (uint32_t)DMA2_Channel1)) << 2U;
 801029e:	009b      	lsls	r3, r3, #2
  }

  /* Reset DMA Channel control register */
  hdma->Instance->CCR = 0U;
 80102a0:	2400      	movs	r4, #0
    hdma->ChannelIndex = (((uint32_t)hdma->Instance - (uint32_t)DMA2_Channel1) / ((uint32_t)DMA2_Channel2 - (uint32_t)DMA2_Channel1)) << 2U;
 80102a2:	6443      	str	r3, [r0, #68]	; 0x44
  hdma->Instance->CCR = 0U;
 80102a4:	6014      	str	r4, [r2, #0]

  /* Clear all flags */
  hdma->DmaBaseAddress->IFCR = (DMA_ISR_GIF1 << (hdma->ChannelIndex & 0x1CU));
 80102a6:	f003 031c 	and.w	r3, r3, #28
 80102aa:	2201      	movs	r2, #1
 80102ac:	409a      	lsls	r2, r3
    DMA1_CSELR->CSELR &= ~(DMA_CSELR_C1S << (hdma->ChannelIndex & 0x1cU));
  }
  else
  {
    /* DMA2 */
    DMA2_CSELR->CSELR &= ~(DMA_CSELR_C1S << (hdma->ChannelIndex & 0x1cU));
 80102ae:	4c1f      	ldr	r4, [pc, #124]	; (801032c <HAL_DMA_DeInit+0xb4>)
  hdma->DmaBaseAddress->IFCR = (DMA_ISR_GIF1 << (hdma->ChannelIndex & 0x1CU));
 80102b0:	604a      	str	r2, [r1, #4]
    DMA2_CSELR->CSELR &= ~(DMA_CSELR_C1S << (hdma->ChannelIndex & 0x1cU));
 80102b2:	f8d4 24a8 	ldr.w	r2, [r4, #1192]	; 0x4a8
 80102b6:	210f      	movs	r1, #15
 80102b8:	fa01 f303 	lsl.w	r3, r1, r3
 80102bc:	ea22 0303 	bic.w	r3, r2, r3
 80102c0:	f8c4 34a8 	str.w	r3, [r4, #1192]	; 0x4a8
  hdma->DMAmuxRequestGenStatusMask = 0U;

#endif /* DMAMUX1 */

  /* Clean callbacks */
  hdma->XferCpltCallback = NULL;
 80102c4:	2300      	movs	r3, #0
  hdma->XferHalfCpltCallback = NULL;
  hdma->XferErrorCallback = NULL;
  hdma->XferAbortCallback = NULL;

  /* Initialise the error code */
  hdma->ErrorCode = HAL_DMA_ERROR_NONE;
 80102c6:	63c3      	str	r3, [r0, #60]	; 0x3c

  /* Initialize the DMA state */
  hdma->State = HAL_DMA_STATE_RESET;

  /* Release Lock */
  __HAL_UNLOCK(hdma);
 80102c8:	f880 3024 	strb.w	r3, [r0, #36]	; 0x24
  hdma->State = HAL_DMA_STATE_RESET;
 80102cc:	f880 3025 	strb.w	r3, [r0, #37]	; 0x25
  hdma->XferHalfCpltCallback = NULL;
 80102d0:	e9c0 330b 	strd	r3, r3, [r0, #44]	; 0x2c
  hdma->XferAbortCallback = NULL;
 80102d4:	e9c0 330d 	strd	r3, r3, [r0, #52]	; 0x34

  return HAL_OK;
}
 80102d8:	f85d 4b04 	ldr.w	r4, [sp], #4
  return HAL_OK;
 80102dc:	4618      	mov	r0, r3
}
 80102de:	4770      	bx	lr
    hdma->ChannelIndex = (((uint32_t)hdma->Instance - (uint32_t)DMA1_Channel1) / ((uint32_t)DMA1_Channel2 - (uint32_t)DMA1_Channel1)) << 2U;
 80102e0:	4b13      	ldr	r3, [pc, #76]	; (8010330 <HAL_DMA_DeInit+0xb8>)
 80102e2:	4910      	ldr	r1, [pc, #64]	; (8010324 <HAL_DMA_DeInit+0xac>)
 80102e4:	4413      	add	r3, r2
 80102e6:	fba1 1303 	umull	r1, r3, r1, r3
 80102ea:	091b      	lsrs	r3, r3, #4
    hdma->DmaBaseAddress = DMA1;
 80102ec:	490f      	ldr	r1, [pc, #60]	; (801032c <HAL_DMA_DeInit+0xb4>)
 80102ee:	6401      	str	r1, [r0, #64]	; 0x40
    hdma->ChannelIndex = (((uint32_t)hdma->Instance - (uint32_t)DMA1_Channel1) / ((uint32_t)DMA1_Channel2 - (uint32_t)DMA1_Channel1)) << 2U;
 80102f0:	009b      	lsls	r3, r3, #2
  hdma->Instance->CCR = 0U;
 80102f2:	2400      	movs	r4, #0
    hdma->ChannelIndex = (((uint32_t)hdma->Instance - (uint32_t)DMA1_Channel1) / ((uint32_t)DMA1_Channel2 - (uint32_t)DMA1_Channel1)) << 2U;
 80102f4:	6443      	str	r3, [r0, #68]	; 0x44
  hdma->Instance->CCR = 0U;
 80102f6:	6014      	str	r4, [r2, #0]
  hdma->DmaBaseAddress->IFCR = (DMA_ISR_GIF1 << (hdma->ChannelIndex & 0x1CU));
 80102f8:	f003 031c 	and.w	r3, r3, #28
 80102fc:	2201      	movs	r2, #1
 80102fe:	409a      	lsls	r2, r3
 8010300:	604a      	str	r2, [r1, #4]
    DMA1_CSELR->CSELR &= ~(DMA_CSELR_C1S << (hdma->ChannelIndex & 0x1cU));
 8010302:	f8d1 20a8 	ldr.w	r2, [r1, #168]	; 0xa8
 8010306:	240f      	movs	r4, #15
 8010308:	fa04 f303 	lsl.w	r3, r4, r3
 801030c:	ea22 0303 	bic.w	r3, r2, r3
 8010310:	f8c1 30a8 	str.w	r3, [r1, #168]	; 0xa8
 8010314:	e7d6      	b.n	80102c4 <HAL_DMA_DeInit+0x4c>
    return HAL_ERROR;
 8010316:	2001      	movs	r0, #1
}
 8010318:	4770      	bx	lr
 801031a:	bf00      	nop
 801031c:	40020407 	.word	0x40020407
 8010320:	bffdfbf8 	.word	0xbffdfbf8
 8010324:	cccccccd 	.word	0xcccccccd
 8010328:	40020400 	.word	0x40020400
 801032c:	40020000 	.word	0x40020000
 8010330:	bffdfff8 	.word	0xbffdfff8

08010334 <HAL_DMA_Start_IT>:

  /* Check the parameters */
  assert_param(IS_DMA_BUFFER_SIZE(DataLength));

  /* Process locked */
  __HAL_LOCK(hdma);
 8010334:	f890 c024 	ldrb.w	ip, [r0, #36]	; 0x24
 8010338:	f1bc 0f01 	cmp.w	ip, #1
 801033c:	d03c      	beq.n	80103b8 <HAL_DMA_Start_IT+0x84>
{
 801033e:	b570      	push	{r4, r5, r6, lr}

  if(HAL_DMA_STATE_READY == hdma->State)
 8010340:	f890 c025 	ldrb.w	ip, [r0, #37]	; 0x25
  __HAL_LOCK(hdma);
 8010344:	2401      	movs	r4, #1
  if(HAL_DMA_STATE_READY == hdma->State)
 8010346:	45a4      	cmp	ip, r4
  __HAL_LOCK(hdma);
 8010348:	f880 4024 	strb.w	r4, [r0, #36]	; 0x24
  if(HAL_DMA_STATE_READY == hdma->State)
 801034c:	fa5f fe8c 	uxtb.w	lr, ip
 8010350:	d004      	beq.n	801035c <HAL_DMA_Start_IT+0x28>
    __HAL_DMA_ENABLE(hdma);
  }
  else
  {
    /* Process Unlocked */
    __HAL_UNLOCK(hdma);
 8010352:	2300      	movs	r3, #0
 8010354:	f880 3024 	strb.w	r3, [r0, #36]	; 0x24

    /* Remain BUSY */
    status = HAL_BUSY;
 8010358:	2002      	movs	r0, #2
  }
  return status;
}
 801035a:	bd70      	pop	{r4, r5, r6, pc}
    hdma->State = HAL_DMA_STATE_BUSY;
 801035c:	2502      	movs	r5, #2
 801035e:	f880 5025 	strb.w	r5, [r0, #37]	; 0x25
    __HAL_DMA_DISABLE(hdma);
 8010362:	6804      	ldr	r4, [r0, #0]
    hdma->ErrorCode = HAL_DMA_ERROR_NONE;
 8010364:	2500      	movs	r5, #0
 8010366:	63c5      	str	r5, [r0, #60]	; 0x3c
    __HAL_DMA_DISABLE(hdma);
 8010368:	6826      	ldr	r6, [r4, #0]
    hdma->DMAmuxRequestGenStatus->RGCFR = hdma->DMAmuxRequestGenStatusMask;
  }
#endif

  /* Clear all flags */
  hdma->DmaBaseAddress->IFCR = (DMA_ISR_GIF1 << (hdma->ChannelIndex & 0x1CU));
 801036a:	6c45      	ldr	r5, [r0, #68]	; 0x44
    __HAL_DMA_DISABLE(hdma);
 801036c:	f026 0601 	bic.w	r6, r6, #1
 8010370:	6026      	str	r6, [r4, #0]
  hdma->DmaBaseAddress->IFCR = (DMA_ISR_GIF1 << (hdma->ChannelIndex & 0x1CU));
 8010372:	f005 051c 	and.w	r5, r5, #28
 8010376:	6c06      	ldr	r6, [r0, #64]	; 0x40
 8010378:	fa0e f505 	lsl.w	r5, lr, r5
 801037c:	6075      	str	r5, [r6, #4]

  /* Configure DMA Channel data length */
  hdma->Instance->CNDTR = DataLength;
 801037e:	6063      	str	r3, [r4, #4]

  /* Memory to Peripheral */
  if((hdma->Init.Direction) == DMA_MEMORY_TO_PERIPH)
 8010380:	6883      	ldr	r3, [r0, #8]
 8010382:	2b10      	cmp	r3, #16
    if(NULL != hdma->XferHalfCpltCallback )
 8010384:	6b03      	ldr	r3, [r0, #48]	; 0x30
  {
    /* Configure DMA Channel destination address */
    hdma->Instance->CPAR = DstAddress;
 8010386:	bf0b      	itete	eq
 8010388:	60a2      	streq	r2, [r4, #8]
  }
  /* Peripheral to Memory */
  else
  {
    /* Configure DMA Channel source address */
    hdma->Instance->CPAR = SrcAddress;
 801038a:	60a1      	strne	r1, [r4, #8]
    hdma->Instance->CMAR = SrcAddress;
 801038c:	60e1      	streq	r1, [r4, #12]

    /* Configure DMA Channel destination address */
    hdma->Instance->CMAR = DstAddress;
 801038e:	60e2      	strne	r2, [r4, #12]
    if(NULL != hdma->XferHalfCpltCallback )
 8010390:	b14b      	cbz	r3, 80103a6 <HAL_DMA_Start_IT+0x72>
      __HAL_DMA_ENABLE_IT(hdma, (DMA_IT_TC | DMA_IT_HT | DMA_IT_TE));
 8010392:	6823      	ldr	r3, [r4, #0]
 8010394:	f043 030e 	orr.w	r3, r3, #14
 8010398:	6023      	str	r3, [r4, #0]
    __HAL_DMA_ENABLE(hdma);
 801039a:	6823      	ldr	r3, [r4, #0]
 801039c:	f043 0301 	orr.w	r3, r3, #1
  HAL_StatusTypeDef status = HAL_OK;
 80103a0:	2000      	movs	r0, #0
    __HAL_DMA_ENABLE(hdma);
 80103a2:	6023      	str	r3, [r4, #0]
}
 80103a4:	bd70      	pop	{r4, r5, r6, pc}
      __HAL_DMA_DISABLE_IT(hdma, DMA_IT_HT);
 80103a6:	6823      	ldr	r3, [r4, #0]
 80103a8:	f023 0304 	bic.w	r3, r3, #4
 80103ac:	6023      	str	r3, [r4, #0]
      __HAL_DMA_ENABLE_IT(hdma, (DMA_IT_TC | DMA_IT_TE));
 80103ae:	6823      	ldr	r3, [r4, #0]
 80103b0:	f043 030a 	orr.w	r3, r3, #10
 80103b4:	6023      	str	r3, [r4, #0]
 80103b6:	e7f0      	b.n	801039a <HAL_DMA_Start_IT+0x66>
  __HAL_LOCK(hdma);
 80103b8:	2002      	movs	r0, #2
}
 80103ba:	4770      	bx	lr

080103bc <HAL_DMA_Abort>:
  if(hdma->State != HAL_DMA_STATE_BUSY)
 80103bc:	f890 3025 	ldrb.w	r3, [r0, #37]	; 0x25
 80103c0:	2b02      	cmp	r3, #2
 80103c2:	d006      	beq.n	80103d2 <HAL_DMA_Abort+0x16>
    hdma->ErrorCode = HAL_DMA_ERROR_NO_XFER;
 80103c4:	2204      	movs	r2, #4
    __HAL_UNLOCK(hdma);
 80103c6:	2300      	movs	r3, #0
    hdma->ErrorCode = HAL_DMA_ERROR_NO_XFER;
 80103c8:	63c2      	str	r2, [r0, #60]	; 0x3c
    __HAL_UNLOCK(hdma);
 80103ca:	f880 3024 	strb.w	r3, [r0, #36]	; 0x24
    return HAL_ERROR;
 80103ce:	2001      	movs	r0, #1
 80103d0:	4770      	bx	lr
    __HAL_DMA_DISABLE_IT(hdma, (DMA_IT_TC | DMA_IT_HT | DMA_IT_TE));
 80103d2:	6802      	ldr	r2, [r0, #0]
    hdma->DmaBaseAddress->IFCR = (DMA_ISR_GIF1 << (hdma->ChannelIndex & 0x1CU));
 80103d4:	6c43      	ldr	r3, [r0, #68]	; 0x44
    __HAL_DMA_DISABLE_IT(hdma, (DMA_IT_TC | DMA_IT_HT | DMA_IT_TE));
 80103d6:	6811      	ldr	r1, [r2, #0]
 80103d8:	f021 010e 	bic.w	r1, r1, #14
 80103dc:	6011      	str	r1, [r2, #0]
    __HAL_DMA_DISABLE(hdma);
 80103de:	6811      	ldr	r1, [r2, #0]
 80103e0:	f021 0101 	bic.w	r1, r1, #1
 80103e4:	6011      	str	r1, [r2, #0]
    hdma->DmaBaseAddress->IFCR = (DMA_ISR_GIF1 << (hdma->ChannelIndex & 0x1CU));
 80103e6:	f04f 0c01 	mov.w	ip, #1
 80103ea:	6c02      	ldr	r2, [r0, #64]	; 0x40
 80103ec:	f003 031c 	and.w	r3, r3, #28
 80103f0:	fa0c f303 	lsl.w	r3, ip, r3
 80103f4:	6053      	str	r3, [r2, #4]
    __HAL_UNLOCK(hdma);
 80103f6:	2300      	movs	r3, #0
    hdma->State = HAL_DMA_STATE_READY;
 80103f8:	f880 c025 	strb.w	ip, [r0, #37]	; 0x25
    __HAL_UNLOCK(hdma);
 80103fc:	f880 3024 	strb.w	r3, [r0, #36]	; 0x24
    return status;
 8010400:	4618      	mov	r0, r3
}
 8010402:	4770      	bx	lr

08010404 <HAL_DMA_Abort_IT>:
  if(HAL_DMA_STATE_BUSY != hdma->State)
 8010404:	f890 2025 	ldrb.w	r2, [r0, #37]	; 0x25
 8010408:	2a02      	cmp	r2, #2
 801040a:	d003      	beq.n	8010414 <HAL_DMA_Abort_IT+0x10>
    hdma->ErrorCode = HAL_DMA_ERROR_NO_XFER;
 801040c:	2204      	movs	r2, #4
 801040e:	63c2      	str	r2, [r0, #60]	; 0x3c
    status = HAL_ERROR;
 8010410:	2001      	movs	r0, #1
}
 8010412:	4770      	bx	lr
    __HAL_DMA_DISABLE_IT(hdma, (DMA_IT_TC | DMA_IT_HT | DMA_IT_TE));
 8010414:	6801      	ldr	r1, [r0, #0]
    hdma->DmaBaseAddress->IFCR = (DMA_ISR_GIF1 << (hdma->ChannelIndex & 0x1CU));
 8010416:	6c42      	ldr	r2, [r0, #68]	; 0x44
{
 8010418:	b510      	push	{r4, lr}
    __HAL_DMA_DISABLE_IT(hdma, (DMA_IT_TC | DMA_IT_HT | DMA_IT_TE));
 801041a:	680c      	ldr	r4, [r1, #0]
 801041c:	f024 040e 	bic.w	r4, r4, #14
 8010420:	600c      	str	r4, [r1, #0]
    __HAL_DMA_DISABLE(hdma);
 8010422:	680c      	ldr	r4, [r1, #0]
 8010424:	f024 0401 	bic.w	r4, r4, #1
 8010428:	600c      	str	r4, [r1, #0]
    hdma->DmaBaseAddress->IFCR = (DMA_ISR_GIF1 << (hdma->ChannelIndex & 0x1CU));
 801042a:	f002 021c 	and.w	r2, r2, #28
 801042e:	6c04      	ldr	r4, [r0, #64]	; 0x40
 8010430:	2101      	movs	r1, #1
 8010432:	fa01 f202 	lsl.w	r2, r1, r2
 8010436:	6062      	str	r2, [r4, #4]
    if(hdma->XferAbortCallback != NULL)
 8010438:	6b82      	ldr	r2, [r0, #56]	; 0x38
    hdma->State = HAL_DMA_STATE_READY;
 801043a:	f880 1025 	strb.w	r1, [r0, #37]	; 0x25
    __HAL_UNLOCK(hdma);
 801043e:	2400      	movs	r4, #0
 8010440:	f880 4024 	strb.w	r4, [r0, #36]	; 0x24
    if(hdma->XferAbortCallback != NULL)
 8010444:	b112      	cbz	r2, 801044c <HAL_DMA_Abort_IT+0x48>
      hdma->XferAbortCallback(hdma);
 8010446:	4790      	blx	r2
  HAL_StatusTypeDef status = HAL_OK;
 8010448:	4620      	mov	r0, r4
}
 801044a:	bd10      	pop	{r4, pc}
  HAL_StatusTypeDef status = HAL_OK;
 801044c:	4610      	mov	r0, r2
}
 801044e:	bd10      	pop	{r4, pc}

08010450 <HAL_DMA_IRQHandler>:
{
 8010450:	b470      	push	{r4, r5, r6}
  if (((flag_it & (DMA_FLAG_HT1 << (hdma->ChannelIndex & 0x1CU))) != 0U) && ((source_it & DMA_IT_HT) != 0U))
 8010452:	6c43      	ldr	r3, [r0, #68]	; 0x44
  uint32_t flag_it = hdma->DmaBaseAddress->ISR;
 8010454:	6c06      	ldr	r6, [r0, #64]	; 0x40
  uint32_t source_it = hdma->Instance->CCR;
 8010456:	6805      	ldr	r5, [r0, #0]
  uint32_t flag_it = hdma->DmaBaseAddress->ISR;
 8010458:	6831      	ldr	r1, [r6, #0]
  uint32_t source_it = hdma->Instance->CCR;
 801045a:	682c      	ldr	r4, [r5, #0]
  if (((flag_it & (DMA_FLAG_HT1 << (hdma->ChannelIndex & 0x1CU))) != 0U) && ((source_it & DMA_IT_HT) != 0U))
 801045c:	f003 031c 	and.w	r3, r3, #28
 8010460:	2204      	movs	r2, #4
 8010462:	409a      	lsls	r2, r3
 8010464:	420a      	tst	r2, r1
 8010466:	d00e      	beq.n	8010486 <HAL_DMA_IRQHandler+0x36>
 8010468:	f014 0f04 	tst.w	r4, #4
 801046c:	d00b      	beq.n	8010486 <HAL_DMA_IRQHandler+0x36>
      if((hdma->Instance->CCR & DMA_CCR_CIRC) == 0U)
 801046e:	682b      	ldr	r3, [r5, #0]
 8010470:	069b      	lsls	r3, r3, #26
 8010472:	d403      	bmi.n	801047c <HAL_DMA_IRQHandler+0x2c>
        __HAL_DMA_DISABLE_IT(hdma, DMA_IT_HT);
 8010474:	682b      	ldr	r3, [r5, #0]
 8010476:	f023 0304 	bic.w	r3, r3, #4
 801047a:	602b      	str	r3, [r5, #0]
      if(hdma->XferHalfCpltCallback != NULL)
 801047c:	6b03      	ldr	r3, [r0, #48]	; 0x30
      hdma->DmaBaseAddress->IFCR = DMA_ISR_HTIF1 << (hdma->ChannelIndex & 0x1CU);
 801047e:	6072      	str	r2, [r6, #4]
      if(hdma->XferHalfCpltCallback != NULL)
 8010480:	b1cb      	cbz	r3, 80104b6 <HAL_DMA_IRQHandler+0x66>
}
 8010482:	bc70      	pop	{r4, r5, r6}
      hdma->XferCpltCallback(hdma);
 8010484:	4718      	bx	r3
  else if (((flag_it & (DMA_FLAG_TC1 << (hdma->ChannelIndex & 0x1CU))) != 0U) && ((source_it & DMA_IT_TC) != 0U))
 8010486:	2202      	movs	r2, #2
 8010488:	409a      	lsls	r2, r3
 801048a:	420a      	tst	r2, r1
 801048c:	d015      	beq.n	80104ba <HAL_DMA_IRQHandler+0x6a>
 801048e:	f014 0f02 	tst.w	r4, #2
 8010492:	d012      	beq.n	80104ba <HAL_DMA_IRQHandler+0x6a>
    if((hdma->Instance->CCR & DMA_CCR_CIRC) == 0U)
 8010494:	682b      	ldr	r3, [r5, #0]
 8010496:	0699      	lsls	r1, r3, #26
 8010498:	d406      	bmi.n	80104a8 <HAL_DMA_IRQHandler+0x58>
      __HAL_DMA_DISABLE_IT(hdma, DMA_IT_TE | DMA_IT_TC);
 801049a:	682b      	ldr	r3, [r5, #0]
 801049c:	f023 030a 	bic.w	r3, r3, #10
 80104a0:	602b      	str	r3, [r5, #0]
      hdma->State = HAL_DMA_STATE_READY;
 80104a2:	2301      	movs	r3, #1
 80104a4:	f880 3025 	strb.w	r3, [r0, #37]	; 0x25
    if(hdma->XferCpltCallback != NULL)
 80104a8:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
    hdma->DmaBaseAddress->IFCR = (DMA_ISR_TCIF1 << (hdma->ChannelIndex & 0x1CU));
 80104aa:	6072      	str	r2, [r6, #4]
    __HAL_UNLOCK(hdma);
 80104ac:	2100      	movs	r1, #0
 80104ae:	f880 1024 	strb.w	r1, [r0, #36]	; 0x24
    if(hdma->XferCpltCallback != NULL)
 80104b2:	2b00      	cmp	r3, #0
 80104b4:	d1e5      	bne.n	8010482 <HAL_DMA_IRQHandler+0x32>
}
 80104b6:	bc70      	pop	{r4, r5, r6}
 80104b8:	4770      	bx	lr
  else if (((flag_it & (DMA_FLAG_TE1 << (hdma->ChannelIndex & 0x1CU))) != 0U) && ((source_it & DMA_IT_TE) !=  0U))
 80104ba:	2208      	movs	r2, #8
 80104bc:	409a      	lsls	r2, r3
 80104be:	420a      	tst	r2, r1
 80104c0:	d0f9      	beq.n	80104b6 <HAL_DMA_IRQHandler+0x66>
 80104c2:	0722      	lsls	r2, r4, #28
 80104c4:	d5f7      	bpl.n	80104b6 <HAL_DMA_IRQHandler+0x66>
    __HAL_DMA_DISABLE_IT(hdma, (DMA_IT_TC | DMA_IT_HT | DMA_IT_TE));
 80104c6:	682a      	ldr	r2, [r5, #0]
    if (hdma->XferErrorCallback != NULL)
 80104c8:	6b41      	ldr	r1, [r0, #52]	; 0x34
    __HAL_DMA_DISABLE_IT(hdma, (DMA_IT_TC | DMA_IT_HT | DMA_IT_TE));
 80104ca:	f022 020e 	bic.w	r2, r2, #14
 80104ce:	602a      	str	r2, [r5, #0]
    hdma->DmaBaseAddress->IFCR = (DMA_ISR_GIF1 << (hdma->ChannelIndex & 0x1CU));
 80104d0:	2201      	movs	r2, #1
 80104d2:	fa02 f303 	lsl.w	r3, r2, r3
    __HAL_UNLOCK(hdma);
 80104d6:	2400      	movs	r4, #0
    hdma->DmaBaseAddress->IFCR = (DMA_ISR_GIF1 << (hdma->ChannelIndex & 0x1CU));
 80104d8:	6073      	str	r3, [r6, #4]
    hdma->ErrorCode = HAL_DMA_ERROR_TE;
 80104da:	63c2      	str	r2, [r0, #60]	; 0x3c
    __HAL_UNLOCK(hdma);
 80104dc:	f880 4024 	strb.w	r4, [r0, #36]	; 0x24
    hdma->State = HAL_DMA_STATE_READY;
 80104e0:	f880 2025 	strb.w	r2, [r0, #37]	; 0x25
    if (hdma->XferErrorCallback != NULL)
 80104e4:	2900      	cmp	r1, #0
 80104e6:	d0e6      	beq.n	80104b6 <HAL_DMA_IRQHandler+0x66>
}
 80104e8:	bc70      	pop	{r4, r5, r6}
      hdma->XferErrorCallback(hdma);
 80104ea:	4708      	bx	r1

080104ec <HAL_EXTI_RegisterCallback>:
  */
HAL_StatusTypeDef HAL_EXTI_RegisterCallback(EXTI_HandleTypeDef *hexti, EXTI_CallbackIDTypeDef CallbackID, void (*pPendingCbfn)(void))
{
  HAL_StatusTypeDef status = HAL_OK;

  switch (CallbackID)
 80104ec:	b911      	cbnz	r1, 80104f4 <HAL_EXTI_RegisterCallback+0x8>
  {
    case  HAL_EXTI_COMMON_CB_ID:
      hexti->PendingCallback = pPendingCbfn;
 80104ee:	6042      	str	r2, [r0, #4]
  HAL_StatusTypeDef status = HAL_OK;
 80104f0:	4608      	mov	r0, r1
      break;
 80104f2:	4770      	bx	lr

    default:
      status = HAL_ERROR;
 80104f4:	2001      	movs	r0, #1
      break;
  }

  return status;
}
 80104f6:	4770      	bx	lr

080104f8 <HAL_EXTI_GetHandle>:
{
  /* Check the parameters */
  assert_param(IS_EXTI_LINE(ExtiLine));

  /* Check null pointer */
  if (hexti == NULL)
 80104f8:	b110      	cbz	r0, 8010500 <HAL_EXTI_GetHandle+0x8>
    return HAL_ERROR;
  }
  else
  {
    /* Store line number as handle private field */
    hexti->Line = ExtiLine;
 80104fa:	6001      	str	r1, [r0, #0]

    return HAL_OK;
 80104fc:	2000      	movs	r0, #0
 80104fe:	4770      	bx	lr
    return HAL_ERROR;
 8010500:	2001      	movs	r0, #1
  }
}
 8010502:	4770      	bx	lr

08010504 <HAL_FLASH_Unlock>:
  */
HAL_StatusTypeDef HAL_FLASH_Unlock(void)
{
  HAL_StatusTypeDef status = HAL_OK;

  if(READ_BIT(FLASH->CR, FLASH_CR_LOCK) != 0U)
 8010504:	4b06      	ldr	r3, [pc, #24]	; (8010520 <HAL_FLASH_Unlock+0x1c>)
 8010506:	695a      	ldr	r2, [r3, #20]
 8010508:	2a00      	cmp	r2, #0
 801050a:	db01      	blt.n	8010510 <HAL_FLASH_Unlock+0xc>
  HAL_StatusTypeDef status = HAL_OK;
 801050c:	2000      	movs	r0, #0
      status = HAL_ERROR;
    }
  }

  return status;
}
 801050e:	4770      	bx	lr
    WRITE_REG(FLASH->KEYR, FLASH_KEY1);
 8010510:	4904      	ldr	r1, [pc, #16]	; (8010524 <HAL_FLASH_Unlock+0x20>)
    WRITE_REG(FLASH->KEYR, FLASH_KEY2);
 8010512:	4a05      	ldr	r2, [pc, #20]	; (8010528 <HAL_FLASH_Unlock+0x24>)
    WRITE_REG(FLASH->KEYR, FLASH_KEY1);
 8010514:	6099      	str	r1, [r3, #8]
    WRITE_REG(FLASH->KEYR, FLASH_KEY2);
 8010516:	609a      	str	r2, [r3, #8]
    if(READ_BIT(FLASH->CR, FLASH_CR_LOCK) != 0U)
 8010518:	6958      	ldr	r0, [r3, #20]
  HAL_StatusTypeDef status = HAL_OK;
 801051a:	0fc0      	lsrs	r0, r0, #31
 801051c:	4770      	bx	lr
 801051e:	bf00      	nop
 8010520:	40022000 	.word	0x40022000
 8010524:	45670123 	.word	0x45670123
 8010528:	cdef89ab 	.word	0xcdef89ab

0801052c <HAL_FLASH_Lock>:
  * @retval HAL Status
  */
HAL_StatusTypeDef HAL_FLASH_Lock(void)
{
  /* Set the LOCK Bit to lock the FLASH Registers access */
  SET_BIT(FLASH->CR, FLASH_CR_LOCK);
 801052c:	4a03      	ldr	r2, [pc, #12]	; (801053c <HAL_FLASH_Lock+0x10>)
 801052e:	6953      	ldr	r3, [r2, #20]
 8010530:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000

  return HAL_OK;
}
 8010534:	2000      	movs	r0, #0
  SET_BIT(FLASH->CR, FLASH_CR_LOCK);
 8010536:	6153      	str	r3, [r2, #20]
}
 8010538:	4770      	bx	lr
 801053a:	bf00      	nop
 801053c:	40022000 	.word	0x40022000

08010540 <FLASH_WaitForLastOperation>:
  * @brief  Wait for a FLASH operation to complete.
  * @param  Timeout: maximum flash operation timeout
  * @retval HAL_StatusTypeDef HAL Status
  */
HAL_StatusTypeDef FLASH_WaitForLastOperation(uint32_t Timeout)
{
 8010540:	b570      	push	{r4, r5, r6, lr}
 8010542:	4605      	mov	r5, r0
  /* Wait for the FLASH operation to complete by polling on BUSY flag to be reset.
     Even if the FLASH operation fails, the BUSY flag will be reset and an error
     flag will be set */

  uint32_t tickstart = HAL_GetTick();
 8010544:	f7ff f978 	bl	800f838 <HAL_GetTick>
  uint32_t error;

  while(__HAL_FLASH_GET_FLAG(FLASH_FLAG_BSY))
 8010548:	4c19      	ldr	r4, [pc, #100]	; (80105b0 <FLASH_WaitForLastOperation+0x70>)
  uint32_t tickstart = HAL_GetTick();
 801054a:	4606      	mov	r6, r0
  while(__HAL_FLASH_GET_FLAG(FLASH_FLAG_BSY))
 801054c:	e001      	b.n	8010552 <FLASH_WaitForLastOperation+0x12>
  {
    if(Timeout != HAL_MAX_DELAY)
 801054e:	1c6a      	adds	r2, r5, #1
 8010550:	d113      	bne.n	801057a <FLASH_WaitForLastOperation+0x3a>
  while(__HAL_FLASH_GET_FLAG(FLASH_FLAG_BSY))
 8010552:	6923      	ldr	r3, [r4, #16]
 8010554:	03db      	lsls	r3, r3, #15
 8010556:	d4fa      	bmi.n	801054e <FLASH_WaitForLastOperation+0xe>
        return HAL_TIMEOUT;
      }
    }
  }

  error = (FLASH->SR & FLASH_FLAG_SR_ERRORS);
 8010558:	6920      	ldr	r0, [r4, #16]
  error |= (FLASH->ECCR & FLASH_FLAG_ECCD);
 801055a:	69a3      	ldr	r3, [r4, #24]
  error = (FLASH->SR & FLASH_FLAG_SR_ERRORS);
 801055c:	f24c 32fa 	movw	r2, #50170	; 0xc3fa
 8010560:	4010      	ands	r0, r2
  error |= (FLASH->ECCR & FLASH_FLAG_ECCD);
 8010562:	f003 4300 	and.w	r3, r3, #2147483648	; 0x80000000

  if(error != 0u)
 8010566:	4303      	orrs	r3, r0
 8010568:	d10e      	bne.n	8010588 <FLASH_WaitForLastOperation+0x48>

    return HAL_ERROR;
  }

  /* Check FLASH End of Operation flag  */
  if (__HAL_FLASH_GET_FLAG(FLASH_FLAG_EOP))
 801056a:	6920      	ldr	r0, [r4, #16]
 801056c:	f010 0001 	ands.w	r0, r0, #1
 8010570:	d002      	beq.n	8010578 <FLASH_WaitForLastOperation+0x38>
  {
    /* Clear FLASH End of Operation pending bit */
    __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_EOP);
 8010572:	2201      	movs	r2, #1
 8010574:	6122      	str	r2, [r4, #16]
  }

  /* If there is an error flag set */
  return HAL_OK;
 8010576:	4618      	mov	r0, r3
}
 8010578:	bd70      	pop	{r4, r5, r6, pc}
      if((HAL_GetTick() - tickstart) >= Timeout)
 801057a:	f7ff f95d 	bl	800f838 <HAL_GetTick>
 801057e:	1b80      	subs	r0, r0, r6
 8010580:	42a8      	cmp	r0, r5
 8010582:	d3e6      	bcc.n	8010552 <FLASH_WaitForLastOperation+0x12>
        return HAL_TIMEOUT;
 8010584:	2003      	movs	r0, #3
}
 8010586:	bd70      	pop	{r4, r5, r6, pc}
    pFlash.ErrorCode |= error;
 8010588:	490a      	ldr	r1, [pc, #40]	; (80105b4 <FLASH_WaitForLastOperation+0x74>)
 801058a:	684a      	ldr	r2, [r1, #4]
 801058c:	431a      	orrs	r2, r3
 801058e:	604a      	str	r2, [r1, #4]
    __HAL_FLASH_CLEAR_FLAG(error);
 8010590:	f013 4240 	ands.w	r2, r3, #3221225472	; 0xc0000000
 8010594:	d002      	beq.n	801059c <FLASH_WaitForLastOperation+0x5c>
 8010596:	69a1      	ldr	r1, [r4, #24]
 8010598:	430a      	orrs	r2, r1
 801059a:	61a2      	str	r2, [r4, #24]
 801059c:	f033 4240 	bics.w	r2, r3, #3221225472	; 0xc0000000
 80105a0:	d003      	beq.n	80105aa <FLASH_WaitForLastOperation+0x6a>
 80105a2:	4b03      	ldr	r3, [pc, #12]	; (80105b0 <FLASH_WaitForLastOperation+0x70>)
    return HAL_ERROR;
 80105a4:	2001      	movs	r0, #1
    __HAL_FLASH_CLEAR_FLAG(error);
 80105a6:	611a      	str	r2, [r3, #16]
}
 80105a8:	bd70      	pop	{r4, r5, r6, pc}
    return HAL_ERROR;
 80105aa:	2001      	movs	r0, #1
}
 80105ac:	bd70      	pop	{r4, r5, r6, pc}
 80105ae:	bf00      	nop
 80105b0:	40022000 	.word	0x40022000
 80105b4:	20000128 	.word	0x20000128

080105b8 <HAL_FLASH_Program>:
{
 80105b8:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  __HAL_LOCK(&pFlash);
 80105bc:	4e32      	ldr	r6, [pc, #200]	; (8010688 <HAL_FLASH_Program+0xd0>)
{
 80105be:	4698      	mov	r8, r3
  __HAL_LOCK(&pFlash);
 80105c0:	7833      	ldrb	r3, [r6, #0]
 80105c2:	2b01      	cmp	r3, #1
 80105c4:	d027      	beq.n	8010616 <HAL_FLASH_Program+0x5e>
 80105c6:	2301      	movs	r3, #1
 80105c8:	4607      	mov	r7, r0
  status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
 80105ca:	f24c 3050 	movw	r0, #50000	; 0xc350
 80105ce:	460d      	mov	r5, r1
 80105d0:	4614      	mov	r4, r2
  __HAL_LOCK(&pFlash);
 80105d2:	7033      	strb	r3, [r6, #0]
  status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
 80105d4:	f7ff ffb4 	bl	8010540 <FLASH_WaitForLastOperation>
 80105d8:	4681      	mov	r9, r0
  if(status == HAL_OK)
 80105da:	b120      	cbz	r0, 80105e6 <HAL_FLASH_Program+0x2e>
  __HAL_UNLOCK(&pFlash);
 80105dc:	2300      	movs	r3, #0
 80105de:	7033      	strb	r3, [r6, #0]
}
 80105e0:	4648      	mov	r0, r9
 80105e2:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    if(READ_BIT(FLASH->ACR, FLASH_ACR_DCEN) != 0U)
 80105e6:	4a29      	ldr	r2, [pc, #164]	; (801068c <HAL_FLASH_Program+0xd4>)
    pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;
 80105e8:	6070      	str	r0, [r6, #4]
    if(READ_BIT(FLASH->ACR, FLASH_ACR_DCEN) != 0U)
 80105ea:	6813      	ldr	r3, [r2, #0]
 80105ec:	f413 6380 	ands.w	r3, r3, #1024	; 0x400
      __HAL_FLASH_DATA_CACHE_DISABLE();
 80105f0:	bf1f      	itttt	ne
 80105f2:	6813      	ldrne	r3, [r2, #0]
 80105f4:	f423 6380 	bicne.w	r3, r3, #1024	; 0x400
 80105f8:	6013      	strne	r3, [r2, #0]
      pFlash.CacheToReactivate = FLASH_CACHE_DCACHE_ENABLED;
 80105fa:	2302      	movne	r3, #2
      pFlash.CacheToReactivate = FLASH_CACHE_DISABLED;
 80105fc:	7733      	strb	r3, [r6, #28]
    if(TypeProgram == FLASH_TYPEPROGRAM_DOUBLEWORD)
 80105fe:	b17f      	cbz	r7, 8010620 <HAL_FLASH_Program+0x68>
    else if((TypeProgram == FLASH_TYPEPROGRAM_FAST) || (TypeProgram == FLASH_TYPEPROGRAM_FAST_AND_LAST))
 8010600:	1e7b      	subs	r3, r7, #1
 8010602:	2b01      	cmp	r3, #1
 8010604:	d922      	bls.n	801064c <HAL_FLASH_Program+0x94>
    status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
 8010606:	f24c 3050 	movw	r0, #50000	; 0xc350
 801060a:	f7ff ff99 	bl	8010540 <FLASH_WaitForLastOperation>
 801060e:	4681      	mov	r9, r0
    FLASH_FlushCaches();
 8010610:	f000 f85c 	bl	80106cc <FLASH_FlushCaches>
 8010614:	e7e2      	b.n	80105dc <HAL_FLASH_Program+0x24>
  __HAL_LOCK(&pFlash);
 8010616:	f04f 0902 	mov.w	r9, #2
}
 801061a:	4648      	mov	r0, r9
 801061c:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
{
  /* Check the parameters */
  assert_param(IS_FLASH_PROGRAM_ADDRESS(Address));

  /* Set PG bit */
  SET_BIT(FLASH->CR, FLASH_CR_PG);
 8010620:	4a1a      	ldr	r2, [pc, #104]	; (801068c <HAL_FLASH_Program+0xd4>)
 8010622:	6953      	ldr	r3, [r2, #20]
 8010624:	f043 0301 	orr.w	r3, r3, #1
 8010628:	6153      	str	r3, [r2, #20]

  /* Program first word */
  *(__IO uint32_t*)Address = (uint32_t)Data;
 801062a:	602c      	str	r4, [r5, #0]
  __ASM volatile ("isb 0xF":::"memory");
 801062c:	f3bf 8f6f 	isb	sy
    status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
 8010630:	f24c 3050 	movw	r0, #50000	; 0xc350
  /* Barrier to ensure programming is performed in 2 steps, in right order
    (independently of compiler optimization behavior) */
  __ISB();

  /* Program second word */
  *(__IO uint32_t*)(Address+4U) = (uint32_t)(Data >> 32);
 8010634:	f8c5 8004 	str.w	r8, [r5, #4]
    status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
 8010638:	f7ff ff82 	bl	8010540 <FLASH_WaitForLastOperation>
 801063c:	f06f 0101 	mvn.w	r1, #1
 8010640:	4681      	mov	r9, r0
      CLEAR_BIT(FLASH->CR, prog_bit);
 8010642:	4a12      	ldr	r2, [pc, #72]	; (801068c <HAL_FLASH_Program+0xd4>)
 8010644:	6953      	ldr	r3, [r2, #20]
 8010646:	400b      	ands	r3, r1
 8010648:	6153      	str	r3, [r2, #20]
 801064a:	e7e1      	b.n	8010610 <HAL_FLASH_Program+0x58>

  /* Check the parameters */
  assert_param(IS_FLASH_MAIN_MEM_ADDRESS(Address));

  /* Set FSTPG bit */
  SET_BIT(FLASH->CR, FLASH_CR_FSTPG);
 801064c:	490f      	ldr	r1, [pc, #60]	; (801068c <HAL_FLASH_Program+0xd4>)
 801064e:	694b      	ldr	r3, [r1, #20]
 8010650:	f443 2380 	orr.w	r3, r3, #262144	; 0x40000
  __IO uint32_t *src_addr = (__IO uint32_t*)DataAddress;
 8010654:	4622      	mov	r2, r4
  SET_BIT(FLASH->CR, FLASH_CR_FSTPG);
 8010656:	614b      	str	r3, [r1, #20]
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 8010658:	f3ef 8410 	mrs	r4, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 801065c:	b672      	cpsid	i
 801065e:	1aa9      	subs	r1, r5, r2
 8010660:	f502 7080 	add.w	r0, r2, #256	; 0x100
  __disable_irq();

  /* Program the double word of the row */
  do
  {
    *dest_addr = *src_addr;
 8010664:	6813      	ldr	r3, [r2, #0]
 8010666:	5053      	str	r3, [r2, r1]
    dest_addr++;
    src_addr++;
 8010668:	3204      	adds	r2, #4
    row_index--;
  } while (row_index != 0U);
 801066a:	4282      	cmp	r2, r0
 801066c:	d1fa      	bne.n	8010664 <HAL_FLASH_Program+0xac>
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 801066e:	f384 8810 	msr	PRIMASK, r4
      if(TypeProgram == FLASH_TYPEPROGRAM_FAST_AND_LAST)
 8010672:	2f02      	cmp	r7, #2
    status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
 8010674:	f24c 3050 	movw	r0, #50000	; 0xc350
      if(TypeProgram == FLASH_TYPEPROGRAM_FAST_AND_LAST)
 8010678:	d1c7      	bne.n	801060a <HAL_FLASH_Program+0x52>
    status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
 801067a:	f7ff ff61 	bl	8010540 <FLASH_WaitForLastOperation>
 801067e:	f46f 2180 	mvn.w	r1, #262144	; 0x40000
 8010682:	4681      	mov	r9, r0
    if (prog_bit != 0U)
 8010684:	e7dd      	b.n	8010642 <HAL_FLASH_Program+0x8a>
 8010686:	bf00      	nop
 8010688:	20000128 	.word	0x20000128
 801068c:	40022000 	.word	0x40022000

08010690 <FLASH_PageErase>:
  {
    assert_param(IS_FLASH_BANK_EXCLUSIVE(Banks));

    if((Banks & FLASH_BANK_1) != 0U)
    {
      CLEAR_BIT(FLASH->CR, FLASH_CR_BKER);
 8010690:	4a0d      	ldr	r2, [pc, #52]	; (80106c8 <FLASH_PageErase+0x38>)
 8010692:	6953      	ldr	r3, [r2, #20]
    if((Banks & FLASH_BANK_1) != 0U)
 8010694:	07c9      	lsls	r1, r1, #31
      CLEAR_BIT(FLASH->CR, FLASH_CR_BKER);
 8010696:	bf4c      	ite	mi
 8010698:	f423 6300 	bicmi.w	r3, r3, #2048	; 0x800
    }
    else
    {
      SET_BIT(FLASH->CR, FLASH_CR_BKER);
 801069c:	f443 6300 	orrpl.w	r3, r3, #2048	; 0x800
 80106a0:	6153      	str	r3, [r2, #20]
  /* Prevent unused argument(s) compilation warning */
  UNUSED(Banks);
#endif

  /* Proceed to erase the page */
  MODIFY_REG(FLASH->CR, FLASH_CR_PNB, ((Page & 0xFFU) << FLASH_CR_PNB_Pos));
 80106a2:	4b09      	ldr	r3, [pc, #36]	; (80106c8 <FLASH_PageErase+0x38>)
 80106a4:	695a      	ldr	r2, [r3, #20]
 80106a6:	00c0      	lsls	r0, r0, #3
 80106a8:	f422 62ff 	bic.w	r2, r2, #2040	; 0x7f8
 80106ac:	f400 60ff 	and.w	r0, r0, #2040	; 0x7f8
 80106b0:	4310      	orrs	r0, r2
 80106b2:	6158      	str	r0, [r3, #20]
  SET_BIT(FLASH->CR, FLASH_CR_PER);
 80106b4:	695a      	ldr	r2, [r3, #20]
 80106b6:	f042 0202 	orr.w	r2, r2, #2
 80106ba:	615a      	str	r2, [r3, #20]
  SET_BIT(FLASH->CR, FLASH_CR_STRT);
 80106bc:	695a      	ldr	r2, [r3, #20]
 80106be:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
 80106c2:	615a      	str	r2, [r3, #20]
}
 80106c4:	4770      	bx	lr
 80106c6:	bf00      	nop
 80106c8:	40022000 	.word	0x40022000

080106cc <FLASH_FlushCaches>:
  * @brief  Flush the instruction and data caches.
  * @retval None
  */
void FLASH_FlushCaches(void)
{
  FLASH_CacheTypeDef cache = pFlash.CacheToReactivate;
 80106cc:	4913      	ldr	r1, [pc, #76]	; (801071c <FLASH_FlushCaches+0x50>)
 80106ce:	7f0b      	ldrb	r3, [r1, #28]

  /* Flush instruction cache  */
  if((cache == FLASH_CACHE_ICACHE_ENABLED) ||
 80106d0:	f003 02fd 	and.w	r2, r3, #253	; 0xfd
 80106d4:	2a01      	cmp	r2, #1
  FLASH_CacheTypeDef cache = pFlash.CacheToReactivate;
 80106d6:	b2db      	uxtb	r3, r3
  if((cache == FLASH_CACHE_ICACHE_ENABLED) ||
 80106d8:	d10c      	bne.n	80106f4 <FLASH_FlushCaches+0x28>
     (cache == FLASH_CACHE_ICACHE_DCACHE_ENABLED))
  {
    /* Reset instruction cache */
    __HAL_FLASH_INSTRUCTION_CACHE_RESET();
 80106da:	4a11      	ldr	r2, [pc, #68]	; (8010720 <FLASH_FlushCaches+0x54>)
 80106dc:	6810      	ldr	r0, [r2, #0]
 80106de:	f440 6000 	orr.w	r0, r0, #2048	; 0x800
 80106e2:	6010      	str	r0, [r2, #0]
 80106e4:	6810      	ldr	r0, [r2, #0]
 80106e6:	f420 6000 	bic.w	r0, r0, #2048	; 0x800
 80106ea:	6010      	str	r0, [r2, #0]
    /* Enable instruction cache */
    __HAL_FLASH_INSTRUCTION_CACHE_ENABLE();
 80106ec:	6810      	ldr	r0, [r2, #0]
 80106ee:	f440 7000 	orr.w	r0, r0, #512	; 0x200
 80106f2:	6010      	str	r0, [r2, #0]
  }

  /* Flush data cache */
  if((cache == FLASH_CACHE_DCACHE_ENABLED) ||
 80106f4:	3b02      	subs	r3, #2
 80106f6:	2b01      	cmp	r3, #1
 80106f8:	d80c      	bhi.n	8010714 <FLASH_FlushCaches+0x48>
     (cache == FLASH_CACHE_ICACHE_DCACHE_ENABLED))
  {
    /* Reset data cache */
    __HAL_FLASH_DATA_CACHE_RESET();
 80106fa:	4b09      	ldr	r3, [pc, #36]	; (8010720 <FLASH_FlushCaches+0x54>)
 80106fc:	681a      	ldr	r2, [r3, #0]
 80106fe:	f442 5280 	orr.w	r2, r2, #4096	; 0x1000
 8010702:	601a      	str	r2, [r3, #0]
 8010704:	681a      	ldr	r2, [r3, #0]
 8010706:	f422 5280 	bic.w	r2, r2, #4096	; 0x1000
 801070a:	601a      	str	r2, [r3, #0]
    /* Enable data cache */
    __HAL_FLASH_DATA_CACHE_ENABLE();
 801070c:	681a      	ldr	r2, [r3, #0]
 801070e:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
 8010712:	601a      	str	r2, [r3, #0]
  }

  /* Reset internal variable */
  pFlash.CacheToReactivate = FLASH_CACHE_DISABLED;
 8010714:	2300      	movs	r3, #0
 8010716:	770b      	strb	r3, [r1, #28]
}
 8010718:	4770      	bx	lr
 801071a:	bf00      	nop
 801071c:	20000128 	.word	0x20000128
 8010720:	40022000 	.word	0x40022000

08010724 <HAL_FLASHEx_Erase>:
{
 8010724:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  __HAL_LOCK(&pFlash);
 8010728:	4f41      	ldr	r7, [pc, #260]	; (8010830 <HAL_FLASHEx_Erase+0x10c>)
 801072a:	783b      	ldrb	r3, [r7, #0]
 801072c:	2b01      	cmp	r3, #1
 801072e:	d04a      	beq.n	80107c6 <HAL_FLASHEx_Erase+0xa2>
 8010730:	4604      	mov	r4, r0
 8010732:	2501      	movs	r5, #1
  status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
 8010734:	f24c 3050 	movw	r0, #50000	; 0xc350
 8010738:	4688      	mov	r8, r1
  __HAL_LOCK(&pFlash);
 801073a:	703d      	strb	r5, [r7, #0]
  status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
 801073c:	f7ff ff00 	bl	8010540 <FLASH_WaitForLastOperation>
  if (status == HAL_OK)
 8010740:	4606      	mov	r6, r0
 8010742:	b120      	cbz	r0, 801074e <HAL_FLASHEx_Erase+0x2a>
  __HAL_UNLOCK(&pFlash);
 8010744:	2300      	movs	r3, #0
 8010746:	703b      	strb	r3, [r7, #0]
}
 8010748:	4630      	mov	r0, r6
 801074a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    if(READ_BIT(FLASH->ACR, FLASH_ACR_ICEN) != 0U)
 801074e:	4b39      	ldr	r3, [pc, #228]	; (8010834 <HAL_FLASHEx_Erase+0x110>)
    pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;
 8010750:	6078      	str	r0, [r7, #4]
    if(READ_BIT(FLASH->ACR, FLASH_ACR_ICEN) != 0U)
 8010752:	681a      	ldr	r2, [r3, #0]
 8010754:	f412 7f00 	tst.w	r2, #512	; 0x200
      __HAL_FLASH_INSTRUCTION_CACHE_DISABLE();
 8010758:	681a      	ldr	r2, [r3, #0]
    if(READ_BIT(FLASH->ACR, FLASH_ACR_ICEN) != 0U)
 801075a:	d138      	bne.n	80107ce <HAL_FLASHEx_Erase+0xaa>
    else if(READ_BIT(FLASH->ACR, FLASH_ACR_DCEN) != 0U)
 801075c:	0551      	lsls	r1, r2, #21
 801075e:	d545      	bpl.n	80107ec <HAL_FLASHEx_Erase+0xc8>
      __HAL_FLASH_DATA_CACHE_DISABLE();
 8010760:	681a      	ldr	r2, [r3, #0]
 8010762:	f422 6280 	bic.w	r2, r2, #1024	; 0x400
 8010766:	601a      	str	r2, [r3, #0]
      pFlash.CacheToReactivate = FLASH_CACHE_DCACHE_ENABLED;
 8010768:	2302      	movs	r3, #2
 801076a:	773b      	strb	r3, [r7, #28]
    if (pEraseInit->TypeErase == FLASH_TYPEERASE_MASSERASE)
 801076c:	6823      	ldr	r3, [r4, #0]
 801076e:	2b01      	cmp	r3, #1
 8010770:	d03e      	beq.n	80107f0 <HAL_FLASHEx_Erase+0xcc>
      *PageError = 0xFFFFFFFFU;
 8010772:	f04f 33ff 	mov.w	r3, #4294967295
 8010776:	f8c8 3000 	str.w	r3, [r8]
      for(page_index = pEraseInit->Page; page_index < (pEraseInit->Page + pEraseInit->NbPages); page_index++)
 801077a:	e9d4 5302 	ldrd	r5, r3, [r4, #8]
 801077e:	442b      	add	r3, r5
 8010780:	429d      	cmp	r5, r3
 8010782:	d21d      	bcs.n	80107c0 <HAL_FLASHEx_Erase+0x9c>
        CLEAR_BIT(FLASH->CR, (FLASH_CR_PER | FLASH_CR_PNB));
 8010784:	f8df a0ac 	ldr.w	sl, [pc, #172]	; 8010834 <HAL_FLASHEx_Erase+0x110>
 8010788:	f8df 90ac 	ldr.w	r9, [pc, #172]	; 8010838 <HAL_FLASHEx_Erase+0x114>
 801078c:	e005      	b.n	801079a <HAL_FLASHEx_Erase+0x76>
      for(page_index = pEraseInit->Page; page_index < (pEraseInit->Page + pEraseInit->NbPages); page_index++)
 801078e:	e9d4 3202 	ldrd	r3, r2, [r4, #8]
 8010792:	3501      	adds	r5, #1
 8010794:	4413      	add	r3, r2
 8010796:	42ab      	cmp	r3, r5
 8010798:	d912      	bls.n	80107c0 <HAL_FLASHEx_Erase+0x9c>
        FLASH_PageErase(page_index, pEraseInit->Banks);
 801079a:	6861      	ldr	r1, [r4, #4]
 801079c:	4628      	mov	r0, r5
 801079e:	f7ff ff77 	bl	8010690 <FLASH_PageErase>
        status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
 80107a2:	f24c 3050 	movw	r0, #50000	; 0xc350
 80107a6:	f7ff fecb 	bl	8010540 <FLASH_WaitForLastOperation>
        CLEAR_BIT(FLASH->CR, (FLASH_CR_PER | FLASH_CR_PNB));
 80107aa:	f8da 3014 	ldr.w	r3, [sl, #20]
 80107ae:	ea03 0309 	and.w	r3, r3, r9
 80107b2:	f8ca 3014 	str.w	r3, [sl, #20]
        if (status != HAL_OK)
 80107b6:	2800      	cmp	r0, #0
 80107b8:	d0e9      	beq.n	801078e <HAL_FLASHEx_Erase+0x6a>
          *PageError = page_index;
 80107ba:	f8c8 5000 	str.w	r5, [r8]
        status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
 80107be:	4606      	mov	r6, r0
    FLASH_FlushCaches();
 80107c0:	f7ff ff84 	bl	80106cc <FLASH_FlushCaches>
 80107c4:	e7be      	b.n	8010744 <HAL_FLASHEx_Erase+0x20>
  __HAL_LOCK(&pFlash);
 80107c6:	2602      	movs	r6, #2
}
 80107c8:	4630      	mov	r0, r6
 80107ca:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
      __HAL_FLASH_INSTRUCTION_CACHE_DISABLE();
 80107ce:	f422 7200 	bic.w	r2, r2, #512	; 0x200
 80107d2:	601a      	str	r2, [r3, #0]
      if(READ_BIT(FLASH->ACR, FLASH_ACR_DCEN) != 0U)
 80107d4:	681a      	ldr	r2, [r3, #0]
 80107d6:	0550      	lsls	r0, r2, #21
 80107d8:	d506      	bpl.n	80107e8 <HAL_FLASHEx_Erase+0xc4>
        __HAL_FLASH_DATA_CACHE_DISABLE();
 80107da:	681a      	ldr	r2, [r3, #0]
 80107dc:	f422 6280 	bic.w	r2, r2, #1024	; 0x400
 80107e0:	601a      	str	r2, [r3, #0]
        pFlash.CacheToReactivate = FLASH_CACHE_ICACHE_DCACHE_ENABLED;
 80107e2:	2303      	movs	r3, #3
 80107e4:	773b      	strb	r3, [r7, #28]
 80107e6:	e7c1      	b.n	801076c <HAL_FLASHEx_Erase+0x48>
        pFlash.CacheToReactivate = FLASH_CACHE_ICACHE_ENABLED;
 80107e8:	773d      	strb	r5, [r7, #28]
 80107ea:	e7bf      	b.n	801076c <HAL_FLASHEx_Erase+0x48>
      pFlash.CacheToReactivate = FLASH_CACHE_DISABLED;
 80107ec:	7738      	strb	r0, [r7, #28]
 80107ee:	e7bd      	b.n	801076c <HAL_FLASHEx_Erase+0x48>
      FLASH_MassErase(pEraseInit->Banks);
 80107f0:	6863      	ldr	r3, [r4, #4]
    if((Banks & FLASH_BANK_1) != 0U)
 80107f2:	07da      	lsls	r2, r3, #31
 80107f4:	d504      	bpl.n	8010800 <HAL_FLASHEx_Erase+0xdc>
      SET_BIT(FLASH->CR, FLASH_CR_MER1);
 80107f6:	490f      	ldr	r1, [pc, #60]	; (8010834 <HAL_FLASHEx_Erase+0x110>)
 80107f8:	694a      	ldr	r2, [r1, #20]
 80107fa:	f042 0204 	orr.w	r2, r2, #4
 80107fe:	614a      	str	r2, [r1, #20]
    if((Banks & FLASH_BANK_2) != 0U)
 8010800:	079b      	lsls	r3, r3, #30
 8010802:	d504      	bpl.n	801080e <HAL_FLASHEx_Erase+0xea>
      SET_BIT(FLASH->CR, FLASH_CR_MER2);
 8010804:	4a0b      	ldr	r2, [pc, #44]	; (8010834 <HAL_FLASHEx_Erase+0x110>)
 8010806:	6953      	ldr	r3, [r2, #20]
 8010808:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 801080c:	6153      	str	r3, [r2, #20]
  SET_BIT(FLASH->CR, FLASH_CR_STRT);
 801080e:	4c09      	ldr	r4, [pc, #36]	; (8010834 <HAL_FLASHEx_Erase+0x110>)
 8010810:	6963      	ldr	r3, [r4, #20]
 8010812:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 8010816:	6163      	str	r3, [r4, #20]
      status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
 8010818:	f24c 3050 	movw	r0, #50000	; 0xc350
 801081c:	f7ff fe90 	bl	8010540 <FLASH_WaitForLastOperation>
      CLEAR_BIT(FLASH->CR, (FLASH_CR_MER1 | FLASH_CR_MER2));
 8010820:	6963      	ldr	r3, [r4, #20]
 8010822:	f423 4300 	bic.w	r3, r3, #32768	; 0x8000
 8010826:	f023 0304 	bic.w	r3, r3, #4
      status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
 801082a:	4606      	mov	r6, r0
      CLEAR_BIT(FLASH->CR, (FLASH_CR_MER1 | FLASH_CR_MER2));
 801082c:	6163      	str	r3, [r4, #20]
 801082e:	e7c7      	b.n	80107c0 <HAL_FLASHEx_Erase+0x9c>
 8010830:	20000128 	.word	0x20000128
 8010834:	40022000 	.word	0x40022000
 8010838:	fffff805 	.word	0xfffff805

0801083c <HAL_GPIO_Init>:
  * @param  GPIO_Init: pointer to a GPIO_InitTypeDef structure that contains
  *         the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, GPIO_InitTypeDef *GPIO_Init)
{
 801083c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  assert_param(IS_GPIO_PIN(GPIO_Init->Pin));
  assert_param(IS_GPIO_MODE(GPIO_Init->Mode));
  assert_param(IS_GPIO_PULL(GPIO_Init->Pull));

  /* Configure the port pins */
  while (((GPIO_Init->Pin) >> position) != 0x00u)
 8010840:	680d      	ldr	r5, [r1, #0]
{
 8010842:	b083      	sub	sp, #12
  while (((GPIO_Init->Pin) >> position) != 0x00u)
 8010844:	2d00      	cmp	r5, #0
 8010846:	f000 80a9 	beq.w	801099c <HAL_GPIO_Init+0x160>
  uint32_t position = 0x00u;
 801084a:	2300      	movs	r3, #0
  {
    /* Get current io position */
    iocurrent = (GPIO_Init->Pin) & (1uL << position);
 801084c:	f04f 0b01 	mov.w	fp, #1
 8010850:	fa0b f703 	lsl.w	r7, fp, r3

    if (iocurrent != 0x00u)
 8010854:	ea17 0a05 	ands.w	sl, r7, r5
 8010858:	f000 809b 	beq.w	8010992 <HAL_GPIO_Init+0x156>
    {
      /*--------------------- GPIO Mode Configuration ------------------------*/
      /* In case of Alternate function mode selection */
      if((GPIO_Init->Mode == GPIO_MODE_AF_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
 801085c:	684c      	ldr	r4, [r1, #4]
 801085e:	f024 0e10 	bic.w	lr, r4, #16
 8010862:	f1be 0f02 	cmp.w	lr, #2
 8010866:	f000 809c 	beq.w	80109a2 <HAL_GPIO_Init+0x166>
        temp |= ((GPIO_Init->Alternate) << ((position & 0x07u) * 4u));
        GPIOx->AFR[position >> 3u] = temp;
      }

      /* Configure IO Direction mode (Input, Output, Alternate or Analog) */
      temp = GPIOx->MODER;
 801086a:	f8d0 8000 	ldr.w	r8, [r0]
      temp &= ~(GPIO_MODER_MODE0 << (position * 2u));
 801086e:	ea4f 0c43 	mov.w	ip, r3, lsl #1
 8010872:	2203      	movs	r2, #3
 8010874:	fa02 f20c 	lsl.w	r2, r2, ip
 8010878:	ea28 0602 	bic.w	r6, r8, r2
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2u));
 801087c:	f004 0803 	and.w	r8, r4, #3
      GPIOx->MODER = temp;

      /* In case of Output or Alternate function mode selection */
      if((GPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_PP) ||
 8010880:	f10e 3eff 	add.w	lr, lr, #4294967295
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2u));
 8010884:	fa08 f90c 	lsl.w	r9, r8, ip
 8010888:	ea49 0906 	orr.w	r9, r9, r6
      if((GPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_PP) ||
 801088c:	f1be 0f01 	cmp.w	lr, #1
      temp &= ~(GPIO_MODER_MODE0 << (position * 2u));
 8010890:	ea6f 0202 	mvn.w	r2, r2
      GPIOx->MODER = temp;
 8010894:	f8c0 9000 	str.w	r9, [r0]
      if((GPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_PP) ||
 8010898:	f240 80ac 	bls.w	80109f4 <HAL_GPIO_Init+0x1b8>
      }

#if defined(STM32L471xx) || defined(STM32L475xx) || defined(STM32L476xx) || defined(STM32L485xx) || defined(STM32L486xx)

      /* In case of Analog mode, check if ADC control mode is selected */
      if((GPIO_Init->Mode & GPIO_MODE_ANALOG) == GPIO_MODE_ANALOG)
 801089c:	f1b8 0f03 	cmp.w	r8, #3
 80108a0:	d109      	bne.n	80108b6 <HAL_GPIO_Init+0x7a>
      {
        /* Configure the IO Output Type */
        temp = GPIOx->ASCR;
 80108a2:	f8d0 e02c 	ldr.w	lr, [r0, #44]	; 0x2c
        temp &= ~(GPIO_ASCR_ASC0 << position) ;
 80108a6:	ea2e 0e07 	bic.w	lr, lr, r7
        temp |= (((GPIO_Init->Mode & ANALOG_MODE) >> 3) << position);
 80108aa:	f3c4 07c0 	ubfx	r7, r4, #3, #1
 80108ae:	409f      	lsls	r7, r3
 80108b0:	ea47 070e 	orr.w	r7, r7, lr
        GPIOx->ASCR = temp;
 80108b4:	62c7      	str	r7, [r0, #44]	; 0x2c
      }

#endif /* STM32L471xx || STM32L475xx || STM32L476xx || STM32L485xx || STM32L486xx */

      /* Activate the Pull-up or Pull down resistor for the current IO */
      temp = GPIOx->PUPDR;
 80108b6:	68c7      	ldr	r7, [r0, #12]
      temp &= ~(GPIO_PUPDR_PUPD0 << (position * 2u));
 80108b8:	403a      	ands	r2, r7
      temp |= ((GPIO_Init->Pull) << (position * 2u));
 80108ba:	688f      	ldr	r7, [r1, #8]
 80108bc:	fa07 f70c 	lsl.w	r7, r7, ip
 80108c0:	4317      	orrs	r7, r2
      GPIOx->PUPDR = temp;
 80108c2:	60c7      	str	r7, [r0, #12]

      /*--------------------- EXTI Mode Configuration ------------------------*/
      /* Configure the External Interrupt or event for the current IO */
      if((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE)
 80108c4:	00e7      	lsls	r7, r4, #3
 80108c6:	d564      	bpl.n	8010992 <HAL_GPIO_Init+0x156>
      {
        /* Enable SYSCFG Clock */
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 80108c8:	4f67      	ldr	r7, [pc, #412]	; (8010a68 <HAL_GPIO_Init+0x22c>)
 80108ca:	6e3a      	ldr	r2, [r7, #96]	; 0x60
 80108cc:	f042 0201 	orr.w	r2, r2, #1
 80108d0:	663a      	str	r2, [r7, #96]	; 0x60
 80108d2:	6e3a      	ldr	r2, [r7, #96]	; 0x60
 80108d4:	f002 0201 	and.w	r2, r2, #1
 80108d8:	9201      	str	r2, [sp, #4]
 80108da:	9a01      	ldr	r2, [sp, #4]

        temp = SYSCFG->EXTICR[position >> 2u];
 80108dc:	f023 0203 	bic.w	r2, r3, #3
 80108e0:	f102 4280 	add.w	r2, r2, #1073741824	; 0x40000000
 80108e4:	f502 3280 	add.w	r2, r2, #65536	; 0x10000
        temp &= ~(0x0FuL << (4u * (position & 0x03u)));
 80108e8:	f003 0e03 	and.w	lr, r3, #3
        temp = SYSCFG->EXTICR[position >> 2u];
 80108ec:	f8d2 c008 	ldr.w	ip, [r2, #8]
        temp &= ~(0x0FuL << (4u * (position & 0x03u)));
 80108f0:	ea4f 0e8e 	mov.w	lr, lr, lsl #2
 80108f4:	270f      	movs	r7, #15
 80108f6:	fa07 f70e 	lsl.w	r7, r7, lr
        temp |= (GPIO_GET_INDEX(GPIOx) << (4u * (position & 0x03u)));
 80108fa:	f1b0 4f90 	cmp.w	r0, #1207959552	; 0x48000000
        temp &= ~(0x0FuL << (4u * (position & 0x03u)));
 80108fe:	ea2c 0707 	bic.w	r7, ip, r7
        temp |= (GPIO_GET_INDEX(GPIOx) << (4u * (position & 0x03u)));
 8010902:	d01e      	beq.n	8010942 <HAL_GPIO_Init+0x106>
 8010904:	4e59      	ldr	r6, [pc, #356]	; (8010a6c <HAL_GPIO_Init+0x230>)
 8010906:	42b0      	cmp	r0, r6
 8010908:	f000 8093 	beq.w	8010a32 <HAL_GPIO_Init+0x1f6>
 801090c:	4e58      	ldr	r6, [pc, #352]	; (8010a70 <HAL_GPIO_Init+0x234>)
 801090e:	42b0      	cmp	r0, r6
 8010910:	f000 8094 	beq.w	8010a3c <HAL_GPIO_Init+0x200>
 8010914:	4e57      	ldr	r6, [pc, #348]	; (8010a74 <HAL_GPIO_Init+0x238>)
 8010916:	42b0      	cmp	r0, r6
 8010918:	f000 8084 	beq.w	8010a24 <HAL_GPIO_Init+0x1e8>
 801091c:	4e56      	ldr	r6, [pc, #344]	; (8010a78 <HAL_GPIO_Init+0x23c>)
 801091e:	42b0      	cmp	r0, r6
 8010920:	f000 8093 	beq.w	8010a4a <HAL_GPIO_Init+0x20e>
 8010924:	4e55      	ldr	r6, [pc, #340]	; (8010a7c <HAL_GPIO_Init+0x240>)
 8010926:	42b0      	cmp	r0, r6
 8010928:	f000 8096 	beq.w	8010a58 <HAL_GPIO_Init+0x21c>
 801092c:	4e54      	ldr	r6, [pc, #336]	; (8010a80 <HAL_GPIO_Init+0x244>)
 801092e:	42b0      	cmp	r0, r6
 8010930:	bf0c      	ite	eq
 8010932:	f04f 0c06 	moveq.w	ip, #6
 8010936:	f04f 0c07 	movne.w	ip, #7
 801093a:	fa0c fe0e 	lsl.w	lr, ip, lr
 801093e:	ea47 070e 	orr.w	r7, r7, lr
        SYSCFG->EXTICR[position >> 2u] = temp;
 8010942:	6097      	str	r7, [r2, #8]

        /* Clear EXTI line configuration */
        temp = EXTI->IMR1;
 8010944:	4a4f      	ldr	r2, [pc, #316]	; (8010a84 <HAL_GPIO_Init+0x248>)
 8010946:	6812      	ldr	r2, [r2, #0]
        temp &= ~(iocurrent);
        if((GPIO_Init->Mode & GPIO_MODE_IT) == GPIO_MODE_IT)
 8010948:	03e6      	lsls	r6, r4, #15
        temp &= ~(iocurrent);
 801094a:	ea6f 0c0a 	mvn.w	ip, sl
        {
          temp |= iocurrent;
        }
        EXTI->IMR1 = temp;
 801094e:	4e4d      	ldr	r6, [pc, #308]	; (8010a84 <HAL_GPIO_Init+0x248>)
        temp &= ~(iocurrent);
 8010950:	bf54      	ite	pl
 8010952:	ea0c 0202 	andpl.w	r2, ip, r2
          temp |= iocurrent;
 8010956:	ea4a 0202 	orrmi.w	r2, sl, r2
        EXTI->IMR1 = temp;
 801095a:	6032      	str	r2, [r6, #0]

        temp = EXTI->EMR1;
 801095c:	6877      	ldr	r7, [r6, #4]
        temp &= ~(iocurrent);
        if((GPIO_Init->Mode & GPIO_MODE_EVT) == GPIO_MODE_EVT)
 801095e:	03a2      	lsls	r2, r4, #14
        {
          temp |= iocurrent;
        }
        EXTI->EMR1 = temp;
 8010960:	4a48      	ldr	r2, [pc, #288]	; (8010a84 <HAL_GPIO_Init+0x248>)
        temp &= ~(iocurrent);
 8010962:	bf54      	ite	pl
 8010964:	ea0c 0707 	andpl.w	r7, ip, r7
          temp |= iocurrent;
 8010968:	ea4a 0707 	orrmi.w	r7, sl, r7
        EXTI->EMR1 = temp;
 801096c:	6057      	str	r7, [r2, #4]

        /* Clear Rising Falling edge configuration */
        temp = EXTI->RTSR1;
 801096e:	6897      	ldr	r7, [r2, #8]
        temp &= ~(iocurrent);
        if((GPIO_Init->Mode & RISING_EDGE) == RISING_EDGE)
        {
          temp |= iocurrent;
        }
        EXTI->RTSR1 = temp;
 8010970:	4a44      	ldr	r2, [pc, #272]	; (8010a84 <HAL_GPIO_Init+0x248>)
        if((GPIO_Init->Mode & RISING_EDGE) == RISING_EDGE)
 8010972:	02e6      	lsls	r6, r4, #11
        temp &= ~(iocurrent);
 8010974:	bf54      	ite	pl
 8010976:	ea0c 0707 	andpl.w	r7, ip, r7
          temp |= iocurrent;
 801097a:	ea4a 0707 	orrmi.w	r7, sl, r7
        EXTI->RTSR1 = temp;
 801097e:	6097      	str	r7, [r2, #8]

        temp = EXTI->FTSR1;
 8010980:	68d2      	ldr	r2, [r2, #12]
        temp &= ~(iocurrent);
        if((GPIO_Init->Mode & FALLING_EDGE) == FALLING_EDGE)
 8010982:	02a4      	lsls	r4, r4, #10
        {
          temp |= iocurrent;
        }
        EXTI->FTSR1 = temp;
 8010984:	4c3f      	ldr	r4, [pc, #252]	; (8010a84 <HAL_GPIO_Init+0x248>)
        temp &= ~(iocurrent);
 8010986:	bf54      	ite	pl
 8010988:	ea0c 0202 	andpl.w	r2, ip, r2
          temp |= iocurrent;
 801098c:	ea4a 0202 	orrmi.w	r2, sl, r2
        EXTI->FTSR1 = temp;
 8010990:	60e2      	str	r2, [r4, #12]
      }
    }

    position++;
 8010992:	3301      	adds	r3, #1
  while (((GPIO_Init->Pin) >> position) != 0x00u)
 8010994:	fa35 f203 	lsrs.w	r2, r5, r3
 8010998:	f47f af5a 	bne.w	8010850 <HAL_GPIO_Init+0x14>
  }
}
 801099c:	b003      	add	sp, #12
 801099e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        temp = GPIOx->AFR[position >> 3u];
 80109a2:	ea4f 0cd3 	mov.w	ip, r3, lsr #3
 80109a6:	eb00 0c8c 	add.w	ip, r0, ip, lsl #2
        temp |= ((GPIO_Init->Alternate) << ((position & 0x07u) * 4u));
 80109aa:	690a      	ldr	r2, [r1, #16]
        temp = GPIOx->AFR[position >> 3u];
 80109ac:	f8dc 8020 	ldr.w	r8, [ip, #32]
        temp &= ~(0xFu << ((position & 0x07u) * 4u));
 80109b0:	f003 0e07 	and.w	lr, r3, #7
 80109b4:	ea4f 0e8e 	mov.w	lr, lr, lsl #2
 80109b8:	f04f 090f 	mov.w	r9, #15
        temp |= ((GPIO_Init->Alternate) << ((position & 0x07u) * 4u));
 80109bc:	fa02 f20e 	lsl.w	r2, r2, lr
        temp &= ~(0xFu << ((position & 0x07u) * 4u));
 80109c0:	fa09 fe0e 	lsl.w	lr, r9, lr
 80109c4:	ea28 0e0e 	bic.w	lr, r8, lr
        temp |= ((GPIO_Init->Alternate) << ((position & 0x07u) * 4u));
 80109c8:	ea42 020e 	orr.w	r2, r2, lr
        GPIOx->AFR[position >> 3u] = temp;
 80109cc:	f8cc 2020 	str.w	r2, [ip, #32]
      temp = GPIOx->MODER;
 80109d0:	f8d0 e000 	ldr.w	lr, [r0]
      temp &= ~(GPIO_MODER_MODE0 << (position * 2u));
 80109d4:	ea4f 0c43 	mov.w	ip, r3, lsl #1
 80109d8:	2203      	movs	r2, #3
 80109da:	fa02 f20c 	lsl.w	r2, r2, ip
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2u));
 80109de:	f004 0803 	and.w	r8, r4, #3
      temp &= ~(GPIO_MODER_MODE0 << (position * 2u));
 80109e2:	ea2e 0e02 	bic.w	lr, lr, r2
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2u));
 80109e6:	fa08 f90c 	lsl.w	r9, r8, ip
 80109ea:	ea49 0e0e 	orr.w	lr, r9, lr
      temp &= ~(GPIO_MODER_MODE0 << (position * 2u));
 80109ee:	43d2      	mvns	r2, r2
      GPIOx->MODER = temp;
 80109f0:	f8c0 e000 	str.w	lr, [r0]
        temp = GPIOx->OSPEEDR;
 80109f4:	f8d0 e008 	ldr.w	lr, [r0, #8]
        temp |= (GPIO_Init->Speed << (position * 2u));
 80109f8:	68ce      	ldr	r6, [r1, #12]
        temp &= ~(GPIO_OSPEEDR_OSPEED0 << (position * 2u));
 80109fa:	ea02 0e0e 	and.w	lr, r2, lr
        temp |= (GPIO_Init->Speed << (position * 2u));
 80109fe:	fa06 f90c 	lsl.w	r9, r6, ip
 8010a02:	ea49 0e0e 	orr.w	lr, r9, lr
        GPIOx->OSPEEDR = temp;
 8010a06:	f8c0 e008 	str.w	lr, [r0, #8]
        temp = GPIOx->OTYPER;
 8010a0a:	f8d0 9004 	ldr.w	r9, [r0, #4]
        temp |= (((GPIO_Init->Mode & GPIO_OUTPUT_TYPE) >> 4u) << position);
 8010a0e:	f3c4 1e00 	ubfx	lr, r4, #4, #1
        temp &= ~(GPIO_OTYPER_OT0 << position) ;
 8010a12:	ea29 0907 	bic.w	r9, r9, r7
        temp |= (((GPIO_Init->Mode & GPIO_OUTPUT_TYPE) >> 4u) << position);
 8010a16:	fa0e fe03 	lsl.w	lr, lr, r3
 8010a1a:	ea4e 0e09 	orr.w	lr, lr, r9
        GPIOx->OTYPER = temp;
 8010a1e:	f8c0 e004 	str.w	lr, [r0, #4]
 8010a22:	e73b      	b.n	801089c <HAL_GPIO_Init+0x60>
        temp |= (GPIO_GET_INDEX(GPIOx) << (4u * (position & 0x03u)));
 8010a24:	f04f 0c03 	mov.w	ip, #3
 8010a28:	fa0c fe0e 	lsl.w	lr, ip, lr
 8010a2c:	ea47 070e 	orr.w	r7, r7, lr
 8010a30:	e787      	b.n	8010942 <HAL_GPIO_Init+0x106>
 8010a32:	fa0b fe0e 	lsl.w	lr, fp, lr
 8010a36:	ea47 070e 	orr.w	r7, r7, lr
 8010a3a:	e782      	b.n	8010942 <HAL_GPIO_Init+0x106>
 8010a3c:	f04f 0c02 	mov.w	ip, #2
 8010a40:	fa0c fe0e 	lsl.w	lr, ip, lr
 8010a44:	ea47 070e 	orr.w	r7, r7, lr
 8010a48:	e77b      	b.n	8010942 <HAL_GPIO_Init+0x106>
 8010a4a:	f04f 0c04 	mov.w	ip, #4
 8010a4e:	fa0c fe0e 	lsl.w	lr, ip, lr
 8010a52:	ea47 070e 	orr.w	r7, r7, lr
 8010a56:	e774      	b.n	8010942 <HAL_GPIO_Init+0x106>
 8010a58:	f04f 0c05 	mov.w	ip, #5
 8010a5c:	fa0c fe0e 	lsl.w	lr, ip, lr
 8010a60:	ea47 070e 	orr.w	r7, r7, lr
 8010a64:	e76d      	b.n	8010942 <HAL_GPIO_Init+0x106>
 8010a66:	bf00      	nop
 8010a68:	40021000 	.word	0x40021000
 8010a6c:	48000400 	.word	0x48000400
 8010a70:	48000800 	.word	0x48000800
 8010a74:	48000c00 	.word	0x48000c00
 8010a78:	48001000 	.word	0x48001000
 8010a7c:	48001400 	.word	0x48001400
 8010a80:	48001800 	.word	0x48001800
 8010a84:	40010400 	.word	0x40010400

08010a88 <HAL_GPIO_DeInit>:
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));
  assert_param(IS_GPIO_PIN(GPIO_Pin));

  /* Configure the port pins */
  while ((GPIO_Pin >> position) != 0x00u)
 8010a88:	2900      	cmp	r1, #0
 8010a8a:	f000 8093 	beq.w	8010bb4 <HAL_GPIO_DeInit+0x12c>
{
 8010a8e:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
      tmp = SYSCFG->EXTICR[position >> 2u];
      tmp &= (0x0FuL << (4u * (position & 0x03u)));
      if (tmp == (GPIO_GET_INDEX(GPIOx) << (4u * (position & 0x03u))))
      {
        /* Clear EXTI line configuration */
        EXTI->IMR1 &= ~(iocurrent);
 8010a92:	4e49      	ldr	r6, [pc, #292]	; (8010bb8 <HAL_GPIO_DeInit+0x130>)
      if (tmp == (GPIO_GET_INDEX(GPIOx) << (4u * (position & 0x03u))))
 8010a94:	f8df a138 	ldr.w	sl, [pc, #312]	; 8010bd0 <HAL_GPIO_DeInit+0x148>
  uint32_t position = 0x00u;
 8010a98:	2300      	movs	r3, #0
      tmp &= (0x0FuL << (4u * (position & 0x03u)));
 8010a9a:	f04f 090f 	mov.w	r9, #15
    iocurrent = (GPIO_Pin) & (1uL << position);
 8010a9e:	2201      	movs	r2, #1
 8010aa0:	409a      	lsls	r2, r3
    if (iocurrent != 0x00u)
 8010aa2:	ea12 0e01 	ands.w	lr, r2, r1
 8010aa6:	d067      	beq.n	8010b78 <HAL_GPIO_DeInit+0xf0>
      tmp = SYSCFG->EXTICR[position >> 2u];
 8010aa8:	f023 0503 	bic.w	r5, r3, #3
 8010aac:	f105 4580 	add.w	r5, r5, #1073741824	; 0x40000000
 8010ab0:	f505 3580 	add.w	r5, r5, #65536	; 0x10000
      tmp &= (0x0FuL << (4u * (position & 0x03u)));
 8010ab4:	f003 0403 	and.w	r4, r3, #3
      tmp = SYSCFG->EXTICR[position >> 2u];
 8010ab8:	f8d5 c008 	ldr.w	ip, [r5, #8]
      tmp &= (0x0FuL << (4u * (position & 0x03u)));
 8010abc:	00a4      	lsls	r4, r4, #2
 8010abe:	fa09 f804 	lsl.w	r8, r9, r4
      if (tmp == (GPIO_GET_INDEX(GPIOx) << (4u * (position & 0x03u))))
 8010ac2:	f1b0 4f90 	cmp.w	r0, #1207959552	; 0x48000000
      tmp &= (0x0FuL << (4u * (position & 0x03u)));
 8010ac6:	ea08 0c0c 	and.w	ip, r8, ip
      if (tmp == (GPIO_GET_INDEX(GPIOx) << (4u * (position & 0x03u))))
 8010aca:	d017      	beq.n	8010afc <HAL_GPIO_DeInit+0x74>
 8010acc:	4550      	cmp	r0, sl
 8010ace:	d059      	beq.n	8010b84 <HAL_GPIO_DeInit+0xfc>
 8010ad0:	4f3a      	ldr	r7, [pc, #232]	; (8010bbc <HAL_GPIO_DeInit+0x134>)
 8010ad2:	42b8      	cmp	r0, r7
 8010ad4:	d05a      	beq.n	8010b8c <HAL_GPIO_DeInit+0x104>
 8010ad6:	4f3a      	ldr	r7, [pc, #232]	; (8010bc0 <HAL_GPIO_DeInit+0x138>)
 8010ad8:	42b8      	cmp	r0, r7
 8010ada:	d061      	beq.n	8010ba0 <HAL_GPIO_DeInit+0x118>
 8010adc:	4f39      	ldr	r7, [pc, #228]	; (8010bc4 <HAL_GPIO_DeInit+0x13c>)
 8010ade:	42b8      	cmp	r0, r7
 8010ae0:	d063      	beq.n	8010baa <HAL_GPIO_DeInit+0x122>
 8010ae2:	4f39      	ldr	r7, [pc, #228]	; (8010bc8 <HAL_GPIO_DeInit+0x140>)
 8010ae4:	42b8      	cmp	r0, r7
 8010ae6:	d056      	beq.n	8010b96 <HAL_GPIO_DeInit+0x10e>
 8010ae8:	4f38      	ldr	r7, [pc, #224]	; (8010bcc <HAL_GPIO_DeInit+0x144>)
 8010aea:	42b8      	cmp	r0, r7
 8010aec:	bf14      	ite	ne
 8010aee:	f04f 0b07 	movne.w	fp, #7
 8010af2:	f04f 0b06 	moveq.w	fp, #6
 8010af6:	fa0b f404 	lsl.w	r4, fp, r4
 8010afa:	e000      	b.n	8010afe <HAL_GPIO_DeInit+0x76>
 8010afc:	2400      	movs	r4, #0
 8010afe:	45a4      	cmp	ip, r4
 8010b00:	d113      	bne.n	8010b2a <HAL_GPIO_DeInit+0xa2>
        EXTI->IMR1 &= ~(iocurrent);
 8010b02:	6834      	ldr	r4, [r6, #0]
 8010b04:	ea24 040e 	bic.w	r4, r4, lr
 8010b08:	6034      	str	r4, [r6, #0]
        EXTI->EMR1 &= ~(iocurrent);
 8010b0a:	6874      	ldr	r4, [r6, #4]
 8010b0c:	ea24 040e 	bic.w	r4, r4, lr
 8010b10:	6074      	str	r4, [r6, #4]

        /* Clear Rising Falling edge configuration */
        EXTI->RTSR1 &= ~(iocurrent);
 8010b12:	68b4      	ldr	r4, [r6, #8]
 8010b14:	ea24 040e 	bic.w	r4, r4, lr
 8010b18:	60b4      	str	r4, [r6, #8]
        EXTI->FTSR1 &= ~(iocurrent);
 8010b1a:	68f4      	ldr	r4, [r6, #12]
 8010b1c:	ea24 040e 	bic.w	r4, r4, lr
 8010b20:	60f4      	str	r4, [r6, #12]

        tmp = 0x0FuL << (4u * (position & 0x03u));
        SYSCFG->EXTICR[position >> 2u] &= ~tmp;
 8010b22:	68ac      	ldr	r4, [r5, #8]
 8010b24:	ea24 0408 	bic.w	r4, r4, r8
 8010b28:	60ac      	str	r4, [r5, #8]
      }

      /*------------------------- GPIO Mode Configuration --------------------*/
      /* Configure IO in Analog Mode */
      GPIOx->MODER |= (GPIO_MODER_MODE0 << (position * 2u));
 8010b2a:	6804      	ldr	r4, [r0, #0]
 8010b2c:	f04f 0c03 	mov.w	ip, #3
 8010b30:	005d      	lsls	r5, r3, #1
 8010b32:	fa0c f505 	lsl.w	r5, ip, r5

      /* Configure the default Alternate Function in current IO */
      GPIOx->AFR[position >> 3u] &= ~(0xFu << ((position & 0x07u) * 4u)) ;
 8010b36:	fa23 fc0c 	lsr.w	ip, r3, ip
      GPIOx->MODER |= (GPIO_MODER_MODE0 << (position * 2u));
 8010b3a:	432c      	orrs	r4, r5
 8010b3c:	eb00 0c8c 	add.w	ip, r0, ip, lsl #2
 8010b40:	6004      	str	r4, [r0, #0]
      GPIOx->AFR[position >> 3u] &= ~(0xFu << ((position & 0x07u) * 4u)) ;
 8010b42:	f003 0407 	and.w	r4, r3, #7
 8010b46:	f8dc e020 	ldr.w	lr, [ip, #32]
 8010b4a:	00a4      	lsls	r4, r4, #2
 8010b4c:	fa09 f404 	lsl.w	r4, r9, r4
 8010b50:	ea2e 0404 	bic.w	r4, lr, r4
 8010b54:	f8cc 4020 	str.w	r4, [ip, #32]

      /* Configure the default value for IO Speed */
      GPIOx->OSPEEDR &= ~(GPIO_OSPEEDR_OSPEED0 << (position * 2u));
 8010b58:	6884      	ldr	r4, [r0, #8]
 8010b5a:	ea24 0405 	bic.w	r4, r4, r5
 8010b5e:	6084      	str	r4, [r0, #8]

      /* Configure the default value IO Output Type */
      GPIOx->OTYPER  &= ~(GPIO_OTYPER_OT0 << position) ;
 8010b60:	6844      	ldr	r4, [r0, #4]
 8010b62:	ea24 0402 	bic.w	r4, r4, r2
 8010b66:	6044      	str	r4, [r0, #4]

      /* Deactivate the Pull-up and Pull-down resistor for the current IO */
      GPIOx->PUPDR &= ~(GPIO_PUPDR_PUPD0 << (position * 2u));
 8010b68:	68c4      	ldr	r4, [r0, #12]
 8010b6a:	ea24 0505 	bic.w	r5, r4, r5
 8010b6e:	60c5      	str	r5, [r0, #12]

#if defined(STM32L471xx) || defined(STM32L475xx) || defined(STM32L476xx) || defined(STM32L485xx) || defined(STM32L486xx)
      /* Deactivate the Control bit of Analog mode for the current IO */
      GPIOx->ASCR &= ~(GPIO_ASCR_ASC0<< position);
 8010b70:	6ac4      	ldr	r4, [r0, #44]	; 0x2c
 8010b72:	ea24 0202 	bic.w	r2, r4, r2
 8010b76:	62c2      	str	r2, [r0, #44]	; 0x2c
#endif /* STM32L471xx || STM32L475xx || STM32L476xx || STM32L485xx || STM32L486xx */
    }

    position++;
 8010b78:	3301      	adds	r3, #1
  while ((GPIO_Pin >> position) != 0x00u)
 8010b7a:	fa31 f203 	lsrs.w	r2, r1, r3
 8010b7e:	d18e      	bne.n	8010a9e <HAL_GPIO_DeInit+0x16>
  }
}
 8010b80:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
      if (tmp == (GPIO_GET_INDEX(GPIOx) << (4u * (position & 0x03u))))
 8010b84:	2701      	movs	r7, #1
 8010b86:	fa07 f404 	lsl.w	r4, r7, r4
 8010b8a:	e7b8      	b.n	8010afe <HAL_GPIO_DeInit+0x76>
 8010b8c:	f04f 0b02 	mov.w	fp, #2
 8010b90:	fa0b f404 	lsl.w	r4, fp, r4
 8010b94:	e7b3      	b.n	8010afe <HAL_GPIO_DeInit+0x76>
 8010b96:	f04f 0b05 	mov.w	fp, #5
 8010b9a:	fa0b f404 	lsl.w	r4, fp, r4
 8010b9e:	e7ae      	b.n	8010afe <HAL_GPIO_DeInit+0x76>
 8010ba0:	f04f 0b03 	mov.w	fp, #3
 8010ba4:	fa0b f404 	lsl.w	r4, fp, r4
 8010ba8:	e7a9      	b.n	8010afe <HAL_GPIO_DeInit+0x76>
 8010baa:	f04f 0b04 	mov.w	fp, #4
 8010bae:	fa0b f404 	lsl.w	r4, fp, r4
 8010bb2:	e7a4      	b.n	8010afe <HAL_GPIO_DeInit+0x76>
 8010bb4:	4770      	bx	lr
 8010bb6:	bf00      	nop
 8010bb8:	40010400 	.word	0x40010400
 8010bbc:	48000800 	.word	0x48000800
 8010bc0:	48000c00 	.word	0x48000c00
 8010bc4:	48001000 	.word	0x48001000
 8010bc8:	48001400 	.word	0x48001400
 8010bcc:	48001800 	.word	0x48001800
 8010bd0:	48000400 	.word	0x48000400

08010bd4 <HAL_GPIO_ReadPin>:
  GPIO_PinState bitstatus;

  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));

  if ((GPIOx->IDR & GPIO_Pin) != 0x00u)
 8010bd4:	6903      	ldr	r3, [r0, #16]
 8010bd6:	4219      	tst	r1, r3
  else
  {
    bitstatus = GPIO_PIN_RESET;
  }
  return bitstatus;
}
 8010bd8:	bf14      	ite	ne
 8010bda:	2001      	movne	r0, #1
 8010bdc:	2000      	moveq	r0, #0
 8010bde:	4770      	bx	lr

08010be0 <HAL_GPIO_WritePin>:
{
  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));
  assert_param(IS_GPIO_PIN_ACTION(PinState));

  if(PinState != GPIO_PIN_RESET)
 8010be0:	b10a      	cbz	r2, 8010be6 <HAL_GPIO_WritePin+0x6>
  {
    GPIOx->BSRR = (uint32_t)GPIO_Pin;
 8010be2:	6181      	str	r1, [r0, #24]
 8010be4:	4770      	bx	lr
  }
  else
  {
    GPIOx->BRR = (uint32_t)GPIO_Pin;
 8010be6:	6281      	str	r1, [r0, #40]	; 0x28
  }
}
 8010be8:	4770      	bx	lr
 8010bea:	bf00      	nop

08010bec <HAL_GPIO_EXTI_IRQHandler>:
  * @retval None
  */
void HAL_GPIO_EXTI_IRQHandler(uint16_t GPIO_Pin)
{
  /* EXTI line interrupt detected */
  if(__HAL_GPIO_EXTI_GET_IT(GPIO_Pin) != 0x00u)
 8010bec:	4a04      	ldr	r2, [pc, #16]	; (8010c00 <HAL_GPIO_EXTI_IRQHandler+0x14>)
 8010bee:	6951      	ldr	r1, [r2, #20]
 8010bf0:	4201      	tst	r1, r0
 8010bf2:	d100      	bne.n	8010bf6 <HAL_GPIO_EXTI_IRQHandler+0xa>
 8010bf4:	4770      	bx	lr
{
 8010bf6:	b508      	push	{r3, lr}
  {
    __HAL_GPIO_EXTI_CLEAR_IT(GPIO_Pin);
 8010bf8:	6150      	str	r0, [r2, #20]
    HAL_GPIO_EXTI_Callback(GPIO_Pin);
 8010bfa:	f011 ff37 	bl	8022a6c <HAL_GPIO_EXTI_Callback>
  }
}
 8010bfe:	bd08      	pop	{r3, pc}
 8010c00:	40010400 	.word	0x40010400

08010c04 <I2C_IsAcknowledgeFailed.part.0>:
  *                the configuration information for the specified I2C.
  * @param  Timeout Timeout duration
  * @param  Tickstart Tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef I2C_IsAcknowledgeFailed(I2C_HandleTypeDef *hi2c, uint32_t Timeout, uint32_t Tickstart)
 8010c04:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8010c06:	4606      	mov	r6, r0
 8010c08:	460d      	mov	r5, r1
 8010c0a:	4617      	mov	r7, r2
{
  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF) == SET)
  {
    /* Wait until STOP Flag is reset */
    /* AutoEnd should be initiate after AF */
    while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET)
 8010c0c:	6834      	ldr	r4, [r6, #0]
 8010c0e:	e001      	b.n	8010c14 <I2C_IsAcknowledgeFailed.part.0+0x10>
    {
      /* Check for the Timeout */
      if (Timeout != HAL_MAX_DELAY)
 8010c10:	1c68      	adds	r0, r5, #1
 8010c12:	d120      	bne.n	8010c56 <I2C_IsAcknowledgeFailed.part.0+0x52>
    while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET)
 8010c14:	69a3      	ldr	r3, [r4, #24]
 8010c16:	0699      	lsls	r1, r3, #26
 8010c18:	d5fa      	bpl.n	8010c10 <I2C_IsAcknowledgeFailed.part.0+0xc>
        }
      }
    }

    /* Clear NACKF Flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
 8010c1a:	2210      	movs	r2, #16

    /* Clear STOP Flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
 8010c1c:	2320      	movs	r3, #32
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
 8010c1e:	61e2      	str	r2, [r4, #28]
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
 8010c20:	61e3      	str	r3, [r4, #28]
  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXIS) != RESET)
 8010c22:	69a3      	ldr	r3, [r4, #24]
 8010c24:	079a      	lsls	r2, r3, #30
    hi2c->Instance->TXDR = 0x00U;
 8010c26:	bf44      	itt	mi
 8010c28:	2300      	movmi	r3, #0
 8010c2a:	62a3      	strmi	r3, [r4, #40]	; 0x28
  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXE) == RESET)
 8010c2c:	69a3      	ldr	r3, [r4, #24]
 8010c2e:	07db      	lsls	r3, r3, #31
 8010c30:	d525      	bpl.n	8010c7e <I2C_IsAcknowledgeFailed.part.0+0x7a>

    /* Flush TX register */
    I2C_Flush_TXDR(hi2c);

    /* Clear Configuration Register 2 */
    I2C_RESET_CR2(hi2c);
 8010c32:	6863      	ldr	r3, [r4, #4]
 8010c34:	4914      	ldr	r1, [pc, #80]	; (8010c88 <I2C_IsAcknowledgeFailed.part.0+0x84>)
 8010c36:	400b      	ands	r3, r1
 8010c38:	6063      	str	r3, [r4, #4]

    hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
 8010c3a:	6c73      	ldr	r3, [r6, #68]	; 0x44
    hi2c->State = HAL_I2C_STATE_READY;
    hi2c->Mode = HAL_I2C_MODE_NONE;
 8010c3c:	2200      	movs	r2, #0
    hi2c->State = HAL_I2C_STATE_READY;
 8010c3e:	2120      	movs	r1, #32
    hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
 8010c40:	f043 0304 	orr.w	r3, r3, #4
 8010c44:	6473      	str	r3, [r6, #68]	; 0x44

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
 8010c46:	f886 2040 	strb.w	r2, [r6, #64]	; 0x40
    hi2c->State = HAL_I2C_STATE_READY;
 8010c4a:	f886 1041 	strb.w	r1, [r6, #65]	; 0x41
    hi2c->Mode = HAL_I2C_MODE_NONE;
 8010c4e:	f886 2042 	strb.w	r2, [r6, #66]	; 0x42

    return HAL_ERROR;
  }
  return HAL_OK;
}
 8010c52:	2001      	movs	r0, #1
 8010c54:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
 8010c56:	f7fe fdef 	bl	800f838 <HAL_GetTick>
 8010c5a:	1bc0      	subs	r0, r0, r7
 8010c5c:	4285      	cmp	r5, r0
 8010c5e:	d301      	bcc.n	8010c64 <I2C_IsAcknowledgeFailed.part.0+0x60>
 8010c60:	2d00      	cmp	r5, #0
 8010c62:	d1d3      	bne.n	8010c0c <I2C_IsAcknowledgeFailed.part.0+0x8>
          hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
 8010c64:	6c73      	ldr	r3, [r6, #68]	; 0x44
          hi2c->Mode = HAL_I2C_MODE_NONE;
 8010c66:	2200      	movs	r2, #0
          hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
 8010c68:	f043 0320 	orr.w	r3, r3, #32
          hi2c->State = HAL_I2C_STATE_READY;
 8010c6c:	2120      	movs	r1, #32
          hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
 8010c6e:	6473      	str	r3, [r6, #68]	; 0x44
          __HAL_UNLOCK(hi2c);
 8010c70:	f886 2040 	strb.w	r2, [r6, #64]	; 0x40
          hi2c->State = HAL_I2C_STATE_READY;
 8010c74:	f886 1041 	strb.w	r1, [r6, #65]	; 0x41
          hi2c->Mode = HAL_I2C_MODE_NONE;
 8010c78:	f886 2042 	strb.w	r2, [r6, #66]	; 0x42
          return HAL_ERROR;
 8010c7c:	e7e9      	b.n	8010c52 <I2C_IsAcknowledgeFailed.part.0+0x4e>
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_TXE);
 8010c7e:	69a3      	ldr	r3, [r4, #24]
 8010c80:	f043 0301 	orr.w	r3, r3, #1
 8010c84:	61a3      	str	r3, [r4, #24]
 8010c86:	e7d4      	b.n	8010c32 <I2C_IsAcknowledgeFailed.part.0+0x2e>
 8010c88:	fe00e800 	.word	0xfe00e800

08010c8c <I2C_WaitOnTXISFlagUntilTimeout>:
{
 8010c8c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8010c8e:	4604      	mov	r4, r0
 8010c90:	460d      	mov	r5, r1
 8010c92:	4617      	mov	r7, r2
  while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXIS) == RESET)
 8010c94:	e001      	b.n	8010c9a <I2C_WaitOnTXISFlagUntilTimeout+0xe>
    if (Timeout != HAL_MAX_DELAY)
 8010c96:	1c6b      	adds	r3, r5, #1
 8010c98:	d111      	bne.n	8010cbe <I2C_WaitOnTXISFlagUntilTimeout+0x32>
  while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXIS) == RESET)
 8010c9a:	6823      	ldr	r3, [r4, #0]
 8010c9c:	699e      	ldr	r6, [r3, #24]
 8010c9e:	07b6      	lsls	r6, r6, #30
 8010ca0:	463a      	mov	r2, r7
 8010ca2:	4629      	mov	r1, r5
 8010ca4:	4620      	mov	r0, r4
 8010ca6:	d408      	bmi.n	8010cba <I2C_WaitOnTXISFlagUntilTimeout+0x2e>
  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF) == SET)
 8010ca8:	699b      	ldr	r3, [r3, #24]
 8010caa:	06de      	lsls	r6, r3, #27
 8010cac:	d5f3      	bpl.n	8010c96 <I2C_WaitOnTXISFlagUntilTimeout+0xa>
 8010cae:	f7ff ffa9 	bl	8010c04 <I2C_IsAcknowledgeFailed.part.0>
    if (I2C_IsAcknowledgeFailed(hi2c, Timeout, Tickstart) != HAL_OK)
 8010cb2:	2800      	cmp	r0, #0
 8010cb4:	d0ef      	beq.n	8010c96 <I2C_WaitOnTXISFlagUntilTimeout+0xa>
      return HAL_ERROR;
 8010cb6:	2001      	movs	r0, #1
}
 8010cb8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  return HAL_OK;
 8010cba:	2000      	movs	r0, #0
}
 8010cbc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
 8010cbe:	f7fe fdbb 	bl	800f838 <HAL_GetTick>
 8010cc2:	1bc0      	subs	r0, r0, r7
 8010cc4:	42a8      	cmp	r0, r5
 8010cc6:	d801      	bhi.n	8010ccc <I2C_WaitOnTXISFlagUntilTimeout+0x40>
 8010cc8:	2d00      	cmp	r5, #0
 8010cca:	d1e6      	bne.n	8010c9a <I2C_WaitOnTXISFlagUntilTimeout+0xe>
        hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
 8010ccc:	6c63      	ldr	r3, [r4, #68]	; 0x44
        hi2c->Mode = HAL_I2C_MODE_NONE;
 8010cce:	2200      	movs	r2, #0
        hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
 8010cd0:	f043 0320 	orr.w	r3, r3, #32
        hi2c->State = HAL_I2C_STATE_READY;
 8010cd4:	2120      	movs	r1, #32
        hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
 8010cd6:	6463      	str	r3, [r4, #68]	; 0x44
        __HAL_UNLOCK(hi2c);
 8010cd8:	f884 2040 	strb.w	r2, [r4, #64]	; 0x40
        hi2c->State = HAL_I2C_STATE_READY;
 8010cdc:	f884 1041 	strb.w	r1, [r4, #65]	; 0x41
        hi2c->Mode = HAL_I2C_MODE_NONE;
 8010ce0:	f884 2042 	strb.w	r2, [r4, #66]	; 0x42
        return HAL_ERROR;
 8010ce4:	2001      	movs	r0, #1
}
 8010ce6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

08010ce8 <I2C_WaitOnSTOPFlagUntilTimeout>:
{
 8010ce8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8010cea:	4605      	mov	r5, r0
 8010cec:	460c      	mov	r4, r1
 8010cee:	4616      	mov	r6, r2
  while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET)
 8010cf0:	e005      	b.n	8010cfe <I2C_WaitOnSTOPFlagUntilTimeout+0x16>
    if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
 8010cf2:	f7fe fda1 	bl	800f838 <HAL_GetTick>
 8010cf6:	1b80      	subs	r0, r0, r6
 8010cf8:	42a0      	cmp	r0, r4
 8010cfa:	d810      	bhi.n	8010d1e <I2C_WaitOnSTOPFlagUntilTimeout+0x36>
 8010cfc:	b17c      	cbz	r4, 8010d1e <I2C_WaitOnSTOPFlagUntilTimeout+0x36>
  while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET)
 8010cfe:	682b      	ldr	r3, [r5, #0]
 8010d00:	699f      	ldr	r7, [r3, #24]
 8010d02:	06bf      	lsls	r7, r7, #26
 8010d04:	4632      	mov	r2, r6
 8010d06:	4621      	mov	r1, r4
 8010d08:	4628      	mov	r0, r5
 8010d0a:	d416      	bmi.n	8010d3a <I2C_WaitOnSTOPFlagUntilTimeout+0x52>
  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF) == SET)
 8010d0c:	699b      	ldr	r3, [r3, #24]
 8010d0e:	06db      	lsls	r3, r3, #27
 8010d10:	d5ef      	bpl.n	8010cf2 <I2C_WaitOnSTOPFlagUntilTimeout+0xa>
 8010d12:	f7ff ff77 	bl	8010c04 <I2C_IsAcknowledgeFailed.part.0>
    if (I2C_IsAcknowledgeFailed(hi2c, Timeout, Tickstart) != HAL_OK)
 8010d16:	2800      	cmp	r0, #0
 8010d18:	d0eb      	beq.n	8010cf2 <I2C_WaitOnSTOPFlagUntilTimeout+0xa>
      return HAL_ERROR;
 8010d1a:	2001      	movs	r0, #1
}
 8010d1c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
 8010d1e:	6c6b      	ldr	r3, [r5, #68]	; 0x44
        hi2c->Mode = HAL_I2C_MODE_NONE;
 8010d20:	2200      	movs	r2, #0
        hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
 8010d22:	f043 0320 	orr.w	r3, r3, #32
        hi2c->State = HAL_I2C_STATE_READY;
 8010d26:	2120      	movs	r1, #32
        hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
 8010d28:	646b      	str	r3, [r5, #68]	; 0x44
        __HAL_UNLOCK(hi2c);
 8010d2a:	f885 2040 	strb.w	r2, [r5, #64]	; 0x40
        hi2c->State = HAL_I2C_STATE_READY;
 8010d2e:	f885 1041 	strb.w	r1, [r5, #65]	; 0x41
        hi2c->Mode = HAL_I2C_MODE_NONE;
 8010d32:	f885 2042 	strb.w	r2, [r5, #66]	; 0x42
        __HAL_UNLOCK(hi2c);
 8010d36:	2001      	movs	r0, #1
}
 8010d38:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  return HAL_OK;
 8010d3a:	2000      	movs	r0, #0
}
 8010d3c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8010d3e:	bf00      	nop

08010d40 <I2C_RequestMemoryWrite>:
{
 8010d40:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8010d44:	4616      	mov	r6, r2
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
  assert_param(IS_TRANSFER_MODE(Mode));
  assert_param(IS_TRANSFER_REQUEST(Request));

  /* update CR2 register */
  MODIFY_REG(hi2c->Instance->CR2, ((I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | (I2C_CR2_RD_WRN & (uint32_t)(Request >> (31U - I2C_CR2_RD_WRN_Pos))) | I2C_CR2_START | I2C_CR2_STOP)), \
 8010d46:	6802      	ldr	r2, [r0, #0]
 8010d48:	4c27      	ldr	r4, [pc, #156]	; (8010de8 <I2C_RequestMemoryWrite+0xa8>)
{
 8010d4a:	461f      	mov	r7, r3
  MODIFY_REG(hi2c->Instance->CR2, ((I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | (I2C_CR2_RD_WRN & (uint32_t)(Request >> (31U - I2C_CR2_RD_WRN_Pos))) | I2C_CR2_START | I2C_CR2_STOP)), \
 8010d4c:	6853      	ldr	r3, [r2, #4]
 8010d4e:	f3c1 0109 	ubfx	r1, r1, #0, #10
 8010d52:	4023      	ands	r3, r4
 8010d54:	b2fc      	uxtb	r4, r7
 8010d56:	ea41 4104 	orr.w	r1, r1, r4, lsl #16
 8010d5a:	4319      	orrs	r1, r3
{
 8010d5c:	e9dd 4908 	ldrd	r4, r9, [sp, #32]
  MODIFY_REG(hi2c->Instance->CR2, ((I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | (I2C_CR2_RD_WRN & (uint32_t)(Request >> (31U - I2C_CR2_RD_WRN_Pos))) | I2C_CR2_START | I2C_CR2_STOP)), \
 8010d60:	f041 4101 	orr.w	r1, r1, #2164260864	; 0x81000000
 8010d64:	f441 5100 	orr.w	r1, r1, #8192	; 0x2000
 8010d68:	6051      	str	r1, [r2, #4]
  if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, Tickstart) != HAL_OK)
 8010d6a:	464a      	mov	r2, r9
 8010d6c:	4621      	mov	r1, r4
{
 8010d6e:	4605      	mov	r5, r0
  if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, Tickstart) != HAL_OK)
 8010d70:	f7ff ff8c 	bl	8010c8c <I2C_WaitOnTXISFlagUntilTimeout>
 8010d74:	b9c0      	cbnz	r0, 8010da8 <I2C_RequestMemoryWrite+0x68>
  if (MemAddSize == I2C_MEMADD_SIZE_8BIT)
 8010d76:	2f01      	cmp	r7, #1
 8010d78:	4680      	mov	r8, r0
 8010d7a:	d10b      	bne.n	8010d94 <I2C_RequestMemoryWrite+0x54>
    hi2c->Instance->TXDR = I2C_MEM_ADD_LSB(MemAddress);
 8010d7c:	682a      	ldr	r2, [r5, #0]
 8010d7e:	b2f6      	uxtb	r6, r6
 8010d80:	6296      	str	r6, [r2, #40]	; 0x28
 8010d82:	e001      	b.n	8010d88 <I2C_RequestMemoryWrite+0x48>
    if (Timeout != HAL_MAX_DELAY)
 8010d84:	1c61      	adds	r1, r4, #1
 8010d86:	d114      	bne.n	8010db2 <I2C_RequestMemoryWrite+0x72>
  while (__HAL_I2C_GET_FLAG(hi2c, Flag) == Status)
 8010d88:	6993      	ldr	r3, [r2, #24]
 8010d8a:	061b      	lsls	r3, r3, #24
 8010d8c:	d5fa      	bpl.n	8010d84 <I2C_RequestMemoryWrite+0x44>
}
 8010d8e:	4640      	mov	r0, r8
 8010d90:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    hi2c->Instance->TXDR = I2C_MEM_ADD_MSB(MemAddress);
 8010d94:	682b      	ldr	r3, [r5, #0]
 8010d96:	0a32      	lsrs	r2, r6, #8
 8010d98:	629a      	str	r2, [r3, #40]	; 0x28
    if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, Tickstart) != HAL_OK)
 8010d9a:	4621      	mov	r1, r4
 8010d9c:	464a      	mov	r2, r9
 8010d9e:	4628      	mov	r0, r5
 8010da0:	f7ff ff74 	bl	8010c8c <I2C_WaitOnTXISFlagUntilTimeout>
 8010da4:	2800      	cmp	r0, #0
 8010da6:	d0e9      	beq.n	8010d7c <I2C_RequestMemoryWrite+0x3c>
    return HAL_ERROR;
 8010da8:	f04f 0801 	mov.w	r8, #1
}
 8010dac:	4640      	mov	r0, r8
 8010dae:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
 8010db2:	f7fe fd41 	bl	800f838 <HAL_GetTick>
 8010db6:	eba0 0009 	sub.w	r0, r0, r9
 8010dba:	4284      	cmp	r4, r0
 8010dbc:	d302      	bcc.n	8010dc4 <I2C_RequestMemoryWrite+0x84>
 8010dbe:	b10c      	cbz	r4, 8010dc4 <I2C_RequestMemoryWrite+0x84>
  while (__HAL_I2C_GET_FLAG(hi2c, Flag) == Status)
 8010dc0:	682a      	ldr	r2, [r5, #0]
 8010dc2:	e7e1      	b.n	8010d88 <I2C_RequestMemoryWrite+0x48>
        hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
 8010dc4:	6c6b      	ldr	r3, [r5, #68]	; 0x44
        hi2c->Mode = HAL_I2C_MODE_NONE;
 8010dc6:	2200      	movs	r2, #0
        hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
 8010dc8:	f043 0320 	orr.w	r3, r3, #32
        hi2c->State = HAL_I2C_STATE_READY;
 8010dcc:	2120      	movs	r1, #32
        hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
 8010dce:	646b      	str	r3, [r5, #68]	; 0x44
    return HAL_ERROR;
 8010dd0:	f04f 0801 	mov.w	r8, #1
        hi2c->State = HAL_I2C_STATE_READY;
 8010dd4:	f885 1041 	strb.w	r1, [r5, #65]	; 0x41
        __HAL_UNLOCK(hi2c);
 8010dd8:	f885 2040 	strb.w	r2, [r5, #64]	; 0x40
        hi2c->Mode = HAL_I2C_MODE_NONE;
 8010ddc:	f885 2042 	strb.w	r2, [r5, #66]	; 0x42
}
 8010de0:	4640      	mov	r0, r8
 8010de2:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 8010de6:	bf00      	nop
 8010de8:	fc009800 	.word	0xfc009800

08010dec <I2C_RequestMemoryRead>:
{
 8010dec:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8010df0:	4616      	mov	r6, r2
  MODIFY_REG(hi2c->Instance->CR2, ((I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | (I2C_CR2_RD_WRN & (uint32_t)(Request >> (31U - I2C_CR2_RD_WRN_Pos))) | I2C_CR2_START | I2C_CR2_STOP)), \
 8010df2:	6802      	ldr	r2, [r0, #0]
 8010df4:	4c27      	ldr	r4, [pc, #156]	; (8010e94 <I2C_RequestMemoryRead+0xa8>)
{
 8010df6:	461f      	mov	r7, r3
  MODIFY_REG(hi2c->Instance->CR2, ((I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | (I2C_CR2_RD_WRN & (uint32_t)(Request >> (31U - I2C_CR2_RD_WRN_Pos))) | I2C_CR2_START | I2C_CR2_STOP)), \
 8010df8:	6853      	ldr	r3, [r2, #4]
 8010dfa:	f3c1 0109 	ubfx	r1, r1, #0, #10
 8010dfe:	4023      	ands	r3, r4
 8010e00:	b2fc      	uxtb	r4, r7
 8010e02:	ea41 4104 	orr.w	r1, r1, r4, lsl #16
 8010e06:	4319      	orrs	r1, r3
{
 8010e08:	e9dd 4908 	ldrd	r4, r9, [sp, #32]
  MODIFY_REG(hi2c->Instance->CR2, ((I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | (I2C_CR2_RD_WRN & (uint32_t)(Request >> (31U - I2C_CR2_RD_WRN_Pos))) | I2C_CR2_START | I2C_CR2_STOP)), \
 8010e0c:	f041 4100 	orr.w	r1, r1, #2147483648	; 0x80000000
 8010e10:	f441 5100 	orr.w	r1, r1, #8192	; 0x2000
 8010e14:	6051      	str	r1, [r2, #4]
  if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, Tickstart) != HAL_OK)
 8010e16:	464a      	mov	r2, r9
 8010e18:	4621      	mov	r1, r4
{
 8010e1a:	4605      	mov	r5, r0
  if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, Tickstart) != HAL_OK)
 8010e1c:	f7ff ff36 	bl	8010c8c <I2C_WaitOnTXISFlagUntilTimeout>
 8010e20:	b9c0      	cbnz	r0, 8010e54 <I2C_RequestMemoryRead+0x68>
  if (MemAddSize == I2C_MEMADD_SIZE_8BIT)
 8010e22:	2f01      	cmp	r7, #1
 8010e24:	4680      	mov	r8, r0
 8010e26:	d10b      	bne.n	8010e40 <I2C_RequestMemoryRead+0x54>
    hi2c->Instance->TXDR = I2C_MEM_ADD_LSB(MemAddress);
 8010e28:	682a      	ldr	r2, [r5, #0]
 8010e2a:	b2f6      	uxtb	r6, r6
 8010e2c:	6296      	str	r6, [r2, #40]	; 0x28
 8010e2e:	e001      	b.n	8010e34 <I2C_RequestMemoryRead+0x48>
    if (Timeout != HAL_MAX_DELAY)
 8010e30:	1c61      	adds	r1, r4, #1
 8010e32:	d114      	bne.n	8010e5e <I2C_RequestMemoryRead+0x72>
  while (__HAL_I2C_GET_FLAG(hi2c, Flag) == Status)
 8010e34:	6993      	ldr	r3, [r2, #24]
 8010e36:	065b      	lsls	r3, r3, #25
 8010e38:	d5fa      	bpl.n	8010e30 <I2C_RequestMemoryRead+0x44>
}
 8010e3a:	4640      	mov	r0, r8
 8010e3c:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    hi2c->Instance->TXDR = I2C_MEM_ADD_MSB(MemAddress);
 8010e40:	682b      	ldr	r3, [r5, #0]
 8010e42:	0a32      	lsrs	r2, r6, #8
 8010e44:	629a      	str	r2, [r3, #40]	; 0x28
    if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, Tickstart) != HAL_OK)
 8010e46:	4621      	mov	r1, r4
 8010e48:	464a      	mov	r2, r9
 8010e4a:	4628      	mov	r0, r5
 8010e4c:	f7ff ff1e 	bl	8010c8c <I2C_WaitOnTXISFlagUntilTimeout>
 8010e50:	2800      	cmp	r0, #0
 8010e52:	d0e9      	beq.n	8010e28 <I2C_RequestMemoryRead+0x3c>
    return HAL_ERROR;
 8010e54:	f04f 0801 	mov.w	r8, #1
}
 8010e58:	4640      	mov	r0, r8
 8010e5a:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
 8010e5e:	f7fe fceb 	bl	800f838 <HAL_GetTick>
 8010e62:	eba0 0009 	sub.w	r0, r0, r9
 8010e66:	4284      	cmp	r4, r0
 8010e68:	d302      	bcc.n	8010e70 <I2C_RequestMemoryRead+0x84>
 8010e6a:	b10c      	cbz	r4, 8010e70 <I2C_RequestMemoryRead+0x84>
  while (__HAL_I2C_GET_FLAG(hi2c, Flag) == Status)
 8010e6c:	682a      	ldr	r2, [r5, #0]
 8010e6e:	e7e1      	b.n	8010e34 <I2C_RequestMemoryRead+0x48>
        hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
 8010e70:	6c6b      	ldr	r3, [r5, #68]	; 0x44
        hi2c->Mode = HAL_I2C_MODE_NONE;
 8010e72:	2200      	movs	r2, #0
        hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
 8010e74:	f043 0320 	orr.w	r3, r3, #32
        hi2c->State = HAL_I2C_STATE_READY;
 8010e78:	2120      	movs	r1, #32
        hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
 8010e7a:	646b      	str	r3, [r5, #68]	; 0x44
    return HAL_ERROR;
 8010e7c:	f04f 0801 	mov.w	r8, #1
        hi2c->State = HAL_I2C_STATE_READY;
 8010e80:	f885 1041 	strb.w	r1, [r5, #65]	; 0x41
        __HAL_UNLOCK(hi2c);
 8010e84:	f885 2040 	strb.w	r2, [r5, #64]	; 0x40
        hi2c->Mode = HAL_I2C_MODE_NONE;
 8010e88:	f885 2042 	strb.w	r2, [r5, #66]	; 0x42
}
 8010e8c:	4640      	mov	r0, r8
 8010e8e:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 8010e92:	bf00      	nop
 8010e94:	fc009800 	.word	0xfc009800

08010e98 <HAL_I2C_MspInit>:
}
 8010e98:	4770      	bx	lr
 8010e9a:	bf00      	nop

08010e9c <HAL_I2C_Init>:
  if (hi2c == NULL)
 8010e9c:	2800      	cmp	r0, #0
 8010e9e:	d04f      	beq.n	8010f40 <HAL_I2C_Init+0xa4>
{
 8010ea0:	b510      	push	{r4, lr}
  if (hi2c->State == HAL_I2C_STATE_RESET)
 8010ea2:	f890 3041 	ldrb.w	r3, [r0, #65]	; 0x41
 8010ea6:	4604      	mov	r4, r0
 8010ea8:	f003 02ff 	and.w	r2, r3, #255	; 0xff
 8010eac:	2b00      	cmp	r3, #0
 8010eae:	d042      	beq.n	8010f36 <HAL_I2C_Init+0x9a>
  __HAL_I2C_DISABLE(hi2c);
 8010eb0:	6823      	ldr	r3, [r4, #0]
  hi2c->State = HAL_I2C_STATE_BUSY;
 8010eb2:	2224      	movs	r2, #36	; 0x24
 8010eb4:	f884 2041 	strb.w	r2, [r4, #65]	; 0x41
  __HAL_I2C_DISABLE(hi2c);
 8010eb8:	6819      	ldr	r1, [r3, #0]
  hi2c->Instance->TIMINGR = hi2c->Init.Timing & TIMING_CLEAR_MASK;
 8010eba:	6862      	ldr	r2, [r4, #4]
  __HAL_I2C_DISABLE(hi2c);
 8010ebc:	f021 0101 	bic.w	r1, r1, #1
  hi2c->Instance->TIMINGR = hi2c->Init.Timing & TIMING_CLEAR_MASK;
 8010ec0:	f022 6270 	bic.w	r2, r2, #251658240	; 0xf000000
  __HAL_I2C_DISABLE(hi2c);
 8010ec4:	6019      	str	r1, [r3, #0]
  hi2c->Instance->TIMINGR = hi2c->Init.Timing & TIMING_CLEAR_MASK;
 8010ec6:	611a      	str	r2, [r3, #16]
  hi2c->Instance->OAR1 &= ~I2C_OAR1_OA1EN;
 8010ec8:	689a      	ldr	r2, [r3, #8]
  if (hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_7BIT)
 8010eca:	68e1      	ldr	r1, [r4, #12]
  hi2c->Instance->OAR1 &= ~I2C_OAR1_OA1EN;
 8010ecc:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
  if (hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_7BIT)
 8010ed0:	2901      	cmp	r1, #1
  hi2c->Instance->OAR1 &= ~I2C_OAR1_OA1EN;
 8010ed2:	609a      	str	r2, [r3, #8]
    hi2c->Instance->OAR1 = (I2C_OAR1_OA1EN | hi2c->Init.OwnAddress1);
 8010ed4:	68a2      	ldr	r2, [r4, #8]
  if (hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_7BIT)
 8010ed6:	d02a      	beq.n	8010f2e <HAL_I2C_Init+0x92>
    hi2c->Instance->OAR1 = (I2C_OAR1_OA1EN | I2C_OAR1_OA1MODE | hi2c->Init.OwnAddress1);
 8010ed8:	f442 4204 	orr.w	r2, r2, #33792	; 0x8400
  if (hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_10BIT)
 8010edc:	2902      	cmp	r1, #2
    hi2c->Instance->OAR1 = (I2C_OAR1_OA1EN | I2C_OAR1_OA1MODE | hi2c->Init.OwnAddress1);
 8010ede:	609a      	str	r2, [r3, #8]
    hi2c->Instance->CR2 = (I2C_CR2_ADD10);
 8010ee0:	bf04      	itt	eq
 8010ee2:	f44f 6200 	moveq.w	r2, #2048	; 0x800
 8010ee6:	605a      	streq	r2, [r3, #4]
  hi2c->Instance->CR2 |= (I2C_CR2_AUTOEND | I2C_CR2_NACK);
 8010ee8:	6859      	ldr	r1, [r3, #4]
  hi2c->Instance->OAR2 = (hi2c->Init.DualAddressMode | hi2c->Init.OwnAddress2 | (hi2c->Init.OwnAddress2Masks << 8));
 8010eea:	6922      	ldr	r2, [r4, #16]
  hi2c->Instance->CR2 |= (I2C_CR2_AUTOEND | I2C_CR2_NACK);
 8010eec:	f041 7100 	orr.w	r1, r1, #33554432	; 0x2000000
 8010ef0:	f441 4100 	orr.w	r1, r1, #32768	; 0x8000
 8010ef4:	6059      	str	r1, [r3, #4]
  hi2c->Instance->OAR2 = (hi2c->Init.DualAddressMode | hi2c->Init.OwnAddress2 | (hi2c->Init.OwnAddress2Masks << 8));
 8010ef6:	6961      	ldr	r1, [r4, #20]
  hi2c->Instance->OAR2 &= ~I2C_DUALADDRESS_ENABLE;
 8010ef8:	68d8      	ldr	r0, [r3, #12]
  hi2c->Instance->OAR2 = (hi2c->Init.DualAddressMode | hi2c->Init.OwnAddress2 | (hi2c->Init.OwnAddress2Masks << 8));
 8010efa:	430a      	orrs	r2, r1
 8010efc:	69a1      	ldr	r1, [r4, #24]
  hi2c->Instance->OAR2 &= ~I2C_DUALADDRESS_ENABLE;
 8010efe:	f420 4000 	bic.w	r0, r0, #32768	; 0x8000
  hi2c->Instance->OAR2 = (hi2c->Init.DualAddressMode | hi2c->Init.OwnAddress2 | (hi2c->Init.OwnAddress2Masks << 8));
 8010f02:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
  hi2c->Instance->CR1 = (hi2c->Init.GeneralCallMode | hi2c->Init.NoStretchMode);
 8010f06:	69e1      	ldr	r1, [r4, #28]
  hi2c->Instance->OAR2 &= ~I2C_DUALADDRESS_ENABLE;
 8010f08:	60d8      	str	r0, [r3, #12]
  hi2c->Instance->CR1 = (hi2c->Init.GeneralCallMode | hi2c->Init.NoStretchMode);
 8010f0a:	6a20      	ldr	r0, [r4, #32]
  hi2c->Instance->OAR2 = (hi2c->Init.DualAddressMode | hi2c->Init.OwnAddress2 | (hi2c->Init.OwnAddress2Masks << 8));
 8010f0c:	60da      	str	r2, [r3, #12]
  hi2c->Instance->CR1 = (hi2c->Init.GeneralCallMode | hi2c->Init.NoStretchMode);
 8010f0e:	4301      	orrs	r1, r0
 8010f10:	6019      	str	r1, [r3, #0]
  __HAL_I2C_ENABLE(hi2c);
 8010f12:	6819      	ldr	r1, [r3, #0]
 8010f14:	f041 0101 	orr.w	r1, r1, #1
 8010f18:	6019      	str	r1, [r3, #0]
  hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
 8010f1a:	2200      	movs	r2, #0
  hi2c->State = HAL_I2C_STATE_READY;
 8010f1c:	2320      	movs	r3, #32
  hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
 8010f1e:	6462      	str	r2, [r4, #68]	; 0x44
  hi2c->State = HAL_I2C_STATE_READY;
 8010f20:	f884 3041 	strb.w	r3, [r4, #65]	; 0x41
  hi2c->PreviousState = I2C_STATE_NONE;
 8010f24:	6322      	str	r2, [r4, #48]	; 0x30
  hi2c->Mode = HAL_I2C_MODE_NONE;
 8010f26:	f884 2042 	strb.w	r2, [r4, #66]	; 0x42
  return HAL_OK;
 8010f2a:	4610      	mov	r0, r2
}
 8010f2c:	bd10      	pop	{r4, pc}
    hi2c->Instance->OAR1 = (I2C_OAR1_OA1EN | hi2c->Init.OwnAddress1);
 8010f2e:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
 8010f32:	609a      	str	r2, [r3, #8]
  if (hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_10BIT)
 8010f34:	e7d8      	b.n	8010ee8 <HAL_I2C_Init+0x4c>
    hi2c->Lock = HAL_UNLOCKED;
 8010f36:	f880 2040 	strb.w	r2, [r0, #64]	; 0x40
    HAL_I2C_MspInit(hi2c);
 8010f3a:	f7ff ffad 	bl	8010e98 <HAL_I2C_MspInit>
 8010f3e:	e7b7      	b.n	8010eb0 <HAL_I2C_Init+0x14>
    return HAL_ERROR;
 8010f40:	2001      	movs	r0, #1
}
 8010f42:	4770      	bx	lr

08010f44 <HAL_I2C_MspDeInit>:
 8010f44:	4770      	bx	lr
 8010f46:	bf00      	nop

08010f48 <HAL_I2C_DeInit>:
  if (hi2c == NULL)
 8010f48:	b1b0      	cbz	r0, 8010f78 <HAL_I2C_DeInit+0x30>
  __HAL_I2C_DISABLE(hi2c);
 8010f4a:	6802      	ldr	r2, [r0, #0]
  hi2c->State = HAL_I2C_STATE_BUSY;
 8010f4c:	2324      	movs	r3, #36	; 0x24
{
 8010f4e:	b510      	push	{r4, lr}
  hi2c->State = HAL_I2C_STATE_BUSY;
 8010f50:	f880 3041 	strb.w	r3, [r0, #65]	; 0x41
  __HAL_I2C_DISABLE(hi2c);
 8010f54:	6813      	ldr	r3, [r2, #0]
 8010f56:	f023 0301 	bic.w	r3, r3, #1
 8010f5a:	4604      	mov	r4, r0
 8010f5c:	6013      	str	r3, [r2, #0]
  HAL_I2C_MspDeInit(hi2c);
 8010f5e:	f7ff fff1 	bl	8010f44 <HAL_I2C_MspDeInit>
  hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
 8010f62:	2300      	movs	r3, #0
 8010f64:	6463      	str	r3, [r4, #68]	; 0x44
  __HAL_UNLOCK(hi2c);
 8010f66:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
  hi2c->State = HAL_I2C_STATE_RESET;
 8010f6a:	f884 3041 	strb.w	r3, [r4, #65]	; 0x41
  hi2c->PreviousState = I2C_STATE_NONE;
 8010f6e:	6323      	str	r3, [r4, #48]	; 0x30
  hi2c->Mode = HAL_I2C_MODE_NONE;
 8010f70:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
  return HAL_OK;
 8010f74:	4618      	mov	r0, r3
}
 8010f76:	bd10      	pop	{r4, pc}
    return HAL_ERROR;
 8010f78:	2001      	movs	r0, #1
}
 8010f7a:	4770      	bx	lr

08010f7c <HAL_I2C_Mem_Write>:
{
 8010f7c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8010f80:	4699      	mov	r9, r3
  if (hi2c->State == HAL_I2C_STATE_READY)
 8010f82:	f890 3041 	ldrb.w	r3, [r0, #65]	; 0x41
{
 8010f86:	b083      	sub	sp, #12
  if (hi2c->State == HAL_I2C_STATE_READY)
 8010f88:	2b20      	cmp	r3, #32
{
 8010f8a:	f8bd a034 	ldrh.w	sl, [sp, #52]	; 0x34
 8010f8e:	9d0e      	ldr	r5, [sp, #56]	; 0x38
  if (hi2c->State == HAL_I2C_STATE_READY)
 8010f90:	f040 8092 	bne.w	80110b8 <HAL_I2C_Mem_Write+0x13c>
    if ((pData == NULL) || (Size == 0U))
 8010f94:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8010f96:	4604      	mov	r4, r0
 8010f98:	2b00      	cmp	r3, #0
 8010f9a:	f000 8086 	beq.w	80110aa <HAL_I2C_Mem_Write+0x12e>
 8010f9e:	f1ba 0f00 	cmp.w	sl, #0
 8010fa2:	f000 8082 	beq.w	80110aa <HAL_I2C_Mem_Write+0x12e>
    __HAL_LOCK(hi2c);
 8010fa6:	f890 3040 	ldrb.w	r3, [r0, #64]	; 0x40
 8010faa:	2b01      	cmp	r3, #1
 8010fac:	f000 8084 	beq.w	80110b8 <HAL_I2C_Mem_Write+0x13c>
 8010fb0:	2301      	movs	r3, #1
 8010fb2:	f880 3040 	strb.w	r3, [r0, #64]	; 0x40
 8010fb6:	460f      	mov	r7, r1
 8010fb8:	4690      	mov	r8, r2
    tickstart = HAL_GetTick();
 8010fba:	f7fe fc3d 	bl	800f838 <HAL_GetTick>
 8010fbe:	4606      	mov	r6, r0
  while (__HAL_I2C_GET_FLAG(hi2c, Flag) == Status)
 8010fc0:	e004      	b.n	8010fcc <HAL_I2C_Mem_Write+0x50>
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
 8010fc2:	f7fe fc39 	bl	800f838 <HAL_GetTick>
 8010fc6:	1b80      	subs	r0, r0, r6
 8010fc8:	2819      	cmp	r0, #25
 8010fca:	d879      	bhi.n	80110c0 <HAL_I2C_Mem_Write+0x144>
  while (__HAL_I2C_GET_FLAG(hi2c, Flag) == Status)
 8010fcc:	6823      	ldr	r3, [r4, #0]
 8010fce:	699b      	ldr	r3, [r3, #24]
 8010fd0:	f413 4b00 	ands.w	fp, r3, #32768	; 0x8000
 8010fd4:	d1f5      	bne.n	8010fc2 <HAL_I2C_Mem_Write+0x46>
    hi2c->pBuffPtr  = pData;
 8010fd6:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8010fd8:	6263      	str	r3, [r4, #36]	; 0x24
    hi2c->State     = HAL_I2C_STATE_BUSY_TX;
 8010fda:	2121      	movs	r1, #33	; 0x21
    hi2c->XferISR   = NULL;
 8010fdc:	f8c4 b034 	str.w	fp, [r4, #52]	; 0x34
    if (I2C_RequestMemoryWrite(hi2c, DevAddress, MemAddress, MemAddSize, Timeout, tickstart) != HAL_OK)
 8010fe0:	e9cd 5600 	strd	r5, r6, [sp]
    hi2c->State     = HAL_I2C_STATE_BUSY_TX;
 8010fe4:	f884 1041 	strb.w	r1, [r4, #65]	; 0x41
    hi2c->Mode      = HAL_I2C_MODE_MEM;
 8010fe8:	2140      	movs	r1, #64	; 0x40
 8010fea:	f884 1042 	strb.w	r1, [r4, #66]	; 0x42
    if (I2C_RequestMemoryWrite(hi2c, DevAddress, MemAddress, MemAddSize, Timeout, tickstart) != HAL_OK)
 8010fee:	464b      	mov	r3, r9
    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
 8010ff0:	f8c4 b044 	str.w	fp, [r4, #68]	; 0x44
    if (I2C_RequestMemoryWrite(hi2c, DevAddress, MemAddress, MemAddSize, Timeout, tickstart) != HAL_OK)
 8010ff4:	4642      	mov	r2, r8
    hi2c->XferCount = Size;
 8010ff6:	f8a4 a02a 	strh.w	sl, [r4, #42]	; 0x2a
    if (I2C_RequestMemoryWrite(hi2c, DevAddress, MemAddress, MemAddSize, Timeout, tickstart) != HAL_OK)
 8010ffa:	4639      	mov	r1, r7
 8010ffc:	4620      	mov	r0, r4
 8010ffe:	f7ff fe9f 	bl	8010d40 <I2C_RequestMemoryWrite>
 8011002:	2800      	cmp	r0, #0
 8011004:	f040 8095 	bne.w	8011132 <HAL_I2C_Mem_Write+0x1b6>
    if (hi2c->XferCount > MAX_NBYTE_SIZE)
 8011008:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
 801100a:	b29b      	uxth	r3, r3
 801100c:	2bff      	cmp	r3, #255	; 0xff
 801100e:	d867      	bhi.n	80110e0 <HAL_I2C_Mem_Write+0x164>
      hi2c->XferSize = hi2c->XferCount;
 8011010:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
  MODIFY_REG(hi2c->Instance->CR2, ((I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | (I2C_CR2_RD_WRN & (uint32_t)(Request >> (31U - I2C_CR2_RD_WRN_Pos))) | I2C_CR2_START | I2C_CR2_STOP)), \
 8011012:	6820      	ldr	r0, [r4, #0]
 8011014:	4953      	ldr	r1, [pc, #332]	; (8011164 <HAL_I2C_Mem_Write+0x1e8>)
      hi2c->XferSize = hi2c->XferCount;
 8011016:	b29b      	uxth	r3, r3
 8011018:	8523      	strh	r3, [r4, #40]	; 0x28
  MODIFY_REG(hi2c->Instance->CR2, ((I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | (I2C_CR2_RD_WRN & (uint32_t)(Request >> (31U - I2C_CR2_RD_WRN_Pos))) | I2C_CR2_START | I2C_CR2_STOP)), \
 801101a:	b2da      	uxtb	r2, r3
 801101c:	6843      	ldr	r3, [r0, #4]
 801101e:	4019      	ands	r1, r3
 8011020:	f3c7 0309 	ubfx	r3, r7, #0, #10
 8011024:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
 8011028:	430b      	orrs	r3, r1
 801102a:	f043 7300 	orr.w	r3, r3, #33554432	; 0x2000000
 801102e:	6043      	str	r3, [r0, #4]
 8011030:	f3c7 0709 	ubfx	r7, r7, #0, #10
 8011034:	f8df 812c 	ldr.w	r8, [pc, #300]	; 8011164 <HAL_I2C_Mem_Write+0x1e8>
 8011038:	f8df 9130 	ldr.w	r9, [pc, #304]	; 801116c <HAL_I2C_Mem_Write+0x1f0>
 801103c:	b2bf      	uxth	r7, r7
 801103e:	e003      	b.n	8011048 <HAL_I2C_Mem_Write+0xcc>
    while (hi2c->XferCount > 0U);
 8011040:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
 8011042:	b29b      	uxth	r3, r3
 8011044:	2b00      	cmp	r3, #0
 8011046:	d078      	beq.n	801113a <HAL_I2C_Mem_Write+0x1be>
      if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
 8011048:	4632      	mov	r2, r6
 801104a:	4629      	mov	r1, r5
 801104c:	4620      	mov	r0, r4
 801104e:	f7ff fe1d 	bl	8010c8c <I2C_WaitOnTXISFlagUntilTimeout>
 8011052:	2800      	cmp	r0, #0
 8011054:	d16b      	bne.n	801112e <HAL_I2C_Mem_Write+0x1b2>
      hi2c->Instance->TXDR = *hi2c->pBuffPtr;
 8011056:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8011058:	6822      	ldr	r2, [r4, #0]
 801105a:	f813 1b01 	ldrb.w	r1, [r3], #1
 801105e:	6291      	str	r1, [r2, #40]	; 0x28
      hi2c->pBuffPtr++;
 8011060:	6263      	str	r3, [r4, #36]	; 0x24
      hi2c->XferCount--;
 8011062:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
 8011064:	3b01      	subs	r3, #1
 8011066:	b29b      	uxth	r3, r3
 8011068:	8563      	strh	r3, [r4, #42]	; 0x2a
      hi2c->XferSize--;
 801106a:	8d23      	ldrh	r3, [r4, #40]	; 0x28
      if ((hi2c->XferCount != 0U) && (hi2c->XferSize == 0U))
 801106c:	8d61      	ldrh	r1, [r4, #42]	; 0x2a
      hi2c->XferSize--;
 801106e:	3b01      	subs	r3, #1
 8011070:	b29b      	uxth	r3, r3
      if ((hi2c->XferCount != 0U) && (hi2c->XferSize == 0U))
 8011072:	b289      	uxth	r1, r1
      hi2c->XferSize--;
 8011074:	8523      	strh	r3, [r4, #40]	; 0x28
      if ((hi2c->XferCount != 0U) && (hi2c->XferSize == 0U))
 8011076:	2900      	cmp	r1, #0
 8011078:	d0e2      	beq.n	8011040 <HAL_I2C_Mem_Write+0xc4>
 801107a:	2b00      	cmp	r3, #0
 801107c:	d1e0      	bne.n	8011040 <HAL_I2C_Mem_Write+0xc4>
  while (__HAL_I2C_GET_FLAG(hi2c, Flag) == Status)
 801107e:	6993      	ldr	r3, [r2, #24]
 8011080:	061b      	lsls	r3, r3, #24
 8011082:	d404      	bmi.n	801108e <HAL_I2C_Mem_Write+0x112>
    if (Timeout != HAL_MAX_DELAY)
 8011084:	1c69      	adds	r1, r5, #1
 8011086:	d13b      	bne.n	8011100 <HAL_I2C_Mem_Write+0x184>
  while (__HAL_I2C_GET_FLAG(hi2c, Flag) == Status)
 8011088:	6993      	ldr	r3, [r2, #24]
 801108a:	061b      	lsls	r3, r3, #24
 801108c:	d5fa      	bpl.n	8011084 <HAL_I2C_Mem_Write+0x108>
        if (hi2c->XferCount > MAX_NBYTE_SIZE)
 801108e:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
 8011090:	b29b      	uxth	r3, r3
 8011092:	2bff      	cmp	r3, #255	; 0xff
 8011094:	d93d      	bls.n	8011112 <HAL_I2C_Mem_Write+0x196>
  MODIFY_REG(hi2c->Instance->CR2, ((I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | (I2C_CR2_RD_WRN & (uint32_t)(Request >> (31U - I2C_CR2_RD_WRN_Pos))) | I2C_CR2_START | I2C_CR2_STOP)), \
 8011096:	6853      	ldr	r3, [r2, #4]
 8011098:	ea03 0308 	and.w	r3, r3, r8
 801109c:	433b      	orrs	r3, r7
 801109e:	ea43 0309 	orr.w	r3, r3, r9
          hi2c->XferSize = MAX_NBYTE_SIZE;
 80110a2:	21ff      	movs	r1, #255	; 0xff
 80110a4:	8521      	strh	r1, [r4, #40]	; 0x28
  MODIFY_REG(hi2c->Instance->CR2, ((I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | (I2C_CR2_RD_WRN & (uint32_t)(Request >> (31U - I2C_CR2_RD_WRN_Pos))) | I2C_CR2_START | I2C_CR2_STOP)), \
 80110a6:	6053      	str	r3, [r2, #4]
             (uint32_t)(((uint32_t)DevAddress & I2C_CR2_SADD) | (((uint32_t)Size << I2C_CR2_NBYTES_Pos) & I2C_CR2_NBYTES) | (uint32_t)Mode | (uint32_t)Request));
}
 80110a8:	e7ca      	b.n	8011040 <HAL_I2C_Mem_Write+0xc4>
      hi2c->ErrorCode = HAL_I2C_ERROR_INVALID_PARAM;
 80110aa:	f44f 7300 	mov.w	r3, #512	; 0x200
 80110ae:	6463      	str	r3, [r4, #68]	; 0x44
      return  HAL_ERROR;
 80110b0:	2001      	movs	r0, #1
}
 80110b2:	b003      	add	sp, #12
 80110b4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    return HAL_BUSY;
 80110b8:	2002      	movs	r0, #2
}
 80110ba:	b003      	add	sp, #12
 80110bc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
 80110c0:	6c63      	ldr	r3, [r4, #68]	; 0x44
        hi2c->Mode = HAL_I2C_MODE_NONE;
 80110c2:	2200      	movs	r2, #0
        hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
 80110c4:	f043 0320 	orr.w	r3, r3, #32
        hi2c->State = HAL_I2C_STATE_READY;
 80110c8:	2120      	movs	r1, #32
          return HAL_ERROR;
 80110ca:	2001      	movs	r0, #1
        hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
 80110cc:	6463      	str	r3, [r4, #68]	; 0x44
        __HAL_UNLOCK(hi2c);
 80110ce:	f884 2040 	strb.w	r2, [r4, #64]	; 0x40
        hi2c->State = HAL_I2C_STATE_READY;
 80110d2:	f884 1041 	strb.w	r1, [r4, #65]	; 0x41
        hi2c->Mode = HAL_I2C_MODE_NONE;
 80110d6:	f884 2042 	strb.w	r2, [r4, #66]	; 0x42
}
 80110da:	b003      	add	sp, #12
 80110dc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  MODIFY_REG(hi2c->Instance->CR2, ((I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | (I2C_CR2_RD_WRN & (uint32_t)(Request >> (31U - I2C_CR2_RD_WRN_Pos))) | I2C_CR2_START | I2C_CR2_STOP)), \
 80110e0:	6822      	ldr	r2, [r4, #0]
 80110e2:	4920      	ldr	r1, [pc, #128]	; (8011164 <HAL_I2C_Mem_Write+0x1e8>)
      hi2c->XferSize = MAX_NBYTE_SIZE;
 80110e4:	23ff      	movs	r3, #255	; 0xff
 80110e6:	8523      	strh	r3, [r4, #40]	; 0x28
  MODIFY_REG(hi2c->Instance->CR2, ((I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | (I2C_CR2_RD_WRN & (uint32_t)(Request >> (31U - I2C_CR2_RD_WRN_Pos))) | I2C_CR2_START | I2C_CR2_STOP)), \
 80110e8:	6853      	ldr	r3, [r2, #4]
 80110ea:	400b      	ands	r3, r1
 80110ec:	f3c7 0109 	ubfx	r1, r7, #0, #10
 80110f0:	430b      	orrs	r3, r1
 80110f2:	f043 73ff 	orr.w	r3, r3, #33423360	; 0x1fe0000
 80110f6:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 80110fa:	6053      	str	r3, [r2, #4]
 80110fc:	460f      	mov	r7, r1
}
 80110fe:	e799      	b.n	8011034 <HAL_I2C_Mem_Write+0xb8>
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
 8011100:	f7fe fb9a 	bl	800f838 <HAL_GetTick>
 8011104:	1b80      	subs	r0, r0, r6
 8011106:	4285      	cmp	r5, r0
 8011108:	d3da      	bcc.n	80110c0 <HAL_I2C_Mem_Write+0x144>
 801110a:	2d00      	cmp	r5, #0
 801110c:	d0d8      	beq.n	80110c0 <HAL_I2C_Mem_Write+0x144>
  while (__HAL_I2C_GET_FLAG(hi2c, Flag) == Status)
 801110e:	6822      	ldr	r2, [r4, #0]
 8011110:	e7ba      	b.n	8011088 <HAL_I2C_Mem_Write+0x10c>
          hi2c->XferSize = hi2c->XferCount;
 8011112:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
 8011114:	b29b      	uxth	r3, r3
 8011116:	8523      	strh	r3, [r4, #40]	; 0x28
  MODIFY_REG(hi2c->Instance->CR2, ((I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | (I2C_CR2_RD_WRN & (uint32_t)(Request >> (31U - I2C_CR2_RD_WRN_Pos))) | I2C_CR2_START | I2C_CR2_STOP)), \
 8011118:	b2d9      	uxtb	r1, r3
 801111a:	6853      	ldr	r3, [r2, #4]
 801111c:	ea03 0308 	and.w	r3, r3, r8
 8011120:	433b      	orrs	r3, r7
 8011122:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
 8011126:	f043 7300 	orr.w	r3, r3, #33554432	; 0x2000000
 801112a:	6053      	str	r3, [r2, #4]
}
 801112c:	e788      	b.n	8011040 <HAL_I2C_Mem_Write+0xc4>
        return HAL_ERROR;
 801112e:	2001      	movs	r0, #1
 8011130:	e7bf      	b.n	80110b2 <HAL_I2C_Mem_Write+0x136>
      __HAL_UNLOCK(hi2c);
 8011132:	f884 b040 	strb.w	fp, [r4, #64]	; 0x40
      return HAL_ERROR;
 8011136:	2001      	movs	r0, #1
 8011138:	e7bb      	b.n	80110b2 <HAL_I2C_Mem_Write+0x136>
    if (I2C_WaitOnSTOPFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
 801113a:	4632      	mov	r2, r6
 801113c:	4629      	mov	r1, r5
 801113e:	4620      	mov	r0, r4
 8011140:	f7ff fdd2 	bl	8010ce8 <I2C_WaitOnSTOPFlagUntilTimeout>
 8011144:	2800      	cmp	r0, #0
 8011146:	d1f2      	bne.n	801112e <HAL_I2C_Mem_Write+0x1b2>
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
 8011148:	6823      	ldr	r3, [r4, #0]
    I2C_RESET_CR2(hi2c);
 801114a:	4d07      	ldr	r5, [pc, #28]	; (8011168 <HAL_I2C_Mem_Write+0x1ec>)
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
 801114c:	2120      	movs	r1, #32
 801114e:	61d9      	str	r1, [r3, #28]
    I2C_RESET_CR2(hi2c);
 8011150:	685a      	ldr	r2, [r3, #4]
 8011152:	402a      	ands	r2, r5
 8011154:	605a      	str	r2, [r3, #4]
    hi2c->State = HAL_I2C_STATE_READY;
 8011156:	f884 1041 	strb.w	r1, [r4, #65]	; 0x41
    __HAL_UNLOCK(hi2c);
 801115a:	f884 0040 	strb.w	r0, [r4, #64]	; 0x40
    hi2c->Mode  = HAL_I2C_MODE_NONE;
 801115e:	f884 0042 	strb.w	r0, [r4, #66]	; 0x42
    return HAL_OK;
 8011162:	e7a6      	b.n	80110b2 <HAL_I2C_Mem_Write+0x136>
 8011164:	fc009c00 	.word	0xfc009c00
 8011168:	fe00e800 	.word	0xfe00e800
 801116c:	01ff0000 	.word	0x01ff0000

08011170 <HAL_I2C_Mem_Read>:
{
 8011170:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8011174:	4699      	mov	r9, r3
  if (hi2c->State == HAL_I2C_STATE_READY)
 8011176:	f890 3041 	ldrb.w	r3, [r0, #65]	; 0x41
{
 801117a:	b083      	sub	sp, #12
  if (hi2c->State == HAL_I2C_STATE_READY)
 801117c:	2b20      	cmp	r3, #32
{
 801117e:	f8bd a034 	ldrh.w	sl, [sp, #52]	; 0x34
 8011182:	9c0e      	ldr	r4, [sp, #56]	; 0x38
  if (hi2c->State == HAL_I2C_STATE_READY)
 8011184:	d178      	bne.n	8011278 <HAL_I2C_Mem_Read+0x108>
    if ((pData == NULL) || (Size == 0U))
 8011186:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8011188:	4605      	mov	r5, r0
 801118a:	2b00      	cmp	r3, #0
 801118c:	d06d      	beq.n	801126a <HAL_I2C_Mem_Read+0xfa>
 801118e:	f1ba 0f00 	cmp.w	sl, #0
 8011192:	d06a      	beq.n	801126a <HAL_I2C_Mem_Read+0xfa>
    __HAL_LOCK(hi2c);
 8011194:	f890 3040 	ldrb.w	r3, [r0, #64]	; 0x40
 8011198:	2b01      	cmp	r3, #1
 801119a:	d06d      	beq.n	8011278 <HAL_I2C_Mem_Read+0x108>
 801119c:	2301      	movs	r3, #1
 801119e:	f880 3040 	strb.w	r3, [r0, #64]	; 0x40
 80111a2:	460f      	mov	r7, r1
 80111a4:	4690      	mov	r8, r2
    tickstart = HAL_GetTick();
 80111a6:	f7fe fb47 	bl	800f838 <HAL_GetTick>
 80111aa:	4606      	mov	r6, r0
  while (__HAL_I2C_GET_FLAG(hi2c, Flag) == Status)
 80111ac:	e004      	b.n	80111b8 <HAL_I2C_Mem_Read+0x48>
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
 80111ae:	f7fe fb43 	bl	800f838 <HAL_GetTick>
 80111b2:	1b80      	subs	r0, r0, r6
 80111b4:	2819      	cmp	r0, #25
 80111b6:	d86a      	bhi.n	801128e <HAL_I2C_Mem_Read+0x11e>
  while (__HAL_I2C_GET_FLAG(hi2c, Flag) == Status)
 80111b8:	682b      	ldr	r3, [r5, #0]
 80111ba:	699b      	ldr	r3, [r3, #24]
 80111bc:	f413 4b00 	ands.w	fp, r3, #32768	; 0x8000
 80111c0:	d1f5      	bne.n	80111ae <HAL_I2C_Mem_Read+0x3e>
    hi2c->pBuffPtr  = pData;
 80111c2:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 80111c4:	626b      	str	r3, [r5, #36]	; 0x24
    hi2c->State     = HAL_I2C_STATE_BUSY_RX;
 80111c6:	2122      	movs	r1, #34	; 0x22
    hi2c->XferISR   = NULL;
 80111c8:	f8c5 b034 	str.w	fp, [r5, #52]	; 0x34
    if (I2C_RequestMemoryRead(hi2c, DevAddress, MemAddress, MemAddSize, Timeout, tickstart) != HAL_OK)
 80111cc:	e9cd 4600 	strd	r4, r6, [sp]
    hi2c->State     = HAL_I2C_STATE_BUSY_RX;
 80111d0:	f885 1041 	strb.w	r1, [r5, #65]	; 0x41
    hi2c->Mode      = HAL_I2C_MODE_MEM;
 80111d4:	2140      	movs	r1, #64	; 0x40
 80111d6:	f885 1042 	strb.w	r1, [r5, #66]	; 0x42
    if (I2C_RequestMemoryRead(hi2c, DevAddress, MemAddress, MemAddSize, Timeout, tickstart) != HAL_OK)
 80111da:	464b      	mov	r3, r9
    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
 80111dc:	f8c5 b044 	str.w	fp, [r5, #68]	; 0x44
    if (I2C_RequestMemoryRead(hi2c, DevAddress, MemAddress, MemAddSize, Timeout, tickstart) != HAL_OK)
 80111e0:	4642      	mov	r2, r8
    hi2c->XferCount = Size;
 80111e2:	f8a5 a02a 	strh.w	sl, [r5, #42]	; 0x2a
    if (I2C_RequestMemoryRead(hi2c, DevAddress, MemAddress, MemAddSize, Timeout, tickstart) != HAL_OK)
 80111e6:	4639      	mov	r1, r7
 80111e8:	4628      	mov	r0, r5
 80111ea:	f7ff fdff 	bl	8010dec <I2C_RequestMemoryRead>
 80111ee:	2800      	cmp	r0, #0
 80111f0:	f040 8095 	bne.w	801131e <HAL_I2C_Mem_Read+0x1ae>
    if (hi2c->XferCount > MAX_NBYTE_SIZE)
 80111f4:	8d6b      	ldrh	r3, [r5, #42]	; 0x2a
 80111f6:	b29b      	uxth	r3, r3
 80111f8:	2bff      	cmp	r3, #255	; 0xff
 80111fa:	d874      	bhi.n	80112e6 <HAL_I2C_Mem_Read+0x176>
      hi2c->XferSize = hi2c->XferCount;
 80111fc:	8d6b      	ldrh	r3, [r5, #42]	; 0x2a
  MODIFY_REG(hi2c->Instance->CR2, ((I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | (I2C_CR2_RD_WRN & (uint32_t)(Request >> (31U - I2C_CR2_RD_WRN_Pos))) | I2C_CR2_START | I2C_CR2_STOP)), \
 80111fe:	682a      	ldr	r2, [r5, #0]
 8011200:	4854      	ldr	r0, [pc, #336]	; (8011354 <HAL_I2C_Mem_Read+0x1e4>)
      hi2c->XferSize = hi2c->XferCount;
 8011202:	b29b      	uxth	r3, r3
 8011204:	852b      	strh	r3, [r5, #40]	; 0x28
  MODIFY_REG(hi2c->Instance->CR2, ((I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | (I2C_CR2_RD_WRN & (uint32_t)(Request >> (31U - I2C_CR2_RD_WRN_Pos))) | I2C_CR2_START | I2C_CR2_STOP)), \
 8011206:	b2d9      	uxtb	r1, r3
 8011208:	6853      	ldr	r3, [r2, #4]
 801120a:	4018      	ands	r0, r3
 801120c:	f3c7 0309 	ubfx	r3, r7, #0, #10
 8011210:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
 8011214:	4303      	orrs	r3, r0
 8011216:	f043 4302 	orr.w	r3, r3, #2181038080	; 0x82000000
 801121a:	f443 5310 	orr.w	r3, r3, #9216	; 0x2400
 801121e:	6053      	str	r3, [r2, #4]
 8011220:	f3c7 0709 	ubfx	r7, r7, #0, #10
 8011224:	f8df 8138 	ldr.w	r8, [pc, #312]	; 8011360 <HAL_I2C_Mem_Read+0x1f0>
 8011228:	f8df 9138 	ldr.w	r9, [pc, #312]	; 8011364 <HAL_I2C_Mem_Read+0x1f4>
 801122c:	b2bf      	uxth	r7, r7
 801122e:	e001      	b.n	8011234 <HAL_I2C_Mem_Read+0xc4>
    if (Timeout != HAL_MAX_DELAY)
 8011230:	1c63      	adds	r3, r4, #1
 8011232:	d125      	bne.n	8011280 <HAL_I2C_Mem_Read+0x110>
  while (__HAL_I2C_GET_FLAG(hi2c, Flag) == Status)
 8011234:	6993      	ldr	r3, [r2, #24]
 8011236:	0758      	lsls	r0, r3, #29
 8011238:	d5fa      	bpl.n	8011230 <HAL_I2C_Mem_Read+0xc0>
      *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->RXDR;
 801123a:	6a6b      	ldr	r3, [r5, #36]	; 0x24
 801123c:	6a52      	ldr	r2, [r2, #36]	; 0x24
 801123e:	701a      	strb	r2, [r3, #0]
      hi2c->XferCount--;
 8011240:	8d6b      	ldrh	r3, [r5, #42]	; 0x2a
      hi2c->pBuffPtr++;
 8011242:	6a6a      	ldr	r2, [r5, #36]	; 0x24
      hi2c->XferCount--;
 8011244:	3b01      	subs	r3, #1
 8011246:	b29b      	uxth	r3, r3
 8011248:	856b      	strh	r3, [r5, #42]	; 0x2a
      hi2c->pBuffPtr++;
 801124a:	3201      	adds	r2, #1
      hi2c->XferSize--;
 801124c:	8d2b      	ldrh	r3, [r5, #40]	; 0x28
      hi2c->pBuffPtr++;
 801124e:	626a      	str	r2, [r5, #36]	; 0x24
      if ((hi2c->XferCount != 0U) && (hi2c->XferSize == 0U))
 8011250:	8d6a      	ldrh	r2, [r5, #42]	; 0x2a
      hi2c->XferSize--;
 8011252:	3b01      	subs	r3, #1
 8011254:	b29b      	uxth	r3, r3
      if ((hi2c->XferCount != 0U) && (hi2c->XferSize == 0U))
 8011256:	b292      	uxth	r2, r2
      hi2c->XferSize--;
 8011258:	852b      	strh	r3, [r5, #40]	; 0x28
      if ((hi2c->XferCount != 0U) && (hi2c->XferSize == 0U))
 801125a:	b102      	cbz	r2, 801125e <HAL_I2C_Mem_Read+0xee>
 801125c:	b373      	cbz	r3, 80112bc <HAL_I2C_Mem_Read+0x14c>
    while (hi2c->XferCount > 0U);
 801125e:	8d6b      	ldrh	r3, [r5, #42]	; 0x2a
 8011260:	b29b      	uxth	r3, r3
 8011262:	2b00      	cmp	r3, #0
 8011264:	d05f      	beq.n	8011326 <HAL_I2C_Mem_Read+0x1b6>
  while (__HAL_I2C_GET_FLAG(hi2c, Flag) == Status)
 8011266:	682a      	ldr	r2, [r5, #0]
 8011268:	e7e4      	b.n	8011234 <HAL_I2C_Mem_Read+0xc4>
      hi2c->ErrorCode = HAL_I2C_ERROR_INVALID_PARAM;
 801126a:	f44f 7300 	mov.w	r3, #512	; 0x200
 801126e:	646b      	str	r3, [r5, #68]	; 0x44
      return  HAL_ERROR;
 8011270:	2001      	movs	r0, #1
}
 8011272:	b003      	add	sp, #12
 8011274:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    return HAL_BUSY;
 8011278:	2002      	movs	r0, #2
}
 801127a:	b003      	add	sp, #12
 801127c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
 8011280:	f7fe fada 	bl	800f838 <HAL_GetTick>
 8011284:	1b80      	subs	r0, r0, r6
 8011286:	4284      	cmp	r4, r0
 8011288:	d301      	bcc.n	801128e <HAL_I2C_Mem_Read+0x11e>
 801128a:	2c00      	cmp	r4, #0
 801128c:	d1eb      	bne.n	8011266 <HAL_I2C_Mem_Read+0xf6>
        hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
 801128e:	6c6b      	ldr	r3, [r5, #68]	; 0x44
        hi2c->Mode = HAL_I2C_MODE_NONE;
 8011290:	2200      	movs	r2, #0
        hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
 8011292:	f043 0320 	orr.w	r3, r3, #32
        hi2c->State = HAL_I2C_STATE_READY;
 8011296:	2120      	movs	r1, #32
          return HAL_ERROR;
 8011298:	2001      	movs	r0, #1
        hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
 801129a:	646b      	str	r3, [r5, #68]	; 0x44
        __HAL_UNLOCK(hi2c);
 801129c:	f885 2040 	strb.w	r2, [r5, #64]	; 0x40
        hi2c->State = HAL_I2C_STATE_READY;
 80112a0:	f885 1041 	strb.w	r1, [r5, #65]	; 0x41
        hi2c->Mode = HAL_I2C_MODE_NONE;
 80112a4:	f885 2042 	strb.w	r2, [r5, #66]	; 0x42
}
 80112a8:	b003      	add	sp, #12
 80112aa:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
 80112ae:	f7fe fac3 	bl	800f838 <HAL_GetTick>
 80112b2:	1b80      	subs	r0, r0, r6
 80112b4:	4284      	cmp	r4, r0
 80112b6:	d3ea      	bcc.n	801128e <HAL_I2C_Mem_Read+0x11e>
 80112b8:	2c00      	cmp	r4, #0
 80112ba:	d0e8      	beq.n	801128e <HAL_I2C_Mem_Read+0x11e>
  while (__HAL_I2C_GET_FLAG(hi2c, Flag) == Status)
 80112bc:	682a      	ldr	r2, [r5, #0]
 80112be:	e001      	b.n	80112c4 <HAL_I2C_Mem_Read+0x154>
    if (Timeout != HAL_MAX_DELAY)
 80112c0:	1c61      	adds	r1, r4, #1
 80112c2:	d1f4      	bne.n	80112ae <HAL_I2C_Mem_Read+0x13e>
  while (__HAL_I2C_GET_FLAG(hi2c, Flag) == Status)
 80112c4:	6993      	ldr	r3, [r2, #24]
 80112c6:	061b      	lsls	r3, r3, #24
 80112c8:	d5fa      	bpl.n	80112c0 <HAL_I2C_Mem_Read+0x150>
        if (hi2c->XferCount > MAX_NBYTE_SIZE)
 80112ca:	8d6b      	ldrh	r3, [r5, #42]	; 0x2a
 80112cc:	b29b      	uxth	r3, r3
 80112ce:	2bff      	cmp	r3, #255	; 0xff
 80112d0:	d917      	bls.n	8011302 <HAL_I2C_Mem_Read+0x192>
  MODIFY_REG(hi2c->Instance->CR2, ((I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | (I2C_CR2_RD_WRN & (uint32_t)(Request >> (31U - I2C_CR2_RD_WRN_Pos))) | I2C_CR2_START | I2C_CR2_STOP)), \
 80112d2:	6853      	ldr	r3, [r2, #4]
 80112d4:	ea03 0308 	and.w	r3, r3, r8
 80112d8:	433b      	orrs	r3, r7
 80112da:	ea43 0309 	orr.w	r3, r3, r9
          hi2c->XferSize = MAX_NBYTE_SIZE;
 80112de:	21ff      	movs	r1, #255	; 0xff
 80112e0:	8529      	strh	r1, [r5, #40]	; 0x28
  MODIFY_REG(hi2c->Instance->CR2, ((I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | (I2C_CR2_RD_WRN & (uint32_t)(Request >> (31U - I2C_CR2_RD_WRN_Pos))) | I2C_CR2_START | I2C_CR2_STOP)), \
 80112e2:	6053      	str	r3, [r2, #4]
}
 80112e4:	e7bb      	b.n	801125e <HAL_I2C_Mem_Read+0xee>
  MODIFY_REG(hi2c->Instance->CR2, ((I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | (I2C_CR2_RD_WRN & (uint32_t)(Request >> (31U - I2C_CR2_RD_WRN_Pos))) | I2C_CR2_START | I2C_CR2_STOP)), \
 80112e6:	682a      	ldr	r2, [r5, #0]
 80112e8:	491a      	ldr	r1, [pc, #104]	; (8011354 <HAL_I2C_Mem_Read+0x1e4>)
      hi2c->XferSize = MAX_NBYTE_SIZE;
 80112ea:	23ff      	movs	r3, #255	; 0xff
 80112ec:	852b      	strh	r3, [r5, #40]	; 0x28
  MODIFY_REG(hi2c->Instance->CR2, ((I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | (I2C_CR2_RD_WRN & (uint32_t)(Request >> (31U - I2C_CR2_RD_WRN_Pos))) | I2C_CR2_START | I2C_CR2_STOP)), \
 80112ee:	6853      	ldr	r3, [r2, #4]
 80112f0:	f3c7 0009 	ubfx	r0, r7, #0, #10
 80112f4:	400b      	ands	r3, r1
 80112f6:	4918      	ldr	r1, [pc, #96]	; (8011358 <HAL_I2C_Mem_Read+0x1e8>)
 80112f8:	4303      	orrs	r3, r0
 80112fa:	4319      	orrs	r1, r3
 80112fc:	6051      	str	r1, [r2, #4]
 80112fe:	4607      	mov	r7, r0
}
 8011300:	e790      	b.n	8011224 <HAL_I2C_Mem_Read+0xb4>
          hi2c->XferSize = hi2c->XferCount;
 8011302:	8d6b      	ldrh	r3, [r5, #42]	; 0x2a
 8011304:	b29b      	uxth	r3, r3
 8011306:	852b      	strh	r3, [r5, #40]	; 0x28
  MODIFY_REG(hi2c->Instance->CR2, ((I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | (I2C_CR2_RD_WRN & (uint32_t)(Request >> (31U - I2C_CR2_RD_WRN_Pos))) | I2C_CR2_START | I2C_CR2_STOP)), \
 8011308:	b2d9      	uxtb	r1, r3
 801130a:	6853      	ldr	r3, [r2, #4]
 801130c:	ea03 0308 	and.w	r3, r3, r8
 8011310:	433b      	orrs	r3, r7
 8011312:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
 8011316:	f043 7300 	orr.w	r3, r3, #33554432	; 0x2000000
 801131a:	6053      	str	r3, [r2, #4]
}
 801131c:	e79f      	b.n	801125e <HAL_I2C_Mem_Read+0xee>
      __HAL_UNLOCK(hi2c);
 801131e:	f885 b040 	strb.w	fp, [r5, #64]	; 0x40
      return HAL_ERROR;
 8011322:	2001      	movs	r0, #1
 8011324:	e7a5      	b.n	8011272 <HAL_I2C_Mem_Read+0x102>
    if (I2C_WaitOnSTOPFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
 8011326:	4632      	mov	r2, r6
 8011328:	4621      	mov	r1, r4
 801132a:	4628      	mov	r0, r5
 801132c:	f7ff fcdc 	bl	8010ce8 <I2C_WaitOnSTOPFlagUntilTimeout>
 8011330:	b968      	cbnz	r0, 801134e <HAL_I2C_Mem_Read+0x1de>
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
 8011332:	682b      	ldr	r3, [r5, #0]
    I2C_RESET_CR2(hi2c);
 8011334:	4c09      	ldr	r4, [pc, #36]	; (801135c <HAL_I2C_Mem_Read+0x1ec>)
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
 8011336:	2120      	movs	r1, #32
 8011338:	61d9      	str	r1, [r3, #28]
    I2C_RESET_CR2(hi2c);
 801133a:	685a      	ldr	r2, [r3, #4]
 801133c:	4022      	ands	r2, r4
 801133e:	605a      	str	r2, [r3, #4]
    hi2c->State = HAL_I2C_STATE_READY;
 8011340:	f885 1041 	strb.w	r1, [r5, #65]	; 0x41
    __HAL_UNLOCK(hi2c);
 8011344:	f885 0040 	strb.w	r0, [r5, #64]	; 0x40
    hi2c->Mode  = HAL_I2C_MODE_NONE;
 8011348:	f885 0042 	strb.w	r0, [r5, #66]	; 0x42
    return HAL_OK;
 801134c:	e791      	b.n	8011272 <HAL_I2C_Mem_Read+0x102>
      return HAL_ERROR;
 801134e:	2001      	movs	r0, #1
 8011350:	e78f      	b.n	8011272 <HAL_I2C_Mem_Read+0x102>
 8011352:	bf00      	nop
 8011354:	fc009800 	.word	0xfc009800
 8011358:	81ff2400 	.word	0x81ff2400
 801135c:	fe00e800 	.word	0xfe00e800
 8011360:	fc009c00 	.word	0xfc009c00
 8011364:	01ff0000 	.word	0x01ff0000

08011368 <HAL_I2C_GetState>:
  return hi2c->State;
 8011368:	f890 0041 	ldrb.w	r0, [r0, #65]	; 0x41
}
 801136c:	4770      	bx	lr
 801136e:	bf00      	nop

08011370 <HAL_I2C_GetError>:
  return hi2c->ErrorCode;
 8011370:	6c40      	ldr	r0, [r0, #68]	; 0x44
}
 8011372:	4770      	bx	lr

08011374 <HAL_I2CEx_ConfigAnalogFilter>:
{
  /* Check the parameters */
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
  assert_param(IS_I2C_ANALOG_FILTER(AnalogFilter));

  if (hi2c->State == HAL_I2C_STATE_READY)
 8011374:	f890 2041 	ldrb.w	r2, [r0, #65]	; 0x41
 8011378:	2a20      	cmp	r2, #32
 801137a:	d123      	bne.n	80113c4 <HAL_I2CEx_ConfigAnalogFilter+0x50>
 801137c:	fa5f fc82 	uxtb.w	ip, r2
  {
    /* Process Locked */
    __HAL_LOCK(hi2c);
 8011380:	f890 2040 	ldrb.w	r2, [r0, #64]	; 0x40
 8011384:	2a01      	cmp	r2, #1
 8011386:	4603      	mov	r3, r0
 8011388:	d01c      	beq.n	80113c4 <HAL_I2CEx_ConfigAnalogFilter+0x50>

    hi2c->State = HAL_I2C_STATE_BUSY;

    /* Disable the selected I2C peripheral */
    __HAL_I2C_DISABLE(hi2c);
 801138a:	6802      	ldr	r2, [r0, #0]
    hi2c->State = HAL_I2C_STATE_BUSY;
 801138c:	2024      	movs	r0, #36	; 0x24
{
 801138e:	b500      	push	{lr}
    hi2c->State = HAL_I2C_STATE_BUSY;
 8011390:	f883 0041 	strb.w	r0, [r3, #65]	; 0x41
    __HAL_I2C_DISABLE(hi2c);
 8011394:	6810      	ldr	r0, [r2, #0]
 8011396:	f020 0001 	bic.w	r0, r0, #1
 801139a:	6010      	str	r0, [r2, #0]

    /* Reset I2Cx ANOFF bit */
    hi2c->Instance->CR1 &= ~(I2C_CR1_ANFOFF);
 801139c:	6810      	ldr	r0, [r2, #0]
 801139e:	f420 5080 	bic.w	r0, r0, #4096	; 0x1000
 80113a2:	6010      	str	r0, [r2, #0]

    /* Set analog filter bit*/
    hi2c->Instance->CR1 |= AnalogFilter;
 80113a4:	6810      	ldr	r0, [r2, #0]
 80113a6:	4301      	orrs	r1, r0
 80113a8:	6011      	str	r1, [r2, #0]

    __HAL_I2C_ENABLE(hi2c);
 80113aa:	6811      	ldr	r1, [r2, #0]

    hi2c->State = HAL_I2C_STATE_READY;

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
 80113ac:	f04f 0e00 	mov.w	lr, #0
    __HAL_I2C_ENABLE(hi2c);
 80113b0:	f041 0101 	orr.w	r1, r1, #1
 80113b4:	6011      	str	r1, [r2, #0]
    hi2c->State = HAL_I2C_STATE_READY;
 80113b6:	f883 c041 	strb.w	ip, [r3, #65]	; 0x41
    __HAL_UNLOCK(hi2c);
 80113ba:	f883 e040 	strb.w	lr, [r3, #64]	; 0x40

    return HAL_OK;
 80113be:	4670      	mov	r0, lr
  }
  else
  {
    return HAL_BUSY;
  }
}
 80113c0:	f85d fb04 	ldr.w	pc, [sp], #4
    return HAL_BUSY;
 80113c4:	2002      	movs	r0, #2
}
 80113c6:	4770      	bx	lr

080113c8 <HAL_I2CEx_ConfigDigitalFilter>:

  /* Check the parameters */
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
  assert_param(IS_I2C_DIGITAL_FILTER(DigitalFilter));

  if (hi2c->State == HAL_I2C_STATE_READY)
 80113c8:	f890 2041 	ldrb.w	r2, [r0, #65]	; 0x41
 80113cc:	2a20      	cmp	r2, #32
 80113ce:	d122      	bne.n	8011416 <HAL_I2CEx_ConfigDigitalFilter+0x4e>
{
 80113d0:	b500      	push	{lr}
 80113d2:	fa5f fe82 	uxtb.w	lr, r2
  {
    /* Process Locked */
    __HAL_LOCK(hi2c);
 80113d6:	f890 2040 	ldrb.w	r2, [r0, #64]	; 0x40
 80113da:	2a01      	cmp	r2, #1
 80113dc:	4603      	mov	r3, r0
 80113de:	d01c      	beq.n	801141a <HAL_I2CEx_ConfigDigitalFilter+0x52>

    hi2c->State = HAL_I2C_STATE_BUSY;

    /* Disable the selected I2C peripheral */
    __HAL_I2C_DISABLE(hi2c);
 80113e0:	6802      	ldr	r2, [r0, #0]
    hi2c->State = HAL_I2C_STATE_BUSY;
 80113e2:	2024      	movs	r0, #36	; 0x24
 80113e4:	f883 0041 	strb.w	r0, [r3, #65]	; 0x41
    __HAL_I2C_DISABLE(hi2c);
 80113e8:	6810      	ldr	r0, [r2, #0]
 80113ea:	f020 0001 	bic.w	r0, r0, #1
 80113ee:	6010      	str	r0, [r2, #0]

    /* Get the old register value */
    tmpreg = hi2c->Instance->CR1;
 80113f0:	6810      	ldr	r0, [r2, #0]

    /* Reset I2Cx DNF bits [11:8] */
    tmpreg &= ~(I2C_CR1_DNF);
 80113f2:	f420 6070 	bic.w	r0, r0, #3840	; 0xf00

    /* Set I2Cx DNF coefficient */
    tmpreg |= DigitalFilter << 8U;
 80113f6:	ea40 2101 	orr.w	r1, r0, r1, lsl #8

    /* Store the new register value */
    hi2c->Instance->CR1 = tmpreg;
 80113fa:	6011      	str	r1, [r2, #0]

    __HAL_I2C_ENABLE(hi2c);
 80113fc:	6811      	ldr	r1, [r2, #0]

    hi2c->State = HAL_I2C_STATE_READY;

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
 80113fe:	f04f 0c00 	mov.w	ip, #0
    __HAL_I2C_ENABLE(hi2c);
 8011402:	f041 0101 	orr.w	r1, r1, #1
 8011406:	6011      	str	r1, [r2, #0]
    hi2c->State = HAL_I2C_STATE_READY;
 8011408:	f883 e041 	strb.w	lr, [r3, #65]	; 0x41
    __HAL_UNLOCK(hi2c);
 801140c:	f883 c040 	strb.w	ip, [r3, #64]	; 0x40

    return HAL_OK;
 8011410:	4660      	mov	r0, ip
  }
  else
  {
    return HAL_BUSY;
  }
}
 8011412:	f85d fb04 	ldr.w	pc, [sp], #4
    return HAL_BUSY;
 8011416:	2002      	movs	r0, #2
}
 8011418:	4770      	bx	lr
    return HAL_BUSY;
 801141a:	2002      	movs	r0, #2
}
 801141c:	f85d fb04 	ldr.w	pc, [sp], #4

08011420 <HAL_PCD_Init>:
  *         parameters in the PCD_InitTypeDef and initialize the associated handle.
  * @param  hpcd PCD handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_Init(PCD_HandleTypeDef *hpcd)
{
 8011420:	b5f0      	push	{r4, r5, r6, r7, lr}
 8011422:	b08b      	sub	sp, #44	; 0x2c
  USB_OTG_GlobalTypeDef *USBx;
#endif /* defined (USB_OTG_FS) */
  uint8_t i;

  /* Check the PCD handle allocation */
  if (hpcd == NULL)
 8011424:	2800      	cmp	r0, #0
 8011426:	f000 8088 	beq.w	801153a <HAL_PCD_Init+0x11a>

#if defined (USB_OTG_FS)
  USBx = hpcd->Instance;
#endif /* defined (USB_OTG_FS) */

  if (hpcd->State == HAL_PCD_STATE_RESET)
 801142a:	f890 33bd 	ldrb.w	r3, [r0, #957]	; 0x3bd
  USBx = hpcd->Instance;
 801142e:	6804      	ldr	r4, [r0, #0]
  if (hpcd->State == HAL_PCD_STATE_RESET)
 8011430:	4605      	mov	r5, r0
 8011432:	f003 02ff 	and.w	r2, r3, #255	; 0xff
 8011436:	2b00      	cmp	r3, #0
 8011438:	d079      	beq.n	801152e <HAL_PCD_Init+0x10e>
 801143a:	4620      	mov	r0, r4
    /* Init the low level hardware : GPIO, CLOCK, NVIC... */
    HAL_PCD_MspInit(hpcd);
#endif /* (USE_HAL_PCD_REGISTER_CALLBACKS) */
  }

  hpcd->State = HAL_PCD_STATE_BUSY;
 801143c:	2303      	movs	r3, #3
 801143e:	f885 33bd 	strb.w	r3, [r5, #957]	; 0x3bd

#if defined (USB_OTG_FS)
  /* Disable DMA mode for FS instance */
  if ((USBx->CID & (0x1U << 8)) == 0U)
 8011442:	6be3      	ldr	r3, [r4, #60]	; 0x3c

  /* Disable the Interrupts */
  __HAL_PCD_DISABLE(hpcd);

  /*Init the Core (common init.) */
  if (USB_CoreInit(hpcd->Instance, hpcd->Init) != HAL_OK)
 8011444:	462e      	mov	r6, r5
  if ((USBx->CID & (0x1U << 8)) == 0U)
 8011446:	f413 7380 	ands.w	r3, r3, #256	; 0x100
    hpcd->Init.dma_enable = 0U;
 801144a:	bf08      	it	eq
 801144c:	612b      	streq	r3, [r5, #16]
  __HAL_PCD_DISABLE(hpcd);
 801144e:	f003 febf 	bl	80151d0 <USB_DisableGlobalInt>
  if (USB_CoreInit(hpcd->Instance, hpcd->Init) != HAL_OK)
 8011452:	f856 eb10 	ldr.w	lr, [r6], #16
 8011456:	46b4      	mov	ip, r6
 8011458:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 801145c:	466c      	mov	r4, sp
 801145e:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 8011460:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 8011464:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 8011466:	e89c 0003 	ldmia.w	ip, {r0, r1}
 801146a:	e884 0003 	stmia.w	r4, {r0, r1}
 801146e:	1d2f      	adds	r7, r5, #4
 8011470:	e897 000e 	ldmia.w	r7, {r1, r2, r3}
 8011474:	4670      	mov	r0, lr
 8011476:	f003 fdc7 	bl	8015008 <USB_CoreInit>
 801147a:	4604      	mov	r4, r0
 801147c:	b130      	cbz	r0, 801148c <HAL_PCD_Init+0x6c>

  /* Init Device */
  if (USB_DevInit(hpcd->Instance, hpcd->Init) != HAL_OK)
  {
    hpcd->State = HAL_PCD_STATE_ERROR;
    return HAL_ERROR;
 801147e:	2401      	movs	r4, #1
    hpcd->State = HAL_PCD_STATE_ERROR;
 8011480:	2302      	movs	r3, #2
  }
  
  (void)USB_DevDisconnect(hpcd->Instance);

  return HAL_OK;
}
 8011482:	4620      	mov	r0, r4
    hpcd->State = HAL_PCD_STATE_ERROR;
 8011484:	f885 33bd 	strb.w	r3, [r5, #957]	; 0x3bd
}
 8011488:	b00b      	add	sp, #44	; 0x2c
 801148a:	bdf0      	pop	{r4, r5, r6, r7, pc}
  (void)USB_SetCurrentMode(hpcd->Instance, USB_DEVICE_MODE);
 801148c:	4601      	mov	r1, r0
 801148e:	6828      	ldr	r0, [r5, #0]
 8011490:	f003 fea6 	bl	80151e0 <USB_SetCurrentMode>
  for (i = 0U; i < hpcd->Init.dev_endpoints; i++)
 8011494:	6868      	ldr	r0, [r5, #4]
 8011496:	b358      	cbz	r0, 80114f0 <HAL_PCD_Init+0xd0>
 8011498:	4622      	mov	r2, r4
    hpcd->IN_ep[i].is_in = 1U;
 801149a:	f04f 0e01 	mov.w	lr, #1
    hpcd->IN_ep[i].type = EP_TYPE_CTRL;
 801149e:	4621      	mov	r1, r4
    hpcd->IN_ep[i].is_in = 1U;
 80114a0:	ebc2 03c2 	rsb	r3, r2, r2, lsl #3
 80114a4:	eb05 0383 	add.w	r3, r5, r3, lsl #2
  for (i = 0U; i < hpcd->Init.dev_endpoints; i++)
 80114a8:	f102 0c01 	add.w	ip, r2, #1
    hpcd->IN_ep[i].num = i;
 80114ac:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c
    hpcd->IN_ep[i].tx_fifo_num = i;
 80114b0:	f8a3 2042 	strh.w	r2, [r3, #66]	; 0x42
  for (i = 0U; i < hpcd->Init.dev_endpoints; i++)
 80114b4:	fa5f f28c 	uxtb.w	r2, ip
 80114b8:	4282      	cmp	r2, r0
    hpcd->IN_ep[i].xfer_buff = 0U;
 80114ba:	e9c3 1111 	strd	r1, r1, [r3, #68]	; 0x44
    hpcd->IN_ep[i].is_in = 1U;
 80114be:	f883 e03d 	strb.w	lr, [r3, #61]	; 0x3d
    hpcd->IN_ep[i].type = EP_TYPE_CTRL;
 80114c2:	f883 103f 	strb.w	r1, [r3, #63]	; 0x3f
    hpcd->IN_ep[i].xfer_len = 0U;
 80114c6:	6519      	str	r1, [r3, #80]	; 0x50
  for (i = 0U; i < hpcd->Init.dev_endpoints; i++)
 80114c8:	d3ea      	bcc.n	80114a0 <HAL_PCD_Init+0x80>
    hpcd->OUT_ep[i].is_in = 0U;
 80114ca:	2200      	movs	r2, #0
 80114cc:	ebc4 03c4 	rsb	r3, r4, r4, lsl #3
 80114d0:	eb05 0383 	add.w	r3, r5, r3, lsl #2
  for (i = 0U; i < hpcd->Init.dev_endpoints; i++)
 80114d4:	1c61      	adds	r1, r4, #1
    hpcd->OUT_ep[i].num = i;
 80114d6:	f883 41fc 	strb.w	r4, [r3, #508]	; 0x1fc
  for (i = 0U; i < hpcd->Init.dev_endpoints; i++)
 80114da:	b2cc      	uxtb	r4, r1
 80114dc:	4284      	cmp	r4, r0
    hpcd->OUT_ep[i].xfer_buff = 0U;
 80114de:	e9c3 2281 	strd	r2, r2, [r3, #516]	; 0x204
    hpcd->OUT_ep[i].is_in = 0U;
 80114e2:	f883 21fd 	strb.w	r2, [r3, #509]	; 0x1fd
    hpcd->OUT_ep[i].type = EP_TYPE_CTRL;
 80114e6:	f883 21ff 	strb.w	r2, [r3, #511]	; 0x1ff
    hpcd->OUT_ep[i].xfer_len = 0U;
 80114ea:	f8c3 2210 	str.w	r2, [r3, #528]	; 0x210
  for (i = 0U; i < hpcd->Init.dev_endpoints; i++)
 80114ee:	d3ed      	bcc.n	80114cc <HAL_PCD_Init+0xac>
  if (USB_DevInit(hpcd->Instance, hpcd->Init) != HAL_OK)
 80114f0:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
 80114f2:	466c      	mov	r4, sp
 80114f4:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 80114f6:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
 80114f8:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 80114fa:	e896 0003 	ldmia.w	r6, {r0, r1}
 80114fe:	e884 0003 	stmia.w	r4, {r0, r1}
 8011502:	e897 000e 	ldmia.w	r7, {r1, r2, r3}
 8011506:	6828      	ldr	r0, [r5, #0]
 8011508:	f003 fe82 	bl	8015210 <USB_DevInit>
 801150c:	4604      	mov	r4, r0
 801150e:	2800      	cmp	r0, #0
 8011510:	d1b5      	bne.n	801147e <HAL_PCD_Init+0x5e>
  if (hpcd->Init.lpm_enable == 1U)
 8011512:	6a6b      	ldr	r3, [r5, #36]	; 0x24
  hpcd->USB_Address = 0U;
 8011514:	f885 0038 	strb.w	r0, [r5, #56]	; 0x38
  hpcd->State = HAL_PCD_STATE_READY;
 8011518:	2201      	movs	r2, #1
  if (hpcd->Init.lpm_enable == 1U)
 801151a:	4293      	cmp	r3, r2
  hpcd->State = HAL_PCD_STATE_READY;
 801151c:	f885 23bd 	strb.w	r2, [r5, #957]	; 0x3bd
  if (hpcd->Init.lpm_enable == 1U)
 8011520:	d00f      	beq.n	8011542 <HAL_PCD_Init+0x122>
  (void)USB_DevDisconnect(hpcd->Instance);
 8011522:	6828      	ldr	r0, [r5, #0]
 8011524:	f004 fa20 	bl	8015968 <USB_DevDisconnect>
}
 8011528:	4620      	mov	r0, r4
 801152a:	b00b      	add	sp, #44	; 0x2c
 801152c:	bdf0      	pop	{r4, r5, r6, r7, pc}
    hpcd->Lock = HAL_UNLOCKED;
 801152e:	f880 23bc 	strb.w	r2, [r0, #956]	; 0x3bc
    HAL_PCD_MspInit(hpcd);
 8011532:	f013 fa8d 	bl	8024a50 <HAL_PCD_MspInit>
  __HAL_PCD_DISABLE(hpcd);
 8011536:	6828      	ldr	r0, [r5, #0]
 8011538:	e780      	b.n	801143c <HAL_PCD_Init+0x1c>
    return HAL_ERROR;
 801153a:	2401      	movs	r4, #1
}
 801153c:	4620      	mov	r0, r4
 801153e:	b00b      	add	sp, #44	; 0x2c
 8011540:	bdf0      	pop	{r4, r5, r6, r7, pc}
    (void)HAL_PCDEx_ActivateLPM(hpcd);
 8011542:	4628      	mov	r0, r5
 8011544:	f000 fca4 	bl	8011e90 <HAL_PCDEx_ActivateLPM>
 8011548:	e7eb      	b.n	8011522 <HAL_PCD_Init+0x102>
 801154a:	bf00      	nop

0801154c <HAL_PCD_DeInit>:
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_DeInit(PCD_HandleTypeDef *hpcd)
{
  /* Check the PCD handle allocation */
  if (hpcd == NULL)
 801154c:	b348      	cbz	r0, 80115a2 <HAL_PCD_DeInit+0x56>
{
 801154e:	b538      	push	{r3, r4, r5, lr}
  * @param  hpcd PCD handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_Stop(PCD_HandleTypeDef *hpcd)
{
  __HAL_LOCK(hpcd);
 8011550:	f890 33bc 	ldrb.w	r3, [r0, #956]	; 0x3bc
  hpcd->State = HAL_PCD_STATE_BUSY;
 8011554:	2203      	movs	r2, #3
  __HAL_LOCK(hpcd);
 8011556:	2b01      	cmp	r3, #1
 8011558:	4604      	mov	r4, r0
  hpcd->State = HAL_PCD_STATE_BUSY;
 801155a:	f880 23bd 	strb.w	r2, [r0, #957]	; 0x3bd
  __HAL_LOCK(hpcd);
 801155e:	d00d      	beq.n	801157c <HAL_PCD_DeInit+0x30>
 8011560:	2301      	movs	r3, #1
  __HAL_PCD_DISABLE(hpcd);
 8011562:	6800      	ldr	r0, [r0, #0]
  __HAL_LOCK(hpcd);
 8011564:	f884 33bc 	strb.w	r3, [r4, #956]	; 0x3bc
  __HAL_PCD_DISABLE(hpcd);
 8011568:	f003 fe32 	bl	80151d0 <USB_DisableGlobalInt>

  if (USB_StopDevice(hpcd->Instance) != HAL_OK)
 801156c:	6820      	ldr	r0, [r4, #0]
 801156e:	f004 f9a9 	bl	80158c4 <USB_StopDevice>
 8011572:	4605      	mov	r5, r0
 8011574:	b148      	cbz	r0, 801158a <HAL_PCD_DeInit+0x3e>
  {
    __HAL_UNLOCK(hpcd);
 8011576:	2300      	movs	r3, #0
 8011578:	f884 33bc 	strb.w	r3, [r4, #956]	; 0x3bc
  HAL_PCD_MspDeInit(hpcd);
 801157c:	4620      	mov	r0, r4
 801157e:	f013 fa99 	bl	8024ab4 <HAL_PCD_MspDeInit>
  hpcd->State = HAL_PCD_STATE_RESET;
 8011582:	2000      	movs	r0, #0
 8011584:	f884 03bd 	strb.w	r0, [r4, #957]	; 0x3bd
}
 8011588:	bd38      	pop	{r3, r4, r5, pc}
    return HAL_ERROR;
  }

  (void)USB_DevDisconnect(hpcd->Instance);
 801158a:	6820      	ldr	r0, [r4, #0]
 801158c:	f004 f9ec 	bl	8015968 <USB_DevDisconnect>
  HAL_PCD_MspDeInit(hpcd);
 8011590:	4620      	mov	r0, r4
  __HAL_UNLOCK(hpcd);
 8011592:	f884 53bc 	strb.w	r5, [r4, #956]	; 0x3bc
  HAL_PCD_MspDeInit(hpcd);
 8011596:	f013 fa8d 	bl	8024ab4 <HAL_PCD_MspDeInit>
  hpcd->State = HAL_PCD_STATE_RESET;
 801159a:	2000      	movs	r0, #0
 801159c:	f884 03bd 	strb.w	r0, [r4, #957]	; 0x3bd
}
 80115a0:	bd38      	pop	{r3, r4, r5, pc}
    return HAL_ERROR;
 80115a2:	2001      	movs	r0, #1
}
 80115a4:	4770      	bx	lr
 80115a6:	bf00      	nop

080115a8 <HAL_PCD_Start>:
{
 80115a8:	b510      	push	{r4, lr}
  __HAL_LOCK(hpcd);
 80115aa:	f890 33bc 	ldrb.w	r3, [r0, #956]	; 0x3bc
 80115ae:	2b01      	cmp	r3, #1
{
 80115b0:	4604      	mov	r4, r0
  USB_OTG_GlobalTypeDef *USBx = hpcd->Instance;
 80115b2:	6800      	ldr	r0, [r0, #0]
  __HAL_LOCK(hpcd);
 80115b4:	d012      	beq.n	80115dc <HAL_PCD_Start+0x34>
  if (hpcd->Init.battery_charging_enable == 1U)
 80115b6:	6aa3      	ldr	r3, [r4, #40]	; 0x28
  __HAL_LOCK(hpcd);
 80115b8:	2201      	movs	r2, #1
  if (hpcd->Init.battery_charging_enable == 1U)
 80115ba:	4293      	cmp	r3, r2
  __HAL_LOCK(hpcd);
 80115bc:	f884 23bc 	strb.w	r2, [r4, #956]	; 0x3bc
  if (hpcd->Init.battery_charging_enable == 1U)
 80115c0:	d103      	bne.n	80115ca <HAL_PCD_Start+0x22>
    USBx->GCCFG |= USB_OTG_GCCFG_PWRDWN;
 80115c2:	6b83      	ldr	r3, [r0, #56]	; 0x38
 80115c4:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 80115c8:	6383      	str	r3, [r0, #56]	; 0x38
  (void)USB_DevConnect(hpcd->Instance);
 80115ca:	f004 f9bf 	bl	801594c <USB_DevConnect>
  __HAL_PCD_ENABLE(hpcd);
 80115ce:	6820      	ldr	r0, [r4, #0]
 80115d0:	f003 fdf6 	bl	80151c0 <USB_EnableGlobalInt>
  __HAL_UNLOCK(hpcd);
 80115d4:	2000      	movs	r0, #0
 80115d6:	f884 03bc 	strb.w	r0, [r4, #956]	; 0x3bc
}
 80115da:	bd10      	pop	{r4, pc}
  __HAL_LOCK(hpcd);
 80115dc:	2002      	movs	r0, #2
}
 80115de:	bd10      	pop	{r4, pc}

080115e0 <HAL_PCD_Stop>:
{
 80115e0:	b570      	push	{r4, r5, r6, lr}
  __HAL_LOCK(hpcd);
 80115e2:	f890 33bc 	ldrb.w	r3, [r0, #956]	; 0x3bc
 80115e6:	2b01      	cmp	r3, #1
 80115e8:	d018      	beq.n	801161c <HAL_PCD_Stop+0x3c>
 80115ea:	4604      	mov	r4, r0
 80115ec:	2601      	movs	r6, #1
  __HAL_PCD_DISABLE(hpcd);
 80115ee:	6800      	ldr	r0, [r0, #0]
  __HAL_LOCK(hpcd);
 80115f0:	f884 63bc 	strb.w	r6, [r4, #956]	; 0x3bc
  __HAL_PCD_DISABLE(hpcd);
 80115f4:	f003 fdec 	bl	80151d0 <USB_DisableGlobalInt>
  if (USB_StopDevice(hpcd->Instance) != HAL_OK)
 80115f8:	6820      	ldr	r0, [r4, #0]
 80115fa:	f004 f963 	bl	80158c4 <USB_StopDevice>
 80115fe:	4605      	mov	r5, r0
 8011600:	b128      	cbz	r0, 801160e <HAL_PCD_Stop+0x2e>
    __HAL_UNLOCK(hpcd);
 8011602:	2300      	movs	r3, #0
    return HAL_ERROR;
 8011604:	4635      	mov	r5, r6
    __HAL_UNLOCK(hpcd);
 8011606:	f884 33bc 	strb.w	r3, [r4, #956]	; 0x3bc

  return HAL_OK;
}
 801160a:	4628      	mov	r0, r5
 801160c:	bd70      	pop	{r4, r5, r6, pc}
  (void)USB_DevDisconnect(hpcd->Instance);
 801160e:	6820      	ldr	r0, [r4, #0]
 8011610:	f004 f9aa 	bl	8015968 <USB_DevDisconnect>
  __HAL_UNLOCK(hpcd);
 8011614:	f884 53bc 	strb.w	r5, [r4, #956]	; 0x3bc
}
 8011618:	4628      	mov	r0, r5
 801161a:	bd70      	pop	{r4, r5, r6, pc}
  __HAL_LOCK(hpcd);
 801161c:	2502      	movs	r5, #2
}
 801161e:	4628      	mov	r0, r5
 8011620:	bd70      	pop	{r4, r5, r6, pc}
 8011622:	bf00      	nop

08011624 <HAL_PCD_IRQHandler>:
  * @brief  Handles PCD interrupt request.
  * @param  hpcd PCD handle
  * @retval HAL status
  */
void HAL_PCD_IRQHandler(PCD_HandleTypeDef *hpcd)
{
 8011624:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  USB_OTG_GlobalTypeDef *USBx = hpcd->Instance;
 8011628:	f8d0 8000 	ldr.w	r8, [r0]
{
 801162c:	b085      	sub	sp, #20
 801162e:	4604      	mov	r4, r0
  uint32_t i, ep_intr, epint, epnum = 0U;
  uint32_t fifoemptymsk, temp;
  USB_OTG_EPTypeDef *ep;

  /* ensure that we are in device mode */
  if (USB_GetMode(hpcd->Instance) == USB_OTG_MODE_DEVICE)
 8011630:	4640      	mov	r0, r8
 8011632:	f004 f9d5 	bl	80159e0 <USB_GetMode>
 8011636:	b110      	cbz	r0, 801163e <HAL_PCD_IRQHandler+0x1a>
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
      }
      hpcd->Instance->GOTGINT |= temp;
    }
  }
}
 8011638:	b005      	add	sp, #20
 801163a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    if (__HAL_PCD_IS_INVALID_INTERRUPT(hpcd))
 801163e:	4605      	mov	r5, r0
 8011640:	6820      	ldr	r0, [r4, #0]
 8011642:	f004 f99f 	bl	8015984 <USB_ReadInterrupts>
 8011646:	2800      	cmp	r0, #0
 8011648:	d0f6      	beq.n	8011638 <HAL_PCD_IRQHandler+0x14>
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_MMIS))
 801164a:	6820      	ldr	r0, [r4, #0]
 801164c:	f004 f99a 	bl	8015984 <USB_ReadInterrupts>
 8011650:	f010 0f02 	tst.w	r0, #2
      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_MMIS);
 8011654:	6820      	ldr	r0, [r4, #0]
 8011656:	bf1e      	ittt	ne
 8011658:	6943      	ldrne	r3, [r0, #20]
 801165a:	f003 0302 	andne.w	r3, r3, #2
 801165e:	6143      	strne	r3, [r0, #20]
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_OEPINT))
 8011660:	f004 f990 	bl	8015984 <USB_ReadInterrupts>
 8011664:	f410 2b00 	ands.w	fp, r0, #524288	; 0x80000
      ep_intr = USB_ReadDevAllOutEpInterrupt(hpcd->Instance);
 8011668:	6820      	ldr	r0, [r4, #0]
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_OEPINT))
 801166a:	f040 8135 	bne.w	80118d8 <HAL_PCD_IRQHandler+0x2b4>
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_IEPINT))
 801166e:	f004 f989 	bl	8015984 <USB_ReadInterrupts>
 8011672:	f410 2f80 	tst.w	r0, #262144	; 0x40000
      ep_intr = USB_ReadDevAllInEpInterrupt(hpcd->Instance);
 8011676:	6820      	ldr	r0, [r4, #0]
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_IEPINT))
 8011678:	f040 80ec 	bne.w	8011854 <HAL_PCD_IRQHandler+0x230>
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_WKUINT))
 801167c:	f004 f982 	bl	8015984 <USB_ReadInterrupts>
 8011680:	2800      	cmp	r0, #0
 8011682:	db75      	blt.n	8011770 <HAL_PCD_IRQHandler+0x14c>
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_USBSUSP))
 8011684:	6820      	ldr	r0, [r4, #0]
 8011686:	f004 f97d 	bl	8015984 <USB_ReadInterrupts>
 801168a:	0500      	lsls	r0, r0, #20
 801168c:	d465      	bmi.n	801175a <HAL_PCD_IRQHandler+0x136>
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_LPMINT))
 801168e:	6820      	ldr	r0, [r4, #0]
 8011690:	f004 f978 	bl	8015984 <USB_ReadInterrupts>
 8011694:	0102      	lsls	r2, r0, #4
 8011696:	d514      	bpl.n	80116c2 <HAL_PCD_IRQHandler+0x9e>
      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_LPMINT);
 8011698:	6822      	ldr	r2, [r4, #0]
 801169a:	6953      	ldr	r3, [r2, #20]
 801169c:	f003 6300 	and.w	r3, r3, #134217728	; 0x8000000
 80116a0:	6153      	str	r3, [r2, #20]
      if (hpcd->LPM_State == LPM_L0)
 80116a2:	f894 33f4 	ldrb.w	r3, [r4, #1012]	; 0x3f4
 80116a6:	2b00      	cmp	r3, #0
 80116a8:	f040 8175 	bne.w	8011996 <HAL_PCD_IRQHandler+0x372>
        hpcd->LPM_State = LPM_L1;
 80116ac:	2101      	movs	r1, #1
 80116ae:	f884 13f4 	strb.w	r1, [r4, #1012]	; 0x3f4
        hpcd->BESL = (hpcd->Instance->GLPMCFG & USB_OTG_GLPMCFG_BESL) >> 2U;
 80116b2:	6d53      	ldr	r3, [r2, #84]	; 0x54
 80116b4:	f3c3 0383 	ubfx	r3, r3, #2, #4
 80116b8:	f8c4 33f8 	str.w	r3, [r4, #1016]	; 0x3f8
        HAL_PCDEx_LPM_Callback(hpcd, PCD_LPM_L1_ACTIVE);
 80116bc:	4620      	mov	r0, r4
 80116be:	f000 fbfd 	bl	8011ebc <HAL_PCDEx_LPM_Callback>
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_USBRST))
 80116c2:	6820      	ldr	r0, [r4, #0]
 80116c4:	f004 f95e 	bl	8015984 <USB_ReadInterrupts>
 80116c8:	04c3      	lsls	r3, r0, #19
 80116ca:	d47c      	bmi.n	80117c6 <HAL_PCD_IRQHandler+0x1a2>
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_ENUMDNE))
 80116cc:	6820      	ldr	r0, [r4, #0]
 80116ce:	f004 f959 	bl	8015984 <USB_ReadInterrupts>
 80116d2:	f410 5f00 	tst.w	r0, #8192	; 0x2000
      (void)USB_ActivateSetup(hpcd->Instance);
 80116d6:	6820      	ldr	r0, [r4, #0]
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_ENUMDNE))
 80116d8:	d15e      	bne.n	8011798 <HAL_PCD_IRQHandler+0x174>
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_RXFLVL))
 80116da:	f004 f953 	bl	8015984 <USB_ReadInterrupts>
 80116de:	f010 0f10 	tst.w	r0, #16
      USB_MASK_INTERRUPT(hpcd->Instance, USB_OTG_GINTSTS_RXFLVL);
 80116e2:	6820      	ldr	r0, [r4, #0]
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_RXFLVL))
 80116e4:	d013      	beq.n	801170e <HAL_PCD_IRQHandler+0xea>
      USB_MASK_INTERRUPT(hpcd->Instance, USB_OTG_GINTSTS_RXFLVL);
 80116e6:	6983      	ldr	r3, [r0, #24]
 80116e8:	f023 0310 	bic.w	r3, r3, #16
 80116ec:	6183      	str	r3, [r0, #24]
      temp = USBx->GRXSTSP;
 80116ee:	f8d8 5020 	ldr.w	r5, [r8, #32]
      if (((temp & USB_OTG_GRXSTSP_PKTSTS) >> 17) ==  STS_DATA_UPDT)
 80116f2:	f3c5 4343 	ubfx	r3, r5, #17, #4
 80116f6:	2b02      	cmp	r3, #2
      ep = &hpcd->OUT_ep[temp & USB_OTG_GRXSTSP_EPNUM];
 80116f8:	f005 060f 	and.w	r6, r5, #15
      if (((temp & USB_OTG_GRXSTSP_PKTSTS) >> 17) ==  STS_DATA_UPDT)
 80116fc:	f000 8204 	beq.w	8011b08 <HAL_PCD_IRQHandler+0x4e4>
      else if (((temp & USB_OTG_GRXSTSP_PKTSTS) >> 17) ==  STS_SETUP_UPDT)
 8011700:	2b06      	cmp	r3, #6
 8011702:	f000 815e 	beq.w	80119c2 <HAL_PCD_IRQHandler+0x39e>
      USB_UNMASK_INTERRUPT(hpcd->Instance, USB_OTG_GINTSTS_RXFLVL);
 8011706:	6983      	ldr	r3, [r0, #24]
 8011708:	f043 0310 	orr.w	r3, r3, #16
 801170c:	6183      	str	r3, [r0, #24]
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_SOF))
 801170e:	f004 f939 	bl	8015984 <USB_ReadInterrupts>
 8011712:	0707      	lsls	r7, r0, #28
 8011714:	f100 8136 	bmi.w	8011984 <HAL_PCD_IRQHandler+0x360>
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_IISOIXFR))
 8011718:	6820      	ldr	r0, [r4, #0]
 801171a:	f004 f933 	bl	8015984 <USB_ReadInterrupts>
 801171e:	02c6      	lsls	r6, r0, #11
 8011720:	f100 8125 	bmi.w	801196e <HAL_PCD_IRQHandler+0x34a>
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_PXFR_INCOMPISOOUT))
 8011724:	6820      	ldr	r0, [r4, #0]
 8011726:	f004 f92d 	bl	8015984 <USB_ReadInterrupts>
 801172a:	0285      	lsls	r5, r0, #10
 801172c:	f100 8114 	bmi.w	8011958 <HAL_PCD_IRQHandler+0x334>
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_SRQINT))
 8011730:	6820      	ldr	r0, [r4, #0]
 8011732:	f004 f927 	bl	8015984 <USB_ReadInterrupts>
 8011736:	0040      	lsls	r0, r0, #1
 8011738:	f100 8105 	bmi.w	8011946 <HAL_PCD_IRQHandler+0x322>
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_OTGINT))
 801173c:	6820      	ldr	r0, [r4, #0]
 801173e:	f004 f921 	bl	8015984 <USB_ReadInterrupts>
 8011742:	0741      	lsls	r1, r0, #29
 8011744:	f57f af78 	bpl.w	8011638 <HAL_PCD_IRQHandler+0x14>
      temp = hpcd->Instance->GOTGINT;
 8011748:	6823      	ldr	r3, [r4, #0]
 801174a:	685d      	ldr	r5, [r3, #4]
      if ((temp & USB_OTG_GOTGINT_SEDET) == USB_OTG_GOTGINT_SEDET)
 801174c:	076a      	lsls	r2, r5, #29
 801174e:	f100 81fd 	bmi.w	8011b4c <HAL_PCD_IRQHandler+0x528>
      hpcd->Instance->GOTGINT |= temp;
 8011752:	685a      	ldr	r2, [r3, #4]
 8011754:	432a      	orrs	r2, r5
 8011756:	605a      	str	r2, [r3, #4]
 8011758:	e76e      	b.n	8011638 <HAL_PCD_IRQHandler+0x14>
      if ((USBx_DEVICE->DSTS & USB_OTG_DSTS_SUSPSTS) == USB_OTG_DSTS_SUSPSTS)
 801175a:	f8d8 3808 	ldr.w	r3, [r8, #2056]	; 0x808
 801175e:	07d9      	lsls	r1, r3, #31
 8011760:	f100 81f0 	bmi.w	8011b44 <HAL_PCD_IRQHandler+0x520>
      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_USBSUSP);
 8011764:	6820      	ldr	r0, [r4, #0]
 8011766:	6943      	ldr	r3, [r0, #20]
 8011768:	f403 6300 	and.w	r3, r3, #2048	; 0x800
 801176c:	6143      	str	r3, [r0, #20]
 801176e:	e78f      	b.n	8011690 <HAL_PCD_IRQHandler+0x6c>
      USBx_DEVICE->DCTL &= ~USB_OTG_DCTL_RWUSIG;
 8011770:	f8d8 3804 	ldr.w	r3, [r8, #2052]	; 0x804
 8011774:	f023 0301 	bic.w	r3, r3, #1
 8011778:	f8c8 3804 	str.w	r3, [r8, #2052]	; 0x804
      if (hpcd->LPM_State == LPM_L1)
 801177c:	f894 33f4 	ldrb.w	r3, [r4, #1012]	; 0x3f4
 8011780:	2b01      	cmp	r3, #1
 8011782:	f000 8117 	beq.w	80119b4 <HAL_PCD_IRQHandler+0x390>
        HAL_PCD_ResumeCallback(hpcd);
 8011786:	4620      	mov	r0, r4
 8011788:	f013 fa42 	bl	8024c10 <HAL_PCD_ResumeCallback>
      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_WKUINT);
 801178c:	6820      	ldr	r0, [r4, #0]
 801178e:	6943      	ldr	r3, [r0, #20]
 8011790:	f003 4300 	and.w	r3, r3, #2147483648	; 0x80000000
 8011794:	6143      	str	r3, [r0, #20]
 8011796:	e776      	b.n	8011686 <HAL_PCD_IRQHandler+0x62>
      (void)USB_ActivateSetup(hpcd->Instance);
 8011798:	f004 f926 	bl	80159e8 <USB_ActivateSetup>
      hpcd->Init.speed = USB_GetDevSpeed(hpcd->Instance);
 801179c:	6820      	ldr	r0, [r4, #0]
 801179e:	f003 fe13 	bl	80153c8 <USB_GetDevSpeed>
 80117a2:	60e0      	str	r0, [r4, #12]
      (void)USB_SetTurnaroundTime(hpcd->Instance,
 80117a4:	6825      	ldr	r5, [r4, #0]
 80117a6:	f001 fae9 	bl	8012d7c <HAL_RCC_GetHCLKFreq>
 80117aa:	7b22      	ldrb	r2, [r4, #12]
 80117ac:	4601      	mov	r1, r0
 80117ae:	4628      	mov	r0, r5
 80117b0:	f003 fc8c 	bl	80150cc <USB_SetTurnaroundTime>
      HAL_PCD_ResetCallback(hpcd);
 80117b4:	4620      	mov	r0, r4
 80117b6:	f013 fa19 	bl	8024bec <HAL_PCD_ResetCallback>
      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_ENUMDNE);
 80117ba:	6820      	ldr	r0, [r4, #0]
 80117bc:	6943      	ldr	r3, [r0, #20]
 80117be:	f403 5300 	and.w	r3, r3, #8192	; 0x2000
 80117c2:	6143      	str	r3, [r0, #20]
 80117c4:	e789      	b.n	80116da <HAL_PCD_IRQHandler+0xb6>
      USBx_DEVICE->DCTL &= ~USB_OTG_DCTL_RWUSIG;
 80117c6:	f8d8 3804 	ldr.w	r3, [r8, #2052]	; 0x804
      (void)USB_FlushTxFifo(hpcd->Instance, 0x10U);
 80117ca:	6820      	ldr	r0, [r4, #0]
      USBx_DEVICE->DCTL &= ~USB_OTG_DCTL_RWUSIG;
 80117cc:	f023 0301 	bic.w	r3, r3, #1
      (void)USB_FlushTxFifo(hpcd->Instance, 0x10U);
 80117d0:	2110      	movs	r1, #16
      USBx_DEVICE->DCTL &= ~USB_OTG_DCTL_RWUSIG;
 80117d2:	f8c8 3804 	str.w	r3, [r8, #2052]	; 0x804
      (void)USB_FlushTxFifo(hpcd->Instance, 0x10U);
 80117d6:	f003 fdd5 	bl	8015384 <USB_FlushTxFifo>
      for (i = 0U; i < hpcd->Init.dev_endpoints; i++)
 80117da:	6860      	ldr	r0, [r4, #4]
      USBx_DEVICE->DCTL &= ~USB_OTG_DCTL_RWUSIG;
 80117dc:	f508 6600 	add.w	r6, r8, #2048	; 0x800
      for (i = 0U; i < hpcd->Init.dev_endpoints; i++)
 80117e0:	b1a8      	cbz	r0, 801180e <HAL_PCD_IRQHandler+0x1ea>
 80117e2:	f508 6310 	add.w	r3, r8, #2304	; 0x900
        USBx_INEP(i)->DIEPINT = 0xFB7FU;
 80117e6:	f64f 317f 	movw	r1, #64383	; 0xfb7f
 80117ea:	6099      	str	r1, [r3, #8]
        USBx_INEP(i)->DIEPCTL &= ~USB_OTG_DIEPCTL_STALL;
 80117ec:	681a      	ldr	r2, [r3, #0]
 80117ee:	f422 1200 	bic.w	r2, r2, #2097152	; 0x200000
 80117f2:	601a      	str	r2, [r3, #0]
        USBx_OUTEP(i)->DOEPINT = 0xFB7FU;
 80117f4:	f8c3 1208 	str.w	r1, [r3, #520]	; 0x208
        USBx_OUTEP(i)->DOEPCTL &= ~USB_OTG_DOEPCTL_STALL;
 80117f8:	f8d3 2200 	ldr.w	r2, [r3, #512]	; 0x200
      for (i = 0U; i < hpcd->Init.dev_endpoints; i++)
 80117fc:	3501      	adds	r5, #1
        USBx_OUTEP(i)->DOEPCTL &= ~USB_OTG_DOEPCTL_STALL;
 80117fe:	f422 1200 	bic.w	r2, r2, #2097152	; 0x200000
      for (i = 0U; i < hpcd->Init.dev_endpoints; i++)
 8011802:	4285      	cmp	r5, r0
        USBx_OUTEP(i)->DOEPCTL &= ~USB_OTG_DOEPCTL_STALL;
 8011804:	f8c3 2200 	str.w	r2, [r3, #512]	; 0x200
      for (i = 0U; i < hpcd->Init.dev_endpoints; i++)
 8011808:	f103 0320 	add.w	r3, r3, #32
 801180c:	d1ed      	bne.n	80117ea <HAL_PCD_IRQHandler+0x1c6>
      USBx_DEVICE->DAINTMSK |= 0x10001U;
 801180e:	69f3      	ldr	r3, [r6, #28]
 8011810:	f043 1301 	orr.w	r3, r3, #65537	; 0x10001
 8011814:	61f3      	str	r3, [r6, #28]
      if (hpcd->Init.use_dedicated_ep1 != 0U)
 8011816:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8011818:	2b00      	cmp	r3, #0
 801181a:	f040 80c0 	bne.w	801199e <HAL_PCD_IRQHandler+0x37a>
        USBx_DEVICE->DOEPMSK |= USB_OTG_DOEPMSK_STUPM |
 801181e:	6973      	ldr	r3, [r6, #20]
 8011820:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
 8011824:	f043 032b 	orr.w	r3, r3, #43	; 0x2b
 8011828:	6173      	str	r3, [r6, #20]
        USBx_DEVICE->DIEPMSK |= USB_OTG_DIEPMSK_TOM |
 801182a:	6933      	ldr	r3, [r6, #16]
 801182c:	f043 030b 	orr.w	r3, r3, #11
 8011830:	6133      	str	r3, [r6, #16]
      USBx_DEVICE->DCFG &= ~USB_OTG_DCFG_DAD;
 8011832:	f8d8 3800 	ldr.w	r3, [r8, #2048]	; 0x800
      (void)USB_EP0_OutStart(hpcd->Instance, (uint8_t *)hpcd->Setup);
 8011836:	6820      	ldr	r0, [r4, #0]
      USBx_DEVICE->DCFG &= ~USB_OTG_DCFG_DAD;
 8011838:	f423 63fe 	bic.w	r3, r3, #2032	; 0x7f0
 801183c:	f8c8 3800 	str.w	r3, [r8, #2048]	; 0x800
      (void)USB_EP0_OutStart(hpcd->Instance, (uint8_t *)hpcd->Setup);
 8011840:	f504 7171 	add.w	r1, r4, #964	; 0x3c4
 8011844:	f004 f8ec 	bl	8015a20 <USB_EP0_OutStart>
      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_USBRST);
 8011848:	6820      	ldr	r0, [r4, #0]
 801184a:	6943      	ldr	r3, [r0, #20]
 801184c:	f403 5380 	and.w	r3, r3, #4096	; 0x1000
 8011850:	6143      	str	r3, [r0, #20]
 8011852:	e73c      	b.n	80116ce <HAL_PCD_IRQHandler+0xaa>
      ep_intr = USB_ReadDevAllInEpInterrupt(hpcd->Instance);
 8011854:	f004 f8a2 	bl	801599c <USB_ReadDevAllInEpInterrupt>
      while (ep_intr != 0U)
 8011858:	4681      	mov	r9, r0
      epnum = 0U;
 801185a:	46cb      	mov	fp, r9
          epint = USB_ReadDevInEPInterrupt(hpcd->Instance, (uint8_t)epnum);
 801185c:	6820      	ldr	r0, [r4, #0]
      while (ep_intr != 0U)
 801185e:	f1b9 0f00 	cmp.w	r9, #0
 8011862:	f43f af0b 	beq.w	801167c <HAL_PCD_IRQHandler+0x58>
            CLEAR_IN_EP_INTR(epnum, USB_OTG_DIEPINT_INEPNE);
 8011866:	e9cd 8501 	strd	r8, r5, [sp, #4]
 801186a:	4627      	mov	r7, r4
 801186c:	f508 6a10 	add.w	sl, r8, #2304	; 0x900
      epnum = 0U;
 8011870:	f04f 0b00 	mov.w	fp, #0
            CLEAR_IN_EP_INTR(epnum, USB_OTG_DIEPINT_INEPNE);
 8011874:	9400      	str	r4, [sp, #0]
 8011876:	e009      	b.n	801188c <HAL_PCD_IRQHandler+0x268>
      while (ep_intr != 0U)
 8011878:	ea5f 0959 	movs.w	r9, r9, lsr #1
        epnum++;
 801187c:	f10b 0b01 	add.w	fp, fp, #1
      while (ep_intr != 0U)
 8011880:	f107 071c 	add.w	r7, r7, #28
 8011884:	f10a 0a20 	add.w	sl, sl, #32
 8011888:	f000 80ae 	beq.w	80119e8 <HAL_PCD_IRQHandler+0x3c4>
        if ((ep_intr & 0x1U) != 0U) /* In ITR */
 801188c:	f019 0f01 	tst.w	r9, #1
 8011890:	d0f2      	beq.n	8011878 <HAL_PCD_IRQHandler+0x254>
          epint = USB_ReadDevInEPInterrupt(hpcd->Instance, (uint8_t)epnum);
 8011892:	fa5f f48b 	uxtb.w	r4, fp
 8011896:	4621      	mov	r1, r4
 8011898:	f004 f892 	bl	80159c0 <USB_ReadDevInEPInterrupt>
 801189c:	4605      	mov	r5, r0
          if ((epint & USB_OTG_DIEPINT_XFRC) == USB_OTG_DIEPINT_XFRC)
 801189e:	07e8      	lsls	r0, r5, #31
 80118a0:	f100 8115 	bmi.w	8011ace <HAL_PCD_IRQHandler+0x4aa>
          if ((epint & USB_OTG_DIEPINT_TOC) == USB_OTG_DIEPINT_TOC)
 80118a4:	0729      	lsls	r1, r5, #28
            CLEAR_IN_EP_INTR(epnum, USB_OTG_DIEPINT_TOC);
 80118a6:	bf44      	itt	mi
 80118a8:	2308      	movmi	r3, #8
 80118aa:	f8ca 3008 	strmi.w	r3, [sl, #8]
          if ((epint & USB_OTG_DIEPINT_ITTXFE) == USB_OTG_DIEPINT_ITTXFE)
 80118ae:	06ea      	lsls	r2, r5, #27
            CLEAR_IN_EP_INTR(epnum, USB_OTG_DIEPINT_ITTXFE);
 80118b0:	bf44      	itt	mi
 80118b2:	2310      	movmi	r3, #16
 80118b4:	f8ca 3008 	strmi.w	r3, [sl, #8]
          if ((epint & USB_OTG_DIEPINT_INEPNE) == USB_OTG_DIEPINT_INEPNE)
 80118b8:	066b      	lsls	r3, r5, #25
            CLEAR_IN_EP_INTR(epnum, USB_OTG_DIEPINT_INEPNE);
 80118ba:	bf44      	itt	mi
 80118bc:	2340      	movmi	r3, #64	; 0x40
 80118be:	f8ca 3008 	strmi.w	r3, [sl, #8]
          if ((epint & USB_OTG_DIEPINT_EPDISD) == USB_OTG_DIEPINT_EPDISD)
 80118c2:	07ae      	lsls	r6, r5, #30
            CLEAR_IN_EP_INTR(epnum, USB_OTG_DIEPINT_EPDISD);
 80118c4:	bf44      	itt	mi
 80118c6:	2302      	movmi	r3, #2
 80118c8:	f8ca 3008 	strmi.w	r3, [sl, #8]
          if ((epint & USB_OTG_DIEPINT_TXFE) == USB_OTG_DIEPINT_TXFE)
 80118cc:	062d      	lsls	r5, r5, #24
  * @param  epnum endpoint number
  * @retval HAL status
  */
static HAL_StatusTypeDef PCD_WriteEmptyTxFifo(PCD_HandleTypeDef *hpcd, uint32_t epnum)
{
  USB_OTG_GlobalTypeDef *USBx = hpcd->Instance;
 80118ce:	9b00      	ldr	r3, [sp, #0]
          if ((epint & USB_OTG_DIEPINT_TXFE) == USB_OTG_DIEPINT_TXFE)
 80118d0:	f100 80b5 	bmi.w	8011a3e <HAL_PCD_IRQHandler+0x41a>
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_WKUINT))
 80118d4:	6818      	ldr	r0, [r3, #0]
 80118d6:	e7cf      	b.n	8011878 <HAL_PCD_IRQHandler+0x254>
      ep_intr = USB_ReadDevAllOutEpInterrupt(hpcd->Instance);
 80118d8:	f004 f858 	bl	801598c <USB_ReadDevAllOutEpInterrupt>
      while (ep_intr != 0U)
 80118dc:	4606      	mov	r6, r0
      epnum = 0U;
 80118de:	46b3      	mov	fp, r6
          epint = USB_ReadDevOutEPInterrupt(hpcd->Instance, (uint8_t)epnum);
 80118e0:	6820      	ldr	r0, [r4, #0]
      while (ep_intr != 0U)
 80118e2:	2e00      	cmp	r6, #0
 80118e4:	f43f aec3 	beq.w	801166e <HAL_PCD_IRQHandler+0x4a>
  uint32_t USBx_BASE = (uint32_t)USBx;
  uint32_t gSNPSiD = *(__IO uint32_t *)(&USBx->CID + 0x1U);
  uint32_t DoepintReg = USBx_OUTEP(epnum)->DOEPINT;


  if ((gSNPSiD == USB_OTG_CORE_ID_310A) &&
 80118e8:	f8df 927c 	ldr.w	r9, [pc, #636]	; 8011b68 <HAL_PCD_IRQHandler+0x544>
 80118ec:	f508 6730 	add.w	r7, r8, #2816	; 0xb00
      epnum = 0U;
 80118f0:	f04f 0b00 	mov.w	fp, #0
 80118f4:	e006      	b.n	8011904 <HAL_PCD_IRQHandler+0x2e0>
      while (ep_intr != 0U)
 80118f6:	0876      	lsrs	r6, r6, #1
        epnum++;
 80118f8:	f10b 0b01 	add.w	fp, fp, #1
      while (ep_intr != 0U)
 80118fc:	f107 0720 	add.w	r7, r7, #32
 8011900:	f43f aeb5 	beq.w	801166e <HAL_PCD_IRQHandler+0x4a>
        if ((ep_intr & 0x1U) != 0U)
 8011904:	07f1      	lsls	r1, r6, #31
 8011906:	d5f6      	bpl.n	80118f6 <HAL_PCD_IRQHandler+0x2d2>
          epint = USB_ReadDevOutEPInterrupt(hpcd->Instance, (uint8_t)epnum);
 8011908:	fa5f f18b 	uxtb.w	r1, fp
 801190c:	9100      	str	r1, [sp, #0]
 801190e:	f004 f84d 	bl	80159ac <USB_ReadDevOutEPInterrupt>
 8011912:	4682      	mov	sl, r0
          if ((epint & USB_OTG_DOEPINT_XFRC) == USB_OTG_DOEPINT_XFRC)
 8011914:	f01a 0f01 	tst.w	sl, #1
  USB_OTG_GlobalTypeDef *USBx = hpcd->Instance;
 8011918:	6820      	ldr	r0, [r4, #0]
          if ((epint & USB_OTG_DOEPINT_XFRC) == USB_OTG_DOEPINT_XFRC)
 801191a:	9900      	ldr	r1, [sp, #0]
 801191c:	d17d      	bne.n	8011a1a <HAL_PCD_IRQHandler+0x3f6>
          if ((epint & USB_OTG_DOEPINT_STUP) == USB_OTG_DOEPINT_STUP)
 801191e:	f01a 0f08 	tst.w	sl, #8
 8011922:	d165      	bne.n	80119f0 <HAL_PCD_IRQHandler+0x3cc>
          if ((epint & USB_OTG_DOEPINT_OTEPDIS) == USB_OTG_DOEPINT_OTEPDIS)
 8011924:	f01a 0f10 	tst.w	sl, #16
            CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_OTEPDIS);
 8011928:	bf1c      	itt	ne
 801192a:	2310      	movne	r3, #16
 801192c:	60bb      	strne	r3, [r7, #8]
          if ((epint & USB_OTG_DOEPINT_OTEPSPR) == USB_OTG_DOEPINT_OTEPSPR)
 801192e:	f01a 0f20 	tst.w	sl, #32
            CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_OTEPSPR);
 8011932:	bf1c      	itt	ne
 8011934:	2320      	movne	r3, #32
 8011936:	60bb      	strne	r3, [r7, #8]
          if ((epint & USB_OTG_DOEPINT_NAK) == USB_OTG_DOEPINT_NAK)
 8011938:	f41a 5f00 	tst.w	sl, #8192	; 0x2000
            CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_NAK);
 801193c:	bf1c      	itt	ne
 801193e:	f44f 5300 	movne.w	r3, #8192	; 0x2000
 8011942:	60bb      	strne	r3, [r7, #8]
 8011944:	e7d7      	b.n	80118f6 <HAL_PCD_IRQHandler+0x2d2>
      HAL_PCD_ConnectCallback(hpcd);
 8011946:	4620      	mov	r0, r4
 8011948:	f013 f96e 	bl	8024c28 <HAL_PCD_ConnectCallback>
      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_SRQINT);
 801194c:	6820      	ldr	r0, [r4, #0]
 801194e:	6943      	ldr	r3, [r0, #20]
 8011950:	f003 4380 	and.w	r3, r3, #1073741824	; 0x40000000
 8011954:	6143      	str	r3, [r0, #20]
 8011956:	e6f2      	b.n	801173e <HAL_PCD_IRQHandler+0x11a>
      HAL_PCD_ISOOUTIncompleteCallback(hpcd, (uint8_t)epnum);
 8011958:	4620      	mov	r0, r4
 801195a:	fa5f f18b 	uxtb.w	r1, fp
 801195e:	f013 f95b 	bl	8024c18 <HAL_PCD_ISOOUTIncompleteCallback>
      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_PXFR_INCOMPISOOUT);
 8011962:	6820      	ldr	r0, [r4, #0]
 8011964:	6943      	ldr	r3, [r0, #20]
 8011966:	f403 1300 	and.w	r3, r3, #2097152	; 0x200000
 801196a:	6143      	str	r3, [r0, #20]
 801196c:	e6e1      	b.n	8011732 <HAL_PCD_IRQHandler+0x10e>
      HAL_PCD_ISOINIncompleteCallback(hpcd, (uint8_t)epnum);
 801196e:	4620      	mov	r0, r4
 8011970:	fa5f f18b 	uxtb.w	r1, fp
 8011974:	f013 f954 	bl	8024c20 <HAL_PCD_ISOINIncompleteCallback>
      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_IISOIXFR);
 8011978:	6820      	ldr	r0, [r4, #0]
 801197a:	6943      	ldr	r3, [r0, #20]
 801197c:	f403 1380 	and.w	r3, r3, #1048576	; 0x100000
 8011980:	6143      	str	r3, [r0, #20]
 8011982:	e6d0      	b.n	8011726 <HAL_PCD_IRQHandler+0x102>
      HAL_PCD_SOFCallback(hpcd);
 8011984:	4620      	mov	r0, r4
 8011986:	f013 f92d 	bl	8024be4 <HAL_PCD_SOFCallback>
      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_SOF);
 801198a:	6820      	ldr	r0, [r4, #0]
 801198c:	6943      	ldr	r3, [r0, #20]
 801198e:	f003 0308 	and.w	r3, r3, #8
 8011992:	6143      	str	r3, [r0, #20]
 8011994:	e6c1      	b.n	801171a <HAL_PCD_IRQHandler+0xf6>
        HAL_PCD_SuspendCallback(hpcd);
 8011996:	4620      	mov	r0, r4
 8011998:	f013 f936 	bl	8024c08 <HAL_PCD_SuspendCallback>
 801199c:	e691      	b.n	80116c2 <HAL_PCD_IRQHandler+0x9e>
        USBx_DEVICE->DOUTEP1MSK |= USB_OTG_DOEPMSK_STUPM |
 801199e:	f8d6 3084 	ldr.w	r3, [r6, #132]	; 0x84
 80119a2:	f043 030b 	orr.w	r3, r3, #11
 80119a6:	f8c6 3084 	str.w	r3, [r6, #132]	; 0x84
        USBx_DEVICE->DINEP1MSK |= USB_OTG_DIEPMSK_TOM |
 80119aa:	6c73      	ldr	r3, [r6, #68]	; 0x44
 80119ac:	f043 030b 	orr.w	r3, r3, #11
 80119b0:	6473      	str	r3, [r6, #68]	; 0x44
 80119b2:	e73e      	b.n	8011832 <HAL_PCD_IRQHandler+0x20e>
        hpcd->LPM_State = LPM_L0;
 80119b4:	2100      	movs	r1, #0
 80119b6:	f884 13f4 	strb.w	r1, [r4, #1012]	; 0x3f4
        HAL_PCDEx_LPM_Callback(hpcd, PCD_LPM_L0_ACTIVE);
 80119ba:	4620      	mov	r0, r4
 80119bc:	f000 fa7e 	bl	8011ebc <HAL_PCDEx_LPM_Callback>
 80119c0:	e6e4      	b.n	801178c <HAL_PCD_IRQHandler+0x168>
        (void)USB_ReadPacket(USBx, (uint8_t *)hpcd->Setup, 8U);
 80119c2:	2208      	movs	r2, #8
 80119c4:	f504 7171 	add.w	r1, r4, #964	; 0x3c4
 80119c8:	4640      	mov	r0, r8
        ep->xfer_count += (temp & USB_OTG_GRXSTSP_BCNT) >> 4;
 80119ca:	ebc6 06c6 	rsb	r6, r6, r6, lsl #3
        (void)USB_ReadPacket(USBx, (uint8_t *)hpcd->Setup, 8U);
 80119ce:	f003 ff0f 	bl	80157f0 <USB_ReadPacket>
        ep->xfer_count += (temp & USB_OTG_GRXSTSP_BCNT) >> 4;
 80119d2:	eb04 0286 	add.w	r2, r4, r6, lsl #2
 80119d6:	f3c5 130a 	ubfx	r3, r5, #4, #11
 80119da:	f8d2 1214 	ldr.w	r1, [r2, #532]	; 0x214
      USB_UNMASK_INTERRUPT(hpcd->Instance, USB_OTG_GINTSTS_RXFLVL);
 80119de:	6820      	ldr	r0, [r4, #0]
        ep->xfer_count += (temp & USB_OTG_GRXSTSP_BCNT) >> 4;
 80119e0:	440b      	add	r3, r1
 80119e2:	f8c2 3214 	str.w	r3, [r2, #532]	; 0x214
 80119e6:	e68e      	b.n	8011706 <HAL_PCD_IRQHandler+0xe2>
 80119e8:	e9dd 8501 	ldrd	r8, r5, [sp, #4]
 80119ec:	9c00      	ldr	r4, [sp, #0]
 80119ee:	e645      	b.n	801167c <HAL_PCD_IRQHandler+0x58>
  uint32_t gSNPSiD = *(__IO uint32_t *)(&USBx->CID + 0x1U);
 80119f0:	6c02      	ldr	r2, [r0, #64]	; 0x40
  uint32_t DoepintReg = USBx_OUTEP(epnum)->DOEPINT;
 80119f2:	eb00 134b 	add.w	r3, r0, fp, lsl #5
  if ((gSNPSiD == USB_OTG_CORE_ID_310A) &&
 80119f6:	454a      	cmp	r2, r9
  uint32_t DoepintReg = USBx_OUTEP(epnum)->DOEPINT;
 80119f8:	f8d3 1b08 	ldr.w	r1, [r3, #2824]	; 0xb08
 80119fc:	f503 6330 	add.w	r3, r3, #2816	; 0xb00
  if ((gSNPSiD == USB_OTG_CORE_ID_310A) &&
 8011a00:	d104      	bne.n	8011a0c <HAL_PCD_IRQHandler+0x3e8>
 8011a02:	040a      	lsls	r2, r1, #16
      ((DoepintReg & USB_OTG_DOEPINT_STPKTRX) == USB_OTG_DOEPINT_STPKTRX))
  {
    CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_STPKTRX);
 8011a04:	bf44      	itt	mi
 8011a06:	f44f 4200 	movmi.w	r2, #32768	; 0x8000
 8011a0a:	609a      	strmi	r2, [r3, #8]

  /* Inform the upper layer that a setup packet is available */
#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
  hpcd->SetupStageCallback(hpcd);
#else
  HAL_PCD_SetupStageCallback(hpcd);
 8011a0c:	4620      	mov	r0, r4
 8011a0e:	f013 f8cf 	bl	8024bb0 <HAL_PCD_SetupStageCallback>
            CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_STUP);
 8011a12:	2308      	movs	r3, #8
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_IEPINT))
 8011a14:	6820      	ldr	r0, [r4, #0]
            CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_STUP);
 8011a16:	60bb      	str	r3, [r7, #8]
 8011a18:	e784      	b.n	8011924 <HAL_PCD_IRQHandler+0x300>
            CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_XFRC);
 8011a1a:	2301      	movs	r3, #1
 8011a1c:	60bb      	str	r3, [r7, #8]
  uint32_t gSNPSiD = *(__IO uint32_t *)(&USBx->CID + 0x1U);
 8011a1e:	6c02      	ldr	r2, [r0, #64]	; 0x40
  uint32_t DoepintReg = USBx_OUTEP(epnum)->DOEPINT;
 8011a20:	f500 6330 	add.w	r3, r0, #2816	; 0xb00
 8011a24:	eb03 134b 	add.w	r3, r3, fp, lsl #5
  if (gSNPSiD == USB_OTG_CORE_ID_310A)
 8011a28:	454a      	cmp	r2, r9
  uint32_t DoepintReg = USBx_OUTEP(epnum)->DOEPINT;
 8011a2a:	f8d3 c008 	ldr.w	ip, [r3, #8]
  if (gSNPSiD == USB_OTG_CORE_ID_310A)
 8011a2e:	d166      	bne.n	8011afe <HAL_PCD_IRQHandler+0x4da>
    if ((DoepintReg & USB_OTG_DOEPINT_STPKTRX) == USB_OTG_DOEPINT_STPKTRX)
 8011a30:	f41c 4f00 	tst.w	ip, #32768	; 0x8000
 8011a34:	d05e      	beq.n	8011af4 <HAL_PCD_IRQHandler+0x4d0>
      CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_STPKTRX);
 8011a36:	f44f 4200 	mov.w	r2, #32768	; 0x8000
 8011a3a:	609a      	str	r2, [r3, #8]
 8011a3c:	e76f      	b.n	801191e <HAL_PCD_IRQHandler+0x2fa>
  USB_OTG_GlobalTypeDef *USBx = hpcd->Instance;
 8011a3e:	681e      	ldr	r6, [r3, #0]
  if (ep->xfer_count > ep->xfer_len)
 8011a40:	e9d7 5314 	ldrd	r5, r3, [r7, #80]	; 0x50
 8011a44:	42ab      	cmp	r3, r5
  USB_OTG_GlobalTypeDef *USBx = hpcd->Instance;
 8011a46:	4630      	mov	r0, r6
  if (ep->xfer_count > ep->xfer_len)
 8011a48:	f63f af16 	bhi.w	8011878 <HAL_PCD_IRQHandler+0x254>
  while (((USBx_INEP(epnum)->DTXFSTS & USB_OTG_DTXFSTS_INEPTFSAV) >= len32b) &&
 8011a4c:	f506 6810 	add.w	r8, r6, #2304	; 0x900
  len32b = (len + 3U) / 4U;
 8011a50:	6c79      	ldr	r1, [r7, #68]	; 0x44
  uint32_t USBx_BASE = (uint32_t)USBx;
 8011a52:	9603      	str	r6, [sp, #12]
  while (((USBx_INEP(epnum)->DTXFSTS & USB_OTG_DTXFSTS_INEPTFSAV) >= len32b) &&
 8011a54:	eb08 184b 	add.w	r8, r8, fp, lsl #5
  len = ep->xfer_len - ep->xfer_count;
 8011a58:	eba5 0c03 	sub.w	ip, r5, r3
  len32b = (len + 3U) / 4U;
 8011a5c:	4561      	cmp	r1, ip
  while (((USBx_INEP(epnum)->DTXFSTS & USB_OTG_DTXFSTS_INEPTFSAV) >= len32b) &&
 8011a5e:	f8d8 e018 	ldr.w	lr, [r8, #24]
  len32b = (len + 3U) / 4U;
 8011a62:	bf28      	it	cs
 8011a64:	4661      	movcs	r1, ip
  while (((USBx_INEP(epnum)->DTXFSTS & USB_OTG_DTXFSTS_INEPTFSAV) >= len32b) &&
 8011a66:	fa1f fe8e 	uxth.w	lr, lr
  len32b = (len + 3U) / 4U;
 8011a6a:	3103      	adds	r1, #3
  while (((USBx_INEP(epnum)->DTXFSTS & USB_OTG_DTXFSTS_INEPTFSAV) >= len32b) &&
 8011a6c:	ebbe 0f91 	cmp.w	lr, r1, lsr #2
 8011a70:	d218      	bcs.n	8011aa4 <HAL_PCD_IRQHandler+0x480>
 8011a72:	e074      	b.n	8011b5e <HAL_PCD_IRQHandler+0x53a>
 8011a74:	6c7b      	ldr	r3, [r7, #68]	; 0x44
    (void)USB_WritePacket(USBx, ep->xfer_buff, (uint8_t)epnum, (uint16_t)len);
 8011a76:	6cb9      	ldr	r1, [r7, #72]	; 0x48
 8011a78:	429d      	cmp	r5, r3
 8011a7a:	bf28      	it	cs
 8011a7c:	461d      	movcs	r5, r3
 8011a7e:	b2ab      	uxth	r3, r5
 8011a80:	4622      	mov	r2, r4
 8011a82:	4630      	mov	r0, r6
 8011a84:	f003 fea4 	bl	80157d0 <USB_WritePacket>
    ep->xfer_buff  += len;
 8011a88:	6cbb      	ldr	r3, [r7, #72]	; 0x48
  while (((USBx_INEP(epnum)->DTXFSTS & USB_OTG_DTXFSTS_INEPTFSAV) >= len32b) &&
 8011a8a:	f8d8 2018 	ldr.w	r2, [r8, #24]
    ep->xfer_buff  += len;
 8011a8e:	442b      	add	r3, r5
 8011a90:	64bb      	str	r3, [r7, #72]	; 0x48
    ep->xfer_count += len;
 8011a92:	6d7b      	ldr	r3, [r7, #84]	; 0x54
  while (((USBx_INEP(epnum)->DTXFSTS & USB_OTG_DTXFSTS_INEPTFSAV) >= len32b) &&
 8011a94:	b292      	uxth	r2, r2
    ep->xfer_count += len;
 8011a96:	442b      	add	r3, r5
    len32b = (len + 3U) / 4U;
 8011a98:	3503      	adds	r5, #3
  while (((USBx_INEP(epnum)->DTXFSTS & USB_OTG_DTXFSTS_INEPTFSAV) >= len32b) &&
 8011a9a:	ebb2 0f95 	cmp.w	r2, r5, lsr #2
    ep->xfer_count += len;
 8011a9e:	657b      	str	r3, [r7, #84]	; 0x54
  while (((USBx_INEP(epnum)->DTXFSTS & USB_OTG_DTXFSTS_INEPTFSAV) >= len32b) &&
 8011aa0:	d359      	bcc.n	8011b56 <HAL_PCD_IRQHandler+0x532>
         (ep->xfer_count < ep->xfer_len) && (ep->xfer_len != 0U))
 8011aa2:	6d3d      	ldr	r5, [r7, #80]	; 0x50
 8011aa4:	429d      	cmp	r5, r3
    len = ep->xfer_len - ep->xfer_count;
 8011aa6:	eba5 0503 	sub.w	r5, r5, r3
         (ep->xfer_count < ep->xfer_len) && (ep->xfer_len != 0U))
 8011aaa:	d8e3      	bhi.n	8011a74 <HAL_PCD_IRQHandler+0x450>
 8011aac:	9b00      	ldr	r3, [sp, #0]
 8011aae:	681e      	ldr	r6, [r3, #0]
    USBx_DEVICE->DIEPEMPMSK &= ~fifoemptymsk;
 8011ab0:	9b03      	ldr	r3, [sp, #12]
    fifoemptymsk = (uint32_t)(0x1UL << (epnum & EP_ADDR_MSK));
 8011ab2:	f00b 020f 	and.w	r2, fp, #15
    USBx_DEVICE->DIEPEMPMSK &= ~fifoemptymsk;
 8011ab6:	f503 6100 	add.w	r1, r3, #2048	; 0x800
    fifoemptymsk = (uint32_t)(0x1UL << (epnum & EP_ADDR_MSK));
 8011aba:	2401      	movs	r4, #1
    USBx_DEVICE->DIEPEMPMSK &= ~fifoemptymsk;
 8011abc:	f8d3 3834 	ldr.w	r3, [r3, #2100]	; 0x834
    fifoemptymsk = (uint32_t)(0x1UL << (epnum & EP_ADDR_MSK));
 8011ac0:	fa04 f202 	lsl.w	r2, r4, r2
    USBx_DEVICE->DIEPEMPMSK &= ~fifoemptymsk;
 8011ac4:	ea23 0302 	bic.w	r3, r3, r2
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_WKUINT))
 8011ac8:	4630      	mov	r0, r6
    USBx_DEVICE->DIEPEMPMSK &= ~fifoemptymsk;
 8011aca:	634b      	str	r3, [r1, #52]	; 0x34
 8011acc:	e6d4      	b.n	8011878 <HAL_PCD_IRQHandler+0x254>
            USBx_DEVICE->DIEPEMPMSK &= ~fifoemptymsk;
 8011ace:	9a01      	ldr	r2, [sp, #4]
            fifoemptymsk = (uint32_t)(0x1UL << (epnum & EP_ADDR_MSK));
 8011ad0:	2001      	movs	r0, #1
            USBx_DEVICE->DIEPEMPMSK &= ~fifoemptymsk;
 8011ad2:	f8d2 3834 	ldr.w	r3, [r2, #2100]	; 0x834
            fifoemptymsk = (uint32_t)(0x1UL << (epnum & EP_ADDR_MSK));
 8011ad6:	f00b 010f 	and.w	r1, fp, #15
 8011ada:	fa00 f101 	lsl.w	r1, r0, r1
            USBx_DEVICE->DIEPEMPMSK &= ~fifoemptymsk;
 8011ade:	ea23 0301 	bic.w	r3, r3, r1
 8011ae2:	f8c2 3834 	str.w	r3, [r2, #2100]	; 0x834
            HAL_PCD_DataInStageCallback(hpcd, (uint8_t)epnum);
 8011ae6:	4621      	mov	r1, r4
            CLEAR_IN_EP_INTR(epnum, USB_OTG_DIEPINT_XFRC);
 8011ae8:	f8ca 0008 	str.w	r0, [sl, #8]
            HAL_PCD_DataInStageCallback(hpcd, (uint8_t)epnum);
 8011aec:	9800      	ldr	r0, [sp, #0]
 8011aee:	f013 f86f 	bl	8024bd0 <HAL_PCD_DataInStageCallback>
 8011af2:	e6d7      	b.n	80118a4 <HAL_PCD_IRQHandler+0x280>
      if ((DoepintReg & USB_OTG_DOEPINT_OTEPSPR) == USB_OTG_DOEPINT_OTEPSPR)
 8011af4:	f01c 0f20 	tst.w	ip, #32
        CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_OTEPSPR);
 8011af8:	bf1c      	itt	ne
 8011afa:	2220      	movne	r2, #32
 8011afc:	609a      	strne	r2, [r3, #8]
    HAL_PCD_DataOutStageCallback(hpcd, (uint8_t)epnum);
 8011afe:	4620      	mov	r0, r4
 8011b00:	f013 f85c 	bl	8024bbc <HAL_PCD_DataOutStageCallback>
  USB_OTG_GlobalTypeDef *USBx = hpcd->Instance;
 8011b04:	6820      	ldr	r0, [r4, #0]
 8011b06:	e70a      	b.n	801191e <HAL_PCD_IRQHandler+0x2fa>
        if ((temp & USB_OTG_GRXSTSP_BCNT) != 0U)
 8011b08:	f647 73f0 	movw	r3, #32752	; 0x7ff0
 8011b0c:	421d      	tst	r5, r3
 8011b0e:	f43f adfa 	beq.w	8011706 <HAL_PCD_IRQHandler+0xe2>
          (void)USB_ReadPacket(USBx, ep->xfer_buff,
 8011b12:	ebc6 06c6 	rsb	r6, r6, r6, lsl #3
 8011b16:	eb04 0686 	add.w	r6, r4, r6, lsl #2
 8011b1a:	f3c5 120a 	ubfx	r2, r5, #4, #11
 8011b1e:	f8d6 1208 	ldr.w	r1, [r6, #520]	; 0x208
 8011b22:	4640      	mov	r0, r8
 8011b24:	f003 fe64 	bl	80157f0 <USB_ReadPacket>
          ep->xfer_buff += (temp & USB_OTG_GRXSTSP_BCNT) >> 4;
 8011b28:	f8d6 2208 	ldr.w	r2, [r6, #520]	; 0x208
      USB_UNMASK_INTERRUPT(hpcd->Instance, USB_OTG_GINTSTS_RXFLVL);
 8011b2c:	6820      	ldr	r0, [r4, #0]
          (void)USB_ReadPacket(USBx, ep->xfer_buff,
 8011b2e:	f3c5 130a 	ubfx	r3, r5, #4, #11
          ep->xfer_buff += (temp & USB_OTG_GRXSTSP_BCNT) >> 4;
 8011b32:	441a      	add	r2, r3
 8011b34:	f8c6 2208 	str.w	r2, [r6, #520]	; 0x208
          ep->xfer_count += (temp & USB_OTG_GRXSTSP_BCNT) >> 4;
 8011b38:	f8d6 2214 	ldr.w	r2, [r6, #532]	; 0x214
 8011b3c:	441a      	add	r2, r3
 8011b3e:	f8c6 2214 	str.w	r2, [r6, #532]	; 0x214
 8011b42:	e5e0      	b.n	8011706 <HAL_PCD_IRQHandler+0xe2>
        HAL_PCD_SuspendCallback(hpcd);
 8011b44:	4620      	mov	r0, r4
 8011b46:	f013 f85f 	bl	8024c08 <HAL_PCD_SuspendCallback>
 8011b4a:	e60b      	b.n	8011764 <HAL_PCD_IRQHandler+0x140>
        HAL_PCD_DisconnectCallback(hpcd);
 8011b4c:	4620      	mov	r0, r4
 8011b4e:	f013 f86f 	bl	8024c30 <HAL_PCD_DisconnectCallback>
      hpcd->Instance->GOTGINT |= temp;
 8011b52:	6823      	ldr	r3, [r4, #0]
 8011b54:	e5fd      	b.n	8011752 <HAL_PCD_IRQHandler+0x12e>
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_WKUINT))
 8011b56:	9a00      	ldr	r2, [sp, #0]
  if (ep->xfer_len <= ep->xfer_count)
 8011b58:	6d3d      	ldr	r5, [r7, #80]	; 0x50
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_WKUINT))
 8011b5a:	6816      	ldr	r6, [r2, #0]
 8011b5c:	4630      	mov	r0, r6
  if (ep->xfer_len <= ep->xfer_count)
 8011b5e:	42ab      	cmp	r3, r5
 8011b60:	f4ff ae8a 	bcc.w	8011878 <HAL_PCD_IRQHandler+0x254>
 8011b64:	e7a4      	b.n	8011ab0 <HAL_PCD_IRQHandler+0x48c>
 8011b66:	bf00      	nop
 8011b68:	4f54310a 	.word	0x4f54310a

08011b6c <HAL_PCD_SetAddress>:
  __HAL_LOCK(hpcd);
 8011b6c:	f890 23bc 	ldrb.w	r2, [r0, #956]	; 0x3bc
 8011b70:	2a01      	cmp	r2, #1
 8011b72:	d00d      	beq.n	8011b90 <HAL_PCD_SetAddress+0x24>
{
 8011b74:	b510      	push	{r4, lr}
 8011b76:	4604      	mov	r4, r0
  __HAL_LOCK(hpcd);
 8011b78:	2201      	movs	r2, #1
  (void)USB_SetDevAddress(hpcd->Instance, address);
 8011b7a:	6800      	ldr	r0, [r0, #0]
  __HAL_LOCK(hpcd);
 8011b7c:	f884 23bc 	strb.w	r2, [r4, #956]	; 0x3bc
  hpcd->USB_Address = address;
 8011b80:	f884 1038 	strb.w	r1, [r4, #56]	; 0x38
  (void)USB_SetDevAddress(hpcd->Instance, address);
 8011b84:	f003 fed2 	bl	801592c <USB_SetDevAddress>
  __HAL_UNLOCK(hpcd);
 8011b88:	2000      	movs	r0, #0
 8011b8a:	f884 03bc 	strb.w	r0, [r4, #956]	; 0x3bc
}
 8011b8e:	bd10      	pop	{r4, pc}
  __HAL_LOCK(hpcd);
 8011b90:	2002      	movs	r0, #2
}
 8011b92:	4770      	bx	lr

08011b94 <HAL_PCD_EP_Open>:
{
 8011b94:	b510      	push	{r4, lr}
 8011b96:	f001 0e0f 	and.w	lr, r1, #15
  if ((ep_addr & 0x80U) == 0x80U)
 8011b9a:	0609      	lsls	r1, r1, #24
{
 8011b9c:	4604      	mov	r4, r0
  if ((ep_addr & 0x80U) == 0x80U)
 8011b9e:	d427      	bmi.n	8011bf0 <HAL_PCD_EP_Open+0x5c>
    ep = &hpcd->OUT_ep[ep_addr & EP_ADDR_MSK];
 8011ba0:	f04f 0c1c 	mov.w	ip, #28
 8011ba4:	fb0c 0c0e 	mla	ip, ip, lr, r0
 8011ba8:	f50c 71fe 	add.w	r1, ip, #508	; 0x1fc
    ep->is_in = 0U;
 8011bac:	ebce 0cce 	rsb	ip, lr, lr, lsl #3
 8011bb0:	eb00 0c8c 	add.w	ip, r0, ip, lsl #2
 8011bb4:	2000      	movs	r0, #0
 8011bb6:	f88c 01fd 	strb.w	r0, [ip, #509]	; 0x1fd
  ep->maxpacket = ep_mps;
 8011bba:	608a      	str	r2, [r1, #8]
  if (ep->is_in != 0U)
 8011bbc:	784a      	ldrb	r2, [r1, #1]
  ep->num = ep_addr & EP_ADDR_MSK;
 8011bbe:	f881 e000 	strb.w	lr, [r1]
  ep->type = ep_type;
 8011bc2:	70cb      	strb	r3, [r1, #3]
  if (ep->is_in != 0U)
 8011bc4:	b10a      	cbz	r2, 8011bca <HAL_PCD_EP_Open+0x36>
    ep->tx_fifo_num = ep->num;
 8011bc6:	f8a1 e006 	strh.w	lr, [r1, #6]
  if (ep_type == EP_TYPE_BULK)
 8011bca:	2b02      	cmp	r3, #2
    ep->data_pid_start = 0U;
 8011bcc:	bf04      	itt	eq
 8011bce:	2300      	moveq	r3, #0
 8011bd0:	710b      	strbeq	r3, [r1, #4]
  __HAL_LOCK(hpcd);
 8011bd2:	f894 33bc 	ldrb.w	r3, [r4, #956]	; 0x3bc
 8011bd6:	2b01      	cmp	r3, #1
 8011bd8:	d018      	beq.n	8011c0c <HAL_PCD_EP_Open+0x78>
 8011bda:	2301      	movs	r3, #1
 8011bdc:	f884 33bc 	strb.w	r3, [r4, #956]	; 0x3bc
  (void)USB_ActivateEndpoint(hpcd->Instance, ep);
 8011be0:	6820      	ldr	r0, [r4, #0]
 8011be2:	f003 fbfb 	bl	80153dc <USB_ActivateEndpoint>
  __HAL_UNLOCK(hpcd);
 8011be6:	2300      	movs	r3, #0
 8011be8:	f884 33bc 	strb.w	r3, [r4, #956]	; 0x3bc
  return ret;
 8011bec:	4618      	mov	r0, r3
}
 8011bee:	bd10      	pop	{r4, pc}
    ep = &hpcd->IN_ep[ep_addr & EP_ADDR_MSK];
 8011bf0:	201c      	movs	r0, #28
 8011bf2:	fb00 400e 	mla	r0, r0, lr, r4
 8011bf6:	f100 013c 	add.w	r1, r0, #60	; 0x3c
    ep->is_in = 1U;
 8011bfa:	ebce 00ce 	rsb	r0, lr, lr, lsl #3
 8011bfe:	eb04 0080 	add.w	r0, r4, r0, lsl #2
 8011c02:	f04f 0c01 	mov.w	ip, #1
 8011c06:	f880 c03d 	strb.w	ip, [r0, #61]	; 0x3d
 8011c0a:	e7d6      	b.n	8011bba <HAL_PCD_EP_Open+0x26>
  __HAL_LOCK(hpcd);
 8011c0c:	2002      	movs	r0, #2
}
 8011c0e:	bd10      	pop	{r4, pc}

08011c10 <HAL_PCD_EP_Close>:
  if ((ep_addr & 0x80U) == 0x80U)
 8011c10:	f001 030f 	and.w	r3, r1, #15
    ep->is_in = 1U;
 8011c14:	ebc3 02c3 	rsb	r2, r3, r3, lsl #3
  if ((ep_addr & 0x80U) == 0x80U)
 8011c18:	f011 0f80 	tst.w	r1, #128	; 0x80
    ep = &hpcd->IN_ep[ep_addr & EP_ADDR_MSK];
 8011c1c:	f04f 011c 	mov.w	r1, #28
{
 8011c20:	b510      	push	{r4, lr}
    ep->is_in = 1U;
 8011c22:	eb00 0282 	add.w	r2, r0, r2, lsl #2
{
 8011c26:	4604      	mov	r4, r0
    ep = &hpcd->IN_ep[ep_addr & EP_ADDR_MSK];
 8011c28:	fb01 0103 	mla	r1, r1, r3, r0
  if ((ep_addr & 0x80U) == 0x80U)
 8011c2c:	d113      	bne.n	8011c56 <HAL_PCD_EP_Close+0x46>
    ep = &hpcd->OUT_ep[ep_addr & EP_ADDR_MSK];
 8011c2e:	f501 71fe 	add.w	r1, r1, #508	; 0x1fc
    ep->is_in = 0U;
 8011c32:	2000      	movs	r0, #0
 8011c34:	f882 01fd 	strb.w	r0, [r2, #509]	; 0x1fd
  ep->num   = ep_addr & EP_ADDR_MSK;
 8011c38:	700b      	strb	r3, [r1, #0]
  __HAL_LOCK(hpcd);
 8011c3a:	f894 33bc 	ldrb.w	r3, [r4, #956]	; 0x3bc
 8011c3e:	2b01      	cmp	r3, #1
 8011c40:	d012      	beq.n	8011c68 <HAL_PCD_EP_Close+0x58>
 8011c42:	2301      	movs	r3, #1
  (void)USB_DeactivateEndpoint(hpcd->Instance, ep);
 8011c44:	6820      	ldr	r0, [r4, #0]
  __HAL_LOCK(hpcd);
 8011c46:	f884 33bc 	strb.w	r3, [r4, #956]	; 0x3bc
  (void)USB_DeactivateEndpoint(hpcd->Instance, ep);
 8011c4a:	f003 fc13 	bl	8015474 <USB_DeactivateEndpoint>
  __HAL_UNLOCK(hpcd);
 8011c4e:	2000      	movs	r0, #0
 8011c50:	f884 03bc 	strb.w	r0, [r4, #956]	; 0x3bc
}
 8011c54:	bd10      	pop	{r4, pc}
    ep = &hpcd->IN_ep[ep_addr & EP_ADDR_MSK];
 8011c56:	313c      	adds	r1, #60	; 0x3c
    ep->is_in = 1U;
 8011c58:	2001      	movs	r0, #1
 8011c5a:	f882 003d 	strb.w	r0, [r2, #61]	; 0x3d
  ep->num   = ep_addr & EP_ADDR_MSK;
 8011c5e:	700b      	strb	r3, [r1, #0]
  __HAL_LOCK(hpcd);
 8011c60:	f894 33bc 	ldrb.w	r3, [r4, #956]	; 0x3bc
 8011c64:	2b01      	cmp	r3, #1
 8011c66:	d1ec      	bne.n	8011c42 <HAL_PCD_EP_Close+0x32>
 8011c68:	2002      	movs	r0, #2
}
 8011c6a:	bd10      	pop	{r4, pc}

08011c6c <HAL_PCD_EP_Receive>:
{
 8011c6c:	b510      	push	{r4, lr}
 8011c6e:	f001 040f 	and.w	r4, r1, #15
  ep->xfer_buff = pBuf;
 8011c72:	ebc4 0cc4 	rsb	ip, r4, r4, lsl #3
 8011c76:	eb00 0c8c 	add.w	ip, r0, ip, lsl #2
  ep = &hpcd->OUT_ep[ep_addr & EP_ADDR_MSK];
 8011c7a:	211c      	movs	r1, #28
 8011c7c:	fb01 0104 	mla	r1, r1, r4, r0
  ep->xfer_len = len;
 8011c80:	f8cc 3210 	str.w	r3, [ip, #528]	; 0x210
  ep->xfer_count = 0U;
 8011c84:	2300      	movs	r3, #0
    (void)USB_EP0StartXfer(hpcd->Instance, ep);
 8011c86:	6800      	ldr	r0, [r0, #0]
  ep->xfer_buff = pBuf;
 8011c88:	f8cc 2208 	str.w	r2, [ip, #520]	; 0x208
  ep = &hpcd->OUT_ep[ep_addr & EP_ADDR_MSK];
 8011c8c:	f501 71fe 	add.w	r1, r1, #508	; 0x1fc
  ep->xfer_count = 0U;
 8011c90:	f8cc 3214 	str.w	r3, [ip, #532]	; 0x214
  ep->is_in = 0U;
 8011c94:	f88c 31fd 	strb.w	r3, [ip, #509]	; 0x1fd
  ep->num = ep_addr & EP_ADDR_MSK;
 8011c98:	f88c 41fc 	strb.w	r4, [ip, #508]	; 0x1fc
  if ((ep_addr & EP_ADDR_MSK) == 0U)
 8011c9c:	b91c      	cbnz	r4, 8011ca6 <HAL_PCD_EP_Receive+0x3a>
    (void)USB_EP0StartXfer(hpcd->Instance, ep);
 8011c9e:	f003 fd07 	bl	80156b0 <USB_EP0StartXfer>
}
 8011ca2:	2000      	movs	r0, #0
 8011ca4:	bd10      	pop	{r4, pc}
    (void)USB_EPStartXfer(hpcd->Instance, ep);
 8011ca6:	f003 fc1f 	bl	80154e8 <USB_EPStartXfer>
}
 8011caa:	2000      	movs	r0, #0
 8011cac:	bd10      	pop	{r4, pc}
 8011cae:	bf00      	nop

08011cb0 <HAL_PCD_EP_GetRxCount>:
  return hpcd->OUT_ep[ep_addr & EP_ADDR_MSK].xfer_count;
 8011cb0:	f001 010f 	and.w	r1, r1, #15
 8011cb4:	ebc1 01c1 	rsb	r1, r1, r1, lsl #3
 8011cb8:	eb00 0181 	add.w	r1, r0, r1, lsl #2
}
 8011cbc:	f8d1 0214 	ldr.w	r0, [r1, #532]	; 0x214
 8011cc0:	4770      	bx	lr
 8011cc2:	bf00      	nop

08011cc4 <HAL_PCD_EP_Transmit>:
{
 8011cc4:	b510      	push	{r4, lr}
 8011cc6:	f001 040f 	and.w	r4, r1, #15
  ep->xfer_buff = pBuf;
 8011cca:	ebc4 0cc4 	rsb	ip, r4, r4, lsl #3
 8011cce:	eb00 0c8c 	add.w	ip, r0, ip, lsl #2
  ep = &hpcd->IN_ep[ep_addr & EP_ADDR_MSK];
 8011cd2:	211c      	movs	r1, #28
  ep->xfer_len = len;
 8011cd4:	f8cc 3050 	str.w	r3, [ip, #80]	; 0x50
  ep->xfer_count = 0U;
 8011cd8:	2300      	movs	r3, #0
  ep = &hpcd->IN_ep[ep_addr & EP_ADDR_MSK];
 8011cda:	fb01 0104 	mla	r1, r1, r4, r0
  ep->xfer_count = 0U;
 8011cde:	f8cc 3054 	str.w	r3, [ip, #84]	; 0x54
  ep->is_in = 1U;
 8011ce2:	2301      	movs	r3, #1
    (void)USB_EP0StartXfer(hpcd->Instance, ep);
 8011ce4:	6800      	ldr	r0, [r0, #0]
  ep->xfer_buff = pBuf;
 8011ce6:	f8cc 2048 	str.w	r2, [ip, #72]	; 0x48
  ep = &hpcd->IN_ep[ep_addr & EP_ADDR_MSK];
 8011cea:	313c      	adds	r1, #60	; 0x3c
  ep->is_in = 1U;
 8011cec:	f88c 303d 	strb.w	r3, [ip, #61]	; 0x3d
  ep->num = ep_addr & EP_ADDR_MSK;
 8011cf0:	f88c 403c 	strb.w	r4, [ip, #60]	; 0x3c
  if ((ep_addr & EP_ADDR_MSK) == 0U)
 8011cf4:	b91c      	cbnz	r4, 8011cfe <HAL_PCD_EP_Transmit+0x3a>
    (void)USB_EP0StartXfer(hpcd->Instance, ep);
 8011cf6:	f003 fcdb 	bl	80156b0 <USB_EP0StartXfer>
}
 8011cfa:	2000      	movs	r0, #0
 8011cfc:	bd10      	pop	{r4, pc}
    (void)USB_EPStartXfer(hpcd->Instance, ep);
 8011cfe:	f003 fbf3 	bl	80154e8 <USB_EPStartXfer>
}
 8011d02:	2000      	movs	r0, #0
 8011d04:	bd10      	pop	{r4, pc}
 8011d06:	bf00      	nop

08011d08 <HAL_PCD_EP_SetStall>:
{
 8011d08:	b538      	push	{r3, r4, r5, lr}
  if (((uint32_t)ep_addr & EP_ADDR_MSK) > hpcd->Init.dev_endpoints)
 8011d0a:	6843      	ldr	r3, [r0, #4]
 8011d0c:	f001 050f 	and.w	r5, r1, #15
 8011d10:	429d      	cmp	r5, r3
 8011d12:	d833      	bhi.n	8011d7c <HAL_PCD_EP_SetStall+0x74>
  if ((0x80U & ep_addr) == 0x80U)
 8011d14:	060b      	lsls	r3, r1, #24
 8011d16:	4604      	mov	r4, r0
 8011d18:	d41c      	bmi.n	8011d54 <HAL_PCD_EP_SetStall+0x4c>
    ep->is_in = 0U;
 8011d1a:	ebc1 03c1 	rsb	r3, r1, r1, lsl #3
    ep = &hpcd->OUT_ep[ep_addr];
 8011d1e:	221c      	movs	r2, #28
 8011d20:	fb02 0101 	mla	r1, r2, r1, r0
    ep->is_in = 0U;
 8011d24:	eb00 0383 	add.w	r3, r0, r3, lsl #2
    ep = &hpcd->OUT_ep[ep_addr];
 8011d28:	f501 71fe 	add.w	r1, r1, #508	; 0x1fc
    ep->is_in = 0U;
 8011d2c:	2200      	movs	r2, #0
 8011d2e:	f883 21fd 	strb.w	r2, [r3, #509]	; 0x1fd
  ep->is_stall = 1U;
 8011d32:	2301      	movs	r3, #1
 8011d34:	708b      	strb	r3, [r1, #2]
  ep->num = ep_addr & EP_ADDR_MSK;
 8011d36:	700d      	strb	r5, [r1, #0]
  __HAL_LOCK(hpcd);
 8011d38:	f894 23bc 	ldrb.w	r2, [r4, #956]	; 0x3bc
 8011d3c:	429a      	cmp	r2, r3
 8011d3e:	d01b      	beq.n	8011d78 <HAL_PCD_EP_SetStall+0x70>
  (void)USB_EPSetStall(hpcd->Instance, ep);
 8011d40:	6820      	ldr	r0, [r4, #0]
  __HAL_LOCK(hpcd);
 8011d42:	f884 33bc 	strb.w	r3, [r4, #956]	; 0x3bc
  (void)USB_EPSetStall(hpcd->Instance, ep);
 8011d46:	f003 fd63 	bl	8015810 <USB_EPSetStall>
  if ((ep_addr & EP_ADDR_MSK) == 0U)
 8011d4a:	b1cd      	cbz	r5, 8011d80 <HAL_PCD_EP_SetStall+0x78>
  __HAL_UNLOCK(hpcd);
 8011d4c:	2000      	movs	r0, #0
 8011d4e:	f884 03bc 	strb.w	r0, [r4, #956]	; 0x3bc
}
 8011d52:	bd38      	pop	{r3, r4, r5, pc}
    ep->is_in = 1U;
 8011d54:	ebc5 03c5 	rsb	r3, r5, r5, lsl #3
    ep = &hpcd->IN_ep[ep_addr & EP_ADDR_MSK];
 8011d58:	211c      	movs	r1, #28
 8011d5a:	fb01 0105 	mla	r1, r1, r5, r0
    ep->is_in = 1U;
 8011d5e:	eb00 0383 	add.w	r3, r0, r3, lsl #2
 8011d62:	2201      	movs	r2, #1
    ep = &hpcd->IN_ep[ep_addr & EP_ADDR_MSK];
 8011d64:	313c      	adds	r1, #60	; 0x3c
    ep->is_in = 1U;
 8011d66:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d
  ep->is_stall = 1U;
 8011d6a:	2301      	movs	r3, #1
 8011d6c:	708b      	strb	r3, [r1, #2]
  ep->num = ep_addr & EP_ADDR_MSK;
 8011d6e:	700d      	strb	r5, [r1, #0]
  __HAL_LOCK(hpcd);
 8011d70:	f894 23bc 	ldrb.w	r2, [r4, #956]	; 0x3bc
 8011d74:	429a      	cmp	r2, r3
 8011d76:	d1e3      	bne.n	8011d40 <HAL_PCD_EP_SetStall+0x38>
 8011d78:	2002      	movs	r0, #2
}
 8011d7a:	bd38      	pop	{r3, r4, r5, pc}
    return HAL_ERROR;
 8011d7c:	2001      	movs	r0, #1
}
 8011d7e:	bd38      	pop	{r3, r4, r5, pc}
    (void)USB_EP0_OutStart(hpcd->Instance, (uint8_t *)hpcd->Setup);
 8011d80:	6820      	ldr	r0, [r4, #0]
 8011d82:	f504 7171 	add.w	r1, r4, #964	; 0x3c4
 8011d86:	f003 fe4b 	bl	8015a20 <USB_EP0_OutStart>
 8011d8a:	e7df      	b.n	8011d4c <HAL_PCD_EP_SetStall+0x44>

08011d8c <HAL_PCD_EP_ClrStall>:
  if (((uint32_t)ep_addr & 0x0FU) > hpcd->Init.dev_endpoints)
 8011d8c:	6842      	ldr	r2, [r0, #4]
{
 8011d8e:	b538      	push	{r3, r4, r5, lr}
 8011d90:	f001 030f 	and.w	r3, r1, #15
  if (((uint32_t)ep_addr & 0x0FU) > hpcd->Init.dev_endpoints)
 8011d94:	4293      	cmp	r3, r2
 8011d96:	d82e      	bhi.n	8011df6 <HAL_PCD_EP_ClrStall+0x6a>
    ep->is_in = 1U;
 8011d98:	ebc3 02c3 	rsb	r2, r3, r3, lsl #3
  if ((0x80U & ep_addr) == 0x80U)
 8011d9c:	f011 0f80 	tst.w	r1, #128	; 0x80
    ep = &hpcd->IN_ep[ep_addr & EP_ADDR_MSK];
 8011da0:	f04f 011c 	mov.w	r1, #28
 8011da4:	4604      	mov	r4, r0
    ep->is_in = 1U;
 8011da6:	eb00 0282 	add.w	r2, r0, r2, lsl #2
    ep = &hpcd->IN_ep[ep_addr & EP_ADDR_MSK];
 8011daa:	fb01 0103 	mla	r1, r1, r3, r0
  if ((0x80U & ep_addr) == 0x80U)
 8011dae:	d115      	bne.n	8011ddc <HAL_PCD_EP_ClrStall+0x50>
    ep = &hpcd->OUT_ep[ep_addr & EP_ADDR_MSK];
 8011db0:	f501 71fe 	add.w	r1, r1, #508	; 0x1fc
    ep->is_in = 0U;
 8011db4:	2000      	movs	r0, #0
  ep->is_stall = 0U;
 8011db6:	2500      	movs	r5, #0
    ep->is_in = 0U;
 8011db8:	f882 01fd 	strb.w	r0, [r2, #509]	; 0x1fd
  ep->is_stall = 0U;
 8011dbc:	708d      	strb	r5, [r1, #2]
  ep->num = ep_addr & EP_ADDR_MSK;
 8011dbe:	700b      	strb	r3, [r1, #0]
  __HAL_LOCK(hpcd);
 8011dc0:	f894 33bc 	ldrb.w	r3, [r4, #956]	; 0x3bc
 8011dc4:	2b01      	cmp	r3, #1
 8011dc6:	d014      	beq.n	8011df2 <HAL_PCD_EP_ClrStall+0x66>
 8011dc8:	2301      	movs	r3, #1
  (void)USB_EPClearStall(hpcd->Instance, ep);
 8011dca:	6820      	ldr	r0, [r4, #0]
  __HAL_LOCK(hpcd);
 8011dcc:	f884 33bc 	strb.w	r3, [r4, #956]	; 0x3bc
  (void)USB_EPClearStall(hpcd->Instance, ep);
 8011dd0:	f003 fd4c 	bl	801586c <USB_EPClearStall>
  __HAL_UNLOCK(hpcd);
 8011dd4:	f884 53bc 	strb.w	r5, [r4, #956]	; 0x3bc
  return HAL_OK;
 8011dd8:	4628      	mov	r0, r5
}
 8011dda:	bd38      	pop	{r3, r4, r5, pc}
    ep = &hpcd->IN_ep[ep_addr & EP_ADDR_MSK];
 8011ddc:	313c      	adds	r1, #60	; 0x3c
    ep->is_in = 1U;
 8011dde:	2001      	movs	r0, #1
  ep->is_stall = 0U;
 8011de0:	2500      	movs	r5, #0
    ep->is_in = 1U;
 8011de2:	f882 003d 	strb.w	r0, [r2, #61]	; 0x3d
  ep->is_stall = 0U;
 8011de6:	708d      	strb	r5, [r1, #2]
  ep->num = ep_addr & EP_ADDR_MSK;
 8011de8:	700b      	strb	r3, [r1, #0]
  __HAL_LOCK(hpcd);
 8011dea:	f894 33bc 	ldrb.w	r3, [r4, #956]	; 0x3bc
 8011dee:	2b01      	cmp	r3, #1
 8011df0:	d1ea      	bne.n	8011dc8 <HAL_PCD_EP_ClrStall+0x3c>
 8011df2:	2002      	movs	r0, #2
}
 8011df4:	bd38      	pop	{r3, r4, r5, pc}
    return HAL_ERROR;
 8011df6:	2001      	movs	r0, #1
}
 8011df8:	bd38      	pop	{r3, r4, r5, pc}
 8011dfa:	bf00      	nop

08011dfc <HAL_PCD_EP_Flush>:
  __HAL_LOCK(hpcd);
 8011dfc:	f890 33bc 	ldrb.w	r3, [r0, #956]	; 0x3bc
 8011e00:	2b01      	cmp	r3, #1
 8011e02:	d015      	beq.n	8011e30 <HAL_PCD_EP_Flush+0x34>
 8011e04:	2301      	movs	r3, #1
{
 8011e06:	b510      	push	{r4, lr}
  __HAL_LOCK(hpcd);
 8011e08:	f880 33bc 	strb.w	r3, [r0, #956]	; 0x3bc
  if ((ep_addr & 0x80U) == 0x80U)
 8011e0c:	060b      	lsls	r3, r1, #24
 8011e0e:	4604      	mov	r4, r0
    (void)USB_FlushTxFifo(hpcd->Instance, (uint32_t)ep_addr & EP_ADDR_MSK);
 8011e10:	6800      	ldr	r0, [r0, #0]
  if ((ep_addr & 0x80U) == 0x80U)
 8011e12:	d405      	bmi.n	8011e20 <HAL_PCD_EP_Flush+0x24>
    (void)USB_FlushRxFifo(hpcd->Instance);
 8011e14:	f003 fac8 	bl	80153a8 <USB_FlushRxFifo>
  __HAL_UNLOCK(hpcd);
 8011e18:	2000      	movs	r0, #0
 8011e1a:	f884 03bc 	strb.w	r0, [r4, #956]	; 0x3bc
}
 8011e1e:	bd10      	pop	{r4, pc}
    (void)USB_FlushTxFifo(hpcd->Instance, (uint32_t)ep_addr & EP_ADDR_MSK);
 8011e20:	f001 010f 	and.w	r1, r1, #15
 8011e24:	f003 faae 	bl	8015384 <USB_FlushTxFifo>
  __HAL_UNLOCK(hpcd);
 8011e28:	2000      	movs	r0, #0
 8011e2a:	f884 03bc 	strb.w	r0, [r4, #956]	; 0x3bc
}
 8011e2e:	bd10      	pop	{r4, pc}
  __HAL_LOCK(hpcd);
 8011e30:	2002      	movs	r0, #2
}
 8011e32:	4770      	bx	lr

08011e34 <HAL_PCDEx_SetTxFiFo>:
  * @param  fifo The number of Tx fifo
  * @param  size Fifo size
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCDEx_SetTxFiFo(PCD_HandleTypeDef *hpcd, uint8_t fifo, uint16_t size)
{
 8011e34:	b410      	push	{r4}
         --> Txn should be configured with the minimum space of 16 words
     The FIFO is used optimally when used TxFIFOs are allocated in the top
         of the FIFO.Ex: use EP1 and EP2 as IN instead of EP1 and EP3 as IN ones.
     When DMA is used 3n * FIFO locations should be reserved for internal DMA registers */

  Tx_Offset = hpcd->Instance->GRXFSIZ;
 8011e36:	6804      	ldr	r4, [r0, #0]
 8011e38:	6a60      	ldr	r0, [r4, #36]	; 0x24

  if (fifo == 0U)
 8011e3a:	b931      	cbnz	r1, 8011e4a <HAL_PCDEx_SetTxFiFo+0x16>
  {
    hpcd->Instance->DIEPTXF0_HNPTXFSIZ = ((uint32_t)size << 16) | Tx_Offset;
 8011e3c:	ea40 4002 	orr.w	r0, r0, r2, lsl #16
 8011e40:	62a0      	str	r0, [r4, #40]	; 0x28
    /* Multiply Tx_Size by 2 to get higher performance */
    hpcd->Instance->DIEPTXF[fifo - 1U] = ((uint32_t)size << 16) | Tx_Offset;
  }

  return HAL_OK;
}
 8011e42:	2000      	movs	r0, #0
 8011e44:	f85d 4b04 	ldr.w	r4, [sp], #4
 8011e48:	4770      	bx	lr
    Tx_Offset += (hpcd->Instance->DIEPTXF0_HNPTXFSIZ) >> 16;
 8011e4a:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    for (i = 0U; i < (fifo - 1U); i++)
 8011e4c:	f1b1 0c01 	subs.w	ip, r1, #1
    Tx_Offset += (hpcd->Instance->DIEPTXF0_HNPTXFSIZ) >> 16;
 8011e50:	eb00 4013 	add.w	r0, r0, r3, lsr #16
    for (i = 0U; i < (fifo - 1U); i++)
 8011e54:	d00b      	beq.n	8011e6e <HAL_PCDEx_SetTxFiFo+0x3a>
 8011e56:	2300      	movs	r3, #0
      Tx_Offset += (hpcd->Instance->DIEPTXF[i] >> 16);
 8011e58:	f103 0140 	add.w	r1, r3, #64	; 0x40
 8011e5c:	eb04 0181 	add.w	r1, r4, r1, lsl #2
    for (i = 0U; i < (fifo - 1U); i++)
 8011e60:	3301      	adds	r3, #1
      Tx_Offset += (hpcd->Instance->DIEPTXF[i] >> 16);
 8011e62:	6849      	ldr	r1, [r1, #4]
    for (i = 0U; i < (fifo - 1U); i++)
 8011e64:	b2db      	uxtb	r3, r3
 8011e66:	4563      	cmp	r3, ip
      Tx_Offset += (hpcd->Instance->DIEPTXF[i] >> 16);
 8011e68:	eb00 4011 	add.w	r0, r0, r1, lsr #16
    for (i = 0U; i < (fifo - 1U); i++)
 8011e6c:	d3f4      	bcc.n	8011e58 <HAL_PCDEx_SetTxFiFo+0x24>
    hpcd->Instance->DIEPTXF[fifo - 1U] = ((uint32_t)size << 16) | Tx_Offset;
 8011e6e:	f10c 0c40 	add.w	ip, ip, #64	; 0x40
 8011e72:	eb04 0c8c 	add.w	ip, r4, ip, lsl #2
 8011e76:	ea40 4002 	orr.w	r0, r0, r2, lsl #16
 8011e7a:	f8cc 0004 	str.w	r0, [ip, #4]
}
 8011e7e:	f85d 4b04 	ldr.w	r4, [sp], #4
 8011e82:	2000      	movs	r0, #0
 8011e84:	4770      	bx	lr
 8011e86:	bf00      	nop

08011e88 <HAL_PCDEx_SetRxFiFo>:
  * @param  size Size of Rx fifo
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCDEx_SetRxFiFo(PCD_HandleTypeDef *hpcd, uint16_t size)
{
  hpcd->Instance->GRXFSIZ = size;
 8011e88:	6803      	ldr	r3, [r0, #0]

  return HAL_OK;
}
 8011e8a:	2000      	movs	r0, #0
  hpcd->Instance->GRXFSIZ = size;
 8011e8c:	6259      	str	r1, [r3, #36]	; 0x24
}
 8011e8e:	4770      	bx	lr

08011e90 <HAL_PCDEx_ActivateLPM>:
  * @param  hpcd PCD handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCDEx_ActivateLPM(PCD_HandleTypeDef *hpcd)
{
  USB_OTG_GlobalTypeDef *USBx = hpcd->Instance;
 8011e90:	6802      	ldr	r2, [r0, #0]

  hpcd->lpm_active = 1U;
  hpcd->LPM_State = LPM_L0;
 8011e92:	2100      	movs	r1, #0
{
 8011e94:	b410      	push	{r4}
  hpcd->LPM_State = LPM_L0;
 8011e96:	f880 13f4 	strb.w	r1, [r0, #1012]	; 0x3f4
  USBx->GINTMSK |= USB_OTG_GINTMSK_LPMINTM;
 8011e9a:	6993      	ldr	r3, [r2, #24]
  hpcd->lpm_active = 1U;
 8011e9c:	2401      	movs	r4, #1
  USBx->GINTMSK |= USB_OTG_GINTMSK_LPMINTM;
 8011e9e:	f043 6300 	orr.w	r3, r3, #134217728	; 0x8000000
  hpcd->lpm_active = 1U;
 8011ea2:	f8c0 43fc 	str.w	r4, [r0, #1020]	; 0x3fc
  USBx->GINTMSK |= USB_OTG_GINTMSK_LPMINTM;
 8011ea6:	6193      	str	r3, [r2, #24]
  USBx->GLPMCFG |= (USB_OTG_GLPMCFG_LPMEN | USB_OTG_GLPMCFG_LPMACK | USB_OTG_GLPMCFG_ENBESL);
 8011ea8:	6d53      	ldr	r3, [r2, #84]	; 0x54

  return HAL_OK;
}
 8011eaa:	f85d 4b04 	ldr.w	r4, [sp], #4
  USBx->GLPMCFG |= (USB_OTG_GLPMCFG_LPMEN | USB_OTG_GLPMCFG_LPMACK | USB_OTG_GLPMCFG_ENBESL);
 8011eae:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 8011eb2:	f043 0303 	orr.w	r3, r3, #3
}
 8011eb6:	4608      	mov	r0, r1
  USBx->GLPMCFG |= (USB_OTG_GLPMCFG_LPMEN | USB_OTG_GLPMCFG_LPMACK | USB_OTG_GLPMCFG_ENBESL);
 8011eb8:	6553      	str	r3, [r2, #84]	; 0x54
}
 8011eba:	4770      	bx	lr

08011ebc <HAL_PCDEx_LPM_Callback>:
  UNUSED(msg);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_PCDEx_LPM_Callback could be implemented in the user file
   */
}
 8011ebc:	4770      	bx	lr
 8011ebe:	bf00      	nop

08011ec0 <HAL_PWR_EnableBkUpAccess>:
  *        back-up domain.
  * @retval None
  */
void HAL_PWR_EnableBkUpAccess(void)
{
  SET_BIT(PWR->CR1, PWR_CR1_DBP);
 8011ec0:	4a02      	ldr	r2, [pc, #8]	; (8011ecc <HAL_PWR_EnableBkUpAccess+0xc>)
 8011ec2:	6813      	ldr	r3, [r2, #0]
 8011ec4:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 8011ec8:	6013      	str	r3, [r2, #0]
}
 8011eca:	4770      	bx	lr
 8011ecc:	40007000 	.word	0x40007000

08011ed0 <HAL_PWREx_GetVoltageRange>:
    else
    {
      return PWR_REGULATOR_VOLTAGE_SCALE1_BOOST;
    }
#else
  return  (PWR->CR1 & PWR_CR1_VOS);
 8011ed0:	4b02      	ldr	r3, [pc, #8]	; (8011edc <HAL_PWREx_GetVoltageRange+0xc>)
 8011ed2:	6818      	ldr	r0, [r3, #0]
#endif
}
 8011ed4:	f400 60c0 	and.w	r0, r0, #1536	; 0x600
 8011ed8:	4770      	bx	lr
 8011eda:	bf00      	nop
 8011edc:	40007000 	.word	0x40007000

08011ee0 <HAL_PWREx_EnableVddUSB>:
  * @note  Remove VDDUSB electrical and logical isolation, once VDDUSB supply is present.
  * @retval None
  */
void HAL_PWREx_EnableVddUSB(void)
{
  SET_BIT(PWR->CR2, PWR_CR2_USV);
 8011ee0:	4a02      	ldr	r2, [pc, #8]	; (8011eec <HAL_PWREx_EnableVddUSB+0xc>)
 8011ee2:	6853      	ldr	r3, [r2, #4]
 8011ee4:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
 8011ee8:	6053      	str	r3, [r2, #4]
}
 8011eea:	4770      	bx	lr
 8011eec:	40007000 	.word	0x40007000

08011ef0 <QSPI_Config>:
  *            @arg QSPI_FUNCTIONAL_MODE_AUTO_POLLING: Automatic polling mode
  *            @arg QSPI_FUNCTIONAL_MODE_MEMORY_MAPPED: Memory-mapped mode
  * @retval None
  */
static void QSPI_Config(QSPI_HandleTypeDef *hqspi, QSPI_CommandTypeDef *cmd, uint32_t FunctionalMode)
{
 8011ef0:	b4f0      	push	{r4, r5, r6, r7}
  assert_param(IS_QSPI_FUNCTIONAL_MODE(FunctionalMode));

  if ((cmd->DataMode != QSPI_DATA_NONE) && (FunctionalMode != QSPI_FUNCTIONAL_MODE_MEMORY_MAPPED))
 8011ef2:	6a4d      	ldr	r5, [r1, #36]	; 0x24
 8011ef4:	b135      	cbz	r5, 8011f04 <QSPI_Config+0x14>
 8011ef6:	f1b2 6f40 	cmp.w	r2, #201326592	; 0xc000000
 8011efa:	d003      	beq.n	8011f04 <QSPI_Config+0x14>
  {
    /* Configure QSPI: DLR register with the number of data to read or write */
    WRITE_REG(hqspi->Instance->DLR, (cmd->NbData - 1U));
 8011efc:	6a8b      	ldr	r3, [r1, #40]	; 0x28
 8011efe:	6804      	ldr	r4, [r0, #0]
 8011f00:	3b01      	subs	r3, #1
 8011f02:	6123      	str	r3, [r4, #16]
  }

  if (cmd->InstructionMode != QSPI_INSTRUCTION_NONE)
 8011f04:	698b      	ldr	r3, [r1, #24]
 8011f06:	b31b      	cbz	r3, 8011f50 <QSPI_Config+0x60>
  {
    if (cmd->AlternateByteMode != QSPI_ALTERNATE_BYTES_NONE)
 8011f08:	6a0c      	ldr	r4, [r1, #32]
 8011f0a:	2c00      	cmp	r4, #0
 8011f0c:	d047      	beq.n	8011f9e <QSPI_Config+0xae>
    {
      /* Configure QSPI: ABR register with alternate bytes value */
      WRITE_REG(hqspi->Instance->ABR, cmd->AlternateBytes);
 8011f0e:	6800      	ldr	r0, [r0, #0]

      if (cmd->AddressMode != QSPI_ADDRESS_NONE)
 8011f10:	69ce      	ldr	r6, [r1, #28]
      WRITE_REG(hqspi->Instance->ABR, cmd->AlternateBytes);
 8011f12:	688f      	ldr	r7, [r1, #8]
 8011f14:	61c7      	str	r7, [r0, #28]
      if (cmd->AddressMode != QSPI_ADDRESS_NONE)
 8011f16:	2e00      	cmp	r6, #0
 8011f18:	d05f      	beq.n	8011fda <QSPI_Config+0xea>
      {
        /*---- Command with instruction, address and alternate bytes ----*/
        /* Configure QSPI: CCR register with all communications parameters */
        WRITE_REG(hqspi->Instance->CCR, (cmd->DdrMode | cmd->DdrHoldHalfCycle | cmd->SIOOMode |
 8011f1a:	432b      	orrs	r3, r5
 8011f1c:	4313      	orrs	r3, r2
 8011f1e:	4323      	orrs	r3, r4
 8011f20:	6acc      	ldr	r4, [r1, #44]	; 0x2c
 8011f22:	4333      	orrs	r3, r6
 8011f24:	4323      	orrs	r3, r4
 8011f26:	6b0c      	ldr	r4, [r1, #48]	; 0x30
 8011f28:	4323      	orrs	r3, r4
 8011f2a:	6b4c      	ldr	r4, [r1, #52]	; 0x34
 8011f2c:	4323      	orrs	r3, r4
 8011f2e:	690c      	ldr	r4, [r1, #16]
 8011f30:	4323      	orrs	r3, r4
 8011f32:	68cc      	ldr	r4, [r1, #12]
 8011f34:	4323      	orrs	r3, r4
 8011f36:	680c      	ldr	r4, [r1, #0]
    {
      if (cmd->AddressMode != QSPI_ADDRESS_NONE)
      {
        /*---- Command with only address ----*/
        /* Configure QSPI: CCR register with all communications parameters */
        WRITE_REG(hqspi->Instance->CCR, (cmd->DdrMode | cmd->DdrHoldHalfCycle | cmd->SIOOMode |
 8011f38:	4323      	orrs	r3, r4
 8011f3a:	694c      	ldr	r4, [r1, #20]
                                         cmd->DataMode | (cmd->DummyCycles << QUADSPI_CCR_DCYC_Pos) |
                                         cmd->AlternateByteMode | cmd->AddressSize |
                                         cmd->AddressMode | cmd->InstructionMode | FunctionalMode));

        if (FunctionalMode != QSPI_FUNCTIONAL_MODE_MEMORY_MAPPED)
 8011f3c:	f1b2 6f40 	cmp.w	r2, #201326592	; 0xc000000
        WRITE_REG(hqspi->Instance->CCR, (cmd->DdrMode | cmd->DdrHoldHalfCycle | cmd->SIOOMode |
 8011f40:	ea43 4384 	orr.w	r3, r3, r4, lsl #18
 8011f44:	6143      	str	r3, [r0, #20]
        if (FunctionalMode != QSPI_FUNCTIONAL_MODE_MEMORY_MAPPED)
 8011f46:	d05b      	beq.n	8012000 <QSPI_Config+0x110>
        {
          /* Configure QSPI: AR register with address value */
          WRITE_REG(hqspi->Instance->AR, cmd->Address);
 8011f48:	684b      	ldr	r3, [r1, #4]
 8011f4a:	6183      	str	r3, [r0, #24]
                                           cmd->InstructionMode | FunctionalMode));
        }
      }
    }
  }
}
 8011f4c:	bcf0      	pop	{r4, r5, r6, r7}
 8011f4e:	4770      	bx	lr
    if (cmd->AlternateByteMode != QSPI_ALTERNATE_BYTES_NONE)
 8011f50:	6a0b      	ldr	r3, [r1, #32]
 8011f52:	b193      	cbz	r3, 8011f7a <QSPI_Config+0x8a>
      WRITE_REG(hqspi->Instance->ABR, cmd->AlternateBytes);
 8011f54:	6800      	ldr	r0, [r0, #0]
      if (cmd->AddressMode != QSPI_ADDRESS_NONE)
 8011f56:	69ce      	ldr	r6, [r1, #28]
      WRITE_REG(hqspi->Instance->ABR, cmd->AlternateBytes);
 8011f58:	688c      	ldr	r4, [r1, #8]
 8011f5a:	61c4      	str	r4, [r0, #28]
        WRITE_REG(hqspi->Instance->CCR, (cmd->DdrMode | cmd->DdrHoldHalfCycle | cmd->SIOOMode |
 8011f5c:	432b      	orrs	r3, r5
      if (cmd->AddressMode != QSPI_ADDRESS_NONE)
 8011f5e:	2e00      	cmp	r6, #0
 8011f60:	d061      	beq.n	8012026 <QSPI_Config+0x136>
        WRITE_REG(hqspi->Instance->CCR, (cmd->DdrMode | cmd->DdrHoldHalfCycle | cmd->SIOOMode |
 8011f62:	6acc      	ldr	r4, [r1, #44]	; 0x2c
 8011f64:	4313      	orrs	r3, r2
 8011f66:	4333      	orrs	r3, r6
 8011f68:	4323      	orrs	r3, r4
 8011f6a:	6b0c      	ldr	r4, [r1, #48]	; 0x30
 8011f6c:	4323      	orrs	r3, r4
 8011f6e:	6b4c      	ldr	r4, [r1, #52]	; 0x34
 8011f70:	4323      	orrs	r3, r4
 8011f72:	690c      	ldr	r4, [r1, #16]
        WRITE_REG(hqspi->Instance->CCR, (cmd->DdrMode | cmd->DdrHoldHalfCycle | cmd->SIOOMode |
 8011f74:	4323      	orrs	r3, r4
 8011f76:	68cc      	ldr	r4, [r1, #12]
 8011f78:	e7de      	b.n	8011f38 <QSPI_Config+0x48>
      if (cmd->AddressMode != QSPI_ADDRESS_NONE)
 8011f7a:	69cb      	ldr	r3, [r1, #28]
 8011f7c:	2b00      	cmp	r3, #0
 8011f7e:	d161      	bne.n	8012044 <QSPI_Config+0x154>
        if (cmd->DataMode != QSPI_DATA_NONE)
 8011f80:	2d00      	cmp	r5, #0
 8011f82:	d03d      	beq.n	8012000 <QSPI_Config+0x110>
          WRITE_REG(hqspi->Instance->CCR, (cmd->DdrMode | cmd->DdrHoldHalfCycle | cmd->SIOOMode |
 8011f84:	6acb      	ldr	r3, [r1, #44]	; 0x2c
 8011f86:	6b0c      	ldr	r4, [r1, #48]	; 0x30
 8011f88:	6800      	ldr	r0, [r0, #0]
 8011f8a:	432b      	orrs	r3, r5
 8011f8c:	4313      	orrs	r3, r2
 8011f8e:	4323      	orrs	r3, r4
 8011f90:	6b4c      	ldr	r4, [r1, #52]	; 0x34
 8011f92:	694a      	ldr	r2, [r1, #20]
 8011f94:	4323      	orrs	r3, r4
 8011f96:	ea43 4382 	orr.w	r3, r3, r2, lsl #18
 8011f9a:	6143      	str	r3, [r0, #20]
}
 8011f9c:	e030      	b.n	8012000 <QSPI_Config+0x110>
      if (cmd->AddressMode != QSPI_ADDRESS_NONE)
 8011f9e:	69cc      	ldr	r4, [r1, #28]
        WRITE_REG(hqspi->Instance->CCR, (cmd->DdrMode | cmd->DdrHoldHalfCycle | cmd->SIOOMode |
 8011fa0:	ea45 0c03 	orr.w	ip, r5, r3
      if (cmd->AddressMode != QSPI_ADDRESS_NONE)
 8011fa4:	b374      	cbz	r4, 8012004 <QSPI_Config+0x114>
        WRITE_REG(hqspi->Instance->CCR, (cmd->DdrMode | cmd->DdrHoldHalfCycle | cmd->SIOOMode |
 8011fa6:	ea4c 0c02 	orr.w	ip, ip, r2
 8011faa:	ea4c 0c04 	orr.w	ip, ip, r4
 8011fae:	6acc      	ldr	r4, [r1, #44]	; 0x2c
 8011fb0:	6803      	ldr	r3, [r0, #0]
 8011fb2:	ea4c 0004 	orr.w	r0, ip, r4
 8011fb6:	6b0c      	ldr	r4, [r1, #48]	; 0x30
 8011fb8:	4320      	orrs	r0, r4
 8011fba:	6b4c      	ldr	r4, [r1, #52]	; 0x34
 8011fbc:	4320      	orrs	r0, r4
 8011fbe:	68cc      	ldr	r4, [r1, #12]
 8011fc0:	4320      	orrs	r0, r4
 8011fc2:	680c      	ldr	r4, [r1, #0]
 8011fc4:	4320      	orrs	r0, r4
 8011fc6:	694c      	ldr	r4, [r1, #20]
        if (FunctionalMode != QSPI_FUNCTIONAL_MODE_MEMORY_MAPPED)
 8011fc8:	f1b2 6f40 	cmp.w	r2, #201326592	; 0xc000000
        WRITE_REG(hqspi->Instance->CCR, (cmd->DdrMode | cmd->DdrHoldHalfCycle | cmd->SIOOMode |
 8011fcc:	ea40 4084 	orr.w	r0, r0, r4, lsl #18
 8011fd0:	6158      	str	r0, [r3, #20]
        if (FunctionalMode != QSPI_FUNCTIONAL_MODE_MEMORY_MAPPED)
 8011fd2:	d015      	beq.n	8012000 <QSPI_Config+0x110>
          WRITE_REG(hqspi->Instance->AR, cmd->Address);
 8011fd4:	684a      	ldr	r2, [r1, #4]
 8011fd6:	619a      	str	r2, [r3, #24]
 8011fd8:	e012      	b.n	8012000 <QSPI_Config+0x110>
        WRITE_REG(hqspi->Instance->CCR, (cmd->DdrMode | cmd->DdrHoldHalfCycle | cmd->SIOOMode |
 8011fda:	ea45 0c03 	orr.w	ip, r5, r3
 8011fde:	ea4c 0302 	orr.w	r3, ip, r2
 8011fe2:	6aca      	ldr	r2, [r1, #44]	; 0x2c
 8011fe4:	690d      	ldr	r5, [r1, #16]
 8011fe6:	4323      	orrs	r3, r4
 8011fe8:	4313      	orrs	r3, r2
 8011fea:	e9d1 420c 	ldrd	r4, r2, [r1, #48]	; 0x30
 8011fee:	4323      	orrs	r3, r4
 8011ff0:	4313      	orrs	r3, r2
 8011ff2:	680c      	ldr	r4, [r1, #0]
 8011ff4:	694a      	ldr	r2, [r1, #20]
 8011ff6:	432b      	orrs	r3, r5
 8011ff8:	4323      	orrs	r3, r4
 8011ffa:	ea43 4382 	orr.w	r3, r3, r2, lsl #18
 8011ffe:	6143      	str	r3, [r0, #20]
}
 8012000:	bcf0      	pop	{r4, r5, r6, r7}
 8012002:	4770      	bx	lr
        WRITE_REG(hqspi->Instance->CCR, (cmd->DdrMode | cmd->DdrHoldHalfCycle | cmd->SIOOMode |
 8012004:	6acc      	ldr	r4, [r1, #44]	; 0x2c
 8012006:	ea4c 0302 	orr.w	r3, ip, r2
 801200a:	4323      	orrs	r3, r4
 801200c:	e9d1 420c 	ldrd	r4, r2, [r1, #48]	; 0x30
 8012010:	4323      	orrs	r3, r4
 8012012:	680c      	ldr	r4, [r1, #0]
 8012014:	6949      	ldr	r1, [r1, #20]
 8012016:	4313      	orrs	r3, r2
 8012018:	4323      	orrs	r3, r4
 801201a:	6802      	ldr	r2, [r0, #0]
 801201c:	ea43 4381 	orr.w	r3, r3, r1, lsl #18
}
 8012020:	bcf0      	pop	{r4, r5, r6, r7}
        WRITE_REG(hqspi->Instance->CCR, (cmd->DdrMode | cmd->DdrHoldHalfCycle | cmd->SIOOMode |
 8012022:	6153      	str	r3, [r2, #20]
}
 8012024:	4770      	bx	lr
        WRITE_REG(hqspi->Instance->CCR, (cmd->DdrMode | cmd->DdrHoldHalfCycle | cmd->SIOOMode |
 8012026:	6acc      	ldr	r4, [r1, #44]	; 0x2c
 8012028:	4313      	orrs	r3, r2
 801202a:	4323      	orrs	r3, r4
 801202c:	e9d1 420c 	ldrd	r4, r2, [r1, #48]	; 0x30
 8012030:	4323      	orrs	r3, r4
 8012032:	4313      	orrs	r3, r2
 8012034:	e9d1 4204 	ldrd	r4, r2, [r1, #16]
 8012038:	4323      	orrs	r3, r4
 801203a:	ea43 4382 	orr.w	r3, r3, r2, lsl #18
}
 801203e:	bcf0      	pop	{r4, r5, r6, r7}
        WRITE_REG(hqspi->Instance->CCR, (cmd->DdrMode | cmd->DdrHoldHalfCycle | cmd->SIOOMode |
 8012040:	6143      	str	r3, [r0, #20]
}
 8012042:	4770      	bx	lr
        WRITE_REG(hqspi->Instance->CCR, (cmd->DdrMode | cmd->DdrHoldHalfCycle | cmd->SIOOMode |
 8012044:	432b      	orrs	r3, r5
 8012046:	6acd      	ldr	r5, [r1, #44]	; 0x2c
 8012048:	6b0c      	ldr	r4, [r1, #48]	; 0x30
 801204a:	6800      	ldr	r0, [r0, #0]
 801204c:	4313      	orrs	r3, r2
 801204e:	432b      	orrs	r3, r5
 8012050:	4323      	orrs	r3, r4
 8012052:	6b4c      	ldr	r4, [r1, #52]	; 0x34
 8012054:	e78e      	b.n	8011f74 <QSPI_Config+0x84>
 8012056:	bf00      	nop

08012058 <HAL_QSPI_MspInit>:
}
 8012058:	4770      	bx	lr
 801205a:	bf00      	nop

0801205c <HAL_QSPI_Init>:
{
 801205c:	b570      	push	{r4, r5, r6, lr}
 801205e:	4604      	mov	r4, r0
  uint32_t tickstart = HAL_GetTick();
 8012060:	f7fd fbea 	bl	800f838 <HAL_GetTick>
  if(hqspi == NULL)
 8012064:	2c00      	cmp	r4, #0
 8012066:	d051      	beq.n	801210c <HAL_QSPI_Init+0xb0>
  __HAL_LOCK(hqspi);
 8012068:	f894 3038 	ldrb.w	r3, [r4, #56]	; 0x38
 801206c:	2b01      	cmp	r3, #1
 801206e:	d04f      	beq.n	8012110 <HAL_QSPI_Init+0xb4>
 8012070:	2301      	movs	r3, #1
 8012072:	f884 3038 	strb.w	r3, [r4, #56]	; 0x38
  if(hqspi->State == HAL_QSPI_STATE_RESET)
 8012076:	f894 3039 	ldrb.w	r3, [r4, #57]	; 0x39
 801207a:	4606      	mov	r6, r0
 801207c:	f003 02ff 	and.w	r2, r3, #255	; 0xff
 8012080:	2b00      	cmp	r3, #0
 8012082:	d032      	beq.n	80120ea <HAL_QSPI_Init+0x8e>
  status = QSPI_WaitFlagStateUntilTimeout(hqspi, QSPI_FLAG_BUSY, RESET, tickstart, hqspi->Timeout);
 8012084:	6c25      	ldr	r5, [r4, #64]	; 0x40
  MODIFY_REG(hqspi->Instance->CR, QUADSPI_CR_FTHRES,
 8012086:	6822      	ldr	r2, [r4, #0]
 8012088:	68a1      	ldr	r1, [r4, #8]
 801208a:	6813      	ldr	r3, [r2, #0]
 801208c:	3901      	subs	r1, #1
 801208e:	f423 6370 	bic.w	r3, r3, #3840	; 0xf00
 8012092:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
 8012096:	6013      	str	r3, [r2, #0]
  while((__HAL_QSPI_GET_FLAG(hqspi, Flag)) != State)
 8012098:	e001      	b.n	801209e <HAL_QSPI_Init+0x42>
    if (Timeout != HAL_MAX_DELAY)
 801209a:	1c6b      	adds	r3, r5, #1
 801209c:	d12e      	bne.n	80120fc <HAL_QSPI_Init+0xa0>
  while((__HAL_QSPI_GET_FLAG(hqspi, Flag)) != State)
 801209e:	6893      	ldr	r3, [r2, #8]
 80120a0:	f013 0320 	ands.w	r3, r3, #32
 80120a4:	d1f9      	bne.n	801209a <HAL_QSPI_Init+0x3e>
    MODIFY_REG(hqspi->Instance->CR, (QUADSPI_CR_PRESCALER | QUADSPI_CR_SSHIFT),
 80120a6:	6810      	ldr	r0, [r2, #0]
 80120a8:	6865      	ldr	r5, [r4, #4]
 80120aa:	68e1      	ldr	r1, [r4, #12]
 80120ac:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
 80120b0:	f020 0010 	bic.w	r0, r0, #16
 80120b4:	ea41 6105 	orr.w	r1, r1, r5, lsl #24
 80120b8:	4301      	orrs	r1, r0
 80120ba:	6011      	str	r1, [r2, #0]
    MODIFY_REG(hqspi->Instance->DCR, (QUADSPI_DCR_FSIZE | QUADSPI_DCR_CSHT | QUADSPI_DCR_CKMODE),
 80120bc:	e9d4 1005 	ldrd	r1, r0, [r4, #20]
 80120c0:	4301      	orrs	r1, r0
 80120c2:	6920      	ldr	r0, [r4, #16]
 80120c4:	6855      	ldr	r5, [r2, #4]
 80120c6:	ea41 4100 	orr.w	r1, r1, r0, lsl #16
 80120ca:	4816      	ldr	r0, [pc, #88]	; (8012124 <HAL_QSPI_Init+0xc8>)
 80120cc:	4028      	ands	r0, r5
 80120ce:	4301      	orrs	r1, r0
 80120d0:	6051      	str	r1, [r2, #4]
    __HAL_QSPI_ENABLE(hqspi);
 80120d2:	6811      	ldr	r1, [r2, #0]
    hqspi->State = HAL_QSPI_STATE_READY;
 80120d4:	2501      	movs	r5, #1
    __HAL_QSPI_ENABLE(hqspi);
 80120d6:	4329      	orrs	r1, r5
 80120d8:	6011      	str	r1, [r2, #0]
    hqspi->State = HAL_QSPI_STATE_READY;
 80120da:	4618      	mov	r0, r3
    hqspi->ErrorCode = HAL_QSPI_ERROR_NONE;
 80120dc:	63e3      	str	r3, [r4, #60]	; 0x3c
    hqspi->State = HAL_QSPI_STATE_READY;
 80120de:	f884 5039 	strb.w	r5, [r4, #57]	; 0x39
  __HAL_UNLOCK(hqspi);
 80120e2:	2300      	movs	r3, #0
 80120e4:	f884 3038 	strb.w	r3, [r4, #56]	; 0x38
}
 80120e8:	bd70      	pop	{r4, r5, r6, pc}
    hqspi->Lock = HAL_UNLOCKED;
 80120ea:	f884 2038 	strb.w	r2, [r4, #56]	; 0x38
    HAL_QSPI_MspInit(hqspi);
 80120ee:	4620      	mov	r0, r4
  hqspi->Timeout = Timeout;
 80120f0:	f241 3588 	movw	r5, #5000	; 0x1388
    HAL_QSPI_MspInit(hqspi);
 80120f4:	f7ff ffb0 	bl	8012058 <HAL_QSPI_MspInit>
  hqspi->Timeout = Timeout;
 80120f8:	6425      	str	r5, [r4, #64]	; 0x40
}
 80120fa:	e7c4      	b.n	8012086 <HAL_QSPI_Init+0x2a>
      if(((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
 80120fc:	f7fd fb9c 	bl	800f838 <HAL_GetTick>
 8012100:	1b80      	subs	r0, r0, r6
 8012102:	42a8      	cmp	r0, r5
 8012104:	d806      	bhi.n	8012114 <HAL_QSPI_Init+0xb8>
 8012106:	b12d      	cbz	r5, 8012114 <HAL_QSPI_Init+0xb8>
  while((__HAL_QSPI_GET_FLAG(hqspi, Flag)) != State)
 8012108:	6822      	ldr	r2, [r4, #0]
 801210a:	e7c8      	b.n	801209e <HAL_QSPI_Init+0x42>
    return HAL_ERROR;
 801210c:	2001      	movs	r0, #1
}
 801210e:	bd70      	pop	{r4, r5, r6, pc}
  __HAL_LOCK(hqspi);
 8012110:	2002      	movs	r0, #2
}
 8012112:	bd70      	pop	{r4, r5, r6, pc}
        hqspi->State     = HAL_QSPI_STATE_ERROR;
 8012114:	2304      	movs	r3, #4
 8012116:	f884 3039 	strb.w	r3, [r4, #57]	; 0x39
        hqspi->ErrorCode |= HAL_QSPI_ERROR_TIMEOUT;
 801211a:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 801211c:	2001      	movs	r0, #1
 801211e:	4303      	orrs	r3, r0
 8012120:	63e3      	str	r3, [r4, #60]	; 0x3c
  if(status == HAL_OK)
 8012122:	e7de      	b.n	80120e2 <HAL_QSPI_Init+0x86>
 8012124:	ffe0f8fe 	.word	0xffe0f8fe

08012128 <HAL_QSPI_Command>:
{
 8012128:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 801212c:	4605      	mov	r5, r0
 801212e:	460f      	mov	r7, r1
 8012130:	4616      	mov	r6, r2
  uint32_t tickstart = HAL_GetTick();
 8012132:	f7fd fb81 	bl	800f838 <HAL_GetTick>
  __HAL_LOCK(hqspi);
 8012136:	f895 3038 	ldrb.w	r3, [r5, #56]	; 0x38
 801213a:	2b01      	cmp	r3, #1
 801213c:	d03a      	beq.n	80121b4 <HAL_QSPI_Command+0x8c>
 801213e:	2301      	movs	r3, #1
 8012140:	f885 3038 	strb.w	r3, [r5, #56]	; 0x38
  if(hqspi->State == HAL_QSPI_STATE_READY)
 8012144:	f895 3039 	ldrb.w	r3, [r5, #57]	; 0x39
 8012148:	2b01      	cmp	r3, #1
 801214a:	fa5f f983 	uxtb.w	r9, r3
 801214e:	d007      	beq.n	8012160 <HAL_QSPI_Command+0x38>
    status = HAL_BUSY;
 8012150:	f04f 0902 	mov.w	r9, #2
  __HAL_UNLOCK(hqspi);
 8012154:	2300      	movs	r3, #0
 8012156:	f885 3038 	strb.w	r3, [r5, #56]	; 0x38
}
 801215a:	4648      	mov	r0, r9
 801215c:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    hqspi->ErrorCode = HAL_QSPI_ERROR_NONE;
 8012160:	2300      	movs	r3, #0
 8012162:	63eb      	str	r3, [r5, #60]	; 0x3c
    hqspi->State = HAL_QSPI_STATE_BUSY;
 8012164:	2302      	movs	r3, #2
 8012166:	4680      	mov	r8, r0
 8012168:	f885 3039 	strb.w	r3, [r5, #57]	; 0x39
  while((__HAL_QSPI_GET_FLAG(hqspi, Flag)) != State)
 801216c:	682a      	ldr	r2, [r5, #0]
 801216e:	e001      	b.n	8012174 <HAL_QSPI_Command+0x4c>
    if (Timeout != HAL_MAX_DELAY)
 8012170:	1c70      	adds	r0, r6, #1
 8012172:	d10f      	bne.n	8012194 <HAL_QSPI_Command+0x6c>
  while((__HAL_QSPI_GET_FLAG(hqspi, Flag)) != State)
 8012174:	6894      	ldr	r4, [r2, #8]
 8012176:	f014 0420 	ands.w	r4, r4, #32
 801217a:	d1f9      	bne.n	8012170 <HAL_QSPI_Command+0x48>
      QSPI_Config(hqspi, cmd, QSPI_FUNCTIONAL_MODE_INDIRECT_WRITE);
 801217c:	4622      	mov	r2, r4
 801217e:	4639      	mov	r1, r7
 8012180:	4628      	mov	r0, r5
 8012182:	f7ff feb5 	bl	8011ef0 <QSPI_Config>
      if (cmd->DataMode == QSPI_DATA_NONE)
 8012186:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8012188:	b30b      	cbz	r3, 80121ce <HAL_QSPI_Command+0xa6>
        hqspi->State = HAL_QSPI_STATE_READY;
 801218a:	2301      	movs	r3, #1
 801218c:	f885 3039 	strb.w	r3, [r5, #57]	; 0x39
    status = QSPI_WaitFlagStateUntilTimeout(hqspi, QSPI_FLAG_BUSY, RESET, tickstart, Timeout);
 8012190:	46a1      	mov	r9, r4
 8012192:	e7df      	b.n	8012154 <HAL_QSPI_Command+0x2c>
      if(((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
 8012194:	f7fd fb50 	bl	800f838 <HAL_GetTick>
 8012198:	eba0 0008 	sub.w	r0, r0, r8
 801219c:	4286      	cmp	r6, r0
 801219e:	d301      	bcc.n	80121a4 <HAL_QSPI_Command+0x7c>
 80121a0:	2e00      	cmp	r6, #0
 80121a2:	d1e3      	bne.n	801216c <HAL_QSPI_Command+0x44>
        hqspi->State     = HAL_QSPI_STATE_ERROR;
 80121a4:	2304      	movs	r3, #4
 80121a6:	f885 3039 	strb.w	r3, [r5, #57]	; 0x39
        hqspi->ErrorCode |= HAL_QSPI_ERROR_TIMEOUT;
 80121aa:	6beb      	ldr	r3, [r5, #60]	; 0x3c
 80121ac:	f043 0301 	orr.w	r3, r3, #1
 80121b0:	63eb      	str	r3, [r5, #60]	; 0x3c
        if (status == HAL_OK)
 80121b2:	e7cf      	b.n	8012154 <HAL_QSPI_Command+0x2c>
  __HAL_LOCK(hqspi);
 80121b4:	f04f 0902 	mov.w	r9, #2
}
 80121b8:	4648      	mov	r0, r9
 80121ba:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
      if(((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
 80121be:	f7fd fb3b 	bl	800f838 <HAL_GetTick>
 80121c2:	eba0 0008 	sub.w	r0, r0, r8
 80121c6:	4286      	cmp	r6, r0
 80121c8:	d3ec      	bcc.n	80121a4 <HAL_QSPI_Command+0x7c>
 80121ca:	2e00      	cmp	r6, #0
 80121cc:	d0ea      	beq.n	80121a4 <HAL_QSPI_Command+0x7c>
  while((__HAL_QSPI_GET_FLAG(hqspi, Flag)) != State)
 80121ce:	682a      	ldr	r2, [r5, #0]
 80121d0:	e001      	b.n	80121d6 <HAL_QSPI_Command+0xae>
    if (Timeout != HAL_MAX_DELAY)
 80121d2:	1c71      	adds	r1, r6, #1
 80121d4:	d1f3      	bne.n	80121be <HAL_QSPI_Command+0x96>
  while((__HAL_QSPI_GET_FLAG(hqspi, Flag)) != State)
 80121d6:	6893      	ldr	r3, [r2, #8]
 80121d8:	079b      	lsls	r3, r3, #30
 80121da:	d5fa      	bpl.n	80121d2 <HAL_QSPI_Command+0xaa>
          __HAL_QSPI_CLEAR_FLAG(hqspi, QSPI_FLAG_TC);
 80121dc:	2102      	movs	r1, #2
          hqspi->State = HAL_QSPI_STATE_READY;
 80121de:	2301      	movs	r3, #1
          __HAL_QSPI_CLEAR_FLAG(hqspi, QSPI_FLAG_TC);
 80121e0:	60d1      	str	r1, [r2, #12]
        status = QSPI_WaitFlagStateUntilTimeout(hqspi, QSPI_FLAG_TC, SET, tickstart, Timeout);
 80121e2:	f04f 0900 	mov.w	r9, #0
          hqspi->State = HAL_QSPI_STATE_READY;
 80121e6:	f885 3039 	strb.w	r3, [r5, #57]	; 0x39
 80121ea:	e7b3      	b.n	8012154 <HAL_QSPI_Command+0x2c>

080121ec <HAL_QSPI_AutoPolling>:
{
 80121ec:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 80121f0:	4604      	mov	r4, r0
 80121f2:	461d      	mov	r5, r3
 80121f4:	4688      	mov	r8, r1
 80121f6:	4617      	mov	r7, r2
  uint32_t tickstart = HAL_GetTick();
 80121f8:	f7fd fb1e 	bl	800f838 <HAL_GetTick>
  __HAL_LOCK(hqspi);
 80121fc:	f894 3038 	ldrb.w	r3, [r4, #56]	; 0x38
 8012200:	2b01      	cmp	r3, #1
 8012202:	d04c      	beq.n	801229e <HAL_QSPI_AutoPolling+0xb2>
 8012204:	2301      	movs	r3, #1
 8012206:	f884 3038 	strb.w	r3, [r4, #56]	; 0x38
  if(hqspi->State == HAL_QSPI_STATE_READY)
 801220a:	f894 3039 	ldrb.w	r3, [r4, #57]	; 0x39
 801220e:	2b01      	cmp	r3, #1
 8012210:	fa5f fa83 	uxtb.w	sl, r3
 8012214:	d007      	beq.n	8012226 <HAL_QSPI_AutoPolling+0x3a>
    status = HAL_BUSY;
 8012216:	f04f 0a02 	mov.w	sl, #2
  __HAL_UNLOCK(hqspi);
 801221a:	2300      	movs	r3, #0
 801221c:	f884 3038 	strb.w	r3, [r4, #56]	; 0x38
}
 8012220:	4650      	mov	r0, sl
 8012222:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    hqspi->ErrorCode = HAL_QSPI_ERROR_NONE;
 8012226:	2300      	movs	r3, #0
 8012228:	63e3      	str	r3, [r4, #60]	; 0x3c
    hqspi->State = HAL_QSPI_STATE_BUSY_AUTO_POLLING;
 801222a:	2342      	movs	r3, #66	; 0x42
 801222c:	4681      	mov	r9, r0
 801222e:	f884 3039 	strb.w	r3, [r4, #57]	; 0x39
  while((__HAL_QSPI_GET_FLAG(hqspi, Flag)) != State)
 8012232:	6826      	ldr	r6, [r4, #0]
 8012234:	e001      	b.n	801223a <HAL_QSPI_AutoPolling+0x4e>
    if (Timeout != HAL_MAX_DELAY)
 8012236:	1c6b      	adds	r3, r5, #1
 8012238:	d128      	bne.n	801228c <HAL_QSPI_AutoPolling+0xa0>
  while((__HAL_QSPI_GET_FLAG(hqspi, Flag)) != State)
 801223a:	68b3      	ldr	r3, [r6, #8]
 801223c:	0698      	lsls	r0, r3, #26
 801223e:	d4fa      	bmi.n	8012236 <HAL_QSPI_AutoPolling+0x4a>
      WRITE_REG(hqspi->Instance->PSMAR, cfg->Match);
 8012240:	683b      	ldr	r3, [r7, #0]
 8012242:	62b3      	str	r3, [r6, #40]	; 0x28
      WRITE_REG(hqspi->Instance->PSMKR, cfg->Mask);
 8012244:	687b      	ldr	r3, [r7, #4]
 8012246:	6273      	str	r3, [r6, #36]	; 0x24
      WRITE_REG(hqspi->Instance->PIR, cfg->Interval);
 8012248:	68bb      	ldr	r3, [r7, #8]
 801224a:	62f3      	str	r3, [r6, #44]	; 0x2c
      MODIFY_REG(hqspi->Instance->CR, (QUADSPI_CR_PMM | QUADSPI_CR_APMS),
 801224c:	6832      	ldr	r2, [r6, #0]
 801224e:	693b      	ldr	r3, [r7, #16]
 8012250:	f422 0240 	bic.w	r2, r2, #12582912	; 0xc00000
 8012254:	4313      	orrs	r3, r2
 8012256:	f443 0380 	orr.w	r3, r3, #4194304	; 0x400000
      cmd->NbData = cfg->StatusBytesSize;
 801225a:	68fa      	ldr	r2, [r7, #12]
      MODIFY_REG(hqspi->Instance->CR, (QUADSPI_CR_PMM | QUADSPI_CR_APMS),
 801225c:	6033      	str	r3, [r6, #0]
      QSPI_Config(hqspi, cmd, QSPI_FUNCTIONAL_MODE_AUTO_POLLING);
 801225e:	4641      	mov	r1, r8
      cmd->NbData = cfg->StatusBytesSize;
 8012260:	f8c8 2028 	str.w	r2, [r8, #40]	; 0x28
      QSPI_Config(hqspi, cmd, QSPI_FUNCTIONAL_MODE_AUTO_POLLING);
 8012264:	4620      	mov	r0, r4
 8012266:	f04f 6200 	mov.w	r2, #134217728	; 0x8000000
 801226a:	f7ff fe41 	bl	8011ef0 <QSPI_Config>
  while((__HAL_QSPI_GET_FLAG(hqspi, Flag)) != State)
 801226e:	6822      	ldr	r2, [r4, #0]
 8012270:	e001      	b.n	8012276 <HAL_QSPI_AutoPolling+0x8a>
    if (Timeout != HAL_MAX_DELAY)
 8012272:	1c69      	adds	r1, r5, #1
 8012274:	d118      	bne.n	80122a8 <HAL_QSPI_AutoPolling+0xbc>
  while((__HAL_QSPI_GET_FLAG(hqspi, Flag)) != State)
 8012276:	6893      	ldr	r3, [r2, #8]
 8012278:	071b      	lsls	r3, r3, #28
 801227a:	d5fa      	bpl.n	8012272 <HAL_QSPI_AutoPolling+0x86>
        __HAL_QSPI_CLEAR_FLAG(hqspi, QSPI_FLAG_SM);
 801227c:	2108      	movs	r1, #8
        hqspi->State = HAL_QSPI_STATE_READY;
 801227e:	2301      	movs	r3, #1
        __HAL_QSPI_CLEAR_FLAG(hqspi, QSPI_FLAG_SM);
 8012280:	60d1      	str	r1, [r2, #12]
      status = QSPI_WaitFlagStateUntilTimeout(hqspi, QSPI_FLAG_SM, SET, tickstart, Timeout);
 8012282:	f04f 0a00 	mov.w	sl, #0
        hqspi->State = HAL_QSPI_STATE_READY;
 8012286:	f884 3039 	strb.w	r3, [r4, #57]	; 0x39
 801228a:	e7c6      	b.n	801221a <HAL_QSPI_AutoPolling+0x2e>
      if(((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
 801228c:	f7fd fad4 	bl	800f838 <HAL_GetTick>
 8012290:	eba0 0009 	sub.w	r0, r0, r9
 8012294:	4285      	cmp	r5, r0
 8012296:	d30f      	bcc.n	80122b8 <HAL_QSPI_AutoPolling+0xcc>
 8012298:	2d00      	cmp	r5, #0
 801229a:	d1ca      	bne.n	8012232 <HAL_QSPI_AutoPolling+0x46>
 801229c:	e00c      	b.n	80122b8 <HAL_QSPI_AutoPolling+0xcc>
  __HAL_LOCK(hqspi);
 801229e:	f04f 0a02 	mov.w	sl, #2
}
 80122a2:	4650      	mov	r0, sl
 80122a4:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
      if(((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
 80122a8:	f7fd fac6 	bl	800f838 <HAL_GetTick>
 80122ac:	eba0 0009 	sub.w	r0, r0, r9
 80122b0:	4285      	cmp	r5, r0
 80122b2:	d301      	bcc.n	80122b8 <HAL_QSPI_AutoPolling+0xcc>
 80122b4:	2d00      	cmp	r5, #0
 80122b6:	d1da      	bne.n	801226e <HAL_QSPI_AutoPolling+0x82>
        hqspi->State     = HAL_QSPI_STATE_ERROR;
 80122b8:	2304      	movs	r3, #4
 80122ba:	f884 3039 	strb.w	r3, [r4, #57]	; 0x39
        hqspi->ErrorCode |= HAL_QSPI_ERROR_TIMEOUT;
 80122be:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 80122c0:	f043 0301 	orr.w	r3, r3, #1
 80122c4:	63e3      	str	r3, [r4, #60]	; 0x3c
      if (status == HAL_OK)
 80122c6:	e7a8      	b.n	801221a <HAL_QSPI_AutoPolling+0x2e>

080122c8 <HAL_QSPI_Abort>:
{
 80122c8:	b570      	push	{r4, r5, r6, lr}
 80122ca:	4605      	mov	r5, r0
  uint32_t tickstart = HAL_GetTick();
 80122cc:	f7fd fab4 	bl	800f838 <HAL_GetTick>
  if (((uint32_t)hqspi->State & 0x2U) != 0U)
 80122d0:	f895 3039 	ldrb.w	r3, [r5, #57]	; 0x39
 80122d4:	f013 0302 	ands.w	r3, r3, #2
 80122d8:	d023      	beq.n	8012322 <HAL_QSPI_Abort+0x5a>
    __HAL_UNLOCK(hqspi);
 80122da:	2300      	movs	r3, #0
    if ((hqspi->Instance->CR & QUADSPI_CR_DMAEN) != 0U)
 80122dc:	682a      	ldr	r2, [r5, #0]
    __HAL_UNLOCK(hqspi);
 80122de:	f885 3038 	strb.w	r3, [r5, #56]	; 0x38
    if ((hqspi->Instance->CR & QUADSPI_CR_DMAEN) != 0U)
 80122e2:	6813      	ldr	r3, [r2, #0]
 80122e4:	075c      	lsls	r4, r3, #29
 80122e6:	4606      	mov	r6, r0
 80122e8:	d425      	bmi.n	8012336 <HAL_QSPI_Abort+0x6e>
    SET_BIT(hqspi->Instance->CR, QUADSPI_CR_ABORT);
 80122ea:	6813      	ldr	r3, [r2, #0]
    status = QSPI_WaitFlagStateUntilTimeout(hqspi, QSPI_FLAG_TC, SET, tickstart, hqspi->Timeout);
 80122ec:	6c2c      	ldr	r4, [r5, #64]	; 0x40
    SET_BIT(hqspi->Instance->CR, QUADSPI_CR_ABORT);
 80122ee:	f043 0302 	orr.w	r3, r3, #2
 80122f2:	6013      	str	r3, [r2, #0]
  while((__HAL_QSPI_GET_FLAG(hqspi, Flag)) != State)
 80122f4:	e001      	b.n	80122fa <HAL_QSPI_Abort+0x32>
    if (Timeout != HAL_MAX_DELAY)
 80122f6:	1c60      	adds	r0, r4, #1
 80122f8:	d115      	bne.n	8012326 <HAL_QSPI_Abort+0x5e>
  while((__HAL_QSPI_GET_FLAG(hqspi, Flag)) != State)
 80122fa:	6893      	ldr	r3, [r2, #8]
 80122fc:	0799      	lsls	r1, r3, #30
 80122fe:	d5fa      	bpl.n	80122f6 <HAL_QSPI_Abort+0x2e>
      __HAL_QSPI_CLEAR_FLAG(hqspi, QSPI_FLAG_TC);
 8012300:	2302      	movs	r3, #2
      status = QSPI_WaitFlagStateUntilTimeout(hqspi, QSPI_FLAG_BUSY, RESET, tickstart, hqspi->Timeout);
 8012302:	6c2c      	ldr	r4, [r5, #64]	; 0x40
      __HAL_QSPI_CLEAR_FLAG(hqspi, QSPI_FLAG_TC);
 8012304:	60d3      	str	r3, [r2, #12]
  while((__HAL_QSPI_GET_FLAG(hqspi, Flag)) != State)
 8012306:	e001      	b.n	801230c <HAL_QSPI_Abort+0x44>
    if (Timeout != HAL_MAX_DELAY)
 8012308:	1c63      	adds	r3, r4, #1
 801230a:	d11e      	bne.n	801234a <HAL_QSPI_Abort+0x82>
  while((__HAL_QSPI_GET_FLAG(hqspi, Flag)) != State)
 801230c:	6893      	ldr	r3, [r2, #8]
 801230e:	f013 0320 	ands.w	r3, r3, #32
 8012312:	d1f9      	bne.n	8012308 <HAL_QSPI_Abort+0x40>
      CLEAR_BIT(hqspi->Instance->CCR, QUADSPI_CCR_FMODE);
 8012314:	6951      	ldr	r1, [r2, #20]
      hqspi->State = HAL_QSPI_STATE_READY;
 8012316:	2001      	movs	r0, #1
      CLEAR_BIT(hqspi->Instance->CCR, QUADSPI_CCR_FMODE);
 8012318:	f021 6140 	bic.w	r1, r1, #201326592	; 0xc000000
 801231c:	6151      	str	r1, [r2, #20]
      hqspi->State = HAL_QSPI_STATE_READY;
 801231e:	f885 0039 	strb.w	r0, [r5, #57]	; 0x39
}
 8012322:	4618      	mov	r0, r3
 8012324:	bd70      	pop	{r4, r5, r6, pc}
      if(((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
 8012326:	f7fd fa87 	bl	800f838 <HAL_GetTick>
 801232a:	1b80      	subs	r0, r0, r6
 801232c:	4284      	cmp	r4, r0
 801232e:	d31a      	bcc.n	8012366 <HAL_QSPI_Abort+0x9e>
 8012330:	b1cc      	cbz	r4, 8012366 <HAL_QSPI_Abort+0x9e>
  while((__HAL_QSPI_GET_FLAG(hqspi, Flag)) != State)
 8012332:	682a      	ldr	r2, [r5, #0]
 8012334:	e7e1      	b.n	80122fa <HAL_QSPI_Abort+0x32>
      CLEAR_BIT(hqspi->Instance->CR, QUADSPI_CR_DMAEN);
 8012336:	6813      	ldr	r3, [r2, #0]
      status = HAL_DMA_Abort(hqspi->hdma);
 8012338:	6b68      	ldr	r0, [r5, #52]	; 0x34
      CLEAR_BIT(hqspi->Instance->CR, QUADSPI_CR_DMAEN);
 801233a:	f023 0304 	bic.w	r3, r3, #4
 801233e:	6013      	str	r3, [r2, #0]
      status = HAL_DMA_Abort(hqspi->hdma);
 8012340:	f7fe f83c 	bl	80103bc <HAL_DMA_Abort>
      if(status != HAL_OK)
 8012344:	b948      	cbnz	r0, 801235a <HAL_QSPI_Abort+0x92>
    SET_BIT(hqspi->Instance->CR, QUADSPI_CR_ABORT);
 8012346:	682a      	ldr	r2, [r5, #0]
 8012348:	e7cf      	b.n	80122ea <HAL_QSPI_Abort+0x22>
      if(((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
 801234a:	f7fd fa75 	bl	800f838 <HAL_GetTick>
 801234e:	1b80      	subs	r0, r0, r6
 8012350:	4284      	cmp	r4, r0
 8012352:	d308      	bcc.n	8012366 <HAL_QSPI_Abort+0x9e>
 8012354:	b13c      	cbz	r4, 8012366 <HAL_QSPI_Abort+0x9e>
  while((__HAL_QSPI_GET_FLAG(hqspi, Flag)) != State)
 8012356:	682a      	ldr	r2, [r5, #0]
 8012358:	e7d8      	b.n	801230c <HAL_QSPI_Abort+0x44>
        hqspi->ErrorCode |= HAL_QSPI_ERROR_DMA;
 801235a:	6beb      	ldr	r3, [r5, #60]	; 0x3c
    SET_BIT(hqspi->Instance->CR, QUADSPI_CR_ABORT);
 801235c:	682a      	ldr	r2, [r5, #0]
        hqspi->ErrorCode |= HAL_QSPI_ERROR_DMA;
 801235e:	f043 0304 	orr.w	r3, r3, #4
 8012362:	63eb      	str	r3, [r5, #60]	; 0x3c
 8012364:	e7c1      	b.n	80122ea <HAL_QSPI_Abort+0x22>
        hqspi->State     = HAL_QSPI_STATE_ERROR;
 8012366:	2304      	movs	r3, #4
 8012368:	f885 3039 	strb.w	r3, [r5, #57]	; 0x39
        hqspi->ErrorCode |= HAL_QSPI_ERROR_TIMEOUT;
 801236c:	6bea      	ldr	r2, [r5, #60]	; 0x3c
 801236e:	2301      	movs	r3, #1
 8012370:	431a      	orrs	r2, r3
 8012372:	63ea      	str	r2, [r5, #60]	; 0x3c
    if (status == HAL_OK)
 8012374:	e7d5      	b.n	8012322 <HAL_QSPI_Abort+0x5a>
 8012376:	bf00      	nop

08012378 <HAL_QSPI_Transmit>:
{
 8012378:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 801237c:	4605      	mov	r5, r0
 801237e:	4689      	mov	r9, r1
 8012380:	4614      	mov	r4, r2
  uint32_t tickstart = HAL_GetTick();
 8012382:	f7fd fa59 	bl	800f838 <HAL_GetTick>
  __HAL_LOCK(hqspi);
 8012386:	f895 3038 	ldrb.w	r3, [r5, #56]	; 0x38
  __IO uint32_t *data_reg = &hqspi->Instance->DR;
 801238a:	682f      	ldr	r7, [r5, #0]
  __HAL_LOCK(hqspi);
 801238c:	2b01      	cmp	r3, #1
 801238e:	d065      	beq.n	801245c <HAL_QSPI_Transmit+0xe4>
 8012390:	2301      	movs	r3, #1
 8012392:	f885 3038 	strb.w	r3, [r5, #56]	; 0x38
  if(hqspi->State == HAL_QSPI_STATE_READY)
 8012396:	f895 3039 	ldrb.w	r3, [r5, #57]	; 0x39
 801239a:	2b01      	cmp	r3, #1
 801239c:	fa5f f883 	uxtb.w	r8, r3
 80123a0:	d007      	beq.n	80123b2 <HAL_QSPI_Transmit+0x3a>
    status = HAL_BUSY;
 80123a2:	f04f 0802 	mov.w	r8, #2
  __HAL_UNLOCK(hqspi);
 80123a6:	2300      	movs	r3, #0
 80123a8:	f885 3038 	strb.w	r3, [r5, #56]	; 0x38
}
 80123ac:	4640      	mov	r0, r8
 80123ae:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    hqspi->ErrorCode = HAL_QSPI_ERROR_NONE;
 80123b2:	2300      	movs	r3, #0
 80123b4:	63eb      	str	r3, [r5, #60]	; 0x3c
    if(pData != NULL )
 80123b6:	f1b9 0f00 	cmp.w	r9, #0
 80123ba:	d054      	beq.n	8012466 <HAL_QSPI_Transmit+0xee>
      hqspi->State = HAL_QSPI_STATE_BUSY_INDIRECT_TX;
 80123bc:	2312      	movs	r3, #18
 80123be:	f885 3039 	strb.w	r3, [r5, #57]	; 0x39
      hqspi->TxXferCount = READ_REG(hqspi->Instance->DLR) + 1U;
 80123c2:	693b      	ldr	r3, [r7, #16]
 80123c4:	3301      	adds	r3, #1
 80123c6:	626b      	str	r3, [r5, #36]	; 0x24
      hqspi->TxXferSize = READ_REG(hqspi->Instance->DLR) + 1U;
 80123c8:	693b      	ldr	r3, [r7, #16]
      hqspi->pTxBuffPtr = pData;
 80123ca:	f8c5 901c 	str.w	r9, [r5, #28]
      hqspi->TxXferSize = READ_REG(hqspi->Instance->DLR) + 1U;
 80123ce:	3301      	adds	r3, #1
 80123d0:	622b      	str	r3, [r5, #32]
      MODIFY_REG(hqspi->Instance->CCR, QUADSPI_CCR_FMODE, QSPI_FUNCTIONAL_MODE_INDIRECT_WRITE);
 80123d2:	697b      	ldr	r3, [r7, #20]
 80123d4:	f023 6340 	bic.w	r3, r3, #201326592	; 0xc000000
 80123d8:	617b      	str	r3, [r7, #20]
      while(hqspi->TxXferCount > 0U)
 80123da:	6a6b      	ldr	r3, [r5, #36]	; 0x24
 80123dc:	4606      	mov	r6, r0
 80123de:	463a      	mov	r2, r7
 80123e0:	b1bb      	cbz	r3, 8012412 <HAL_QSPI_Transmit+0x9a>
  while((__HAL_QSPI_GET_FLAG(hqspi, Flag)) != State)
 80123e2:	6893      	ldr	r3, [r2, #8]
 80123e4:	0759      	lsls	r1, r3, #29
 80123e6:	d404      	bmi.n	80123f2 <HAL_QSPI_Transmit+0x7a>
    if (Timeout != HAL_MAX_DELAY)
 80123e8:	1c60      	adds	r0, r4, #1
 80123ea:	d11f      	bne.n	801242c <HAL_QSPI_Transmit+0xb4>
  while((__HAL_QSPI_GET_FLAG(hqspi, Flag)) != State)
 80123ec:	6893      	ldr	r3, [r2, #8]
 80123ee:	0759      	lsls	r1, r3, #29
 80123f0:	d5fa      	bpl.n	80123e8 <HAL_QSPI_Transmit+0x70>
        *((__IO uint8_t *)data_reg) = *hqspi->pTxBuffPtr;
 80123f2:	69eb      	ldr	r3, [r5, #28]
 80123f4:	781b      	ldrb	r3, [r3, #0]
 80123f6:	f887 3020 	strb.w	r3, [r7, #32]
        hqspi->TxXferCount--;
 80123fa:	6a6a      	ldr	r2, [r5, #36]	; 0x24
        hqspi->pTxBuffPtr++;
 80123fc:	69eb      	ldr	r3, [r5, #28]
        hqspi->TxXferCount--;
 80123fe:	3a01      	subs	r2, #1
 8012400:	626a      	str	r2, [r5, #36]	; 0x24
      while(hqspi->TxXferCount > 0U)
 8012402:	6a6a      	ldr	r2, [r5, #36]	; 0x24
        hqspi->pTxBuffPtr++;
 8012404:	3301      	adds	r3, #1
 8012406:	61eb      	str	r3, [r5, #28]
      while(hqspi->TxXferCount > 0U)
 8012408:	b332      	cbz	r2, 8012458 <HAL_QSPI_Transmit+0xe0>
  while((__HAL_QSPI_GET_FLAG(hqspi, Flag)) != State)
 801240a:	682a      	ldr	r2, [r5, #0]
 801240c:	e7ee      	b.n	80123ec <HAL_QSPI_Transmit+0x74>
    if (Timeout != HAL_MAX_DELAY)
 801240e:	1c62      	adds	r2, r4, #1
 8012410:	d11b      	bne.n	801244a <HAL_QSPI_Transmit+0xd2>
  while((__HAL_QSPI_GET_FLAG(hqspi, Flag)) != State)
 8012412:	68bb      	ldr	r3, [r7, #8]
 8012414:	079b      	lsls	r3, r3, #30
 8012416:	d5fa      	bpl.n	801240e <HAL_QSPI_Transmit+0x96>
          __HAL_QSPI_CLEAR_FLAG(hqspi, QSPI_FLAG_TC);
 8012418:	2302      	movs	r3, #2
 801241a:	60fb      	str	r3, [r7, #12]
          status = HAL_QSPI_Abort(hqspi);
 801241c:	4628      	mov	r0, r5
 801241e:	f7ff ff53 	bl	80122c8 <HAL_QSPI_Abort>
 8012422:	4680      	mov	r8, r0
      hqspi->State = HAL_QSPI_STATE_READY;
 8012424:	2301      	movs	r3, #1
 8012426:	f885 3039 	strb.w	r3, [r5, #57]	; 0x39
 801242a:	e7bc      	b.n	80123a6 <HAL_QSPI_Transmit+0x2e>
      if(((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
 801242c:	f7fd fa04 	bl	800f838 <HAL_GetTick>
 8012430:	1b80      	subs	r0, r0, r6
 8012432:	4284      	cmp	r4, r0
 8012434:	d301      	bcc.n	801243a <HAL_QSPI_Transmit+0xc2>
 8012436:	2c00      	cmp	r4, #0
 8012438:	d1e7      	bne.n	801240a <HAL_QSPI_Transmit+0x92>
        hqspi->State     = HAL_QSPI_STATE_ERROR;
 801243a:	2304      	movs	r3, #4
 801243c:	f885 3039 	strb.w	r3, [r5, #57]	; 0x39
        hqspi->ErrorCode |= HAL_QSPI_ERROR_TIMEOUT;
 8012440:	6beb      	ldr	r3, [r5, #60]	; 0x3c
 8012442:	f043 0301 	orr.w	r3, r3, #1
 8012446:	63eb      	str	r3, [r5, #60]	; 0x3c
        if (status == HAL_OK)
 8012448:	e7ec      	b.n	8012424 <HAL_QSPI_Transmit+0xac>
      if(((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
 801244a:	f7fd f9f5 	bl	800f838 <HAL_GetTick>
 801244e:	1b80      	subs	r0, r0, r6
 8012450:	4284      	cmp	r4, r0
 8012452:	d3f2      	bcc.n	801243a <HAL_QSPI_Transmit+0xc2>
 8012454:	2c00      	cmp	r4, #0
 8012456:	d0f0      	beq.n	801243a <HAL_QSPI_Transmit+0xc2>
  while((__HAL_QSPI_GET_FLAG(hqspi, Flag)) != State)
 8012458:	682f      	ldr	r7, [r5, #0]
 801245a:	e7da      	b.n	8012412 <HAL_QSPI_Transmit+0x9a>
  __HAL_LOCK(hqspi);
 801245c:	f04f 0802 	mov.w	r8, #2
}
 8012460:	4640      	mov	r0, r8
 8012462:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
      hqspi->ErrorCode |= HAL_QSPI_ERROR_INVALID_PARAM;
 8012466:	6beb      	ldr	r3, [r5, #60]	; 0x3c
 8012468:	f043 0308 	orr.w	r3, r3, #8
 801246c:	63eb      	str	r3, [r5, #60]	; 0x3c
      status = HAL_ERROR;
 801246e:	e79a      	b.n	80123a6 <HAL_QSPI_Transmit+0x2e>

08012470 <HAL_QSPI_Receive>:
{
 8012470:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8012474:	4605      	mov	r5, r0
 8012476:	4614      	mov	r4, r2
 8012478:	4689      	mov	r9, r1
  uint32_t tickstart = HAL_GetTick();
 801247a:	f7fd f9dd 	bl	800f838 <HAL_GetTick>
  uint32_t addr_reg = READ_REG(hqspi->Instance->AR);
 801247e:	682f      	ldr	r7, [r5, #0]
 8012480:	69ba      	ldr	r2, [r7, #24]
  __HAL_LOCK(hqspi);
 8012482:	f895 3038 	ldrb.w	r3, [r5, #56]	; 0x38
 8012486:	2b01      	cmp	r3, #1
 8012488:	d06a      	beq.n	8012560 <HAL_QSPI_Receive+0xf0>
 801248a:	2301      	movs	r3, #1
 801248c:	f885 3038 	strb.w	r3, [r5, #56]	; 0x38
  if(hqspi->State == HAL_QSPI_STATE_READY)
 8012490:	f895 3039 	ldrb.w	r3, [r5, #57]	; 0x39
 8012494:	2b01      	cmp	r3, #1
 8012496:	fa5f f883 	uxtb.w	r8, r3
 801249a:	d007      	beq.n	80124ac <HAL_QSPI_Receive+0x3c>
    status = HAL_BUSY;
 801249c:	f04f 0802 	mov.w	r8, #2
  __HAL_UNLOCK(hqspi);
 80124a0:	2300      	movs	r3, #0
 80124a2:	f885 3038 	strb.w	r3, [r5, #56]	; 0x38
}
 80124a6:	4640      	mov	r0, r8
 80124a8:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    hqspi->ErrorCode = HAL_QSPI_ERROR_NONE;
 80124ac:	2300      	movs	r3, #0
 80124ae:	63eb      	str	r3, [r5, #60]	; 0x3c
    if(pData != NULL )
 80124b0:	f1b9 0f00 	cmp.w	r9, #0
 80124b4:	d059      	beq.n	801256a <HAL_QSPI_Receive+0xfa>
      hqspi->State = HAL_QSPI_STATE_BUSY_INDIRECT_RX;
 80124b6:	2322      	movs	r3, #34	; 0x22
 80124b8:	f885 3039 	strb.w	r3, [r5, #57]	; 0x39
      hqspi->RxXferCount = READ_REG(hqspi->Instance->DLR) + 1U;
 80124bc:	693b      	ldr	r3, [r7, #16]
 80124be:	3301      	adds	r3, #1
 80124c0:	632b      	str	r3, [r5, #48]	; 0x30
      hqspi->RxXferSize = READ_REG(hqspi->Instance->DLR) + 1U;
 80124c2:	693b      	ldr	r3, [r7, #16]
      hqspi->pRxBuffPtr = pData;
 80124c4:	f8c5 9028 	str.w	r9, [r5, #40]	; 0x28
      hqspi->RxXferSize = READ_REG(hqspi->Instance->DLR) + 1U;
 80124c8:	3301      	adds	r3, #1
 80124ca:	62eb      	str	r3, [r5, #44]	; 0x2c
      MODIFY_REG(hqspi->Instance->CCR, QUADSPI_CCR_FMODE, QSPI_FUNCTIONAL_MODE_INDIRECT_READ);
 80124cc:	697b      	ldr	r3, [r7, #20]
 80124ce:	f023 6340 	bic.w	r3, r3, #201326592	; 0xc000000
 80124d2:	f043 6380 	orr.w	r3, r3, #67108864	; 0x4000000
 80124d6:	617b      	str	r3, [r7, #20]
      WRITE_REG(hqspi->Instance->AR, addr_reg);
 80124d8:	61ba      	str	r2, [r7, #24]
      while(hqspi->RxXferCount > 0U)
 80124da:	6b2b      	ldr	r3, [r5, #48]	; 0x30
 80124dc:	4606      	mov	r6, r0
 80124de:	463a      	mov	r2, r7
 80124e0:	b1cb      	cbz	r3, 8012516 <HAL_QSPI_Receive+0xa6>
  while((__HAL_QSPI_GET_FLAG(hqspi, Flag)) != State)
 80124e2:	6893      	ldr	r3, [r2, #8]
 80124e4:	f013 0f06 	tst.w	r3, #6
 80124e8:	d105      	bne.n	80124f6 <HAL_QSPI_Receive+0x86>
    if (Timeout != HAL_MAX_DELAY)
 80124ea:	1c61      	adds	r1, r4, #1
 80124ec:	d120      	bne.n	8012530 <HAL_QSPI_Receive+0xc0>
  while((__HAL_QSPI_GET_FLAG(hqspi, Flag)) != State)
 80124ee:	6893      	ldr	r3, [r2, #8]
 80124f0:	f013 0f06 	tst.w	r3, #6
 80124f4:	d0f9      	beq.n	80124ea <HAL_QSPI_Receive+0x7a>
        *hqspi->pRxBuffPtr = *((__IO uint8_t *)data_reg);
 80124f6:	6aab      	ldr	r3, [r5, #40]	; 0x28
 80124f8:	f897 2020 	ldrb.w	r2, [r7, #32]
 80124fc:	701a      	strb	r2, [r3, #0]
        hqspi->RxXferCount--;
 80124fe:	6b2a      	ldr	r2, [r5, #48]	; 0x30
        hqspi->pRxBuffPtr++;
 8012500:	6aab      	ldr	r3, [r5, #40]	; 0x28
        hqspi->RxXferCount--;
 8012502:	3a01      	subs	r2, #1
 8012504:	632a      	str	r2, [r5, #48]	; 0x30
      while(hqspi->RxXferCount > 0U)
 8012506:	6b2a      	ldr	r2, [r5, #48]	; 0x30
        hqspi->pRxBuffPtr++;
 8012508:	3301      	adds	r3, #1
 801250a:	62ab      	str	r3, [r5, #40]	; 0x28
      while(hqspi->RxXferCount > 0U)
 801250c:	b332      	cbz	r2, 801255c <HAL_QSPI_Receive+0xec>
  while((__HAL_QSPI_GET_FLAG(hqspi, Flag)) != State)
 801250e:	682a      	ldr	r2, [r5, #0]
 8012510:	e7ed      	b.n	80124ee <HAL_QSPI_Receive+0x7e>
    if (Timeout != HAL_MAX_DELAY)
 8012512:	1c62      	adds	r2, r4, #1
 8012514:	d11b      	bne.n	801254e <HAL_QSPI_Receive+0xde>
  while((__HAL_QSPI_GET_FLAG(hqspi, Flag)) != State)
 8012516:	68bb      	ldr	r3, [r7, #8]
 8012518:	079b      	lsls	r3, r3, #30
 801251a:	d5fa      	bpl.n	8012512 <HAL_QSPI_Receive+0xa2>
          __HAL_QSPI_CLEAR_FLAG(hqspi, QSPI_FLAG_TC);
 801251c:	2302      	movs	r3, #2
 801251e:	60fb      	str	r3, [r7, #12]
          status = HAL_QSPI_Abort(hqspi);
 8012520:	4628      	mov	r0, r5
 8012522:	f7ff fed1 	bl	80122c8 <HAL_QSPI_Abort>
 8012526:	4680      	mov	r8, r0
      hqspi->State = HAL_QSPI_STATE_READY;
 8012528:	2301      	movs	r3, #1
 801252a:	f885 3039 	strb.w	r3, [r5, #57]	; 0x39
 801252e:	e7b7      	b.n	80124a0 <HAL_QSPI_Receive+0x30>
      if(((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
 8012530:	f7fd f982 	bl	800f838 <HAL_GetTick>
 8012534:	1b80      	subs	r0, r0, r6
 8012536:	4284      	cmp	r4, r0
 8012538:	d301      	bcc.n	801253e <HAL_QSPI_Receive+0xce>
 801253a:	2c00      	cmp	r4, #0
 801253c:	d1e7      	bne.n	801250e <HAL_QSPI_Receive+0x9e>
        hqspi->State     = HAL_QSPI_STATE_ERROR;
 801253e:	2304      	movs	r3, #4
 8012540:	f885 3039 	strb.w	r3, [r5, #57]	; 0x39
        hqspi->ErrorCode |= HAL_QSPI_ERROR_TIMEOUT;
 8012544:	6beb      	ldr	r3, [r5, #60]	; 0x3c
 8012546:	f043 0301 	orr.w	r3, r3, #1
 801254a:	63eb      	str	r3, [r5, #60]	; 0x3c
        if  (status == HAL_OK)
 801254c:	e7ec      	b.n	8012528 <HAL_QSPI_Receive+0xb8>
      if(((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
 801254e:	f7fd f973 	bl	800f838 <HAL_GetTick>
 8012552:	1b80      	subs	r0, r0, r6
 8012554:	4284      	cmp	r4, r0
 8012556:	d3f2      	bcc.n	801253e <HAL_QSPI_Receive+0xce>
 8012558:	2c00      	cmp	r4, #0
 801255a:	d0f0      	beq.n	801253e <HAL_QSPI_Receive+0xce>
  while((__HAL_QSPI_GET_FLAG(hqspi, Flag)) != State)
 801255c:	682f      	ldr	r7, [r5, #0]
 801255e:	e7da      	b.n	8012516 <HAL_QSPI_Receive+0xa6>
  __HAL_LOCK(hqspi);
 8012560:	f04f 0802 	mov.w	r8, #2
}
 8012564:	4640      	mov	r0, r8
 8012566:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
      hqspi->ErrorCode |= HAL_QSPI_ERROR_INVALID_PARAM;
 801256a:	6beb      	ldr	r3, [r5, #60]	; 0x3c
 801256c:	f043 0308 	orr.w	r3, r3, #8
 8012570:	63eb      	str	r3, [r5, #60]	; 0x3c
      status = HAL_ERROR;
 8012572:	e795      	b.n	80124a0 <HAL_QSPI_Receive+0x30>

08012574 <RCC_SetFlashLatencyFromMSIRange>:
            voltage range.
  * @param  msirange  MSI range value from RCC_MSIRANGE_0 to RCC_MSIRANGE_11
  * @retval HAL status
  */
static HAL_StatusTypeDef RCC_SetFlashLatencyFromMSIRange(uint32_t msirange)
{
 8012574:	b530      	push	{r4, r5, lr}
  uint32_t vos;
  uint32_t latency = FLASH_LATENCY_0;  /* default value 0WS */

  if(__HAL_RCC_PWR_IS_CLK_ENABLED())
 8012576:	4d20      	ldr	r5, [pc, #128]	; (80125f8 <RCC_SetFlashLatencyFromMSIRange+0x84>)
 8012578:	6dab      	ldr	r3, [r5, #88]	; 0x58
 801257a:	00db      	lsls	r3, r3, #3
{
 801257c:	b083      	sub	sp, #12
 801257e:	4604      	mov	r4, r0
  if(__HAL_RCC_PWR_IS_CLK_ENABLED())
 8012580:	d51c      	bpl.n	80125bc <RCC_SetFlashLatencyFromMSIRange+0x48>
  {
    vos = HAL_PWREx_GetVoltageRange();
 8012582:	f7ff fca5 	bl	8011ed0 <HAL_PWREx_GetVoltageRange>
    __HAL_RCC_PWR_CLK_ENABLE();
    vos = HAL_PWREx_GetVoltageRange();
    __HAL_RCC_PWR_CLK_DISABLE();
  }

  if(vos == PWR_REGULATOR_VOLTAGE_SCALE1)
 8012586:	f5b0 7f00 	cmp.w	r0, #512	; 0x200
 801258a:	d029      	beq.n	80125e0 <RCC_SetFlashLatencyFromMSIRange+0x6c>
        latency = FLASH_LATENCY_1; /* 1WS */
      }
      /* else MSI < 8Mhz default FLASH_LATENCY_0 0WS */
    }
#else
    if(msirange > RCC_MSIRANGE_8)
 801258c:	2c80      	cmp	r4, #128	; 0x80
 801258e:	d813      	bhi.n	80125b8 <RCC_SetFlashLatencyFromMSIRange+0x44>
      /* MSI > 16Mhz */
      latency = FLASH_LATENCY_3; /* 3WS */
    }
    else
    {
      if(msirange == RCC_MSIRANGE_8)
 8012590:	d02f      	beq.n	80125f2 <RCC_SetFlashLatencyFromMSIRange+0x7e>
      {
        /* MSI 16Mhz */
        latency = FLASH_LATENCY_2; /* 2WS */
      }
      else if(msirange == RCC_MSIRANGE_7)
 8012592:	f1a4 0470 	sub.w	r4, r4, #112	; 0x70
 8012596:	fab4 f484 	clz	r4, r4
 801259a:	0964      	lsrs	r4, r4, #5
      /* else MSI < 8Mhz default FLASH_LATENCY_0 0WS */
    }
#endif
  }

  __HAL_FLASH_SET_LATENCY(latency);
 801259c:	4917      	ldr	r1, [pc, #92]	; (80125fc <RCC_SetFlashLatencyFromMSIRange+0x88>)
 801259e:	680b      	ldr	r3, [r1, #0]
 80125a0:	f023 0307 	bic.w	r3, r3, #7
 80125a4:	4323      	orrs	r3, r4
 80125a6:	600b      	str	r3, [r1, #0]

  /* Check that the new number of wait states is taken into account to access the Flash
     memory by reading the FLASH_ACR register */
  if(__HAL_FLASH_GET_LATENCY() != latency)
 80125a8:	6808      	ldr	r0, [r1, #0]
 80125aa:	f000 0007 	and.w	r0, r0, #7
  {
    return HAL_ERROR;
  }

  return HAL_OK;
}
 80125ae:	1b00      	subs	r0, r0, r4
 80125b0:	bf18      	it	ne
 80125b2:	2001      	movne	r0, #1
 80125b4:	b003      	add	sp, #12
 80125b6:	bd30      	pop	{r4, r5, pc}
      latency = FLASH_LATENCY_3; /* 3WS */
 80125b8:	2403      	movs	r4, #3
 80125ba:	e7ef      	b.n	801259c <RCC_SetFlashLatencyFromMSIRange+0x28>
    __HAL_RCC_PWR_CLK_ENABLE();
 80125bc:	6dab      	ldr	r3, [r5, #88]	; 0x58
 80125be:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 80125c2:	65ab      	str	r3, [r5, #88]	; 0x58
 80125c4:	6dab      	ldr	r3, [r5, #88]	; 0x58
 80125c6:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 80125ca:	9301      	str	r3, [sp, #4]
 80125cc:	9b01      	ldr	r3, [sp, #4]
    vos = HAL_PWREx_GetVoltageRange();
 80125ce:	f7ff fc7f 	bl	8011ed0 <HAL_PWREx_GetVoltageRange>
    __HAL_RCC_PWR_CLK_DISABLE();
 80125d2:	6dab      	ldr	r3, [r5, #88]	; 0x58
  if(vos == PWR_REGULATOR_VOLTAGE_SCALE1)
 80125d4:	f5b0 7f00 	cmp.w	r0, #512	; 0x200
    __HAL_RCC_PWR_CLK_DISABLE();
 80125d8:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
 80125dc:	65ab      	str	r3, [r5, #88]	; 0x58
  if(vos == PWR_REGULATOR_VOLTAGE_SCALE1)
 80125de:	d1d5      	bne.n	801258c <RCC_SetFlashLatencyFromMSIRange+0x18>
    if(msirange > RCC_MSIRANGE_8)
 80125e0:	2c80      	cmp	r4, #128	; 0x80
 80125e2:	d904      	bls.n	80125ee <RCC_SetFlashLatencyFromMSIRange+0x7a>
        latency = FLASH_LATENCY_1; /* 1WS */
 80125e4:	2ca0      	cmp	r4, #160	; 0xa0
 80125e6:	bf8c      	ite	hi
 80125e8:	2402      	movhi	r4, #2
 80125ea:	2401      	movls	r4, #1
 80125ec:	e7d6      	b.n	801259c <RCC_SetFlashLatencyFromMSIRange+0x28>
  uint32_t latency = FLASH_LATENCY_0;  /* default value 0WS */
 80125ee:	2400      	movs	r4, #0
 80125f0:	e7d4      	b.n	801259c <RCC_SetFlashLatencyFromMSIRange+0x28>
        latency = FLASH_LATENCY_2; /* 2WS */
 80125f2:	2402      	movs	r4, #2
 80125f4:	e7d2      	b.n	801259c <RCC_SetFlashLatencyFromMSIRange+0x28>
 80125f6:	bf00      	nop
 80125f8:	40021000 	.word	0x40021000
 80125fc:	40022000 	.word	0x40022000

08012600 <HAL_RCC_GetSysClockFreq>:
  sysclk_source = __HAL_RCC_GET_SYSCLK_SOURCE();
 8012600:	4a28      	ldr	r2, [pc, #160]	; (80126a4 <HAL_RCC_GetSysClockFreq+0xa4>)
 8012602:	6893      	ldr	r3, [r2, #8]
  pll_oscsource = __HAL_RCC_GET_PLL_OSCSOURCE();
 8012604:	68d2      	ldr	r2, [r2, #12]
  if((sysclk_source == RCC_CFGR_SWS_MSI) ||
 8012606:	f013 030c 	ands.w	r3, r3, #12
 801260a:	d008      	beq.n	801261e <HAL_RCC_GetSysClockFreq+0x1e>
 801260c:	2b0c      	cmp	r3, #12
 801260e:	d038      	beq.n	8012682 <HAL_RCC_GetSysClockFreq+0x82>
  else if(sysclk_source == RCC_CFGR_SWS_HSI)
 8012610:	2b04      	cmp	r3, #4
 8012612:	d034      	beq.n	801267e <HAL_RCC_GetSysClockFreq+0x7e>
  else if(sysclk_source == RCC_CFGR_SWS_HSE)
 8012614:	2b08      	cmp	r3, #8
 8012616:	4824      	ldr	r0, [pc, #144]	; (80126a8 <HAL_RCC_GetSysClockFreq+0xa8>)
 8012618:	bf18      	it	ne
 801261a:	2000      	movne	r0, #0
 801261c:	4770      	bx	lr
    if(READ_BIT(RCC->CR, RCC_CR_MSIRGSEL) == 0U)
 801261e:	4a21      	ldr	r2, [pc, #132]	; (80126a4 <HAL_RCC_GetSysClockFreq+0xa4>)
 8012620:	6811      	ldr	r1, [r2, #0]
 8012622:	0709      	lsls	r1, r1, #28
      msirange = READ_BIT(RCC->CSR, RCC_CSR_MSISRANGE) >> RCC_CSR_MSISRANGE_Pos;
 8012624:	bf54      	ite	pl
 8012626:	f8d2 2094 	ldrpl.w	r2, [r2, #148]	; 0x94
      msirange = READ_BIT(RCC->CR, RCC_CR_MSIRANGE) >> RCC_CR_MSIRANGE_Pos;
 801262a:	6812      	ldrmi	r2, [r2, #0]
    msirange = MSIRangeTable[msirange];
 801262c:	491f      	ldr	r1, [pc, #124]	; (80126ac <HAL_RCC_GetSysClockFreq+0xac>)
      msirange = READ_BIT(RCC->CSR, RCC_CSR_MSISRANGE) >> RCC_CSR_MSISRANGE_Pos;
 801262e:	bf54      	ite	pl
 8012630:	f3c2 2203 	ubfxpl	r2, r2, #8, #4
      msirange = READ_BIT(RCC->CR, RCC_CR_MSIRANGE) >> RCC_CR_MSIRANGE_Pos;
 8012634:	f3c2 1203 	ubfxmi	r2, r2, #4, #4
    msirange = MSIRangeTable[msirange];
 8012638:	f851 0022 	ldr.w	r0, [r1, r2, lsl #2]
    if(sysclk_source == RCC_CFGR_SWS_MSI)
 801263c:	b303      	cbz	r3, 8012680 <HAL_RCC_GetSysClockFreq+0x80>
  if(sysclk_source == RCC_CFGR_SWS_PLL)
 801263e:	2b0c      	cmp	r3, #12
 8012640:	d12d      	bne.n	801269e <HAL_RCC_GetSysClockFreq+0x9e>
    pllsource = READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC);
 8012642:	4b18      	ldr	r3, [pc, #96]	; (80126a4 <HAL_RCC_GetSysClockFreq+0xa4>)
 8012644:	68db      	ldr	r3, [r3, #12]
 8012646:	f003 0303 	and.w	r3, r3, #3
    switch (pllsource)
 801264a:	2b02      	cmp	r3, #2
 801264c:	d025      	beq.n	801269a <HAL_RCC_GetSysClockFreq+0x9a>
 801264e:	4a16      	ldr	r2, [pc, #88]	; (80126a8 <HAL_RCC_GetSysClockFreq+0xa8>)
 8012650:	2b03      	cmp	r3, #3
 8012652:	bf08      	it	eq
 8012654:	4610      	moveq	r0, r2
    pllm = (READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLM) >> RCC_PLLCFGR_PLLM_Pos) + 1U ;
 8012656:	4b13      	ldr	r3, [pc, #76]	; (80126a4 <HAL_RCC_GetSysClockFreq+0xa4>)
 8012658:	68d9      	ldr	r1, [r3, #12]
    pllvco = (pllvco * (READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos)) / pllm;
 801265a:	68da      	ldr	r2, [r3, #12]
    pllr = ((READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLR) >> RCC_PLLCFGR_PLLR_Pos) + 1U ) * 2U;
 801265c:	68db      	ldr	r3, [r3, #12]
 801265e:	f3c3 6341 	ubfx	r3, r3, #25, #2
    pllvco = (pllvco * (READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos)) / pllm;
 8012662:	f3c2 2206 	ubfx	r2, r2, #8, #7
    pllm = (READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLM) >> RCC_PLLCFGR_PLLM_Pos) + 1U ;
 8012666:	f3c1 1102 	ubfx	r1, r1, #4, #3
    pllr = ((READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLR) >> RCC_PLLCFGR_PLLR_Pos) + 1U ) * 2U;
 801266a:	3301      	adds	r3, #1
    pllvco = (pllvco * (READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos)) / pllm;
 801266c:	fb02 f000 	mul.w	r0, r2, r0
    pllm = (READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLM) >> RCC_PLLCFGR_PLLM_Pos) + 1U ;
 8012670:	3101      	adds	r1, #1
    pllr = ((READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLR) >> RCC_PLLCFGR_PLLR_Pos) + 1U ) * 2U;
 8012672:	005b      	lsls	r3, r3, #1
    pllvco = (pllvco * (READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos)) / pllm;
 8012674:	fbb0 f0f1 	udiv	r0, r0, r1
    sysclockfreq = pllvco / pllr;
 8012678:	fbb0 f0f3 	udiv	r0, r0, r3
 801267c:	4770      	bx	lr
    sysclockfreq = HSI_VALUE;
 801267e:	480c      	ldr	r0, [pc, #48]	; (80126b0 <HAL_RCC_GetSysClockFreq+0xb0>)
}
 8012680:	4770      	bx	lr
  pll_oscsource = __HAL_RCC_GET_PLL_OSCSOURCE();
 8012682:	f002 0203 	and.w	r2, r2, #3
     ((sysclk_source == RCC_CFGR_SWS_PLL) && (pll_oscsource == RCC_PLLSOURCE_MSI)))
 8012686:	2a01      	cmp	r2, #1
 8012688:	d0c9      	beq.n	801261e <HAL_RCC_GetSysClockFreq+0x1e>
    pllsource = READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC);
 801268a:	4b06      	ldr	r3, [pc, #24]	; (80126a4 <HAL_RCC_GetSysClockFreq+0xa4>)
 801268c:	68db      	ldr	r3, [r3, #12]
 801268e:	f003 0303 	and.w	r3, r3, #3
    switch (pllsource)
 8012692:	2b02      	cmp	r3, #2
  uint32_t msirange = 0U, sysclockfreq = 0U;
 8012694:	f04f 0000 	mov.w	r0, #0
    switch (pllsource)
 8012698:	d1d9      	bne.n	801264e <HAL_RCC_GetSysClockFreq+0x4e>
      pllvco = HSI_VALUE;
 801269a:	4805      	ldr	r0, [pc, #20]	; (80126b0 <HAL_RCC_GetSysClockFreq+0xb0>)
 801269c:	e7db      	b.n	8012656 <HAL_RCC_GetSysClockFreq+0x56>
 801269e:	2000      	movs	r0, #0
  return sysclockfreq;
 80126a0:	4770      	bx	lr
 80126a2:	bf00      	nop
 80126a4:	40021000 	.word	0x40021000
 80126a8:	007a1200 	.word	0x007a1200
 80126ac:	0802d2e8 	.word	0x0802d2e8
 80126b0:	00f42400 	.word	0x00f42400

080126b4 <HAL_RCC_OscConfig>:
  if(RCC_OscInitStruct == NULL)
 80126b4:	2800      	cmp	r0, #0
 80126b6:	f000 8207 	beq.w	8012ac8 <HAL_RCC_OscConfig+0x414>
{
 80126ba:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
  sysclk_source = __HAL_RCC_GET_SYSCLK_SOURCE();
 80126be:	4a8a      	ldr	r2, [pc, #552]	; (80128e8 <HAL_RCC_OscConfig+0x234>)
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_MSI) == RCC_OSCILLATORTYPE_MSI)
 80126c0:	6803      	ldr	r3, [r0, #0]
  sysclk_source = __HAL_RCC_GET_SYSCLK_SOURCE();
 80126c2:	6895      	ldr	r5, [r2, #8]
  pll_config = __HAL_RCC_GET_PLL_OSCSOURCE();
 80126c4:	68d6      	ldr	r6, [r2, #12]
 80126c6:	4604      	mov	r4, r0
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_MSI) == RCC_OSCILLATORTYPE_MSI)
 80126c8:	06d8      	lsls	r0, r3, #27
{
 80126ca:	b083      	sub	sp, #12
  sysclk_source = __HAL_RCC_GET_SYSCLK_SOURCE();
 80126cc:	f005 050c 	and.w	r5, r5, #12
  pll_config = __HAL_RCC_GET_PLL_OSCSOURCE();
 80126d0:	f006 0603 	and.w	r6, r6, #3
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_MSI) == RCC_OSCILLATORTYPE_MSI)
 80126d4:	d52e      	bpl.n	8012734 <HAL_RCC_OscConfig+0x80>
    if((sysclk_source == RCC_CFGR_SWS_MSI) ||
 80126d6:	2d00      	cmp	r5, #0
 80126d8:	f000 810d 	beq.w	80128f6 <HAL_RCC_OscConfig+0x242>
 80126dc:	2d0c      	cmp	r5, #12
 80126de:	f000 8107 	beq.w	80128f0 <HAL_RCC_OscConfig+0x23c>
      if(RCC_OscInitStruct->MSIState != RCC_MSI_OFF)
 80126e2:	69a3      	ldr	r3, [r4, #24]
        __HAL_RCC_MSI_ENABLE();
 80126e4:	4f80      	ldr	r7, [pc, #512]	; (80128e8 <HAL_RCC_OscConfig+0x234>)
      if(RCC_OscInitStruct->MSIState != RCC_MSI_OFF)
 80126e6:	2b00      	cmp	r3, #0
 80126e8:	f000 816b 	beq.w	80129c2 <HAL_RCC_OscConfig+0x30e>
        __HAL_RCC_MSI_ENABLE();
 80126ec:	683b      	ldr	r3, [r7, #0]
 80126ee:	f043 0301 	orr.w	r3, r3, #1
 80126f2:	603b      	str	r3, [r7, #0]
        tickstart = HAL_GetTick();
 80126f4:	f7fd f8a0 	bl	800f838 <HAL_GetTick>
 80126f8:	4680      	mov	r8, r0
        while(READ_BIT(RCC->CR, RCC_CR_MSIRDY) == 0U)
 80126fa:	e006      	b.n	801270a <HAL_RCC_OscConfig+0x56>
          if((HAL_GetTick() - tickstart) > MSI_TIMEOUT_VALUE)
 80126fc:	f7fd f89c 	bl	800f838 <HAL_GetTick>
 8012700:	eba0 0008 	sub.w	r0, r0, r8
 8012704:	2802      	cmp	r0, #2
 8012706:	f200 816c 	bhi.w	80129e2 <HAL_RCC_OscConfig+0x32e>
        while(READ_BIT(RCC->CR, RCC_CR_MSIRDY) == 0U)
 801270a:	683b      	ldr	r3, [r7, #0]
 801270c:	079b      	lsls	r3, r3, #30
 801270e:	d5f5      	bpl.n	80126fc <HAL_RCC_OscConfig+0x48>
        __HAL_RCC_MSI_RANGE_CONFIG(RCC_OscInitStruct->MSIClockRange);
 8012710:	683b      	ldr	r3, [r7, #0]
 8012712:	f043 0308 	orr.w	r3, r3, #8
 8012716:	603b      	str	r3, [r7, #0]
 8012718:	683b      	ldr	r3, [r7, #0]
 801271a:	6a22      	ldr	r2, [r4, #32]
 801271c:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
 8012720:	4313      	orrs	r3, r2
 8012722:	603b      	str	r3, [r7, #0]
        __HAL_RCC_MSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->MSICalibrationValue);
 8012724:	687b      	ldr	r3, [r7, #4]
 8012726:	69e2      	ldr	r2, [r4, #28]
 8012728:	f423 437f 	bic.w	r3, r3, #65280	; 0xff00
 801272c:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 8012730:	607b      	str	r3, [r7, #4]
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
 8012732:	6823      	ldr	r3, [r4, #0]
 8012734:	07d9      	lsls	r1, r3, #31
 8012736:	f100 80ad 	bmi.w	8012894 <HAL_RCC_OscConfig+0x1e0>
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI) == RCC_OSCILLATORTYPE_HSI)
 801273a:	0799      	lsls	r1, r3, #30
 801273c:	d523      	bpl.n	8012786 <HAL_RCC_OscConfig+0xd2>
    if((sysclk_source == RCC_CFGR_SWS_HSI) ||
 801273e:	2d04      	cmp	r5, #4
 8012740:	f000 812f 	beq.w	80129a2 <HAL_RCC_OscConfig+0x2ee>
 8012744:	2d0c      	cmp	r5, #12
 8012746:	f000 8129 	beq.w	801299c <HAL_RCC_OscConfig+0x2e8>
      if(RCC_OscInitStruct->HSIState != RCC_HSI_OFF)
 801274a:	68e3      	ldr	r3, [r4, #12]
        __HAL_RCC_HSI_ENABLE();
 801274c:	4e66      	ldr	r6, [pc, #408]	; (80128e8 <HAL_RCC_OscConfig+0x234>)
      if(RCC_OscInitStruct->HSIState != RCC_HSI_OFF)
 801274e:	2b00      	cmp	r3, #0
 8012750:	f000 818c 	beq.w	8012a6c <HAL_RCC_OscConfig+0x3b8>
        __HAL_RCC_HSI_ENABLE();
 8012754:	6833      	ldr	r3, [r6, #0]
 8012756:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 801275a:	6033      	str	r3, [r6, #0]
        tickstart = HAL_GetTick();
 801275c:	f7fd f86c 	bl	800f838 <HAL_GetTick>
 8012760:	4607      	mov	r7, r0
        while(READ_BIT(RCC->CR, RCC_CR_HSIRDY) == 0U)
 8012762:	e005      	b.n	8012770 <HAL_RCC_OscConfig+0xbc>
          if((HAL_GetTick() - tickstart) > HSI_TIMEOUT_VALUE)
 8012764:	f7fd f868 	bl	800f838 <HAL_GetTick>
 8012768:	1bc0      	subs	r0, r0, r7
 801276a:	2802      	cmp	r0, #2
 801276c:	f200 8139 	bhi.w	80129e2 <HAL_RCC_OscConfig+0x32e>
        while(READ_BIT(RCC->CR, RCC_CR_HSIRDY) == 0U)
 8012770:	6833      	ldr	r3, [r6, #0]
 8012772:	055b      	lsls	r3, r3, #21
 8012774:	d5f6      	bpl.n	8012764 <HAL_RCC_OscConfig+0xb0>
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 8012776:	6873      	ldr	r3, [r6, #4]
 8012778:	6922      	ldr	r2, [r4, #16]
 801277a:	f023 53f8 	bic.w	r3, r3, #520093696	; 0x1f000000
 801277e:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
 8012782:	6073      	str	r3, [r6, #4]
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI) == RCC_OSCILLATORTYPE_LSI)
 8012784:	6823      	ldr	r3, [r4, #0]
 8012786:	0719      	lsls	r1, r3, #28
 8012788:	d519      	bpl.n	80127be <HAL_RCC_OscConfig+0x10a>
    if(RCC_OscInitStruct->LSIState != RCC_LSI_OFF)
 801278a:	6963      	ldr	r3, [r4, #20]
      __HAL_RCC_LSI_ENABLE();
 801278c:	4e56      	ldr	r6, [pc, #344]	; (80128e8 <HAL_RCC_OscConfig+0x234>)
    if(RCC_OscInitStruct->LSIState != RCC_LSI_OFF)
 801278e:	2b00      	cmp	r3, #0
 8012790:	f000 812b 	beq.w	80129ea <HAL_RCC_OscConfig+0x336>
      __HAL_RCC_LSI_ENABLE();
 8012794:	f8d6 3094 	ldr.w	r3, [r6, #148]	; 0x94
 8012798:	f043 0301 	orr.w	r3, r3, #1
 801279c:	f8c6 3094 	str.w	r3, [r6, #148]	; 0x94
      tickstart = HAL_GetTick();
 80127a0:	f7fd f84a 	bl	800f838 <HAL_GetTick>
 80127a4:	4607      	mov	r7, r0
      while(READ_BIT(RCC->CSR, RCC_CSR_LSIRDY) == 0U)
 80127a6:	e005      	b.n	80127b4 <HAL_RCC_OscConfig+0x100>
        if((HAL_GetTick() - tickstart) > LSI_TIMEOUT_VALUE)
 80127a8:	f7fd f846 	bl	800f838 <HAL_GetTick>
 80127ac:	1bc0      	subs	r0, r0, r7
 80127ae:	2802      	cmp	r0, #2
 80127b0:	f200 8117 	bhi.w	80129e2 <HAL_RCC_OscConfig+0x32e>
      while(READ_BIT(RCC->CSR, RCC_CSR_LSIRDY) == 0U)
 80127b4:	f8d6 3094 	ldr.w	r3, [r6, #148]	; 0x94
 80127b8:	079a      	lsls	r2, r3, #30
 80127ba:	d5f5      	bpl.n	80127a8 <HAL_RCC_OscConfig+0xf4>
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSE) == RCC_OSCILLATORTYPE_LSE)
 80127bc:	6823      	ldr	r3, [r4, #0]
 80127be:	075e      	lsls	r6, r3, #29
 80127c0:	d53e      	bpl.n	8012840 <HAL_RCC_OscConfig+0x18c>
    if(HAL_IS_BIT_CLR(RCC->APB1ENR1, RCC_APB1ENR1_PWREN))
 80127c2:	4b49      	ldr	r3, [pc, #292]	; (80128e8 <HAL_RCC_OscConfig+0x234>)
 80127c4:	6d9a      	ldr	r2, [r3, #88]	; 0x58
 80127c6:	00d0      	lsls	r0, r2, #3
 80127c8:	f100 814e 	bmi.w	8012a68 <HAL_RCC_OscConfig+0x3b4>
      __HAL_RCC_PWR_CLK_ENABLE();
 80127cc:	6d9a      	ldr	r2, [r3, #88]	; 0x58
 80127ce:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 80127d2:	659a      	str	r2, [r3, #88]	; 0x58
 80127d4:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 80127d6:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 80127da:	9301      	str	r3, [sp, #4]
 80127dc:	9b01      	ldr	r3, [sp, #4]
      pwrclkchanged = SET;
 80127de:	2601      	movs	r6, #1
    if(HAL_IS_BIT_CLR(PWR->CR1, PWR_CR1_DBP))
 80127e0:	4f42      	ldr	r7, [pc, #264]	; (80128ec <HAL_RCC_OscConfig+0x238>)
 80127e2:	683b      	ldr	r3, [r7, #0]
 80127e4:	05d9      	lsls	r1, r3, #23
 80127e6:	f140 817c 	bpl.w	8012ae2 <HAL_RCC_OscConfig+0x42e>
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 80127ea:	68a3      	ldr	r3, [r4, #8]
 80127ec:	2b01      	cmp	r3, #1
 80127ee:	f000 814f 	beq.w	8012a90 <HAL_RCC_OscConfig+0x3dc>
 80127f2:	2b05      	cmp	r3, #5
 80127f4:	f000 81d4 	beq.w	8012ba0 <HAL_RCC_OscConfig+0x4ec>
 80127f8:	4f3b      	ldr	r7, [pc, #236]	; (80128e8 <HAL_RCC_OscConfig+0x234>)
 80127fa:	f8d7 2090 	ldr.w	r2, [r7, #144]	; 0x90
 80127fe:	f022 0201 	bic.w	r2, r2, #1
 8012802:	f8c7 2090 	str.w	r2, [r7, #144]	; 0x90
 8012806:	f8d7 2090 	ldr.w	r2, [r7, #144]	; 0x90
 801280a:	f022 0204 	bic.w	r2, r2, #4
 801280e:	f8c7 2090 	str.w	r2, [r7, #144]	; 0x90
    if(RCC_OscInitStruct->LSEState != RCC_LSE_OFF)
 8012812:	2b00      	cmp	r3, #0
 8012814:	f040 8143 	bne.w	8012a9e <HAL_RCC_OscConfig+0x3ea>
      tickstart = HAL_GetTick();
 8012818:	f7fd f80e 	bl	800f838 <HAL_GetTick>
        if((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 801281c:	f241 3988 	movw	r9, #5000	; 0x1388
      tickstart = HAL_GetTick();
 8012820:	4680      	mov	r8, r0
      while(READ_BIT(RCC->BDCR, RCC_BDCR_LSERDY) != 0U)
 8012822:	e006      	b.n	8012832 <HAL_RCC_OscConfig+0x17e>
        if((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 8012824:	f7fd f808 	bl	800f838 <HAL_GetTick>
 8012828:	eba0 0008 	sub.w	r0, r0, r8
 801282c:	4548      	cmp	r0, r9
 801282e:	f200 80d8 	bhi.w	80129e2 <HAL_RCC_OscConfig+0x32e>
      while(READ_BIT(RCC->BDCR, RCC_BDCR_LSERDY) != 0U)
 8012832:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
 8012836:	0798      	lsls	r0, r3, #30
 8012838:	d4f4      	bmi.n	8012824 <HAL_RCC_OscConfig+0x170>
    if(pwrclkchanged == SET)
 801283a:	2e00      	cmp	r6, #0
 801283c:	f040 814b 	bne.w	8012ad6 <HAL_RCC_OscConfig+0x422>
  if(RCC_OscInitStruct->PLL.PLLState != RCC_PLL_NONE)
 8012840:	6aa0      	ldr	r0, [r4, #40]	; 0x28
 8012842:	b318      	cbz	r0, 801288c <HAL_RCC_OscConfig+0x1d8>
    if(sysclk_source != RCC_CFGR_SWS_PLL)
 8012844:	2d0c      	cmp	r5, #12
 8012846:	f000 816b 	beq.w	8012b20 <HAL_RCC_OscConfig+0x46c>
      if(RCC_OscInitStruct->PLL.PLLState == RCC_PLL_ON)
 801284a:	2802      	cmp	r0, #2
 801284c:	f000 81b6 	beq.w	8012bbc <HAL_RCC_OscConfig+0x508>
        __HAL_RCC_PLL_DISABLE();
 8012850:	4b25      	ldr	r3, [pc, #148]	; (80128e8 <HAL_RCC_OscConfig+0x234>)
 8012852:	681a      	ldr	r2, [r3, #0]
 8012854:	f022 7280 	bic.w	r2, r2, #16777216	; 0x1000000
 8012858:	601a      	str	r2, [r3, #0]
        if(READ_BIT(RCC->CR, (RCC_CR_PLLSAI1RDY | RCC_CR_PLLSAI2RDY)) == 0U)
 801285a:	681a      	ldr	r2, [r3, #0]
 801285c:	f012 5f20 	tst.w	r2, #671088640	; 0x28000000
 8012860:	f000 8134 	beq.w	8012acc <HAL_RCC_OscConfig+0x418>
        __HAL_RCC_PLLCLKOUT_DISABLE(RCC_PLL_SYSCLK | RCC_PLL_48M1CLK | RCC_PLL_SAI3CLK);
 8012864:	4c20      	ldr	r4, [pc, #128]	; (80128e8 <HAL_RCC_OscConfig+0x234>)
 8012866:	68e3      	ldr	r3, [r4, #12]
 8012868:	f023 7388 	bic.w	r3, r3, #17825792	; 0x1100000
 801286c:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 8012870:	60e3      	str	r3, [r4, #12]
        tickstart = HAL_GetTick();
 8012872:	f7fc ffe1 	bl	800f838 <HAL_GetTick>
 8012876:	4605      	mov	r5, r0
        while(READ_BIT(RCC->CR, RCC_CR_PLLRDY) != 0U)
 8012878:	e005      	b.n	8012886 <HAL_RCC_OscConfig+0x1d2>
          if((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
 801287a:	f7fc ffdd 	bl	800f838 <HAL_GetTick>
 801287e:	1b40      	subs	r0, r0, r5
 8012880:	2802      	cmp	r0, #2
 8012882:	f200 80ae 	bhi.w	80129e2 <HAL_RCC_OscConfig+0x32e>
        while(READ_BIT(RCC->CR, RCC_CR_PLLRDY) != 0U)
 8012886:	6823      	ldr	r3, [r4, #0]
 8012888:	019b      	lsls	r3, r3, #6
 801288a:	d4f6      	bmi.n	801287a <HAL_RCC_OscConfig+0x1c6>
  return HAL_OK;
 801288c:	2000      	movs	r0, #0
}
 801288e:	b003      	add	sp, #12
 8012890:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    if((sysclk_source == RCC_CFGR_SWS_HSE) ||
 8012894:	2d08      	cmp	r5, #8
 8012896:	d077      	beq.n	8012988 <HAL_RCC_OscConfig+0x2d4>
 8012898:	2d0c      	cmp	r5, #12
 801289a:	d073      	beq.n	8012984 <HAL_RCC_OscConfig+0x2d0>
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 801289c:	6863      	ldr	r3, [r4, #4]
 801289e:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 80128a2:	f000 80cc 	beq.w	8012a3e <HAL_RCC_OscConfig+0x38a>
 80128a6:	f5b3 2fa0 	cmp.w	r3, #327680	; 0x50000
 80128aa:	f000 812c 	beq.w	8012b06 <HAL_RCC_OscConfig+0x452>
 80128ae:	4f0e      	ldr	r7, [pc, #56]	; (80128e8 <HAL_RCC_OscConfig+0x234>)
 80128b0:	683a      	ldr	r2, [r7, #0]
 80128b2:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
 80128b6:	603a      	str	r2, [r7, #0]
 80128b8:	683a      	ldr	r2, [r7, #0]
 80128ba:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
 80128be:	603a      	str	r2, [r7, #0]
      if(RCC_OscInitStruct->HSEState != RCC_HSE_OFF)
 80128c0:	2b00      	cmp	r3, #0
 80128c2:	f040 80c1 	bne.w	8012a48 <HAL_RCC_OscConfig+0x394>
        tickstart = HAL_GetTick();
 80128c6:	f7fc ffb7 	bl	800f838 <HAL_GetTick>
 80128ca:	4680      	mov	r8, r0
        while(READ_BIT(RCC->CR, RCC_CR_HSERDY) != 0U)
 80128cc:	e006      	b.n	80128dc <HAL_RCC_OscConfig+0x228>
          if((HAL_GetTick() - tickstart) > HSE_TIMEOUT_VALUE)
 80128ce:	f7fc ffb3 	bl	800f838 <HAL_GetTick>
 80128d2:	eba0 0008 	sub.w	r0, r0, r8
 80128d6:	2864      	cmp	r0, #100	; 0x64
 80128d8:	f200 8083 	bhi.w	80129e2 <HAL_RCC_OscConfig+0x32e>
        while(READ_BIT(RCC->CR, RCC_CR_HSERDY) != 0U)
 80128dc:	683b      	ldr	r3, [r7, #0]
 80128de:	0398      	lsls	r0, r3, #14
 80128e0:	d4f5      	bmi.n	80128ce <HAL_RCC_OscConfig+0x21a>
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI) == RCC_OSCILLATORTYPE_HSI)
 80128e2:	6823      	ldr	r3, [r4, #0]
 80128e4:	e729      	b.n	801273a <HAL_RCC_OscConfig+0x86>
 80128e6:	bf00      	nop
 80128e8:	40021000 	.word	0x40021000
 80128ec:	40007000 	.word	0x40007000
       ((sysclk_source == RCC_CFGR_SWS_PLL) && (pll_config == RCC_PLLSOURCE_MSI)))
 80128f0:	2e01      	cmp	r6, #1
 80128f2:	f47f aef6 	bne.w	80126e2 <HAL_RCC_OscConfig+0x2e>
      if((READ_BIT(RCC->CR, RCC_CR_MSIRDY) != 0U) && (RCC_OscInitStruct->MSIState == RCC_MSI_OFF))
 80128f6:	4ba6      	ldr	r3, [pc, #664]	; (8012b90 <HAL_RCC_OscConfig+0x4dc>)
 80128f8:	681b      	ldr	r3, [r3, #0]
 80128fa:	0799      	lsls	r1, r3, #30
 80128fc:	d43b      	bmi.n	8012976 <HAL_RCC_OscConfig+0x2c2>
        if(RCC_OscInitStruct->MSIClockRange > __HAL_RCC_GET_MSI_RANGE())
 80128fe:	4ba4      	ldr	r3, [pc, #656]	; (8012b90 <HAL_RCC_OscConfig+0x4dc>)
 8012900:	6a20      	ldr	r0, [r4, #32]
 8012902:	681a      	ldr	r2, [r3, #0]
 8012904:	0712      	lsls	r2, r2, #28
 8012906:	bf56      	itet	pl
 8012908:	f8d3 3094 	ldrpl.w	r3, [r3, #148]	; 0x94
 801290c:	681b      	ldrmi	r3, [r3, #0]
 801290e:	091b      	lsrpl	r3, r3, #4
 8012910:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
 8012914:	4298      	cmp	r0, r3
 8012916:	d97c      	bls.n	8012a12 <HAL_RCC_OscConfig+0x35e>
          if(RCC_SetFlashLatencyFromMSIRange(RCC_OscInitStruct->MSIClockRange) != HAL_OK)
 8012918:	f7ff fe2c 	bl	8012574 <RCC_SetFlashLatencyFromMSIRange>
 801291c:	2800      	cmp	r0, #0
 801291e:	d12d      	bne.n	801297c <HAL_RCC_OscConfig+0x2c8>
          __HAL_RCC_MSI_RANGE_CONFIG(RCC_OscInitStruct->MSIClockRange);
 8012920:	4b9b      	ldr	r3, [pc, #620]	; (8012b90 <HAL_RCC_OscConfig+0x4dc>)
 8012922:	681a      	ldr	r2, [r3, #0]
 8012924:	f042 0208 	orr.w	r2, r2, #8
 8012928:	601a      	str	r2, [r3, #0]
 801292a:	681a      	ldr	r2, [r3, #0]
 801292c:	6a21      	ldr	r1, [r4, #32]
 801292e:	f022 02f0 	bic.w	r2, r2, #240	; 0xf0
 8012932:	430a      	orrs	r2, r1
 8012934:	601a      	str	r2, [r3, #0]
          __HAL_RCC_MSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->MSICalibrationValue);
 8012936:	685a      	ldr	r2, [r3, #4]
 8012938:	69e1      	ldr	r1, [r4, #28]
 801293a:	f422 427f 	bic.w	r2, r2, #65280	; 0xff00
 801293e:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
 8012942:	605a      	str	r2, [r3, #4]
        SystemCoreClock = HAL_RCC_GetSysClockFreq() >> (AHBPrescTable[READ_BIT(RCC->CFGR, RCC_CFGR_HPRE) >> RCC_CFGR_HPRE_Pos] & 0x1FU);
 8012944:	f7ff fe5c 	bl	8012600 <HAL_RCC_GetSysClockFreq>
 8012948:	4b91      	ldr	r3, [pc, #580]	; (8012b90 <HAL_RCC_OscConfig+0x4dc>)
 801294a:	4a92      	ldr	r2, [pc, #584]	; (8012b94 <HAL_RCC_OscConfig+0x4e0>)
 801294c:	689b      	ldr	r3, [r3, #8]
 801294e:	f3c3 1303 	ubfx	r3, r3, #4, #4
 8012952:	5cd3      	ldrb	r3, [r2, r3]
        status = HAL_InitTick(uwTickPrio);
 8012954:	4a90      	ldr	r2, [pc, #576]	; (8012b98 <HAL_RCC_OscConfig+0x4e4>)
        SystemCoreClock = HAL_RCC_GetSysClockFreq() >> (AHBPrescTable[READ_BIT(RCC->CFGR, RCC_CFGR_HPRE) >> RCC_CFGR_HPRE_Pos] & 0x1FU);
 8012956:	f003 031f 	and.w	r3, r3, #31
 801295a:	fa20 f303 	lsr.w	r3, r0, r3
        status = HAL_InitTick(uwTickPrio);
 801295e:	6810      	ldr	r0, [r2, #0]
        SystemCoreClock = HAL_RCC_GetSysClockFreq() >> (AHBPrescTable[READ_BIT(RCC->CFGR, RCC_CFGR_HPRE) >> RCC_CFGR_HPRE_Pos] & 0x1FU);
 8012960:	4a8e      	ldr	r2, [pc, #568]	; (8012b9c <HAL_RCC_OscConfig+0x4e8>)
 8012962:	6013      	str	r3, [r2, #0]
        status = HAL_InitTick(uwTickPrio);
 8012964:	f7fc ff28 	bl	800f7b8 <HAL_InitTick>
        if(status != HAL_OK)
 8012968:	2800      	cmp	r0, #0
 801296a:	d190      	bne.n	801288e <HAL_RCC_OscConfig+0x1da>
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
 801296c:	6823      	ldr	r3, [r4, #0]
 801296e:	07d9      	lsls	r1, r3, #31
 8012970:	f57f aee3 	bpl.w	801273a <HAL_RCC_OscConfig+0x86>
 8012974:	e78e      	b.n	8012894 <HAL_RCC_OscConfig+0x1e0>
      if((READ_BIT(RCC->CR, RCC_CR_MSIRDY) != 0U) && (RCC_OscInitStruct->MSIState == RCC_MSI_OFF))
 8012976:	69a3      	ldr	r3, [r4, #24]
 8012978:	2b00      	cmp	r3, #0
 801297a:	d1c0      	bne.n	80128fe <HAL_RCC_OscConfig+0x24a>
        return HAL_ERROR;
 801297c:	2001      	movs	r0, #1
}
 801297e:	b003      	add	sp, #12
 8012980:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
       ((sysclk_source == RCC_CFGR_SWS_PLL) && (pll_config == RCC_PLLSOURCE_HSE)))
 8012984:	2e03      	cmp	r6, #3
 8012986:	d189      	bne.n	801289c <HAL_RCC_OscConfig+0x1e8>
      if((READ_BIT(RCC->CR, RCC_CR_HSERDY) != 0U) && (RCC_OscInitStruct->HSEState == RCC_HSE_OFF))
 8012988:	4a81      	ldr	r2, [pc, #516]	; (8012b90 <HAL_RCC_OscConfig+0x4dc>)
 801298a:	6812      	ldr	r2, [r2, #0]
 801298c:	0392      	lsls	r2, r2, #14
 801298e:	f57f aed4 	bpl.w	801273a <HAL_RCC_OscConfig+0x86>
 8012992:	6862      	ldr	r2, [r4, #4]
 8012994:	2a00      	cmp	r2, #0
 8012996:	f47f aed0 	bne.w	801273a <HAL_RCC_OscConfig+0x86>
 801299a:	e7ef      	b.n	801297c <HAL_RCC_OscConfig+0x2c8>
       ((sysclk_source == RCC_CFGR_SWS_PLL) && (pll_config == RCC_PLLSOURCE_HSI)))
 801299c:	2e02      	cmp	r6, #2
 801299e:	f47f aed4 	bne.w	801274a <HAL_RCC_OscConfig+0x96>
      if((READ_BIT(RCC->CR, RCC_CR_HSIRDY) != 0U) && (RCC_OscInitStruct->HSIState == RCC_HSI_OFF))
 80129a2:	4a7b      	ldr	r2, [pc, #492]	; (8012b90 <HAL_RCC_OscConfig+0x4dc>)
 80129a4:	6812      	ldr	r2, [r2, #0]
 80129a6:	0552      	lsls	r2, r2, #21
 80129a8:	d502      	bpl.n	80129b0 <HAL_RCC_OscConfig+0x2fc>
 80129aa:	68e2      	ldr	r2, [r4, #12]
 80129ac:	2a00      	cmp	r2, #0
 80129ae:	d0e5      	beq.n	801297c <HAL_RCC_OscConfig+0x2c8>
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 80129b0:	4977      	ldr	r1, [pc, #476]	; (8012b90 <HAL_RCC_OscConfig+0x4dc>)
 80129b2:	6920      	ldr	r0, [r4, #16]
 80129b4:	684a      	ldr	r2, [r1, #4]
 80129b6:	f022 52f8 	bic.w	r2, r2, #520093696	; 0x1f000000
 80129ba:	ea42 6200 	orr.w	r2, r2, r0, lsl #24
 80129be:	604a      	str	r2, [r1, #4]
      if((READ_BIT(RCC->CR, RCC_CR_HSIRDY) != 0U) && (RCC_OscInitStruct->HSIState == RCC_HSI_OFF))
 80129c0:	e6e1      	b.n	8012786 <HAL_RCC_OscConfig+0xd2>
        __HAL_RCC_MSI_DISABLE();
 80129c2:	683b      	ldr	r3, [r7, #0]
 80129c4:	f023 0301 	bic.w	r3, r3, #1
 80129c8:	603b      	str	r3, [r7, #0]
        tickstart = HAL_GetTick();
 80129ca:	f7fc ff35 	bl	800f838 <HAL_GetTick>
 80129ce:	4680      	mov	r8, r0
        while(READ_BIT(RCC->CR, RCC_CR_MSIRDY) != 0U)
 80129d0:	683b      	ldr	r3, [r7, #0]
 80129d2:	0798      	lsls	r0, r3, #30
 80129d4:	d5ca      	bpl.n	801296c <HAL_RCC_OscConfig+0x2b8>
          if((HAL_GetTick() - tickstart) > MSI_TIMEOUT_VALUE)
 80129d6:	f7fc ff2f 	bl	800f838 <HAL_GetTick>
 80129da:	eba0 0008 	sub.w	r0, r0, r8
 80129de:	2802      	cmp	r0, #2
 80129e0:	d9f6      	bls.n	80129d0 <HAL_RCC_OscConfig+0x31c>
            return HAL_TIMEOUT;
 80129e2:	2003      	movs	r0, #3
}
 80129e4:	b003      	add	sp, #12
 80129e6:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
      __HAL_RCC_LSI_DISABLE();
 80129ea:	f8d6 3094 	ldr.w	r3, [r6, #148]	; 0x94
 80129ee:	f023 0301 	bic.w	r3, r3, #1
 80129f2:	f8c6 3094 	str.w	r3, [r6, #148]	; 0x94
      tickstart = HAL_GetTick();
 80129f6:	f7fc ff1f 	bl	800f838 <HAL_GetTick>
 80129fa:	4607      	mov	r7, r0
      while(READ_BIT(RCC->CSR, RCC_CSR_LSIRDY) != 0U)
 80129fc:	e004      	b.n	8012a08 <HAL_RCC_OscConfig+0x354>
        if((HAL_GetTick() - tickstart) > LSI_TIMEOUT_VALUE)
 80129fe:	f7fc ff1b 	bl	800f838 <HAL_GetTick>
 8012a02:	1bc0      	subs	r0, r0, r7
 8012a04:	2802      	cmp	r0, #2
 8012a06:	d8ec      	bhi.n	80129e2 <HAL_RCC_OscConfig+0x32e>
      while(READ_BIT(RCC->CSR, RCC_CSR_LSIRDY) != 0U)
 8012a08:	f8d6 3094 	ldr.w	r3, [r6, #148]	; 0x94
 8012a0c:	079b      	lsls	r3, r3, #30
 8012a0e:	d4f6      	bmi.n	80129fe <HAL_RCC_OscConfig+0x34a>
 8012a10:	e6d4      	b.n	80127bc <HAL_RCC_OscConfig+0x108>
          __HAL_RCC_MSI_RANGE_CONFIG(RCC_OscInitStruct->MSIClockRange);
 8012a12:	4b5f      	ldr	r3, [pc, #380]	; (8012b90 <HAL_RCC_OscConfig+0x4dc>)
 8012a14:	681a      	ldr	r2, [r3, #0]
 8012a16:	f042 0208 	orr.w	r2, r2, #8
 8012a1a:	601a      	str	r2, [r3, #0]
 8012a1c:	681a      	ldr	r2, [r3, #0]
 8012a1e:	f022 02f0 	bic.w	r2, r2, #240	; 0xf0
 8012a22:	4302      	orrs	r2, r0
 8012a24:	601a      	str	r2, [r3, #0]
          __HAL_RCC_MSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->MSICalibrationValue);
 8012a26:	685a      	ldr	r2, [r3, #4]
 8012a28:	69e1      	ldr	r1, [r4, #28]
 8012a2a:	f422 427f 	bic.w	r2, r2, #65280	; 0xff00
 8012a2e:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
 8012a32:	605a      	str	r2, [r3, #4]
          if(RCC_SetFlashLatencyFromMSIRange(RCC_OscInitStruct->MSIClockRange) != HAL_OK)
 8012a34:	f7ff fd9e 	bl	8012574 <RCC_SetFlashLatencyFromMSIRange>
 8012a38:	2800      	cmp	r0, #0
 8012a3a:	d083      	beq.n	8012944 <HAL_RCC_OscConfig+0x290>
 8012a3c:	e79e      	b.n	801297c <HAL_RCC_OscConfig+0x2c8>
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 8012a3e:	4a54      	ldr	r2, [pc, #336]	; (8012b90 <HAL_RCC_OscConfig+0x4dc>)
 8012a40:	6813      	ldr	r3, [r2, #0]
 8012a42:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 8012a46:	6013      	str	r3, [r2, #0]
        tickstart = HAL_GetTick();
 8012a48:	f7fc fef6 	bl	800f838 <HAL_GetTick>
        while(READ_BIT(RCC->CR, RCC_CR_HSERDY) == 0U)
 8012a4c:	f8df 8140 	ldr.w	r8, [pc, #320]	; 8012b90 <HAL_RCC_OscConfig+0x4dc>
        tickstart = HAL_GetTick();
 8012a50:	4607      	mov	r7, r0
        while(READ_BIT(RCC->CR, RCC_CR_HSERDY) == 0U)
 8012a52:	e004      	b.n	8012a5e <HAL_RCC_OscConfig+0x3aa>
          if((HAL_GetTick() - tickstart) > HSE_TIMEOUT_VALUE)
 8012a54:	f7fc fef0 	bl	800f838 <HAL_GetTick>
 8012a58:	1bc0      	subs	r0, r0, r7
 8012a5a:	2864      	cmp	r0, #100	; 0x64
 8012a5c:	d8c1      	bhi.n	80129e2 <HAL_RCC_OscConfig+0x32e>
        while(READ_BIT(RCC->CR, RCC_CR_HSERDY) == 0U)
 8012a5e:	f8d8 3000 	ldr.w	r3, [r8]
 8012a62:	039b      	lsls	r3, r3, #14
 8012a64:	d5f6      	bpl.n	8012a54 <HAL_RCC_OscConfig+0x3a0>
 8012a66:	e73c      	b.n	80128e2 <HAL_RCC_OscConfig+0x22e>
    FlagStatus       pwrclkchanged = RESET;
 8012a68:	2600      	movs	r6, #0
 8012a6a:	e6b9      	b.n	80127e0 <HAL_RCC_OscConfig+0x12c>
        __HAL_RCC_HSI_DISABLE();
 8012a6c:	6833      	ldr	r3, [r6, #0]
 8012a6e:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 8012a72:	6033      	str	r3, [r6, #0]
        tickstart = HAL_GetTick();
 8012a74:	f7fc fee0 	bl	800f838 <HAL_GetTick>
 8012a78:	4607      	mov	r7, r0
        while(READ_BIT(RCC->CR, RCC_CR_HSIRDY) != 0U)
 8012a7a:	e004      	b.n	8012a86 <HAL_RCC_OscConfig+0x3d2>
          if((HAL_GetTick() - tickstart) > HSI_TIMEOUT_VALUE)
 8012a7c:	f7fc fedc 	bl	800f838 <HAL_GetTick>
 8012a80:	1bc0      	subs	r0, r0, r7
 8012a82:	2802      	cmp	r0, #2
 8012a84:	d8ad      	bhi.n	80129e2 <HAL_RCC_OscConfig+0x32e>
        while(READ_BIT(RCC->CR, RCC_CR_HSIRDY) != 0U)
 8012a86:	6833      	ldr	r3, [r6, #0]
 8012a88:	0558      	lsls	r0, r3, #21
 8012a8a:	d4f7      	bmi.n	8012a7c <HAL_RCC_OscConfig+0x3c8>
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI) == RCC_OSCILLATORTYPE_LSI)
 8012a8c:	6823      	ldr	r3, [r4, #0]
 8012a8e:	e67a      	b.n	8012786 <HAL_RCC_OscConfig+0xd2>
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 8012a90:	4a3f      	ldr	r2, [pc, #252]	; (8012b90 <HAL_RCC_OscConfig+0x4dc>)
 8012a92:	f8d2 3090 	ldr.w	r3, [r2, #144]	; 0x90
 8012a96:	f043 0301 	orr.w	r3, r3, #1
 8012a9a:	f8c2 3090 	str.w	r3, [r2, #144]	; 0x90
      tickstart = HAL_GetTick();
 8012a9e:	f7fc fecb 	bl	800f838 <HAL_GetTick>
      while(READ_BIT(RCC->BDCR, RCC_BDCR_LSERDY) == 0U)
 8012aa2:	f8df 80ec 	ldr.w	r8, [pc, #236]	; 8012b90 <HAL_RCC_OscConfig+0x4dc>
      tickstart = HAL_GetTick();
 8012aa6:	4607      	mov	r7, r0
        if((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 8012aa8:	f241 3988 	movw	r9, #5000	; 0x1388
      while(READ_BIT(RCC->BDCR, RCC_BDCR_LSERDY) == 0U)
 8012aac:	e004      	b.n	8012ab8 <HAL_RCC_OscConfig+0x404>
        if((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 8012aae:	f7fc fec3 	bl	800f838 <HAL_GetTick>
 8012ab2:	1bc0      	subs	r0, r0, r7
 8012ab4:	4548      	cmp	r0, r9
 8012ab6:	d894      	bhi.n	80129e2 <HAL_RCC_OscConfig+0x32e>
      while(READ_BIT(RCC->BDCR, RCC_BDCR_LSERDY) == 0U)
 8012ab8:	f8d8 3090 	ldr.w	r3, [r8, #144]	; 0x90
 8012abc:	079b      	lsls	r3, r3, #30
 8012abe:	d5f6      	bpl.n	8012aae <HAL_RCC_OscConfig+0x3fa>
    if(pwrclkchanged == SET)
 8012ac0:	2e00      	cmp	r6, #0
 8012ac2:	f43f aebd 	beq.w	8012840 <HAL_RCC_OscConfig+0x18c>
 8012ac6:	e006      	b.n	8012ad6 <HAL_RCC_OscConfig+0x422>
    return HAL_ERROR;
 8012ac8:	2001      	movs	r0, #1
}
 8012aca:	4770      	bx	lr
          MODIFY_REG(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC, RCC_PLLSOURCE_NONE);
 8012acc:	68da      	ldr	r2, [r3, #12]
 8012ace:	f022 0203 	bic.w	r2, r2, #3
 8012ad2:	60da      	str	r2, [r3, #12]
 8012ad4:	e6c6      	b.n	8012864 <HAL_RCC_OscConfig+0x1b0>
      __HAL_RCC_PWR_CLK_DISABLE();
 8012ad6:	4a2e      	ldr	r2, [pc, #184]	; (8012b90 <HAL_RCC_OscConfig+0x4dc>)
 8012ad8:	6d93      	ldr	r3, [r2, #88]	; 0x58
 8012ada:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
 8012ade:	6593      	str	r3, [r2, #88]	; 0x58
 8012ae0:	e6ae      	b.n	8012840 <HAL_RCC_OscConfig+0x18c>
      SET_BIT(PWR->CR1, PWR_CR1_DBP);
 8012ae2:	683b      	ldr	r3, [r7, #0]
 8012ae4:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 8012ae8:	603b      	str	r3, [r7, #0]
      tickstart = HAL_GetTick();
 8012aea:	f7fc fea5 	bl	800f838 <HAL_GetTick>
 8012aee:	4680      	mov	r8, r0
      while(HAL_IS_BIT_CLR(PWR->CR1, PWR_CR1_DBP))
 8012af0:	683b      	ldr	r3, [r7, #0]
 8012af2:	05da      	lsls	r2, r3, #23
 8012af4:	f53f ae79 	bmi.w	80127ea <HAL_RCC_OscConfig+0x136>
        if((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
 8012af8:	f7fc fe9e 	bl	800f838 <HAL_GetTick>
 8012afc:	eba0 0008 	sub.w	r0, r0, r8
 8012b00:	2802      	cmp	r0, #2
 8012b02:	d9f5      	bls.n	8012af0 <HAL_RCC_OscConfig+0x43c>
 8012b04:	e76d      	b.n	80129e2 <HAL_RCC_OscConfig+0x32e>
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 8012b06:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
 8012b0a:	f5a3 333c 	sub.w	r3, r3, #192512	; 0x2f000
 8012b0e:	681a      	ldr	r2, [r3, #0]
 8012b10:	f442 2280 	orr.w	r2, r2, #262144	; 0x40000
 8012b14:	601a      	str	r2, [r3, #0]
 8012b16:	681a      	ldr	r2, [r3, #0]
 8012b18:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
 8012b1c:	601a      	str	r2, [r3, #0]
      if(RCC_OscInitStruct->HSEState != RCC_HSE_OFF)
 8012b1e:	e793      	b.n	8012a48 <HAL_RCC_OscConfig+0x394>
      if((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_OFF)
 8012b20:	2801      	cmp	r0, #1
 8012b22:	f43f aeb4 	beq.w	801288e <HAL_RCC_OscConfig+0x1da>
        pll_config = RCC->PLLCFGR;
 8012b26:	4b1a      	ldr	r3, [pc, #104]	; (8012b90 <HAL_RCC_OscConfig+0x4dc>)
        if((READ_BIT(pll_config, RCC_PLLCFGR_PLLSRC)  != RCC_OscInitStruct->PLL.PLLSource) ||
 8012b28:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
        pll_config = RCC->PLLCFGR;
 8012b2a:	68db      	ldr	r3, [r3, #12]
        if((READ_BIT(pll_config, RCC_PLLCFGR_PLLSRC)  != RCC_OscInitStruct->PLL.PLLSource) ||
 8012b2c:	f003 0103 	and.w	r1, r3, #3
 8012b30:	4291      	cmp	r1, r2
 8012b32:	f47f af23 	bne.w	801297c <HAL_RCC_OscConfig+0x2c8>
           (READ_BIT(pll_config, RCC_PLLCFGR_PLLM)    != ((RCC_OscInitStruct->PLL.PLLM - 1U) << RCC_PLLCFGR_PLLM_Pos)) ||
 8012b36:	6b21      	ldr	r1, [r4, #48]	; 0x30
 8012b38:	f003 0270 	and.w	r2, r3, #112	; 0x70
 8012b3c:	3901      	subs	r1, #1
        if((READ_BIT(pll_config, RCC_PLLCFGR_PLLSRC)  != RCC_OscInitStruct->PLL.PLLSource) ||
 8012b3e:	ebb2 1f01 	cmp.w	r2, r1, lsl #4
 8012b42:	f47f af1b 	bne.w	801297c <HAL_RCC_OscConfig+0x2c8>
           (READ_BIT(pll_config, RCC_PLLCFGR_PLLN)    != (RCC_OscInitStruct->PLL.PLLN << RCC_PLLCFGR_PLLN_Pos)) ||
 8012b46:	6b61      	ldr	r1, [r4, #52]	; 0x34
 8012b48:	f403 42fe 	and.w	r2, r3, #32512	; 0x7f00
           (READ_BIT(pll_config, RCC_PLLCFGR_PLLM)    != ((RCC_OscInitStruct->PLL.PLLM - 1U) << RCC_PLLCFGR_PLLM_Pos)) ||
 8012b4c:	ebb2 2f01 	cmp.w	r2, r1, lsl #8
 8012b50:	f47f af14 	bne.w	801297c <HAL_RCC_OscConfig+0x2c8>
           (READ_BIT(pll_config, RCC_PLLCFGR_PLLP)    != ((RCC_OscInitStruct->PLL.PLLP == RCC_PLLP_DIV7) ? 0U : 1U)) ||
 8012b54:	6ba2      	ldr	r2, [r4, #56]	; 0x38
 8012b56:	3a07      	subs	r2, #7
 8012b58:	f403 3100 	and.w	r1, r3, #131072	; 0x20000
 8012b5c:	bf18      	it	ne
 8012b5e:	2201      	movne	r2, #1
           (READ_BIT(pll_config, RCC_PLLCFGR_PLLN)    != (RCC_OscInitStruct->PLL.PLLN << RCC_PLLCFGR_PLLN_Pos)) ||
 8012b60:	4291      	cmp	r1, r2
 8012b62:	f47f af0b 	bne.w	801297c <HAL_RCC_OscConfig+0x2c8>
           (READ_BIT(pll_config, RCC_PLLCFGR_PLLQ)    != ((((RCC_OscInitStruct->PLL.PLLQ) >> 1U) - 1U) << RCC_PLLCFGR_PLLQ_Pos)) ||
 8012b66:	6be2      	ldr	r2, [r4, #60]	; 0x3c
 8012b68:	0852      	lsrs	r2, r2, #1
 8012b6a:	f403 01c0 	and.w	r1, r3, #6291456	; 0x600000
 8012b6e:	3a01      	subs	r2, #1
           (READ_BIT(pll_config, RCC_PLLCFGR_PLLP)    != ((RCC_OscInitStruct->PLL.PLLP == RCC_PLLP_DIV7) ? 0U : 1U)) ||
 8012b70:	ebb1 5f42 	cmp.w	r1, r2, lsl #21
 8012b74:	f47f af02 	bne.w	801297c <HAL_RCC_OscConfig+0x2c8>
           (READ_BIT(pll_config, RCC_PLLCFGR_PLLR)    != ((((RCC_OscInitStruct->PLL.PLLR) >> 1U) - 1U) << RCC_PLLCFGR_PLLR_Pos)))
 8012b78:	6c22      	ldr	r2, [r4, #64]	; 0x40
 8012b7a:	0852      	lsrs	r2, r2, #1
 8012b7c:	f003 63c0 	and.w	r3, r3, #100663296	; 0x6000000
 8012b80:	3a01      	subs	r2, #1
           (READ_BIT(pll_config, RCC_PLLCFGR_PLLQ)    != ((((RCC_OscInitStruct->PLL.PLLQ) >> 1U) - 1U) << RCC_PLLCFGR_PLLQ_Pos)) ||
 8012b82:	ebb3 6f42 	cmp.w	r3, r2, lsl #25
        return HAL_ERROR;
 8012b86:	bf14      	ite	ne
 8012b88:	2001      	movne	r0, #1
 8012b8a:	2000      	moveq	r0, #0
 8012b8c:	e67f      	b.n	801288e <HAL_RCC_OscConfig+0x1da>
 8012b8e:	bf00      	nop
 8012b90:	40021000 	.word	0x40021000
 8012b94:	0802d318 	.word	0x0802d318
 8012b98:	20000124 	.word	0x20000124
 8012b9c:	2000011c 	.word	0x2000011c
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 8012ba0:	4b28      	ldr	r3, [pc, #160]	; (8012c44 <HAL_RCC_OscConfig+0x590>)
 8012ba2:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
 8012ba6:	f042 0204 	orr.w	r2, r2, #4
 8012baa:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
 8012bae:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
 8012bb2:	f042 0201 	orr.w	r2, r2, #1
 8012bb6:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
    if(RCC_OscInitStruct->LSEState != RCC_LSE_OFF)
 8012bba:	e770      	b.n	8012a9e <HAL_RCC_OscConfig+0x3ea>
        __HAL_RCC_PLL_DISABLE();
 8012bbc:	4d21      	ldr	r5, [pc, #132]	; (8012c44 <HAL_RCC_OscConfig+0x590>)
 8012bbe:	682b      	ldr	r3, [r5, #0]
 8012bc0:	f023 7380 	bic.w	r3, r3, #16777216	; 0x1000000
 8012bc4:	602b      	str	r3, [r5, #0]
        tickstart = HAL_GetTick();
 8012bc6:	f7fc fe37 	bl	800f838 <HAL_GetTick>
 8012bca:	4606      	mov	r6, r0
        while(READ_BIT(RCC->CR, RCC_CR_PLLRDY) != 0U)
 8012bcc:	e005      	b.n	8012bda <HAL_RCC_OscConfig+0x526>
          if((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
 8012bce:	f7fc fe33 	bl	800f838 <HAL_GetTick>
 8012bd2:	1b80      	subs	r0, r0, r6
 8012bd4:	2802      	cmp	r0, #2
 8012bd6:	f63f af04 	bhi.w	80129e2 <HAL_RCC_OscConfig+0x32e>
        while(READ_BIT(RCC->CR, RCC_CR_PLLRDY) != 0U)
 8012bda:	682b      	ldr	r3, [r5, #0]
 8012bdc:	0199      	lsls	r1, r3, #6
 8012bde:	d4f6      	bmi.n	8012bce <HAL_RCC_OscConfig+0x51a>
        __HAL_RCC_PLL_CONFIG(RCC_OscInitStruct->PLL.PLLSource,
 8012be0:	68e9      	ldr	r1, [r5, #12]
 8012be2:	4b19      	ldr	r3, [pc, #100]	; (8012c48 <HAL_RCC_OscConfig+0x594>)
 8012be4:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
        while(READ_BIT(RCC->CR, RCC_CR_PLLRDY) == 0U)
 8012be6:	4e17      	ldr	r6, [pc, #92]	; (8012c44 <HAL_RCC_OscConfig+0x590>)
        __HAL_RCC_PLL_CONFIG(RCC_OscInitStruct->PLL.PLLSource,
 8012be8:	400b      	ands	r3, r1
 8012bea:	4313      	orrs	r3, r2
 8012bec:	e9d4 210c 	ldrd	r2, r1, [r4, #48]	; 0x30
 8012bf0:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
 8012bf4:	e9d4 010e 	ldrd	r0, r1, [r4, #56]	; 0x38
 8012bf8:	3a01      	subs	r2, #1
 8012bfa:	ea43 1302 	orr.w	r3, r3, r2, lsl #4
 8012bfe:	6c22      	ldr	r2, [r4, #64]	; 0x40
 8012c00:	0900      	lsrs	r0, r0, #4
 8012c02:	0849      	lsrs	r1, r1, #1
 8012c04:	ea43 4340 	orr.w	r3, r3, r0, lsl #17
 8012c08:	3901      	subs	r1, #1
 8012c0a:	0852      	lsrs	r2, r2, #1
 8012c0c:	ea43 5341 	orr.w	r3, r3, r1, lsl #21
 8012c10:	3a01      	subs	r2, #1
 8012c12:	ea43 6342 	orr.w	r3, r3, r2, lsl #25
 8012c16:	60eb      	str	r3, [r5, #12]
        __HAL_RCC_PLL_ENABLE();
 8012c18:	682b      	ldr	r3, [r5, #0]
 8012c1a:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 8012c1e:	602b      	str	r3, [r5, #0]
        __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_SYSCLK);
 8012c20:	68eb      	ldr	r3, [r5, #12]
 8012c22:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 8012c26:	60eb      	str	r3, [r5, #12]
        tickstart = HAL_GetTick();
 8012c28:	f7fc fe06 	bl	800f838 <HAL_GetTick>
 8012c2c:	4604      	mov	r4, r0
        while(READ_BIT(RCC->CR, RCC_CR_PLLRDY) == 0U)
 8012c2e:	e005      	b.n	8012c3c <HAL_RCC_OscConfig+0x588>
          if((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
 8012c30:	f7fc fe02 	bl	800f838 <HAL_GetTick>
 8012c34:	1b00      	subs	r0, r0, r4
 8012c36:	2802      	cmp	r0, #2
 8012c38:	f63f aed3 	bhi.w	80129e2 <HAL_RCC_OscConfig+0x32e>
        while(READ_BIT(RCC->CR, RCC_CR_PLLRDY) == 0U)
 8012c3c:	6833      	ldr	r3, [r6, #0]
 8012c3e:	019a      	lsls	r2, r3, #6
 8012c40:	d5f6      	bpl.n	8012c30 <HAL_RCC_OscConfig+0x57c>
 8012c42:	e623      	b.n	801288c <HAL_RCC_OscConfig+0x1d8>
 8012c44:	40021000 	.word	0x40021000
 8012c48:	f99d808c 	.word	0xf99d808c

08012c4c <HAL_RCC_ClockConfig>:
  if(RCC_ClkInitStruct == NULL)
 8012c4c:	2800      	cmp	r0, #0
 8012c4e:	f000 8081 	beq.w	8012d54 <HAL_RCC_ClockConfig+0x108>
  if(FLatency > __HAL_FLASH_GET_LATENCY())
 8012c52:	4a45      	ldr	r2, [pc, #276]	; (8012d68 <HAL_RCC_ClockConfig+0x11c>)
 8012c54:	6813      	ldr	r3, [r2, #0]
 8012c56:	f003 0307 	and.w	r3, r3, #7
 8012c5a:	428b      	cmp	r3, r1
{
 8012c5c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8012c60:	460d      	mov	r5, r1
 8012c62:	4604      	mov	r4, r0
  if(FLatency > __HAL_FLASH_GET_LATENCY())
 8012c64:	d20c      	bcs.n	8012c80 <HAL_RCC_ClockConfig+0x34>
    __HAL_FLASH_SET_LATENCY(FLatency);
 8012c66:	6813      	ldr	r3, [r2, #0]
 8012c68:	f023 0307 	bic.w	r3, r3, #7
 8012c6c:	430b      	orrs	r3, r1
 8012c6e:	6013      	str	r3, [r2, #0]
    if(__HAL_FLASH_GET_LATENCY() != FLatency)
 8012c70:	6813      	ldr	r3, [r2, #0]
 8012c72:	f003 0307 	and.w	r3, r3, #7
 8012c76:	428b      	cmp	r3, r1
 8012c78:	d002      	beq.n	8012c80 <HAL_RCC_ClockConfig+0x34>
    return HAL_ERROR;
 8012c7a:	2001      	movs	r0, #1
}
 8012c7c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)
 8012c80:	6823      	ldr	r3, [r4, #0]
 8012c82:	07da      	lsls	r2, r3, #31
 8012c84:	d43f      	bmi.n	8012d06 <HAL_RCC_ClockConfig+0xba>
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
 8012c86:	0799      	lsls	r1, r3, #30
 8012c88:	d506      	bpl.n	8012c98 <HAL_RCC_ClockConfig+0x4c>
    MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, RCC_ClkInitStruct->AHBCLKDivider);
 8012c8a:	4938      	ldr	r1, [pc, #224]	; (8012d6c <HAL_RCC_ClockConfig+0x120>)
 8012c8c:	68a0      	ldr	r0, [r4, #8]
 8012c8e:	688a      	ldr	r2, [r1, #8]
 8012c90:	f022 02f0 	bic.w	r2, r2, #240	; 0xf0
 8012c94:	4302      	orrs	r2, r0
 8012c96:	608a      	str	r2, [r1, #8]
  if(FLatency < __HAL_FLASH_GET_LATENCY())
 8012c98:	4933      	ldr	r1, [pc, #204]	; (8012d68 <HAL_RCC_ClockConfig+0x11c>)
 8012c9a:	680a      	ldr	r2, [r1, #0]
 8012c9c:	f002 0207 	and.w	r2, r2, #7
 8012ca0:	42aa      	cmp	r2, r5
 8012ca2:	d909      	bls.n	8012cb8 <HAL_RCC_ClockConfig+0x6c>
    __HAL_FLASH_SET_LATENCY(FLatency);
 8012ca4:	680a      	ldr	r2, [r1, #0]
 8012ca6:	f022 0207 	bic.w	r2, r2, #7
 8012caa:	432a      	orrs	r2, r5
 8012cac:	600a      	str	r2, [r1, #0]
    if(__HAL_FLASH_GET_LATENCY() != FLatency)
 8012cae:	680a      	ldr	r2, [r1, #0]
 8012cb0:	f002 0207 	and.w	r2, r2, #7
 8012cb4:	42aa      	cmp	r2, r5
 8012cb6:	d1e0      	bne.n	8012c7a <HAL_RCC_ClockConfig+0x2e>
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
 8012cb8:	075a      	lsls	r2, r3, #29
 8012cba:	d506      	bpl.n	8012cca <HAL_RCC_ClockConfig+0x7e>
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE1, RCC_ClkInitStruct->APB1CLKDivider);
 8012cbc:	492b      	ldr	r1, [pc, #172]	; (8012d6c <HAL_RCC_ClockConfig+0x120>)
 8012cbe:	68e0      	ldr	r0, [r4, #12]
 8012cc0:	688a      	ldr	r2, [r1, #8]
 8012cc2:	f422 62e0 	bic.w	r2, r2, #1792	; 0x700
 8012cc6:	4302      	orrs	r2, r0
 8012cc8:	608a      	str	r2, [r1, #8]
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
 8012cca:	071b      	lsls	r3, r3, #28
 8012ccc:	d507      	bpl.n	8012cde <HAL_RCC_ClockConfig+0x92>
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE2, ((RCC_ClkInitStruct->APB2CLKDivider) << 3U));
 8012cce:	4a27      	ldr	r2, [pc, #156]	; (8012d6c <HAL_RCC_ClockConfig+0x120>)
 8012cd0:	6921      	ldr	r1, [r4, #16]
 8012cd2:	6893      	ldr	r3, [r2, #8]
 8012cd4:	f423 5360 	bic.w	r3, r3, #14336	; 0x3800
 8012cd8:	ea43 03c1 	orr.w	r3, r3, r1, lsl #3
 8012cdc:	6093      	str	r3, [r2, #8]
  SystemCoreClock = HAL_RCC_GetSysClockFreq() >> (AHBPrescTable[READ_BIT(RCC->CFGR, RCC_CFGR_HPRE) >> RCC_CFGR_HPRE_Pos] & 0x1FU);
 8012cde:	f7ff fc8f 	bl	8012600 <HAL_RCC_GetSysClockFreq>
 8012ce2:	4a22      	ldr	r2, [pc, #136]	; (8012d6c <HAL_RCC_ClockConfig+0x120>)
 8012ce4:	4c22      	ldr	r4, [pc, #136]	; (8012d70 <HAL_RCC_ClockConfig+0x124>)
 8012ce6:	6892      	ldr	r2, [r2, #8]
 8012ce8:	4922      	ldr	r1, [pc, #136]	; (8012d74 <HAL_RCC_ClockConfig+0x128>)
 8012cea:	f3c2 1203 	ubfx	r2, r2, #4, #4
 8012cee:	4603      	mov	r3, r0
 8012cf0:	5ca2      	ldrb	r2, [r4, r2]
  status = HAL_InitTick(uwTickPrio);
 8012cf2:	4821      	ldr	r0, [pc, #132]	; (8012d78 <HAL_RCC_ClockConfig+0x12c>)
  SystemCoreClock = HAL_RCC_GetSysClockFreq() >> (AHBPrescTable[READ_BIT(RCC->CFGR, RCC_CFGR_HPRE) >> RCC_CFGR_HPRE_Pos] & 0x1FU);
 8012cf4:	f002 021f 	and.w	r2, r2, #31
 8012cf8:	40d3      	lsrs	r3, r2
}
 8012cfa:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
  status = HAL_InitTick(uwTickPrio);
 8012cfe:	6800      	ldr	r0, [r0, #0]
  SystemCoreClock = HAL_RCC_GetSysClockFreq() >> (AHBPrescTable[READ_BIT(RCC->CFGR, RCC_CFGR_HPRE) >> RCC_CFGR_HPRE_Pos] & 0x1FU);
 8012d00:	600b      	str	r3, [r1, #0]
  status = HAL_InitTick(uwTickPrio);
 8012d02:	f7fc bd59 	b.w	800f7b8 <HAL_InitTick>
    if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
 8012d06:	6862      	ldr	r2, [r4, #4]
      if(READ_BIT(RCC->CR, RCC_CR_PLLRDY) == 0U)
 8012d08:	4b18      	ldr	r3, [pc, #96]	; (8012d6c <HAL_RCC_ClockConfig+0x120>)
    if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
 8012d0a:	2a03      	cmp	r2, #3
      if(READ_BIT(RCC->CR, RCC_CR_PLLRDY) == 0U)
 8012d0c:	681b      	ldr	r3, [r3, #0]
    if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
 8012d0e:	d023      	beq.n	8012d58 <HAL_RCC_ClockConfig+0x10c>
      if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 8012d10:	2a02      	cmp	r2, #2
 8012d12:	d01c      	beq.n	8012d4e <HAL_RCC_ClockConfig+0x102>
      else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_MSI)
 8012d14:	bb2a      	cbnz	r2, 8012d62 <HAL_RCC_ClockConfig+0x116>
        if(READ_BIT(RCC->CR, RCC_CR_MSIRDY) == 0U)
 8012d16:	079e      	lsls	r6, r3, #30
 8012d18:	d5af      	bpl.n	8012c7a <HAL_RCC_ClockConfig+0x2e>
    MODIFY_REG(RCC->CFGR, RCC_CFGR_SW, RCC_ClkInitStruct->SYSCLKSource);
 8012d1a:	4e14      	ldr	r6, [pc, #80]	; (8012d6c <HAL_RCC_ClockConfig+0x120>)
 8012d1c:	68b3      	ldr	r3, [r6, #8]
 8012d1e:	f023 0303 	bic.w	r3, r3, #3
 8012d22:	4313      	orrs	r3, r2
 8012d24:	60b3      	str	r3, [r6, #8]
    tickstart = HAL_GetTick();
 8012d26:	f7fc fd87 	bl	800f838 <HAL_GetTick>
      if((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
 8012d2a:	f241 3888 	movw	r8, #5000	; 0x1388
    tickstart = HAL_GetTick();
 8012d2e:	4607      	mov	r7, r0
    while(__HAL_RCC_GET_SYSCLK_SOURCE() != (RCC_ClkInitStruct->SYSCLKSource << RCC_CFGR_SWS_Pos))
 8012d30:	e004      	b.n	8012d3c <HAL_RCC_ClockConfig+0xf0>
      if((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
 8012d32:	f7fc fd81 	bl	800f838 <HAL_GetTick>
 8012d36:	1bc0      	subs	r0, r0, r7
 8012d38:	4540      	cmp	r0, r8
 8012d3a:	d810      	bhi.n	8012d5e <HAL_RCC_ClockConfig+0x112>
    while(__HAL_RCC_GET_SYSCLK_SOURCE() != (RCC_ClkInitStruct->SYSCLKSource << RCC_CFGR_SWS_Pos))
 8012d3c:	68b3      	ldr	r3, [r6, #8]
 8012d3e:	6862      	ldr	r2, [r4, #4]
 8012d40:	f003 030c 	and.w	r3, r3, #12
 8012d44:	ebb3 0f82 	cmp.w	r3, r2, lsl #2
 8012d48:	d1f3      	bne.n	8012d32 <HAL_RCC_ClockConfig+0xe6>
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
 8012d4a:	6823      	ldr	r3, [r4, #0]
 8012d4c:	e79b      	b.n	8012c86 <HAL_RCC_ClockConfig+0x3a>
        if(READ_BIT(RCC->CR, RCC_CR_HSERDY) == 0U)
 8012d4e:	039f      	lsls	r7, r3, #14
 8012d50:	d4e3      	bmi.n	8012d1a <HAL_RCC_ClockConfig+0xce>
 8012d52:	e792      	b.n	8012c7a <HAL_RCC_ClockConfig+0x2e>
    return HAL_ERROR;
 8012d54:	2001      	movs	r0, #1
}
 8012d56:	4770      	bx	lr
      if(READ_BIT(RCC->CR, RCC_CR_PLLRDY) == 0U)
 8012d58:	019b      	lsls	r3, r3, #6
 8012d5a:	d4de      	bmi.n	8012d1a <HAL_RCC_ClockConfig+0xce>
 8012d5c:	e78d      	b.n	8012c7a <HAL_RCC_ClockConfig+0x2e>
        return HAL_TIMEOUT;
 8012d5e:	2003      	movs	r0, #3
 8012d60:	e78c      	b.n	8012c7c <HAL_RCC_ClockConfig+0x30>
        if(READ_BIT(RCC->CR, RCC_CR_HSIRDY) == 0U)
 8012d62:	0558      	lsls	r0, r3, #21
 8012d64:	d589      	bpl.n	8012c7a <HAL_RCC_ClockConfig+0x2e>
 8012d66:	e7d8      	b.n	8012d1a <HAL_RCC_ClockConfig+0xce>
 8012d68:	40022000 	.word	0x40022000
 8012d6c:	40021000 	.word	0x40021000
 8012d70:	0802d318 	.word	0x0802d318
 8012d74:	2000011c 	.word	0x2000011c
 8012d78:	20000124 	.word	0x20000124

08012d7c <HAL_RCC_GetHCLKFreq>:
  return SystemCoreClock;
 8012d7c:	4b01      	ldr	r3, [pc, #4]	; (8012d84 <HAL_RCC_GetHCLKFreq+0x8>)
}
 8012d7e:	6818      	ldr	r0, [r3, #0]
 8012d80:	4770      	bx	lr
 8012d82:	bf00      	nop
 8012d84:	2000011c 	.word	0x2000011c

08012d88 <HAL_RCC_GetPCLK1Freq>:
  return (HAL_RCC_GetHCLKFreq() >> (APBPrescTable[READ_BIT(RCC->CFGR, RCC_CFGR_PPRE1) >> RCC_CFGR_PPRE1_Pos] & 0x1FU));
 8012d88:	4b05      	ldr	r3, [pc, #20]	; (8012da0 <HAL_RCC_GetPCLK1Freq+0x18>)
 8012d8a:	4a06      	ldr	r2, [pc, #24]	; (8012da4 <HAL_RCC_GetPCLK1Freq+0x1c>)
 8012d8c:	689b      	ldr	r3, [r3, #8]
  return SystemCoreClock;
 8012d8e:	4906      	ldr	r1, [pc, #24]	; (8012da8 <HAL_RCC_GetPCLK1Freq+0x20>)
  return (HAL_RCC_GetHCLKFreq() >> (APBPrescTable[READ_BIT(RCC->CFGR, RCC_CFGR_PPRE1) >> RCC_CFGR_PPRE1_Pos] & 0x1FU));
 8012d90:	f3c3 2302 	ubfx	r3, r3, #8, #3
 8012d94:	6808      	ldr	r0, [r1, #0]
 8012d96:	5cd3      	ldrb	r3, [r2, r3]
 8012d98:	f003 031f 	and.w	r3, r3, #31
}
 8012d9c:	40d8      	lsrs	r0, r3
 8012d9e:	4770      	bx	lr
 8012da0:	40021000 	.word	0x40021000
 8012da4:	0802d328 	.word	0x0802d328
 8012da8:	2000011c 	.word	0x2000011c

08012dac <HAL_RCC_GetPCLK2Freq>:
  return (HAL_RCC_GetHCLKFreq()>> (APBPrescTable[READ_BIT(RCC->CFGR, RCC_CFGR_PPRE2) >> RCC_CFGR_PPRE2_Pos] & 0x1FU));
 8012dac:	4b05      	ldr	r3, [pc, #20]	; (8012dc4 <HAL_RCC_GetPCLK2Freq+0x18>)
 8012dae:	4a06      	ldr	r2, [pc, #24]	; (8012dc8 <HAL_RCC_GetPCLK2Freq+0x1c>)
 8012db0:	689b      	ldr	r3, [r3, #8]
  return SystemCoreClock;
 8012db2:	4906      	ldr	r1, [pc, #24]	; (8012dcc <HAL_RCC_GetPCLK2Freq+0x20>)
  return (HAL_RCC_GetHCLKFreq()>> (APBPrescTable[READ_BIT(RCC->CFGR, RCC_CFGR_PPRE2) >> RCC_CFGR_PPRE2_Pos] & 0x1FU));
 8012db4:	f3c3 23c2 	ubfx	r3, r3, #11, #3
 8012db8:	6808      	ldr	r0, [r1, #0]
 8012dba:	5cd3      	ldrb	r3, [r2, r3]
 8012dbc:	f003 031f 	and.w	r3, r3, #31
}
 8012dc0:	40d8      	lsrs	r0, r3
 8012dc2:	4770      	bx	lr
 8012dc4:	40021000 	.word	0x40021000
 8012dc8:	0802d328 	.word	0x0802d328
 8012dcc:	2000011c 	.word	0x2000011c

08012dd0 <RCCEx_GetSAIxPeriphCLKFreq>:
#if defined(RCC_PLLP_SUPPORT)
  uint32_t pllp = 0U;
#endif /* RCC_PLLP_SUPPORT */

  /* Handle SAIs */
  if(PeriphClk == RCC_PERIPHCLK_SAI1)
 8012dd0:	f5b0 6f00 	cmp.w	r0, #2048	; 0x800
{
 8012dd4:	b410      	push	{r4}
  if(PeriphClk == RCC_PERIPHCLK_SAI1)
 8012dd6:	d039      	beq.n	8012e4c <RCCEx_GetSAIxPeriphCLKFreq+0x7c>
    /* Else, PLL clock output to check below */
  }
#if defined(SAI2)
  else
  {
    if(PeriphClk == RCC_PERIPHCLK_SAI2)
 8012dd8:	f5b0 5f80 	cmp.w	r0, #4096	; 0x1000
 8012ddc:	d01a      	beq.n	8012e14 <RCCEx_GetSAIxPeriphCLKFreq+0x44>
        frequency = (pllvco * plln) / pllp;
      }
    }
    else if(srcclk == 0U)  /* RCC_SAI1CLKSOURCE_PLLSAI1 || RCC_SAI2CLKSOURCE_PLLSAI1 */
    {
      if(__HAL_RCC_GET_PLLSAI1CLKOUT_CONFIG(RCC_PLLSAI1_SAI1CLK) != 0U)
 8012dde:	4a38      	ldr	r2, [pc, #224]	; (8012ec0 <RCCEx_GetSAIxPeriphCLKFreq+0xf0>)
 8012de0:	6910      	ldr	r0, [r2, #16]
 8012de2:	f410 3080 	ands.w	r0, r0, #65536	; 0x10000
 8012de6:	d05a      	beq.n	8012e9e <RCCEx_GetSAIxPeriphCLKFreq+0xce>
        /* PLLSAI1M exists: apply PLLSAI1M divider for PLLSAI1 output computation */
        /* f(PLLSAI1 Source) / PLLSAI1M */
        pllvco = (pllvco / ((READ_BIT(RCC->PLLSAI1CFGR, RCC_PLLSAI1CFGR_PLLSAI1M) >> RCC_PLLSAI1CFGR_PLLSAI1M_Pos) + 1U));
#else
        /* f(PLL Source) / PLLM */
        pllvco = (pllvco / ((READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLM) >> RCC_PLLCFGR_PLLM_Pos) + 1U));
 8012de8:	68d3      	ldr	r3, [r2, #12]
#endif
        /* f(PLLSAI1CLK) = f(VCOSAI1 input) * PLLSAI1N / PLLSAI1P */
        plln = READ_BIT(RCC->PLLSAI1CFGR, RCC_PLLSAI1CFGR_PLLSAI1N) >> RCC_PLLSAI1CFGR_PLLSAI1N_Pos;
 8012dea:	6910      	ldr	r0, [r2, #16]
#if defined(RCC_PLLSAI1P_DIV_2_31_SUPPORT)
        pllp = READ_BIT(RCC->PLLSAI1CFGR, RCC_PLLSAI1CFGR_PLLSAI1PDIV) >> RCC_PLLSAI1CFGR_PLLSAI1PDIV_Pos;
#endif
        if(pllp == 0U)
        {
          if(READ_BIT(RCC->PLLSAI1CFGR, RCC_PLLSAI1CFGR_PLLSAI1P) != 0U)
 8012dec:	6914      	ldr	r4, [r2, #16]
          {
            pllp = 17U;
          }
          else
          {
            pllp = 7U;
 8012dee:	f414 3f00 	tst.w	r4, #131072	; 0x20000
        plln = READ_BIT(RCC->PLLSAI2CFGR, RCC_PLLSAI2CFGR_PLLSAI2N) >> RCC_PLLSAI2CFGR_PLLSAI2N_Pos;
 8012df2:	f3c0 2206 	ubfx	r2, r0, #8, #7
        pllvco = (pllvco / ((READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLM) >> RCC_PLLCFGR_PLLM_Pos) + 1U));
 8012df6:	f3c3 1302 	ubfx	r3, r3, #4, #3
            pllp = 7U;
 8012dfa:	bf14      	ite	ne
 8012dfc:	2411      	movne	r4, #17
 8012dfe:	2407      	moveq	r4, #7
        pllvco = (pllvco / ((READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLM) >> RCC_PLLCFGR_PLLM_Pos) + 1U));
 8012e00:	3301      	adds	r3, #1
 8012e02:	fbb1 f0f3 	udiv	r0, r1, r3
          }
        }
        frequency = (pllvco * plln) / pllp;
 8012e06:	fb02 f000 	mul.w	r0, r2, r0
 8012e0a:	fbb0 f0f4 	udiv	r0, r0, r4
    }
  }


  return frequency;
}
 8012e0e:	f85d 4b04 	ldr.w	r4, [sp], #4
 8012e12:	4770      	bx	lr
      srcclk = __HAL_RCC_GET_SAI2_SOURCE();
 8012e14:	f100 4380 	add.w	r3, r0, #1073741824	; 0x40000000
 8012e18:	f503 3300 	add.w	r3, r3, #131072	; 0x20000
 8012e1c:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 8012e20:	f003 7340 	and.w	r3, r3, #50331648	; 0x3000000
      if(srcclk == RCC_SAI2CLKSOURCE_PIN)
 8012e24:	f1b3 7f40 	cmp.w	r3, #50331648	; 0x3000000
 8012e28:	d03c      	beq.n	8012ea4 <RCCEx_GetSAIxPeriphCLKFreq+0xd4>
    if((srcclk == RCC_SAI1CLKSOURCE_PLL) || (srcclk == RCC_SAI2CLKSOURCE_PLL))
 8012e2a:	f1b3 7f00 	cmp.w	r3, #33554432	; 0x2000000
 8012e2e:	d01b      	beq.n	8012e68 <RCCEx_GetSAIxPeriphCLKFreq+0x98>
    else if(srcclk == 0U)  /* RCC_SAI1CLKSOURCE_PLLSAI1 || RCC_SAI2CLKSOURCE_PLLSAI1 */
 8012e30:	2b00      	cmp	r3, #0
 8012e32:	d0d4      	beq.n	8012dde <RCCEx_GetSAIxPeriphCLKFreq+0xe>
    else if((srcclk == RCC_SAI1CLKSOURCE_PLLSAI2) || (srcclk == RCC_SAI2CLKSOURCE_PLLSAI2))
 8012e34:	f1b3 7f80 	cmp.w	r3, #16777216	; 0x1000000
 8012e38:	d13e      	bne.n	8012eb8 <RCCEx_GetSAIxPeriphCLKFreq+0xe8>
      if(__HAL_RCC_GET_PLLSAI2CLKOUT_CONFIG(RCC_PLLSAI2_SAI2CLK) != 0U)
 8012e3a:	4a21      	ldr	r2, [pc, #132]	; (8012ec0 <RCCEx_GetSAIxPeriphCLKFreq+0xf0>)
 8012e3c:	6950      	ldr	r0, [r2, #20]
 8012e3e:	f410 3080 	ands.w	r0, r0, #65536	; 0x10000
 8012e42:	d02c      	beq.n	8012e9e <RCCEx_GetSAIxPeriphCLKFreq+0xce>
        pllvco = (pllvco / ((READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLM) >> RCC_PLLCFGR_PLLM_Pos) + 1U));
 8012e44:	68d3      	ldr	r3, [r2, #12]
        plln = READ_BIT(RCC->PLLSAI2CFGR, RCC_PLLSAI2CFGR_PLLSAI2N) >> RCC_PLLSAI2CFGR_PLLSAI2N_Pos;
 8012e46:	6950      	ldr	r0, [r2, #20]
          if(READ_BIT(RCC->PLLSAI2CFGR, RCC_PLLSAI2CFGR_PLLSAI2P) != 0U)
 8012e48:	6954      	ldr	r4, [r2, #20]
 8012e4a:	e7d0      	b.n	8012dee <RCCEx_GetSAIxPeriphCLKFreq+0x1e>
    srcclk = __HAL_RCC_GET_SAI1_SOURCE();
 8012e4c:	f100 4380 	add.w	r3, r0, #1073741824	; 0x40000000
 8012e50:	f503 3302 	add.w	r3, r3, #133120	; 0x20800
 8012e54:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 8012e58:	f403 0340 	and.w	r3, r3, #12582912	; 0xc00000
    if(srcclk == RCC_SAI1CLKSOURCE_PIN)
 8012e5c:	f5b3 0f40 	cmp.w	r3, #12582912	; 0xc00000
 8012e60:	d020      	beq.n	8012ea4 <RCCEx_GetSAIxPeriphCLKFreq+0xd4>
    if((srcclk == RCC_SAI1CLKSOURCE_PLL) || (srcclk == RCC_SAI2CLKSOURCE_PLL))
 8012e62:	f5b3 0f00 	cmp.w	r3, #8388608	; 0x800000
 8012e66:	d122      	bne.n	8012eae <RCCEx_GetSAIxPeriphCLKFreq+0xde>
      if(__HAL_RCC_GET_PLLCLKOUT_CONFIG(RCC_PLL_SAI3CLK) != 0U)
 8012e68:	4a15      	ldr	r2, [pc, #84]	; (8012ec0 <RCCEx_GetSAIxPeriphCLKFreq+0xf0>)
 8012e6a:	68d0      	ldr	r0, [r2, #12]
 8012e6c:	f410 3080 	ands.w	r0, r0, #65536	; 0x10000
 8012e70:	d015      	beq.n	8012e9e <RCCEx_GetSAIxPeriphCLKFreq+0xce>
        pllvco = (pllvco / ((READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLM) >> RCC_PLLCFGR_PLLM_Pos) + 1U));
 8012e72:	68d3      	ldr	r3, [r2, #12]
        plln = READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos;
 8012e74:	68d0      	ldr	r0, [r2, #12]
          if(READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLP) != 0U)
 8012e76:	68d4      	ldr	r4, [r2, #12]
        pllvco = (pllvco / ((READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLM) >> RCC_PLLCFGR_PLLM_Pos) + 1U));
 8012e78:	f3c3 1302 	ubfx	r3, r3, #4, #3
        plln = READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos;
 8012e7c:	f3c0 2206 	ubfx	r2, r0, #8, #7
            pllp = 7U;
 8012e80:	f414 3f00 	tst.w	r4, #131072	; 0x20000
        pllvco = (pllvco / ((READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLM) >> RCC_PLLCFGR_PLLM_Pos) + 1U));
 8012e84:	f103 0301 	add.w	r3, r3, #1
            pllp = 7U;
 8012e88:	bf14      	ite	ne
 8012e8a:	f04f 0c11 	movne.w	ip, #17
 8012e8e:	f04f 0c07 	moveq.w	ip, #7
        pllvco = (pllvco / ((READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLM) >> RCC_PLLCFGR_PLLM_Pos) + 1U));
 8012e92:	fbb1 f0f3 	udiv	r0, r1, r3
        frequency = (pllvco * plln) / pllp;
 8012e96:	fb02 f000 	mul.w	r0, r2, r0
 8012e9a:	fbb0 f0fc 	udiv	r0, r0, ip
}
 8012e9e:	f85d 4b04 	ldr.w	r4, [sp], #4
 8012ea2:	4770      	bx	lr
      frequency = EXTERNAL_SAI1_CLOCK_VALUE;
 8012ea4:	f64b 3080 	movw	r0, #48000	; 0xbb80
}
 8012ea8:	f85d 4b04 	ldr.w	r4, [sp], #4
 8012eac:	4770      	bx	lr
    else if(srcclk == 0U)  /* RCC_SAI1CLKSOURCE_PLLSAI1 || RCC_SAI2CLKSOURCE_PLLSAI1 */
 8012eae:	2b00      	cmp	r3, #0
 8012eb0:	d095      	beq.n	8012dde <RCCEx_GetSAIxPeriphCLKFreq+0xe>
    else if((srcclk == RCC_SAI1CLKSOURCE_PLLSAI2) || (srcclk == RCC_SAI2CLKSOURCE_PLLSAI2))
 8012eb2:	f5b3 0f80 	cmp.w	r3, #4194304	; 0x400000
 8012eb6:	d0c0      	beq.n	8012e3a <RCCEx_GetSAIxPeriphCLKFreq+0x6a>
 8012eb8:	2000      	movs	r0, #0
}
 8012eba:	f85d 4b04 	ldr.w	r4, [sp], #4
 8012ebe:	4770      	bx	lr
 8012ec0:	40021000 	.word	0x40021000

08012ec4 <RCCEx_PLLSAI1_Config>:
{
 8012ec4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  if(__HAL_RCC_GET_PLL_OSCSOURCE() != RCC_PLLSOURCE_NONE)
 8012ec6:	4b47      	ldr	r3, [pc, #284]	; (8012fe4 <RCCEx_PLLSAI1_Config+0x120>)
 8012ec8:	68da      	ldr	r2, [r3, #12]
 8012eca:	0792      	lsls	r2, r2, #30
{
 8012ecc:	4604      	mov	r4, r0
 8012ece:	460f      	mov	r7, r1
  if(__HAL_RCC_GET_PLL_OSCSOURCE() != RCC_PLLSOURCE_NONE)
 8012ed0:	d007      	beq.n	8012ee2 <RCCEx_PLLSAI1_Config+0x1e>
    if((__HAL_RCC_GET_PLL_OSCSOURCE() != PllSai1->PLLSAI1Source)
 8012ed2:	68da      	ldr	r2, [r3, #12]
 8012ed4:	6801      	ldr	r1, [r0, #0]
 8012ed6:	f002 0203 	and.w	r2, r2, #3
 8012eda:	428a      	cmp	r2, r1
 8012edc:	d04c      	beq.n	8012f78 <RCCEx_PLLSAI1_Config+0xb4>
      status = HAL_ERROR;
 8012ede:	2001      	movs	r0, #1
}
 8012ee0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    switch(PllSai1->PLLSAI1Source)
 8012ee2:	6800      	ldr	r0, [r0, #0]
 8012ee4:	2802      	cmp	r0, #2
 8012ee6:	d058      	beq.n	8012f9a <RCCEx_PLLSAI1_Config+0xd6>
 8012ee8:	2803      	cmp	r0, #3
 8012eea:	d04f      	beq.n	8012f8c <RCCEx_PLLSAI1_Config+0xc8>
 8012eec:	2801      	cmp	r0, #1
 8012eee:	d1f6      	bne.n	8012ede <RCCEx_PLLSAI1_Config+0x1a>
      if(HAL_IS_BIT_CLR(RCC->CR, RCC_CR_MSIRDY))
 8012ef0:	681b      	ldr	r3, [r3, #0]
 8012ef2:	079b      	lsls	r3, r3, #30
 8012ef4:	d5f4      	bpl.n	8012ee0 <RCCEx_PLLSAI1_Config+0x1c>
      MODIFY_REG(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC | RCC_PLLCFGR_PLLM, PllSai1->PLLSAI1Source | (PllSai1->PLLSAI1M - 1U) << RCC_PLLCFGR_PLLM_Pos);
 8012ef6:	4a3b      	ldr	r2, [pc, #236]	; (8012fe4 <RCCEx_PLLSAI1_Config+0x120>)
 8012ef8:	68d3      	ldr	r3, [r2, #12]
 8012efa:	f023 0373 	bic.w	r3, r3, #115	; 0x73
 8012efe:	4318      	orrs	r0, r3
 8012f00:	6863      	ldr	r3, [r4, #4]
 8012f02:	3b01      	subs	r3, #1
 8012f04:	ea40 1003 	orr.w	r0, r0, r3, lsl #4
 8012f08:	60d0      	str	r0, [r2, #12]
    __HAL_RCC_PLLSAI1_DISABLE();
 8012f0a:	4d36      	ldr	r5, [pc, #216]	; (8012fe4 <RCCEx_PLLSAI1_Config+0x120>)
 8012f0c:	682b      	ldr	r3, [r5, #0]
 8012f0e:	f023 6380 	bic.w	r3, r3, #67108864	; 0x4000000
 8012f12:	602b      	str	r3, [r5, #0]
    tickstart = HAL_GetTick();
 8012f14:	f7fc fc90 	bl	800f838 <HAL_GetTick>
 8012f18:	4606      	mov	r6, r0
    while(READ_BIT(RCC->CR, RCC_CR_PLLSAI1RDY) != 0U)
 8012f1a:	e004      	b.n	8012f26 <RCCEx_PLLSAI1_Config+0x62>
      if((HAL_GetTick() - tickstart) > PLLSAI1_TIMEOUT_VALUE)
 8012f1c:	f7fc fc8c 	bl	800f838 <HAL_GetTick>
 8012f20:	1b83      	subs	r3, r0, r6
 8012f22:	2b02      	cmp	r3, #2
 8012f24:	d83d      	bhi.n	8012fa2 <RCCEx_PLLSAI1_Config+0xde>
    while(READ_BIT(RCC->CR, RCC_CR_PLLSAI1RDY) != 0U)
 8012f26:	682b      	ldr	r3, [r5, #0]
 8012f28:	011a      	lsls	r2, r3, #4
 8012f2a:	d4f7      	bmi.n	8012f1c <RCCEx_PLLSAI1_Config+0x58>
      if(Divider == DIVIDER_P_UPDATE)
 8012f2c:	2f00      	cmp	r7, #0
 8012f2e:	d13a      	bne.n	8012fa6 <RCCEx_PLLSAI1_Config+0xe2>
        MODIFY_REG(RCC->PLLSAI1CFGR,
 8012f30:	692b      	ldr	r3, [r5, #16]
 8012f32:	e9d4 1202 	ldrd	r1, r2, [r4, #8]
 8012f36:	f423 331f 	bic.w	r3, r3, #162816	; 0x27c00
 8012f3a:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 8012f3e:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
 8012f42:	0912      	lsrs	r2, r2, #4
 8012f44:	ea43 4342 	orr.w	r3, r3, r2, lsl #17
 8012f48:	612b      	str	r3, [r5, #16]
      __HAL_RCC_PLLSAI1_ENABLE();
 8012f4a:	4d26      	ldr	r5, [pc, #152]	; (8012fe4 <RCCEx_PLLSAI1_Config+0x120>)
 8012f4c:	682b      	ldr	r3, [r5, #0]
 8012f4e:	f043 6380 	orr.w	r3, r3, #67108864	; 0x4000000
 8012f52:	602b      	str	r3, [r5, #0]
      tickstart = HAL_GetTick();
 8012f54:	f7fc fc70 	bl	800f838 <HAL_GetTick>
 8012f58:	4606      	mov	r6, r0
      while(READ_BIT(RCC->CR, RCC_CR_PLLSAI1RDY) == 0U)
 8012f5a:	e004      	b.n	8012f66 <RCCEx_PLLSAI1_Config+0xa2>
        if((HAL_GetTick() - tickstart) > PLLSAI1_TIMEOUT_VALUE)
 8012f5c:	f7fc fc6c 	bl	800f838 <HAL_GetTick>
 8012f60:	1b83      	subs	r3, r0, r6
 8012f62:	2b02      	cmp	r3, #2
 8012f64:	d81d      	bhi.n	8012fa2 <RCCEx_PLLSAI1_Config+0xde>
      while(READ_BIT(RCC->CR, RCC_CR_PLLSAI1RDY) == 0U)
 8012f66:	682b      	ldr	r3, [r5, #0]
 8012f68:	011b      	lsls	r3, r3, #4
 8012f6a:	d5f7      	bpl.n	8012f5c <RCCEx_PLLSAI1_Config+0x98>
        __HAL_RCC_PLLSAI1CLKOUT_ENABLE(PllSai1->PLLSAI1ClockOut);
 8012f6c:	692b      	ldr	r3, [r5, #16]
 8012f6e:	69a2      	ldr	r2, [r4, #24]
 8012f70:	4313      	orrs	r3, r2
 8012f72:	2000      	movs	r0, #0
 8012f74:	612b      	str	r3, [r5, #16]
}
 8012f76:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
       ||
 8012f78:	2a00      	cmp	r2, #0
 8012f7a:	d0b0      	beq.n	8012ede <RCCEx_PLLSAI1_Config+0x1a>
       (((READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLM) >> RCC_PLLCFGR_PLLM_Pos) + 1U) != PllSai1->PLLSAI1M)
 8012f7c:	68db      	ldr	r3, [r3, #12]
       ||
 8012f7e:	6842      	ldr	r2, [r0, #4]
       (((READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLM) >> RCC_PLLCFGR_PLLM_Pos) + 1U) != PllSai1->PLLSAI1M)
 8012f80:	f3c3 1302 	ubfx	r3, r3, #4, #3
 8012f84:	3301      	adds	r3, #1
       ||
 8012f86:	4293      	cmp	r3, r2
 8012f88:	d1a9      	bne.n	8012ede <RCCEx_PLLSAI1_Config+0x1a>
 8012f8a:	e7be      	b.n	8012f0a <RCCEx_PLLSAI1_Config+0x46>
      if(HAL_IS_BIT_CLR(RCC->CR, RCC_CR_HSERDY))
 8012f8c:	681a      	ldr	r2, [r3, #0]
 8012f8e:	0395      	lsls	r5, r2, #14
 8012f90:	d4b1      	bmi.n	8012ef6 <RCCEx_PLLSAI1_Config+0x32>
        if(HAL_IS_BIT_CLR(RCC->CR, RCC_CR_HSEBYP))
 8012f92:	681b      	ldr	r3, [r3, #0]
 8012f94:	0359      	lsls	r1, r3, #13
 8012f96:	d5a2      	bpl.n	8012ede <RCCEx_PLLSAI1_Config+0x1a>
 8012f98:	e7ad      	b.n	8012ef6 <RCCEx_PLLSAI1_Config+0x32>
      if(HAL_IS_BIT_CLR(RCC->CR, RCC_CR_HSIRDY))
 8012f9a:	681b      	ldr	r3, [r3, #0]
 8012f9c:	055e      	lsls	r6, r3, #21
 8012f9e:	d59e      	bpl.n	8012ede <RCCEx_PLLSAI1_Config+0x1a>
 8012fa0:	e7a9      	b.n	8012ef6 <RCCEx_PLLSAI1_Config+0x32>
        status = HAL_TIMEOUT;
 8012fa2:	2003      	movs	r0, #3
}
 8012fa4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      else if(Divider == DIVIDER_Q_UPDATE)
 8012fa6:	2f01      	cmp	r7, #1
        MODIFY_REG(RCC->PLLSAI1CFGR,
 8012fa8:	692b      	ldr	r3, [r5, #16]
      else if(Divider == DIVIDER_Q_UPDATE)
 8012faa:	d00d      	beq.n	8012fc8 <RCCEx_PLLSAI1_Config+0x104>
        MODIFY_REG(RCC->PLLSAI1CFGR,
 8012fac:	6962      	ldr	r2, [r4, #20]
 8012fae:	68a1      	ldr	r1, [r4, #8]
 8012fb0:	f023 63c0 	bic.w	r3, r3, #100663296	; 0x6000000
 8012fb4:	0852      	lsrs	r2, r2, #1
 8012fb6:	f423 43fe 	bic.w	r3, r3, #32512	; 0x7f00
 8012fba:	3a01      	subs	r2, #1
 8012fbc:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
 8012fc0:	ea43 6342 	orr.w	r3, r3, r2, lsl #25
 8012fc4:	612b      	str	r3, [r5, #16]
 8012fc6:	e7c0      	b.n	8012f4a <RCCEx_PLLSAI1_Config+0x86>
        MODIFY_REG(RCC->PLLSAI1CFGR,
 8012fc8:	6922      	ldr	r2, [r4, #16]
 8012fca:	68a1      	ldr	r1, [r4, #8]
 8012fcc:	f423 03c0 	bic.w	r3, r3, #6291456	; 0x600000
 8012fd0:	0852      	lsrs	r2, r2, #1
 8012fd2:	f423 43fe 	bic.w	r3, r3, #32512	; 0x7f00
 8012fd6:	3a01      	subs	r2, #1
 8012fd8:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
 8012fdc:	ea43 5342 	orr.w	r3, r3, r2, lsl #21
 8012fe0:	612b      	str	r3, [r5, #16]
 8012fe2:	e7b2      	b.n	8012f4a <RCCEx_PLLSAI1_Config+0x86>
 8012fe4:	40021000 	.word	0x40021000

08012fe8 <RCCEx_PLLSAI2_Config>:
{
 8012fe8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  if(__HAL_RCC_GET_PLL_OSCSOURCE() != RCC_PLLSOURCE_NONE)
 8012fea:	4b3f      	ldr	r3, [pc, #252]	; (80130e8 <RCCEx_PLLSAI2_Config+0x100>)
 8012fec:	68da      	ldr	r2, [r3, #12]
 8012fee:	0792      	lsls	r2, r2, #30
{
 8012ff0:	4604      	mov	r4, r0
 8012ff2:	460f      	mov	r7, r1
  if(__HAL_RCC_GET_PLL_OSCSOURCE() != RCC_PLLSOURCE_NONE)
 8012ff4:	d007      	beq.n	8013006 <RCCEx_PLLSAI2_Config+0x1e>
    if((__HAL_RCC_GET_PLL_OSCSOURCE() != PllSai2->PLLSAI2Source)
 8012ff6:	68da      	ldr	r2, [r3, #12]
 8012ff8:	6801      	ldr	r1, [r0, #0]
 8012ffa:	f002 0203 	and.w	r2, r2, #3
 8012ffe:	428a      	cmp	r2, r1
 8013000:	d04c      	beq.n	801309c <RCCEx_PLLSAI2_Config+0xb4>
      status = HAL_ERROR;
 8013002:	2001      	movs	r0, #1
}
 8013004:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    switch(PllSai2->PLLSAI2Source)
 8013006:	6800      	ldr	r0, [r0, #0]
 8013008:	2802      	cmp	r0, #2
 801300a:	d058      	beq.n	80130be <RCCEx_PLLSAI2_Config+0xd6>
 801300c:	2803      	cmp	r0, #3
 801300e:	d04f      	beq.n	80130b0 <RCCEx_PLLSAI2_Config+0xc8>
 8013010:	2801      	cmp	r0, #1
 8013012:	d1f6      	bne.n	8013002 <RCCEx_PLLSAI2_Config+0x1a>
      if(HAL_IS_BIT_CLR(RCC->CR, RCC_CR_MSIRDY))
 8013014:	681b      	ldr	r3, [r3, #0]
 8013016:	079b      	lsls	r3, r3, #30
 8013018:	d5f4      	bpl.n	8013004 <RCCEx_PLLSAI2_Config+0x1c>
      MODIFY_REG(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC | RCC_PLLCFGR_PLLM, PllSai2->PLLSAI2Source | (PllSai2->PLLSAI2M - 1U) << RCC_PLLCFGR_PLLM_Pos);
 801301a:	4a33      	ldr	r2, [pc, #204]	; (80130e8 <RCCEx_PLLSAI2_Config+0x100>)
 801301c:	68d3      	ldr	r3, [r2, #12]
 801301e:	f023 0373 	bic.w	r3, r3, #115	; 0x73
 8013022:	4318      	orrs	r0, r3
 8013024:	6863      	ldr	r3, [r4, #4]
 8013026:	3b01      	subs	r3, #1
 8013028:	ea40 1003 	orr.w	r0, r0, r3, lsl #4
 801302c:	60d0      	str	r0, [r2, #12]
    __HAL_RCC_PLLSAI2_DISABLE();
 801302e:	4d2e      	ldr	r5, [pc, #184]	; (80130e8 <RCCEx_PLLSAI2_Config+0x100>)
 8013030:	682b      	ldr	r3, [r5, #0]
 8013032:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
 8013036:	602b      	str	r3, [r5, #0]
    tickstart = HAL_GetTick();
 8013038:	f7fc fbfe 	bl	800f838 <HAL_GetTick>
 801303c:	4606      	mov	r6, r0
    while(READ_BIT(RCC->CR, RCC_CR_PLLSAI2RDY) != 0U)
 801303e:	e004      	b.n	801304a <RCCEx_PLLSAI2_Config+0x62>
      if((HAL_GetTick() - tickstart) > PLLSAI2_TIMEOUT_VALUE)
 8013040:	f7fc fbfa 	bl	800f838 <HAL_GetTick>
 8013044:	1b83      	subs	r3, r0, r6
 8013046:	2b02      	cmp	r3, #2
 8013048:	d83d      	bhi.n	80130c6 <RCCEx_PLLSAI2_Config+0xde>
    while(READ_BIT(RCC->CR, RCC_CR_PLLSAI2RDY) != 0U)
 801304a:	682b      	ldr	r3, [r5, #0]
 801304c:	009a      	lsls	r2, r3, #2
 801304e:	d4f7      	bmi.n	8013040 <RCCEx_PLLSAI2_Config+0x58>
      if(Divider == DIVIDER_P_UPDATE)
 8013050:	2f00      	cmp	r7, #0
 8013052:	d13a      	bne.n	80130ca <RCCEx_PLLSAI2_Config+0xe2>
        MODIFY_REG(RCC->PLLSAI2CFGR,
 8013054:	696b      	ldr	r3, [r5, #20]
 8013056:	e9d4 1202 	ldrd	r1, r2, [r4, #8]
 801305a:	f423 331f 	bic.w	r3, r3, #162816	; 0x27c00
 801305e:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 8013062:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
 8013066:	0912      	lsrs	r2, r2, #4
 8013068:	ea43 4342 	orr.w	r3, r3, r2, lsl #17
 801306c:	616b      	str	r3, [r5, #20]
      __HAL_RCC_PLLSAI2_ENABLE();
 801306e:	4d1e      	ldr	r5, [pc, #120]	; (80130e8 <RCCEx_PLLSAI2_Config+0x100>)
 8013070:	682b      	ldr	r3, [r5, #0]
 8013072:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 8013076:	602b      	str	r3, [r5, #0]
      tickstart = HAL_GetTick();
 8013078:	f7fc fbde 	bl	800f838 <HAL_GetTick>
 801307c:	4606      	mov	r6, r0
      while(READ_BIT(RCC->CR, RCC_CR_PLLSAI2RDY) == 0U)
 801307e:	e004      	b.n	801308a <RCCEx_PLLSAI2_Config+0xa2>
        if((HAL_GetTick() - tickstart) > PLLSAI2_TIMEOUT_VALUE)
 8013080:	f7fc fbda 	bl	800f838 <HAL_GetTick>
 8013084:	1b83      	subs	r3, r0, r6
 8013086:	2b02      	cmp	r3, #2
 8013088:	d81d      	bhi.n	80130c6 <RCCEx_PLLSAI2_Config+0xde>
      while(READ_BIT(RCC->CR, RCC_CR_PLLSAI2RDY) == 0U)
 801308a:	682b      	ldr	r3, [r5, #0]
 801308c:	009b      	lsls	r3, r3, #2
 801308e:	d5f7      	bpl.n	8013080 <RCCEx_PLLSAI2_Config+0x98>
        __HAL_RCC_PLLSAI2CLKOUT_ENABLE(PllSai2->PLLSAI2ClockOut);
 8013090:	696b      	ldr	r3, [r5, #20]
 8013092:	6962      	ldr	r2, [r4, #20]
 8013094:	4313      	orrs	r3, r2
 8013096:	2000      	movs	r0, #0
 8013098:	616b      	str	r3, [r5, #20]
}
 801309a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
       ||
 801309c:	2a00      	cmp	r2, #0
 801309e:	d0b0      	beq.n	8013002 <RCCEx_PLLSAI2_Config+0x1a>
       (((READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLM) >> RCC_PLLCFGR_PLLM_Pos) + 1U) != PllSai2->PLLSAI2M)
 80130a0:	68db      	ldr	r3, [r3, #12]
       ||
 80130a2:	6842      	ldr	r2, [r0, #4]
       (((READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLM) >> RCC_PLLCFGR_PLLM_Pos) + 1U) != PllSai2->PLLSAI2M)
 80130a4:	f3c3 1302 	ubfx	r3, r3, #4, #3
 80130a8:	3301      	adds	r3, #1
       ||
 80130aa:	4293      	cmp	r3, r2
 80130ac:	d1a9      	bne.n	8013002 <RCCEx_PLLSAI2_Config+0x1a>
 80130ae:	e7be      	b.n	801302e <RCCEx_PLLSAI2_Config+0x46>
      if(HAL_IS_BIT_CLR(RCC->CR, RCC_CR_HSERDY))
 80130b0:	681a      	ldr	r2, [r3, #0]
 80130b2:	0395      	lsls	r5, r2, #14
 80130b4:	d4b1      	bmi.n	801301a <RCCEx_PLLSAI2_Config+0x32>
        if(HAL_IS_BIT_CLR(RCC->CR, RCC_CR_HSEBYP))
 80130b6:	681b      	ldr	r3, [r3, #0]
 80130b8:	0359      	lsls	r1, r3, #13
 80130ba:	d5a2      	bpl.n	8013002 <RCCEx_PLLSAI2_Config+0x1a>
 80130bc:	e7ad      	b.n	801301a <RCCEx_PLLSAI2_Config+0x32>
      if(HAL_IS_BIT_CLR(RCC->CR, RCC_CR_HSIRDY))
 80130be:	681b      	ldr	r3, [r3, #0]
 80130c0:	055e      	lsls	r6, r3, #21
 80130c2:	d59e      	bpl.n	8013002 <RCCEx_PLLSAI2_Config+0x1a>
 80130c4:	e7a9      	b.n	801301a <RCCEx_PLLSAI2_Config+0x32>
        status = HAL_TIMEOUT;
 80130c6:	2003      	movs	r0, #3
}
 80130c8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        MODIFY_REG(RCC->PLLSAI2CFGR,
 80130ca:	696b      	ldr	r3, [r5, #20]
 80130cc:	6922      	ldr	r2, [r4, #16]
 80130ce:	68a1      	ldr	r1, [r4, #8]
 80130d0:	f023 63c0 	bic.w	r3, r3, #100663296	; 0x6000000
 80130d4:	0852      	lsrs	r2, r2, #1
 80130d6:	f423 43fe 	bic.w	r3, r3, #32512	; 0x7f00
 80130da:	3a01      	subs	r2, #1
 80130dc:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
 80130e0:	ea43 6342 	orr.w	r3, r3, r2, lsl #25
 80130e4:	616b      	str	r3, [r5, #20]
 80130e6:	e7c2      	b.n	801306e <RCCEx_PLLSAI2_Config+0x86>
 80130e8:	40021000 	.word	0x40021000

080130ec <HAL_RCCEx_PeriphCLKConfig>:
{
 80130ec:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
  if((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI1) == RCC_PERIPHCLK_SAI1))
 80130f0:	6803      	ldr	r3, [r0, #0]
 80130f2:	f413 6500 	ands.w	r5, r3, #2048	; 0x800
{
 80130f6:	b083      	sub	sp, #12
 80130f8:	4604      	mov	r4, r0
  if((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI1) == RCC_PERIPHCLK_SAI1))
 80130fa:	d020      	beq.n	801313e <HAL_RCCEx_PeriphCLKConfig+0x52>
    switch(PeriphClkInit->Sai1ClockSelection)
 80130fc:	6e41      	ldr	r1, [r0, #100]	; 0x64
 80130fe:	f5b1 0f00 	cmp.w	r1, #8388608	; 0x800000
 8013102:	f000 81d4 	beq.w	80134ae <HAL_RCCEx_PeriphCLKConfig+0x3c2>
 8013106:	f200 8122 	bhi.w	801334e <HAL_RCCEx_PeriphCLKConfig+0x262>
 801310a:	2900      	cmp	r1, #0
 801310c:	f000 81ab 	beq.w	8013466 <HAL_RCCEx_PeriphCLKConfig+0x37a>
 8013110:	f5b1 0f80 	cmp.w	r1, #4194304	; 0x400000
 8013114:	f040 811f 	bne.w	8013356 <HAL_RCCEx_PeriphCLKConfig+0x26a>
      ret = RCCEx_PLLSAI2_Config(&(PeriphClkInit->PLLSAI2), DIVIDER_P_UPDATE);
 8013118:	2100      	movs	r1, #0
 801311a:	3020      	adds	r0, #32
 801311c:	f7ff ff64 	bl	8012fe8 <RCCEx_PLLSAI2_Config>
 8013120:	4605      	mov	r5, r0
    if(ret == HAL_OK)
 8013122:	2d00      	cmp	r5, #0
 8013124:	f040 81d0 	bne.w	80134c8 <HAL_RCCEx_PeriphCLKConfig+0x3dc>
      __HAL_RCC_SAI1_CONFIG(PeriphClkInit->Sai1ClockSelection);
 8013128:	6e61      	ldr	r1, [r4, #100]	; 0x64
  if((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI2) == RCC_PERIPHCLK_SAI2))
 801312a:	6823      	ldr	r3, [r4, #0]
      __HAL_RCC_SAI1_CONFIG(PeriphClkInit->Sai1ClockSelection);
 801312c:	48ae      	ldr	r0, [pc, #696]	; (80133e8 <HAL_RCCEx_PeriphCLKConfig+0x2fc>)
 801312e:	f8d0 2088 	ldr.w	r2, [r0, #136]	; 0x88
 8013132:	f422 0240 	bic.w	r2, r2, #12582912	; 0xc00000
 8013136:	4311      	orrs	r1, r2
 8013138:	f8c0 1088 	str.w	r1, [r0, #136]	; 0x88
 801313c:	2500      	movs	r5, #0
  if((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI2) == RCC_PERIPHCLK_SAI2))
 801313e:	04d8      	lsls	r0, r3, #19
 8013140:	f140 810e 	bpl.w	8013360 <HAL_RCCEx_PeriphCLKConfig+0x274>
    switch(PeriphClkInit->Sai2ClockSelection)
 8013144:	6ea1      	ldr	r1, [r4, #104]	; 0x68
 8013146:	f1b1 7f00 	cmp.w	r1, #33554432	; 0x2000000
 801314a:	f000 81b6 	beq.w	80134ba <HAL_RCCEx_PeriphCLKConfig+0x3ce>
 801314e:	f200 816c 	bhi.w	801342a <HAL_RCCEx_PeriphCLKConfig+0x33e>
 8013152:	2900      	cmp	r1, #0
 8013154:	f000 8181 	beq.w	801345a <HAL_RCCEx_PeriphCLKConfig+0x36e>
 8013158:	f1b1 7f80 	cmp.w	r1, #16777216	; 0x1000000
 801315c:	f040 819a 	bne.w	8013494 <HAL_RCCEx_PeriphCLKConfig+0x3a8>
      ret = RCCEx_PLLSAI2_Config(&(PeriphClkInit->PLLSAI2), DIVIDER_P_UPDATE);
 8013160:	2100      	movs	r1, #0
 8013162:	f104 0020 	add.w	r0, r4, #32
 8013166:	f7ff ff3f 	bl	8012fe8 <RCCEx_PLLSAI2_Config>
  if((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_RTC) == RCC_PERIPHCLK_RTC)
 801316a:	6823      	ldr	r3, [r4, #0]
      ret = RCCEx_PLLSAI2_Config(&(PeriphClkInit->PLLSAI2), DIVIDER_P_UPDATE);
 801316c:	4680      	mov	r8, r0
    if(ret == HAL_OK)
 801316e:	f1b8 0f00 	cmp.w	r8, #0
 8013172:	f040 8162 	bne.w	801343a <HAL_RCCEx_PeriphCLKConfig+0x34e>
      __HAL_RCC_SAI2_CONFIG(PeriphClkInit->Sai2ClockSelection);
 8013176:	499c      	ldr	r1, [pc, #624]	; (80133e8 <HAL_RCCEx_PeriphCLKConfig+0x2fc>)
 8013178:	6ea0      	ldr	r0, [r4, #104]	; 0x68
 801317a:	f8d1 2088 	ldr.w	r2, [r1, #136]	; 0x88
 801317e:	f022 7240 	bic.w	r2, r2, #50331648	; 0x3000000
 8013182:	4302      	orrs	r2, r0
 8013184:	f8c1 2088 	str.w	r2, [r1, #136]	; 0x88
  if((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_RTC) == RCC_PERIPHCLK_RTC)
 8013188:	0399      	lsls	r1, r3, #14
 801318a:	f100 80ed 	bmi.w	8013368 <HAL_RCCEx_PeriphCLKConfig+0x27c>
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART1) == RCC_PERIPHCLK_USART1)
 801318e:	07da      	lsls	r2, r3, #31
 8013190:	d508      	bpl.n	80131a4 <HAL_RCCEx_PeriphCLKConfig+0xb8>
    __HAL_RCC_USART1_CONFIG(PeriphClkInit->Usart1ClockSelection);
 8013192:	4995      	ldr	r1, [pc, #596]	; (80133e8 <HAL_RCCEx_PeriphCLKConfig+0x2fc>)
 8013194:	6ba0      	ldr	r0, [r4, #56]	; 0x38
 8013196:	f8d1 2088 	ldr.w	r2, [r1, #136]	; 0x88
 801319a:	f022 0203 	bic.w	r2, r2, #3
 801319e:	4302      	orrs	r2, r0
 80131a0:	f8c1 2088 	str.w	r2, [r1, #136]	; 0x88
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART2) == RCC_PERIPHCLK_USART2)
 80131a4:	079f      	lsls	r7, r3, #30
 80131a6:	d508      	bpl.n	80131ba <HAL_RCCEx_PeriphCLKConfig+0xce>
    __HAL_RCC_USART2_CONFIG(PeriphClkInit->Usart2ClockSelection);
 80131a8:	498f      	ldr	r1, [pc, #572]	; (80133e8 <HAL_RCCEx_PeriphCLKConfig+0x2fc>)
 80131aa:	6be0      	ldr	r0, [r4, #60]	; 0x3c
 80131ac:	f8d1 2088 	ldr.w	r2, [r1, #136]	; 0x88
 80131b0:	f022 020c 	bic.w	r2, r2, #12
 80131b4:	4302      	orrs	r2, r0
 80131b6:	f8c1 2088 	str.w	r2, [r1, #136]	; 0x88
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART3) == RCC_PERIPHCLK_USART3)
 80131ba:	075e      	lsls	r6, r3, #29
 80131bc:	d508      	bpl.n	80131d0 <HAL_RCCEx_PeriphCLKConfig+0xe4>
    __HAL_RCC_USART3_CONFIG(PeriphClkInit->Usart3ClockSelection);
 80131be:	498a      	ldr	r1, [pc, #552]	; (80133e8 <HAL_RCCEx_PeriphCLKConfig+0x2fc>)
 80131c0:	6c20      	ldr	r0, [r4, #64]	; 0x40
 80131c2:	f8d1 2088 	ldr.w	r2, [r1, #136]	; 0x88
 80131c6:	f022 0230 	bic.w	r2, r2, #48	; 0x30
 80131ca:	4302      	orrs	r2, r0
 80131cc:	f8c1 2088 	str.w	r2, [r1, #136]	; 0x88
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_UART4) == RCC_PERIPHCLK_UART4)
 80131d0:	0718      	lsls	r0, r3, #28
 80131d2:	d508      	bpl.n	80131e6 <HAL_RCCEx_PeriphCLKConfig+0xfa>
    __HAL_RCC_UART4_CONFIG(PeriphClkInit->Uart4ClockSelection);
 80131d4:	4984      	ldr	r1, [pc, #528]	; (80133e8 <HAL_RCCEx_PeriphCLKConfig+0x2fc>)
 80131d6:	6c60      	ldr	r0, [r4, #68]	; 0x44
 80131d8:	f8d1 2088 	ldr.w	r2, [r1, #136]	; 0x88
 80131dc:	f022 02c0 	bic.w	r2, r2, #192	; 0xc0
 80131e0:	4302      	orrs	r2, r0
 80131e2:	f8c1 2088 	str.w	r2, [r1, #136]	; 0x88
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_UART5) == RCC_PERIPHCLK_UART5)
 80131e6:	06d9      	lsls	r1, r3, #27
 80131e8:	d508      	bpl.n	80131fc <HAL_RCCEx_PeriphCLKConfig+0x110>
    __HAL_RCC_UART5_CONFIG(PeriphClkInit->Uart5ClockSelection);
 80131ea:	497f      	ldr	r1, [pc, #508]	; (80133e8 <HAL_RCCEx_PeriphCLKConfig+0x2fc>)
 80131ec:	6ca0      	ldr	r0, [r4, #72]	; 0x48
 80131ee:	f8d1 2088 	ldr.w	r2, [r1, #136]	; 0x88
 80131f2:	f422 7240 	bic.w	r2, r2, #768	; 0x300
 80131f6:	4302      	orrs	r2, r0
 80131f8:	f8c1 2088 	str.w	r2, [r1, #136]	; 0x88
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPUART1) == RCC_PERIPHCLK_LPUART1)
 80131fc:	069a      	lsls	r2, r3, #26
 80131fe:	d508      	bpl.n	8013212 <HAL_RCCEx_PeriphCLKConfig+0x126>
    __HAL_RCC_LPUART1_CONFIG(PeriphClkInit->Lpuart1ClockSelection);
 8013200:	4979      	ldr	r1, [pc, #484]	; (80133e8 <HAL_RCCEx_PeriphCLKConfig+0x2fc>)
 8013202:	6ce0      	ldr	r0, [r4, #76]	; 0x4c
 8013204:	f8d1 2088 	ldr.w	r2, [r1, #136]	; 0x88
 8013208:	f422 6240 	bic.w	r2, r2, #3072	; 0xc00
 801320c:	4302      	orrs	r2, r0
 801320e:	f8c1 2088 	str.w	r2, [r1, #136]	; 0x88
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPTIM1) == (RCC_PERIPHCLK_LPTIM1))
 8013212:	059f      	lsls	r7, r3, #22
 8013214:	d508      	bpl.n	8013228 <HAL_RCCEx_PeriphCLKConfig+0x13c>
    __HAL_RCC_LPTIM1_CONFIG(PeriphClkInit->Lptim1ClockSelection);
 8013216:	4974      	ldr	r1, [pc, #464]	; (80133e8 <HAL_RCCEx_PeriphCLKConfig+0x2fc>)
 8013218:	6de0      	ldr	r0, [r4, #92]	; 0x5c
 801321a:	f8d1 2088 	ldr.w	r2, [r1, #136]	; 0x88
 801321e:	f422 2240 	bic.w	r2, r2, #786432	; 0xc0000
 8013222:	4302      	orrs	r2, r0
 8013224:	f8c1 2088 	str.w	r2, [r1, #136]	; 0x88
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPTIM2) == (RCC_PERIPHCLK_LPTIM2))
 8013228:	055e      	lsls	r6, r3, #21
 801322a:	d508      	bpl.n	801323e <HAL_RCCEx_PeriphCLKConfig+0x152>
    __HAL_RCC_LPTIM2_CONFIG(PeriphClkInit->Lptim2ClockSelection);
 801322c:	496e      	ldr	r1, [pc, #440]	; (80133e8 <HAL_RCCEx_PeriphCLKConfig+0x2fc>)
 801322e:	6e20      	ldr	r0, [r4, #96]	; 0x60
 8013230:	f8d1 2088 	ldr.w	r2, [r1, #136]	; 0x88
 8013234:	f422 1240 	bic.w	r2, r2, #3145728	; 0x300000
 8013238:	4302      	orrs	r2, r0
 801323a:	f8c1 2088 	str.w	r2, [r1, #136]	; 0x88
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C1) == RCC_PERIPHCLK_I2C1)
 801323e:	0658      	lsls	r0, r3, #25
 8013240:	d508      	bpl.n	8013254 <HAL_RCCEx_PeriphCLKConfig+0x168>
    __HAL_RCC_I2C1_CONFIG(PeriphClkInit->I2c1ClockSelection);
 8013242:	4969      	ldr	r1, [pc, #420]	; (80133e8 <HAL_RCCEx_PeriphCLKConfig+0x2fc>)
 8013244:	6d20      	ldr	r0, [r4, #80]	; 0x50
 8013246:	f8d1 2088 	ldr.w	r2, [r1, #136]	; 0x88
 801324a:	f422 5240 	bic.w	r2, r2, #12288	; 0x3000
 801324e:	4302      	orrs	r2, r0
 8013250:	f8c1 2088 	str.w	r2, [r1, #136]	; 0x88
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C2) == RCC_PERIPHCLK_I2C2)
 8013254:	0619      	lsls	r1, r3, #24
 8013256:	d508      	bpl.n	801326a <HAL_RCCEx_PeriphCLKConfig+0x17e>
    __HAL_RCC_I2C2_CONFIG(PeriphClkInit->I2c2ClockSelection);
 8013258:	4963      	ldr	r1, [pc, #396]	; (80133e8 <HAL_RCCEx_PeriphCLKConfig+0x2fc>)
 801325a:	6d60      	ldr	r0, [r4, #84]	; 0x54
 801325c:	f8d1 2088 	ldr.w	r2, [r1, #136]	; 0x88
 8013260:	f422 4240 	bic.w	r2, r2, #49152	; 0xc000
 8013264:	4302      	orrs	r2, r0
 8013266:	f8c1 2088 	str.w	r2, [r1, #136]	; 0x88
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C3) == RCC_PERIPHCLK_I2C3)
 801326a:	05da      	lsls	r2, r3, #23
 801326c:	d508      	bpl.n	8013280 <HAL_RCCEx_PeriphCLKConfig+0x194>
    __HAL_RCC_I2C3_CONFIG(PeriphClkInit->I2c3ClockSelection);
 801326e:	495e      	ldr	r1, [pc, #376]	; (80133e8 <HAL_RCCEx_PeriphCLKConfig+0x2fc>)
 8013270:	6da0      	ldr	r0, [r4, #88]	; 0x58
 8013272:	f8d1 2088 	ldr.w	r2, [r1, #136]	; 0x88
 8013276:	f422 3240 	bic.w	r2, r2, #196608	; 0x30000
 801327a:	4302      	orrs	r2, r0
 801327c:	f8c1 2088 	str.w	r2, [r1, #136]	; 0x88
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USB) == (RCC_PERIPHCLK_USB))
 8013280:	049f      	lsls	r7, r3, #18
 8013282:	d510      	bpl.n	80132a6 <HAL_RCCEx_PeriphCLKConfig+0x1ba>
    __HAL_RCC_USB_CONFIG(PeriphClkInit->UsbClockSelection);
 8013284:	4958      	ldr	r1, [pc, #352]	; (80133e8 <HAL_RCCEx_PeriphCLKConfig+0x2fc>)
 8013286:	6ee0      	ldr	r0, [r4, #108]	; 0x6c
 8013288:	f8d1 2088 	ldr.w	r2, [r1, #136]	; 0x88
 801328c:	f022 6240 	bic.w	r2, r2, #201326592	; 0xc000000
 8013290:	4302      	orrs	r2, r0
    if(PeriphClkInit->UsbClockSelection == RCC_USBCLKSOURCE_PLL)
 8013292:	f1b0 6f00 	cmp.w	r0, #134217728	; 0x8000000
    __HAL_RCC_USB_CONFIG(PeriphClkInit->UsbClockSelection);
 8013296:	f8c1 2088 	str.w	r2, [r1, #136]	; 0x88
    if(PeriphClkInit->UsbClockSelection == RCC_USBCLKSOURCE_PLL)
 801329a:	f000 80f1 	beq.w	8013480 <HAL_RCCEx_PeriphCLKConfig+0x394>
      if(PeriphClkInit->UsbClockSelection == RCC_USBCLKSOURCE_PLLSAI1)
 801329e:	f1b0 6f80 	cmp.w	r0, #67108864	; 0x4000000
 80132a2:	f000 8128 	beq.w	80134f6 <HAL_RCCEx_PeriphCLKConfig+0x40a>
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SDMMC1) == (RCC_PERIPHCLK_SDMMC1))
 80132a6:	031e      	lsls	r6, r3, #12
 80132a8:	d510      	bpl.n	80132cc <HAL_RCCEx_PeriphCLKConfig+0x1e0>
    __HAL_RCC_SDMMC1_CONFIG(PeriphClkInit->Sdmmc1ClockSelection);
 80132aa:	494f      	ldr	r1, [pc, #316]	; (80133e8 <HAL_RCCEx_PeriphCLKConfig+0x2fc>)
 80132ac:	6f20      	ldr	r0, [r4, #112]	; 0x70
 80132ae:	f8d1 2088 	ldr.w	r2, [r1, #136]	; 0x88
 80132b2:	f022 6240 	bic.w	r2, r2, #201326592	; 0xc000000
 80132b6:	4302      	orrs	r2, r0
    if(PeriphClkInit->Sdmmc1ClockSelection == RCC_SDMMC1CLKSOURCE_PLL)   /* PLL "Q" ? */
 80132b8:	f1b0 6f00 	cmp.w	r0, #134217728	; 0x8000000
    __HAL_RCC_SDMMC1_CONFIG(PeriphClkInit->Sdmmc1ClockSelection);
 80132bc:	f8c1 2088 	str.w	r2, [r1, #136]	; 0x88
    if(PeriphClkInit->Sdmmc1ClockSelection == RCC_SDMMC1CLKSOURCE_PLL)   /* PLL "Q" ? */
 80132c0:	f000 80e3 	beq.w	801348a <HAL_RCCEx_PeriphCLKConfig+0x39e>
    else if(PeriphClkInit->Sdmmc1ClockSelection == RCC_SDMMC1CLKSOURCE_PLLSAI1)
 80132c4:	f1b0 6f80 	cmp.w	r0, #67108864	; 0x4000000
 80132c8:	f000 811f 	beq.w	801350a <HAL_RCCEx_PeriphCLKConfig+0x41e>
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_RNG) == (RCC_PERIPHCLK_RNG))
 80132cc:	0358      	lsls	r0, r3, #13
 80132ce:	d510      	bpl.n	80132f2 <HAL_RCCEx_PeriphCLKConfig+0x206>
    __HAL_RCC_RNG_CONFIG(PeriphClkInit->RngClockSelection);
 80132d0:	4945      	ldr	r1, [pc, #276]	; (80133e8 <HAL_RCCEx_PeriphCLKConfig+0x2fc>)
 80132d2:	6f60      	ldr	r0, [r4, #116]	; 0x74
 80132d4:	f8d1 2088 	ldr.w	r2, [r1, #136]	; 0x88
 80132d8:	f022 6240 	bic.w	r2, r2, #201326592	; 0xc000000
 80132dc:	4302      	orrs	r2, r0
    if(PeriphClkInit->RngClockSelection == RCC_RNGCLKSOURCE_PLL)
 80132de:	f1b0 6f00 	cmp.w	r0, #134217728	; 0x8000000
    __HAL_RCC_RNG_CONFIG(PeriphClkInit->RngClockSelection);
 80132e2:	f8c1 2088 	str.w	r2, [r1, #136]	; 0x88
    if(PeriphClkInit->RngClockSelection == RCC_RNGCLKSOURCE_PLL)
 80132e6:	f000 80c6 	beq.w	8013476 <HAL_RCCEx_PeriphCLKConfig+0x38a>
    else if(PeriphClkInit->RngClockSelection == RCC_RNGCLKSOURCE_PLLSAI1)
 80132ea:	f1b0 6f80 	cmp.w	r0, #67108864	; 0x4000000
 80132ee:	f000 80f8 	beq.w	80134e2 <HAL_RCCEx_PeriphCLKConfig+0x3f6>
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_ADC) == RCC_PERIPHCLK_ADC)
 80132f2:	0459      	lsls	r1, r3, #17
 80132f4:	d510      	bpl.n	8013318 <HAL_RCCEx_PeriphCLKConfig+0x22c>
    __HAL_RCC_ADC_CONFIG(PeriphClkInit->AdcClockSelection);
 80132f6:	483c      	ldr	r0, [pc, #240]	; (80133e8 <HAL_RCCEx_PeriphCLKConfig+0x2fc>)
 80132f8:	6fa1      	ldr	r1, [r4, #120]	; 0x78
 80132fa:	f8d0 2088 	ldr.w	r2, [r0, #136]	; 0x88
 80132fe:	f022 5240 	bic.w	r2, r2, #805306368	; 0x30000000
 8013302:	430a      	orrs	r2, r1
    if(PeriphClkInit->AdcClockSelection == RCC_ADCCLKSOURCE_PLLSAI1)
 8013304:	f1b1 5f80 	cmp.w	r1, #268435456	; 0x10000000
    __HAL_RCC_ADC_CONFIG(PeriphClkInit->AdcClockSelection);
 8013308:	f8c0 2088 	str.w	r2, [r0, #136]	; 0x88
    if(PeriphClkInit->AdcClockSelection == RCC_ADCCLKSOURCE_PLLSAI1)
 801330c:	f000 80c5 	beq.w	801349a <HAL_RCCEx_PeriphCLKConfig+0x3ae>
    else if(PeriphClkInit->AdcClockSelection == RCC_ADCCLKSOURCE_PLLSAI2)
 8013310:	f1b1 5f00 	cmp.w	r1, #536870912	; 0x20000000
 8013314:	f000 80da 	beq.w	80134cc <HAL_RCCEx_PeriphCLKConfig+0x3e0>
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SWPMI1) == RCC_PERIPHCLK_SWPMI1)
 8013318:	041a      	lsls	r2, r3, #16
 801331a:	d508      	bpl.n	801332e <HAL_RCCEx_PeriphCLKConfig+0x242>
    __HAL_RCC_SWPMI1_CONFIG(PeriphClkInit->Swpmi1ClockSelection);
 801331c:	4932      	ldr	r1, [pc, #200]	; (80133e8 <HAL_RCCEx_PeriphCLKConfig+0x2fc>)
 801331e:	6fe0      	ldr	r0, [r4, #124]	; 0x7c
 8013320:	f8d1 2088 	ldr.w	r2, [r1, #136]	; 0x88
 8013324:	f022 4280 	bic.w	r2, r2, #1073741824	; 0x40000000
 8013328:	4302      	orrs	r2, r0
 801332a:	f8c1 2088 	str.w	r2, [r1, #136]	; 0x88
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_DFSDM1) == RCC_PERIPHCLK_DFSDM1)
 801332e:	03db      	lsls	r3, r3, #15
 8013330:	d509      	bpl.n	8013346 <HAL_RCCEx_PeriphCLKConfig+0x25a>
    __HAL_RCC_DFSDM1_CONFIG(PeriphClkInit->Dfsdm1ClockSelection);
 8013332:	4a2d      	ldr	r2, [pc, #180]	; (80133e8 <HAL_RCCEx_PeriphCLKConfig+0x2fc>)
 8013334:	f8d4 1080 	ldr.w	r1, [r4, #128]	; 0x80
 8013338:	f8d2 3088 	ldr.w	r3, [r2, #136]	; 0x88
 801333c:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
 8013340:	430b      	orrs	r3, r1
 8013342:	f8c2 3088 	str.w	r3, [r2, #136]	; 0x88
}
 8013346:	4628      	mov	r0, r5
 8013348:	b003      	add	sp, #12
 801334a:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    switch(PeriphClkInit->Sai1ClockSelection)
 801334e:	f5b1 0f40 	cmp.w	r1, #12582912	; 0xc00000
 8013352:	f43f aeeb 	beq.w	801312c <HAL_RCCEx_PeriphCLKConfig+0x40>
  if((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI2) == RCC_PERIPHCLK_SAI2))
 8013356:	04d8      	lsls	r0, r3, #19
    switch(PeriphClkInit->Sai1ClockSelection)
 8013358:	f04f 0501 	mov.w	r5, #1
  if((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI2) == RCC_PERIPHCLK_SAI2))
 801335c:	f53f aef2 	bmi.w	8013144 <HAL_RCCEx_PeriphCLKConfig+0x58>
 8013360:	46a8      	mov	r8, r5
  if((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_RTC) == RCC_PERIPHCLK_RTC)
 8013362:	0399      	lsls	r1, r3, #14
 8013364:	f57f af13 	bpl.w	801318e <HAL_RCCEx_PeriphCLKConfig+0xa2>
    if(__HAL_RCC_PWR_IS_CLK_DISABLED() != 0U)
 8013368:	4b1f      	ldr	r3, [pc, #124]	; (80133e8 <HAL_RCCEx_PeriphCLKConfig+0x2fc>)
 801336a:	6d9a      	ldr	r2, [r3, #88]	; 0x58
 801336c:	00d2      	lsls	r2, r2, #3
 801336e:	d566      	bpl.n	801343e <HAL_RCCEx_PeriphCLKConfig+0x352>
    FlagStatus       pwrclkchanged = RESET;
 8013370:	f04f 0900 	mov.w	r9, #0
    SET_BIT(PWR->CR1, PWR_CR1_DBP);
 8013374:	4e1d      	ldr	r6, [pc, #116]	; (80133ec <HAL_RCCEx_PeriphCLKConfig+0x300>)
 8013376:	6833      	ldr	r3, [r6, #0]
 8013378:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 801337c:	6033      	str	r3, [r6, #0]
    tickstart = HAL_GetTick();
 801337e:	f7fc fa5b 	bl	800f838 <HAL_GetTick>
 8013382:	4607      	mov	r7, r0
    while(READ_BIT(PWR->CR1, PWR_CR1_DBP) == 0U)
 8013384:	e004      	b.n	8013390 <HAL_RCCEx_PeriphCLKConfig+0x2a4>
      if((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
 8013386:	f7fc fa57 	bl	800f838 <HAL_GetTick>
 801338a:	1bc3      	subs	r3, r0, r7
 801338c:	2b02      	cmp	r3, #2
 801338e:	d862      	bhi.n	8013456 <HAL_RCCEx_PeriphCLKConfig+0x36a>
    while(READ_BIT(PWR->CR1, PWR_CR1_DBP) == 0U)
 8013390:	6833      	ldr	r3, [r6, #0]
 8013392:	05db      	lsls	r3, r3, #23
 8013394:	d5f7      	bpl.n	8013386 <HAL_RCCEx_PeriphCLKConfig+0x29a>
    if(ret == HAL_OK)
 8013396:	f1b8 0f00 	cmp.w	r8, #0
 801339a:	f040 80c0 	bne.w	801351e <HAL_RCCEx_PeriphCLKConfig+0x432>
      tmpregister = READ_BIT(RCC->BDCR, RCC_BDCR_RTCSEL);
 801339e:	4e12      	ldr	r6, [pc, #72]	; (80133e8 <HAL_RCCEx_PeriphCLKConfig+0x2fc>)
 80133a0:	f8d6 3090 	ldr.w	r3, [r6, #144]	; 0x90
      if((tmpregister != RCC_RTCCLKSOURCE_NONE) && (tmpregister != PeriphClkInit->RTCClockSelection))
 80133a4:	f413 7340 	ands.w	r3, r3, #768	; 0x300
 80133a8:	d02b      	beq.n	8013402 <HAL_RCCEx_PeriphCLKConfig+0x316>
 80133aa:	f8d4 2084 	ldr.w	r2, [r4, #132]	; 0x84
 80133ae:	429a      	cmp	r2, r3
 80133b0:	d029      	beq.n	8013406 <HAL_RCCEx_PeriphCLKConfig+0x31a>
        tmpregister = READ_BIT(RCC->BDCR, ~(RCC_BDCR_RTCSEL));
 80133b2:	f8d6 1090 	ldr.w	r1, [r6, #144]	; 0x90
        __HAL_RCC_BACKUPRESET_FORCE();
 80133b6:	f8d6 3090 	ldr.w	r3, [r6, #144]	; 0x90
 80133ba:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 80133be:	f8c6 3090 	str.w	r3, [r6, #144]	; 0x90
        __HAL_RCC_BACKUPRESET_RELEASE();
 80133c2:	f8d6 3090 	ldr.w	r3, [r6, #144]	; 0x90
 80133c6:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 80133ca:	f8c6 3090 	str.w	r3, [r6, #144]	; 0x90
      if (HAL_IS_BIT_SET(tmpregister, RCC_BDCR_LSEON))
 80133ce:	07c8      	lsls	r0, r1, #31
        tmpregister = READ_BIT(RCC->BDCR, ~(RCC_BDCR_RTCSEL));
 80133d0:	f421 7340 	bic.w	r3, r1, #768	; 0x300
        RCC->BDCR = tmpregister;
 80133d4:	f8c6 3090 	str.w	r3, [r6, #144]	; 0x90
      if (HAL_IS_BIT_SET(tmpregister, RCC_BDCR_LSEON))
 80133d8:	f140 80a3 	bpl.w	8013522 <HAL_RCCEx_PeriphCLKConfig+0x436>
        tickstart = HAL_GetTick();
 80133dc:	f7fc fa2c 	bl	800f838 <HAL_GetTick>
          if((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 80133e0:	f241 3888 	movw	r8, #5000	; 0x1388
        tickstart = HAL_GetTick();
 80133e4:	4607      	mov	r7, r0
        while(READ_BIT(RCC->BDCR, RCC_BDCR_LSERDY) == 0U)
 80133e6:	e008      	b.n	80133fa <HAL_RCCEx_PeriphCLKConfig+0x30e>
 80133e8:	40021000 	.word	0x40021000
 80133ec:	40007000 	.word	0x40007000
          if((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 80133f0:	f7fc fa22 	bl	800f838 <HAL_GetTick>
 80133f4:	1bc0      	subs	r0, r0, r7
 80133f6:	4540      	cmp	r0, r8
 80133f8:	d82d      	bhi.n	8013456 <HAL_RCCEx_PeriphCLKConfig+0x36a>
        while(READ_BIT(RCC->BDCR, RCC_BDCR_LSERDY) == 0U)
 80133fa:	f8d6 3090 	ldr.w	r3, [r6, #144]	; 0x90
 80133fe:	0799      	lsls	r1, r3, #30
 8013400:	d5f6      	bpl.n	80133f0 <HAL_RCCEx_PeriphCLKConfig+0x304>
        __HAL_RCC_RTC_CONFIG(PeriphClkInit->RTCClockSelection);
 8013402:	f8d4 3084 	ldr.w	r3, [r4, #132]	; 0x84
 8013406:	4948      	ldr	r1, [pc, #288]	; (8013528 <HAL_RCCEx_PeriphCLKConfig+0x43c>)
 8013408:	f8d1 2090 	ldr.w	r2, [r1, #144]	; 0x90
 801340c:	f422 7240 	bic.w	r2, r2, #768	; 0x300
 8013410:	4313      	orrs	r3, r2
 8013412:	f8c1 3090 	str.w	r3, [r1, #144]	; 0x90
    if(pwrclkchanged == SET)
 8013416:	f1b9 0f00 	cmp.w	r9, #0
 801341a:	d004      	beq.n	8013426 <HAL_RCCEx_PeriphCLKConfig+0x33a>
      __HAL_RCC_PWR_CLK_DISABLE();
 801341c:	4a42      	ldr	r2, [pc, #264]	; (8013528 <HAL_RCCEx_PeriphCLKConfig+0x43c>)
 801341e:	6d93      	ldr	r3, [r2, #88]	; 0x58
 8013420:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
 8013424:	6593      	str	r3, [r2, #88]	; 0x58
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART1) == RCC_PERIPHCLK_USART1)
 8013426:	6823      	ldr	r3, [r4, #0]
 8013428:	e6b1      	b.n	801318e <HAL_RCCEx_PeriphCLKConfig+0xa2>
    switch(PeriphClkInit->Sai2ClockSelection)
 801342a:	f1b1 7f40 	cmp.w	r1, #50331648	; 0x3000000
 801342e:	d131      	bne.n	8013494 <HAL_RCCEx_PeriphCLKConfig+0x3a8>
 8013430:	46a8      	mov	r8, r5
    if(ret == HAL_OK)
 8013432:	f1b8 0f00 	cmp.w	r8, #0
 8013436:	f43f ae9e 	beq.w	8013176 <HAL_RCCEx_PeriphCLKConfig+0x8a>
 801343a:	4645      	mov	r5, r8
 801343c:	e791      	b.n	8013362 <HAL_RCCEx_PeriphCLKConfig+0x276>
      __HAL_RCC_PWR_CLK_ENABLE();
 801343e:	6d9a      	ldr	r2, [r3, #88]	; 0x58
 8013440:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 8013444:	659a      	str	r2, [r3, #88]	; 0x58
 8013446:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8013448:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 801344c:	9301      	str	r3, [sp, #4]
 801344e:	9b01      	ldr	r3, [sp, #4]
      pwrclkchanged = SET;
 8013450:	f04f 0901 	mov.w	r9, #1
 8013454:	e78e      	b.n	8013374 <HAL_RCCEx_PeriphCLKConfig+0x288>
        ret = HAL_TIMEOUT;
 8013456:	2503      	movs	r5, #3
 8013458:	e7dd      	b.n	8013416 <HAL_RCCEx_PeriphCLKConfig+0x32a>
      ret = RCCEx_PLLSAI1_Config(&(PeriphClkInit->PLLSAI1), DIVIDER_P_UPDATE);
 801345a:	1d20      	adds	r0, r4, #4
 801345c:	f7ff fd32 	bl	8012ec4 <RCCEx_PLLSAI1_Config>
  if((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_RTC) == RCC_PERIPHCLK_RTC)
 8013460:	6823      	ldr	r3, [r4, #0]
      ret = RCCEx_PLLSAI1_Config(&(PeriphClkInit->PLLSAI1), DIVIDER_P_UPDATE);
 8013462:	4680      	mov	r8, r0
      break;
 8013464:	e683      	b.n	801316e <HAL_RCCEx_PeriphCLKConfig+0x82>
      ret = RCCEx_PLLSAI1_Config(&(PeriphClkInit->PLLSAI1), DIVIDER_P_UPDATE);
 8013466:	3004      	adds	r0, #4
 8013468:	f7ff fd2c 	bl	8012ec4 <RCCEx_PLLSAI1_Config>
 801346c:	4605      	mov	r5, r0
    if(ret == HAL_OK)
 801346e:	2d00      	cmp	r5, #0
 8013470:	f43f ae5a 	beq.w	8013128 <HAL_RCCEx_PeriphCLKConfig+0x3c>
 8013474:	e028      	b.n	80134c8 <HAL_RCCEx_PeriphCLKConfig+0x3dc>
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_48M1CLK);
 8013476:	68ca      	ldr	r2, [r1, #12]
 8013478:	f442 1280 	orr.w	r2, r2, #1048576	; 0x100000
 801347c:	60ca      	str	r2, [r1, #12]
 801347e:	e738      	b.n	80132f2 <HAL_RCCEx_PeriphCLKConfig+0x206>
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_48M1CLK);
 8013480:	68ca      	ldr	r2, [r1, #12]
 8013482:	f442 1280 	orr.w	r2, r2, #1048576	; 0x100000
 8013486:	60ca      	str	r2, [r1, #12]
 8013488:	e70d      	b.n	80132a6 <HAL_RCCEx_PeriphCLKConfig+0x1ba>
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_48M1CLK);
 801348a:	68ca      	ldr	r2, [r1, #12]
 801348c:	f442 1280 	orr.w	r2, r2, #1048576	; 0x100000
 8013490:	60ca      	str	r2, [r1, #12]
 8013492:	e71b      	b.n	80132cc <HAL_RCCEx_PeriphCLKConfig+0x1e0>
    switch(PeriphClkInit->Sai2ClockSelection)
 8013494:	2501      	movs	r5, #1
 8013496:	46a8      	mov	r8, r5
 8013498:	e763      	b.n	8013362 <HAL_RCCEx_PeriphCLKConfig+0x276>
      ret = RCCEx_PLLSAI1_Config(&(PeriphClkInit->PLLSAI1), DIVIDER_R_UPDATE);
 801349a:	2102      	movs	r1, #2
 801349c:	1d20      	adds	r0, r4, #4
 801349e:	f7ff fd11 	bl	8012ec4 <RCCEx_PLLSAI1_Config>
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SWPMI1) == RCC_PERIPHCLK_SWPMI1)
 80134a2:	6823      	ldr	r3, [r4, #0]
      if(ret != HAL_OK)
 80134a4:	2800      	cmp	r0, #0
 80134a6:	f43f af37 	beq.w	8013318 <HAL_RCCEx_PeriphCLKConfig+0x22c>
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SWPMI1) == RCC_PERIPHCLK_SWPMI1)
 80134aa:	4605      	mov	r5, r0
 80134ac:	e734      	b.n	8013318 <HAL_RCCEx_PeriphCLKConfig+0x22c>
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_SAI3CLK);
 80134ae:	481e      	ldr	r0, [pc, #120]	; (8013528 <HAL_RCCEx_PeriphCLKConfig+0x43c>)
 80134b0:	68c2      	ldr	r2, [r0, #12]
 80134b2:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
 80134b6:	60c2      	str	r2, [r0, #12]
    if(ret == HAL_OK)
 80134b8:	e638      	b.n	801312c <HAL_RCCEx_PeriphCLKConfig+0x40>
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_SAI3CLK);
 80134ba:	491b      	ldr	r1, [pc, #108]	; (8013528 <HAL_RCCEx_PeriphCLKConfig+0x43c>)
 80134bc:	68ca      	ldr	r2, [r1, #12]
 80134be:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
 80134c2:	60ca      	str	r2, [r1, #12]
      break;
 80134c4:	46a8      	mov	r8, r5
 80134c6:	e652      	b.n	801316e <HAL_RCCEx_PeriphCLKConfig+0x82>
  if((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI2) == RCC_PERIPHCLK_SAI2))
 80134c8:	6823      	ldr	r3, [r4, #0]
 80134ca:	e638      	b.n	801313e <HAL_RCCEx_PeriphCLKConfig+0x52>
      ret = RCCEx_PLLSAI2_Config(&(PeriphClkInit->PLLSAI2), DIVIDER_R_UPDATE);
 80134cc:	2102      	movs	r1, #2
 80134ce:	f104 0020 	add.w	r0, r4, #32
 80134d2:	f7ff fd89 	bl	8012fe8 <RCCEx_PLLSAI2_Config>
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SWPMI1) == RCC_PERIPHCLK_SWPMI1)
 80134d6:	6823      	ldr	r3, [r4, #0]
      if(ret != HAL_OK)
 80134d8:	2800      	cmp	r0, #0
 80134da:	f43f af1d 	beq.w	8013318 <HAL_RCCEx_PeriphCLKConfig+0x22c>
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SWPMI1) == RCC_PERIPHCLK_SWPMI1)
 80134de:	4605      	mov	r5, r0
 80134e0:	e71a      	b.n	8013318 <HAL_RCCEx_PeriphCLKConfig+0x22c>
      ret = RCCEx_PLLSAI1_Config(&(PeriphClkInit->PLLSAI1), DIVIDER_Q_UPDATE);
 80134e2:	2101      	movs	r1, #1
 80134e4:	1d20      	adds	r0, r4, #4
 80134e6:	f7ff fced 	bl	8012ec4 <RCCEx_PLLSAI1_Config>
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_ADC) == RCC_PERIPHCLK_ADC)
 80134ea:	6823      	ldr	r3, [r4, #0]
      if(ret != HAL_OK)
 80134ec:	2800      	cmp	r0, #0
 80134ee:	f43f af00 	beq.w	80132f2 <HAL_RCCEx_PeriphCLKConfig+0x206>
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_ADC) == RCC_PERIPHCLK_ADC)
 80134f2:	4605      	mov	r5, r0
 80134f4:	e6fd      	b.n	80132f2 <HAL_RCCEx_PeriphCLKConfig+0x206>
        ret = RCCEx_PLLSAI1_Config(&(PeriphClkInit->PLLSAI1), DIVIDER_Q_UPDATE);
 80134f6:	2101      	movs	r1, #1
 80134f8:	1d20      	adds	r0, r4, #4
 80134fa:	f7ff fce3 	bl	8012ec4 <RCCEx_PLLSAI1_Config>
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SDMMC1) == (RCC_PERIPHCLK_SDMMC1))
 80134fe:	6823      	ldr	r3, [r4, #0]
        if(ret != HAL_OK)
 8013500:	2800      	cmp	r0, #0
 8013502:	f43f aed0 	beq.w	80132a6 <HAL_RCCEx_PeriphCLKConfig+0x1ba>
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SDMMC1) == (RCC_PERIPHCLK_SDMMC1))
 8013506:	4605      	mov	r5, r0
 8013508:	e6cd      	b.n	80132a6 <HAL_RCCEx_PeriphCLKConfig+0x1ba>
      ret = RCCEx_PLLSAI1_Config(&(PeriphClkInit->PLLSAI1), DIVIDER_Q_UPDATE);
 801350a:	2101      	movs	r1, #1
 801350c:	1d20      	adds	r0, r4, #4
 801350e:	f7ff fcd9 	bl	8012ec4 <RCCEx_PLLSAI1_Config>
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_RNG) == (RCC_PERIPHCLK_RNG))
 8013512:	6823      	ldr	r3, [r4, #0]
      if(ret != HAL_OK)
 8013514:	2800      	cmp	r0, #0
 8013516:	f43f aed9 	beq.w	80132cc <HAL_RCCEx_PeriphCLKConfig+0x1e0>
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_RNG) == (RCC_PERIPHCLK_RNG))
 801351a:	4605      	mov	r5, r0
 801351c:	e6d6      	b.n	80132cc <HAL_RCCEx_PeriphCLKConfig+0x1e0>
 801351e:	4645      	mov	r5, r8
 8013520:	e779      	b.n	8013416 <HAL_RCCEx_PeriphCLKConfig+0x32a>
 8013522:	4613      	mov	r3, r2
 8013524:	e76f      	b.n	8013406 <HAL_RCCEx_PeriphCLKConfig+0x31a>
 8013526:	bf00      	nop
 8013528:	40021000 	.word	0x40021000

0801352c <HAL_RCCEx_GetPeriphCLKConfig>:
  PeriphClkInit->PLLSAI1.PLLSAI1Source = READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC) >> RCC_PLLCFGR_PLLSRC_Pos;
 801352c:	4b4e      	ldr	r3, [pc, #312]	; (8013668 <HAL_RCCEx_GetPeriphCLKConfig+0x13c>)
  PeriphClkInit->PeriphClockSelection = RCC_PERIPHCLK_USART1  | RCC_PERIPHCLK_USART2 | RCC_PERIPHCLK_USART3 | RCC_PERIPHCLK_UART4  | RCC_PERIPHCLK_UART5  | \
 801352e:	4a4f      	ldr	r2, [pc, #316]	; (801366c <HAL_RCCEx_GetPeriphCLKConfig+0x140>)
 8013530:	6002      	str	r2, [r0, #0]
{
 8013532:	b410      	push	{r4}
  PeriphClkInit->PLLSAI1.PLLSAI1Source = READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC) >> RCC_PLLCFGR_PLLSRC_Pos;
 8013534:	68dc      	ldr	r4, [r3, #12]
 8013536:	f004 0403 	and.w	r4, r4, #3
 801353a:	6044      	str	r4, [r0, #4]
  PeriphClkInit->PLLSAI1.PLLSAI1M = (READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLM) >> RCC_PLLCFGR_PLLM_Pos) + 1U;
 801353c:	68d9      	ldr	r1, [r3, #12]
 801353e:	f3c1 1102 	ubfx	r1, r1, #4, #3
 8013542:	3101      	adds	r1, #1
 8013544:	6081      	str	r1, [r0, #8]
  PeriphClkInit->PLLSAI1.PLLSAI1N = READ_BIT(RCC->PLLSAI1CFGR, RCC_PLLSAI1CFGR_PLLSAI1N) >> RCC_PLLSAI1CFGR_PLLSAI1N_Pos;
 8013546:	691a      	ldr	r2, [r3, #16]
 8013548:	f3c2 2206 	ubfx	r2, r2, #8, #7
 801354c:	60c2      	str	r2, [r0, #12]
  PeriphClkInit->PLLSAI1.PLLSAI1P = ((READ_BIT(RCC->PLLSAI1CFGR, RCC_PLLSAI1CFGR_PLLSAI1P) >> RCC_PLLSAI1CFGR_PLLSAI1P_Pos) << 4U) + 7U;
 801354e:	691a      	ldr	r2, [r3, #16]
 8013550:	0b52      	lsrs	r2, r2, #13
 8013552:	f002 0210 	and.w	r2, r2, #16
 8013556:	3207      	adds	r2, #7
 8013558:	6102      	str	r2, [r0, #16]
  PeriphClkInit->PLLSAI1.PLLSAI1Q = ((READ_BIT(RCC->PLLSAI1CFGR, RCC_PLLSAI1CFGR_PLLSAI1Q) >> RCC_PLLSAI1CFGR_PLLSAI1Q_Pos) + 1U) * 2U;
 801355a:	691a      	ldr	r2, [r3, #16]
 801355c:	f3c2 5241 	ubfx	r2, r2, #21, #2
 8013560:	3201      	adds	r2, #1
 8013562:	0052      	lsls	r2, r2, #1
 8013564:	6142      	str	r2, [r0, #20]
  PeriphClkInit->PLLSAI1.PLLSAI1R = ((READ_BIT(RCC->PLLSAI1CFGR, RCC_PLLSAI1CFGR_PLLSAI1R) >> RCC_PLLSAI1CFGR_PLLSAI1R_Pos) + 1U) * 2U;
 8013566:	691a      	ldr	r2, [r3, #16]
  PeriphClkInit->PLLSAI2.PLLSAI2Source = PeriphClkInit->PLLSAI1.PLLSAI1Source;
 8013568:	6204      	str	r4, [r0, #32]
  PeriphClkInit->PLLSAI1.PLLSAI1R = ((READ_BIT(RCC->PLLSAI1CFGR, RCC_PLLSAI1CFGR_PLLSAI1R) >> RCC_PLLSAI1CFGR_PLLSAI1R_Pos) + 1U) * 2U;
 801356a:	f3c2 6241 	ubfx	r2, r2, #25, #2
 801356e:	3201      	adds	r2, #1
 8013570:	0052      	lsls	r2, r2, #1
 8013572:	6182      	str	r2, [r0, #24]
  PeriphClkInit->PLLSAI2.PLLSAI2M = PeriphClkInit->PLLSAI1.PLLSAI1M;
 8013574:	6241      	str	r1, [r0, #36]	; 0x24
  PeriphClkInit->PLLSAI2.PLLSAI2N = READ_BIT(RCC->PLLSAI2CFGR, RCC_PLLSAI2CFGR_PLLSAI2N) >> RCC_PLLSAI2CFGR_PLLSAI2N_Pos;
 8013576:	695a      	ldr	r2, [r3, #20]
 8013578:	f3c2 2206 	ubfx	r2, r2, #8, #7
 801357c:	6282      	str	r2, [r0, #40]	; 0x28
  PeriphClkInit->PLLSAI2.PLLSAI2P = ((READ_BIT(RCC->PLLSAI2CFGR, RCC_PLLSAI2CFGR_PLLSAI2P) >> RCC_PLLSAI2CFGR_PLLSAI2P_Pos) << 4U) + 7U;
 801357e:	695a      	ldr	r2, [r3, #20]
 8013580:	0b52      	lsrs	r2, r2, #13
 8013582:	f002 0210 	and.w	r2, r2, #16
 8013586:	3207      	adds	r2, #7
 8013588:	62c2      	str	r2, [r0, #44]	; 0x2c
  PeriphClkInit->PLLSAI2.PLLSAI2R = ((READ_BIT(RCC->PLLSAI2CFGR, RCC_PLLSAI2CFGR_PLLSAI2R)>> RCC_PLLSAI2CFGR_PLLSAI2R_Pos) + 1U) * 2U;
 801358a:	695a      	ldr	r2, [r3, #20]
 801358c:	f3c2 6241 	ubfx	r2, r2, #25, #2
 8013590:	3201      	adds	r2, #1
 8013592:	0052      	lsls	r2, r2, #1
 8013594:	6302      	str	r2, [r0, #48]	; 0x30
  PeriphClkInit->Usart1ClockSelection  = __HAL_RCC_GET_USART1_SOURCE();
 8013596:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
 801359a:	f002 0203 	and.w	r2, r2, #3
 801359e:	6382      	str	r2, [r0, #56]	; 0x38
  PeriphClkInit->Usart2ClockSelection  = __HAL_RCC_GET_USART2_SOURCE();
 80135a0:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
 80135a4:	f002 020c 	and.w	r2, r2, #12
 80135a8:	63c2      	str	r2, [r0, #60]	; 0x3c
  PeriphClkInit->Usart3ClockSelection  = __HAL_RCC_GET_USART3_SOURCE();
 80135aa:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
 80135ae:	f002 0230 	and.w	r2, r2, #48	; 0x30
 80135b2:	6402      	str	r2, [r0, #64]	; 0x40
  PeriphClkInit->Uart4ClockSelection   = __HAL_RCC_GET_UART4_SOURCE();
 80135b4:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
 80135b8:	f002 02c0 	and.w	r2, r2, #192	; 0xc0
 80135bc:	6442      	str	r2, [r0, #68]	; 0x44
  PeriphClkInit->Uart5ClockSelection   = __HAL_RCC_GET_UART5_SOURCE();
 80135be:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
 80135c2:	f402 7240 	and.w	r2, r2, #768	; 0x300
 80135c6:	6482      	str	r2, [r0, #72]	; 0x48
  PeriphClkInit->Lpuart1ClockSelection = __HAL_RCC_GET_LPUART1_SOURCE();
 80135c8:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
}
 80135cc:	f85d 4b04 	ldr.w	r4, [sp], #4
  PeriphClkInit->Lpuart1ClockSelection = __HAL_RCC_GET_LPUART1_SOURCE();
 80135d0:	f402 6240 	and.w	r2, r2, #3072	; 0xc00
 80135d4:	64c2      	str	r2, [r0, #76]	; 0x4c
  PeriphClkInit->I2c1ClockSelection    = __HAL_RCC_GET_I2C1_SOURCE();
 80135d6:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
 80135da:	f402 5240 	and.w	r2, r2, #12288	; 0x3000
 80135de:	6502      	str	r2, [r0, #80]	; 0x50
  PeriphClkInit->I2c2ClockSelection    = __HAL_RCC_GET_I2C2_SOURCE();
 80135e0:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
 80135e4:	f402 4240 	and.w	r2, r2, #49152	; 0xc000
 80135e8:	6542      	str	r2, [r0, #84]	; 0x54
  PeriphClkInit->I2c3ClockSelection    = __HAL_RCC_GET_I2C3_SOURCE();
 80135ea:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
 80135ee:	f402 3240 	and.w	r2, r2, #196608	; 0x30000
 80135f2:	6582      	str	r2, [r0, #88]	; 0x58
  PeriphClkInit->Lptim1ClockSelection  = __HAL_RCC_GET_LPTIM1_SOURCE();
 80135f4:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
 80135f8:	f402 2240 	and.w	r2, r2, #786432	; 0xc0000
 80135fc:	65c2      	str	r2, [r0, #92]	; 0x5c
  PeriphClkInit->Lptim2ClockSelection  = __HAL_RCC_GET_LPTIM2_SOURCE();
 80135fe:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
 8013602:	f402 1240 	and.w	r2, r2, #3145728	; 0x300000
 8013606:	6602      	str	r2, [r0, #96]	; 0x60
  PeriphClkInit->Sai1ClockSelection    = __HAL_RCC_GET_SAI1_SOURCE();
 8013608:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
 801360c:	f402 0240 	and.w	r2, r2, #12582912	; 0xc00000
 8013610:	6642      	str	r2, [r0, #100]	; 0x64
  PeriphClkInit->Sai2ClockSelection    = __HAL_RCC_GET_SAI2_SOURCE();
 8013612:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
 8013616:	f002 7240 	and.w	r2, r2, #50331648	; 0x3000000
 801361a:	6682      	str	r2, [r0, #104]	; 0x68
  PeriphClkInit->RTCClockSelection     = __HAL_RCC_GET_RTC_SOURCE();
 801361c:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
 8013620:	f402 7240 	and.w	r2, r2, #768	; 0x300
 8013624:	f8c0 2084 	str.w	r2, [r0, #132]	; 0x84
  PeriphClkInit->UsbClockSelection   = __HAL_RCC_GET_USB_SOURCE();
 8013628:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
 801362c:	f002 6240 	and.w	r2, r2, #201326592	; 0xc000000
 8013630:	66c2      	str	r2, [r0, #108]	; 0x6c
  PeriphClkInit->Sdmmc1ClockSelection   = __HAL_RCC_GET_SDMMC1_SOURCE();
 8013632:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
 8013636:	f002 6240 	and.w	r2, r2, #201326592	; 0xc000000
 801363a:	6702      	str	r2, [r0, #112]	; 0x70
  PeriphClkInit->RngClockSelection   = __HAL_RCC_GET_RNG_SOURCE();
 801363c:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
 8013640:	f002 6240 	and.w	r2, r2, #201326592	; 0xc000000
 8013644:	6742      	str	r2, [r0, #116]	; 0x74
  PeriphClkInit->AdcClockSelection     = __HAL_RCC_GET_ADC_SOURCE();
 8013646:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
 801364a:	f002 5240 	and.w	r2, r2, #805306368	; 0x30000000
 801364e:	6782      	str	r2, [r0, #120]	; 0x78
  PeriphClkInit->Swpmi1ClockSelection  = __HAL_RCC_GET_SWPMI1_SOURCE();
 8013650:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
 8013654:	f002 4280 	and.w	r2, r2, #1073741824	; 0x40000000
 8013658:	67c2      	str	r2, [r0, #124]	; 0x7c
  PeriphClkInit->Dfsdm1ClockSelection  = __HAL_RCC_GET_DFSDM1_SOURCE();
 801365a:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 801365e:	f003 4300 	and.w	r3, r3, #2147483648	; 0x80000000
 8013662:	f8c0 3080 	str.w	r3, [r0, #128]	; 0x80
}
 8013666:	4770      	bx	lr
 8013668:	40021000 	.word	0x40021000
 801366c:	000fffff 	.word	0x000fffff

08013670 <HAL_RCCEx_GetPeriphCLKFreq>:
  if(PeriphClk == RCC_PERIPHCLK_RTC)
 8013670:	f5b0 3f00 	cmp.w	r0, #131072	; 0x20000
    srcclk = __HAL_RCC_GET_RTC_SOURCE();
 8013674:	4aae      	ldr	r2, [pc, #696]	; (8013930 <HAL_RCCEx_GetPeriphCLKFreq+0x2c0>)
  if(PeriphClk == RCC_PERIPHCLK_RTC)
 8013676:	d03b      	beq.n	80136f0 <HAL_RCCEx_GetPeriphCLKFreq+0x80>
    pll_oscsource = __HAL_RCC_GET_PLL_OSCSOURCE();
 8013678:	68d3      	ldr	r3, [r2, #12]
 801367a:	f003 0303 	and.w	r3, r3, #3
    switch(pll_oscsource)
 801367e:	2b02      	cmp	r3, #2
 8013680:	f000 80fd 	beq.w	801387e <HAL_RCCEx_GetPeriphCLKFreq+0x20e>
 8013684:	2b03      	cmp	r3, #3
 8013686:	f000 80f3 	beq.w	8013870 <HAL_RCCEx_GetPeriphCLKFreq+0x200>
 801368a:	2b01      	cmp	r3, #1
 801368c:	f000 80dc 	beq.w	8013848 <HAL_RCCEx_GetPeriphCLKFreq+0x1d8>
 8013690:	2100      	movs	r1, #0
    switch(PeriphClk)
 8013692:	f5b0 7f80 	cmp.w	r0, #256	; 0x100
 8013696:	f000 8105 	beq.w	80138a4 <HAL_RCCEx_GetPeriphCLKFreq+0x234>
 801369a:	d850      	bhi.n	801373e <HAL_RCCEx_GetPeriphCLKFreq+0xce>
 801369c:	2820      	cmp	r0, #32
 801369e:	d839      	bhi.n	8013714 <HAL_RCCEx_GetPeriphCLKFreq+0xa4>
 80136a0:	2800      	cmp	r0, #0
 80136a2:	f000 80d0 	beq.w	8013846 <HAL_RCCEx_GetPeriphCLKFreq+0x1d6>
 80136a6:	3801      	subs	r0, #1
 80136a8:	281f      	cmp	r0, #31
 80136aa:	d831      	bhi.n	8013710 <HAL_RCCEx_GetPeriphCLKFreq+0xa0>
 80136ac:	e8df f010 	tbh	[pc, r0, lsl #1]
 80136b0:	0158014a 	.word	0x0158014a
 80136b4:	017e0030 	.word	0x017e0030
 80136b8:	00300030 	.word	0x00300030
 80136bc:	018d0030 	.word	0x018d0030
 80136c0:	00300030 	.word	0x00300030
 80136c4:	00300030 	.word	0x00300030
 80136c8:	00300030 	.word	0x00300030
 80136cc:	019d0030 	.word	0x019d0030
 80136d0:	00300030 	.word	0x00300030
 80136d4:	00300030 	.word	0x00300030
 80136d8:	00300030 	.word	0x00300030
 80136dc:	00300030 	.word	0x00300030
 80136e0:	00300030 	.word	0x00300030
 80136e4:	00300030 	.word	0x00300030
 80136e8:	00300030 	.word	0x00300030
 80136ec:	012d0030 	.word	0x012d0030
    srcclk = __HAL_RCC_GET_RTC_SOURCE();
 80136f0:	f8d2 3090 	ldr.w	r3, [r2, #144]	; 0x90
 80136f4:	f403 7340 	and.w	r3, r3, #768	; 0x300
    switch(srcclk)
 80136f8:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 80136fc:	f000 80f6 	beq.w	80138ec <HAL_RCCEx_GetPeriphCLKFreq+0x27c>
 8013700:	f5b3 7f40 	cmp.w	r3, #768	; 0x300
 8013704:	f000 80fa 	beq.w	80138fc <HAL_RCCEx_GetPeriphCLKFreq+0x28c>
 8013708:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 801370c:	f000 80c2 	beq.w	8013894 <HAL_RCCEx_GetPeriphCLKFreq+0x224>
 8013710:	2000      	movs	r0, #0
  return(frequency);
 8013712:	4770      	bx	lr
    switch(PeriphClk)
 8013714:	2840      	cmp	r0, #64	; 0x40
 8013716:	f000 81d0 	beq.w	8013aba <HAL_RCCEx_GetPeriphCLKFreq+0x44a>
 801371a:	2880      	cmp	r0, #128	; 0x80
 801371c:	d1f8      	bne.n	8013710 <HAL_RCCEx_GetPeriphCLKFreq+0xa0>
        srcclk = __HAL_RCC_GET_I2C2_SOURCE();
 801371e:	4a84      	ldr	r2, [pc, #528]	; (8013930 <HAL_RCCEx_GetPeriphCLKFreq+0x2c0>)
 8013720:	f8d2 3088 	ldr.w	r3, [r2, #136]	; 0x88
 8013724:	f403 4340 	and.w	r3, r3, #49152	; 0xc000
        switch(srcclk)
 8013728:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000
 801372c:	d019      	beq.n	8013762 <HAL_RCCEx_GetPeriphCLKFreq+0xf2>
 801372e:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
 8013732:	f000 80c4 	beq.w	80138be <HAL_RCCEx_GetPeriphCLKFreq+0x24e>
 8013736:	2b00      	cmp	r3, #0
 8013738:	d1ea      	bne.n	8013710 <HAL_RCCEx_GetPeriphCLKFreq+0xa0>
          frequency = HAL_RCC_GetPCLK1Freq();
 801373a:	f7ff bb25 	b.w	8012d88 <HAL_RCC_GetPCLK1Freq>
    switch(PeriphClk)
 801373e:	f5b0 5f80 	cmp.w	r0, #4096	; 0x1000
 8013742:	d017      	beq.n	8013774 <HAL_RCCEx_GetPeriphCLKFreq+0x104>
 8013744:	d90f      	bls.n	8013766 <HAL_RCCEx_GetPeriphCLKFreq+0xf6>
 8013746:	f5b0 4f00 	cmp.w	r0, #32768	; 0x8000
 801374a:	f000 81a9 	beq.w	8013aa0 <HAL_RCCEx_GetPeriphCLKFreq+0x430>
 801374e:	d930      	bls.n	80137b2 <HAL_RCCEx_GetPeriphCLKFreq+0x142>
 8013750:	f5b0 3f80 	cmp.w	r0, #65536	; 0x10000
 8013754:	d110      	bne.n	8013778 <HAL_RCCEx_GetPeriphCLKFreq+0x108>
        srcclk = __HAL_RCC_GET_DFSDM1_SOURCE();
 8013756:	4b76      	ldr	r3, [pc, #472]	; (8013930 <HAL_RCCEx_GetPeriphCLKFreq+0x2c0>)
 8013758:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
        if(srcclk == RCC_DFSDM1CLKSOURCE_PCLK2)
 801375c:	2b00      	cmp	r3, #0
 801375e:	f280 80fd 	bge.w	801395c <HAL_RCCEx_GetPeriphCLKFreq+0x2ec>
          frequency = HAL_RCC_GetSysClockFreq();
 8013762:	f7fe bf4d 	b.w	8012600 <HAL_RCC_GetSysClockFreq>
    switch(PeriphClk)
 8013766:	f5b0 6f80 	cmp.w	r0, #1024	; 0x400
 801376a:	f000 80af 	beq.w	80138cc <HAL_RCCEx_GetPeriphCLKFreq+0x25c>
 801376e:	f5b0 6f00 	cmp.w	r0, #2048	; 0x800
 8013772:	d14b      	bne.n	801380c <HAL_RCCEx_GetPeriphCLKFreq+0x19c>
      frequency = RCCEx_GetSAIxPeriphCLKFreq(RCC_PERIPHCLK_SAI2, pllvco);
 8013774:	f7ff bb2c 	b.w	8012dd0 <RCCEx_GetSAIxPeriphCLKFreq>
    switch(PeriphClk)
 8013778:	d3ca      	bcc.n	8013710 <HAL_RCCEx_GetPeriphCLKFreq+0xa0>
 801377a:	f5b0 2f80 	cmp.w	r0, #262144	; 0x40000
 801377e:	d002      	beq.n	8013786 <HAL_RCCEx_GetPeriphCLKFreq+0x116>
 8013780:	f5b0 2f00 	cmp.w	r0, #524288	; 0x80000
 8013784:	d1c4      	bne.n	8013710 <HAL_RCCEx_GetPeriphCLKFreq+0xa0>
        srcclk = READ_BIT(RCC->CCIPR, RCC_CCIPR_CLK48SEL);
 8013786:	4a6a      	ldr	r2, [pc, #424]	; (8013930 <HAL_RCCEx_GetPeriphCLKFreq+0x2c0>)
 8013788:	f8d2 3088 	ldr.w	r3, [r2, #136]	; 0x88
 801378c:	f003 6340 	and.w	r3, r3, #201326592	; 0xc000000
        switch(srcclk)
 8013790:	f1b3 6f00 	cmp.w	r3, #134217728	; 0x8000000
{
 8013794:	b410      	push	{r4}
 8013796:	f000 813a 	beq.w	8013a0e <HAL_RCCEx_GetPeriphCLKFreq+0x39e>
 801379a:	f1b3 6f40 	cmp.w	r3, #201326592	; 0xc000000
 801379e:	f000 81ad 	beq.w	8013afc <HAL_RCCEx_GetPeriphCLKFreq+0x48c>
 80137a2:	f1b3 6f80 	cmp.w	r3, #67108864	; 0x4000000
 80137a6:	f000 819b 	beq.w	8013ae0 <HAL_RCCEx_GetPeriphCLKFreq+0x470>
 80137aa:	2000      	movs	r0, #0
}
 80137ac:	f85d 4b04 	ldr.w	r4, [sp], #4
 80137b0:	4770      	bx	lr
    switch(PeriphClk)
 80137b2:	f5b0 5f00 	cmp.w	r0, #8192	; 0x2000
 80137b6:	d0e6      	beq.n	8013786 <HAL_RCCEx_GetPeriphCLKFreq+0x116>
 80137b8:	f5b0 4f80 	cmp.w	r0, #16384	; 0x4000
 80137bc:	d1a8      	bne.n	8013710 <HAL_RCCEx_GetPeriphCLKFreq+0xa0>
        srcclk = __HAL_RCC_GET_ADC_SOURCE();
 80137be:	4a5c      	ldr	r2, [pc, #368]	; (8013930 <HAL_RCCEx_GetPeriphCLKFreq+0x2c0>)
 80137c0:	f8d2 3088 	ldr.w	r3, [r2, #136]	; 0x88
 80137c4:	f003 5340 	and.w	r3, r3, #805306368	; 0x30000000
        switch(srcclk)
 80137c8:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
 80137cc:	f000 813c 	beq.w	8013a48 <HAL_RCCEx_GetPeriphCLKFreq+0x3d8>
 80137d0:	f1b3 5f40 	cmp.w	r3, #805306368	; 0x30000000
 80137d4:	d0c5      	beq.n	8013762 <HAL_RCCEx_GetPeriphCLKFreq+0xf2>
 80137d6:	f1b3 5f80 	cmp.w	r3, #268435456	; 0x10000000
 80137da:	d199      	bne.n	8013710 <HAL_RCCEx_GetPeriphCLKFreq+0xa0>
          if(__HAL_RCC_GET_PLLSAI1CLKOUT_CONFIG(RCC_PLLSAI1_ADC1CLK) != 0U)
 80137dc:	6910      	ldr	r0, [r2, #16]
 80137de:	f010 7080 	ands.w	r0, r0, #16777216	; 0x1000000
 80137e2:	4613      	mov	r3, r2
 80137e4:	d02f      	beq.n	8013846 <HAL_RCCEx_GetPeriphCLKFreq+0x1d6>
            plln = READ_BIT(RCC->PLLSAI1CFGR, RCC_PLLSAI1CFGR_PLLSAI1N) >> RCC_PLLSAI1CFGR_PLLSAI1N_Pos;
 80137e6:	6912      	ldr	r2, [r2, #16]
            pllvco = ((pllvco * plln) / ((READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLM) >> RCC_PLLCFGR_PLLM_Pos) + 1U));
 80137e8:	68d8      	ldr	r0, [r3, #12]
            frequency = (pllvco / (((READ_BIT(RCC->PLLSAI1CFGR, RCC_PLLSAI1CFGR_PLLSAI1R) >> RCC_PLLSAI1CFGR_PLLSAI1R_Pos) + 1U) << 1U));
 80137ea:	691b      	ldr	r3, [r3, #16]
            frequency = (pllvco / (((READ_BIT(RCC->PLLSAI2CFGR, RCC_PLLSAI2CFGR_PLLSAI2R) >> RCC_PLLSAI2CFGR_PLLSAI2R_Pos) + 1U) << 1U));
 80137ec:	f3c3 6341 	ubfx	r3, r3, #25, #2
            plln = READ_BIT(RCC->PLLSAI2CFGR, RCC_PLLSAI2CFGR_PLLSAI2N) >> RCC_PLLSAI2CFGR_PLLSAI2N_Pos;
 80137f0:	f3c2 2206 	ubfx	r2, r2, #8, #7
            pllvco = ((pllvco * plln) / ((READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLM) >> RCC_PLLCFGR_PLLM_Pos) + 1U));
 80137f4:	f3c0 1002 	ubfx	r0, r0, #4, #3
            frequency = (pllvco / (((READ_BIT(RCC->PLLSAI2CFGR, RCC_PLLSAI2CFGR_PLLSAI2R) >> RCC_PLLSAI2CFGR_PLLSAI2R_Pos) + 1U) << 1U));
 80137f8:	3301      	adds	r3, #1
            pllvco = ((pllvco * plln) / ((READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLM) >> RCC_PLLCFGR_PLLM_Pos) + 1U));
 80137fa:	fb02 f101 	mul.w	r1, r2, r1
            frequency = (pllvco / (((READ_BIT(RCC->PLLSAI2CFGR, RCC_PLLSAI2CFGR_PLLSAI2R) >> RCC_PLLSAI2CFGR_PLLSAI2R_Pos) + 1U) << 1U));
 80137fe:	005b      	lsls	r3, r3, #1
            pllvco = ((pllvco * plln) / ((READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLM) >> RCC_PLLCFGR_PLLM_Pos) + 1U));
 8013800:	3001      	adds	r0, #1
 8013802:	fbb1 f0f0 	udiv	r0, r1, r0
            frequency = (pllvco / (((READ_BIT(RCC->PLLSAI2CFGR, RCC_PLLSAI2CFGR_PLLSAI2R) >> RCC_PLLSAI2CFGR_PLLSAI2R_Pos) + 1U) << 1U));
 8013806:	fbb0 f0f3 	udiv	r0, r0, r3
 801380a:	4770      	bx	lr
    switch(PeriphClk)
 801380c:	f5b0 7f00 	cmp.w	r0, #512	; 0x200
 8013810:	f47f af7e 	bne.w	8013710 <HAL_RCCEx_GetPeriphCLKFreq+0xa0>
        srcclk = __HAL_RCC_GET_LPTIM1_SOURCE();
 8013814:	4a46      	ldr	r2, [pc, #280]	; (8013930 <HAL_RCCEx_GetPeriphCLKFreq+0x2c0>)
 8013816:	f8d2 3088 	ldr.w	r3, [r2, #136]	; 0x88
 801381a:	f403 2340 	and.w	r3, r3, #786432	; 0xc0000
        switch(srcclk)
 801381e:	f5b3 2f00 	cmp.w	r3, #524288	; 0x80000
 8013822:	d04c      	beq.n	80138be <HAL_RCCEx_GetPeriphCLKFreq+0x24e>
 8013824:	f200 811a 	bhi.w	8013a5c <HAL_RCCEx_GetPeriphCLKFreq+0x3ec>
 8013828:	2b00      	cmp	r3, #0
 801382a:	d086      	beq.n	801373a <HAL_RCCEx_GetPeriphCLKFreq+0xca>
 801382c:	f5b3 2f80 	cmp.w	r3, #262144	; 0x40000
 8013830:	f47f af6e 	bne.w	8013710 <HAL_RCCEx_GetPeriphCLKFreq+0xa0>
          if(HAL_IS_BIT_SET(RCC->CSR, RCC_CSR_LSIRDY))
 8013834:	4b3e      	ldr	r3, [pc, #248]	; (8013930 <HAL_RCCEx_GetPeriphCLKFreq+0x2c0>)
 8013836:	f8d3 0094 	ldr.w	r0, [r3, #148]	; 0x94
              frequency = LSI_VALUE;
 801383a:	f010 0002 	ands.w	r0, r0, #2
 801383e:	bf18      	it	ne
 8013840:	f44f 40fa 	movne.w	r0, #32000	; 0x7d00
 8013844:	4770      	bx	lr
}
 8013846:	4770      	bx	lr
      if(HAL_IS_BIT_SET(RCC->CR, RCC_CR_MSIRDY))
 8013848:	6811      	ldr	r1, [r2, #0]
 801384a:	f011 0102 	ands.w	r1, r1, #2
 801384e:	f43f af20 	beq.w	8013692 <HAL_RCCEx_GetPeriphCLKFreq+0x22>
        pllvco = MSIRangeTable[(__HAL_RCC_GET_MSI_RANGE() >> 4U)];
 8013852:	6813      	ldr	r3, [r2, #0]
 8013854:	071b      	lsls	r3, r3, #28
 8013856:	bf4c      	ite	mi
 8013858:	6813      	ldrmi	r3, [r2, #0]
 801385a:	f8d2 3094 	ldrpl.w	r3, [r2, #148]	; 0x94
 801385e:	4a35      	ldr	r2, [pc, #212]	; (8013934 <HAL_RCCEx_GetPeriphCLKFreq+0x2c4>)
 8013860:	bf4c      	ite	mi
 8013862:	f3c3 1303 	ubfxmi	r3, r3, #4, #4
 8013866:	f3c3 2303 	ubfxpl	r3, r3, #8, #4
 801386a:	f852 1023 	ldr.w	r1, [r2, r3, lsl #2]
 801386e:	e710      	b.n	8013692 <HAL_RCCEx_GetPeriphCLKFreq+0x22>
      if(HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSERDY))
 8013870:	6811      	ldr	r1, [r2, #0]
        pllvco = HSE_VALUE;
 8013872:	4b31      	ldr	r3, [pc, #196]	; (8013938 <HAL_RCCEx_GetPeriphCLKFreq+0x2c8>)
 8013874:	f411 3100 	ands.w	r1, r1, #131072	; 0x20000
 8013878:	bf18      	it	ne
 801387a:	4619      	movne	r1, r3
 801387c:	e709      	b.n	8013692 <HAL_RCCEx_GetPeriphCLKFreq+0x22>
      if(HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY))
 801387e:	6811      	ldr	r1, [r2, #0]
        pllvco = HSI_VALUE;
 8013880:	4b2e      	ldr	r3, [pc, #184]	; (801393c <HAL_RCCEx_GetPeriphCLKFreq+0x2cc>)
 8013882:	f411 6180 	ands.w	r1, r1, #1024	; 0x400
 8013886:	bf18      	it	ne
 8013888:	4619      	movne	r1, r3
 801388a:	e702      	b.n	8013692 <HAL_RCCEx_GetPeriphCLKFreq+0x22>
 801388c:	f5b3 1f40 	cmp.w	r3, #3145728	; 0x300000
 8013890:	f47f af3e 	bne.w	8013710 <HAL_RCCEx_GetPeriphCLKFreq+0xa0>
          if(HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSERDY))
 8013894:	f8d2 0090 	ldr.w	r0, [r2, #144]	; 0x90
        frequency = LSE_VALUE;
 8013898:	f010 0002 	ands.w	r0, r0, #2
 801389c:	bf18      	it	ne
 801389e:	f44f 4000 	movne.w	r0, #32768	; 0x8000
 80138a2:	4770      	bx	lr
        srcclk = __HAL_RCC_GET_I2C3_SOURCE();
 80138a4:	4a22      	ldr	r2, [pc, #136]	; (8013930 <HAL_RCCEx_GetPeriphCLKFreq+0x2c0>)
 80138a6:	f8d2 3088 	ldr.w	r3, [r2, #136]	; 0x88
 80138aa:	f403 3340 	and.w	r3, r3, #196608	; 0x30000
        switch(srcclk)
 80138ae:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 80138b2:	f43f af56 	beq.w	8013762 <HAL_RCCEx_GetPeriphCLKFreq+0xf2>
 80138b6:	f5b3 3f00 	cmp.w	r3, #131072	; 0x20000
 80138ba:	f47f af3c 	bne.w	8013736 <HAL_RCCEx_GetPeriphCLKFreq+0xc6>
          if(HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY))
 80138be:	6810      	ldr	r0, [r2, #0]
            frequency = HSI_VALUE;
 80138c0:	4b1e      	ldr	r3, [pc, #120]	; (801393c <HAL_RCCEx_GetPeriphCLKFreq+0x2cc>)
 80138c2:	f410 6080 	ands.w	r0, r0, #1024	; 0x400
 80138c6:	bf18      	it	ne
 80138c8:	4618      	movne	r0, r3
 80138ca:	4770      	bx	lr
       srcclk = __HAL_RCC_GET_LPTIM2_SOURCE();
 80138cc:	4a18      	ldr	r2, [pc, #96]	; (8013930 <HAL_RCCEx_GetPeriphCLKFreq+0x2c0>)
 80138ce:	f8d2 3088 	ldr.w	r3, [r2, #136]	; 0x88
 80138d2:	f403 1340 	and.w	r3, r3, #3145728	; 0x300000
        switch(srcclk)
 80138d6:	f5b3 1f00 	cmp.w	r3, #2097152	; 0x200000
 80138da:	d0f0      	beq.n	80138be <HAL_RCCEx_GetPeriphCLKFreq+0x24e>
 80138dc:	d8d6      	bhi.n	801388c <HAL_RCCEx_GetPeriphCLKFreq+0x21c>
 80138de:	2b00      	cmp	r3, #0
 80138e0:	f43f af2b 	beq.w	801373a <HAL_RCCEx_GetPeriphCLKFreq+0xca>
 80138e4:	f5b3 1f80 	cmp.w	r3, #1048576	; 0x100000
 80138e8:	f47f af12 	bne.w	8013710 <HAL_RCCEx_GetPeriphCLKFreq+0xa0>
          if(HAL_IS_BIT_SET(RCC->CSR, RCC_CSR_LSIRDY))
 80138ec:	f8d2 0094 	ldr.w	r0, [r2, #148]	; 0x94
              frequency = LSI_VALUE;
 80138f0:	f010 0002 	ands.w	r0, r0, #2
 80138f4:	bf18      	it	ne
 80138f6:	f44f 40fa 	movne.w	r0, #32000	; 0x7d00
 80138fa:	4770      	bx	lr
      if(HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSERDY))
 80138fc:	6810      	ldr	r0, [r2, #0]
        frequency = HSE_VALUE / 32U;
 80138fe:	4b10      	ldr	r3, [pc, #64]	; (8013940 <HAL_RCCEx_GetPeriphCLKFreq+0x2d0>)
 8013900:	f410 3000 	ands.w	r0, r0, #131072	; 0x20000
 8013904:	bf18      	it	ne
 8013906:	4618      	movne	r0, r3
 8013908:	4770      	bx	lr
        srcclk = __HAL_RCC_GET_LPUART1_SOURCE();
 801390a:	4a09      	ldr	r2, [pc, #36]	; (8013930 <HAL_RCCEx_GetPeriphCLKFreq+0x2c0>)
 801390c:	f8d2 3088 	ldr.w	r3, [r2, #136]	; 0x88
 8013910:	f403 6340 	and.w	r3, r3, #3072	; 0xc00
        switch(srcclk)
 8013914:	f5b3 6f00 	cmp.w	r3, #2048	; 0x800
 8013918:	d0d1      	beq.n	80138be <HAL_RCCEx_GetPeriphCLKFreq+0x24e>
 801391a:	f200 80b4 	bhi.w	8013a86 <HAL_RCCEx_GetPeriphCLKFreq+0x416>
 801391e:	2b00      	cmp	r3, #0
 8013920:	f43f af0b 	beq.w	801373a <HAL_RCCEx_GetPeriphCLKFreq+0xca>
 8013924:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 8013928:	f43f af1b 	beq.w	8013762 <HAL_RCCEx_GetPeriphCLKFreq+0xf2>
 801392c:	e6f0      	b.n	8013710 <HAL_RCCEx_GetPeriphCLKFreq+0xa0>
 801392e:	bf00      	nop
 8013930:	40021000 	.word	0x40021000
 8013934:	0802d2e8 	.word	0x0802d2e8
 8013938:	007a1200 	.word	0x007a1200
 801393c:	00f42400 	.word	0x00f42400
 8013940:	0003d090 	.word	0x0003d090
        srcclk = __HAL_RCC_GET_USART1_SOURCE();
 8013944:	4a77      	ldr	r2, [pc, #476]	; (8013b24 <HAL_RCCEx_GetPeriphCLKFreq+0x4b4>)
 8013946:	f8d2 3088 	ldr.w	r3, [r2, #136]	; 0x88
 801394a:	f003 0303 	and.w	r3, r3, #3
        switch(srcclk)
 801394e:	2b02      	cmp	r3, #2
 8013950:	d0b5      	beq.n	80138be <HAL_RCCEx_GetPeriphCLKFreq+0x24e>
 8013952:	2b03      	cmp	r3, #3
 8013954:	d09e      	beq.n	8013894 <HAL_RCCEx_GetPeriphCLKFreq+0x224>
 8013956:	2b01      	cmp	r3, #1
 8013958:	f43f af03 	beq.w	8013762 <HAL_RCCEx_GetPeriphCLKFreq+0xf2>
          frequency = HAL_RCC_GetPCLK2Freq();
 801395c:	f7ff ba26 	b.w	8012dac <HAL_RCC_GetPCLK2Freq>
        srcclk = __HAL_RCC_GET_USART2_SOURCE();
 8013960:	4b70      	ldr	r3, [pc, #448]	; (8013b24 <HAL_RCCEx_GetPeriphCLKFreq+0x4b4>)
 8013962:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 8013966:	f003 030c 	and.w	r3, r3, #12
 801396a:	2b0c      	cmp	r3, #12
 801396c:	f63f aed0 	bhi.w	8013710 <HAL_RCCEx_GetPeriphCLKFreq+0xa0>
 8013970:	a201      	add	r2, pc, #4	; (adr r2, 8013978 <HAL_RCCEx_GetPeriphCLKFreq+0x308>)
 8013972:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8013976:	bf00      	nop
 8013978:	0801373b 	.word	0x0801373b
 801397c:	08013711 	.word	0x08013711
 8013980:	08013711 	.word	0x08013711
 8013984:	08013711 	.word	0x08013711
 8013988:	08013763 	.word	0x08013763
 801398c:	08013711 	.word	0x08013711
 8013990:	08013711 	.word	0x08013711
 8013994:	08013711 	.word	0x08013711
 8013998:	08013a77 	.word	0x08013a77
 801399c:	08013711 	.word	0x08013711
 80139a0:	08013711 	.word	0x08013711
 80139a4:	08013711 	.word	0x08013711
 80139a8:	08013a65 	.word	0x08013a65
        srcclk = __HAL_RCC_GET_USART3_SOURCE();
 80139ac:	4a5d      	ldr	r2, [pc, #372]	; (8013b24 <HAL_RCCEx_GetPeriphCLKFreq+0x4b4>)
 80139ae:	f8d2 3088 	ldr.w	r3, [r2, #136]	; 0x88
 80139b2:	f003 0330 	and.w	r3, r3, #48	; 0x30
        switch(srcclk)
 80139b6:	2b20      	cmp	r3, #32
 80139b8:	d081      	beq.n	80138be <HAL_RCCEx_GetPeriphCLKFreq+0x24e>
 80139ba:	d869      	bhi.n	8013a90 <HAL_RCCEx_GetPeriphCLKFreq+0x420>
 80139bc:	2b00      	cmp	r3, #0
 80139be:	f43f aebc 	beq.w	801373a <HAL_RCCEx_GetPeriphCLKFreq+0xca>
 80139c2:	2b10      	cmp	r3, #16
 80139c4:	f43f aecd 	beq.w	8013762 <HAL_RCCEx_GetPeriphCLKFreq+0xf2>
 80139c8:	e6a2      	b.n	8013710 <HAL_RCCEx_GetPeriphCLKFreq+0xa0>
        srcclk = __HAL_RCC_GET_UART4_SOURCE();
 80139ca:	4a56      	ldr	r2, [pc, #344]	; (8013b24 <HAL_RCCEx_GetPeriphCLKFreq+0x4b4>)
 80139cc:	f8d2 3088 	ldr.w	r3, [r2, #136]	; 0x88
 80139d0:	f003 03c0 	and.w	r3, r3, #192	; 0xc0
        switch(srcclk)
 80139d4:	2b80      	cmp	r3, #128	; 0x80
 80139d6:	f43f af72 	beq.w	80138be <HAL_RCCEx_GetPeriphCLKFreq+0x24e>
 80139da:	d85d      	bhi.n	8013a98 <HAL_RCCEx_GetPeriphCLKFreq+0x428>
 80139dc:	2b00      	cmp	r3, #0
 80139de:	f43f aeac 	beq.w	801373a <HAL_RCCEx_GetPeriphCLKFreq+0xca>
 80139e2:	2b40      	cmp	r3, #64	; 0x40
 80139e4:	f43f aebd 	beq.w	8013762 <HAL_RCCEx_GetPeriphCLKFreq+0xf2>
 80139e8:	e692      	b.n	8013710 <HAL_RCCEx_GetPeriphCLKFreq+0xa0>
        srcclk = __HAL_RCC_GET_UART5_SOURCE();
 80139ea:	4a4e      	ldr	r2, [pc, #312]	; (8013b24 <HAL_RCCEx_GetPeriphCLKFreq+0x4b4>)
 80139ec:	f8d2 3088 	ldr.w	r3, [r2, #136]	; 0x88
 80139f0:	f403 7340 	and.w	r3, r3, #768	; 0x300
        switch(srcclk)
 80139f4:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 80139f8:	f43f af61 	beq.w	80138be <HAL_RCCEx_GetPeriphCLKFreq+0x24e>
 80139fc:	d86b      	bhi.n	8013ad6 <HAL_RCCEx_GetPeriphCLKFreq+0x466>
 80139fe:	2b00      	cmp	r3, #0
 8013a00:	f43f ae9b 	beq.w	801373a <HAL_RCCEx_GetPeriphCLKFreq+0xca>
 8013a04:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 8013a08:	f43f aeab 	beq.w	8013762 <HAL_RCCEx_GetPeriphCLKFreq+0xf2>
 8013a0c:	e680      	b.n	8013710 <HAL_RCCEx_GetPeriphCLKFreq+0xa0>
          if(HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLLRDY))
 8013a0e:	6810      	ldr	r0, [r2, #0]
 8013a10:	f010 7000 	ands.w	r0, r0, #33554432	; 0x2000000
 8013a14:	f43f aeca 	beq.w	80137ac <HAL_RCCEx_GetPeriphCLKFreq+0x13c>
            if(HAL_IS_BIT_SET(RCC->PLLCFGR, RCC_PLLCFGR_PLLQEN))
 8013a18:	68d0      	ldr	r0, [r2, #12]
 8013a1a:	f410 1080 	ands.w	r0, r0, #1048576	; 0x100000
 8013a1e:	f43f aec5 	beq.w	80137ac <HAL_RCCEx_GetPeriphCLKFreq+0x13c>
              plln = READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos;
 8013a22:	68d0      	ldr	r0, [r2, #12]
              pllvco = ((pllvco * plln) / ((READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLM) >> RCC_PLLCFGR_PLLM_Pos) + 1U));
 8013a24:	68d4      	ldr	r4, [r2, #12]
              frequency = (pllvco / (((READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLQ) >> RCC_PLLCFGR_PLLQ_Pos) + 1U) << 1U));
 8013a26:	68d3      	ldr	r3, [r2, #12]
              frequency = (pllvco / (((READ_BIT(RCC->PLLSAI1CFGR, RCC_PLLSAI1CFGR_PLLSAI1Q) >> RCC_PLLSAI1CFGR_PLLSAI1Q_Pos) + 1U) << 1U));
 8013a28:	f3c3 5341 	ubfx	r3, r3, #21, #2
              plln = READ_BIT(RCC->PLLSAI1CFGR, RCC_PLLSAI1CFGR_PLLSAI1N) >> RCC_PLLSAI1CFGR_PLLSAI1N_Pos;
 8013a2c:	f3c0 2206 	ubfx	r2, r0, #8, #7
              frequency = (pllvco / (((READ_BIT(RCC->PLLSAI1CFGR, RCC_PLLSAI1CFGR_PLLSAI1Q) >> RCC_PLLSAI1CFGR_PLLSAI1Q_Pos) + 1U) << 1U));
 8013a30:	3301      	adds	r3, #1
              pllvco = ((pllvco * plln) / ((READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLM) >> RCC_PLLCFGR_PLLM_Pos) + 1U));
 8013a32:	f3c4 1002 	ubfx	r0, r4, #4, #3
 8013a36:	fb02 f101 	mul.w	r1, r2, r1
 8013a3a:	3001      	adds	r0, #1
              frequency = (pllvco / (((READ_BIT(RCC->PLLSAI1CFGR, RCC_PLLSAI1CFGR_PLLSAI1Q) >> RCC_PLLSAI1CFGR_PLLSAI1Q_Pos) + 1U) << 1U));
 8013a3c:	005b      	lsls	r3, r3, #1
              pllvco = ((pllvco * plln) / ((READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLM) >> RCC_PLLCFGR_PLLM_Pos) + 1U));
 8013a3e:	fbb1 f0f0 	udiv	r0, r1, r0
              frequency = (pllvco / (((READ_BIT(RCC->PLLSAI1CFGR, RCC_PLLSAI1CFGR_PLLSAI1Q) >> RCC_PLLSAI1CFGR_PLLSAI1Q_Pos) + 1U) << 1U));
 8013a42:	fbb0 f0f3 	udiv	r0, r0, r3
 8013a46:	e6b1      	b.n	80137ac <HAL_RCCEx_GetPeriphCLKFreq+0x13c>
          if(__HAL_RCC_GET_PLLSAI2CLKOUT_CONFIG(RCC_PLLSAI2_ADC2CLK) != 0U)
 8013a48:	6950      	ldr	r0, [r2, #20]
 8013a4a:	f010 7080 	ands.w	r0, r0, #16777216	; 0x1000000
 8013a4e:	f43f aefa 	beq.w	8013846 <HAL_RCCEx_GetPeriphCLKFreq+0x1d6>
            plln = READ_BIT(RCC->PLLSAI2CFGR, RCC_PLLSAI2CFGR_PLLSAI2N) >> RCC_PLLSAI2CFGR_PLLSAI2N_Pos;
 8013a52:	4b34      	ldr	r3, [pc, #208]	; (8013b24 <HAL_RCCEx_GetPeriphCLKFreq+0x4b4>)
 8013a54:	695a      	ldr	r2, [r3, #20]
            pllvco = ((pllvco * plln) / ((READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLM) >> RCC_PLLCFGR_PLLM_Pos) + 1U));
 8013a56:	68d8      	ldr	r0, [r3, #12]
            frequency = (pllvco / (((READ_BIT(RCC->PLLSAI2CFGR, RCC_PLLSAI2CFGR_PLLSAI2R) >> RCC_PLLSAI2CFGR_PLLSAI2R_Pos) + 1U) << 1U));
 8013a58:	695b      	ldr	r3, [r3, #20]
 8013a5a:	e6c7      	b.n	80137ec <HAL_RCCEx_GetPeriphCLKFreq+0x17c>
 8013a5c:	f5b3 2f40 	cmp.w	r3, #786432	; 0xc0000
 8013a60:	f47f ae56 	bne.w	8013710 <HAL_RCCEx_GetPeriphCLKFreq+0xa0>
          if(HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSERDY))
 8013a64:	4b2f      	ldr	r3, [pc, #188]	; (8013b24 <HAL_RCCEx_GetPeriphCLKFreq+0x4b4>)
 8013a66:	f8d3 0090 	ldr.w	r0, [r3, #144]	; 0x90
        frequency = LSE_VALUE;
 8013a6a:	f010 0002 	ands.w	r0, r0, #2
 8013a6e:	bf18      	it	ne
 8013a70:	f44f 4000 	movne.w	r0, #32768	; 0x8000
 8013a74:	4770      	bx	lr
          if(HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY))
 8013a76:	4a2b      	ldr	r2, [pc, #172]	; (8013b24 <HAL_RCCEx_GetPeriphCLKFreq+0x4b4>)
            frequency = HSI_VALUE;
 8013a78:	4b2b      	ldr	r3, [pc, #172]	; (8013b28 <HAL_RCCEx_GetPeriphCLKFreq+0x4b8>)
          if(HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY))
 8013a7a:	6810      	ldr	r0, [r2, #0]
            frequency = HSI_VALUE;
 8013a7c:	f410 6080 	ands.w	r0, r0, #1024	; 0x400
 8013a80:	bf18      	it	ne
 8013a82:	4618      	movne	r0, r3
 8013a84:	4770      	bx	lr
 8013a86:	f5b3 6f40 	cmp.w	r3, #3072	; 0xc00
 8013a8a:	f43f af03 	beq.w	8013894 <HAL_RCCEx_GetPeriphCLKFreq+0x224>
 8013a8e:	e63f      	b.n	8013710 <HAL_RCCEx_GetPeriphCLKFreq+0xa0>
 8013a90:	2b30      	cmp	r3, #48	; 0x30
 8013a92:	f43f aeff 	beq.w	8013894 <HAL_RCCEx_GetPeriphCLKFreq+0x224>
 8013a96:	e63b      	b.n	8013710 <HAL_RCCEx_GetPeriphCLKFreq+0xa0>
 8013a98:	2bc0      	cmp	r3, #192	; 0xc0
 8013a9a:	f43f aefb 	beq.w	8013894 <HAL_RCCEx_GetPeriphCLKFreq+0x224>
 8013a9e:	e637      	b.n	8013710 <HAL_RCCEx_GetPeriphCLKFreq+0xa0>
        srcclk = __HAL_RCC_GET_SWPMI1_SOURCE();
 8013aa0:	4b20      	ldr	r3, [pc, #128]	; (8013b24 <HAL_RCCEx_GetPeriphCLKFreq+0x4b4>)
 8013aa2:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
        switch(srcclk)
 8013aa6:	0052      	lsls	r2, r2, #1
 8013aa8:	f57f ae47 	bpl.w	801373a <HAL_RCCEx_GetPeriphCLKFreq+0xca>
          if(HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY))
 8013aac:	6818      	ldr	r0, [r3, #0]
            frequency = HSI_VALUE;
 8013aae:	4b1e      	ldr	r3, [pc, #120]	; (8013b28 <HAL_RCCEx_GetPeriphCLKFreq+0x4b8>)
 8013ab0:	f410 6080 	ands.w	r0, r0, #1024	; 0x400
 8013ab4:	bf18      	it	ne
 8013ab6:	4618      	movne	r0, r3
 8013ab8:	4770      	bx	lr
        srcclk = __HAL_RCC_GET_I2C1_SOURCE();
 8013aba:	4a1a      	ldr	r2, [pc, #104]	; (8013b24 <HAL_RCCEx_GetPeriphCLKFreq+0x4b4>)
 8013abc:	f8d2 3088 	ldr.w	r3, [r2, #136]	; 0x88
 8013ac0:	f403 5340 	and.w	r3, r3, #12288	; 0x3000
        switch(srcclk)
 8013ac4:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
 8013ac8:	f43f ae4b 	beq.w	8013762 <HAL_RCCEx_GetPeriphCLKFreq+0xf2>
 8013acc:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
 8013ad0:	f47f ae31 	bne.w	8013736 <HAL_RCCEx_GetPeriphCLKFreq+0xc6>
 8013ad4:	e6f3      	b.n	80138be <HAL_RCCEx_GetPeriphCLKFreq+0x24e>
 8013ad6:	f5b3 7f40 	cmp.w	r3, #768	; 0x300
 8013ada:	f43f aedb 	beq.w	8013894 <HAL_RCCEx_GetPeriphCLKFreq+0x224>
 8013ade:	e617      	b.n	8013710 <HAL_RCCEx_GetPeriphCLKFreq+0xa0>
          if(HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLLSAI1RDY))
 8013ae0:	6810      	ldr	r0, [r2, #0]
 8013ae2:	f010 6000 	ands.w	r0, r0, #134217728	; 0x8000000
 8013ae6:	f43f ae61 	beq.w	80137ac <HAL_RCCEx_GetPeriphCLKFreq+0x13c>
            if(HAL_IS_BIT_SET(RCC->PLLSAI1CFGR, RCC_PLLSAI1CFGR_PLLSAI1QEN))
 8013aea:	6910      	ldr	r0, [r2, #16]
 8013aec:	f410 1080 	ands.w	r0, r0, #1048576	; 0x100000
 8013af0:	f43f ae5c 	beq.w	80137ac <HAL_RCCEx_GetPeriphCLKFreq+0x13c>
              plln = READ_BIT(RCC->PLLSAI1CFGR, RCC_PLLSAI1CFGR_PLLSAI1N) >> RCC_PLLSAI1CFGR_PLLSAI1N_Pos;
 8013af4:	6910      	ldr	r0, [r2, #16]
              pllvco = ((pllvco * plln) / ((READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLM) >> RCC_PLLCFGR_PLLM_Pos) + 1U));
 8013af6:	68d4      	ldr	r4, [r2, #12]
              frequency = (pllvco / (((READ_BIT(RCC->PLLSAI1CFGR, RCC_PLLSAI1CFGR_PLLSAI1Q) >> RCC_PLLSAI1CFGR_PLLSAI1Q_Pos) + 1U) << 1U));
 8013af8:	6913      	ldr	r3, [r2, #16]
 8013afa:	e795      	b.n	8013a28 <HAL_RCCEx_GetPeriphCLKFreq+0x3b8>
          if(HAL_IS_BIT_SET(RCC->CR, RCC_CR_MSIRDY))
 8013afc:	6810      	ldr	r0, [r2, #0]
 8013afe:	f010 0002 	ands.w	r0, r0, #2
 8013b02:	f43f ae53 	beq.w	80137ac <HAL_RCCEx_GetPeriphCLKFreq+0x13c>
            frequency = MSIRangeTable[(__HAL_RCC_GET_MSI_RANGE() >> 4U)];
 8013b06:	6813      	ldr	r3, [r2, #0]
 8013b08:	0719      	lsls	r1, r3, #28
 8013b0a:	bf4c      	ite	mi
 8013b0c:	6813      	ldrmi	r3, [r2, #0]
 8013b0e:	f8d2 3094 	ldrpl.w	r3, [r2, #148]	; 0x94
 8013b12:	4a06      	ldr	r2, [pc, #24]	; (8013b2c <HAL_RCCEx_GetPeriphCLKFreq+0x4bc>)
 8013b14:	bf4c      	ite	mi
 8013b16:	f3c3 1303 	ubfxmi	r3, r3, #4, #4
 8013b1a:	f3c3 2303 	ubfxpl	r3, r3, #8, #4
 8013b1e:	f852 0023 	ldr.w	r0, [r2, r3, lsl #2]
 8013b22:	e643      	b.n	80137ac <HAL_RCCEx_GetPeriphCLKFreq+0x13c>
 8013b24:	40021000 	.word	0x40021000
 8013b28:	00f42400 	.word	0x00f42400
 8013b2c:	0802d2e8 	.word	0x0802d2e8

08013b30 <HAL_RCCEx_DisableLSECSS>:
  CLEAR_BIT(RCC->BDCR, RCC_BDCR_LSECSSON) ;
 8013b30:	4b05      	ldr	r3, [pc, #20]	; (8013b48 <HAL_RCCEx_DisableLSECSS+0x18>)
 8013b32:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
 8013b36:	f022 0220 	bic.w	r2, r2, #32
 8013b3a:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
  __HAL_RCC_DISABLE_IT(RCC_IT_LSECSS);
 8013b3e:	699a      	ldr	r2, [r3, #24]
 8013b40:	f422 7200 	bic.w	r2, r2, #512	; 0x200
 8013b44:	619a      	str	r2, [r3, #24]
}
 8013b46:	4770      	bx	lr
 8013b48:	40021000 	.word	0x40021000

08013b4c <HAL_RCCEx_EnableMSIPLLMode>:
  SET_BIT(RCC->CR, RCC_CR_MSIPLLEN) ;
 8013b4c:	4a02      	ldr	r2, [pc, #8]	; (8013b58 <HAL_RCCEx_EnableMSIPLLMode+0xc>)
 8013b4e:	6813      	ldr	r3, [r2, #0]
 8013b50:	f043 0304 	orr.w	r3, r3, #4
 8013b54:	6013      	str	r3, [r2, #0]
}
 8013b56:	4770      	bx	lr
 8013b58:	40021000 	.word	0x40021000

08013b5c <HAL_RTC_GetTime>:

  /* Check the parameters */
  assert_param(IS_RTC_FORMAT(Format));

  /* Get subseconds structure field from the corresponding register*/
  sTime->SubSeconds = (uint32_t)(hrtc->Instance->SSR);
 8013b5c:	6803      	ldr	r3, [r0, #0]
{
 8013b5e:	b510      	push	{r4, lr}
  sTime->SubSeconds = (uint32_t)(hrtc->Instance->SSR);
 8013b60:	6a9c      	ldr	r4, [r3, #40]	; 0x28

  /* Get SecondFraction structure field from the corresponding register field*/
  sTime->SecondFraction = (uint32_t)(hrtc->Instance->PRER & RTC_PRER_PREDIV_S);
 8013b62:	6918      	ldr	r0, [r3, #16]

  /* Get the TR register */
  tmpreg = (uint32_t)(hrtc->Instance->TR & RTC_TR_RESERVED_MASK);
 8013b64:	681b      	ldr	r3, [r3, #0]
  sTime->SecondFraction = (uint32_t)(hrtc->Instance->PRER & RTC_PRER_PREDIV_S);
 8013b66:	f3c0 000e 	ubfx	r0, r0, #0, #15
 8013b6a:	e9c1 4001 	strd	r4, r0, [r1, #4]

  /* Fill the structure fields with the read parameters */
  sTime->Hours = (uint8_t)((tmpreg & (RTC_TR_HT | RTC_TR_HU)) >> RTC_TR_HU_Pos);
 8013b6e:	f3c3 4e05 	ubfx	lr, r3, #16, #6
  sTime->Minutes = (uint8_t)((tmpreg & (RTC_TR_MNT | RTC_TR_MNU)) >> RTC_TR_MNU_Pos);
 8013b72:	f3c3 2c06 	ubfx	ip, r3, #8, #7
  sTime->Seconds = (uint8_t)((tmpreg & (RTC_TR_ST | RTC_TR_SU)) >> RTC_TR_SU_Pos);
 8013b76:	f003 007f 	and.w	r0, r3, #127	; 0x7f
  sTime->Hours = (uint8_t)((tmpreg & (RTC_TR_HT | RTC_TR_HU)) >> RTC_TR_HU_Pos);
 8013b7a:	f3c3 4406 	ubfx	r4, r3, #16, #7
  sTime->TimeFormat = (uint8_t)((tmpreg & (RTC_TR_PM)) >> RTC_TR_PM_Pos);
 8013b7e:	f3c3 5380 	ubfx	r3, r3, #22, #1
  sTime->Hours = (uint8_t)((tmpreg & (RTC_TR_HT | RTC_TR_HU)) >> RTC_TR_HU_Pos);
 8013b82:	f881 e000 	strb.w	lr, [r1]
  sTime->Minutes = (uint8_t)((tmpreg & (RTC_TR_MNT | RTC_TR_MNU)) >> RTC_TR_MNU_Pos);
 8013b86:	f881 c001 	strb.w	ip, [r1, #1]
  sTime->TimeFormat = (uint8_t)((tmpreg & (RTC_TR_PM)) >> RTC_TR_PM_Pos);
 8013b8a:	70cb      	strb	r3, [r1, #3]
  sTime->Seconds = (uint8_t)((tmpreg & (RTC_TR_ST | RTC_TR_SU)) >> RTC_TR_SU_Pos);
 8013b8c:	7088      	strb	r0, [r1, #2]

  /* Check the input parameters format */
  if (Format == RTC_FORMAT_BIN)
 8013b8e:	b9da      	cbnz	r2, 8013bc8 <HAL_RTC_GetTime+0x6c>
  * @retval Converted word
  */
uint8_t RTC_Bcd2ToByte(uint8_t Value)
{
  uint8_t tmp;
  tmp = ((Value & 0xF0U) >> 4U) * 10U;
 8013b90:	ea4f 131c 	mov.w	r3, ip, lsr #4
 8013b94:	eb03 0383 	add.w	r3, r3, r3, lsl #2
  return (tmp + (Value & 0x0FU));
 8013b98:	f00c 0c0f 	and.w	ip, ip, #15
 8013b9c:	eb0c 0c43 	add.w	ip, ip, r3, lsl #1
  tmp = ((Value & 0xF0U) >> 4U) * 10U;
 8013ba0:	ea4f 1e1e 	mov.w	lr, lr, lsr #4
 8013ba4:	0903      	lsrs	r3, r0, #4
 8013ba6:	eb0e 0e8e 	add.w	lr, lr, lr, lsl #2
  return (tmp + (Value & 0x0FU));
 8013baa:	f004 040f 	and.w	r4, r4, #15
  tmp = ((Value & 0xF0U) >> 4U) * 10U;
 8013bae:	eb03 0383 	add.w	r3, r3, r3, lsl #2
  return (tmp + (Value & 0x0FU));
 8013bb2:	f000 000f 	and.w	r0, r0, #15
 8013bb6:	eb04 0e4e 	add.w	lr, r4, lr, lsl #1
 8013bba:	eb00 0043 	add.w	r0, r0, r3, lsl #1
    sTime->Hours = (uint8_t)RTC_Bcd2ToByte(sTime->Hours);
 8013bbe:	f881 e000 	strb.w	lr, [r1]
    sTime->Minutes = (uint8_t)RTC_Bcd2ToByte(sTime->Minutes);
 8013bc2:	f881 c001 	strb.w	ip, [r1, #1]
    sTime->Seconds = (uint8_t)RTC_Bcd2ToByte(sTime->Seconds);
 8013bc6:	7088      	strb	r0, [r1, #2]
}
 8013bc8:	2000      	movs	r0, #0
 8013bca:	bd10      	pop	{r4, pc}

08013bcc <HAL_RTC_GetDate>:
  datetmpreg = (uint32_t)(hrtc->Instance->DR & RTC_DR_RESERVED_MASK);
 8013bcc:	6803      	ldr	r3, [r0, #0]
 8013bce:	685b      	ldr	r3, [r3, #4]
{
 8013bd0:	b510      	push	{r4, lr}
  sDate->Year = (uint8_t)((datetmpreg & (RTC_DR_YT | RTC_DR_YU)) >> RTC_DR_YU_Pos);
 8013bd2:	f3c3 4007 	ubfx	r0, r3, #16, #8
  sDate->Month = (uint8_t)((datetmpreg & (RTC_DR_MT | RTC_DR_MU)) >> RTC_DR_MU_Pos);
 8013bd6:	f3c3 2e04 	ubfx	lr, r3, #8, #5
  sDate->Date = (uint8_t)((datetmpreg & (RTC_DR_DT | RTC_DR_DU)) >> RTC_DR_DU_Pos);
 8013bda:	f003 0c3f 	and.w	ip, r3, #63	; 0x3f
  sDate->Month = (uint8_t)((datetmpreg & (RTC_DR_MT | RTC_DR_MU)) >> RTC_DR_MU_Pos);
 8013bde:	f3c3 2407 	ubfx	r4, r3, #8, #8
  sDate->WeekDay = (uint8_t)((datetmpreg & (RTC_DR_WDU)) >> RTC_DR_WDU_Pos);
 8013be2:	f3c3 3342 	ubfx	r3, r3, #13, #3
  sDate->Year = (uint8_t)((datetmpreg & (RTC_DR_YT | RTC_DR_YU)) >> RTC_DR_YU_Pos);
 8013be6:	70c8      	strb	r0, [r1, #3]
  sDate->Month = (uint8_t)((datetmpreg & (RTC_DR_MT | RTC_DR_MU)) >> RTC_DR_MU_Pos);
 8013be8:	f881 e001 	strb.w	lr, [r1, #1]
  sDate->WeekDay = (uint8_t)((datetmpreg & (RTC_DR_WDU)) >> RTC_DR_WDU_Pos);
 8013bec:	700b      	strb	r3, [r1, #0]
  sDate->Date = (uint8_t)((datetmpreg & (RTC_DR_DT | RTC_DR_DU)) >> RTC_DR_DU_Pos);
 8013bee:	f881 c002 	strb.w	ip, [r1, #2]
  if (Format == RTC_FORMAT_BIN)
 8013bf2:	b9da      	cbnz	r2, 8013c2c <HAL_RTC_GetDate+0x60>
  tmp = ((Value & 0xF0U) >> 4U) * 10U;
 8013bf4:	ea4f 131c 	mov.w	r3, ip, lsr #4
 8013bf8:	eb03 0383 	add.w	r3, r3, r3, lsl #2
  return (tmp + (Value & 0x0FU));
 8013bfc:	f00c 0c0f 	and.w	ip, ip, #15
 8013c00:	eb0c 0c43 	add.w	ip, ip, r3, lsl #1
  tmp = ((Value & 0xF0U) >> 4U) * 10U;
 8013c04:	ea4f 1e1e 	mov.w	lr, lr, lsr #4
 8013c08:	0903      	lsrs	r3, r0, #4
 8013c0a:	eb0e 0e8e 	add.w	lr, lr, lr, lsl #2
  return (tmp + (Value & 0x0FU));
 8013c0e:	f004 040f 	and.w	r4, r4, #15
  tmp = ((Value & 0xF0U) >> 4U) * 10U;
 8013c12:	eb03 0383 	add.w	r3, r3, r3, lsl #2
  return (tmp + (Value & 0x0FU));
 8013c16:	f000 000f 	and.w	r0, r0, #15
 8013c1a:	eb04 0e4e 	add.w	lr, r4, lr, lsl #1
 8013c1e:	eb00 0043 	add.w	r0, r0, r3, lsl #1
    sDate->Month = (uint8_t)RTC_Bcd2ToByte(sDate->Month);
 8013c22:	f881 e001 	strb.w	lr, [r1, #1]
    sDate->Date = (uint8_t)RTC_Bcd2ToByte(sDate->Date);
 8013c26:	f881 c002 	strb.w	ip, [r1, #2]
    sDate->Year = (uint8_t)RTC_Bcd2ToByte(sDate->Year);
 8013c2a:	70c8      	strb	r0, [r1, #3]
}
 8013c2c:	2000      	movs	r0, #0
 8013c2e:	bd10      	pop	{r4, pc}

08013c30 <RTC_EnterInitMode>:
{
 8013c30:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  if ((hrtc->Instance->ISR & RTC_ISR_INITF) == 0U)
 8013c32:	6803      	ldr	r3, [r0, #0]
 8013c34:	68dc      	ldr	r4, [r3, #12]
 8013c36:	f014 0440 	ands.w	r4, r4, #64	; 0x40
 8013c3a:	d002      	beq.n	8013c42 <RTC_EnterInitMode+0x12>
  HAL_StatusTypeDef status = HAL_OK;
 8013c3c:	2400      	movs	r4, #0
}
 8013c3e:	4620      	mov	r0, r4
 8013c40:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    hrtc->Instance->ISR = (uint32_t)RTC_INIT_MASK;
 8013c42:	f04f 32ff 	mov.w	r2, #4294967295
 8013c46:	60da      	str	r2, [r3, #12]
 8013c48:	4605      	mov	r5, r0
    tickstart = HAL_GetTick();
 8013c4a:	f7fb fdf5 	bl	800f838 <HAL_GetTick>
        hrtc->State = HAL_RTC_STATE_TIMEOUT;
 8013c4e:	2703      	movs	r7, #3
    tickstart = HAL_GetTick();
 8013c50:	4606      	mov	r6, r0
    while ((READ_BIT(hrtc->Instance->ISR, RTC_ISR_INITF) == 0U) && (status != HAL_TIMEOUT))
 8013c52:	e00a      	b.n	8013c6a <RTC_EnterInitMode+0x3a>
 8013c54:	2c03      	cmp	r4, #3
 8013c56:	d0f2      	beq.n	8013c3e <RTC_EnterInitMode+0xe>
      if ((HAL_GetTick()  - tickstart) > RTC_TIMEOUT_VALUE)
 8013c58:	f7fb fdee 	bl	800f838 <HAL_GetTick>
 8013c5c:	1b83      	subs	r3, r0, r6
 8013c5e:	f5b3 7f7a 	cmp.w	r3, #1000	; 0x3e8
        hrtc->State = HAL_RTC_STATE_TIMEOUT;
 8013c62:	bf84      	itt	hi
 8013c64:	f885 7021 	strbhi.w	r7, [r5, #33]	; 0x21
        status = HAL_TIMEOUT;
 8013c68:	2403      	movhi	r4, #3
    while ((READ_BIT(hrtc->Instance->ISR, RTC_ISR_INITF) == 0U) && (status != HAL_TIMEOUT))
 8013c6a:	682b      	ldr	r3, [r5, #0]
 8013c6c:	68db      	ldr	r3, [r3, #12]
 8013c6e:	065b      	lsls	r3, r3, #25
 8013c70:	d5f0      	bpl.n	8013c54 <RTC_EnterInitMode+0x24>
}
 8013c72:	4620      	mov	r0, r4
 8013c74:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8013c76:	bf00      	nop

08013c78 <RTC_ExitInitMode>:
{
 8013c78:	b538      	push	{r3, r4, r5, lr}
  CLEAR_BIT(RTC->ISR, RTC_ISR_INIT);
 8013c7a:	4b22      	ldr	r3, [pc, #136]	; (8013d04 <RTC_ExitInitMode+0x8c>)
 8013c7c:	68da      	ldr	r2, [r3, #12]
 8013c7e:	f022 0280 	bic.w	r2, r2, #128	; 0x80
 8013c82:	60da      	str	r2, [r3, #12]
  if (READ_BIT(RTC->CR, RTC_CR_BYPSHAD) == 0U)
 8013c84:	689a      	ldr	r2, [r3, #8]
 8013c86:	0691      	lsls	r1, r2, #26
{
 8013c88:	4604      	mov	r4, r0
  if (READ_BIT(RTC->CR, RTC_CR_BYPSHAD) == 0U)
 8013c8a:	d414      	bmi.n	8013cb6 <RTC_ExitInitMode+0x3e>
  hrtc->Instance->ISR &= (uint32_t)RTC_RSF_MASK;
 8013c8c:	6802      	ldr	r2, [r0, #0]
 8013c8e:	68d3      	ldr	r3, [r2, #12]
 8013c90:	f023 03a0 	bic.w	r3, r3, #160	; 0xa0
 8013c94:	60d3      	str	r3, [r2, #12]
  tickstart = HAL_GetTick();
 8013c96:	f7fb fdcf 	bl	800f838 <HAL_GetTick>
 8013c9a:	4605      	mov	r5, r0
  while ((hrtc->Instance->ISR & RTC_ISR_RSF) == 0U)
 8013c9c:	e005      	b.n	8013caa <RTC_ExitInitMode+0x32>
    if ((HAL_GetTick() - tickstart) > RTC_TIMEOUT_VALUE)
 8013c9e:	f7fb fdcb 	bl	800f838 <HAL_GetTick>
 8013ca2:	1b43      	subs	r3, r0, r5
 8013ca4:	f5b3 7f7a 	cmp.w	r3, #1000	; 0x3e8
 8013ca8:	d827      	bhi.n	8013cfa <RTC_ExitInitMode+0x82>
  while ((hrtc->Instance->ISR & RTC_ISR_RSF) == 0U)
 8013caa:	6823      	ldr	r3, [r4, #0]
 8013cac:	68db      	ldr	r3, [r3, #12]
 8013cae:	069a      	lsls	r2, r3, #26
 8013cb0:	d5f5      	bpl.n	8013c9e <RTC_ExitInitMode+0x26>
  HAL_StatusTypeDef status = HAL_OK;
 8013cb2:	2000      	movs	r0, #0
}
 8013cb4:	bd38      	pop	{r3, r4, r5, pc}
    CLEAR_BIT(RTC->CR, RTC_CR_BYPSHAD);
 8013cb6:	689a      	ldr	r2, [r3, #8]
  hrtc->Instance->ISR &= (uint32_t)RTC_RSF_MASK;
 8013cb8:	6801      	ldr	r1, [r0, #0]
    CLEAR_BIT(RTC->CR, RTC_CR_BYPSHAD);
 8013cba:	f022 0220 	bic.w	r2, r2, #32
 8013cbe:	609a      	str	r2, [r3, #8]
  hrtc->Instance->ISR &= (uint32_t)RTC_RSF_MASK;
 8013cc0:	68cb      	ldr	r3, [r1, #12]
 8013cc2:	f023 03a0 	bic.w	r3, r3, #160	; 0xa0
 8013cc6:	60cb      	str	r3, [r1, #12]
  tickstart = HAL_GetTick();
 8013cc8:	f7fb fdb6 	bl	800f838 <HAL_GetTick>
 8013ccc:	4605      	mov	r5, r0
  while ((hrtc->Instance->ISR & RTC_ISR_RSF) == 0U)
 8013cce:	e005      	b.n	8013cdc <RTC_ExitInitMode+0x64>
    if ((HAL_GetTick() - tickstart) > RTC_TIMEOUT_VALUE)
 8013cd0:	f7fb fdb2 	bl	800f838 <HAL_GetTick>
 8013cd4:	1b43      	subs	r3, r0, r5
 8013cd6:	f5b3 7f7a 	cmp.w	r3, #1000	; 0x3e8
 8013cda:	d80a      	bhi.n	8013cf2 <RTC_ExitInitMode+0x7a>
  while ((hrtc->Instance->ISR & RTC_ISR_RSF) == 0U)
 8013cdc:	6823      	ldr	r3, [r4, #0]
 8013cde:	68db      	ldr	r3, [r3, #12]
 8013ce0:	069b      	lsls	r3, r3, #26
 8013ce2:	d5f5      	bpl.n	8013cd0 <RTC_ExitInitMode+0x58>
  HAL_StatusTypeDef status = HAL_OK;
 8013ce4:	2000      	movs	r0, #0
    SET_BIT(RTC->CR, RTC_CR_BYPSHAD);
 8013ce6:	4a07      	ldr	r2, [pc, #28]	; (8013d04 <RTC_ExitInitMode+0x8c>)
 8013ce8:	6893      	ldr	r3, [r2, #8]
 8013cea:	f043 0320 	orr.w	r3, r3, #32
 8013cee:	6093      	str	r3, [r2, #8]
}
 8013cf0:	bd38      	pop	{r3, r4, r5, pc}
      hrtc->State = HAL_RTC_STATE_TIMEOUT;
 8013cf2:	2003      	movs	r0, #3
 8013cf4:	f884 0021 	strb.w	r0, [r4, #33]	; 0x21
      status = HAL_TIMEOUT;
 8013cf8:	e7f5      	b.n	8013ce6 <RTC_ExitInitMode+0x6e>
      hrtc->State = HAL_RTC_STATE_TIMEOUT;
 8013cfa:	2003      	movs	r0, #3
 8013cfc:	f884 0021 	strb.w	r0, [r4, #33]	; 0x21
}
 8013d00:	bd38      	pop	{r3, r4, r5, pc}
 8013d02:	bf00      	nop
 8013d04:	40002800 	.word	0x40002800

08013d08 <HAL_RTC_Init>:
  if (hrtc != NULL)
 8013d08:	2800      	cmp	r0, #0
 8013d0a:	d045      	beq.n	8013d98 <HAL_RTC_Init+0x90>
{
 8013d0c:	b538      	push	{r3, r4, r5, lr}
    if (hrtc->State == HAL_RTC_STATE_RESET)
 8013d0e:	f890 3021 	ldrb.w	r3, [r0, #33]	; 0x21
 8013d12:	4604      	mov	r4, r0
 8013d14:	f003 02ff 	and.w	r2, r3, #255	; 0xff
 8013d18:	2b00      	cmp	r3, #0
 8013d1a:	d038      	beq.n	8013d8e <HAL_RTC_Init+0x86>
    __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
 8013d1c:	6823      	ldr	r3, [r4, #0]
    hrtc->State = HAL_RTC_STATE_BUSY;
 8013d1e:	2002      	movs	r0, #2
    __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
 8013d20:	21ca      	movs	r1, #202	; 0xca
 8013d22:	2253      	movs	r2, #83	; 0x53
    hrtc->State = HAL_RTC_STATE_BUSY;
 8013d24:	f884 0021 	strb.w	r0, [r4, #33]	; 0x21
    __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
 8013d28:	6259      	str	r1, [r3, #36]	; 0x24
    status = RTC_EnterInitMode(hrtc);
 8013d2a:	4620      	mov	r0, r4
    __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
 8013d2c:	625a      	str	r2, [r3, #36]	; 0x24
    status = RTC_EnterInitMode(hrtc);
 8013d2e:	f7ff ff7f 	bl	8013c30 <RTC_EnterInitMode>
    if (status == HAL_OK)
 8013d32:	b100      	cbz	r0, 8013d36 <HAL_RTC_Init+0x2e>
}
 8013d34:	bd38      	pop	{r3, r4, r5, pc}
      hrtc->Instance->CR |= (hrtc->Init.HourFormat | hrtc->Init.OutPut | hrtc->Init.OutPutPolarity);
 8013d36:	e9d4 3200 	ldrd	r3, r2, [r4]
      hrtc->Instance->CR &= ~(RTC_CR_FMT | RTC_CR_OSEL | RTC_CR_POL);
 8013d3a:	6899      	ldr	r1, [r3, #8]
      hrtc->Instance->CR |= (hrtc->Init.HourFormat | hrtc->Init.OutPut | hrtc->Init.OutPutPolarity);
 8013d3c:	6925      	ldr	r5, [r4, #16]
      hrtc->Instance->CR &= ~(RTC_CR_FMT | RTC_CR_OSEL | RTC_CR_POL);
 8013d3e:	f421 01e0 	bic.w	r1, r1, #7340032	; 0x700000
 8013d42:	f021 0140 	bic.w	r1, r1, #64	; 0x40
 8013d46:	6099      	str	r1, [r3, #8]
      hrtc->Instance->CR |= (hrtc->Init.HourFormat | hrtc->Init.OutPut | hrtc->Init.OutPutPolarity);
 8013d48:	69a1      	ldr	r1, [r4, #24]
 8013d4a:	6898      	ldr	r0, [r3, #8]
 8013d4c:	432a      	orrs	r2, r5
 8013d4e:	430a      	orrs	r2, r1
 8013d50:	4302      	orrs	r2, r0
      hrtc->Instance->PRER = (hrtc->Init.SynchPrediv);
 8013d52:	68e1      	ldr	r1, [r4, #12]
      hrtc->Instance->CR |= (hrtc->Init.HourFormat | hrtc->Init.OutPut | hrtc->Init.OutPutPolarity);
 8013d54:	609a      	str	r2, [r3, #8]
      hrtc->Instance->PRER = (hrtc->Init.SynchPrediv);
 8013d56:	6119      	str	r1, [r3, #16]
      hrtc->Instance->PRER |= (hrtc->Init.AsynchPrediv << RTC_PRER_PREDIV_A_Pos);
 8013d58:	691a      	ldr	r2, [r3, #16]
 8013d5a:	68a1      	ldr	r1, [r4, #8]
 8013d5c:	ea42 4201 	orr.w	r2, r2, r1, lsl #16
      status = RTC_ExitInitMode(hrtc);
 8013d60:	4620      	mov	r0, r4
      hrtc->Instance->PRER |= (hrtc->Init.AsynchPrediv << RTC_PRER_PREDIV_A_Pos);
 8013d62:	611a      	str	r2, [r3, #16]
      status = RTC_ExitInitMode(hrtc);
 8013d64:	f7ff ff88 	bl	8013c78 <RTC_ExitInitMode>
      if (status == HAL_OK)
 8013d68:	2800      	cmp	r0, #0
 8013d6a:	d1e3      	bne.n	8013d34 <HAL_RTC_Init+0x2c>
        hrtc->Instance->OR &= ~(RTC_OR_ALARMOUTTYPE | RTC_OR_OUT_RMP);
 8013d6c:	6823      	ldr	r3, [r4, #0]
        hrtc->Instance->OR |= (hrtc->Init.OutPutType | hrtc->Init.OutPutRemap);
 8013d6e:	69e2      	ldr	r2, [r4, #28]
        hrtc->Instance->OR &= ~(RTC_OR_ALARMOUTTYPE | RTC_OR_OUT_RMP);
 8013d70:	6cd9      	ldr	r1, [r3, #76]	; 0x4c
        hrtc->Instance->OR |= (hrtc->Init.OutPutType | hrtc->Init.OutPutRemap);
 8013d72:	6965      	ldr	r5, [r4, #20]
        hrtc->Instance->OR &= ~(RTC_OR_ALARMOUTTYPE | RTC_OR_OUT_RMP);
 8013d74:	f021 0103 	bic.w	r1, r1, #3
 8013d78:	64d9      	str	r1, [r3, #76]	; 0x4c
        hrtc->Instance->OR |= (hrtc->Init.OutPutType | hrtc->Init.OutPutRemap);
 8013d7a:	6cd9      	ldr	r1, [r3, #76]	; 0x4c
 8013d7c:	432a      	orrs	r2, r5
 8013d7e:	430a      	orrs	r2, r1
        __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 8013d80:	21ff      	movs	r1, #255	; 0xff
        hrtc->Instance->OR |= (hrtc->Init.OutPutType | hrtc->Init.OutPutRemap);
 8013d82:	64da      	str	r2, [r3, #76]	; 0x4c
        __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 8013d84:	6259      	str	r1, [r3, #36]	; 0x24
          hrtc->State = HAL_RTC_STATE_READY;
 8013d86:	2301      	movs	r3, #1
 8013d88:	f884 3021 	strb.w	r3, [r4, #33]	; 0x21
}
 8013d8c:	bd38      	pop	{r3, r4, r5, pc}
      hrtc->Lock = HAL_UNLOCKED;
 8013d8e:	f880 2020 	strb.w	r2, [r0, #32]
      HAL_RTC_MspInit(hrtc);
 8013d92:	f010 fe9b 	bl	8024acc <HAL_RTC_MspInit>
 8013d96:	e7c1      	b.n	8013d1c <HAL_RTC_Init+0x14>
  HAL_StatusTypeDef status = HAL_ERROR;
 8013d98:	2001      	movs	r0, #1
}
 8013d9a:	4770      	bx	lr

08013d9c <HAL_RTC_SetTime>:
  __HAL_LOCK(hrtc);
 8013d9c:	f890 c020 	ldrb.w	ip, [r0, #32]
 8013da0:	f1bc 0f01 	cmp.w	ip, #1
 8013da4:	d05b      	beq.n	8013e5e <HAL_RTC_SetTime+0xc2>
 8013da6:	2301      	movs	r3, #1
{
 8013da8:	b570      	push	{r4, r5, r6, lr}
  __HAL_LOCK(hrtc);
 8013daa:	f880 3020 	strb.w	r3, [r0, #32]
  hrtc->State = HAL_RTC_STATE_BUSY;
 8013dae:	2302      	movs	r3, #2
 8013db0:	f880 3021 	strb.w	r3, [r0, #33]	; 0x21
  __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
 8013db4:	6803      	ldr	r3, [r0, #0]
 8013db6:	4616      	mov	r6, r2
 8013db8:	22ca      	movs	r2, #202	; 0xca
 8013dba:	625a      	str	r2, [r3, #36]	; 0x24
 8013dbc:	2253      	movs	r2, #83	; 0x53
 8013dbe:	625a      	str	r2, [r3, #36]	; 0x24
  status = RTC_EnterInitMode(hrtc);
 8013dc0:	4604      	mov	r4, r0
 8013dc2:	460d      	mov	r5, r1
 8013dc4:	f7ff ff34 	bl	8013c30 <RTC_EnterInitMode>
  if (status == HAL_OK)
 8013dc8:	b130      	cbz	r0, 8013dd8 <HAL_RTC_SetTime+0x3c>
  __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 8013dca:	6823      	ldr	r3, [r4, #0]
 8013dcc:	22ff      	movs	r2, #255	; 0xff
 8013dce:	625a      	str	r2, [r3, #36]	; 0x24
  __HAL_UNLOCK(hrtc);
 8013dd0:	2300      	movs	r3, #0
 8013dd2:	f884 3020 	strb.w	r3, [r4, #32]
}
 8013dd6:	bd70      	pop	{r4, r5, r6, pc}
      if ((hrtc->Instance->CR & RTC_CR_FMT) != 0U)
 8013dd8:	6821      	ldr	r1, [r4, #0]
    if (Format == RTC_FORMAT_BIN)
 8013dda:	2e00      	cmp	r6, #0
 8013ddc:	d141      	bne.n	8013e62 <HAL_RTC_SetTime+0xc6>
      if ((hrtc->Instance->CR & RTC_CR_FMT) != 0U)
 8013dde:	688b      	ldr	r3, [r1, #8]
 8013de0:	f013 0e40 	ands.w	lr, r3, #64	; 0x40
                          (((uint32_t)sTime->TimeFormat) << RTC_TR_PM_Pos));
 8013de4:	bf16      	itet	ne
 8013de6:	78eb      	ldrbne	r3, [r5, #3]
        sTime->TimeFormat = 0x00U;
 8013de8:	f885 e003 	strbeq.w	lr, [r5, #3]
                          (((uint32_t)sTime->TimeFormat) << RTC_TR_PM_Pos));
 8013dec:	ea4f 5e83 	movne.w	lr, r3, lsl #22
      tmpreg = (uint32_t)(((uint32_t)RTC_ByteToBcd2(sTime->Hours) << RTC_TR_HU_Pos) | \
 8013df0:	782b      	ldrb	r3, [r5, #0]
  while (temp >= 10U)
 8013df2:	2b09      	cmp	r3, #9
 8013df4:	d909      	bls.n	8013e0a <HAL_RTC_SetTime+0x6e>
  uint32_t bcdhigh = 0U;
 8013df6:	2000      	movs	r0, #0
    temp -= 10U;
 8013df8:	3b0a      	subs	r3, #10
 8013dfa:	b2db      	uxtb	r3, r3
  while (temp >= 10U)
 8013dfc:	2b09      	cmp	r3, #9
    bcdhigh++;
 8013dfe:	f100 0001 	add.w	r0, r0, #1
  while (temp >= 10U)
 8013e02:	d8f9      	bhi.n	8013df8 <HAL_RTC_SetTime+0x5c>
  return ((uint8_t)(bcdhigh << 4U) | temp);
 8013e04:	ea43 1000 	orr.w	r0, r3, r0, lsl #4
 8013e08:	b2c3      	uxtb	r3, r0
                          ((uint32_t)RTC_ByteToBcd2(sTime->Minutes) << RTC_TR_MNU_Pos) | \
 8013e0a:	f895 c001 	ldrb.w	ip, [r5, #1]
  while (temp >= 10U)
 8013e0e:	f1bc 0f09 	cmp.w	ip, #9
      tmpreg = (uint32_t)(((uint32_t)RTC_ByteToBcd2(sTime->Hours) << RTC_TR_HU_Pos) | \
 8013e12:	ea4f 4003 	mov.w	r0, r3, lsl #16
  while (temp >= 10U)
 8013e16:	d90d      	bls.n	8013e34 <HAL_RTC_SetTime+0x98>
  uint32_t bcdhigh = 0U;
 8013e18:	2300      	movs	r3, #0
    temp -= 10U;
 8013e1a:	f1ac 0c0a 	sub.w	ip, ip, #10
 8013e1e:	fa5f fc8c 	uxtb.w	ip, ip
  while (temp >= 10U)
 8013e22:	f1bc 0f09 	cmp.w	ip, #9
    bcdhigh++;
 8013e26:	f103 0301 	add.w	r3, r3, #1
  while (temp >= 10U)
 8013e2a:	d8f6      	bhi.n	8013e1a <HAL_RTC_SetTime+0x7e>
  return ((uint8_t)(bcdhigh << 4U) | temp);
 8013e2c:	ea4c 1c03 	orr.w	ip, ip, r3, lsl #4
 8013e30:	fa5f fc8c 	uxtb.w	ip, ip
                          ((uint32_t)RTC_ByteToBcd2(sTime->Seconds) << RTC_TR_SU_Pos) | \
 8013e34:	78aa      	ldrb	r2, [r5, #2]
  while (temp >= 10U)
 8013e36:	2a09      	cmp	r2, #9
                          ((uint32_t)RTC_ByteToBcd2(sTime->Minutes) << RTC_TR_MNU_Pos) | \
 8013e38:	ea4f 2c0c 	mov.w	ip, ip, lsl #8
  while (temp >= 10U)
 8013e3c:	d909      	bls.n	8013e52 <HAL_RTC_SetTime+0xb6>
    temp -= 10U;
 8013e3e:	f1a2 030a 	sub.w	r3, r2, #10
 8013e42:	b2da      	uxtb	r2, r3
  while (temp >= 10U)
 8013e44:	2a09      	cmp	r2, #9
    bcdhigh++;
 8013e46:	f106 0601 	add.w	r6, r6, #1
  while (temp >= 10U)
 8013e4a:	d8f8      	bhi.n	8013e3e <HAL_RTC_SetTime+0xa2>
  return ((uint8_t)(bcdhigh << 4U) | temp);
 8013e4c:	ea42 1306 	orr.w	r3, r2, r6, lsl #4
 8013e50:	b2da      	uxtb	r2, r3
      tmpreg = (uint32_t)(((uint32_t)RTC_ByteToBcd2(sTime->Hours) << RTC_TR_HU_Pos) | \
 8013e52:	ea40 030e 	orr.w	r3, r0, lr
 8013e56:	ea43 030c 	orr.w	r3, r3, ip
 8013e5a:	4313      	orrs	r3, r2
 8013e5c:	e010      	b.n	8013e80 <HAL_RTC_SetTime+0xe4>
  __HAL_LOCK(hrtc);
 8013e5e:	2002      	movs	r0, #2
}
 8013e60:	4770      	bx	lr
      if ((hrtc->Instance->CR & RTC_CR_FMT) != 0U)
 8013e62:	688a      	ldr	r2, [r1, #8]
      tmpreg = (((uint32_t)(sTime->Hours) << RTC_TR_HU_Pos) | \
 8013e64:	7828      	ldrb	r0, [r5, #0]
      if ((hrtc->Instance->CR & RTC_CR_FMT) != 0U)
 8013e66:	f012 0240 	ands.w	r2, r2, #64	; 0x40
                ((uint32_t)(sTime->TimeFormat) << RTC_TR_PM_Pos));
 8013e6a:	bf16      	itet	ne
 8013e6c:	78eb      	ldrbne	r3, [r5, #3]
        sTime->TimeFormat = 0x00U;
 8013e6e:	70ea      	strbeq	r2, [r5, #3]
                ((uint32_t)(sTime->TimeFormat) << RTC_TR_PM_Pos));
 8013e70:	059a      	lslne	r2, r3, #22
                ((uint32_t)(sTime->Minutes) << RTC_TR_MNU_Pos) | \
 8013e72:	786b      	ldrb	r3, [r5, #1]
 8013e74:	021b      	lsls	r3, r3, #8
      tmpreg = (((uint32_t)(sTime->Hours) << RTC_TR_HU_Pos) | \
 8013e76:	ea43 4300 	orr.w	r3, r3, r0, lsl #16
                ((uint32_t)(sTime->Seconds) << RTC_TR_SU_Pos) | \
 8013e7a:	78a8      	ldrb	r0, [r5, #2]
                ((uint32_t)(sTime->Minutes) << RTC_TR_MNU_Pos) | \
 8013e7c:	4303      	orrs	r3, r0
      tmpreg = (((uint32_t)(sTime->Hours) << RTC_TR_HU_Pos) | \
 8013e7e:	4313      	orrs	r3, r2
    hrtc->Instance->TR = (uint32_t)(tmpreg & RTC_TR_RESERVED_MASK);
 8013e80:	f003 337f 	and.w	r3, r3, #2139062143	; 0x7f7f7f7f
 8013e84:	f023 43fe 	bic.w	r3, r3, #2130706432	; 0x7f000000
 8013e88:	600b      	str	r3, [r1, #0]
    hrtc->Instance->CR &= ((uint32_t)~RTC_CR_BKP);
 8013e8a:	688a      	ldr	r2, [r1, #8]
    hrtc->Instance->CR |= (uint32_t)(sTime->DayLightSaving | sTime->StoreOperation);
 8013e8c:	6928      	ldr	r0, [r5, #16]
 8013e8e:	68eb      	ldr	r3, [r5, #12]
    hrtc->Instance->CR &= ((uint32_t)~RTC_CR_BKP);
 8013e90:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
 8013e94:	608a      	str	r2, [r1, #8]
    hrtc->Instance->CR |= (uint32_t)(sTime->DayLightSaving | sTime->StoreOperation);
 8013e96:	688a      	ldr	r2, [r1, #8]
 8013e98:	4303      	orrs	r3, r0
 8013e9a:	4313      	orrs	r3, r2
 8013e9c:	608b      	str	r3, [r1, #8]
    status = RTC_ExitInitMode(hrtc);
 8013e9e:	4620      	mov	r0, r4
 8013ea0:	f7ff feea 	bl	8013c78 <RTC_ExitInitMode>
  __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 8013ea4:	6823      	ldr	r3, [r4, #0]
 8013ea6:	22ff      	movs	r2, #255	; 0xff
 8013ea8:	625a      	str	r2, [r3, #36]	; 0x24
  if (status == HAL_OK)
 8013eaa:	2800      	cmp	r0, #0
 8013eac:	d190      	bne.n	8013dd0 <HAL_RTC_SetTime+0x34>
    hrtc->State = HAL_RTC_STATE_READY;
 8013eae:	2301      	movs	r3, #1
 8013eb0:	f884 3021 	strb.w	r3, [r4, #33]	; 0x21
  __HAL_UNLOCK(hrtc);
 8013eb4:	2300      	movs	r3, #0
 8013eb6:	f884 3020 	strb.w	r3, [r4, #32]
}
 8013eba:	bd70      	pop	{r4, r5, r6, pc}

08013ebc <HAL_RTC_SetDate>:
{
 8013ebc:	b538      	push	{r3, r4, r5, lr}
 8013ebe:	4605      	mov	r5, r0
  __HAL_LOCK(hrtc);
 8013ec0:	f890 0020 	ldrb.w	r0, [r0, #32]
 8013ec4:	2801      	cmp	r0, #1
 8013ec6:	d06e      	beq.n	8013fa6 <HAL_RTC_SetDate+0xea>
 8013ec8:	2001      	movs	r0, #1
  hrtc->State = HAL_RTC_STATE_BUSY;
 8013eca:	2302      	movs	r3, #2
  __HAL_LOCK(hrtc);
 8013ecc:	f885 0020 	strb.w	r0, [r5, #32]
  hrtc->State = HAL_RTC_STATE_BUSY;
 8013ed0:	f885 3021 	strb.w	r3, [r5, #33]	; 0x21
  if ((Format == RTC_FORMAT_BIN) && ((sDate->Month & 0x10U) == 0x10U))
 8013ed4:	b1d2      	cbz	r2, 8013f0c <HAL_RTC_SetDate+0x50>
                  (((uint32_t)sDate->Month) << RTC_DR_MU_Pos) | \
 8013ed6:	784b      	ldrb	r3, [r1, #1]
    datetmpreg = ((((uint32_t)sDate->Year) << RTC_DR_YU_Pos) | \
 8013ed8:	78c8      	ldrb	r0, [r1, #3]
                  (((uint32_t)sDate->Date) << RTC_DR_DU_Pos) | \
 8013eda:	788a      	ldrb	r2, [r1, #2]
                  (((uint32_t)sDate->WeekDay) << RTC_DR_WDU_Pos));
 8013edc:	780c      	ldrb	r4, [r1, #0]
                  (((uint32_t)sDate->Month) << RTC_DR_MU_Pos) | \
 8013ede:	021b      	lsls	r3, r3, #8
    datetmpreg = ((((uint32_t)sDate->Year) << RTC_DR_YU_Pos) | \
 8013ee0:	ea43 4300 	orr.w	r3, r3, r0, lsl #16
                  (((uint32_t)sDate->Month) << RTC_DR_MU_Pos) | \
 8013ee4:	4313      	orrs	r3, r2
    datetmpreg = ((((uint32_t)sDate->Year) << RTC_DR_YU_Pos) | \
 8013ee6:	ea43 3444 	orr.w	r4, r3, r4, lsl #13
  __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
 8013eea:	682b      	ldr	r3, [r5, #0]
 8013eec:	21ca      	movs	r1, #202	; 0xca
 8013eee:	2253      	movs	r2, #83	; 0x53
 8013ef0:	6259      	str	r1, [r3, #36]	; 0x24
  status = RTC_EnterInitMode(hrtc);
 8013ef2:	4628      	mov	r0, r5
  __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
 8013ef4:	625a      	str	r2, [r3, #36]	; 0x24
  status = RTC_EnterInitMode(hrtc);
 8013ef6:	f7ff fe9b 	bl	8013c30 <RTC_EnterInitMode>
  if (status == HAL_OK)
 8013efa:	2800      	cmp	r0, #0
 8013efc:	d03d      	beq.n	8013f7a <HAL_RTC_SetDate+0xbe>
  __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 8013efe:	682b      	ldr	r3, [r5, #0]
 8013f00:	22ff      	movs	r2, #255	; 0xff
 8013f02:	625a      	str	r2, [r3, #36]	; 0x24
  __HAL_UNLOCK(hrtc);
 8013f04:	2300      	movs	r3, #0
 8013f06:	f885 3020 	strb.w	r3, [r5, #32]
}
 8013f0a:	bd38      	pop	{r3, r4, r5, pc}
  if ((Format == RTC_FORMAT_BIN) && ((sDate->Month & 0x10U) == 0x10U))
 8013f0c:	7848      	ldrb	r0, [r1, #1]
 8013f0e:	06c3      	lsls	r3, r0, #27
 8013f10:	d545      	bpl.n	8013f9e <HAL_RTC_SetDate+0xe2>
    datetmpreg = (((uint32_t)RTC_ByteToBcd2(sDate->Year) << RTC_DR_YU_Pos) | \
 8013f12:	78cb      	ldrb	r3, [r1, #3]
    sDate->Month = (uint8_t)((sDate->Month & (uint8_t)~(0x10U)) + (uint8_t)0x0AU);
 8013f14:	f020 0010 	bic.w	r0, r0, #16
 8013f18:	300a      	adds	r0, #10
 8013f1a:	b2c0      	uxtb	r0, r0
  while (temp >= 10U)
 8013f1c:	2b09      	cmp	r3, #9
    sDate->Month = (uint8_t)((sDate->Month & (uint8_t)~(0x10U)) + (uint8_t)0x0AU);
 8013f1e:	7048      	strb	r0, [r1, #1]
  while (temp >= 10U)
 8013f20:	d943      	bls.n	8013faa <HAL_RTC_SetDate+0xee>
  uint32_t bcdhigh = 0U;
 8013f22:	2400      	movs	r4, #0
    temp -= 10U;
 8013f24:	3b0a      	subs	r3, #10
 8013f26:	b2db      	uxtb	r3, r3
  while (temp >= 10U)
 8013f28:	2b09      	cmp	r3, #9
    bcdhigh++;
 8013f2a:	f104 0401 	add.w	r4, r4, #1
  while (temp >= 10U)
 8013f2e:	d8f9      	bhi.n	8013f24 <HAL_RTC_SetDate+0x68>
  return ((uint8_t)(bcdhigh << 4U) | temp);
 8013f30:	ea43 1304 	orr.w	r3, r3, r4, lsl #4
 8013f34:	b2db      	uxtb	r3, r3
  while (temp >= 10U)
 8013f36:	2809      	cmp	r0, #9
    datetmpreg = (((uint32_t)RTC_ByteToBcd2(sDate->Year) << RTC_DR_YU_Pos) | \
 8013f38:	ea4f 4c03 	mov.w	ip, r3, lsl #16
  while (temp >= 10U)
 8013f3c:	d909      	bls.n	8013f52 <HAL_RTC_SetDate+0x96>
  uint32_t bcdhigh = 0U;
 8013f3e:	2300      	movs	r3, #0
    temp -= 10U;
 8013f40:	380a      	subs	r0, #10
 8013f42:	b2c0      	uxtb	r0, r0
  while (temp >= 10U)
 8013f44:	2809      	cmp	r0, #9
    bcdhigh++;
 8013f46:	f103 0301 	add.w	r3, r3, #1
  while (temp >= 10U)
 8013f4a:	d8f9      	bhi.n	8013f40 <HAL_RTC_SetDate+0x84>
  return ((uint8_t)(bcdhigh << 4U) | temp);
 8013f4c:	ea40 1003 	orr.w	r0, r0, r3, lsl #4
 8013f50:	b2c0      	uxtb	r0, r0
                  ((uint32_t)RTC_ByteToBcd2(sDate->Date) << RTC_DR_DU_Pos) | \
 8013f52:	788c      	ldrb	r4, [r1, #2]
  while (temp >= 10U)
 8013f54:	2c09      	cmp	r4, #9
                  ((uint32_t)RTC_ByteToBcd2(sDate->Month) << RTC_DR_MU_Pos) | \
 8013f56:	ea4f 2000 	mov.w	r0, r0, lsl #8
  while (temp >= 10U)
 8013f5a:	d908      	bls.n	8013f6e <HAL_RTC_SetDate+0xb2>
    temp -= 10U;
 8013f5c:	3c0a      	subs	r4, #10
 8013f5e:	b2e4      	uxtb	r4, r4
  while (temp >= 10U)
 8013f60:	2c09      	cmp	r4, #9
    bcdhigh++;
 8013f62:	f102 0201 	add.w	r2, r2, #1
  while (temp >= 10U)
 8013f66:	d8f9      	bhi.n	8013f5c <HAL_RTC_SetDate+0xa0>
  return ((uint8_t)(bcdhigh << 4U) | temp);
 8013f68:	ea44 1402 	orr.w	r4, r4, r2, lsl #4
 8013f6c:	b2e4      	uxtb	r4, r4
                  ((uint32_t)sDate->WeekDay << RTC_DR_WDU_Pos));
 8013f6e:	780b      	ldrb	r3, [r1, #0]
    datetmpreg = (((uint32_t)RTC_ByteToBcd2(sDate->Year) << RTC_DR_YU_Pos) | \
 8013f70:	ea4c 3343 	orr.w	r3, ip, r3, lsl #13
 8013f74:	4303      	orrs	r3, r0
 8013f76:	431c      	orrs	r4, r3
 8013f78:	e7b7      	b.n	8013eea <HAL_RTC_SetDate+0x2e>
    hrtc->Instance->DR = (uint32_t)(datetmpreg & RTC_DR_RESERVED_MASK);
 8013f7a:	682a      	ldr	r2, [r5, #0]
 8013f7c:	f024 447f 	bic.w	r4, r4, #4278190080	; 0xff000000
 8013f80:	f024 04c0 	bic.w	r4, r4, #192	; 0xc0
 8013f84:	6054      	str	r4, [r2, #4]
    status = RTC_ExitInitMode(hrtc);
 8013f86:	4628      	mov	r0, r5
 8013f88:	f7ff fe76 	bl	8013c78 <RTC_ExitInitMode>
  __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 8013f8c:	682b      	ldr	r3, [r5, #0]
 8013f8e:	22ff      	movs	r2, #255	; 0xff
 8013f90:	625a      	str	r2, [r3, #36]	; 0x24
  if (status == HAL_OK)
 8013f92:	2800      	cmp	r0, #0
 8013f94:	d1b6      	bne.n	8013f04 <HAL_RTC_SetDate+0x48>
    hrtc->State = HAL_RTC_STATE_READY ;
 8013f96:	2301      	movs	r3, #1
 8013f98:	f885 3021 	strb.w	r3, [r5, #33]	; 0x21
 8013f9c:	e7b2      	b.n	8013f04 <HAL_RTC_SetDate+0x48>
    datetmpreg = (((uint32_t)RTC_ByteToBcd2(sDate->Year) << RTC_DR_YU_Pos) | \
 8013f9e:	78cb      	ldrb	r3, [r1, #3]
  while (temp >= 10U)
 8013fa0:	2b09      	cmp	r3, #9
 8013fa2:	d8be      	bhi.n	8013f22 <HAL_RTC_SetDate+0x66>
 8013fa4:	e7c7      	b.n	8013f36 <HAL_RTC_SetDate+0x7a>
  __HAL_LOCK(hrtc);
 8013fa6:	2002      	movs	r0, #2
}
 8013fa8:	bd38      	pop	{r3, r4, r5, pc}
    datetmpreg = (((uint32_t)RTC_ByteToBcd2(sDate->Year) << RTC_DR_YU_Pos) | \
 8013faa:	ea4f 4c03 	mov.w	ip, r3, lsl #16
  while (temp >= 10U)
 8013fae:	e7c6      	b.n	8013f3e <HAL_RTC_SetDate+0x82>

08013fb0 <HAL_RTCEx_WakeUpTimerEventCallback>:
 8013fb0:	4770      	bx	lr
 8013fb2:	bf00      	nop

08013fb4 <HAL_RTCEx_WakeUpTimerIRQHandler>:
  * @retval None
  */
void HAL_RTCEx_WakeUpTimerIRQHandler(RTC_HandleTypeDef *hrtc)
{
  /* Clear the EXTI's line Flag for RTC WakeUpTimer */
  __HAL_RTC_WAKEUPTIMER_EXTI_CLEAR_FLAG();
 8013fb4:	4a0c      	ldr	r2, [pc, #48]	; (8013fe8 <HAL_RTCEx_WakeUpTimerIRQHandler+0x34>)
  {
    /* Immediately clear flags */
    hrtc->Instance->SCR = RTC_SCR_CWUTF;
#else
  /* Get the pending status of the WAKEUPTIMER Interrupt */
  if (__HAL_RTC_WAKEUPTIMER_GET_FLAG(hrtc, RTC_FLAG_WUTF) != 0U)
 8013fb6:	6803      	ldr	r3, [r0, #0]
  __HAL_RTC_WAKEUPTIMER_EXTI_CLEAR_FLAG();
 8013fb8:	f44f 1180 	mov.w	r1, #1048576	; 0x100000
{
 8013fbc:	b510      	push	{r4, lr}
  __HAL_RTC_WAKEUPTIMER_EXTI_CLEAR_FLAG();
 8013fbe:	6151      	str	r1, [r2, #20]
  if (__HAL_RTC_WAKEUPTIMER_GET_FLAG(hrtc, RTC_FLAG_WUTF) != 0U)
 8013fc0:	68da      	ldr	r2, [r3, #12]
 8013fc2:	0552      	lsls	r2, r2, #21
{
 8013fc4:	4604      	mov	r4, r0
  if (__HAL_RTC_WAKEUPTIMER_GET_FLAG(hrtc, RTC_FLAG_WUTF) != 0U)
 8013fc6:	d403      	bmi.n	8013fd0 <HAL_RTCEx_WakeUpTimerIRQHandler+0x1c>
    HAL_RTCEx_WakeUpTimerEventCallback(hrtc);
#endif /* USE_HAL_RTC_REGISTER_CALLBACKS */
  }

  /* Change RTC state */
  hrtc->State = HAL_RTC_STATE_READY;
 8013fc8:	2301      	movs	r3, #1
 8013fca:	f884 3021 	strb.w	r3, [r4, #33]	; 0x21
}
 8013fce:	bd10      	pop	{r4, pc}
    __HAL_RTC_WAKEUPTIMER_CLEAR_FLAG(hrtc, RTC_FLAG_WUTF);
 8013fd0:	68da      	ldr	r2, [r3, #12]
 8013fd2:	b2d2      	uxtb	r2, r2
 8013fd4:	f462 6290 	orn	r2, r2, #1152	; 0x480
 8013fd8:	60da      	str	r2, [r3, #12]
    HAL_RTCEx_WakeUpTimerEventCallback(hrtc);
 8013fda:	f7ff ffe9 	bl	8013fb0 <HAL_RTCEx_WakeUpTimerEventCallback>
  hrtc->State = HAL_RTC_STATE_READY;
 8013fde:	2301      	movs	r3, #1
 8013fe0:	f884 3021 	strb.w	r3, [r4, #33]	; 0x21
}
 8013fe4:	bd10      	pop	{r4, pc}
 8013fe6:	bf00      	nop
 8013fe8:	40010400 	.word	0x40010400

08013fec <SPI_WaitFifoStateUntilTimeout.part.0>:
        and slave for their respective CRC calculation */

        /* Disable TXE, RXNE and ERR interrupts for the interrupt process */
        __HAL_SPI_DISABLE_IT(hspi, (SPI_IT_TXE | SPI_IT_RXNE | SPI_IT_ERR));

        if ((hspi->Init.Mode == SPI_MODE_MASTER) && ((hspi->Init.Direction == SPI_DIRECTION_1LINE)
 8013fec:	e9d0 3100 	ldrd	r3, r1, [r0]
        __HAL_SPI_DISABLE_IT(hspi, (SPI_IT_TXE | SPI_IT_RXNE | SPI_IT_ERR));
 8013ff0:	685a      	ldr	r2, [r3, #4]
        if ((hspi->Init.Mode == SPI_MODE_MASTER) && ((hspi->Init.Direction == SPI_DIRECTION_1LINE)
 8013ff2:	f5b1 7f82 	cmp.w	r1, #260	; 0x104
        __HAL_SPI_DISABLE_IT(hspi, (SPI_IT_TXE | SPI_IT_RXNE | SPI_IT_ERR));
 8013ff6:	f022 02e0 	bic.w	r2, r2, #224	; 0xe0
 8013ffa:	605a      	str	r2, [r3, #4]
        if ((hspi->Init.Mode == SPI_MODE_MASTER) && ((hspi->Init.Direction == SPI_DIRECTION_1LINE)
 8013ffc:	d013      	beq.n	8014026 <SPI_WaitFifoStateUntilTimeout.part.0+0x3a>
          /* Disable SPI peripheral */
          __HAL_SPI_DISABLE(hspi);
        }

        /* Reset CRC Calculation */
        if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
 8013ffe:	6a82      	ldr	r2, [r0, #40]	; 0x28
 8014000:	f5b2 5f00 	cmp.w	r2, #8192	; 0x2000
 8014004:	d107      	bne.n	8014016 <SPI_WaitFifoStateUntilTimeout.part.0+0x2a>
        {
          SPI_RESET_CRC(hspi);
 8014006:	681a      	ldr	r2, [r3, #0]
 8014008:	f422 5200 	bic.w	r2, r2, #8192	; 0x2000
 801400c:	601a      	str	r2, [r3, #0]
 801400e:	681a      	ldr	r2, [r3, #0]
 8014010:	f442 5200 	orr.w	r2, r2, #8192	; 0x2000
 8014014:	601a      	str	r2, [r3, #0]
        }

        hspi->State = HAL_SPI_STATE_READY;
 8014016:	2201      	movs	r2, #1

        /* Process Unlocked */
        __HAL_UNLOCK(hspi);
 8014018:	2300      	movs	r3, #0
        hspi->State = HAL_SPI_STATE_READY;
 801401a:	f880 205d 	strb.w	r2, [r0, #93]	; 0x5d
        __HAL_UNLOCK(hspi);
 801401e:	f880 305c 	strb.w	r3, [r0, #92]	; 0x5c
      }
    }
  }

  return HAL_OK;
}
 8014022:	2003      	movs	r0, #3
 8014024:	4770      	bx	lr
        if ((hspi->Init.Mode == SPI_MODE_MASTER) && ((hspi->Init.Direction == SPI_DIRECTION_1LINE)
 8014026:	6882      	ldr	r2, [r0, #8]
 8014028:	f5b2 4f00 	cmp.w	r2, #32768	; 0x8000
 801402c:	d002      	beq.n	8014034 <SPI_WaitFifoStateUntilTimeout.part.0+0x48>
                                                     || (hspi->Init.Direction == SPI_DIRECTION_2LINES_RXONLY)))
 801402e:	f5b2 6f80 	cmp.w	r2, #1024	; 0x400
 8014032:	d1e4      	bne.n	8013ffe <SPI_WaitFifoStateUntilTimeout.part.0+0x12>
          __HAL_SPI_DISABLE(hspi);
 8014034:	681a      	ldr	r2, [r3, #0]
 8014036:	f022 0240 	bic.w	r2, r2, #64	; 0x40
 801403a:	601a      	str	r2, [r3, #0]
 801403c:	e7df      	b.n	8013ffe <SPI_WaitFifoStateUntilTimeout.part.0+0x12>
 801403e:	bf00      	nop

08014040 <SPI_EndRxTxTransaction>:
  * @param  Timeout Timeout duration
  * @param  Tickstart tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef SPI_EndRxTxTransaction(SPI_HandleTypeDef *hspi, uint32_t Timeout, uint32_t Tickstart)
{
 8014040:	b570      	push	{r4, r5, r6, lr}
 8014042:	4605      	mov	r5, r0
 8014044:	460c      	mov	r4, r1
 8014046:	4616      	mov	r6, r2
  while ((hspi->Instance->SR & Fifo) != State)
 8014048:	682b      	ldr	r3, [r5, #0]
 801404a:	e001      	b.n	8014050 <SPI_EndRxTxTransaction+0x10>
    if (Timeout != HAL_MAX_DELAY)
 801404c:	1c62      	adds	r2, r4, #1
 801404e:	d113      	bne.n	8014078 <SPI_EndRxTxTransaction+0x38>
  while ((hspi->Instance->SR & Fifo) != State)
 8014050:	6899      	ldr	r1, [r3, #8]
 8014052:	f411 5fc0 	tst.w	r1, #6144	; 0x1800
 8014056:	d1f9      	bne.n	801404c <SPI_EndRxTxTransaction+0xc>
 8014058:	e001      	b.n	801405e <SPI_EndRxTxTransaction+0x1e>
    if (Timeout != HAL_MAX_DELAY)
 801405a:	1c60      	adds	r0, r4, #1
 801405c:	d11b      	bne.n	8014096 <SPI_EndRxTxTransaction+0x56>
  while ((__HAL_SPI_GET_FLAG(hspi, Flag) ? SET : RESET) != State)
 801405e:	6899      	ldr	r1, [r3, #8]
 8014060:	0609      	lsls	r1, r1, #24
 8014062:	d4fa      	bmi.n	801405a <SPI_EndRxTxTransaction+0x1a>
 8014064:	e002      	b.n	801406c <SPI_EndRxTxTransaction+0x2c>
    if (Timeout != HAL_MAX_DELAY)
 8014066:	1c62      	adds	r2, r4, #1
      READ_REG(*((__IO uint8_t *)&hspi->Instance->DR));
 8014068:	7b19      	ldrb	r1, [r3, #12]
    if (Timeout != HAL_MAX_DELAY)
 801406a:	d11b      	bne.n	80140a4 <SPI_EndRxTxTransaction+0x64>
  while ((hspi->Instance->SR & Fifo) != State)
 801406c:	6899      	ldr	r1, [r3, #8]
 801406e:	f411 6fc0 	tst.w	r1, #1536	; 0x600
 8014072:	d1f8      	bne.n	8014066 <SPI_EndRxTxTransaction+0x26>
  {
    SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
    return HAL_TIMEOUT;
  }

  return HAL_OK;
 8014074:	2000      	movs	r0, #0
}
 8014076:	bd70      	pop	{r4, r5, r6, pc}
      if (((HAL_GetTick() - Tickstart) >= Timeout) || (Timeout == 0U))
 8014078:	f7fb fbde 	bl	800f838 <HAL_GetTick>
 801407c:	1b80      	subs	r0, r0, r6
 801407e:	4284      	cmp	r4, r0
 8014080:	d8e2      	bhi.n	8014048 <SPI_EndRxTxTransaction+0x8>
 8014082:	4628      	mov	r0, r5
 8014084:	f7ff ffb2 	bl	8013fec <SPI_WaitFifoStateUntilTimeout.part.0>
  if (SPI_WaitFifoStateUntilTimeout(hspi, SPI_FLAG_FTLVL, SPI_FTLVL_EMPTY, Timeout, Tickstart) != HAL_OK)
 8014088:	b150      	cbz	r0, 80140a0 <SPI_EndRxTxTransaction+0x60>
    SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
 801408a:	6e2b      	ldr	r3, [r5, #96]	; 0x60
 801408c:	f043 0320 	orr.w	r3, r3, #32
    return HAL_TIMEOUT;
 8014090:	2003      	movs	r0, #3
    SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
 8014092:	662b      	str	r3, [r5, #96]	; 0x60
}
 8014094:	bd70      	pop	{r4, r5, r6, pc}
      if (((HAL_GetTick() - Tickstart) >= Timeout) || (Timeout == 0U))
 8014096:	f7fb fbcf 	bl	800f838 <HAL_GetTick>
 801409a:	1b80      	subs	r0, r0, r6
 801409c:	4284      	cmp	r4, r0
 801409e:	d908      	bls.n	80140b2 <SPI_EndRxTxTransaction+0x72>
  while ((__HAL_SPI_GET_FLAG(hspi, Flag) ? SET : RESET) != State)
 80140a0:	682b      	ldr	r3, [r5, #0]
 80140a2:	e7dc      	b.n	801405e <SPI_EndRxTxTransaction+0x1e>
      if (((HAL_GetTick() - Tickstart) >= Timeout) || (Timeout == 0U))
 80140a4:	f7fb fbc8 	bl	800f838 <HAL_GetTick>
 80140a8:	1b80      	subs	r0, r0, r6
 80140aa:	4284      	cmp	r4, r0
 80140ac:	d907      	bls.n	80140be <SPI_EndRxTxTransaction+0x7e>
  while ((hspi->Instance->SR & Fifo) != State)
 80140ae:	682b      	ldr	r3, [r5, #0]
 80140b0:	e7dc      	b.n	801406c <SPI_EndRxTxTransaction+0x2c>
 80140b2:	4628      	mov	r0, r5
 80140b4:	f7ff ff9a 	bl	8013fec <SPI_WaitFifoStateUntilTimeout.part.0>
  if (SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_BSY, RESET, Timeout, Tickstart) != HAL_OK)
 80140b8:	2800      	cmp	r0, #0
 80140ba:	d1e6      	bne.n	801408a <SPI_EndRxTxTransaction+0x4a>
 80140bc:	e7f7      	b.n	80140ae <SPI_EndRxTxTransaction+0x6e>
 80140be:	4628      	mov	r0, r5
 80140c0:	f7ff ff94 	bl	8013fec <SPI_WaitFifoStateUntilTimeout.part.0>
  if (SPI_WaitFifoStateUntilTimeout(hspi, SPI_FLAG_FRLVL, SPI_FRLVL_EMPTY, Timeout, Tickstart) != HAL_OK)
 80140c4:	2800      	cmp	r0, #0
 80140c6:	d1e0      	bne.n	801408a <SPI_EndRxTxTransaction+0x4a>
 80140c8:	e7d4      	b.n	8014074 <SPI_EndRxTxTransaction+0x34>
 80140ca:	bf00      	nop

080140cc <HAL_SPI_MspInit>:
}
 80140cc:	4770      	bx	lr
 80140ce:	bf00      	nop

080140d0 <HAL_SPI_Init>:
  if (hspi == NULL)
 80140d0:	2800      	cmp	r0, #0
 80140d2:	d066      	beq.n	80141a2 <HAL_SPI_Init+0xd2>
{
 80140d4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  if (hspi->State == HAL_SPI_STATE_RESET)
 80140d6:	f890 305d 	ldrb.w	r3, [r0, #93]	; 0x5d
 80140da:	4604      	mov	r4, r0
 80140dc:	f003 02ff 	and.w	r2, r3, #255	; 0xff
 80140e0:	2b00      	cmp	r3, #0
 80140e2:	d050      	beq.n	8014186 <HAL_SPI_Init+0xb6>
  __HAL_SPI_DISABLE(hspi);
 80140e4:	6822      	ldr	r2, [r4, #0]
  if (hspi->Init.DataSize > SPI_DATASIZE_8BIT)
 80140e6:	68e5      	ldr	r5, [r4, #12]
  hspi->State = HAL_SPI_STATE_BUSY;
 80140e8:	2302      	movs	r3, #2
 80140ea:	f884 305d 	strb.w	r3, [r4, #93]	; 0x5d
  __HAL_SPI_DISABLE(hspi);
 80140ee:	6813      	ldr	r3, [r2, #0]
  if (hspi->Init.DataSize > SPI_DATASIZE_8BIT)
 80140f0:	f5b5 6fe0 	cmp.w	r5, #1792	; 0x700
  __HAL_SPI_DISABLE(hspi);
 80140f4:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 80140f8:	6013      	str	r3, [r2, #0]
  if (hspi->Init.DataSize > SPI_DATASIZE_8BIT)
 80140fa:	d938      	bls.n	801416e <HAL_SPI_Init+0x9e>
  if ((hspi->Init.DataSize != SPI_DATASIZE_16BIT) && (hspi->Init.DataSize != SPI_DATASIZE_8BIT))
 80140fc:	f5b5 6f70 	cmp.w	r5, #3840	; 0xf00
 8014100:	d151      	bne.n	80141a6 <HAL_SPI_Init+0xd6>
  if (hspi->Init.CRCLength == SPI_CRC_LENGTH_DATASIZE)
 8014102:	6b26      	ldr	r6, [r4, #48]	; 0x30
  WRITE_REG(hspi->Instance->CR1, (hspi->Init.Mode | hspi->Init.Direction |
 8014104:	6aa1      	ldr	r1, [r4, #40]	; 0x28
  if (hspi->Init.CRCLength == SPI_CRC_LENGTH_DATASIZE)
 8014106:	2e00      	cmp	r6, #0
 8014108:	d142      	bne.n	8014190 <HAL_SPI_Init+0xc0>
      hspi->Init.CRCLength = SPI_CRC_LENGTH_16BIT;
 801410a:	2602      	movs	r6, #2
 801410c:	6326      	str	r6, [r4, #48]	; 0x30
 801410e:	f04f 0e00 	mov.w	lr, #0
  WRITE_REG(hspi->Instance->CR1, (hspi->Init.Mode | hspi->Init.Direction |
 8014112:	e9d4 3701 	ldrd	r3, r7, [r4, #4]
 8014116:	433b      	orrs	r3, r7
 8014118:	6927      	ldr	r7, [r4, #16]
 801411a:	6a20      	ldr	r0, [r4, #32]
 801411c:	433b      	orrs	r3, r7
 801411e:	6967      	ldr	r7, [r4, #20]
 8014120:	433b      	orrs	r3, r7
 8014122:	69e7      	ldr	r7, [r4, #28]
 8014124:	433b      	orrs	r3, r7
 8014126:	69a7      	ldr	r7, [r4, #24]
 8014128:	4303      	orrs	r3, r0
 801412a:	f407 7c00 	and.w	ip, r7, #512	; 0x200
 801412e:	ea43 030c 	orr.w	r3, r3, ip
 8014132:	430b      	orrs	r3, r1
  if (hspi->Init.CRCLength == SPI_CRC_LENGTH_16BIT)
 8014134:	2e02      	cmp	r6, #2
  WRITE_REG(hspi->Instance->CR1, (hspi->Init.Mode | hspi->Init.Direction |
 8014136:	6013      	str	r3, [r2, #0]
  if (hspi->Init.CRCLength == SPI_CRC_LENGTH_16BIT)
 8014138:	d103      	bne.n	8014142 <HAL_SPI_Init+0x72>
    hspi->Instance->CR1 |= SPI_CR1_CRCL;
 801413a:	6813      	ldr	r3, [r2, #0]
 801413c:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
 8014140:	6013      	str	r3, [r2, #0]
  WRITE_REG(hspi->Instance->CR2, (((hspi->Init.NSS >> 16U) & SPI_CR2_SSOE) | hspi->Init.TIMode |
 8014142:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8014144:	432b      	orrs	r3, r5
 8014146:	6b65      	ldr	r5, [r4, #52]	; 0x34
 8014148:	0c3f      	lsrs	r7, r7, #16
 801414a:	f007 0704 	and.w	r7, r7, #4
 801414e:	432b      	orrs	r3, r5
 8014150:	433b      	orrs	r3, r7
 8014152:	ea43 030e 	orr.w	r3, r3, lr
  if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
 8014156:	f5b1 5f00 	cmp.w	r1, #8192	; 0x2000
  WRITE_REG(hspi->Instance->CR2, (((hspi->Init.NSS >> 16U) & SPI_CR2_SSOE) | hspi->Init.TIMode |
 801415a:	6053      	str	r3, [r2, #4]
    WRITE_REG(hspi->Instance->CRCPR, hspi->Init.CRCPolynomial);
 801415c:	bf04      	itt	eq
 801415e:	6ae3      	ldreq	r3, [r4, #44]	; 0x2c
 8014160:	6113      	streq	r3, [r2, #16]
  hspi->ErrorCode = HAL_SPI_ERROR_NONE;
 8014162:	2000      	movs	r0, #0
  hspi->State     = HAL_SPI_STATE_READY;
 8014164:	2301      	movs	r3, #1
  hspi->ErrorCode = HAL_SPI_ERROR_NONE;
 8014166:	6620      	str	r0, [r4, #96]	; 0x60
  hspi->State     = HAL_SPI_STATE_READY;
 8014168:	f884 305d 	strb.w	r3, [r4, #93]	; 0x5d
}
 801416c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  if ((hspi->Init.DataSize != SPI_DATASIZE_16BIT) && (hspi->Init.DataSize != SPI_DATASIZE_8BIT))
 801416e:	d012      	beq.n	8014196 <HAL_SPI_Init+0xc6>
  if (hspi->Init.CRCLength == SPI_CRC_LENGTH_DATASIZE)
 8014170:	6b26      	ldr	r6, [r4, #48]	; 0x30
    hspi->Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
 8014172:	2100      	movs	r1, #0
 8014174:	62a1      	str	r1, [r4, #40]	; 0x28
  if (hspi->Init.CRCLength == SPI_CRC_LENGTH_DATASIZE)
 8014176:	b91e      	cbnz	r6, 8014180 <HAL_SPI_Init+0xb0>
      hspi->Init.CRCLength = SPI_CRC_LENGTH_8BIT;
 8014178:	2301      	movs	r3, #1
 801417a:	4631      	mov	r1, r6
 801417c:	6323      	str	r3, [r4, #48]	; 0x30
 801417e:	461e      	mov	r6, r3
 8014180:	f44f 5e80 	mov.w	lr, #4096	; 0x1000
 8014184:	e7c5      	b.n	8014112 <HAL_SPI_Init+0x42>
    hspi->Lock = HAL_UNLOCKED;
 8014186:	f880 205c 	strb.w	r2, [r0, #92]	; 0x5c
    HAL_SPI_MspInit(hspi);
 801418a:	f7ff ff9f 	bl	80140cc <HAL_SPI_MspInit>
 801418e:	e7a9      	b.n	80140e4 <HAL_SPI_Init+0x14>
    frxth = SPI_RXFIFO_THRESHOLD_HF;
 8014190:	f04f 0e00 	mov.w	lr, #0
 8014194:	e7bd      	b.n	8014112 <HAL_SPI_Init+0x42>
  if (hspi->Init.CRCLength == SPI_CRC_LENGTH_DATASIZE)
 8014196:	6b26      	ldr	r6, [r4, #48]	; 0x30
 8014198:	b176      	cbz	r6, 80141b8 <HAL_SPI_Init+0xe8>
  WRITE_REG(hspi->Instance->CR1, (hspi->Init.Mode | hspi->Init.Direction |
 801419a:	6aa1      	ldr	r1, [r4, #40]	; 0x28
    frxth = SPI_RXFIFO_THRESHOLD_QF;
 801419c:	f44f 5e80 	mov.w	lr, #4096	; 0x1000
 80141a0:	e7b7      	b.n	8014112 <HAL_SPI_Init+0x42>
    return HAL_ERROR;
 80141a2:	2001      	movs	r0, #1
}
 80141a4:	4770      	bx	lr
  if (hspi->Init.CRCLength == SPI_CRC_LENGTH_DATASIZE)
 80141a6:	6b21      	ldr	r1, [r4, #48]	; 0x30
    hspi->Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
 80141a8:	2300      	movs	r3, #0
 80141aa:	62a3      	str	r3, [r4, #40]	; 0x28
  if (hspi->Init.CRCLength == SPI_CRC_LENGTH_DATASIZE)
 80141ac:	2900      	cmp	r1, #0
 80141ae:	d0ac      	beq.n	801410a <HAL_SPI_Init+0x3a>
 80141b0:	460e      	mov	r6, r1
    frxth = SPI_RXFIFO_THRESHOLD_HF;
 80141b2:	469e      	mov	lr, r3
  if (hspi->Init.CRCLength == SPI_CRC_LENGTH_DATASIZE)
 80141b4:	4619      	mov	r1, r3
 80141b6:	e7ac      	b.n	8014112 <HAL_SPI_Init+0x42>
  WRITE_REG(hspi->Instance->CR1, (hspi->Init.Mode | hspi->Init.Direction |
 80141b8:	6aa6      	ldr	r6, [r4, #40]	; 0x28
 80141ba:	e7dd      	b.n	8014178 <HAL_SPI_Init+0xa8>

080141bc <HAL_SPI_TransmitReceive>:
{
 80141bc:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80141c0:	4699      	mov	r9, r3
  __HAL_LOCK(hspi);
 80141c2:	f890 305c 	ldrb.w	r3, [r0, #92]	; 0x5c
{
 80141c6:	9e0a      	ldr	r6, [sp, #40]	; 0x28
  __HAL_LOCK(hspi);
 80141c8:	2b01      	cmp	r3, #1
 80141ca:	f000 80bc 	beq.w	8014346 <HAL_SPI_TransmitReceive+0x18a>
 80141ce:	4604      	mov	r4, r0
 80141d0:	2301      	movs	r3, #1
 80141d2:	f880 305c 	strb.w	r3, [r0, #92]	; 0x5c
 80141d6:	4688      	mov	r8, r1
 80141d8:	4693      	mov	fp, r2
  tickstart = HAL_GetTick();
 80141da:	f7fb fb2d 	bl	800f838 <HAL_GetTick>
  tmp_state           = hspi->State;
 80141de:	f894 305d 	ldrb.w	r3, [r4, #93]	; 0x5d
  tmp_mode            = hspi->Init.Mode;
 80141e2:	e9d4 5100 	ldrd	r5, r1, [r4]
  if (!((tmp_state == HAL_SPI_STATE_READY) || \
 80141e6:	2b01      	cmp	r3, #1
  spi_cr1             = READ_REG(hspi->Instance->CR1);
 80141e8:	f8d5 c000 	ldr.w	ip, [r5]
  tickstart = HAL_GetTick();
 80141ec:	4607      	mov	r7, r0
  tmp_state           = hspi->State;
 80141ee:	fa5f fe83 	uxtb.w	lr, r3
  spi_cr2             = READ_REG(hspi->Instance->CR2);
 80141f2:	6868      	ldr	r0, [r5, #4]
  spi_cr1             = READ_REG(hspi->Instance->CR1);
 80141f4:	462a      	mov	r2, r5
  if (!((tmp_state == HAL_SPI_STATE_READY) || \
 80141f6:	d012      	beq.n	801421e <HAL_SPI_TransmitReceive+0x62>
 80141f8:	f5b1 7f82 	cmp.w	r1, #260	; 0x104
 80141fc:	d009      	beq.n	8014212 <HAL_SPI_TransmitReceive+0x56>
    errorcode = HAL_BUSY;
 80141fe:	2502      	movs	r5, #2
  hspi->State = HAL_SPI_STATE_READY;
 8014200:	2201      	movs	r2, #1
  __HAL_UNLOCK(hspi);
 8014202:	2300      	movs	r3, #0
  hspi->State = HAL_SPI_STATE_READY;
 8014204:	f884 205d 	strb.w	r2, [r4, #93]	; 0x5d
  __HAL_UNLOCK(hspi);
 8014208:	f884 305c 	strb.w	r3, [r4, #92]	; 0x5c
}
 801420c:	4628      	mov	r0, r5
 801420e:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
        ((tmp_mode == SPI_MODE_MASTER) && (hspi->Init.Direction == SPI_DIRECTION_2LINES) && (tmp_state == HAL_SPI_STATE_BUSY_RX))))
 8014212:	68a3      	ldr	r3, [r4, #8]
 8014214:	2b00      	cmp	r3, #0
 8014216:	d1f2      	bne.n	80141fe <HAL_SPI_TransmitReceive+0x42>
 8014218:	f1be 0f04 	cmp.w	lr, #4
 801421c:	d1ef      	bne.n	80141fe <HAL_SPI_TransmitReceive+0x42>
  if ((pTxData == NULL) || (pRxData == NULL) || (Size == 0U))
 801421e:	f1b8 0f00 	cmp.w	r8, #0
 8014222:	f000 8094 	beq.w	801434e <HAL_SPI_TransmitReceive+0x192>
 8014226:	f1bb 0f00 	cmp.w	fp, #0
 801422a:	f000 8090 	beq.w	801434e <HAL_SPI_TransmitReceive+0x192>
 801422e:	f1b9 0f00 	cmp.w	r9, #0
 8014232:	f000 808c 	beq.w	801434e <HAL_SPI_TransmitReceive+0x192>
  if (hspi->State != HAL_SPI_STATE_BUSY_RX)
 8014236:	f894 305d 	ldrb.w	r3, [r4, #93]	; 0x5d
  hspi->pRxBuffPtr  = (uint8_t *)pRxData;
 801423a:	f8c4 b040 	str.w	fp, [r4, #64]	; 0x40
  if (hspi->State != HAL_SPI_STATE_BUSY_RX)
 801423e:	2b04      	cmp	r3, #4
    hspi->State = HAL_SPI_STATE_BUSY_TX_RX;
 8014240:	bf1c      	itt	ne
 8014242:	2305      	movne	r3, #5
 8014244:	f884 305d 	strbne.w	r3, [r4, #93]	; 0x5d
  hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
 8014248:	2300      	movs	r3, #0
 801424a:	6623      	str	r3, [r4, #96]	; 0x60
  hspi->TxISR       = NULL;
 801424c:	e9c4 3313 	strd	r3, r3, [r4, #76]	; 0x4c
  if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
 8014250:	6aa3      	ldr	r3, [r4, #40]	; 0x28
  hspi->RxXferCount = Size;
 8014252:	f8a4 9046 	strh.w	r9, [r4, #70]	; 0x46
  if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
 8014256:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
  hspi->RxXferSize  = Size;
 801425a:	f8a4 9044 	strh.w	r9, [r4, #68]	; 0x44
  hspi->pTxBuffPtr  = (uint8_t *)pTxData;
 801425e:	f8c4 8038 	str.w	r8, [r4, #56]	; 0x38
  hspi->TxXferSize  = Size;
 8014262:	f8a4 903c 	strh.w	r9, [r4, #60]	; 0x3c
  hspi->TxXferCount = Size;
 8014266:	f8a4 903e 	strh.w	r9, [r4, #62]	; 0x3e
  if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
 801426a:	d107      	bne.n	801427c <HAL_SPI_TransmitReceive+0xc0>
    SPI_RESET_CRC(hspi);
 801426c:	682b      	ldr	r3, [r5, #0]
 801426e:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
 8014272:	602b      	str	r3, [r5, #0]
 8014274:	682b      	ldr	r3, [r5, #0]
 8014276:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
 801427a:	602b      	str	r3, [r5, #0]
  if ((hspi->Init.DataSize > SPI_DATASIZE_8BIT) || (initial_RxXferCount > 1U))
 801427c:	68e3      	ldr	r3, [r4, #12]
 801427e:	f5b3 6fe0 	cmp.w	r3, #1792	; 0x700
    CLEAR_BIT(hspi->Instance->CR2, SPI_RXFIFO_THRESHOLD);
 8014282:	686b      	ldr	r3, [r5, #4]
  if ((hspi->Init.DataSize > SPI_DATASIZE_8BIT) || (initial_RxXferCount > 1U))
 8014284:	d865      	bhi.n	8014352 <HAL_SPI_TransmitReceive+0x196>
 8014286:	f1b9 0f01 	cmp.w	r9, #1
 801428a:	f000 814f 	beq.w	801452c <HAL_SPI_TransmitReceive+0x370>
    CLEAR_BIT(hspi->Instance->CR2, SPI_RXFIFO_THRESHOLD);
 801428e:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
 8014292:	606b      	str	r3, [r5, #4]
  if ((hspi->Instance->CR1 & SPI_CR1_SPE) != SPI_CR1_SPE)
 8014294:	682b      	ldr	r3, [r5, #0]
 8014296:	065b      	lsls	r3, r3, #25
 8014298:	f100 8103 	bmi.w	80144a2 <HAL_SPI_TransmitReceive+0x2e6>
    __HAL_SPI_ENABLE(hspi);
 801429c:	682b      	ldr	r3, [r5, #0]
 801429e:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 80142a2:	602b      	str	r3, [r5, #0]
    if ((hspi->Init.Mode == SPI_MODE_SLAVE) || (initial_TxXferCount == 0x01U))
 80142a4:	2900      	cmp	r1, #0
 80142a6:	f000 80ff 	beq.w	80144a8 <HAL_SPI_TransmitReceive+0x2ec>
 80142aa:	f1b9 0f01 	cmp.w	r9, #1
 80142ae:	f000 80fb 	beq.w	80144a8 <HAL_SPI_TransmitReceive+0x2ec>
          if ((READ_BIT(spi_cr1, SPI_CR1_MSTR) == 0U) && (READ_BIT(spi_cr2, SPI_CR2_NSSP) == SPI_CR2_NSSP))
 80142b2:	f00c 0804 	and.w	r8, ip, #4
 80142b6:	f000 0a08 	and.w	sl, r0, #8
        txallowed = 1U;
 80142ba:	f04f 0901 	mov.w	r9, #1
 80142be:	e003      	b.n	80142c8 <HAL_SPI_TransmitReceive+0x10c>
      if ((((HAL_GetTick() - tickstart) >=  Timeout) && ((Timeout != HAL_MAX_DELAY))) || (Timeout == 0U))
 80142c0:	1c72      	adds	r2, r6, #1
 80142c2:	d13e      	bne.n	8014342 <HAL_SPI_TransmitReceive+0x186>
      if ((__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_TXE)) && (hspi->TxXferCount > 0U) && (txallowed == 1U))
 80142c4:	6825      	ldr	r5, [r4, #0]
 80142c6:	462a      	mov	r2, r5
    while ((hspi->TxXferCount > 0U) || (hspi->RxXferCount > 0U))
 80142c8:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
 80142ca:	b29b      	uxth	r3, r3
 80142cc:	b92b      	cbnz	r3, 80142da <HAL_SPI_TransmitReceive+0x11e>
 80142ce:	f8b4 3046 	ldrh.w	r3, [r4, #70]	; 0x46
 80142d2:	b29b      	uxth	r3, r3
 80142d4:	2b00      	cmp	r3, #0
 80142d6:	f000 80a9 	beq.w	801442c <HAL_SPI_TransmitReceive+0x270>
      if ((__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_TXE)) && (hspi->TxXferCount > 0U) && (txallowed == 1U))
 80142da:	68ab      	ldr	r3, [r5, #8]
 80142dc:	0799      	lsls	r1, r3, #30
 80142de:	d506      	bpl.n	80142ee <HAL_SPI_TransmitReceive+0x132>
 80142e0:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
 80142e2:	b29b      	uxth	r3, r3
 80142e4:	b11b      	cbz	r3, 80142ee <HAL_SPI_TransmitReceive+0x132>
 80142e6:	f1b9 0f00 	cmp.w	r9, #0
 80142ea:	f040 80f9 	bne.w	80144e0 <HAL_SPI_TransmitReceive+0x324>
      if ((__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_RXNE)) && (hspi->RxXferCount > 0U))
 80142ee:	6893      	ldr	r3, [r2, #8]
 80142f0:	f013 0301 	ands.w	r3, r3, #1
 80142f4:	d01e      	beq.n	8014334 <HAL_SPI_TransmitReceive+0x178>
 80142f6:	f8b4 1046 	ldrh.w	r1, [r4, #70]	; 0x46
 80142fa:	b289      	uxth	r1, r1
 80142fc:	b1d1      	cbz	r1, 8014334 <HAL_SPI_TransmitReceive+0x178>
        if (hspi->RxXferCount > 1U)
 80142fe:	f8b4 1046 	ldrh.w	r1, [r4, #70]	; 0x46
 8014302:	b289      	uxth	r1, r1
 8014304:	2901      	cmp	r1, #1
 8014306:	f240 80dd 	bls.w	80144c4 <HAL_SPI_TransmitReceive+0x308>
          *((uint16_t *)hspi->pRxBuffPtr) = (uint16_t)hspi->Instance->DR;
 801430a:	6c21      	ldr	r1, [r4, #64]	; 0x40
 801430c:	68d0      	ldr	r0, [r2, #12]
 801430e:	f821 0b02 	strh.w	r0, [r1], #2
          hspi->pRxBuffPtr += sizeof(uint16_t);
 8014312:	6421      	str	r1, [r4, #64]	; 0x40
          hspi->RxXferCount -= 2U;
 8014314:	f8b4 1046 	ldrh.w	r1, [r4, #70]	; 0x46
 8014318:	3902      	subs	r1, #2
 801431a:	b289      	uxth	r1, r1
 801431c:	f8a4 1046 	strh.w	r1, [r4, #70]	; 0x46
          if (hspi->RxXferCount <= 1U)
 8014320:	f8b4 1046 	ldrh.w	r1, [r4, #70]	; 0x46
 8014324:	b289      	uxth	r1, r1
 8014326:	2901      	cmp	r1, #1
        txallowed = 1U;
 8014328:	4699      	mov	r9, r3
          if (hspi->RxXferCount <= 1U)
 801432a:	d803      	bhi.n	8014334 <HAL_SPI_TransmitReceive+0x178>
            SET_BIT(hspi->Instance->CR2, SPI_RXFIFO_THRESHOLD);
 801432c:	6853      	ldr	r3, [r2, #4]
 801432e:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
 8014332:	6053      	str	r3, [r2, #4]
      if ((((HAL_GetTick() - tickstart) >=  Timeout) && ((Timeout != HAL_MAX_DELAY))) || (Timeout == 0U))
 8014334:	f7fb fa80 	bl	800f838 <HAL_GetTick>
 8014338:	1bc0      	subs	r0, r0, r7
 801433a:	42b0      	cmp	r0, r6
 801433c:	d2c0      	bcs.n	80142c0 <HAL_SPI_TransmitReceive+0x104>
 801433e:	2e00      	cmp	r6, #0
 8014340:	d1c0      	bne.n	80142c4 <HAL_SPI_TransmitReceive+0x108>
        errorcode = HAL_TIMEOUT;
 8014342:	2503      	movs	r5, #3
 8014344:	e75c      	b.n	8014200 <HAL_SPI_TransmitReceive+0x44>
  __HAL_LOCK(hspi);
 8014346:	2502      	movs	r5, #2
}
 8014348:	4628      	mov	r0, r5
 801434a:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    errorcode = HAL_ERROR;
 801434e:	2501      	movs	r5, #1
 8014350:	e756      	b.n	8014200 <HAL_SPI_TransmitReceive+0x44>
    CLEAR_BIT(hspi->Instance->CR2, SPI_RXFIFO_THRESHOLD);
 8014352:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
 8014356:	606b      	str	r3, [r5, #4]
  if ((hspi->Instance->CR1 & SPI_CR1_SPE) != SPI_CR1_SPE)
 8014358:	682b      	ldr	r3, [r5, #0]
 801435a:	065b      	lsls	r3, r3, #25
 801435c:	d403      	bmi.n	8014366 <HAL_SPI_TransmitReceive+0x1aa>
    __HAL_SPI_ENABLE(hspi);
 801435e:	682b      	ldr	r3, [r5, #0]
 8014360:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8014364:	602b      	str	r3, [r5, #0]
    if ((hspi->Init.Mode == SPI_MODE_SLAVE) || (initial_TxXferCount == 0x01U))
 8014366:	2900      	cmp	r1, #0
 8014368:	f040 808d 	bne.w	8014486 <HAL_SPI_TransmitReceive+0x2ca>
      hspi->Instance->DR = *((uint16_t *)hspi->pTxBuffPtr);
 801436c:	4641      	mov	r1, r8
 801436e:	f831 3b02 	ldrh.w	r3, [r1], #2
 8014372:	60eb      	str	r3, [r5, #12]
      hspi->TxXferCount--;
 8014374:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
      hspi->pTxBuffPtr += sizeof(uint16_t);
 8014376:	63a1      	str	r1, [r4, #56]	; 0x38
      hspi->TxXferCount--;
 8014378:	3b01      	subs	r3, #1
 801437a:	b29b      	uxth	r3, r3
 801437c:	87e3      	strh	r3, [r4, #62]	; 0x3e
          if ((READ_BIT(spi_cr1, SPI_CR1_MSTR) == 0U) && (READ_BIT(spi_cr2, SPI_CR2_NSSP) == SPI_CR2_NSSP))
 801437e:	f00c 0804 	and.w	r8, ip, #4
 8014382:	f000 0a08 	and.w	sl, r0, #8
        txallowed = 1U;
 8014386:	f04f 0901 	mov.w	r9, #1
 801438a:	e01d      	b.n	80143c8 <HAL_SPI_TransmitReceive+0x20c>
        txallowed = 0U;
 801438c:	f04f 0900 	mov.w	r9, #0
      if ((__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_RXNE)) && (hspi->RxXferCount > 0U))
 8014390:	68ab      	ldr	r3, [r5, #8]
 8014392:	f013 0301 	ands.w	r3, r3, #1
 8014396:	d00f      	beq.n	80143b8 <HAL_SPI_TransmitReceive+0x1fc>
 8014398:	f8b4 2046 	ldrh.w	r2, [r4, #70]	; 0x46
 801439c:	b292      	uxth	r2, r2
 801439e:	b15a      	cbz	r2, 80143b8 <HAL_SPI_TransmitReceive+0x1fc>
        txallowed = 1U;
 80143a0:	4699      	mov	r9, r3
        *((uint16_t *)hspi->pRxBuffPtr) = (uint16_t)hspi->Instance->DR;
 80143a2:	6c23      	ldr	r3, [r4, #64]	; 0x40
 80143a4:	68ea      	ldr	r2, [r5, #12]
 80143a6:	f823 2b02 	strh.w	r2, [r3], #2
        hspi->pRxBuffPtr += sizeof(uint16_t);
 80143aa:	6423      	str	r3, [r4, #64]	; 0x40
        hspi->RxXferCount--;
 80143ac:	f8b4 3046 	ldrh.w	r3, [r4, #70]	; 0x46
 80143b0:	3b01      	subs	r3, #1
 80143b2:	b29b      	uxth	r3, r3
 80143b4:	f8a4 3046 	strh.w	r3, [r4, #70]	; 0x46
      if (((HAL_GetTick() - tickstart) >=  Timeout) && (Timeout != HAL_MAX_DELAY))
 80143b8:	f7fb fa3e 	bl	800f838 <HAL_GetTick>
 80143bc:	1bc0      	subs	r0, r0, r7
 80143be:	42b0      	cmp	r0, r6
 80143c0:	d301      	bcc.n	80143c6 <HAL_SPI_TransmitReceive+0x20a>
 80143c2:	1c70      	adds	r0, r6, #1
 80143c4:	d1bd      	bne.n	8014342 <HAL_SPI_TransmitReceive+0x186>
      if ((__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_TXE)) && (hspi->TxXferCount > 0U) && (txallowed == 1U))
 80143c6:	6825      	ldr	r5, [r4, #0]
    while ((hspi->TxXferCount > 0U) || (hspi->RxXferCount > 0U))
 80143c8:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
 80143ca:	b29b      	uxth	r3, r3
 80143cc:	b923      	cbnz	r3, 80143d8 <HAL_SPI_TransmitReceive+0x21c>
 80143ce:	f8b4 3046 	ldrh.w	r3, [r4, #70]	; 0x46
 80143d2:	b29b      	uxth	r3, r3
 80143d4:	2b00      	cmp	r3, #0
 80143d6:	d029      	beq.n	801442c <HAL_SPI_TransmitReceive+0x270>
      if ((__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_TXE)) && (hspi->TxXferCount > 0U) && (txallowed == 1U))
 80143d8:	68ab      	ldr	r3, [r5, #8]
 80143da:	079b      	lsls	r3, r3, #30
 80143dc:	d5d8      	bpl.n	8014390 <HAL_SPI_TransmitReceive+0x1d4>
 80143de:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
 80143e0:	b29b      	uxth	r3, r3
 80143e2:	2b00      	cmp	r3, #0
 80143e4:	d0d4      	beq.n	8014390 <HAL_SPI_TransmitReceive+0x1d4>
 80143e6:	f1b9 0f00 	cmp.w	r9, #0
 80143ea:	d0cf      	beq.n	801438c <HAL_SPI_TransmitReceive+0x1d0>
        hspi->Instance->DR = *((uint16_t *)hspi->pTxBuffPtr);
 80143ec:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 80143ee:	f833 2b02 	ldrh.w	r2, [r3], #2
 80143f2:	60ea      	str	r2, [r5, #12]
        hspi->pTxBuffPtr += sizeof(uint16_t);
 80143f4:	63a3      	str	r3, [r4, #56]	; 0x38
        hspi->TxXferCount--;
 80143f6:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
 80143f8:	3b01      	subs	r3, #1
 80143fa:	b29b      	uxth	r3, r3
 80143fc:	87e3      	strh	r3, [r4, #62]	; 0x3e
        if ((hspi->TxXferCount == 0U) && (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE))
 80143fe:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
 8014400:	b29b      	uxth	r3, r3
 8014402:	2b00      	cmp	r3, #0
 8014404:	d1c2      	bne.n	801438c <HAL_SPI_TransmitReceive+0x1d0>
 8014406:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 8014408:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
 801440c:	d1be      	bne.n	801438c <HAL_SPI_TransmitReceive+0x1d0>
          if ((READ_BIT(spi_cr1, SPI_CR1_MSTR) == 0U) && (READ_BIT(spi_cr2, SPI_CR2_NSSP) == SPI_CR2_NSSP))
 801440e:	f1b8 0f00 	cmp.w	r8, #0
 8014412:	d106      	bne.n	8014422 <HAL_SPI_TransmitReceive+0x266>
 8014414:	f1ba 0f00 	cmp.w	sl, #0
 8014418:	d003      	beq.n	8014422 <HAL_SPI_TransmitReceive+0x266>
            SET_BIT(hspi->Instance->CR1, SPI_CR1_SSM);
 801441a:	682b      	ldr	r3, [r5, #0]
 801441c:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 8014420:	602b      	str	r3, [r5, #0]
          SET_BIT(hspi->Instance->CR1, SPI_CR1_CRCNEXT);
 8014422:	682b      	ldr	r3, [r5, #0]
 8014424:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
 8014428:	602b      	str	r3, [r5, #0]
 801442a:	e7af      	b.n	801438c <HAL_SPI_TransmitReceive+0x1d0>
  if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
 801442c:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 801442e:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
 8014432:	d013      	beq.n	801445c <HAL_SPI_TransmitReceive+0x2a0>
  if (__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_CRCERR))
 8014434:	68ab      	ldr	r3, [r5, #8]
 8014436:	f013 0310 	ands.w	r3, r3, #16
 801443a:	d129      	bne.n	8014490 <HAL_SPI_TransmitReceive+0x2d4>
  HAL_StatusTypeDef    errorcode = HAL_OK;
 801443c:	461d      	mov	r5, r3
  if (SPI_EndRxTxTransaction(hspi, Timeout, tickstart) != HAL_OK)
 801443e:	463a      	mov	r2, r7
 8014440:	4631      	mov	r1, r6
 8014442:	4620      	mov	r0, r4
 8014444:	f7ff fdfc 	bl	8014040 <SPI_EndRxTxTransaction>
 8014448:	2800      	cmp	r0, #0
 801444a:	f43f aed9 	beq.w	8014200 <HAL_SPI_TransmitReceive+0x44>
    hspi->ErrorCode = HAL_SPI_ERROR_FLAG;
 801444e:	2320      	movs	r3, #32
 8014450:	6623      	str	r3, [r4, #96]	; 0x60
    errorcode = HAL_ERROR;
 8014452:	2501      	movs	r5, #1
 8014454:	e6d4      	b.n	8014200 <HAL_SPI_TransmitReceive+0x44>
    if (Timeout != HAL_MAX_DELAY)
 8014456:	1c73      	adds	r3, r6, #1
 8014458:	f040 808e 	bne.w	8014578 <HAL_SPI_TransmitReceive+0x3bc>
  while ((__HAL_SPI_GET_FLAG(hspi, Flag) ? SET : RESET) != State)
 801445c:	68ab      	ldr	r3, [r5, #8]
 801445e:	07d8      	lsls	r0, r3, #31
 8014460:	d5f9      	bpl.n	8014456 <HAL_SPI_TransmitReceive+0x29a>
    if (hspi->Init.DataSize == SPI_DATASIZE_16BIT)
 8014462:	68e3      	ldr	r3, [r4, #12]
 8014464:	f5b3 6f70 	cmp.w	r3, #3840	; 0xf00
 8014468:	f000 8097 	beq.w	801459a <HAL_SPI_TransmitReceive+0x3de>
      if (hspi->Init.CRCLength == SPI_CRC_LENGTH_16BIT)
 801446c:	6b23      	ldr	r3, [r4, #48]	; 0x30
      READ_REG(*(__IO uint8_t *)&hspi->Instance->DR);
 801446e:	7b2a      	ldrb	r2, [r5, #12]
      if (hspi->Init.CRCLength == SPI_CRC_LENGTH_16BIT)
 8014470:	2b02      	cmp	r3, #2
 8014472:	d1df      	bne.n	8014434 <HAL_SPI_TransmitReceive+0x278>
 8014474:	e002      	b.n	801447c <HAL_SPI_TransmitReceive+0x2c0>
    if (Timeout != HAL_MAX_DELAY)
 8014476:	1c71      	adds	r1, r6, #1
 8014478:	f040 8091 	bne.w	801459e <HAL_SPI_TransmitReceive+0x3e2>
  while ((__HAL_SPI_GET_FLAG(hspi, Flag) ? SET : RESET) != State)
 801447c:	68ab      	ldr	r3, [r5, #8]
 801447e:	07da      	lsls	r2, r3, #31
 8014480:	d5f9      	bpl.n	8014476 <HAL_SPI_TransmitReceive+0x2ba>
        READ_REG(*(__IO uint8_t *)&hspi->Instance->DR);
 8014482:	7b2b      	ldrb	r3, [r5, #12]
 8014484:	e7d6      	b.n	8014434 <HAL_SPI_TransmitReceive+0x278>
    if ((hspi->Init.Mode == SPI_MODE_SLAVE) || (initial_TxXferCount == 0x01U))
 8014486:	f1b9 0f01 	cmp.w	r9, #1
 801448a:	f47f af78 	bne.w	801437e <HAL_SPI_TransmitReceive+0x1c2>
 801448e:	e76d      	b.n	801436c <HAL_SPI_TransmitReceive+0x1b0>
    SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_CRC);
 8014490:	6e23      	ldr	r3, [r4, #96]	; 0x60
 8014492:	f043 0302 	orr.w	r3, r3, #2
 8014496:	6623      	str	r3, [r4, #96]	; 0x60
    __HAL_SPI_CLEAR_CRCERRFLAG(hspi);
 8014498:	f64f 73ef 	movw	r3, #65519	; 0xffef
 801449c:	60ab      	str	r3, [r5, #8]
    errorcode = HAL_ERROR;
 801449e:	2501      	movs	r5, #1
 80144a0:	e7cd      	b.n	801443e <HAL_SPI_TransmitReceive+0x282>
    if ((hspi->Init.Mode == SPI_MODE_SLAVE) || (initial_TxXferCount == 0x01U))
 80144a2:	2900      	cmp	r1, #0
 80144a4:	f47f af05 	bne.w	80142b2 <HAL_SPI_TransmitReceive+0xf6>
      if (hspi->TxXferCount > 1U)
 80144a8:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
 80144aa:	b29b      	uxth	r3, r3
 80144ac:	2b01      	cmp	r3, #1
 80144ae:	d945      	bls.n	801453c <HAL_SPI_TransmitReceive+0x380>
        hspi->Instance->DR = *((uint16_t *)hspi->pTxBuffPtr);
 80144b0:	4641      	mov	r1, r8
 80144b2:	f831 3b02 	ldrh.w	r3, [r1], #2
 80144b6:	60eb      	str	r3, [r5, #12]
        hspi->TxXferCount -= 2U;
 80144b8:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
        hspi->pTxBuffPtr += sizeof(uint16_t);
 80144ba:	63a1      	str	r1, [r4, #56]	; 0x38
        hspi->TxXferCount -= 2U;
 80144bc:	3b02      	subs	r3, #2
 80144be:	b29b      	uxth	r3, r3
 80144c0:	87e3      	strh	r3, [r4, #62]	; 0x3e
 80144c2:	e6f6      	b.n	80142b2 <HAL_SPI_TransmitReceive+0xf6>
        txallowed = 1U;
 80144c4:	4699      	mov	r9, r3
          (*(uint8_t *)hspi->pRxBuffPtr) = *(__IO uint8_t *)&hspi->Instance->DR;
 80144c6:	6c23      	ldr	r3, [r4, #64]	; 0x40
 80144c8:	7b12      	ldrb	r2, [r2, #12]
 80144ca:	701a      	strb	r2, [r3, #0]
          hspi->RxXferCount--;
 80144cc:	f8b4 3046 	ldrh.w	r3, [r4, #70]	; 0x46
 80144d0:	3b01      	subs	r3, #1
 80144d2:	b29b      	uxth	r3, r3
 80144d4:	f8a4 3046 	strh.w	r3, [r4, #70]	; 0x46
          hspi->pRxBuffPtr++;
 80144d8:	6c23      	ldr	r3, [r4, #64]	; 0x40
 80144da:	3301      	adds	r3, #1
 80144dc:	6423      	str	r3, [r4, #64]	; 0x40
          hspi->RxXferCount--;
 80144de:	e729      	b.n	8014334 <HAL_SPI_TransmitReceive+0x178>
        if (hspi->TxXferCount > 1U)
 80144e0:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
 80144e2:	b29b      	uxth	r3, r3
 80144e4:	2b01      	cmp	r3, #1
          hspi->Instance->DR = *((uint16_t *)hspi->pTxBuffPtr);
 80144e6:	6ba3      	ldr	r3, [r4, #56]	; 0x38
        if (hspi->TxXferCount > 1U)
 80144e8:	d915      	bls.n	8014516 <HAL_SPI_TransmitReceive+0x35a>
          hspi->Instance->DR = *((uint16_t *)hspi->pTxBuffPtr);
 80144ea:	f833 1b02 	ldrh.w	r1, [r3], #2
 80144ee:	60e9      	str	r1, [r5, #12]
          hspi->pTxBuffPtr += sizeof(uint16_t);
 80144f0:	63a3      	str	r3, [r4, #56]	; 0x38
          hspi->TxXferCount -= 2U;
 80144f2:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
 80144f4:	3b02      	subs	r3, #2
 80144f6:	b29b      	uxth	r3, r3
 80144f8:	87e3      	strh	r3, [r4, #62]	; 0x3e
        if ((hspi->TxXferCount == 0U) && (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE))
 80144fa:	f8b4 903e 	ldrh.w	r9, [r4, #62]	; 0x3e
 80144fe:	fa1f f389 	uxth.w	r3, r9
 8014502:	b92b      	cbnz	r3, 8014510 <HAL_SPI_TransmitReceive+0x354>
 8014504:	6aa1      	ldr	r1, [r4, #40]	; 0x28
 8014506:	f5b1 5f00 	cmp.w	r1, #8192	; 0x2000
 801450a:	d024      	beq.n	8014556 <HAL_SPI_TransmitReceive+0x39a>
        txallowed = 0U;
 801450c:	4699      	mov	r9, r3
 801450e:	e6ee      	b.n	80142ee <HAL_SPI_TransmitReceive+0x132>
 8014510:	f04f 0900 	mov.w	r9, #0
 8014514:	e6eb      	b.n	80142ee <HAL_SPI_TransmitReceive+0x132>
          *(__IO uint8_t *)&hspi->Instance->DR = (*hspi->pTxBuffPtr);
 8014516:	781b      	ldrb	r3, [r3, #0]
 8014518:	732b      	strb	r3, [r5, #12]
          hspi->TxXferCount--;
 801451a:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
            SET_BIT(hspi->Instance->CR1, SPI_CR1_SSM);
 801451c:	6822      	ldr	r2, [r4, #0]
          hspi->TxXferCount--;
 801451e:	3b01      	subs	r3, #1
 8014520:	b29b      	uxth	r3, r3
 8014522:	87e3      	strh	r3, [r4, #62]	; 0x3e
          hspi->pTxBuffPtr++;
 8014524:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8014526:	3301      	adds	r3, #1
 8014528:	63a3      	str	r3, [r4, #56]	; 0x38
          hspi->TxXferCount--;
 801452a:	e7e6      	b.n	80144fa <HAL_SPI_TransmitReceive+0x33e>
    SET_BIT(hspi->Instance->CR2, SPI_RXFIFO_THRESHOLD);
 801452c:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
 8014530:	606b      	str	r3, [r5, #4]
  if ((hspi->Instance->CR1 & SPI_CR1_SPE) != SPI_CR1_SPE)
 8014532:	682b      	ldr	r3, [r5, #0]
 8014534:	065b      	lsls	r3, r3, #25
 8014536:	f57f aeb1 	bpl.w	801429c <HAL_SPI_TransmitReceive+0xe0>
 801453a:	e7b5      	b.n	80144a8 <HAL_SPI_TransmitReceive+0x2ec>
        *(__IO uint8_t *)&hspi->Instance->DR = (*hspi->pTxBuffPtr);
 801453c:	f898 3000 	ldrb.w	r3, [r8]
 8014540:	732b      	strb	r3, [r5, #12]
        hspi->TxXferCount--;
 8014542:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
      if ((__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_TXE)) && (hspi->TxXferCount > 0U) && (txallowed == 1U))
 8014544:	6825      	ldr	r5, [r4, #0]
        hspi->TxXferCount--;
 8014546:	3b01      	subs	r3, #1
 8014548:	b29b      	uxth	r3, r3
 801454a:	87e3      	strh	r3, [r4, #62]	; 0x3e
        hspi->pTxBuffPtr++;
 801454c:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 801454e:	3301      	adds	r3, #1
 8014550:	63a3      	str	r3, [r4, #56]	; 0x38
      if ((__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_TXE)) && (hspi->TxXferCount > 0U) && (txallowed == 1U))
 8014552:	462a      	mov	r2, r5
 8014554:	e6ad      	b.n	80142b2 <HAL_SPI_TransmitReceive+0xf6>
          if ((READ_BIT(spi_cr1, SPI_CR1_MSTR) == 0U) && (READ_BIT(spi_cr2, SPI_CR2_NSSP) == SPI_CR2_NSSP))
 8014556:	f1b8 0f00 	cmp.w	r8, #0
 801455a:	d106      	bne.n	801456a <HAL_SPI_TransmitReceive+0x3ae>
 801455c:	f1ba 0f00 	cmp.w	sl, #0
 8014560:	d003      	beq.n	801456a <HAL_SPI_TransmitReceive+0x3ae>
            SET_BIT(hspi->Instance->CR1, SPI_CR1_SSM);
 8014562:	6813      	ldr	r3, [r2, #0]
 8014564:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 8014568:	6013      	str	r3, [r2, #0]
          SET_BIT(hspi->Instance->CR1, SPI_CR1_CRCNEXT);
 801456a:	6813      	ldr	r3, [r2, #0]
 801456c:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
 8014570:	6013      	str	r3, [r2, #0]
        txallowed = 0U;
 8014572:	f04f 0900 	mov.w	r9, #0
 8014576:	e6ba      	b.n	80142ee <HAL_SPI_TransmitReceive+0x132>
      if (((HAL_GetTick() - Tickstart) >= Timeout) || (Timeout == 0U))
 8014578:	f7fb f95e 	bl	800f838 <HAL_GetTick>
 801457c:	1bc0      	subs	r0, r0, r7
 801457e:	4286      	cmp	r6, r0
 8014580:	d901      	bls.n	8014586 <HAL_SPI_TransmitReceive+0x3ca>
  while ((__HAL_SPI_GET_FLAG(hspi, Flag) ? SET : RESET) != State)
 8014582:	6825      	ldr	r5, [r4, #0]
 8014584:	e76a      	b.n	801445c <HAL_SPI_TransmitReceive+0x2a0>
 8014586:	4620      	mov	r0, r4
 8014588:	f7ff fd30 	bl	8013fec <SPI_WaitFifoStateUntilTimeout.part.0>
    if (SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_RXNE, SET, Timeout, tickstart) != HAL_OK)
 801458c:	b1a8      	cbz	r0, 80145ba <HAL_SPI_TransmitReceive+0x3fe>
          SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_CRC);
 801458e:	6e23      	ldr	r3, [r4, #96]	; 0x60
 8014590:	f043 0302 	orr.w	r3, r3, #2
          errorcode = HAL_TIMEOUT;
 8014594:	2503      	movs	r5, #3
          SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_CRC);
 8014596:	6623      	str	r3, [r4, #96]	; 0x60
          goto error;
 8014598:	e632      	b.n	8014200 <HAL_SPI_TransmitReceive+0x44>
      READ_REG(hspi->Instance->DR);
 801459a:	68eb      	ldr	r3, [r5, #12]
 801459c:	e74a      	b.n	8014434 <HAL_SPI_TransmitReceive+0x278>
      if (((HAL_GetTick() - Tickstart) >= Timeout) || (Timeout == 0U))
 801459e:	f7fb f94b 	bl	800f838 <HAL_GetTick>
 80145a2:	1bc0      	subs	r0, r0, r7
 80145a4:	4286      	cmp	r6, r0
 80145a6:	d901      	bls.n	80145ac <HAL_SPI_TransmitReceive+0x3f0>
  while ((__HAL_SPI_GET_FLAG(hspi, Flag) ? SET : RESET) != State)
 80145a8:	6825      	ldr	r5, [r4, #0]
 80145aa:	e767      	b.n	801447c <HAL_SPI_TransmitReceive+0x2c0>
 80145ac:	4620      	mov	r0, r4
 80145ae:	f7ff fd1d 	bl	8013fec <SPI_WaitFifoStateUntilTimeout.part.0>
        if (SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_RXNE, SET, Timeout, tickstart) != HAL_OK)
 80145b2:	2800      	cmp	r0, #0
 80145b4:	d1eb      	bne.n	801458e <HAL_SPI_TransmitReceive+0x3d2>
 80145b6:	6825      	ldr	r5, [r4, #0]
 80145b8:	e763      	b.n	8014482 <HAL_SPI_TransmitReceive+0x2c6>
      READ_REG(hspi->Instance->DR);
 80145ba:	6825      	ldr	r5, [r4, #0]
 80145bc:	e751      	b.n	8014462 <HAL_SPI_TransmitReceive+0x2a6>
 80145be:	bf00      	nop

080145c0 <HAL_SPI_GetState>:
  return hspi->State;
 80145c0:	f890 005d 	ldrb.w	r0, [r0, #93]	; 0x5d
}
 80145c4:	4770      	bx	lr
 80145c6:	bf00      	nop

080145c8 <HAL_UART_MspInit>:
  UNUSED(huart);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_UART_MspInit can be implemented in the user file
   */
}
 80145c8:	4770      	bx	lr
 80145ca:	bf00      	nop

080145cc <HAL_UART_Receive_IT>:
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_UART_Receive_IT(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size)
{
  /* Check that a Rx process is not already ongoing */
  if (huart->RxState == HAL_UART_STATE_READY)
 80145cc:	6f83      	ldr	r3, [r0, #120]	; 0x78
 80145ce:	2b20      	cmp	r3, #32
 80145d0:	d137      	bne.n	8014642 <HAL_UART_Receive_IT+0x76>
  {
    if ((pData == NULL) || (Size == 0U))
 80145d2:	2900      	cmp	r1, #0
 80145d4:	d033      	beq.n	801463e <HAL_UART_Receive_IT+0x72>
 80145d6:	2a00      	cmp	r2, #0
 80145d8:	d031      	beq.n	801463e <HAL_UART_Receive_IT+0x72>
    {
      return HAL_ERROR;
    }

    __HAL_LOCK(huart);
 80145da:	f890 3070 	ldrb.w	r3, [r0, #112]	; 0x70
 80145de:	2b01      	cmp	r3, #1
 80145e0:	d02f      	beq.n	8014642 <HAL_UART_Receive_IT+0x76>
    huart->RxXferSize  = Size;
    huart->RxXferCount = Size;
    huart->RxISR       = NULL;

    /* Computation of UART mask to apply to RDR register */
    UART_MASK_COMPUTATION(huart);
 80145e2:	6883      	ldr	r3, [r0, #8]
{
 80145e4:	b410      	push	{r4}
    __HAL_LOCK(huart);
 80145e6:	2401      	movs	r4, #1
 80145e8:	f880 4070 	strb.w	r4, [r0, #112]	; 0x70
    UART_MASK_COMPUTATION(huart);
 80145ec:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
    huart->RxISR       = NULL;
 80145f0:	f04f 0400 	mov.w	r4, #0
    huart->pRxBuffPtr  = pData;
 80145f4:	6541      	str	r1, [r0, #84]	; 0x54
    huart->RxXferSize  = Size;
 80145f6:	f8a0 2058 	strh.w	r2, [r0, #88]	; 0x58
    huart->RxXferCount = Size;
 80145fa:	f8a0 205a 	strh.w	r2, [r0, #90]	; 0x5a
    huart->RxISR       = NULL;
 80145fe:	6604      	str	r4, [r0, #96]	; 0x60
    UART_MASK_COMPUTATION(huart);
 8014600:	d021      	beq.n	8014646 <HAL_UART_Receive_IT+0x7a>
 8014602:	2b00      	cmp	r3, #0
 8014604:	d12f      	bne.n	8014666 <HAL_UART_Receive_IT+0x9a>
 8014606:	6903      	ldr	r3, [r0, #16]
 8014608:	2b00      	cmp	r3, #0
 801460a:	d03f      	beq.n	801468c <HAL_UART_Receive_IT+0xc0>
 801460c:	237f      	movs	r3, #127	; 0x7f
 801460e:	f8a0 305c 	strh.w	r3, [r0, #92]	; 0x5c

    huart->ErrorCode = HAL_UART_ERROR_NONE;
    huart->RxState = HAL_UART_STATE_BUSY_RX;

    /* Enable the UART Error Interrupt: (Frame error, noise error, overrun error) */
    SET_BIT(huart->Instance->CR3, USART_CR3_EIE);
 8014612:	6802      	ldr	r2, [r0, #0]
    {
      huart->RxISR = UART_RxISR_16BIT;
    }
    else
    {
      huart->RxISR = UART_RxISR_8BIT;
 8014614:	4c23      	ldr	r4, [pc, #140]	; (80146a4 <HAL_UART_Receive_IT+0xd8>)
    huart->RxState = HAL_UART_STATE_BUSY_RX;
 8014616:	2322      	movs	r3, #34	; 0x22
    huart->ErrorCode = HAL_UART_ERROR_NONE;
 8014618:	2100      	movs	r1, #0
 801461a:	67c1      	str	r1, [r0, #124]	; 0x7c
    huart->RxState = HAL_UART_STATE_BUSY_RX;
 801461c:	6783      	str	r3, [r0, #120]	; 0x78
    SET_BIT(huart->Instance->CR3, USART_CR3_EIE);
 801461e:	6893      	ldr	r3, [r2, #8]
 8014620:	f043 0301 	orr.w	r3, r3, #1
 8014624:	6093      	str	r3, [r2, #8]
    }

    __HAL_UNLOCK(huart);
 8014626:	2300      	movs	r3, #0
 8014628:	f880 3070 	strb.w	r3, [r0, #112]	; 0x70

    /* Enable the UART Parity Error interrupt and Data Register Not Empty interrupt */
    SET_BIT(huart->Instance->CR1, USART_CR1_PEIE | USART_CR1_RXNEIE);
 801462c:	6811      	ldr	r1, [r2, #0]
 801462e:	6604      	str	r4, [r0, #96]	; 0x60
 8014630:	f441 7190 	orr.w	r1, r1, #288	; 0x120
#endif /* USART_CR1_FIFOEN */

    return HAL_OK;
 8014634:	4618      	mov	r0, r3
  }
  else
  {
    return HAL_BUSY;
  }
}
 8014636:	f85d 4b04 	ldr.w	r4, [sp], #4
    SET_BIT(huart->Instance->CR1, USART_CR1_PEIE | USART_CR1_RXNEIE);
 801463a:	6011      	str	r1, [r2, #0]
}
 801463c:	4770      	bx	lr
      return HAL_ERROR;
 801463e:	2001      	movs	r0, #1
 8014640:	4770      	bx	lr
    return HAL_BUSY;
 8014642:	2002      	movs	r0, #2
}
 8014644:	4770      	bx	lr
    UART_MASK_COMPUTATION(huart);
 8014646:	6903      	ldr	r3, [r0, #16]
 8014648:	b99b      	cbnz	r3, 8014672 <HAL_UART_Receive_IT+0xa6>
    SET_BIT(huart->Instance->CR3, USART_CR3_EIE);
 801464a:	6802      	ldr	r2, [r0, #0]
    huart->ErrorCode = HAL_UART_ERROR_NONE;
 801464c:	67c3      	str	r3, [r0, #124]	; 0x7c
    huart->RxState = HAL_UART_STATE_BUSY_RX;
 801464e:	2122      	movs	r1, #34	; 0x22
 8014650:	6781      	str	r1, [r0, #120]	; 0x78
    SET_BIT(huart->Instance->CR3, USART_CR3_EIE);
 8014652:	6893      	ldr	r3, [r2, #8]
      huart->RxISR = UART_RxISR_16BIT;
 8014654:	4c14      	ldr	r4, [pc, #80]	; (80146a8 <HAL_UART_Receive_IT+0xdc>)
 8014656:	f240 11ff 	movw	r1, #511	; 0x1ff
    SET_BIT(huart->Instance->CR3, USART_CR3_EIE);
 801465a:	f043 0301 	orr.w	r3, r3, #1
 801465e:	f8a0 105c 	strh.w	r1, [r0, #92]	; 0x5c
 8014662:	6093      	str	r3, [r2, #8]
    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
 8014664:	e7df      	b.n	8014626 <HAL_UART_Receive_IT+0x5a>
    UART_MASK_COMPUTATION(huart);
 8014666:	f1b3 5f80 	cmp.w	r3, #268435456	; 0x10000000
 801466a:	d013      	beq.n	8014694 <HAL_UART_Receive_IT+0xc8>
 801466c:	f8a0 405c 	strh.w	r4, [r0, #92]	; 0x5c
 8014670:	e7cf      	b.n	8014612 <HAL_UART_Receive_IT+0x46>
    SET_BIT(huart->Instance->CR3, USART_CR3_EIE);
 8014672:	6802      	ldr	r2, [r0, #0]
    huart->ErrorCode = HAL_UART_ERROR_NONE;
 8014674:	67c4      	str	r4, [r0, #124]	; 0x7c
    huart->RxState = HAL_UART_STATE_BUSY_RX;
 8014676:	2322      	movs	r3, #34	; 0x22
 8014678:	6783      	str	r3, [r0, #120]	; 0x78
    SET_BIT(huart->Instance->CR3, USART_CR3_EIE);
 801467a:	6893      	ldr	r3, [r2, #8]
      huart->RxISR = UART_RxISR_8BIT;
 801467c:	4c09      	ldr	r4, [pc, #36]	; (80146a4 <HAL_UART_Receive_IT+0xd8>)
 801467e:	21ff      	movs	r1, #255	; 0xff
    SET_BIT(huart->Instance->CR3, USART_CR3_EIE);
 8014680:	f043 0301 	orr.w	r3, r3, #1
 8014684:	f8a0 105c 	strh.w	r1, [r0, #92]	; 0x5c
 8014688:	6093      	str	r3, [r2, #8]
    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
 801468a:	e7cc      	b.n	8014626 <HAL_UART_Receive_IT+0x5a>
    UART_MASK_COMPUTATION(huart);
 801468c:	23ff      	movs	r3, #255	; 0xff
 801468e:	f8a0 305c 	strh.w	r3, [r0, #92]	; 0x5c
 8014692:	e7be      	b.n	8014612 <HAL_UART_Receive_IT+0x46>
 8014694:	6903      	ldr	r3, [r0, #16]
 8014696:	2b00      	cmp	r3, #0
 8014698:	d0b8      	beq.n	801460c <HAL_UART_Receive_IT+0x40>
 801469a:	233f      	movs	r3, #63	; 0x3f
 801469c:	f8a0 305c 	strh.w	r3, [r0, #92]	; 0x5c
 80146a0:	e7b7      	b.n	8014612 <HAL_UART_Receive_IT+0x46>
 80146a2:	bf00      	nop
 80146a4:	080146b1 	.word	0x080146b1
 80146a8:	08014711 	.word	0x08014711

080146ac <HAL_UART_TxCpltCallback>:
 80146ac:	4770      	bx	lr
 80146ae:	bf00      	nop

080146b0 <UART_RxISR_8BIT>:
{
  uint16_t uhMask = huart->Mask;
  uint16_t  uhdata;

  /* Check that a Rx process is ongoing */
  if (huart->RxState == HAL_UART_STATE_BUSY_RX)
 80146b0:	6f82      	ldr	r2, [r0, #120]	; 0x78
 80146b2:	2a22      	cmp	r2, #34	; 0x22
  {
    uhdata = (uint16_t) READ_REG(huart->Instance->RDR);
 80146b4:	6802      	ldr	r2, [r0, #0]
  if (huart->RxState == HAL_UART_STATE_BUSY_RX)
 80146b6:	d005      	beq.n	80146c4 <UART_RxISR_8BIT+0x14>
    }
  }
  else
  {
    /* Clear RXNE interrupt flag */
    __HAL_UART_SEND_REQ(huart, UART_RXDATA_FLUSH_REQUEST);
 80146b8:	8b13      	ldrh	r3, [r2, #24]
 80146ba:	b29b      	uxth	r3, r3
 80146bc:	f043 0308 	orr.w	r3, r3, #8
 80146c0:	8313      	strh	r3, [r2, #24]
  }
}
 80146c2:	4770      	bx	lr
    uhdata = (uint16_t) READ_REG(huart->Instance->RDR);
 80146c4:	8c92      	ldrh	r2, [r2, #36]	; 0x24
    *huart->pRxBuffPtr = (uint8_t)(uhdata & (uint8_t)uhMask);
 80146c6:	f8b0 c05c 	ldrh.w	ip, [r0, #92]	; 0x5c
 80146ca:	6d41      	ldr	r1, [r0, #84]	; 0x54
 80146cc:	ea02 020c 	and.w	r2, r2, ip
 80146d0:	700a      	strb	r2, [r1, #0]
    huart->RxXferCount--;
 80146d2:	f8b0 205a 	ldrh.w	r2, [r0, #90]	; 0x5a
    huart->pRxBuffPtr++;
 80146d6:	6d41      	ldr	r1, [r0, #84]	; 0x54
    huart->RxXferCount--;
 80146d8:	3a01      	subs	r2, #1
 80146da:	b292      	uxth	r2, r2
 80146dc:	f8a0 205a 	strh.w	r2, [r0, #90]	; 0x5a
    if (huart->RxXferCount == 0U)
 80146e0:	f8b0 205a 	ldrh.w	r2, [r0, #90]	; 0x5a
    huart->pRxBuffPtr++;
 80146e4:	3101      	adds	r1, #1
    if (huart->RxXferCount == 0U)
 80146e6:	b292      	uxth	r2, r2
    huart->pRxBuffPtr++;
 80146e8:	6541      	str	r1, [r0, #84]	; 0x54
    if (huart->RxXferCount == 0U)
 80146ea:	b102      	cbz	r2, 80146ee <UART_RxISR_8BIT+0x3e>
 80146ec:	4770      	bx	lr
      CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE));
 80146ee:	6801      	ldr	r1, [r0, #0]
{
 80146f0:	b510      	push	{r4, lr}
      CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE));
 80146f2:	680c      	ldr	r4, [r1, #0]
 80146f4:	f424 7490 	bic.w	r4, r4, #288	; 0x120
 80146f8:	600c      	str	r4, [r1, #0]
      CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 80146fa:	688c      	ldr	r4, [r1, #8]
 80146fc:	f024 0401 	bic.w	r4, r4, #1
 8014700:	608c      	str	r4, [r1, #8]
      huart->RxState = HAL_UART_STATE_READY;
 8014702:	2120      	movs	r1, #32
 8014704:	6781      	str	r1, [r0, #120]	; 0x78
      huart->RxISR = NULL;
 8014706:	6602      	str	r2, [r0, #96]	; 0x60
      HAL_UART_RxCpltCallback(huart);
 8014708:	f00c fd4a 	bl	80211a0 <HAL_UART_RxCpltCallback>
}
 801470c:	bd10      	pop	{r4, pc}
 801470e:	bf00      	nop

08014710 <UART_RxISR_16BIT>:
  uint16_t *tmp;
  uint16_t uhMask = huart->Mask;
  uint16_t  uhdata;

  /* Check that a Rx process is ongoing */
  if (huart->RxState == HAL_UART_STATE_BUSY_RX)
 8014710:	6f82      	ldr	r2, [r0, #120]	; 0x78
 8014712:	2a22      	cmp	r2, #34	; 0x22
 8014714:	d006      	beq.n	8014724 <UART_RxISR_16BIT+0x14>
    }
  }
  else
  {
    /* Clear RXNE interrupt flag */
    __HAL_UART_SEND_REQ(huart, UART_RXDATA_FLUSH_REQUEST);
 8014716:	6802      	ldr	r2, [r0, #0]
 8014718:	8b13      	ldrh	r3, [r2, #24]
 801471a:	b29b      	uxth	r3, r3
 801471c:	f043 0308 	orr.w	r3, r3, #8
 8014720:	8313      	strh	r3, [r2, #24]
 8014722:	4770      	bx	lr
{
 8014724:	b510      	push	{r4, lr}
    uhdata = (uint16_t) READ_REG(huart->Instance->RDR);
 8014726:	6804      	ldr	r4, [r0, #0]
    *tmp = (uint16_t)(uhdata & uhMask);
 8014728:	f8b0 105c 	ldrh.w	r1, [r0, #92]	; 0x5c
    uhdata = (uint16_t) READ_REG(huart->Instance->RDR);
 801472c:	8ca2      	ldrh	r2, [r4, #36]	; 0x24
    *tmp = (uint16_t)(uhdata & uhMask);
 801472e:	400a      	ands	r2, r1
 8014730:	6d41      	ldr	r1, [r0, #84]	; 0x54
 8014732:	f821 2b02 	strh.w	r2, [r1], #2
    huart->RxXferCount--;
 8014736:	f8b0 205a 	ldrh.w	r2, [r0, #90]	; 0x5a
    huart->pRxBuffPtr += 2U;
 801473a:	6541      	str	r1, [r0, #84]	; 0x54
    huart->RxXferCount--;
 801473c:	3a01      	subs	r2, #1
 801473e:	b292      	uxth	r2, r2
 8014740:	f8a0 205a 	strh.w	r2, [r0, #90]	; 0x5a
    if (huart->RxXferCount == 0U)
 8014744:	f8b0 205a 	ldrh.w	r2, [r0, #90]	; 0x5a
 8014748:	b292      	uxth	r2, r2
 801474a:	b102      	cbz	r2, 801474e <UART_RxISR_16BIT+0x3e>
  }
}
 801474c:	bd10      	pop	{r4, pc}
      CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE));
 801474e:	6821      	ldr	r1, [r4, #0]
 8014750:	f421 7190 	bic.w	r1, r1, #288	; 0x120
 8014754:	6021      	str	r1, [r4, #0]
      CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 8014756:	68a1      	ldr	r1, [r4, #8]
 8014758:	f021 0101 	bic.w	r1, r1, #1
 801475c:	60a1      	str	r1, [r4, #8]
      huart->RxState = HAL_UART_STATE_READY;
 801475e:	2120      	movs	r1, #32
 8014760:	6781      	str	r1, [r0, #120]	; 0x78
      huart->RxISR = NULL;
 8014762:	6602      	str	r2, [r0, #96]	; 0x60
      HAL_UART_RxCpltCallback(huart);
 8014764:	f00c fd1c 	bl	80211a0 <HAL_UART_RxCpltCallback>
}
 8014768:	bd10      	pop	{r4, pc}
 801476a:	bf00      	nop

0801476c <HAL_UART_ErrorCallback>:
 801476c:	4770      	bx	lr
 801476e:	bf00      	nop

08014770 <HAL_UART_IRQHandler>:
  uint32_t isrflags   = READ_REG(huart->Instance->ISR);
 8014770:	6802      	ldr	r2, [r0, #0]
 8014772:	69d3      	ldr	r3, [r2, #28]
  uint32_t cr1its     = READ_REG(huart->Instance->CR1);
 8014774:	6811      	ldr	r1, [r2, #0]
{
 8014776:	b570      	push	{r4, r5, r6, lr}
  if (errorflags == 0U)
 8014778:	071e      	lsls	r6, r3, #28
  uint32_t cr3its     = READ_REG(huart->Instance->CR3);
 801477a:	6895      	ldr	r5, [r2, #8]
{
 801477c:	4604      	mov	r4, r0
  if (errorflags == 0U)
 801477e:	d117      	bne.n	80147b0 <HAL_UART_IRQHandler+0x40>
    if (((isrflags & USART_ISR_RXNE) != 0U)
 8014780:	069e      	lsls	r6, r3, #26
 8014782:	d501      	bpl.n	8014788 <HAL_UART_IRQHandler+0x18>
        && ((cr1its & USART_CR1_RXNEIE) != 0U))
 8014784:	068e      	lsls	r6, r1, #26
 8014786:	d475      	bmi.n	8014874 <HAL_UART_IRQHandler+0x104>
  if (((isrflags & USART_ISR_WUF) != 0U) && ((cr3its & USART_CR3_WUFIE) != 0U))
 8014788:	02de      	lsls	r6, r3, #11
 801478a:	d501      	bpl.n	8014790 <HAL_UART_IRQHandler+0x20>
 801478c:	0268      	lsls	r0, r5, #9
 801478e:	d475      	bmi.n	801487c <HAL_UART_IRQHandler+0x10c>
  if (((isrflags & USART_ISR_TXE) != 0U)
 8014790:	061e      	lsls	r6, r3, #24
 8014792:	d404      	bmi.n	801479e <HAL_UART_IRQHandler+0x2e>
  if (((isrflags & USART_ISR_TC) != 0U) && ((cr1its & USART_CR1_TCIE) != 0U))
 8014794:	0658      	lsls	r0, r3, #25
 8014796:	d501      	bpl.n	801479c <HAL_UART_IRQHandler+0x2c>
 8014798:	064b      	lsls	r3, r1, #25
 801479a:	d47b      	bmi.n	8014894 <HAL_UART_IRQHandler+0x124>
}
 801479c:	bd70      	pop	{r4, r5, r6, pc}
      && ((cr1its & USART_CR1_TXEIE) != 0U))
 801479e:	060d      	lsls	r5, r1, #24
 80147a0:	d5f8      	bpl.n	8014794 <HAL_UART_IRQHandler+0x24>
    if (huart->TxISR != NULL)
 80147a2:	6e63      	ldr	r3, [r4, #100]	; 0x64
 80147a4:	2b00      	cmp	r3, #0
 80147a6:	d0f9      	beq.n	801479c <HAL_UART_IRQHandler+0x2c>
      huart->TxISR(huart);
 80147a8:	4620      	mov	r0, r4
}
 80147aa:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
      huart->TxISR(huart);
 80147ae:	4718      	bx	r3
      && (((cr3its & USART_CR3_EIE) != 0U)
 80147b0:	f005 0001 	and.w	r0, r5, #1
          || ((cr1its & (USART_CR1_RXNEIE | USART_CR1_PEIE)) != 0U)))
 80147b4:	f401 7c90 	and.w	ip, r1, #288	; 0x120
 80147b8:	ea5c 0c00 	orrs.w	ip, ip, r0
 80147bc:	d0e4      	beq.n	8014788 <HAL_UART_IRQHandler+0x18>
    if (((isrflags & USART_ISR_PE) != 0U) && ((cr1its & USART_CR1_PEIE) != 0U))
 80147be:	07de      	lsls	r6, r3, #31
 80147c0:	d507      	bpl.n	80147d2 <HAL_UART_IRQHandler+0x62>
 80147c2:	05cd      	lsls	r5, r1, #23
 80147c4:	d505      	bpl.n	80147d2 <HAL_UART_IRQHandler+0x62>
      __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_PEF);
 80147c6:	2501      	movs	r5, #1
 80147c8:	6215      	str	r5, [r2, #32]
      huart->ErrorCode |= HAL_UART_ERROR_PE;
 80147ca:	6fe5      	ldr	r5, [r4, #124]	; 0x7c
 80147cc:	f045 0501 	orr.w	r5, r5, #1
 80147d0:	67e5      	str	r5, [r4, #124]	; 0x7c
    if (((isrflags & USART_ISR_FE) != 0U) && ((cr3its & USART_CR3_EIE) != 0U))
 80147d2:	079e      	lsls	r6, r3, #30
 80147d4:	d549      	bpl.n	801486a <HAL_UART_IRQHandler+0xfa>
 80147d6:	b168      	cbz	r0, 80147f4 <HAL_UART_IRQHandler+0x84>
      __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_FEF);
 80147d8:	2502      	movs	r5, #2
 80147da:	6215      	str	r5, [r2, #32]
      huart->ErrorCode |= HAL_UART_ERROR_FE;
 80147dc:	6fe5      	ldr	r5, [r4, #124]	; 0x7c
 80147de:	f045 0504 	orr.w	r5, r5, #4
 80147e2:	67e5      	str	r5, [r4, #124]	; 0x7c
    if (((isrflags & USART_ISR_NE) != 0U) && ((cr3its & USART_CR3_EIE) != 0U))
 80147e4:	075d      	lsls	r5, r3, #29
 80147e6:	d505      	bpl.n	80147f4 <HAL_UART_IRQHandler+0x84>
      __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_NEF);
 80147e8:	2504      	movs	r5, #4
 80147ea:	6215      	str	r5, [r2, #32]
      huart->ErrorCode |= HAL_UART_ERROR_NE;
 80147ec:	6fe5      	ldr	r5, [r4, #124]	; 0x7c
 80147ee:	f045 0502 	orr.w	r5, r5, #2
 80147f2:	67e5      	str	r5, [r4, #124]	; 0x7c
    if (((isrflags & USART_ISR_ORE) != 0U)
 80147f4:	071d      	lsls	r5, r3, #28
 80147f6:	d509      	bpl.n	801480c <HAL_UART_IRQHandler+0x9c>
        && (((cr1its & USART_CR1_RXNEIE) != 0U) ||
 80147f8:	f001 0520 	and.w	r5, r1, #32
 80147fc:	4328      	orrs	r0, r5
 80147fe:	d005      	beq.n	801480c <HAL_UART_IRQHandler+0x9c>
      __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_OREF);
 8014800:	2008      	movs	r0, #8
 8014802:	6210      	str	r0, [r2, #32]
      huart->ErrorCode |= HAL_UART_ERROR_ORE;
 8014804:	6fe0      	ldr	r0, [r4, #124]	; 0x7c
 8014806:	f040 0008 	orr.w	r0, r0, #8
 801480a:	67e0      	str	r0, [r4, #124]	; 0x7c
    if (huart->ErrorCode != HAL_UART_ERROR_NONE)
 801480c:	6fe0      	ldr	r0, [r4, #124]	; 0x7c
 801480e:	2800      	cmp	r0, #0
 8014810:	d0c4      	beq.n	801479c <HAL_UART_IRQHandler+0x2c>
      if (((isrflags & USART_ISR_RXNE) != 0U)
 8014812:	0698      	lsls	r0, r3, #26
 8014814:	d501      	bpl.n	801481a <HAL_UART_IRQHandler+0xaa>
          && ((cr1its & USART_CR1_RXNEIE) != 0U))
 8014816:	0689      	lsls	r1, r1, #26
 8014818:	d448      	bmi.n	80148ac <HAL_UART_IRQHandler+0x13c>
      errorcode = huart->ErrorCode;
 801481a:	6fe5      	ldr	r5, [r4, #124]	; 0x7c
      if ((HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR)) ||
 801481c:	6893      	ldr	r3, [r2, #8]
          ((errorcode & HAL_UART_ERROR_ORE) != 0U))
 801481e:	f005 0508 	and.w	r5, r5, #8
      if ((HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR)) ||
 8014822:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8014826:	431d      	orrs	r5, r3
 8014828:	d047      	beq.n	80148ba <HAL_UART_IRQHandler+0x14a>
  CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE));
 801482a:	6813      	ldr	r3, [r2, #0]
 801482c:	f423 7390 	bic.w	r3, r3, #288	; 0x120
 8014830:	6013      	str	r3, [r2, #0]
  CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 8014832:	6893      	ldr	r3, [r2, #8]
  huart->RxState = HAL_UART_STATE_READY;
 8014834:	2020      	movs	r0, #32
  CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 8014836:	f023 0301 	bic.w	r3, r3, #1
 801483a:	6093      	str	r3, [r2, #8]
  huart->RxState = HAL_UART_STATE_READY;
 801483c:	67a0      	str	r0, [r4, #120]	; 0x78
        if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
 801483e:	6893      	ldr	r3, [r2, #8]
  huart->RxISR = NULL;
 8014840:	2100      	movs	r1, #0
        if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
 8014842:	065b      	lsls	r3, r3, #25
  huart->RxISR = NULL;
 8014844:	6621      	str	r1, [r4, #96]	; 0x60
        if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
 8014846:	d521      	bpl.n	801488c <HAL_UART_IRQHandler+0x11c>
          CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
 8014848:	6893      	ldr	r3, [r2, #8]
          if (huart->hdmarx != NULL)
 801484a:	6ee0      	ldr	r0, [r4, #108]	; 0x6c
          CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
 801484c:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 8014850:	6093      	str	r3, [r2, #8]
          if (huart->hdmarx != NULL)
 8014852:	b1d8      	cbz	r0, 801488c <HAL_UART_IRQHandler+0x11c>
            huart->hdmarx->XferAbortCallback = UART_DMAAbortOnError;
 8014854:	4b1b      	ldr	r3, [pc, #108]	; (80148c4 <HAL_UART_IRQHandler+0x154>)
 8014856:	6383      	str	r3, [r0, #56]	; 0x38
            if (HAL_DMA_Abort_IT(huart->hdmarx) != HAL_OK)
 8014858:	f7fb fdd4 	bl	8010404 <HAL_DMA_Abort_IT>
 801485c:	2800      	cmp	r0, #0
 801485e:	d09d      	beq.n	801479c <HAL_UART_IRQHandler+0x2c>
              huart->hdmarx->XferAbortCallback(huart->hdmarx);
 8014860:	6ee0      	ldr	r0, [r4, #108]	; 0x6c
}
 8014862:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
              huart->hdmarx->XferAbortCallback(huart->hdmarx);
 8014866:	6b83      	ldr	r3, [r0, #56]	; 0x38
 8014868:	4718      	bx	r3
    if (((isrflags & USART_ISR_NE) != 0U) && ((cr3its & USART_CR3_EIE) != 0U))
 801486a:	075e      	lsls	r6, r3, #29
 801486c:	d5c2      	bpl.n	80147f4 <HAL_UART_IRQHandler+0x84>
 801486e:	2800      	cmp	r0, #0
 8014870:	d1ba      	bne.n	80147e8 <HAL_UART_IRQHandler+0x78>
 8014872:	e7bf      	b.n	80147f4 <HAL_UART_IRQHandler+0x84>
      if (huart->RxISR != NULL)
 8014874:	6e03      	ldr	r3, [r0, #96]	; 0x60
 8014876:	2b00      	cmp	r3, #0
 8014878:	d197      	bne.n	80147aa <HAL_UART_IRQHandler+0x3a>
 801487a:	e78f      	b.n	801479c <HAL_UART_IRQHandler+0x2c>
    __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_WUF);
 801487c:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
    HAL_UARTEx_WakeupCallback(huart);
 8014880:	4620      	mov	r0, r4
    __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_WUF);
 8014882:	6213      	str	r3, [r2, #32]
}
 8014884:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    HAL_UARTEx_WakeupCallback(huart);
 8014888:	f000 bbbc 	b.w	8015004 <HAL_UARTEx_WakeupCallback>
            HAL_UART_ErrorCallback(huart);
 801488c:	4620      	mov	r0, r4
 801488e:	f7ff ff6d 	bl	801476c <HAL_UART_ErrorCallback>
}
 8014892:	bd70      	pop	{r4, r5, r6, pc}
  CLEAR_BIT(huart->Instance->CR1, USART_CR1_TCIE);
 8014894:	6813      	ldr	r3, [r2, #0]
  huart->gState = HAL_UART_STATE_READY;
 8014896:	2020      	movs	r0, #32
  CLEAR_BIT(huart->Instance->CR1, USART_CR1_TCIE);
 8014898:	f023 0340 	bic.w	r3, r3, #64	; 0x40
  huart->TxISR = NULL;
 801489c:	2100      	movs	r1, #0
  CLEAR_BIT(huart->Instance->CR1, USART_CR1_TCIE);
 801489e:	6013      	str	r3, [r2, #0]
  huart->gState = HAL_UART_STATE_READY;
 80148a0:	6760      	str	r0, [r4, #116]	; 0x74
  huart->TxISR = NULL;
 80148a2:	6661      	str	r1, [r4, #100]	; 0x64
  HAL_UART_TxCpltCallback(huart);
 80148a4:	4620      	mov	r0, r4
 80148a6:	f7ff ff01 	bl	80146ac <HAL_UART_TxCpltCallback>
}
 80148aa:	bd70      	pop	{r4, r5, r6, pc}
        if (huart->RxISR != NULL)
 80148ac:	6e23      	ldr	r3, [r4, #96]	; 0x60
 80148ae:	2b00      	cmp	r3, #0
 80148b0:	d0b3      	beq.n	801481a <HAL_UART_IRQHandler+0xaa>
          huart->RxISR(huart);
 80148b2:	4620      	mov	r0, r4
 80148b4:	4798      	blx	r3
      if ((HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR)) ||
 80148b6:	6822      	ldr	r2, [r4, #0]
 80148b8:	e7af      	b.n	801481a <HAL_UART_IRQHandler+0xaa>
        HAL_UART_ErrorCallback(huart);
 80148ba:	4620      	mov	r0, r4
 80148bc:	f7ff ff56 	bl	801476c <HAL_UART_ErrorCallback>
        huart->ErrorCode = HAL_UART_ERROR_NONE;
 80148c0:	67e5      	str	r5, [r4, #124]	; 0x7c
}
 80148c2:	bd70      	pop	{r4, r5, r6, pc}
 80148c4:	080148c9 	.word	0x080148c9

080148c8 <UART_DMAAbortOnError>:
{
 80148c8:	b508      	push	{r3, lr}
  UART_HandleTypeDef *huart = (UART_HandleTypeDef *)(hdma->Parent);
 80148ca:	6a80      	ldr	r0, [r0, #40]	; 0x28
  huart->RxXferCount = 0U;
 80148cc:	2300      	movs	r3, #0
 80148ce:	f8a0 305a 	strh.w	r3, [r0, #90]	; 0x5a
  huart->TxXferCount = 0U;
 80148d2:	f8a0 3052 	strh.w	r3, [r0, #82]	; 0x52
  HAL_UART_ErrorCallback(huart);
 80148d6:	f7ff ff49 	bl	801476c <HAL_UART_ErrorCallback>
}
 80148da:	bd08      	pop	{r3, pc}

080148dc <UART_SetConfig>:
{
 80148dc:	b538      	push	{r3, r4, r5, lr}
 80148de:	4604      	mov	r4, r0
  if (UART_INSTANCE_LOWPOWER(huart))
 80148e0:	6803      	ldr	r3, [r0, #0]
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling ;
 80148e2:	6882      	ldr	r2, [r0, #8]
 80148e4:	6900      	ldr	r0, [r0, #16]
 80148e6:	6961      	ldr	r1, [r4, #20]
  MODIFY_REG(huart->Instance->CR1, USART_CR1_FIELDS, tmpreg);
 80148e8:	681d      	ldr	r5, [r3, #0]
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling ;
 80148ea:	4302      	orrs	r2, r0
 80148ec:	430a      	orrs	r2, r1
 80148ee:	69e0      	ldr	r0, [r4, #28]
  MODIFY_REG(huart->Instance->CR1, USART_CR1_FIELDS, tmpreg);
 80148f0:	49ac      	ldr	r1, [pc, #688]	; (8014ba4 <UART_SetConfig+0x2c8>)
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling ;
 80148f2:	4302      	orrs	r2, r0
  MODIFY_REG(huart->Instance->CR1, USART_CR1_FIELDS, tmpreg);
 80148f4:	4029      	ands	r1, r5
 80148f6:	430a      	orrs	r2, r1
 80148f8:	601a      	str	r2, [r3, #0]
  MODIFY_REG(huart->Instance->CR2, USART_CR2_STOP, huart->Init.StopBits);
 80148fa:	685a      	ldr	r2, [r3, #4]
 80148fc:	68e1      	ldr	r1, [r4, #12]
 80148fe:	f422 5240 	bic.w	r2, r2, #12288	; 0x3000
 8014902:	430a      	orrs	r2, r1
  if (!(UART_INSTANCE_LOWPOWER(huart)))
 8014904:	49a8      	ldr	r1, [pc, #672]	; (8014ba8 <UART_SetConfig+0x2cc>)
  MODIFY_REG(huart->Instance->CR2, USART_CR2_STOP, huart->Init.StopBits);
 8014906:	605a      	str	r2, [r3, #4]
  if (!(UART_INSTANCE_LOWPOWER(huart)))
 8014908:	428b      	cmp	r3, r1
  tmpreg = (uint32_t)huart->Init.HwFlowCtl;
 801490a:	69a2      	ldr	r2, [r4, #24]
  MODIFY_REG(huart->Instance->CR3, USART_CR3_FIELDS, tmpreg);
 801490c:	6899      	ldr	r1, [r3, #8]
  if (!(UART_INSTANCE_LOWPOWER(huart)))
 801490e:	d071      	beq.n	80149f4 <UART_SetConfig+0x118>
    tmpreg |= huart->Init.OneBitSampling;
 8014910:	6a25      	ldr	r5, [r4, #32]
  MODIFY_REG(huart->Instance->CR3, USART_CR3_FIELDS, tmpreg);
 8014912:	f421 6130 	bic.w	r1, r1, #2816	; 0xb00
    tmpreg |= huart->Init.OneBitSampling;
 8014916:	432a      	orrs	r2, r5
  MODIFY_REG(huart->Instance->CR3, USART_CR3_FIELDS, tmpreg);
 8014918:	430a      	orrs	r2, r1
  UART_GETCLOCKSOURCE(huart, clocksource);
 801491a:	49a4      	ldr	r1, [pc, #656]	; (8014bac <UART_SetConfig+0x2d0>)
  MODIFY_REG(huart->Instance->CR3, USART_CR3_FIELDS, tmpreg);
 801491c:	609a      	str	r2, [r3, #8]
  UART_GETCLOCKSOURCE(huart, clocksource);
 801491e:	428b      	cmp	r3, r1
 8014920:	d024      	beq.n	801496c <UART_SetConfig+0x90>
 8014922:	4aa3      	ldr	r2, [pc, #652]	; (8014bb0 <UART_SetConfig+0x2d4>)
 8014924:	4293      	cmp	r3, r2
 8014926:	d042      	beq.n	80149ae <UART_SetConfig+0xd2>
 8014928:	4aa2      	ldr	r2, [pc, #648]	; (8014bb4 <UART_SetConfig+0x2d8>)
 801492a:	4293      	cmp	r3, r2
 801492c:	f000 80eb 	beq.w	8014b06 <UART_SetConfig+0x22a>
 8014930:	4aa1      	ldr	r2, [pc, #644]	; (8014bb8 <UART_SetConfig+0x2dc>)
 8014932:	4293      	cmp	r3, r2
 8014934:	f000 80a5 	beq.w	8014a82 <UART_SetConfig+0x1a6>
 8014938:	4aa0      	ldr	r2, [pc, #640]	; (8014bbc <UART_SetConfig+0x2e0>)
 801493a:	4293      	cmp	r3, r2
 801493c:	d111      	bne.n	8014962 <UART_SetConfig+0x86>
 801493e:	4ba0      	ldr	r3, [pc, #640]	; (8014bc0 <UART_SetConfig+0x2e4>)
 8014940:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 8014944:	f403 7340 	and.w	r3, r3, #768	; 0x300
 8014948:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 801494c:	f000 80c9 	beq.w	8014ae2 <UART_SetConfig+0x206>
 8014950:	f200 80b3 	bhi.w	8014aba <UART_SetConfig+0x1de>
 8014954:	2b00      	cmp	r3, #0
 8014956:	f000 80e8 	beq.w	8014b2a <UART_SetConfig+0x24e>
 801495a:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 801495e:	f000 809d 	beq.w	8014a9c <UART_SetConfig+0x1c0>
        ret = HAL_ERROR;
 8014962:	2001      	movs	r0, #1
  huart->RxISR = NULL;
 8014964:	2300      	movs	r3, #0
  huart->TxISR = NULL;
 8014966:	e9c4 3318 	strd	r3, r3, [r4, #96]	; 0x60
}
 801496a:	bd38      	pop	{r3, r4, r5, pc}
  UART_GETCLOCKSOURCE(huart, clocksource);
 801496c:	4b94      	ldr	r3, [pc, #592]	; (8014bc0 <UART_SetConfig+0x2e4>)
 801496e:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 8014972:	f003 0303 	and.w	r3, r3, #3
 8014976:	3b01      	subs	r3, #1
 8014978:	2b02      	cmp	r3, #2
 801497a:	d979      	bls.n	8014a70 <UART_SetConfig+0x194>
  else if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 801497c:	f5b0 4f00 	cmp.w	r0, #32768	; 0x8000
 8014980:	f000 810d 	beq.w	8014b9e <UART_SetConfig+0x2c2>
        usartdiv = (uint16_t)(UART_DIV_SAMPLING16(HAL_RCC_GetPCLK2Freq(), huart->Init.BaudRate));
 8014984:	f7fe fa12 	bl	8012dac <HAL_RCC_GetPCLK2Freq>
 8014988:	6863      	ldr	r3, [r4, #4]
 801498a:	eb00 0053 	add.w	r0, r0, r3, lsr #1
 801498e:	fbb0 f3f3 	udiv	r3, r0, r3
 8014992:	b29b      	uxth	r3, r3
    if ((usartdiv >= UART_BRR_MIN) && (usartdiv <= UART_BRR_MAX))
 8014994:	f1a3 0210 	sub.w	r2, r3, #16
 8014998:	f64f 71ef 	movw	r1, #65519	; 0xffef
 801499c:	428a      	cmp	r2, r1
 801499e:	d8e0      	bhi.n	8014962 <UART_SetConfig+0x86>
      huart->Instance->BRR = usartdiv;
 80149a0:	6822      	ldr	r2, [r4, #0]
 80149a2:	60d3      	str	r3, [r2, #12]
  huart->RxISR = NULL;
 80149a4:	2300      	movs	r3, #0
  huart->TxISR = NULL;
 80149a6:	e9c4 3318 	strd	r3, r3, [r4, #96]	; 0x60
 80149aa:	2000      	movs	r0, #0
}
 80149ac:	bd38      	pop	{r3, r4, r5, pc}
  UART_GETCLOCKSOURCE(huart, clocksource);
 80149ae:	f502 32e6 	add.w	r2, r2, #117760	; 0x1cc00
 80149b2:	4b84      	ldr	r3, [pc, #528]	; (8014bc4 <UART_SetConfig+0x2e8>)
 80149b4:	f8d2 2088 	ldr.w	r2, [r2, #136]	; 0x88
 80149b8:	f002 020c 	and.w	r2, r2, #12
 80149bc:	4413      	add	r3, r2
 80149be:	791b      	ldrb	r3, [r3, #4]
  else if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 80149c0:	f5b0 4f00 	cmp.w	r0, #32768	; 0x8000
 80149c4:	d070      	beq.n	8014aa8 <UART_SetConfig+0x1cc>
    switch (clocksource)
 80149c6:	2b08      	cmp	r3, #8
 80149c8:	d8cb      	bhi.n	8014962 <UART_SetConfig+0x86>
 80149ca:	a201      	add	r2, pc, #4	; (adr r2, 80149d0 <UART_SetConfig+0xf4>)
 80149cc:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 80149d0:	08014b01 	.word	0x08014b01
 80149d4:	08014985 	.word	0x08014985
 80149d8:	08014ae9 	.word	0x08014ae9
 80149dc:	08014963 	.word	0x08014963
 80149e0:	08014aa3 	.word	0x08014aa3
 80149e4:	08014963 	.word	0x08014963
 80149e8:	08014963 	.word	0x08014963
 80149ec:	08014963 	.word	0x08014963
 80149f0:	08014acf 	.word	0x08014acf
  MODIFY_REG(huart->Instance->CR3, USART_CR3_FIELDS, tmpreg);
 80149f4:	f421 6130 	bic.w	r1, r1, #2816	; 0xb00
  UART_GETCLOCKSOURCE(huart, clocksource);
 80149f8:	4871      	ldr	r0, [pc, #452]	; (8014bc0 <UART_SetConfig+0x2e4>)
  MODIFY_REG(huart->Instance->CR3, USART_CR3_FIELDS, tmpreg);
 80149fa:	430a      	orrs	r2, r1
 80149fc:	609a      	str	r2, [r3, #8]
  UART_GETCLOCKSOURCE(huart, clocksource);
 80149fe:	f8d0 5088 	ldr.w	r5, [r0, #136]	; 0x88
 8014a02:	f405 6540 	and.w	r5, r5, #3072	; 0xc00
 8014a06:	f5b5 6f00 	cmp.w	r5, #2048	; 0x800
 8014a0a:	f000 808b 	beq.w	8014b24 <UART_SetConfig+0x248>
 8014a0e:	d809      	bhi.n	8014a24 <UART_SetConfig+0x148>
 8014a10:	b38d      	cbz	r5, 8014a76 <UART_SetConfig+0x19a>
 8014a12:	f5b5 6f80 	cmp.w	r5, #1024	; 0x400
 8014a16:	d1a4      	bne.n	8014962 <UART_SetConfig+0x86>
        lpuart_ker_ck_pres = HAL_RCC_GetSysClockFreq();
 8014a18:	f7fd fdf2 	bl	8012600 <HAL_RCC_GetSysClockFreq>
        break;
 8014a1c:	2504      	movs	r5, #4
    if (lpuart_ker_ck_pres != 0U)
 8014a1e:	2800      	cmp	r0, #0
 8014a20:	d0a0      	beq.n	8014964 <UART_SetConfig+0x88>
 8014a22:	e005      	b.n	8014a30 <UART_SetConfig+0x154>
  UART_GETCLOCKSOURCE(huart, clocksource);
 8014a24:	f5b5 6f40 	cmp.w	r5, #3072	; 0xc00
 8014a28:	d19b      	bne.n	8014962 <UART_SetConfig+0x86>
 8014a2a:	2508      	movs	r5, #8
        lpuart_ker_ck_pres = (uint32_t)LSE_VALUE;
 8014a2c:	f44f 4000 	mov.w	r0, #32768	; 0x8000
      if ((lpuart_ker_ck_pres < (3U * huart->Init.BaudRate)) ||
 8014a30:	6862      	ldr	r2, [r4, #4]
 8014a32:	eb02 0342 	add.w	r3, r2, r2, lsl #1
 8014a36:	4283      	cmp	r3, r0
 8014a38:	d893      	bhi.n	8014962 <UART_SetConfig+0x86>
 8014a3a:	ebb0 3f02 	cmp.w	r0, r2, lsl #12
 8014a3e:	d890      	bhi.n	8014962 <UART_SetConfig+0x86>
        switch (clocksource)
 8014a40:	2d08      	cmp	r5, #8
 8014a42:	d88e      	bhi.n	8014962 <UART_SetConfig+0x86>
 8014a44:	a301      	add	r3, pc, #4	; (adr r3, 8014a4c <UART_SetConfig+0x170>)
 8014a46:	f853 f025 	ldr.w	pc, [r3, r5, lsl #2]
 8014a4a:	bf00      	nop
 8014a4c:	08014c29 	.word	0x08014c29
 8014a50:	08014963 	.word	0x08014963
 8014a54:	08014c0f 	.word	0x08014c0f
 8014a58:	08014963 	.word	0x08014963
 8014a5c:	08014beb 	.word	0x08014beb
 8014a60:	08014963 	.word	0x08014963
 8014a64:	08014963 	.word	0x08014963
 8014a68:	08014963 	.word	0x08014963
 8014a6c:	08014bcd 	.word	0x08014bcd
 8014a70:	4a54      	ldr	r2, [pc, #336]	; (8014bc4 <UART_SetConfig+0x2e8>)
 8014a72:	5cd3      	ldrb	r3, [r2, r3]
  if (UART_INSTANCE_LOWPOWER(huart))
 8014a74:	e7a4      	b.n	80149c0 <UART_SetConfig+0xe4>
        lpuart_ker_ck_pres = HAL_RCC_GetPCLK1Freq();
 8014a76:	f7fe f987 	bl	8012d88 <HAL_RCC_GetPCLK1Freq>
    if (lpuart_ker_ck_pres != 0U)
 8014a7a:	2800      	cmp	r0, #0
 8014a7c:	f43f af72 	beq.w	8014964 <UART_SetConfig+0x88>
 8014a80:	e7d6      	b.n	8014a30 <UART_SetConfig+0x154>
  UART_GETCLOCKSOURCE(huart, clocksource);
 8014a82:	4b4f      	ldr	r3, [pc, #316]	; (8014bc0 <UART_SetConfig+0x2e4>)
 8014a84:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 8014a88:	f003 03c0 	and.w	r3, r3, #192	; 0xc0
 8014a8c:	2b80      	cmp	r3, #128	; 0x80
 8014a8e:	d028      	beq.n	8014ae2 <UART_SetConfig+0x206>
 8014a90:	d845      	bhi.n	8014b1e <UART_SetConfig+0x242>
 8014a92:	2b00      	cmp	r3, #0
 8014a94:	d049      	beq.n	8014b2a <UART_SetConfig+0x24e>
 8014a96:	2b40      	cmp	r3, #64	; 0x40
 8014a98:	f47f af63 	bne.w	8014962 <UART_SetConfig+0x86>
  else if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 8014a9c:	f5b0 4f00 	cmp.w	r0, #32768	; 0x8000
 8014aa0:	d06f      	beq.n	8014b82 <UART_SetConfig+0x2a6>
        usartdiv = (uint16_t)(UART_DIV_SAMPLING16(HAL_RCC_GetSysClockFreq(), huart->Init.BaudRate));
 8014aa2:	f7fd fdad 	bl	8012600 <HAL_RCC_GetSysClockFreq>
 8014aa6:	e76f      	b.n	8014988 <UART_SetConfig+0xac>
    switch (clocksource)
 8014aa8:	2b08      	cmp	r3, #8
 8014aaa:	d85e      	bhi.n	8014b6a <UART_SetConfig+0x28e>
 8014aac:	e8df f003 	tbb	[pc, r3]
 8014ab0:	5d6c7740 	.word	0x5d6c7740
 8014ab4:	5d5d5d69 	.word	0x5d5d5d69
 8014ab8:	60          	.byte	0x60
 8014ab9:	00          	.byte	0x00
  UART_GETCLOCKSOURCE(huart, clocksource);
 8014aba:	f5b3 7f40 	cmp.w	r3, #768	; 0x300
 8014abe:	d003      	beq.n	8014ac8 <UART_SetConfig+0x1ec>
 8014ac0:	e74f      	b.n	8014962 <UART_SetConfig+0x86>
 8014ac2:	2b30      	cmp	r3, #48	; 0x30
 8014ac4:	f47f af4d 	bne.w	8014962 <UART_SetConfig+0x86>
  else if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 8014ac8:	f5b0 4f00 	cmp.w	r0, #32768	; 0x8000
 8014acc:	d050      	beq.n	8014b70 <UART_SetConfig+0x294>
        usartdiv = (uint16_t)(UART_DIV_SAMPLING16(LSE_VALUE, huart->Init.BaudRate));
 8014ace:	6862      	ldr	r2, [r4, #4]
 8014ad0:	0853      	lsrs	r3, r2, #1
 8014ad2:	f503 4300 	add.w	r3, r3, #32768	; 0x8000
 8014ad6:	fbb3 f3f2 	udiv	r3, r3, r2
 8014ada:	b29b      	uxth	r3, r3
    if ((usartdiv >= UART_BRR_MIN) && (usartdiv <= UART_BRR_MAX))
 8014adc:	f1a3 0210 	sub.w	r2, r3, #16
        break;
 8014ae0:	e75a      	b.n	8014998 <UART_SetConfig+0xbc>
  else if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 8014ae2:	f5b0 4f00 	cmp.w	r0, #32768	; 0x8000
 8014ae6:	d04f      	beq.n	8014b88 <UART_SetConfig+0x2ac>
        usartdiv = (uint16_t)(UART_DIV_SAMPLING16(HSI_VALUE, huart->Init.BaudRate));
 8014ae8:	6862      	ldr	r2, [r4, #4]
 8014aea:	0853      	lsrs	r3, r2, #1
 8014aec:	f503 0374 	add.w	r3, r3, #15990784	; 0xf40000
 8014af0:	f503 5310 	add.w	r3, r3, #9216	; 0x2400
 8014af4:	fbb3 f3f2 	udiv	r3, r3, r2
 8014af8:	b29b      	uxth	r3, r3
    if ((usartdiv >= UART_BRR_MIN) && (usartdiv <= UART_BRR_MAX))
 8014afa:	f1a3 0210 	sub.w	r2, r3, #16
        break;
 8014afe:	e74b      	b.n	8014998 <UART_SetConfig+0xbc>
        usartdiv = (uint16_t)(UART_DIV_SAMPLING16(HAL_RCC_GetPCLK1Freq(), huart->Init.BaudRate));
 8014b00:	f7fe f942 	bl	8012d88 <HAL_RCC_GetPCLK1Freq>
 8014b04:	e740      	b.n	8014988 <UART_SetConfig+0xac>
  UART_GETCLOCKSOURCE(huart, clocksource);
 8014b06:	4b2e      	ldr	r3, [pc, #184]	; (8014bc0 <UART_SetConfig+0x2e4>)
 8014b08:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 8014b0c:	f003 0330 	and.w	r3, r3, #48	; 0x30
 8014b10:	2b20      	cmp	r3, #32
 8014b12:	d0e6      	beq.n	8014ae2 <UART_SetConfig+0x206>
 8014b14:	d8d5      	bhi.n	8014ac2 <UART_SetConfig+0x1e6>
 8014b16:	b143      	cbz	r3, 8014b2a <UART_SetConfig+0x24e>
 8014b18:	2b10      	cmp	r3, #16
 8014b1a:	d0bf      	beq.n	8014a9c <UART_SetConfig+0x1c0>
 8014b1c:	e721      	b.n	8014962 <UART_SetConfig+0x86>
 8014b1e:	2bc0      	cmp	r3, #192	; 0xc0
 8014b20:	d0d2      	beq.n	8014ac8 <UART_SetConfig+0x1ec>
 8014b22:	e71e      	b.n	8014962 <UART_SetConfig+0x86>
 8014b24:	4828      	ldr	r0, [pc, #160]	; (8014bc8 <UART_SetConfig+0x2ec>)
 8014b26:	2502      	movs	r5, #2
 8014b28:	e782      	b.n	8014a30 <UART_SetConfig+0x154>
  else if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 8014b2a:	f5b0 4f00 	cmp.w	r0, #32768	; 0x8000
 8014b2e:	d1e7      	bne.n	8014b00 <UART_SetConfig+0x224>
        usartdiv = (uint16_t)(UART_DIV_SAMPLING8(HAL_RCC_GetPCLK1Freq(), huart->Init.BaudRate));
 8014b30:	f7fe f92a 	bl	8012d88 <HAL_RCC_GetPCLK1Freq>
        usartdiv = (uint16_t)(UART_DIV_SAMPLING8(HAL_RCC_GetSysClockFreq(), huart->Init.BaudRate));
 8014b34:	6862      	ldr	r2, [r4, #4]
 8014b36:	4601      	mov	r1, r0
 8014b38:	0853      	lsrs	r3, r2, #1
 8014b3a:	eb03 0341 	add.w	r3, r3, r1, lsl #1
  HAL_StatusTypeDef ret               = HAL_OK;
 8014b3e:	2000      	movs	r0, #0
        usartdiv = (uint16_t)(UART_DIV_SAMPLING8(HAL_RCC_GetSysClockFreq(), huart->Init.BaudRate));
 8014b40:	fbb3 f3f2 	udiv	r3, r3, r2
 8014b44:	b29b      	uxth	r3, r3
    if ((usartdiv >= UART_BRR_MIN) && (usartdiv <= UART_BRR_MAX))
 8014b46:	f1a3 0110 	sub.w	r1, r3, #16
 8014b4a:	f64f 72ef 	movw	r2, #65519	; 0xffef
 8014b4e:	4291      	cmp	r1, r2
 8014b50:	f63f af07 	bhi.w	8014962 <UART_SetConfig+0x86>
      brrtemp = (uint16_t)(usartdiv & 0xFFF0U);
 8014b54:	f023 020f 	bic.w	r2, r3, #15
      huart->Instance->BRR = brrtemp;
 8014b58:	6821      	ldr	r1, [r4, #0]
      brrtemp |= (uint16_t)((usartdiv & (uint16_t)0x000FU) >> 1U);
 8014b5a:	f3c3 0342 	ubfx	r3, r3, #1, #3
      huart->Instance->BRR = brrtemp;
 8014b5e:	4313      	orrs	r3, r2
 8014b60:	60cb      	str	r3, [r1, #12]
  huart->RxISR = NULL;
 8014b62:	2300      	movs	r3, #0
  huart->TxISR = NULL;
 8014b64:	e9c4 3318 	strd	r3, r3, [r4, #96]	; 0x60
}
 8014b68:	bd38      	pop	{r3, r4, r5, pc}
    switch (clocksource)
 8014b6a:	2001      	movs	r0, #1
 8014b6c:	2300      	movs	r3, #0
 8014b6e:	e7ea      	b.n	8014b46 <UART_SetConfig+0x26a>
        usartdiv = (uint16_t)(UART_DIV_SAMPLING8(LSE_VALUE, huart->Init.BaudRate));
 8014b70:	6862      	ldr	r2, [r4, #4]
 8014b72:	0853      	lsrs	r3, r2, #1
 8014b74:	f503 3380 	add.w	r3, r3, #65536	; 0x10000
  HAL_StatusTypeDef ret               = HAL_OK;
 8014b78:	2000      	movs	r0, #0
        usartdiv = (uint16_t)(UART_DIV_SAMPLING8(LSE_VALUE, huart->Init.BaudRate));
 8014b7a:	fbb3 f3f2 	udiv	r3, r3, r2
 8014b7e:	b29b      	uxth	r3, r3
        break;
 8014b80:	e7e1      	b.n	8014b46 <UART_SetConfig+0x26a>
        usartdiv = (uint16_t)(UART_DIV_SAMPLING8(HAL_RCC_GetSysClockFreq(), huart->Init.BaudRate));
 8014b82:	f7fd fd3d 	bl	8012600 <HAL_RCC_GetSysClockFreq>
 8014b86:	e7d5      	b.n	8014b34 <UART_SetConfig+0x258>
        usartdiv = (uint16_t)(UART_DIV_SAMPLING8(HSI_VALUE, huart->Init.BaudRate));
 8014b88:	6862      	ldr	r2, [r4, #4]
 8014b8a:	0853      	lsrs	r3, r2, #1
 8014b8c:	f103 73f4 	add.w	r3, r3, #31981568	; 0x1e80000
 8014b90:	f503 4390 	add.w	r3, r3, #18432	; 0x4800
  HAL_StatusTypeDef ret               = HAL_OK;
 8014b94:	2000      	movs	r0, #0
        usartdiv = (uint16_t)(UART_DIV_SAMPLING8(HSI_VALUE, huart->Init.BaudRate));
 8014b96:	fbb3 f3f2 	udiv	r3, r3, r2
 8014b9a:	b29b      	uxth	r3, r3
        break;
 8014b9c:	e7d3      	b.n	8014b46 <UART_SetConfig+0x26a>
        usartdiv = (uint16_t)(UART_DIV_SAMPLING8(HAL_RCC_GetPCLK2Freq(), huart->Init.BaudRate));
 8014b9e:	f7fe f905 	bl	8012dac <HAL_RCC_GetPCLK2Freq>
 8014ba2:	e7c7      	b.n	8014b34 <UART_SetConfig+0x258>
 8014ba4:	efff69f3 	.word	0xefff69f3
 8014ba8:	40008000 	.word	0x40008000
 8014bac:	40013800 	.word	0x40013800
 8014bb0:	40004400 	.word	0x40004400
 8014bb4:	40004800 	.word	0x40004800
 8014bb8:	40004c00 	.word	0x40004c00
 8014bbc:	40005000 	.word	0x40005000
 8014bc0:	40021000 	.word	0x40021000
 8014bc4:	0802d330 	.word	0x0802d330
 8014bc8:	00f42400 	.word	0x00f42400
            usartdiv = (uint32_t)(UART_DIV_LPUART(LSE_VALUE, huart->Init.BaudRate));
 8014bcc:	0850      	lsrs	r0, r2, #1
 8014bce:	2300      	movs	r3, #0
 8014bd0:	4619      	mov	r1, r3
 8014bd2:	f500 0000 	add.w	r0, r0, #8388608	; 0x800000
 8014bd6:	f7f6 f93f 	bl	800ae58 <__aeabi_uldivmod>
 8014bda:	4603      	mov	r3, r0
        if ((usartdiv >= LPUART_BRR_MIN) && (usartdiv <= LPUART_BRR_MAX))
 8014bdc:	f5a0 7240 	sub.w	r2, r0, #768	; 0x300
 8014be0:	4913      	ldr	r1, [pc, #76]	; (8014c30 <UART_SetConfig+0x354>)
 8014be2:	428a      	cmp	r2, r1
 8014be4:	f67f aedc 	bls.w	80149a0 <UART_SetConfig+0xc4>
 8014be8:	e6bb      	b.n	8014962 <UART_SetConfig+0x86>
            usartdiv = (uint32_t)(UART_DIV_LPUART(HAL_RCC_GetSysClockFreq(), huart->Init.BaudRate));
 8014bea:	f7fd fd09 	bl	8012600 <HAL_RCC_GetSysClockFreq>
 8014bee:	6862      	ldr	r2, [r4, #4]
 8014bf0:	2300      	movs	r3, #0
 8014bf2:	0851      	lsrs	r1, r2, #1
 8014bf4:	468c      	mov	ip, r1
 8014bf6:	f44f 7580 	mov.w	r5, #256	; 0x100
 8014bfa:	4619      	mov	r1, r3
 8014bfc:	fbe0 c105 	umlal	ip, r1, r0, r5
 8014c00:	4660      	mov	r0, ip
 8014c02:	f7f6 f929 	bl	800ae58 <__aeabi_uldivmod>
 8014c06:	4603      	mov	r3, r0
        if ((usartdiv >= LPUART_BRR_MIN) && (usartdiv <= LPUART_BRR_MAX))
 8014c08:	f5a0 7240 	sub.w	r2, r0, #768	; 0x300
            break;
 8014c0c:	e7e8      	b.n	8014be0 <UART_SetConfig+0x304>
            usartdiv = (uint32_t)(UART_DIV_LPUART(HSI_VALUE, huart->Init.BaudRate));
 8014c0e:	4809      	ldr	r0, [pc, #36]	; (8014c34 <UART_SetConfig+0x358>)
 8014c10:	0853      	lsrs	r3, r2, #1
 8014c12:	1818      	adds	r0, r3, r0
 8014c14:	f04f 0300 	mov.w	r3, #0
 8014c18:	f143 0100 	adc.w	r1, r3, #0
 8014c1c:	f7f6 f91c 	bl	800ae58 <__aeabi_uldivmod>
 8014c20:	4603      	mov	r3, r0
        if ((usartdiv >= LPUART_BRR_MIN) && (usartdiv <= LPUART_BRR_MAX))
 8014c22:	f5a0 7240 	sub.w	r2, r0, #768	; 0x300
            break;
 8014c26:	e7db      	b.n	8014be0 <UART_SetConfig+0x304>
            usartdiv = (uint32_t)(UART_DIV_LPUART(HAL_RCC_GetPCLK1Freq(), huart->Init.BaudRate));
 8014c28:	f7fe f8ae 	bl	8012d88 <HAL_RCC_GetPCLK1Freq>
 8014c2c:	e7df      	b.n	8014bee <UART_SetConfig+0x312>
 8014c2e:	bf00      	nop
 8014c30:	000ffcff 	.word	0x000ffcff
 8014c34:	f4240000 	.word	0xf4240000

08014c38 <UART_AdvFeatureConfig>:
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_TXINVERT_INIT))
 8014c38:	6a43      	ldr	r3, [r0, #36]	; 0x24
 8014c3a:	07da      	lsls	r2, r3, #31
{
 8014c3c:	b410      	push	{r4}
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_TXINVERT_INIT))
 8014c3e:	d506      	bpl.n	8014c4e <UART_AdvFeatureConfig+0x16>
    MODIFY_REG(huart->Instance->CR2, USART_CR2_TXINV, huart->AdvancedInit.TxPinLevelInvert);
 8014c40:	6801      	ldr	r1, [r0, #0]
 8014c42:	6a84      	ldr	r4, [r0, #40]	; 0x28
 8014c44:	684a      	ldr	r2, [r1, #4]
 8014c46:	f422 3200 	bic.w	r2, r2, #131072	; 0x20000
 8014c4a:	4322      	orrs	r2, r4
 8014c4c:	604a      	str	r2, [r1, #4]
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_RXINVERT_INIT))
 8014c4e:	079c      	lsls	r4, r3, #30
 8014c50:	d506      	bpl.n	8014c60 <UART_AdvFeatureConfig+0x28>
    MODIFY_REG(huart->Instance->CR2, USART_CR2_RXINV, huart->AdvancedInit.RxPinLevelInvert);
 8014c52:	6801      	ldr	r1, [r0, #0]
 8014c54:	6ac4      	ldr	r4, [r0, #44]	; 0x2c
 8014c56:	684a      	ldr	r2, [r1, #4]
 8014c58:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
 8014c5c:	4322      	orrs	r2, r4
 8014c5e:	604a      	str	r2, [r1, #4]
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_DATAINVERT_INIT))
 8014c60:	0759      	lsls	r1, r3, #29
 8014c62:	d506      	bpl.n	8014c72 <UART_AdvFeatureConfig+0x3a>
    MODIFY_REG(huart->Instance->CR2, USART_CR2_DATAINV, huart->AdvancedInit.DataInvert);
 8014c64:	6801      	ldr	r1, [r0, #0]
 8014c66:	6b04      	ldr	r4, [r0, #48]	; 0x30
 8014c68:	684a      	ldr	r2, [r1, #4]
 8014c6a:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
 8014c6e:	4322      	orrs	r2, r4
 8014c70:	604a      	str	r2, [r1, #4]
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_SWAP_INIT))
 8014c72:	071a      	lsls	r2, r3, #28
 8014c74:	d506      	bpl.n	8014c84 <UART_AdvFeatureConfig+0x4c>
    MODIFY_REG(huart->Instance->CR2, USART_CR2_SWAP, huart->AdvancedInit.Swap);
 8014c76:	6801      	ldr	r1, [r0, #0]
 8014c78:	6b44      	ldr	r4, [r0, #52]	; 0x34
 8014c7a:	684a      	ldr	r2, [r1, #4]
 8014c7c:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
 8014c80:	4322      	orrs	r2, r4
 8014c82:	604a      	str	r2, [r1, #4]
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_RXOVERRUNDISABLE_INIT))
 8014c84:	06dc      	lsls	r4, r3, #27
 8014c86:	d506      	bpl.n	8014c96 <UART_AdvFeatureConfig+0x5e>
    MODIFY_REG(huart->Instance->CR3, USART_CR3_OVRDIS, huart->AdvancedInit.OverrunDisable);
 8014c88:	6801      	ldr	r1, [r0, #0]
 8014c8a:	6b84      	ldr	r4, [r0, #56]	; 0x38
 8014c8c:	688a      	ldr	r2, [r1, #8]
 8014c8e:	f422 5280 	bic.w	r2, r2, #4096	; 0x1000
 8014c92:	4322      	orrs	r2, r4
 8014c94:	608a      	str	r2, [r1, #8]
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_DMADISABLEONERROR_INIT))
 8014c96:	0699      	lsls	r1, r3, #26
 8014c98:	d506      	bpl.n	8014ca8 <UART_AdvFeatureConfig+0x70>
    MODIFY_REG(huart->Instance->CR3, USART_CR3_DDRE, huart->AdvancedInit.DMADisableonRxError);
 8014c9a:	6801      	ldr	r1, [r0, #0]
 8014c9c:	6bc4      	ldr	r4, [r0, #60]	; 0x3c
 8014c9e:	688a      	ldr	r2, [r1, #8]
 8014ca0:	f422 5200 	bic.w	r2, r2, #8192	; 0x2000
 8014ca4:	4322      	orrs	r2, r4
 8014ca6:	608a      	str	r2, [r1, #8]
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_AUTOBAUDRATE_INIT))
 8014ca8:	065a      	lsls	r2, r3, #25
 8014caa:	d509      	bpl.n	8014cc0 <UART_AdvFeatureConfig+0x88>
    MODIFY_REG(huart->Instance->CR2, USART_CR2_ABREN, huart->AdvancedInit.AutoBaudRateEnable);
 8014cac:	6801      	ldr	r1, [r0, #0]
 8014cae:	6c04      	ldr	r4, [r0, #64]	; 0x40
 8014cb0:	684a      	ldr	r2, [r1, #4]
 8014cb2:	f422 1280 	bic.w	r2, r2, #1048576	; 0x100000
 8014cb6:	4322      	orrs	r2, r4
    if (huart->AdvancedInit.AutoBaudRateEnable == UART_ADVFEATURE_AUTOBAUDRATE_ENABLE)
 8014cb8:	f5b4 1f80 	cmp.w	r4, #1048576	; 0x100000
    MODIFY_REG(huart->Instance->CR2, USART_CR2_ABREN, huart->AdvancedInit.AutoBaudRateEnable);
 8014cbc:	604a      	str	r2, [r1, #4]
    if (huart->AdvancedInit.AutoBaudRateEnable == UART_ADVFEATURE_AUTOBAUDRATE_ENABLE)
 8014cbe:	d00b      	beq.n	8014cd8 <UART_AdvFeatureConfig+0xa0>
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_MSBFIRST_INIT))
 8014cc0:	061b      	lsls	r3, r3, #24
 8014cc2:	d506      	bpl.n	8014cd2 <UART_AdvFeatureConfig+0x9a>
    MODIFY_REG(huart->Instance->CR2, USART_CR2_MSBFIRST, huart->AdvancedInit.MSBFirst);
 8014cc4:	6802      	ldr	r2, [r0, #0]
 8014cc6:	6c81      	ldr	r1, [r0, #72]	; 0x48
 8014cc8:	6853      	ldr	r3, [r2, #4]
 8014cca:	f423 2300 	bic.w	r3, r3, #524288	; 0x80000
 8014cce:	430b      	orrs	r3, r1
 8014cd0:	6053      	str	r3, [r2, #4]
}
 8014cd2:	f85d 4b04 	ldr.w	r4, [sp], #4
 8014cd6:	4770      	bx	lr
      MODIFY_REG(huart->Instance->CR2, USART_CR2_ABRMODE, huart->AdvancedInit.AutoBaudRateMode);
 8014cd8:	684a      	ldr	r2, [r1, #4]
 8014cda:	6c44      	ldr	r4, [r0, #68]	; 0x44
 8014cdc:	f422 02c0 	bic.w	r2, r2, #6291456	; 0x600000
 8014ce0:	4322      	orrs	r2, r4
 8014ce2:	604a      	str	r2, [r1, #4]
 8014ce4:	e7ec      	b.n	8014cc0 <UART_AdvFeatureConfig+0x88>
 8014ce6:	bf00      	nop

08014ce8 <UART_CheckIdleState>:
{
 8014ce8:	b570      	push	{r4, r5, r6, lr}
  huart->ErrorCode = HAL_UART_ERROR_NONE;
 8014cea:	2300      	movs	r3, #0
{
 8014cec:	4604      	mov	r4, r0
  huart->ErrorCode = HAL_UART_ERROR_NONE;
 8014cee:	67c3      	str	r3, [r0, #124]	; 0x7c
  tickstart = HAL_GetTick();
 8014cf0:	f7fa fda2 	bl	800f838 <HAL_GetTick>
  if ((huart->Instance->CR1 & USART_CR1_TE) == USART_CR1_TE)
 8014cf4:	6823      	ldr	r3, [r4, #0]
 8014cf6:	681a      	ldr	r2, [r3, #0]
 8014cf8:	0711      	lsls	r1, r2, #28
  tickstart = HAL_GetTick();
 8014cfa:	4605      	mov	r5, r0
  if ((huart->Instance->CR1 & USART_CR1_TE) == USART_CR1_TE)
 8014cfc:	d409      	bmi.n	8014d12 <UART_CheckIdleState+0x2a>
  if ((huart->Instance->CR1 & USART_CR1_RE) == USART_CR1_RE)
 8014cfe:	681a      	ldr	r2, [r3, #0]
 8014d00:	0752      	lsls	r2, r2, #29
 8014d02:	d420      	bmi.n	8014d46 <UART_CheckIdleState+0x5e>
  __HAL_UNLOCK(huart);
 8014d04:	2000      	movs	r0, #0
  huart->gState = HAL_UART_STATE_READY;
 8014d06:	2320      	movs	r3, #32
  __HAL_UNLOCK(huart);
 8014d08:	f884 0070 	strb.w	r0, [r4, #112]	; 0x70
  huart->gState = HAL_UART_STATE_READY;
 8014d0c:	6763      	str	r3, [r4, #116]	; 0x74
  huart->RxState = HAL_UART_STATE_READY;
 8014d0e:	67a3      	str	r3, [r4, #120]	; 0x78
}
 8014d10:	bd70      	pop	{r4, r5, r6, pc}
  while ((__HAL_UART_GET_FLAG(huart, Flag) ? SET : RESET) == Status)
 8014d12:	69de      	ldr	r6, [r3, #28]
 8014d14:	f416 1600 	ands.w	r6, r6, #2097152	; 0x200000
 8014d18:	d1f1      	bne.n	8014cfe <UART_CheckIdleState+0x16>
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
 8014d1a:	f7fa fd8d 	bl	800f838 <HAL_GetTick>
 8014d1e:	1b43      	subs	r3, r0, r5
 8014d20:	f1b3 7f00 	cmp.w	r3, #33554432	; 0x2000000
        CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE | USART_CR1_TXEIE));
 8014d24:	6823      	ldr	r3, [r4, #0]
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
 8014d26:	d3f4      	bcc.n	8014d12 <UART_CheckIdleState+0x2a>
        CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE | USART_CR1_TXEIE));
 8014d28:	681a      	ldr	r2, [r3, #0]
 8014d2a:	f422 72d0 	bic.w	r2, r2, #416	; 0x1a0
 8014d2e:	601a      	str	r2, [r3, #0]
        CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 8014d30:	689a      	ldr	r2, [r3, #8]
 8014d32:	f022 0201 	bic.w	r2, r2, #1
 8014d36:	609a      	str	r2, [r3, #8]
        huart->gState = HAL_UART_STATE_READY;
 8014d38:	2120      	movs	r1, #32
        __HAL_UNLOCK(huart);
 8014d3a:	f884 6070 	strb.w	r6, [r4, #112]	; 0x70
        huart->gState = HAL_UART_STATE_READY;
 8014d3e:	6761      	str	r1, [r4, #116]	; 0x74
      return HAL_TIMEOUT;
 8014d40:	2003      	movs	r0, #3
        huart->RxState = HAL_UART_STATE_READY;
 8014d42:	67a1      	str	r1, [r4, #120]	; 0x78
}
 8014d44:	bd70      	pop	{r4, r5, r6, pc}
  while ((__HAL_UART_GET_FLAG(huart, Flag) ? SET : RESET) == Status)
 8014d46:	69de      	ldr	r6, [r3, #28]
 8014d48:	f416 0680 	ands.w	r6, r6, #4194304	; 0x400000
 8014d4c:	d1da      	bne.n	8014d04 <UART_CheckIdleState+0x1c>
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
 8014d4e:	f7fa fd73 	bl	800f838 <HAL_GetTick>
 8014d52:	1b43      	subs	r3, r0, r5
 8014d54:	f1b3 7f00 	cmp.w	r3, #33554432	; 0x2000000
        CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE | USART_CR1_TXEIE));
 8014d58:	6823      	ldr	r3, [r4, #0]
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
 8014d5a:	d3f4      	bcc.n	8014d46 <UART_CheckIdleState+0x5e>
 8014d5c:	e7e4      	b.n	8014d28 <UART_CheckIdleState+0x40>
 8014d5e:	bf00      	nop

08014d60 <HAL_UART_Init>:
  if (huart == NULL)
 8014d60:	b370      	cbz	r0, 8014dc0 <HAL_UART_Init+0x60>
  if (huart->gState == HAL_UART_STATE_RESET)
 8014d62:	6f43      	ldr	r3, [r0, #116]	; 0x74
{
 8014d64:	b510      	push	{r4, lr}
 8014d66:	4604      	mov	r4, r0
  if (huart->gState == HAL_UART_STATE_RESET)
 8014d68:	b32b      	cbz	r3, 8014db6 <HAL_UART_Init+0x56>
  __HAL_UART_DISABLE(huart);
 8014d6a:	6822      	ldr	r2, [r4, #0]
  huart->gState = HAL_UART_STATE_BUSY;
 8014d6c:	2324      	movs	r3, #36	; 0x24
 8014d6e:	6763      	str	r3, [r4, #116]	; 0x74
  __HAL_UART_DISABLE(huart);
 8014d70:	6813      	ldr	r3, [r2, #0]
 8014d72:	f023 0301 	bic.w	r3, r3, #1
  if (UART_SetConfig(huart) == HAL_ERROR)
 8014d76:	4620      	mov	r0, r4
  __HAL_UART_DISABLE(huart);
 8014d78:	6013      	str	r3, [r2, #0]
  if (UART_SetConfig(huart) == HAL_ERROR)
 8014d7a:	f7ff fdaf 	bl	80148dc <UART_SetConfig>
 8014d7e:	2801      	cmp	r0, #1
 8014d80:	d017      	beq.n	8014db2 <HAL_UART_Init+0x52>
  if (huart->AdvancedInit.AdvFeatureInit != UART_ADVFEATURE_NO_INIT)
 8014d82:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8014d84:	b98b      	cbnz	r3, 8014daa <HAL_UART_Init+0x4a>
  CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
 8014d86:	6823      	ldr	r3, [r4, #0]
 8014d88:	685a      	ldr	r2, [r3, #4]
 8014d8a:	f422 4290 	bic.w	r2, r2, #18432	; 0x4800
 8014d8e:	605a      	str	r2, [r3, #4]
  CLEAR_BIT(huart->Instance->CR3, (USART_CR3_SCEN | USART_CR3_HDSEL | USART_CR3_IREN));
 8014d90:	689a      	ldr	r2, [r3, #8]
 8014d92:	f022 022a 	bic.w	r2, r2, #42	; 0x2a
 8014d96:	609a      	str	r2, [r3, #8]
  __HAL_UART_ENABLE(huart);
 8014d98:	681a      	ldr	r2, [r3, #0]
 8014d9a:	f042 0201 	orr.w	r2, r2, #1
  return (UART_CheckIdleState(huart));
 8014d9e:	4620      	mov	r0, r4
  __HAL_UART_ENABLE(huart);
 8014da0:	601a      	str	r2, [r3, #0]
}
 8014da2:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  return (UART_CheckIdleState(huart));
 8014da6:	f7ff bf9f 	b.w	8014ce8 <UART_CheckIdleState>
    UART_AdvFeatureConfig(huart);
 8014daa:	4620      	mov	r0, r4
 8014dac:	f7ff ff44 	bl	8014c38 <UART_AdvFeatureConfig>
 8014db0:	e7e9      	b.n	8014d86 <HAL_UART_Init+0x26>
}
 8014db2:	2001      	movs	r0, #1
 8014db4:	bd10      	pop	{r4, pc}
    huart->Lock = HAL_UNLOCKED;
 8014db6:	f880 3070 	strb.w	r3, [r0, #112]	; 0x70
    HAL_UART_MspInit(huart);
 8014dba:	f7ff fc05 	bl	80145c8 <HAL_UART_MspInit>
 8014dbe:	e7d4      	b.n	8014d6a <HAL_UART_Init+0xa>
}
 8014dc0:	2001      	movs	r0, #1
 8014dc2:	4770      	bx	lr

08014dc4 <UART_WaitOnFlagUntilTimeout>:
{
 8014dc4:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8014dc8:	9f08      	ldr	r7, [sp, #32]
 8014dca:	4680      	mov	r8, r0
 8014dcc:	460e      	mov	r6, r1
 8014dce:	4615      	mov	r5, r2
 8014dd0:	4699      	mov	r9, r3
  while ((__HAL_UART_GET_FLAG(huart, Flag) ? SET : RESET) == Status)
 8014dd2:	f8d8 2000 	ldr.w	r2, [r8]
 8014dd6:	e001      	b.n	8014ddc <UART_WaitOnFlagUntilTimeout+0x18>
    if (Timeout != HAL_MAX_DELAY)
 8014dd8:	1c7b      	adds	r3, r7, #1
 8014dda:	d10c      	bne.n	8014df6 <UART_WaitOnFlagUntilTimeout+0x32>
  while ((__HAL_UART_GET_FLAG(huart, Flag) ? SET : RESET) == Status)
 8014ddc:	69d4      	ldr	r4, [r2, #28]
 8014dde:	ea36 0304 	bics.w	r3, r6, r4
 8014de2:	bf0c      	ite	eq
 8014de4:	f04f 0c01 	moveq.w	ip, #1
 8014de8:	f04f 0c00 	movne.w	ip, #0
 8014dec:	45ac      	cmp	ip, r5
 8014dee:	d0f3      	beq.n	8014dd8 <UART_WaitOnFlagUntilTimeout+0x14>
  return HAL_OK;
 8014df0:	2000      	movs	r0, #0
}
 8014df2:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
 8014df6:	f7fa fd1f 	bl	800f838 <HAL_GetTick>
 8014dfa:	eba0 0009 	sub.w	r0, r0, r9
 8014dfe:	42b8      	cmp	r0, r7
 8014e00:	d801      	bhi.n	8014e06 <UART_WaitOnFlagUntilTimeout+0x42>
 8014e02:	2f00      	cmp	r7, #0
 8014e04:	d1e5      	bne.n	8014dd2 <UART_WaitOnFlagUntilTimeout+0xe>
        CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE | USART_CR1_TXEIE));
 8014e06:	f8d8 3000 	ldr.w	r3, [r8]
 8014e0a:	681a      	ldr	r2, [r3, #0]
 8014e0c:	f422 72d0 	bic.w	r2, r2, #416	; 0x1a0
 8014e10:	601a      	str	r2, [r3, #0]
        CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 8014e12:	689a      	ldr	r2, [r3, #8]
        huart->gState = HAL_UART_STATE_READY;
 8014e14:	2120      	movs	r1, #32
        __HAL_UNLOCK(huart);
 8014e16:	2400      	movs	r4, #0
        CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 8014e18:	f022 0201 	bic.w	r2, r2, #1
 8014e1c:	609a      	str	r2, [r3, #8]
        __HAL_UNLOCK(huart);
 8014e1e:	2003      	movs	r0, #3
        huart->gState = HAL_UART_STATE_READY;
 8014e20:	f8c8 1074 	str.w	r1, [r8, #116]	; 0x74
        __HAL_UNLOCK(huart);
 8014e24:	f888 4070 	strb.w	r4, [r8, #112]	; 0x70
        huart->RxState = HAL_UART_STATE_READY;
 8014e28:	f8c8 1078 	str.w	r1, [r8, #120]	; 0x78
        return HAL_TIMEOUT;
 8014e2c:	e7e1      	b.n	8014df2 <UART_WaitOnFlagUntilTimeout+0x2e>
 8014e2e:	bf00      	nop

08014e30 <HAL_UART_Transmit>:
{
 8014e30:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 8014e34:	4604      	mov	r4, r0
  if (huart->gState == HAL_UART_STATE_READY)
 8014e36:	6f40      	ldr	r0, [r0, #116]	; 0x74
 8014e38:	2820      	cmp	r0, #32
{
 8014e3a:	b083      	sub	sp, #12
  if (huart->gState == HAL_UART_STATE_READY)
 8014e3c:	d146      	bne.n	8014ecc <HAL_UART_Transmit+0x9c>
    if ((pData == NULL) || (Size == 0U))
 8014e3e:	460d      	mov	r5, r1
 8014e40:	2900      	cmp	r1, #0
 8014e42:	d03f      	beq.n	8014ec4 <HAL_UART_Transmit+0x94>
 8014e44:	4617      	mov	r7, r2
 8014e46:	2a00      	cmp	r2, #0
 8014e48:	d03c      	beq.n	8014ec4 <HAL_UART_Transmit+0x94>
 8014e4a:	461e      	mov	r6, r3
    __HAL_LOCK(huart);
 8014e4c:	f894 3070 	ldrb.w	r3, [r4, #112]	; 0x70
 8014e50:	2b01      	cmp	r3, #1
 8014e52:	d03b      	beq.n	8014ecc <HAL_UART_Transmit+0x9c>
 8014e54:	2301      	movs	r3, #1
 8014e56:	f884 3070 	strb.w	r3, [r4, #112]	; 0x70
    huart->ErrorCode = HAL_UART_ERROR_NONE;
 8014e5a:	f04f 0900 	mov.w	r9, #0
    huart->gState = HAL_UART_STATE_BUSY_TX;
 8014e5e:	2321      	movs	r3, #33	; 0x21
    huart->ErrorCode = HAL_UART_ERROR_NONE;
 8014e60:	f8c4 907c 	str.w	r9, [r4, #124]	; 0x7c
    huart->gState = HAL_UART_STATE_BUSY_TX;
 8014e64:	6763      	str	r3, [r4, #116]	; 0x74
    tickstart = HAL_GetTick();
 8014e66:	f7fa fce7 	bl	800f838 <HAL_GetTick>
    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
 8014e6a:	68a3      	ldr	r3, [r4, #8]
    huart->TxXferSize  = Size;
 8014e6c:	f8a4 7050 	strh.w	r7, [r4, #80]	; 0x50
    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
 8014e70:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
    huart->TxXferCount = Size;
 8014e74:	f8a4 7052 	strh.w	r7, [r4, #82]	; 0x52
    tickstart = HAL_GetTick();
 8014e78:	4680      	mov	r8, r0
    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
 8014e7a:	d02b      	beq.n	8014ed4 <HAL_UART_Transmit+0xa4>
    while (huart->TxXferCount > 0U)
 8014e7c:	f8b4 3052 	ldrh.w	r3, [r4, #82]	; 0x52
 8014e80:	b29b      	uxth	r3, r3
 8014e82:	b973      	cbnz	r3, 8014ea2 <HAL_UART_Transmit+0x72>
 8014e84:	e030      	b.n	8014ee8 <HAL_UART_Transmit+0xb8>
        huart->Instance->TDR = (uint8_t)(*pdata8bits & 0xFFU);
 8014e86:	6823      	ldr	r3, [r4, #0]
 8014e88:	f815 2b01 	ldrb.w	r2, [r5], #1
 8014e8c:	851a      	strh	r2, [r3, #40]	; 0x28
      huart->TxXferCount--;
 8014e8e:	f8b4 2052 	ldrh.w	r2, [r4, #82]	; 0x52
 8014e92:	3a01      	subs	r2, #1
 8014e94:	b292      	uxth	r2, r2
 8014e96:	f8a4 2052 	strh.w	r2, [r4, #82]	; 0x52
    while (huart->TxXferCount > 0U)
 8014e9a:	f8b4 2052 	ldrh.w	r2, [r4, #82]	; 0x52
 8014e9e:	b292      	uxth	r2, r2
 8014ea0:	b312      	cbz	r2, 8014ee8 <HAL_UART_Transmit+0xb8>
      if (UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TXE, RESET, tickstart, Timeout) != HAL_OK)
 8014ea2:	9600      	str	r6, [sp, #0]
 8014ea4:	4643      	mov	r3, r8
 8014ea6:	2200      	movs	r2, #0
 8014ea8:	2180      	movs	r1, #128	; 0x80
 8014eaa:	4620      	mov	r0, r4
 8014eac:	f7ff ff8a 	bl	8014dc4 <UART_WaitOnFlagUntilTimeout>
 8014eb0:	b9b0      	cbnz	r0, 8014ee0 <HAL_UART_Transmit+0xb0>
      if (pdata8bits == NULL)
 8014eb2:	2d00      	cmp	r5, #0
 8014eb4:	d1e7      	bne.n	8014e86 <HAL_UART_Transmit+0x56>
        huart->Instance->TDR = (uint16_t)(*pdata16bits & 0x01FFU);
 8014eb6:	f839 3b02 	ldrh.w	r3, [r9], #2
 8014eba:	6822      	ldr	r2, [r4, #0]
 8014ebc:	f3c3 0308 	ubfx	r3, r3, #0, #9
 8014ec0:	8513      	strh	r3, [r2, #40]	; 0x28
        pdata16bits++;
 8014ec2:	e7e4      	b.n	8014e8e <HAL_UART_Transmit+0x5e>
      return  HAL_ERROR;
 8014ec4:	2001      	movs	r0, #1
}
 8014ec6:	b003      	add	sp, #12
 8014ec8:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    return HAL_BUSY;
 8014ecc:	2002      	movs	r0, #2
}
 8014ece:	b003      	add	sp, #12
 8014ed0:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
 8014ed4:	6923      	ldr	r3, [r4, #16]
 8014ed6:	2b00      	cmp	r3, #0
 8014ed8:	d1d0      	bne.n	8014e7c <HAL_UART_Transmit+0x4c>
 8014eda:	46a9      	mov	r9, r5
      pdata8bits  = NULL;
 8014edc:	461d      	mov	r5, r3
 8014ede:	e7cd      	b.n	8014e7c <HAL_UART_Transmit+0x4c>
        return HAL_TIMEOUT;
 8014ee0:	2003      	movs	r0, #3
}
 8014ee2:	b003      	add	sp, #12
 8014ee4:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    if (UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TC, RESET, tickstart, Timeout) != HAL_OK)
 8014ee8:	9600      	str	r6, [sp, #0]
 8014eea:	4643      	mov	r3, r8
 8014eec:	2200      	movs	r2, #0
 8014eee:	2140      	movs	r1, #64	; 0x40
 8014ef0:	4620      	mov	r0, r4
 8014ef2:	f7ff ff67 	bl	8014dc4 <UART_WaitOnFlagUntilTimeout>
 8014ef6:	2800      	cmp	r0, #0
 8014ef8:	d1f2      	bne.n	8014ee0 <HAL_UART_Transmit+0xb0>
    huart->gState = HAL_UART_STATE_READY;
 8014efa:	2320      	movs	r3, #32
 8014efc:	6763      	str	r3, [r4, #116]	; 0x74
    __HAL_UNLOCK(huart);
 8014efe:	f884 0070 	strb.w	r0, [r4, #112]	; 0x70
    return HAL_OK;
 8014f02:	e7e0      	b.n	8014ec6 <HAL_UART_Transmit+0x96>

08014f04 <HAL_UART_Receive>:
{
 8014f04:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 8014f08:	4604      	mov	r4, r0
  if (huart->RxState == HAL_UART_STATE_READY)
 8014f0a:	6f80      	ldr	r0, [r0, #120]	; 0x78
 8014f0c:	2820      	cmp	r0, #32
{
 8014f0e:	b083      	sub	sp, #12
  if (huart->RxState == HAL_UART_STATE_READY)
 8014f10:	d149      	bne.n	8014fa6 <HAL_UART_Receive+0xa2>
    if ((pData == NULL) || (Size == 0U))
 8014f12:	460d      	mov	r5, r1
 8014f14:	2900      	cmp	r1, #0
 8014f16:	d042      	beq.n	8014f9e <HAL_UART_Receive+0x9a>
 8014f18:	4617      	mov	r7, r2
 8014f1a:	2a00      	cmp	r2, #0
 8014f1c:	d03f      	beq.n	8014f9e <HAL_UART_Receive+0x9a>
 8014f1e:	461e      	mov	r6, r3
    __HAL_LOCK(huart);
 8014f20:	f894 3070 	ldrb.w	r3, [r4, #112]	; 0x70
 8014f24:	2b01      	cmp	r3, #1
 8014f26:	d03e      	beq.n	8014fa6 <HAL_UART_Receive+0xa2>
 8014f28:	2301      	movs	r3, #1
 8014f2a:	f884 3070 	strb.w	r3, [r4, #112]	; 0x70
    huart->ErrorCode = HAL_UART_ERROR_NONE;
 8014f2e:	f04f 0800 	mov.w	r8, #0
    huart->RxState = HAL_UART_STATE_BUSY_RX;
 8014f32:	2322      	movs	r3, #34	; 0x22
    huart->ErrorCode = HAL_UART_ERROR_NONE;
 8014f34:	f8c4 807c 	str.w	r8, [r4, #124]	; 0x7c
    huart->RxState = HAL_UART_STATE_BUSY_RX;
 8014f38:	67a3      	str	r3, [r4, #120]	; 0x78
    tickstart = HAL_GetTick();
 8014f3a:	f7fa fc7d 	bl	800f838 <HAL_GetTick>
    UART_MASK_COMPUTATION(huart);
 8014f3e:	68a3      	ldr	r3, [r4, #8]
    huart->RxXferSize  = Size;
 8014f40:	f8a4 7058 	strh.w	r7, [r4, #88]	; 0x58
    UART_MASK_COMPUTATION(huart);
 8014f44:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
    huart->RxXferCount = Size;
 8014f48:	f8a4 705a 	strh.w	r7, [r4, #90]	; 0x5a
    tickstart = HAL_GetTick();
 8014f4c:	4681      	mov	r9, r0
    UART_MASK_COMPUTATION(huart);
 8014f4e:	d02e      	beq.n	8014fae <HAL_UART_Receive+0xaa>
 8014f50:	2b00      	cmp	r3, #0
 8014f52:	d141      	bne.n	8014fd8 <HAL_UART_Receive+0xd4>
 8014f54:	6923      	ldr	r3, [r4, #16]
 8014f56:	2b00      	cmp	r3, #0
 8014f58:	d049      	beq.n	8014fee <HAL_UART_Receive+0xea>
 8014f5a:	277f      	movs	r7, #127	; 0x7f
 8014f5c:	f8a4 705c 	strh.w	r7, [r4, #92]	; 0x5c
      pdata16bits = NULL;
 8014f60:	f04f 0800 	mov.w	r8, #0
 8014f64:	e007      	b.n	8014f76 <HAL_UART_Receive+0x72>
        *pdata8bits = (uint8_t)(huart->Instance->RDR & (uint8_t)uhMask);
 8014f66:	f805 3b01 	strb.w	r3, [r5], #1
      huart->RxXferCount--;
 8014f6a:	f8b4 205a 	ldrh.w	r2, [r4, #90]	; 0x5a
 8014f6e:	3a01      	subs	r2, #1
 8014f70:	b292      	uxth	r2, r2
 8014f72:	f8a4 205a 	strh.w	r2, [r4, #90]	; 0x5a
    while (huart->RxXferCount > 0U)
 8014f76:	f8b4 305a 	ldrh.w	r3, [r4, #90]	; 0x5a
 8014f7a:	b29b      	uxth	r3, r3
 8014f7c:	b303      	cbz	r3, 8014fc0 <HAL_UART_Receive+0xbc>
      if (UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_RXNE, RESET, tickstart, Timeout) != HAL_OK)
 8014f7e:	9600      	str	r6, [sp, #0]
 8014f80:	464b      	mov	r3, r9
 8014f82:	2200      	movs	r2, #0
 8014f84:	2120      	movs	r1, #32
 8014f86:	4620      	mov	r0, r4
 8014f88:	f7ff ff1c 	bl	8014dc4 <UART_WaitOnFlagUntilTimeout>
 8014f8c:	bb00      	cbnz	r0, 8014fd0 <HAL_UART_Receive+0xcc>
        *pdata16bits = (uint16_t)(huart->Instance->RDR & uhMask);
 8014f8e:	6823      	ldr	r3, [r4, #0]
 8014f90:	8c9b      	ldrh	r3, [r3, #36]	; 0x24
 8014f92:	403b      	ands	r3, r7
      if (pdata8bits == NULL)
 8014f94:	2d00      	cmp	r5, #0
 8014f96:	d1e6      	bne.n	8014f66 <HAL_UART_Receive+0x62>
        *pdata16bits = (uint16_t)(huart->Instance->RDR & uhMask);
 8014f98:	f828 3b02 	strh.w	r3, [r8], #2
        pdata16bits++;
 8014f9c:	e7e5      	b.n	8014f6a <HAL_UART_Receive+0x66>
      return  HAL_ERROR;
 8014f9e:	2001      	movs	r0, #1
}
 8014fa0:	b003      	add	sp, #12
 8014fa2:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    return HAL_BUSY;
 8014fa6:	2002      	movs	r0, #2
}
 8014fa8:	b003      	add	sp, #12
 8014faa:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    UART_MASK_COMPUTATION(huart);
 8014fae:	6923      	ldr	r3, [r4, #16]
 8014fb0:	b9cb      	cbnz	r3, 8014fe6 <HAL_UART_Receive+0xe2>
 8014fb2:	f240 17ff 	movw	r7, #511	; 0x1ff
 8014fb6:	46a8      	mov	r8, r5
 8014fb8:	f8a4 705c 	strh.w	r7, [r4, #92]	; 0x5c
      pdata8bits  = NULL;
 8014fbc:	461d      	mov	r5, r3
 8014fbe:	e7da      	b.n	8014f76 <HAL_UART_Receive+0x72>
    __HAL_UNLOCK(huart);
 8014fc0:	2000      	movs	r0, #0
    huart->RxState = HAL_UART_STATE_READY;
 8014fc2:	2320      	movs	r3, #32
 8014fc4:	67a3      	str	r3, [r4, #120]	; 0x78
    __HAL_UNLOCK(huart);
 8014fc6:	f884 0070 	strb.w	r0, [r4, #112]	; 0x70
}
 8014fca:	b003      	add	sp, #12
 8014fcc:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
        return HAL_TIMEOUT;
 8014fd0:	2003      	movs	r0, #3
}
 8014fd2:	b003      	add	sp, #12
 8014fd4:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    UART_MASK_COMPUTATION(huart);
 8014fd8:	f1b3 5f80 	cmp.w	r3, #268435456	; 0x10000000
 8014fdc:	d00b      	beq.n	8014ff6 <HAL_UART_Receive+0xf2>
 8014fde:	f8a4 805c 	strh.w	r8, [r4, #92]	; 0x5c
 8014fe2:	4647      	mov	r7, r8
 8014fe4:	e7bc      	b.n	8014f60 <HAL_UART_Receive+0x5c>
 8014fe6:	27ff      	movs	r7, #255	; 0xff
 8014fe8:	f8a4 705c 	strh.w	r7, [r4, #92]	; 0x5c
    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
 8014fec:	e7c3      	b.n	8014f76 <HAL_UART_Receive+0x72>
    UART_MASK_COMPUTATION(huart);
 8014fee:	27ff      	movs	r7, #255	; 0xff
 8014ff0:	f8a4 705c 	strh.w	r7, [r4, #92]	; 0x5c
 8014ff4:	e7b4      	b.n	8014f60 <HAL_UART_Receive+0x5c>
 8014ff6:	6923      	ldr	r3, [r4, #16]
 8014ff8:	2b00      	cmp	r3, #0
 8014ffa:	d0ae      	beq.n	8014f5a <HAL_UART_Receive+0x56>
 8014ffc:	273f      	movs	r7, #63	; 0x3f
 8014ffe:	f8a4 705c 	strh.w	r7, [r4, #92]	; 0x5c
 8015002:	e7ad      	b.n	8014f60 <HAL_UART_Receive+0x5c>

08015004 <HAL_UARTEx_WakeupCallback>:
  UNUSED(huart);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_UARTEx_WakeupCallback can be implemented in the user file.
   */
}
 8015004:	4770      	bx	lr
 8015006:	bf00      	nop

08015008 <USB_CoreInit>:
  * @param  cfg pointer to a USB_OTG_CfgTypeDef structure that contains
  *         the configuration information for the specified USBx peripheral.
  * @retval HAL status
  */
HAL_StatusTypeDef USB_CoreInit(USB_OTG_GlobalTypeDef *USBx, USB_OTG_CfgTypeDef cfg)
{
 8015008:	b084      	sub	sp, #16
 801500a:	f10d 0c04 	add.w	ip, sp, #4
 801500e:	e88c 000e 	stmia.w	ip, {r1, r2, r3}
  HAL_StatusTypeDef ret;

  if (cfg.phy_itface == USB_OTG_ULPI_PHY)
 8015012:	9b06      	ldr	r3, [sp, #24]
 8015014:	2b01      	cmp	r3, #1
{
 8015016:	4602      	mov	r2, r0
  if (cfg.phy_itface == USB_OTG_ULPI_PHY)
 8015018:	d126      	bne.n	8015068 <USB_CoreInit+0x60>
  {
    USBx->GCCFG &= ~(USB_OTG_GCCFG_PWRDWN);
 801501a:	6b83      	ldr	r3, [r0, #56]	; 0x38
    /* Init The ULPI Interface */
    USBx->GUSBCFG &= ~(USB_OTG_GUSBCFG_TSDPS | USB_OTG_GUSBCFG_ULPIFSLS | USB_OTG_GUSBCFG_PHYSEL);

    /* Select vbus source */
    USBx->GUSBCFG &= ~(USB_OTG_GUSBCFG_ULPIEVBUSD | USB_OTG_GUSBCFG_ULPIEVBUSI);
    if (cfg.use_external_vbus == 1U)
 801501c:	990d      	ldr	r1, [sp, #52]	; 0x34
    USBx->GCCFG &= ~(USB_OTG_GCCFG_PWRDWN);
 801501e:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 8015022:	6383      	str	r3, [r0, #56]	; 0x38
    USBx->GUSBCFG &= ~(USB_OTG_GUSBCFG_TSDPS | USB_OTG_GUSBCFG_ULPIFSLS | USB_OTG_GUSBCFG_PHYSEL);
 8015024:	68c3      	ldr	r3, [r0, #12]
 8015026:	f423 0384 	bic.w	r3, r3, #4325376	; 0x420000
 801502a:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 801502e:	60c3      	str	r3, [r0, #12]
    USBx->GUSBCFG &= ~(USB_OTG_GUSBCFG_ULPIEVBUSD | USB_OTG_GUSBCFG_ULPIEVBUSI);
 8015030:	68c3      	ldr	r3, [r0, #12]
    if (cfg.use_external_vbus == 1U)
 8015032:	2901      	cmp	r1, #1
    USBx->GUSBCFG &= ~(USB_OTG_GUSBCFG_ULPIEVBUSD | USB_OTG_GUSBCFG_ULPIEVBUSI);
 8015034:	f423 1340 	bic.w	r3, r3, #3145728	; 0x300000
 8015038:	60c3      	str	r3, [r0, #12]
    if (cfg.use_external_vbus == 1U)
 801503a:	d03b      	beq.n	80150b4 <USB_CoreInit+0xac>
{
 801503c:	4b22      	ldr	r3, [pc, #136]	; (80150c8 <USB_CoreInit+0xc0>)
 801503e:	e001      	b.n	8015044 <USB_CoreInit+0x3c>
  uint32_t count = 0U;

  /* Wait for AHB master IDLE state. */
  do
  {
    if (++count > 200000U)
 8015040:	3b01      	subs	r3, #1
 8015042:	d03c      	beq.n	80150be <USB_CoreInit+0xb6>
    {
      return HAL_TIMEOUT;
    }
  }
  while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_AHBIDL) == 0U);
 8015044:	6911      	ldr	r1, [r2, #16]
 8015046:	2900      	cmp	r1, #0
 8015048:	dafa      	bge.n	8015040 <USB_CoreInit+0x38>

  /* Core Soft Reset */
  count = 0U;
  USBx->GRSTCTL |= USB_OTG_GRSTCTL_CSRST;
 801504a:	6913      	ldr	r3, [r2, #16]
 801504c:	491e      	ldr	r1, [pc, #120]	; (80150c8 <USB_CoreInit+0xc0>)
 801504e:	f043 0301 	orr.w	r3, r3, #1
 8015052:	6113      	str	r3, [r2, #16]

  do
  {
    if (++count > 200000U)
 8015054:	e001      	b.n	801505a <USB_CoreInit+0x52>
 8015056:	3901      	subs	r1, #1
 8015058:	d031      	beq.n	80150be <USB_CoreInit+0xb6>
    {
      return HAL_TIMEOUT;
    }
  }
  while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_CSRST) == USB_OTG_GRSTCTL_CSRST);
 801505a:	6913      	ldr	r3, [r2, #16]
 801505c:	f013 0301 	ands.w	r3, r3, #1
 8015060:	d1f9      	bne.n	8015056 <USB_CoreInit+0x4e>

  return HAL_OK;
 8015062:	4618      	mov	r0, r3
}
 8015064:	b004      	add	sp, #16
 8015066:	4770      	bx	lr
    USBx->GUSBCFG |= USB_OTG_GUSBCFG_PHYSEL;
 8015068:	68c1      	ldr	r1, [r0, #12]
 801506a:	4b17      	ldr	r3, [pc, #92]	; (80150c8 <USB_CoreInit+0xc0>)
 801506c:	f041 0140 	orr.w	r1, r1, #64	; 0x40
 8015070:	60c1      	str	r1, [r0, #12]
    if (++count > 200000U)
 8015072:	e001      	b.n	8015078 <USB_CoreInit+0x70>
 8015074:	3b01      	subs	r3, #1
 8015076:	d025      	beq.n	80150c4 <USB_CoreInit+0xbc>
  while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_AHBIDL) == 0U);
 8015078:	6911      	ldr	r1, [r2, #16]
 801507a:	2900      	cmp	r1, #0
 801507c:	dafa      	bge.n	8015074 <USB_CoreInit+0x6c>
  USBx->GRSTCTL |= USB_OTG_GRSTCTL_CSRST;
 801507e:	6913      	ldr	r3, [r2, #16]
 8015080:	4911      	ldr	r1, [pc, #68]	; (80150c8 <USB_CoreInit+0xc0>)
 8015082:	f043 0301 	orr.w	r3, r3, #1
 8015086:	6113      	str	r3, [r2, #16]
    if (++count > 200000U)
 8015088:	e001      	b.n	801508e <USB_CoreInit+0x86>
 801508a:	3901      	subs	r1, #1
 801508c:	d01a      	beq.n	80150c4 <USB_CoreInit+0xbc>
  while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_CSRST) == USB_OTG_GRSTCTL_CSRST);
 801508e:	6913      	ldr	r3, [r2, #16]
 8015090:	f013 0301 	ands.w	r3, r3, #1
 8015094:	d1f9      	bne.n	801508a <USB_CoreInit+0x82>
  return HAL_OK;
 8015096:	4618      	mov	r0, r3
    if (cfg.battery_charging_enable == 0U)
 8015098:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 801509a:	b92b      	cbnz	r3, 80150a8 <USB_CoreInit+0xa0>
      USBx->GCCFG |= USB_OTG_GCCFG_PWRDWN;
 801509c:	6b93      	ldr	r3, [r2, #56]	; 0x38
 801509e:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 80150a2:	6393      	str	r3, [r2, #56]	; 0x38
}
 80150a4:	b004      	add	sp, #16
 80150a6:	4770      	bx	lr
      USBx->GCCFG &= ~(USB_OTG_GCCFG_PWRDWN);
 80150a8:	6b93      	ldr	r3, [r2, #56]	; 0x38
 80150aa:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 80150ae:	6393      	str	r3, [r2, #56]	; 0x38
}
 80150b0:	b004      	add	sp, #16
 80150b2:	4770      	bx	lr
      USBx->GUSBCFG |= USB_OTG_GUSBCFG_ULPIEVBUSD;
 80150b4:	68c3      	ldr	r3, [r0, #12]
 80150b6:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
 80150ba:	60c3      	str	r3, [r0, #12]
 80150bc:	e7be      	b.n	801503c <USB_CoreInit+0x34>
      return HAL_TIMEOUT;
 80150be:	2003      	movs	r0, #3
}
 80150c0:	b004      	add	sp, #16
 80150c2:	4770      	bx	lr
      return HAL_TIMEOUT;
 80150c4:	2003      	movs	r0, #3
 80150c6:	e7e7      	b.n	8015098 <USB_CoreInit+0x90>
 80150c8:	00030d40 	.word	0x00030d40

080150cc <USB_SetTurnaroundTime>:
  if (speed == USBD_FS_SPEED)
 80150cc:	2a02      	cmp	r2, #2
{
 80150ce:	4603      	mov	r3, r0
  if (speed == USBD_FS_SPEED)
 80150d0:	d00b      	beq.n	80150ea <USB_SetTurnaroundTime+0x1e>
 80150d2:	f44f 5c10 	mov.w	ip, #9216	; 0x2400
  USBx->GUSBCFG &= ~USB_OTG_GUSBCFG_TRDT;
 80150d6:	68d9      	ldr	r1, [r3, #12]
 80150d8:	f421 5170 	bic.w	r1, r1, #15360	; 0x3c00
 80150dc:	60d9      	str	r1, [r3, #12]
  USBx->GUSBCFG |= (uint32_t)((UsbTrd << 10) & USB_OTG_GUSBCFG_TRDT);
 80150de:	68da      	ldr	r2, [r3, #12]
 80150e0:	ea42 020c 	orr.w	r2, r2, ip
}
 80150e4:	2000      	movs	r0, #0
  USBx->GUSBCFG |= (uint32_t)((UsbTrd << 10) & USB_OTG_GUSBCFG_TRDT);
 80150e6:	60da      	str	r2, [r3, #12]
}
 80150e8:	4770      	bx	lr
    if ((hclk >= 14200000U) && (hclk < 15000000U))
 80150ea:	4a26      	ldr	r2, [pc, #152]	; (8015184 <USB_SetTurnaroundTime+0xb8>)
 80150ec:	4826      	ldr	r0, [pc, #152]	; (8015188 <USB_SetTurnaroundTime+0xbc>)
 80150ee:	440a      	add	r2, r1
 80150f0:	4282      	cmp	r2, r0
 80150f2:	d932      	bls.n	801515a <USB_SetTurnaroundTime+0x8e>
    else if ((hclk >= 15000000U) && (hclk < 16000000U))
 80150f4:	4a25      	ldr	r2, [pc, #148]	; (801518c <USB_SetTurnaroundTime+0xc0>)
 80150f6:	4826      	ldr	r0, [pc, #152]	; (8015190 <USB_SetTurnaroundTime+0xc4>)
 80150f8:	440a      	add	r2, r1
 80150fa:	4282      	cmp	r2, r0
 80150fc:	d930      	bls.n	8015160 <USB_SetTurnaroundTime+0x94>
    else if ((hclk >= 16000000U) && (hclk < 17200000U))
 80150fe:	4825      	ldr	r0, [pc, #148]	; (8015194 <USB_SetTurnaroundTime+0xc8>)
 8015100:	f5a1 0274 	sub.w	r2, r1, #15990784	; 0xf40000
 8015104:	f5a2 5210 	sub.w	r2, r2, #9216	; 0x2400
 8015108:	4282      	cmp	r2, r0
 801510a:	d92c      	bls.n	8015166 <USB_SetTurnaroundTime+0x9a>
    else if ((hclk >= 17200000U) && (hclk < 18500000U))
 801510c:	4822      	ldr	r0, [pc, #136]	; (8015198 <USB_SetTurnaroundTime+0xcc>)
 801510e:	f1a1 7283 	sub.w	r2, r1, #17170432	; 0x1060000
 8015112:	f5a2 42e7 	sub.w	r2, r2, #29568	; 0x7380
 8015116:	4282      	cmp	r2, r0
 8015118:	d328      	bcc.n	801516c <USB_SetTurnaroundTime+0xa0>
    else if ((hclk >= 18500000U) && (hclk < 20000000U))
 801511a:	4a20      	ldr	r2, [pc, #128]	; (801519c <USB_SetTurnaroundTime+0xd0>)
 801511c:	4820      	ldr	r0, [pc, #128]	; (80151a0 <USB_SetTurnaroundTime+0xd4>)
 801511e:	440a      	add	r2, r1
 8015120:	4282      	cmp	r2, r0
 8015122:	d926      	bls.n	8015172 <USB_SetTurnaroundTime+0xa6>
    else if ((hclk >= 20000000U) && (hclk < 21800000U))
 8015124:	4a1f      	ldr	r2, [pc, #124]	; (80151a4 <USB_SetTurnaroundTime+0xd8>)
 8015126:	4820      	ldr	r0, [pc, #128]	; (80151a8 <USB_SetTurnaroundTime+0xdc>)
 8015128:	440a      	add	r2, r1
 801512a:	4282      	cmp	r2, r0
 801512c:	d324      	bcc.n	8015178 <USB_SetTurnaroundTime+0xac>
    else if ((hclk >= 21800000U) && (hclk < 24000000U))
 801512e:	4a1f      	ldr	r2, [pc, #124]	; (80151ac <USB_SetTurnaroundTime+0xe0>)
 8015130:	481f      	ldr	r0, [pc, #124]	; (80151b0 <USB_SetTurnaroundTime+0xe4>)
 8015132:	440a      	add	r2, r1
 8015134:	4282      	cmp	r2, r0
 8015136:	d3cc      	bcc.n	80150d2 <USB_SetTurnaroundTime+0x6>
    else if ((hclk >= 24000000U) && (hclk < 27700000U))
 8015138:	481e      	ldr	r0, [pc, #120]	; (80151b4 <USB_SetTurnaroundTime+0xe8>)
 801513a:	f1a1 72b7 	sub.w	r2, r1, #23986176	; 0x16e0000
 801513e:	f5a2 5258 	sub.w	r2, r2, #13824	; 0x3600
 8015142:	4282      	cmp	r2, r0
 8015144:	d31b      	bcc.n	801517e <USB_SetTurnaroundTime+0xb2>
    else if ((hclk >= 27700000U) && (hclk < 32000000U))
 8015146:	4a1c      	ldr	r2, [pc, #112]	; (80151b8 <USB_SetTurnaroundTime+0xec>)
 8015148:	481c      	ldr	r0, [pc, #112]	; (80151bc <USB_SetTurnaroundTime+0xf0>)
 801514a:	440a      	add	r2, r1
 801514c:	4282      	cmp	r2, r0
 801514e:	bf34      	ite	cc
 8015150:	f44f 5ce0 	movcc.w	ip, #7168	; 0x1c00
 8015154:	f44f 5cc0 	movcs.w	ip, #6144	; 0x1800
 8015158:	e7bd      	b.n	80150d6 <USB_SetTurnaroundTime+0xa>
 801515a:	f44f 5c70 	mov.w	ip, #15360	; 0x3c00
 801515e:	e7ba      	b.n	80150d6 <USB_SetTurnaroundTime+0xa>
 8015160:	f44f 5c60 	mov.w	ip, #14336	; 0x3800
 8015164:	e7b7      	b.n	80150d6 <USB_SetTurnaroundTime+0xa>
 8015166:	f44f 5c50 	mov.w	ip, #13312	; 0x3400
 801516a:	e7b4      	b.n	80150d6 <USB_SetTurnaroundTime+0xa>
 801516c:	f44f 5c40 	mov.w	ip, #12288	; 0x3000
 8015170:	e7b1      	b.n	80150d6 <USB_SetTurnaroundTime+0xa>
 8015172:	f44f 5c30 	mov.w	ip, #11264	; 0x2c00
 8015176:	e7ae      	b.n	80150d6 <USB_SetTurnaroundTime+0xa>
 8015178:	f44f 5c20 	mov.w	ip, #10240	; 0x2800
 801517c:	e7ab      	b.n	80150d6 <USB_SetTurnaroundTime+0xa>
 801517e:	f44f 5c00 	mov.w	ip, #8192	; 0x2000
 8015182:	e7a8      	b.n	80150d6 <USB_SetTurnaroundTime+0xa>
 8015184:	ff275340 	.word	0xff275340
 8015188:	000c34ff 	.word	0x000c34ff
 801518c:	ff1b1e40 	.word	0xff1b1e40
 8015190:	000f423f 	.word	0x000f423f
 8015194:	00124f7f 	.word	0x00124f7f
 8015198:	0013d620 	.word	0x0013d620
 801519c:	fee5b660 	.word	0xfee5b660
 80151a0:	0016e35f 	.word	0x0016e35f
 80151a4:	feced300 	.word	0xfeced300
 80151a8:	001b7740 	.word	0x001b7740
 80151ac:	feb35bc0 	.word	0xfeb35bc0
 80151b0:	002191c0 	.word	0x002191c0
 80151b4:	00387520 	.word	0x00387520
 80151b8:	fe5954e0 	.word	0xfe5954e0
 80151bc:	00419ce0 	.word	0x00419ce0

080151c0 <USB_EnableGlobalInt>:
{
 80151c0:	4603      	mov	r3, r0
}
 80151c2:	2000      	movs	r0, #0
  USBx->GAHBCFG |= USB_OTG_GAHBCFG_GINT;
 80151c4:	689a      	ldr	r2, [r3, #8]
 80151c6:	f042 0201 	orr.w	r2, r2, #1
 80151ca:	609a      	str	r2, [r3, #8]
}
 80151cc:	4770      	bx	lr
 80151ce:	bf00      	nop

080151d0 <USB_DisableGlobalInt>:
{
 80151d0:	4603      	mov	r3, r0
}
 80151d2:	2000      	movs	r0, #0
  USBx->GAHBCFG &= ~USB_OTG_GAHBCFG_GINT;
 80151d4:	689a      	ldr	r2, [r3, #8]
 80151d6:	f022 0201 	bic.w	r2, r2, #1
 80151da:	609a      	str	r2, [r3, #8]
}
 80151dc:	4770      	bx	lr
 80151de:	bf00      	nop

080151e0 <USB_SetCurrentMode>:
{
 80151e0:	b508      	push	{r3, lr}
  USBx->GUSBCFG &= ~(USB_OTG_GUSBCFG_FHMOD | USB_OTG_GUSBCFG_FDMOD);
 80151e2:	68c3      	ldr	r3, [r0, #12]
  if (mode == USB_HOST_MODE)
 80151e4:	2901      	cmp	r1, #1
  USBx->GUSBCFG &= ~(USB_OTG_GUSBCFG_FHMOD | USB_OTG_GUSBCFG_FDMOD);
 80151e6:	f023 43c0 	bic.w	r3, r3, #1610612736	; 0x60000000
 80151ea:	60c3      	str	r3, [r0, #12]
  if (mode == USB_HOST_MODE)
 80151ec:	d00b      	beq.n	8015206 <USB_SetCurrentMode+0x26>
  else if (mode == USB_DEVICE_MODE)
 80151ee:	b941      	cbnz	r1, 8015202 <USB_SetCurrentMode+0x22>
    USBx->GUSBCFG |= USB_OTG_GUSBCFG_FDMOD;
 80151f0:	68c3      	ldr	r3, [r0, #12]
 80151f2:	f043 4380 	orr.w	r3, r3, #1073741824	; 0x40000000
 80151f6:	60c3      	str	r3, [r0, #12]
  HAL_Delay(50U);
 80151f8:	2032      	movs	r0, #50	; 0x32
 80151fa:	f00d fbdf 	bl	80229bc <HAL_Delay>
  return HAL_OK;
 80151fe:	2000      	movs	r0, #0
}
 8015200:	bd08      	pop	{r3, pc}
    return HAL_ERROR;
 8015202:	2001      	movs	r0, #1
}
 8015204:	bd08      	pop	{r3, pc}
    USBx->GUSBCFG |= USB_OTG_GUSBCFG_FHMOD;
 8015206:	68c3      	ldr	r3, [r0, #12]
 8015208:	f043 5300 	orr.w	r3, r3, #536870912	; 0x20000000
 801520c:	60c3      	str	r3, [r0, #12]
 801520e:	e7f3      	b.n	80151f8 <USB_SetCurrentMode+0x18>

08015210 <USB_DevInit>:
{
 8015210:	b084      	sub	sp, #16
 8015212:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 8015216:	ac08      	add	r4, sp, #32
 8015218:	e884 000e 	stmia.w	r4, {r1, r2, r3}
 801521c:	9d12      	ldr	r5, [sp, #72]	; 0x48
  for (i = 0U; i < 15U; i++)
 801521e:	2200      	movs	r2, #0
{
 8015220:	4603      	mov	r3, r0
 8015222:	460c      	mov	r4, r1
    USBx->DIEPTXF[i] = 0U;
 8015224:	4610      	mov	r0, r2
 8015226:	f102 0140 	add.w	r1, r2, #64	; 0x40
 801522a:	eb03 0181 	add.w	r1, r3, r1, lsl #2
  for (i = 0U; i < 15U; i++)
 801522e:	3201      	adds	r2, #1
 8015230:	2a0f      	cmp	r2, #15
    USBx->DIEPTXF[i] = 0U;
 8015232:	6048      	str	r0, [r1, #4]
  for (i = 0U; i < 15U; i++)
 8015234:	d1f7      	bne.n	8015226 <USB_DevInit+0x16>
    USBx->GCCFG &= ~USB_OTG_GCCFG_VBDEN;
 8015236:	6b9a      	ldr	r2, [r3, #56]	; 0x38
  if (cfg.vbus_sensing_enable == 0U)
 8015238:	2d00      	cmp	r5, #0
 801523a:	f040 8096 	bne.w	801536a <USB_DevInit+0x15a>
    USBx->GCCFG &= ~USB_OTG_GCCFG_VBDEN;
 801523e:	f422 1200 	bic.w	r2, r2, #2097152	; 0x200000
 8015242:	639a      	str	r2, [r3, #56]	; 0x38
    USBx->GOTGCTL |= USB_OTG_GOTGCTL_BVALOEN;
 8015244:	681a      	ldr	r2, [r3, #0]
 8015246:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 801524a:	601a      	str	r2, [r3, #0]
    USBx->GOTGCTL |= USB_OTG_GOTGCTL_BVALOVAL;
 801524c:	681a      	ldr	r2, [r3, #0]
 801524e:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 8015252:	601a      	str	r2, [r3, #0]
  USBx_PCGCCTL = 0U;
 8015254:	2200      	movs	r2, #0
 8015256:	f8c3 2e00 	str.w	r2, [r3, #3584]	; 0xe00
  USBx_DEVICE->DCFG |= DCFG_FRAME_INTERVAL_80;
 801525a:	f8d3 2800 	ldr.w	r2, [r3, #2048]	; 0x800
 801525e:	f8c3 2800 	str.w	r2, [r3, #2048]	; 0x800
  USBx_DEVICE->DCFG |= speed;
 8015262:	f8d3 2800 	ldr.w	r2, [r3, #2048]	; 0x800
  USBx->GRSTCTL = (USB_OTG_GRSTCTL_TXFFLSH | (num << 6));
 8015266:	f44f 6184 	mov.w	r1, #1056	; 0x420
  USBx_DEVICE->DCFG |= speed;
 801526a:	f042 0203 	orr.w	r2, r2, #3
 801526e:	f8c3 2800 	str.w	r2, [r3, #2048]	; 0x800
  USBx_DEVICE->DCFG |= DCFG_FRAME_INTERVAL_80;
 8015272:	f503 6c00 	add.w	ip, r3, #2048	; 0x800
  USBx->GRSTCTL = (USB_OTG_GRSTCTL_TXFFLSH | (num << 6));
 8015276:	4a41      	ldr	r2, [pc, #260]	; (801537c <USB_DevInit+0x16c>)
 8015278:	6119      	str	r1, [r3, #16]
    if (++count > 200000U)
 801527a:	e001      	b.n	8015280 <USB_DevInit+0x70>
 801527c:	3a01      	subs	r2, #1
 801527e:	d07a      	beq.n	8015376 <USB_DevInit+0x166>
  while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_TXFFLSH) == USB_OTG_GRSTCTL_TXFFLSH);
 8015280:	6918      	ldr	r0, [r3, #16]
 8015282:	f010 0020 	ands.w	r0, r0, #32
 8015286:	d1f9      	bne.n	801527c <USB_DevInit+0x6c>
  USBx->GRSTCTL = USB_OTG_GRSTCTL_RXFFLSH;
 8015288:	2210      	movs	r2, #16
 801528a:	611a      	str	r2, [r3, #16]
 801528c:	4a3b      	ldr	r2, [pc, #236]	; (801537c <USB_DevInit+0x16c>)
 801528e:	e001      	b.n	8015294 <USB_DevInit+0x84>
    if (++count > 200000U)
 8015290:	3a01      	subs	r2, #1
 8015292:	d06e      	beq.n	8015372 <USB_DevInit+0x162>
  while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_RXFFLSH) == USB_OTG_GRSTCTL_RXFFLSH);
 8015294:	6919      	ldr	r1, [r3, #16]
 8015296:	06c9      	lsls	r1, r1, #27
 8015298:	d4fa      	bmi.n	8015290 <USB_DevInit+0x80>
  USBx_DEVICE->DIEPMSK = 0U;
 801529a:	2100      	movs	r1, #0
 801529c:	f8cc 1010 	str.w	r1, [ip, #16]
  USBx_DEVICE->DOEPMSK = 0U;
 80152a0:	f8cc 1014 	str.w	r1, [ip, #20]
  USBx_DEVICE->DAINTMSK = 0U;
 80152a4:	f8cc 101c 	str.w	r1, [ip, #28]
  for (i = 0U; i < cfg.dev_endpoints; i++)
 80152a8:	b1e4      	cbz	r4, 80152e4 <USB_DevInit+0xd4>
 80152aa:	f503 6210 	add.w	r2, r3, #2304	; 0x900
      USBx_INEP(i)->DIEPCTL = 0U;
 80152ae:	460f      	mov	r7, r1
        USBx_INEP(i)->DIEPCTL = USB_OTG_DIEPCTL_EPDIS | USB_OTG_DIEPCTL_SNAK;
 80152b0:	f04f 4890 	mov.w	r8, #1207959552	; 0x48000000
        USBx_INEP(i)->DIEPCTL = USB_OTG_DIEPCTL_SNAK;
 80152b4:	f04f 6900 	mov.w	r9, #134217728	; 0x8000000
    USBx_INEP(i)->DIEPINT  = 0xFB7FU;
 80152b8:	f64f 3e7f 	movw	lr, #64383	; 0xfb7f
 80152bc:	e008      	b.n	80152d0 <USB_DevInit+0xc0>
      USBx_INEP(i)->DIEPCTL = 0U;
 80152be:	6017      	str	r7, [r2, #0]
  for (i = 0U; i < cfg.dev_endpoints; i++)
 80152c0:	3101      	adds	r1, #1
 80152c2:	42a1      	cmp	r1, r4
    USBx_INEP(i)->DIEPTSIZ = 0U;
 80152c4:	6117      	str	r7, [r2, #16]
    USBx_INEP(i)->DIEPINT  = 0xFB7FU;
 80152c6:	f8c2 e008 	str.w	lr, [r2, #8]
  for (i = 0U; i < cfg.dev_endpoints; i++)
 80152ca:	f102 0220 	add.w	r2, r2, #32
 80152ce:	d02e      	beq.n	801532e <USB_DevInit+0x11e>
    if ((USBx_INEP(i)->DIEPCTL & USB_OTG_DIEPCTL_EPENA) == USB_OTG_DIEPCTL_EPENA)
 80152d0:	6816      	ldr	r6, [r2, #0]
 80152d2:	2e00      	cmp	r6, #0
 80152d4:	daf3      	bge.n	80152be <USB_DevInit+0xae>
      if (i == 0U)
 80152d6:	b111      	cbz	r1, 80152de <USB_DevInit+0xce>
        USBx_INEP(i)->DIEPCTL = USB_OTG_DIEPCTL_EPDIS | USB_OTG_DIEPCTL_SNAK;
 80152d8:	f8c2 8000 	str.w	r8, [r2]
 80152dc:	e7f0      	b.n	80152c0 <USB_DevInit+0xb0>
        USBx_INEP(i)->DIEPCTL = USB_OTG_DIEPCTL_SNAK;
 80152de:	f8c2 9000 	str.w	r9, [r2]
 80152e2:	e7ed      	b.n	80152c0 <USB_DevInit+0xb0>
  USBx_DEVICE->DIEPMSK &= ~(USB_OTG_DIEPMSK_TXFURM);
 80152e4:	f8dc 2010 	ldr.w	r2, [ip, #16]
 80152e8:	f422 7280 	bic.w	r2, r2, #256	; 0x100
 80152ec:	f8cc 2010 	str.w	r2, [ip, #16]
  USBx->GINTMSK = 0U;
 80152f0:	2100      	movs	r1, #0
  USBx->GINTSTS = 0xBFFFFFFFU;
 80152f2:	f06f 4280 	mvn.w	r2, #1073741824	; 0x40000000
  USBx->GINTMSK = 0U;
 80152f6:	6199      	str	r1, [r3, #24]
  USBx->GINTSTS = 0xBFFFFFFFU;
 80152f8:	615a      	str	r2, [r3, #20]
  USBx->GINTMSK |= USB_OTG_GINTMSK_RXFLVLM;
 80152fa:	6999      	ldr	r1, [r3, #24]
  USBx->GINTMSK |= USB_OTG_GINTMSK_USBSUSPM | USB_OTG_GINTMSK_USBRST |
 80152fc:	4a20      	ldr	r2, [pc, #128]	; (8015380 <USB_DevInit+0x170>)
  USBx->GINTMSK |= USB_OTG_GINTMSK_RXFLVLM;
 80152fe:	f041 0110 	orr.w	r1, r1, #16
 8015302:	6199      	str	r1, [r3, #24]
  USBx->GINTMSK |= USB_OTG_GINTMSK_USBSUSPM | USB_OTG_GINTMSK_USBRST |
 8015304:	6999      	ldr	r1, [r3, #24]
 8015306:	430a      	orrs	r2, r1
  if (cfg.Sof_enable != 0U)
 8015308:	990e      	ldr	r1, [sp, #56]	; 0x38
  USBx->GINTMSK |= USB_OTG_GINTMSK_USBSUSPM | USB_OTG_GINTMSK_USBRST |
 801530a:	619a      	str	r2, [r3, #24]
  if (cfg.Sof_enable != 0U)
 801530c:	b119      	cbz	r1, 8015316 <USB_DevInit+0x106>
    USBx->GINTMSK |= USB_OTG_GINTMSK_SOFM;
 801530e:	699a      	ldr	r2, [r3, #24]
 8015310:	f042 0208 	orr.w	r2, r2, #8
 8015314:	619a      	str	r2, [r3, #24]
  if (cfg.vbus_sensing_enable == 1U)
 8015316:	2d01      	cmp	r5, #1
 8015318:	d105      	bne.n	8015326 <USB_DevInit+0x116>
    USBx->GINTMSK |= (USB_OTG_GINTMSK_SRQIM | USB_OTG_GINTMSK_OTGINT);
 801531a:	699a      	ldr	r2, [r3, #24]
 801531c:	f042 4280 	orr.w	r2, r2, #1073741824	; 0x40000000
 8015320:	f042 0204 	orr.w	r2, r2, #4
 8015324:	619a      	str	r2, [r3, #24]
}
 8015326:	e8bd 43f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, lr}
 801532a:	b004      	add	sp, #16
 801532c:	4770      	bx	lr
  for (i = 0U; i < cfg.dev_endpoints; i++)
 801532e:	2100      	movs	r1, #0
 8015330:	f503 6230 	add.w	r2, r3, #2816	; 0xb00
      USBx_OUTEP(i)->DOEPCTL = 0U;
 8015334:	460f      	mov	r7, r1
        USBx_OUTEP(i)->DOEPCTL = USB_OTG_DOEPCTL_EPDIS | USB_OTG_DOEPCTL_SNAK;
 8015336:	f04f 4890 	mov.w	r8, #1207959552	; 0x48000000
        USBx_OUTEP(i)->DOEPCTL = USB_OTG_DOEPCTL_SNAK;
 801533a:	f04f 6900 	mov.w	r9, #134217728	; 0x8000000
    USBx_OUTEP(i)->DOEPINT  = 0xFB7FU;
 801533e:	f64f 3e7f 	movw	lr, #64383	; 0xfb7f
 8015342:	e008      	b.n	8015356 <USB_DevInit+0x146>
      USBx_OUTEP(i)->DOEPCTL = 0U;
 8015344:	6017      	str	r7, [r2, #0]
  for (i = 0U; i < cfg.dev_endpoints; i++)
 8015346:	3101      	adds	r1, #1
 8015348:	42a1      	cmp	r1, r4
    USBx_OUTEP(i)->DOEPTSIZ = 0U;
 801534a:	6117      	str	r7, [r2, #16]
    USBx_OUTEP(i)->DOEPINT  = 0xFB7FU;
 801534c:	f8c2 e008 	str.w	lr, [r2, #8]
  for (i = 0U; i < cfg.dev_endpoints; i++)
 8015350:	f102 0220 	add.w	r2, r2, #32
 8015354:	d0c6      	beq.n	80152e4 <USB_DevInit+0xd4>
    if ((USBx_OUTEP(i)->DOEPCTL & USB_OTG_DOEPCTL_EPENA) == USB_OTG_DOEPCTL_EPENA)
 8015356:	6816      	ldr	r6, [r2, #0]
 8015358:	2e00      	cmp	r6, #0
 801535a:	daf3      	bge.n	8015344 <USB_DevInit+0x134>
      if (i == 0U)
 801535c:	b111      	cbz	r1, 8015364 <USB_DevInit+0x154>
        USBx_OUTEP(i)->DOEPCTL = USB_OTG_DOEPCTL_EPDIS | USB_OTG_DOEPCTL_SNAK;
 801535e:	f8c2 8000 	str.w	r8, [r2]
 8015362:	e7f0      	b.n	8015346 <USB_DevInit+0x136>
        USBx_OUTEP(i)->DOEPCTL = USB_OTG_DOEPCTL_SNAK;
 8015364:	f8c2 9000 	str.w	r9, [r2]
 8015368:	e7ed      	b.n	8015346 <USB_DevInit+0x136>
    USBx->GCCFG |= USB_OTG_GCCFG_VBDEN;
 801536a:	f442 1200 	orr.w	r2, r2, #2097152	; 0x200000
 801536e:	639a      	str	r2, [r3, #56]	; 0x38
 8015370:	e770      	b.n	8015254 <USB_DevInit+0x44>
    ret = HAL_ERROR;
 8015372:	2001      	movs	r0, #1
 8015374:	e791      	b.n	801529a <USB_DevInit+0x8a>
    ret = HAL_ERROR;
 8015376:	2001      	movs	r0, #1
 8015378:	e786      	b.n	8015288 <USB_DevInit+0x78>
 801537a:	bf00      	nop
 801537c:	00030d40 	.word	0x00030d40
 8015380:	803c3800 	.word	0x803c3800

08015384 <USB_FlushTxFifo>:
  USBx->GRSTCTL = (USB_OTG_GRSTCTL_TXFFLSH | (num << 6));
 8015384:	0189      	lsls	r1, r1, #6
 8015386:	f041 0120 	orr.w	r1, r1, #32
 801538a:	4a06      	ldr	r2, [pc, #24]	; (80153a4 <USB_FlushTxFifo+0x20>)
 801538c:	6101      	str	r1, [r0, #16]
    if (++count > 200000U)
 801538e:	e001      	b.n	8015394 <USB_FlushTxFifo+0x10>
 8015390:	3a01      	subs	r2, #1
 8015392:	d005      	beq.n	80153a0 <USB_FlushTxFifo+0x1c>
  while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_TXFFLSH) == USB_OTG_GRSTCTL_TXFFLSH);
 8015394:	6903      	ldr	r3, [r0, #16]
 8015396:	f013 0320 	ands.w	r3, r3, #32
 801539a:	d1f9      	bne.n	8015390 <USB_FlushTxFifo+0xc>
  return HAL_OK;
 801539c:	4618      	mov	r0, r3
 801539e:	4770      	bx	lr
      return HAL_TIMEOUT;
 80153a0:	2003      	movs	r0, #3
}
 80153a2:	4770      	bx	lr
 80153a4:	00030d40 	.word	0x00030d40

080153a8 <USB_FlushRxFifo>:
  USBx->GRSTCTL = USB_OTG_GRSTCTL_RXFFLSH;
 80153a8:	2310      	movs	r3, #16
 80153aa:	4a06      	ldr	r2, [pc, #24]	; (80153c4 <USB_FlushRxFifo+0x1c>)
 80153ac:	6103      	str	r3, [r0, #16]
    if (++count > 200000U)
 80153ae:	e001      	b.n	80153b4 <USB_FlushRxFifo+0xc>
 80153b0:	3a01      	subs	r2, #1
 80153b2:	d005      	beq.n	80153c0 <USB_FlushRxFifo+0x18>
  while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_RXFFLSH) == USB_OTG_GRSTCTL_RXFFLSH);
 80153b4:	6903      	ldr	r3, [r0, #16]
 80153b6:	f013 0310 	ands.w	r3, r3, #16
 80153ba:	d1f9      	bne.n	80153b0 <USB_FlushRxFifo+0x8>
  return HAL_OK;
 80153bc:	4618      	mov	r0, r3
 80153be:	4770      	bx	lr
      return HAL_TIMEOUT;
 80153c0:	2003      	movs	r0, #3
}
 80153c2:	4770      	bx	lr
 80153c4:	00030d40 	.word	0x00030d40

080153c8 <USB_GetDevSpeed>:
  uint32_t DevEnumSpeed = USBx_DEVICE->DSTS & USB_OTG_DSTS_ENUMSPD;
 80153c8:	f8d0 3808 	ldr.w	r3, [r0, #2056]	; 0x808
    speed = 0xFU;
 80153cc:	f013 0f02 	tst.w	r3, #2
  uint32_t DevEnumSpeed = USBx_DEVICE->DSTS & USB_OTG_DSTS_ENUMSPD;
 80153d0:	f500 6000 	add.w	r0, r0, #2048	; 0x800
}
 80153d4:	bf14      	ite	ne
 80153d6:	2002      	movne	r0, #2
 80153d8:	200f      	moveq	r0, #15
 80153da:	4770      	bx	lr

080153dc <USB_ActivateEndpoint>:
{
 80153dc:	b430      	push	{r4, r5}
  if (ep->is_in == 1U)
 80153de:	784b      	ldrb	r3, [r1, #1]
  uint32_t epnum = (uint32_t)ep->num;
 80153e0:	780a      	ldrb	r2, [r1, #0]
  if (ep->is_in == 1U)
 80153e2:	2b01      	cmp	r3, #1
 80153e4:	d022      	beq.n	801542c <USB_ActivateEndpoint+0x50>
    USBx_DEVICE->DAINTMSK |= USB_OTG_DAINTMSK_OEPM & ((uint32_t)(1UL << (ep->num & EP_ADDR_MSK)) << 16);
 80153e6:	f8d0 481c 	ldr.w	r4, [r0, #2076]	; 0x81c
 80153ea:	f002 0c0f 	and.w	ip, r2, #15
 80153ee:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 80153f2:	fa03 f30c 	lsl.w	r3, r3, ip
 80153f6:	4323      	orrs	r3, r4
    if (((USBx_OUTEP(epnum)->DOEPCTL) & USB_OTG_DOEPCTL_USBAEP) == 0U)
 80153f8:	eb00 1242 	add.w	r2, r0, r2, lsl #5
    USBx_DEVICE->DAINTMSK |= USB_OTG_DAINTMSK_OEPM & ((uint32_t)(1UL << (ep->num & EP_ADDR_MSK)) << 16);
 80153fc:	f8c0 381c 	str.w	r3, [r0, #2076]	; 0x81c
    if (((USBx_OUTEP(epnum)->DOEPCTL) & USB_OTG_DOEPCTL_USBAEP) == 0U)
 8015400:	f8d2 3b00 	ldr.w	r3, [r2, #2816]	; 0xb00
 8015404:	041b      	lsls	r3, r3, #16
 8015406:	d40e      	bmi.n	8015426 <USB_ActivateEndpoint+0x4a>
      USBx_OUTEP(epnum)->DOEPCTL |= (ep->maxpacket & USB_OTG_DOEPCTL_MPSIZ) |
 8015408:	688b      	ldr	r3, [r1, #8]
 801540a:	f8d2 0b00 	ldr.w	r0, [r2, #2816]	; 0xb00
                                    ((uint32_t)ep->type << 18) |
 801540e:	78c9      	ldrb	r1, [r1, #3]
      USBx_OUTEP(epnum)->DOEPCTL |= (ep->maxpacket & USB_OTG_DOEPCTL_MPSIZ) |
 8015410:	f3c3 030a 	ubfx	r3, r3, #0, #11
 8015414:	4303      	orrs	r3, r0
 8015416:	ea43 4381 	orr.w	r3, r3, r1, lsl #18
 801541a:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 801541e:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 8015422:	f8c2 3b00 	str.w	r3, [r2, #2816]	; 0xb00
}
 8015426:	2000      	movs	r0, #0
 8015428:	bc30      	pop	{r4, r5}
 801542a:	4770      	bx	lr
    USBx_DEVICE->DAINTMSK |= USB_OTG_DAINTMSK_IEPM & (uint32_t)(1UL << (ep->num & EP_ADDR_MSK));
 801542c:	f8d0 581c 	ldr.w	r5, [r0, #2076]	; 0x81c
 8015430:	f002 0c0f 	and.w	ip, r2, #15
 8015434:	fa03 f30c 	lsl.w	r3, r3, ip
 8015438:	f500 6400 	add.w	r4, r0, #2048	; 0x800
 801543c:	432b      	orrs	r3, r5
    if ((USBx_INEP(epnum)->DIEPCTL & USB_OTG_DIEPCTL_USBAEP) == 0U)
 801543e:	eb00 1042 	add.w	r0, r0, r2, lsl #5
    USBx_DEVICE->DAINTMSK |= USB_OTG_DAINTMSK_IEPM & (uint32_t)(1UL << (ep->num & EP_ADDR_MSK));
 8015442:	61e3      	str	r3, [r4, #28]
    if ((USBx_INEP(epnum)->DIEPCTL & USB_OTG_DIEPCTL_USBAEP) == 0U)
 8015444:	f8d0 3900 	ldr.w	r3, [r0, #2304]	; 0x900
 8015448:	041c      	lsls	r4, r3, #16
 801544a:	d4ec      	bmi.n	8015426 <USB_ActivateEndpoint+0x4a>
      USBx_INEP(epnum)->DIEPCTL |= (ep->maxpacket & USB_OTG_DIEPCTL_MPSIZ) |
 801544c:	688b      	ldr	r3, [r1, #8]
 801544e:	f8d0 4900 	ldr.w	r4, [r0, #2304]	; 0x900
                                   ((uint32_t)ep->type << 18) | (epnum << 22) |
 8015452:	78c9      	ldrb	r1, [r1, #3]
      USBx_INEP(epnum)->DIEPCTL |= (ep->maxpacket & USB_OTG_DIEPCTL_MPSIZ) |
 8015454:	f3c3 030a 	ubfx	r3, r3, #0, #11
 8015458:	4323      	orrs	r3, r4
 801545a:	ea43 4381 	orr.w	r3, r3, r1, lsl #18
 801545e:	ea43 5282 	orr.w	r2, r3, r2, lsl #22
 8015462:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 8015466:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
 801546a:	f8c0 2900 	str.w	r2, [r0, #2304]	; 0x900
}
 801546e:	bc30      	pop	{r4, r5}
 8015470:	2000      	movs	r0, #0
 8015472:	4770      	bx	lr

08015474 <USB_DeactivateEndpoint>:
  if (ep->is_in == 1U)
 8015474:	784a      	ldrb	r2, [r1, #1]
  uint32_t epnum = (uint32_t)ep->num;
 8015476:	780b      	ldrb	r3, [r1, #0]
    USBx_DEVICE->DEACHMSK &= ~(USB_OTG_DAINTMSK_IEPM & (uint32_t)(1UL << (ep->num & EP_ADDR_MSK)));
 8015478:	f8d0 183c 	ldr.w	r1, [r0, #2108]	; 0x83c
  if (ep->is_in == 1U)
 801547c:	2a01      	cmp	r2, #1
    USBx_DEVICE->DEACHMSK &= ~(USB_OTG_DAINTMSK_IEPM & (uint32_t)(1UL << (ep->num & EP_ADDR_MSK)));
 801547e:	f003 0c0f 	and.w	ip, r3, #15
  if (ep->is_in == 1U)
 8015482:	d017      	beq.n	80154b4 <USB_DeactivateEndpoint+0x40>
    USBx_DEVICE->DEACHMSK &= ~(USB_OTG_DAINTMSK_OEPM & ((uint32_t)(1UL << (ep->num & EP_ADDR_MSK)) << 16));
 8015484:	f44f 3280 	mov.w	r2, #65536	; 0x10000
 8015488:	fa02 f20c 	lsl.w	r2, r2, ip
 801548c:	ea21 0102 	bic.w	r1, r1, r2
 8015490:	f8c0 183c 	str.w	r1, [r0, #2108]	; 0x83c
    USBx_DEVICE->DAINTMSK &= ~(USB_OTG_DAINTMSK_OEPM & ((uint32_t)(1UL << (ep->num & EP_ADDR_MSK)) << 16));
 8015494:	f8d0 181c 	ldr.w	r1, [r0, #2076]	; 0x81c
    USBx_OUTEP(epnum)->DOEPCTL &= ~(USB_OTG_DOEPCTL_USBAEP |
 8015498:	eb00 1343 	add.w	r3, r0, r3, lsl #5
    USBx_DEVICE->DAINTMSK &= ~(USB_OTG_DAINTMSK_OEPM & ((uint32_t)(1UL << (ep->num & EP_ADDR_MSK)) << 16));
 801549c:	ea21 0202 	bic.w	r2, r1, r2
 80154a0:	f8c0 281c 	str.w	r2, [r0, #2076]	; 0x81c
    USBx_OUTEP(epnum)->DOEPCTL &= ~(USB_OTG_DOEPCTL_USBAEP |
 80154a4:	f8d3 1b00 	ldr.w	r1, [r3, #2816]	; 0xb00
 80154a8:	4a0d      	ldr	r2, [pc, #52]	; (80154e0 <USB_DeactivateEndpoint+0x6c>)
 80154aa:	400a      	ands	r2, r1
 80154ac:	f8c3 2b00 	str.w	r2, [r3, #2816]	; 0xb00
}
 80154b0:	2000      	movs	r0, #0
 80154b2:	4770      	bx	lr
    USBx_DEVICE->DEACHMSK &= ~(USB_OTG_DAINTMSK_IEPM & (uint32_t)(1UL << (ep->num & EP_ADDR_MSK)));
 80154b4:	fa02 f20c 	lsl.w	r2, r2, ip
 80154b8:	ea21 0102 	bic.w	r1, r1, r2
 80154bc:	f8c0 183c 	str.w	r1, [r0, #2108]	; 0x83c
    USBx_DEVICE->DAINTMSK &= ~(USB_OTG_DAINTMSK_IEPM & (uint32_t)(1UL << (ep->num & EP_ADDR_MSK)));
 80154c0:	f8d0 181c 	ldr.w	r1, [r0, #2076]	; 0x81c
    USBx_INEP(epnum)->DIEPCTL &= ~(USB_OTG_DIEPCTL_USBAEP |
 80154c4:	eb00 1343 	add.w	r3, r0, r3, lsl #5
    USBx_DEVICE->DAINTMSK &= ~(USB_OTG_DAINTMSK_IEPM & (uint32_t)(1UL << (ep->num & EP_ADDR_MSK)));
 80154c8:	ea21 0202 	bic.w	r2, r1, r2
 80154cc:	f8c0 281c 	str.w	r2, [r0, #2076]	; 0x81c
    USBx_INEP(epnum)->DIEPCTL &= ~(USB_OTG_DIEPCTL_USBAEP |
 80154d0:	f8d3 1900 	ldr.w	r1, [r3, #2304]	; 0x900
 80154d4:	4a03      	ldr	r2, [pc, #12]	; (80154e4 <USB_DeactivateEndpoint+0x70>)
 80154d6:	400a      	ands	r2, r1
 80154d8:	f8c3 2900 	str.w	r2, [r3, #2304]	; 0x900
}
 80154dc:	2000      	movs	r0, #0
 80154de:	4770      	bx	lr
 80154e0:	eff37800 	.word	0xeff37800
 80154e4:	ec337800 	.word	0xec337800

080154e8 <USB_EPStartXfer>:
{
 80154e8:	b5f0      	push	{r4, r5, r6, r7, lr}
  if (ep->is_in == 1U)
 80154ea:	784c      	ldrb	r4, [r1, #1]
  uint32_t epnum = (uint32_t)ep->num;
 80154ec:	780b      	ldrb	r3, [r1, #0]
  if (ep->is_in == 1U)
 80154ee:	2c01      	cmp	r4, #1
 80154f0:	d052      	beq.n	8015598 <USB_EPStartXfer+0xb0>
    USBx_OUTEP(epnum)->DOEPTSIZ &= ~(USB_OTG_DOEPTSIZ_XFRSIZ);
 80154f2:	eb00 1343 	add.w	r3, r0, r3, lsl #5
 80154f6:	f503 6c30 	add.w	ip, r3, #2816	; 0xb00
 80154fa:	f8dc 2010 	ldr.w	r2, [ip, #16]
 80154fe:	0cd2      	lsrs	r2, r2, #19
 8015500:	04d2      	lsls	r2, r2, #19
 8015502:	f8cc 2010 	str.w	r2, [ip, #16]
    USBx_OUTEP(epnum)->DOEPTSIZ &= ~(USB_OTG_DOEPTSIZ_PKTCNT);
 8015506:	f8dc 2010 	ldr.w	r2, [ip, #16]
 801550a:	f022 52ff 	bic.w	r2, r2, #534773760	; 0x1fe00000
 801550e:	f422 12c0 	bic.w	r2, r2, #1572864	; 0x180000
 8015512:	f8cc 2010 	str.w	r2, [ip, #16]
    if (ep->xfer_len == 0U)
 8015516:	694a      	ldr	r2, [r1, #20]
 8015518:	b37a      	cbz	r2, 801557a <USB_EPStartXfer+0x92>
      pktcnt = (uint16_t)((ep->xfer_len + ep->maxpacket - 1U) / ep->maxpacket);
 801551a:	688c      	ldr	r4, [r1, #8]
      USBx_OUTEP(epnum)->DOEPTSIZ |= USB_OTG_DOEPTSIZ_PKTCNT & ((uint32_t)pktcnt << 19);
 801551c:	4d63      	ldr	r5, [pc, #396]	; (80156ac <USB_EPStartXfer+0x1c4>)
      pktcnt = (uint16_t)((ep->xfer_len + ep->maxpacket - 1U) / ep->maxpacket);
 801551e:	4422      	add	r2, r4
 8015520:	3a01      	subs	r2, #1
 8015522:	fbb2 f2f4 	udiv	r2, r2, r4
      USBx_OUTEP(epnum)->DOEPTSIZ |= USB_OTG_DOEPTSIZ_PKTCNT & ((uint32_t)pktcnt << 19);
 8015526:	ea05 4ec2 	and.w	lr, r5, r2, lsl #19
 801552a:	b292      	uxth	r2, r2
      USBx_OUTEP(epnum)->DOEPTSIZ |= USB_OTG_DOEPTSIZ_XFRSIZ & (ep->maxpacket * pktcnt);
 801552c:	fb04 f202 	mul.w	r2, r4, r2
      USBx_OUTEP(epnum)->DOEPTSIZ |= USB_OTG_DOEPTSIZ_PKTCNT & ((uint32_t)pktcnt << 19);
 8015530:	f8dc 4010 	ldr.w	r4, [ip, #16]
 8015534:	ea4e 0404 	orr.w	r4, lr, r4
 8015538:	f8cc 4010 	str.w	r4, [ip, #16]
      USBx_OUTEP(epnum)->DOEPTSIZ |= USB_OTG_DOEPTSIZ_XFRSIZ & (ep->maxpacket * pktcnt);
 801553c:	f8dc 4010 	ldr.w	r4, [ip, #16]
 8015540:	f3c2 0212 	ubfx	r2, r2, #0, #19
 8015544:	4322      	orrs	r2, r4
 8015546:	f8cc 2010 	str.w	r2, [ip, #16]
    if (ep->type == EP_TYPE_ISOC)
 801554a:	78ca      	ldrb	r2, [r1, #3]
 801554c:	2a01      	cmp	r2, #1
 801554e:	d10c      	bne.n	801556a <USB_EPStartXfer+0x82>
      if ((USBx_DEVICE->DSTS & (1U << 8)) == 0U)
 8015550:	f8d0 2808 	ldr.w	r2, [r0, #2056]	; 0x808
 8015554:	f412 7f80 	tst.w	r2, #256	; 0x100
        USBx_OUTEP(epnum)->DOEPCTL |= USB_OTG_DOEPCTL_SODDFRM;
 8015558:	f8d3 2b00 	ldr.w	r2, [r3, #2816]	; 0xb00
 801555c:	bf0c      	ite	eq
 801555e:	f042 5200 	orreq.w	r2, r2, #536870912	; 0x20000000
        USBx_OUTEP(epnum)->DOEPCTL |= USB_OTG_DOEPCTL_SD0PID_SEVNFRM;
 8015562:	f042 5280 	orrne.w	r2, r2, #268435456	; 0x10000000
 8015566:	f8c3 2b00 	str.w	r2, [r3, #2816]	; 0xb00
    USBx_OUTEP(epnum)->DOEPCTL |= (USB_OTG_DOEPCTL_CNAK | USB_OTG_DOEPCTL_EPENA);
 801556a:	f8d3 2b00 	ldr.w	r2, [r3, #2816]	; 0xb00
 801556e:	f042 4204 	orr.w	r2, r2, #2214592512	; 0x84000000
 8015572:	f8c3 2b00 	str.w	r2, [r3, #2816]	; 0xb00
}
 8015576:	2000      	movs	r0, #0
 8015578:	bdf0      	pop	{r4, r5, r6, r7, pc}
      USBx_OUTEP(epnum)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_XFRSIZ & ep->maxpacket);
 801557a:	688a      	ldr	r2, [r1, #8]
 801557c:	f8dc 4010 	ldr.w	r4, [ip, #16]
 8015580:	f3c2 0212 	ubfx	r2, r2, #0, #19
 8015584:	4322      	orrs	r2, r4
 8015586:	f8cc 2010 	str.w	r2, [ip, #16]
      USBx_OUTEP(epnum)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_PKTCNT & (1U << 19));
 801558a:	f8dc 2010 	ldr.w	r2, [ip, #16]
 801558e:	f442 2200 	orr.w	r2, r2, #524288	; 0x80000
 8015592:	f8cc 2010 	str.w	r2, [ip, #16]
 8015596:	e7d8      	b.n	801554a <USB_EPStartXfer+0x62>
    if (ep->xfer_len == 0U)
 8015598:	694a      	ldr	r2, [r1, #20]
      USBx_INEP(epnum)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_PKTCNT);
 801559a:	eb00 1c43 	add.w	ip, r0, r3, lsl #5
    if (ep->xfer_len == 0U)
 801559e:	2a00      	cmp	r2, #0
 80155a0:	d13b      	bne.n	801561a <USB_EPStartXfer+0x132>
      USBx_INEP(epnum)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_PKTCNT);
 80155a2:	f8dc 4910 	ldr.w	r4, [ip, #2320]	; 0x910
 80155a6:	f024 54ff 	bic.w	r4, r4, #534773760	; 0x1fe00000
 80155aa:	f424 14c0 	bic.w	r4, r4, #1572864	; 0x180000
 80155ae:	f8cc 4910 	str.w	r4, [ip, #2320]	; 0x910
      USBx_INEP(epnum)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_PKTCNT & (1U << 19));
 80155b2:	f8dc 4910 	ldr.w	r4, [ip, #2320]	; 0x910
 80155b6:	f444 2400 	orr.w	r4, r4, #524288	; 0x80000
 80155ba:	f8cc 4910 	str.w	r4, [ip, #2320]	; 0x910
      USBx_INEP(epnum)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_XFRSIZ);
 80155be:	f8dc 4910 	ldr.w	r4, [ip, #2320]	; 0x910
 80155c2:	0ce4      	lsrs	r4, r4, #19
 80155c4:	04e4      	lsls	r4, r4, #19
 80155c6:	f8cc 4910 	str.w	r4, [ip, #2320]	; 0x910
    USBx_INEP(epnum)->DIEPCTL |= (USB_OTG_DIEPCTL_CNAK | USB_OTG_DIEPCTL_EPENA);
 80155ca:	f8dc 4900 	ldr.w	r4, [ip, #2304]	; 0x900
 80155ce:	f044 4404 	orr.w	r4, r4, #2214592512	; 0x84000000
 80155d2:	f8cc 4900 	str.w	r4, [ip, #2304]	; 0x900
    if (ep->type != EP_TYPE_ISOC)
 80155d6:	78cc      	ldrb	r4, [r1, #3]
 80155d8:	2c01      	cmp	r4, #1
      USBx_INEP(epnum)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_PKTCNT);
 80155da:	f50c 6510 	add.w	r5, ip, #2304	; 0x900
    if (ep->type != EP_TYPE_ISOC)
 80155de:	d1ca      	bne.n	8015576 <USB_EPStartXfer+0x8e>
      if ((USBx_DEVICE->DSTS & (1U << 8)) == 0U)
 80155e0:	f8d0 4808 	ldr.w	r4, [r0, #2056]	; 0x808
 80155e4:	f414 7f80 	tst.w	r4, #256	; 0x100
        USBx_INEP(epnum)->DIEPCTL |= USB_OTG_DIEPCTL_SODDFRM;
 80155e8:	682c      	ldr	r4, [r5, #0]
  count32b = ((uint32_t)len + 3U) / 4U;
 80155ea:	b292      	uxth	r2, r2
        USBx_INEP(epnum)->DIEPCTL |= USB_OTG_DIEPCTL_SODDFRM;
 80155ec:	bf0c      	ite	eq
 80155ee:	f044 5400 	orreq.w	r4, r4, #536870912	; 0x20000000
        USBx_INEP(epnum)->DIEPCTL |= USB_OTG_DIEPCTL_SD0PID_SEVNFRM;
 80155f2:	f044 5480 	orrne.w	r4, r4, #268435456	; 0x10000000
 80155f6:	602c      	str	r4, [r5, #0]
  count32b = ((uint32_t)len + 3U) / 4U;
 80155f8:	1cd4      	adds	r4, r2, #3
      (void)USB_WritePacket(USBx, ep->xfer_buff, ep->num, (uint16_t)ep->xfer_len);
 80155fa:	68ca      	ldr	r2, [r1, #12]
  for (i = 0U; i < count32b; i++)
 80155fc:	08a1      	lsrs	r1, r4, #2
 80155fe:	d0ba      	beq.n	8015576 <USB_EPStartXfer+0x8e>
    USBx_DFIFO((uint32_t)ch_ep_num) = __UNALIGNED_UINT32_READ(pSrc);
 8015600:	eb00 3303 	add.w	r3, r0, r3, lsl #12
 8015604:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 8015608:	eb02 0181 	add.w	r1, r2, r1, lsl #2
 801560c:	f852 4b04 	ldr.w	r4, [r2], #4
 8015610:	601c      	str	r4, [r3, #0]
  for (i = 0U; i < count32b; i++)
 8015612:	4291      	cmp	r1, r2
 8015614:	d1fa      	bne.n	801560c <USB_EPStartXfer+0x124>
}
 8015616:	2000      	movs	r0, #0
 8015618:	bdf0      	pop	{r4, r5, r6, r7, pc}
      USBx_INEP(epnum)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_XFRSIZ);
 801561a:	f8dc 5910 	ldr.w	r5, [ip, #2320]	; 0x910
      USBx_INEP(epnum)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_PKTCNT & (((ep->xfer_len + ep->maxpacket - 1U) / ep->maxpacket) << 19));
 801561e:	688e      	ldr	r6, [r1, #8]
      USBx_INEP(epnum)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_XFRSIZ);
 8015620:	0ced      	lsrs	r5, r5, #19
 8015622:	04ed      	lsls	r5, r5, #19
 8015624:	f8cc 5910 	str.w	r5, [ip, #2320]	; 0x910
      USBx_INEP(epnum)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_PKTCNT);
 8015628:	f8dc 5910 	ldr.w	r5, [ip, #2320]	; 0x910
 801562c:	f025 55ff 	bic.w	r5, r5, #534773760	; 0x1fe00000
 8015630:	f425 15c0 	bic.w	r5, r5, #1572864	; 0x180000
 8015634:	f8cc 5910 	str.w	r5, [ip, #2320]	; 0x910
      USBx_INEP(epnum)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_PKTCNT & (((ep->xfer_len + ep->maxpacket - 1U) / ep->maxpacket) << 19));
 8015638:	4d1c      	ldr	r5, [pc, #112]	; (80156ac <USB_EPStartXfer+0x1c4>)
 801563a:	f8dc 7910 	ldr.w	r7, [ip, #2320]	; 0x910
 801563e:	eb02 0e06 	add.w	lr, r2, r6
 8015642:	f10e 3eff 	add.w	lr, lr, #4294967295
 8015646:	fbbe fef6 	udiv	lr, lr, r6
 801564a:	ea05 45ce 	and.w	r5, r5, lr, lsl #19
 801564e:	433d      	orrs	r5, r7
 8015650:	f8cc 5910 	str.w	r5, [ip, #2320]	; 0x910
      USBx_INEP(epnum)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_XFRSIZ & ep->xfer_len);
 8015654:	f8dc 6910 	ldr.w	r6, [ip, #2320]	; 0x910
 8015658:	f3c2 0512 	ubfx	r5, r2, #0, #19
 801565c:	4335      	orrs	r5, r6
 801565e:	f8cc 5910 	str.w	r5, [ip, #2320]	; 0x910
      if (ep->type == EP_TYPE_ISOC)
 8015662:	78ce      	ldrb	r6, [r1, #3]
 8015664:	2e01      	cmp	r6, #1
      USBx_INEP(epnum)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_XFRSIZ);
 8015666:	f50c 6510 	add.w	r5, ip, #2304	; 0x900
      if (ep->type == EP_TYPE_ISOC)
 801566a:	d00f      	beq.n	801568c <USB_EPStartXfer+0x1a4>
    USBx_INEP(epnum)->DIEPCTL |= (USB_OTG_DIEPCTL_CNAK | USB_OTG_DIEPCTL_EPENA);
 801566c:	f8dc 2900 	ldr.w	r2, [ip, #2304]	; 0x900
 8015670:	f042 4204 	orr.w	r2, r2, #2214592512	; 0x84000000
 8015674:	f8cc 2900 	str.w	r2, [ip, #2304]	; 0x900
        USBx_DEVICE->DIEPEMPMSK |= 1UL << (ep->num & EP_ADDR_MSK);
 8015678:	f8d0 2834 	ldr.w	r2, [r0, #2100]	; 0x834
 801567c:	f003 030f 	and.w	r3, r3, #15
 8015680:	409c      	lsls	r4, r3
 8015682:	4314      	orrs	r4, r2
 8015684:	f8c0 4834 	str.w	r4, [r0, #2100]	; 0x834
}
 8015688:	2000      	movs	r0, #0
 801568a:	bdf0      	pop	{r4, r5, r6, r7, pc}
        USBx_INEP(epnum)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_MULCNT);
 801568c:	692c      	ldr	r4, [r5, #16]
 801568e:	f024 44c0 	bic.w	r4, r4, #1610612736	; 0x60000000
 8015692:	612c      	str	r4, [r5, #16]
        USBx_INEP(epnum)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_MULCNT & (1U << 29));
 8015694:	692c      	ldr	r4, [r5, #16]
 8015696:	f044 5400 	orr.w	r4, r4, #536870912	; 0x20000000
 801569a:	612c      	str	r4, [r5, #16]
    USBx_INEP(epnum)->DIEPCTL |= (USB_OTG_DIEPCTL_CNAK | USB_OTG_DIEPCTL_EPENA);
 801569c:	f8dc 4900 	ldr.w	r4, [ip, #2304]	; 0x900
 80156a0:	f044 4404 	orr.w	r4, r4, #2214592512	; 0x84000000
 80156a4:	f8cc 4900 	str.w	r4, [ip, #2304]	; 0x900
    if (ep->type != EP_TYPE_ISOC)
 80156a8:	e79a      	b.n	80155e0 <USB_EPStartXfer+0xf8>
 80156aa:	bf00      	nop
 80156ac:	1ff80000 	.word	0x1ff80000

080156b0 <USB_EP0StartXfer>:
{
 80156b0:	b470      	push	{r4, r5, r6}
  if (ep->is_in == 1U)
 80156b2:	784a      	ldrb	r2, [r1, #1]
  uint32_t epnum = (uint32_t)ep->num;
 80156b4:	780b      	ldrb	r3, [r1, #0]
  if (ep->is_in == 1U)
 80156b6:	2a01      	cmp	r2, #1
 80156b8:	d025      	beq.n	8015706 <USB_EP0StartXfer+0x56>
    USBx_OUTEP(epnum)->DOEPTSIZ &= ~(USB_OTG_DOEPTSIZ_XFRSIZ);
 80156ba:	eb00 1043 	add.w	r0, r0, r3, lsl #5
 80156be:	f500 6330 	add.w	r3, r0, #2816	; 0xb00
 80156c2:	f8d0 2b10 	ldr.w	r2, [r0, #2832]	; 0xb10
    if (ep->xfer_len > 0U)
 80156c6:	694c      	ldr	r4, [r1, #20]
    USBx_OUTEP(epnum)->DOEPTSIZ &= ~(USB_OTG_DOEPTSIZ_XFRSIZ);
 80156c8:	0cd2      	lsrs	r2, r2, #19
 80156ca:	04d2      	lsls	r2, r2, #19
 80156cc:	611a      	str	r2, [r3, #16]
    USBx_OUTEP(epnum)->DOEPTSIZ &= ~(USB_OTG_DOEPTSIZ_PKTCNT);
 80156ce:	691a      	ldr	r2, [r3, #16]
 80156d0:	f022 52ff 	bic.w	r2, r2, #534773760	; 0x1fe00000
 80156d4:	f422 12c0 	bic.w	r2, r2, #1572864	; 0x180000
 80156d8:	611a      	str	r2, [r3, #16]
      ep->xfer_len = ep->maxpacket;
 80156da:	688a      	ldr	r2, [r1, #8]
    if (ep->xfer_len > 0U)
 80156dc:	b98c      	cbnz	r4, 8015702 <USB_EP0StartXfer+0x52>
    USBx_OUTEP(epnum)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_PKTCNT & (1U << 19));
 80156de:	6919      	ldr	r1, [r3, #16]
 80156e0:	f441 2100 	orr.w	r1, r1, #524288	; 0x80000
 80156e4:	6119      	str	r1, [r3, #16]
    USBx_OUTEP(epnum)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_XFRSIZ & (ep->maxpacket));
 80156e6:	6919      	ldr	r1, [r3, #16]
 80156e8:	f3c2 0212 	ubfx	r2, r2, #0, #19
 80156ec:	430a      	orrs	r2, r1
 80156ee:	611a      	str	r2, [r3, #16]
    USBx_OUTEP(epnum)->DOEPCTL |= (USB_OTG_DOEPCTL_CNAK | USB_OTG_DOEPCTL_EPENA);
 80156f0:	f8d0 3b00 	ldr.w	r3, [r0, #2816]	; 0xb00
 80156f4:	f043 4304 	orr.w	r3, r3, #2214592512	; 0x84000000
 80156f8:	f8c0 3b00 	str.w	r3, [r0, #2816]	; 0xb00
}
 80156fc:	2000      	movs	r0, #0
 80156fe:	bc70      	pop	{r4, r5, r6}
 8015700:	4770      	bx	lr
      ep->xfer_len = ep->maxpacket;
 8015702:	614a      	str	r2, [r1, #20]
 8015704:	e7eb      	b.n	80156de <USB_EP0StartXfer+0x2e>
    if (ep->xfer_len == 0U)
 8015706:	694c      	ldr	r4, [r1, #20]
 8015708:	b394      	cbz	r4, 8015770 <USB_EP0StartXfer+0xc0>
      USBx_INEP(epnum)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_XFRSIZ);
 801570a:	eb00 1243 	add.w	r2, r0, r3, lsl #5
      if (ep->xfer_len > ep->maxpacket)
 801570e:	688e      	ldr	r6, [r1, #8]
      USBx_INEP(epnum)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_XFRSIZ);
 8015710:	f8d2 5910 	ldr.w	r5, [r2, #2320]	; 0x910
 8015714:	0ced      	lsrs	r5, r5, #19
 8015716:	04ed      	lsls	r5, r5, #19
 8015718:	f8c2 5910 	str.w	r5, [r2, #2320]	; 0x910
      USBx_INEP(epnum)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_PKTCNT);
 801571c:	f8d2 5910 	ldr.w	r5, [r2, #2320]	; 0x910
 8015720:	f025 55ff 	bic.w	r5, r5, #534773760	; 0x1fe00000
 8015724:	f425 15c0 	bic.w	r5, r5, #1572864	; 0x180000
      if (ep->xfer_len > ep->maxpacket)
 8015728:	42b4      	cmp	r4, r6
      USBx_INEP(epnum)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_PKTCNT);
 801572a:	f8c2 5910 	str.w	r5, [r2, #2320]	; 0x910
      USBx_INEP(epnum)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_XFRSIZ);
 801572e:	f502 6510 	add.w	r5, r2, #2304	; 0x900
      if (ep->xfer_len > ep->maxpacket)
 8015732:	d93c      	bls.n	80157ae <USB_EP0StartXfer+0xfe>
        ep->xfer_len = ep->maxpacket;
 8015734:	614e      	str	r6, [r1, #20]
      USBx_INEP(epnum)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_PKTCNT & (1U << 19));
 8015736:	6929      	ldr	r1, [r5, #16]
 8015738:	f441 2100 	orr.w	r1, r1, #524288	; 0x80000
 801573c:	6129      	str	r1, [r5, #16]
      USBx_INEP(epnum)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_XFRSIZ & ep->xfer_len);
 801573e:	692c      	ldr	r4, [r5, #16]
 8015740:	f3c6 0112 	ubfx	r1, r6, #0, #19
 8015744:	4321      	orrs	r1, r4
 8015746:	6129      	str	r1, [r5, #16]
    USBx_INEP(epnum)->DIEPCTL |= (USB_OTG_DIEPCTL_CNAK | USB_OTG_DIEPCTL_EPENA);
 8015748:	f8d2 1900 	ldr.w	r1, [r2, #2304]	; 0x900
 801574c:	f041 4104 	orr.w	r1, r1, #2214592512	; 0x84000000
 8015750:	f8c2 1900 	str.w	r1, [r2, #2304]	; 0x900
    if (ep->xfer_len > 0U)
 8015754:	2e00      	cmp	r6, #0
 8015756:	d0d1      	beq.n	80156fc <USB_EP0StartXfer+0x4c>
      USBx_DEVICE->DIEPEMPMSK |= 1UL << (ep->num & EP_ADDR_MSK);
 8015758:	f8d0 2834 	ldr.w	r2, [r0, #2100]	; 0x834
 801575c:	f003 010f 	and.w	r1, r3, #15
 8015760:	2301      	movs	r3, #1
 8015762:	408b      	lsls	r3, r1
 8015764:	4313      	orrs	r3, r2
 8015766:	f8c0 3834 	str.w	r3, [r0, #2100]	; 0x834
}
 801576a:	bc70      	pop	{r4, r5, r6}
 801576c:	2000      	movs	r0, #0
 801576e:	4770      	bx	lr
      USBx_INEP(epnum)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_PKTCNT);
 8015770:	eb00 1043 	add.w	r0, r0, r3, lsl #5
}
 8015774:	bc70      	pop	{r4, r5, r6}
      USBx_INEP(epnum)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_PKTCNT);
 8015776:	f8d0 1910 	ldr.w	r1, [r0, #2320]	; 0x910
 801577a:	f021 51ff 	bic.w	r1, r1, #534773760	; 0x1fe00000
 801577e:	f421 11c0 	bic.w	r1, r1, #1572864	; 0x180000
 8015782:	f8c0 1910 	str.w	r1, [r0, #2320]	; 0x910
      USBx_INEP(epnum)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_PKTCNT & (1U << 19));
 8015786:	f8d0 3910 	ldr.w	r3, [r0, #2320]	; 0x910
 801578a:	f443 2300 	orr.w	r3, r3, #524288	; 0x80000
 801578e:	f8c0 3910 	str.w	r3, [r0, #2320]	; 0x910
      USBx_INEP(epnum)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_XFRSIZ);
 8015792:	f8d0 1910 	ldr.w	r1, [r0, #2320]	; 0x910
 8015796:	0cc9      	lsrs	r1, r1, #19
 8015798:	04c9      	lsls	r1, r1, #19
 801579a:	f8c0 1910 	str.w	r1, [r0, #2320]	; 0x910
    USBx_INEP(epnum)->DIEPCTL |= (USB_OTG_DIEPCTL_CNAK | USB_OTG_DIEPCTL_EPENA);
 801579e:	f8d0 3900 	ldr.w	r3, [r0, #2304]	; 0x900
 80157a2:	f043 4304 	orr.w	r3, r3, #2214592512	; 0x84000000
 80157a6:	f8c0 3900 	str.w	r3, [r0, #2304]	; 0x900
}
 80157aa:	2000      	movs	r0, #0
 80157ac:	4770      	bx	lr
      USBx_INEP(epnum)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_PKTCNT & (1U << 19));
 80157ae:	6929      	ldr	r1, [r5, #16]
 80157b0:	f441 2100 	orr.w	r1, r1, #524288	; 0x80000
 80157b4:	6129      	str	r1, [r5, #16]
      USBx_INEP(epnum)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_XFRSIZ & ep->xfer_len);
 80157b6:	6929      	ldr	r1, [r5, #16]
 80157b8:	f3c4 0412 	ubfx	r4, r4, #0, #19
 80157bc:	430c      	orrs	r4, r1
 80157be:	612c      	str	r4, [r5, #16]
    USBx_INEP(epnum)->DIEPCTL |= (USB_OTG_DIEPCTL_CNAK | USB_OTG_DIEPCTL_EPENA);
 80157c0:	f8d2 1900 	ldr.w	r1, [r2, #2304]	; 0x900
 80157c4:	f041 4104 	orr.w	r1, r1, #2214592512	; 0x84000000
 80157c8:	f8c2 1900 	str.w	r1, [r2, #2304]	; 0x900
    if (ep->xfer_len > 0U)
 80157cc:	e7c4      	b.n	8015758 <USB_EP0StartXfer+0xa8>
 80157ce:	bf00      	nop

080157d0 <USB_WritePacket>:
  count32b = ((uint32_t)len + 3U) / 4U;
 80157d0:	3303      	adds	r3, #3
  for (i = 0U; i < count32b; i++)
 80157d2:	089b      	lsrs	r3, r3, #2
 80157d4:	d009      	beq.n	80157ea <USB_WritePacket+0x1a>
    USBx_DFIFO((uint32_t)ch_ep_num) = __UNALIGNED_UINT32_READ(pSrc);
 80157d6:	3201      	adds	r2, #1
 80157d8:	eb00 3002 	add.w	r0, r0, r2, lsl #12
 80157dc:	eb01 0283 	add.w	r2, r1, r3, lsl #2
 80157e0:	f851 3b04 	ldr.w	r3, [r1], #4
 80157e4:	6003      	str	r3, [r0, #0]
  for (i = 0U; i < count32b; i++)
 80157e6:	428a      	cmp	r2, r1
 80157e8:	d1fa      	bne.n	80157e0 <USB_WritePacket+0x10>
}
 80157ea:	2000      	movs	r0, #0
 80157ec:	4770      	bx	lr
 80157ee:	bf00      	nop

080157f0 <USB_ReadPacket>:
  uint32_t count32b = ((uint32_t)len + 3U) / 4U;
 80157f0:	3203      	adds	r2, #3
  for (i = 0U; i < count32b; i++)
 80157f2:	0892      	lsrs	r2, r2, #2
 80157f4:	d00a      	beq.n	801580c <USB_ReadPacket+0x1c>
    __UNALIGNED_UINT32_WRITE(pDest, USBx_DFIFO(0U));
 80157f6:	f500 5c80 	add.w	ip, r0, #4096	; 0x1000
 80157fa:	eb01 0082 	add.w	r0, r1, r2, lsl #2
 80157fe:	f8dc 3000 	ldr.w	r3, [ip]
 8015802:	f841 3b04 	str.w	r3, [r1], #4
  for (i = 0U; i < count32b; i++)
 8015806:	4281      	cmp	r1, r0
 8015808:	d1f9      	bne.n	80157fe <USB_ReadPacket+0xe>
 801580a:	4770      	bx	lr
  uint32_t *pDest = (uint32_t *)dest;
 801580c:	4608      	mov	r0, r1
}
 801580e:	4770      	bx	lr

08015810 <USB_EPSetStall>:
  if (ep->is_in == 1U)
 8015810:	784a      	ldrb	r2, [r1, #1]
  uint32_t epnum = (uint32_t)ep->num;
 8015812:	780b      	ldrb	r3, [r1, #0]
  if (ep->is_in == 1U)
 8015814:	2a01      	cmp	r2, #1
    if (((USBx_INEP(epnum)->DIEPCTL & USB_OTG_DIEPCTL_EPENA) == 0U) && (epnum != 0U))
 8015816:	eb00 1043 	add.w	r0, r0, r3, lsl #5
  if (ep->is_in == 1U)
 801581a:	d00c      	beq.n	8015836 <USB_EPSetStall+0x26>
    if (((USBx_OUTEP(epnum)->DOEPCTL & USB_OTG_DOEPCTL_EPENA) == 0U) && (epnum != 0U))
 801581c:	f8d0 2b00 	ldr.w	r2, [r0, #2816]	; 0xb00
 8015820:	2a00      	cmp	r2, #0
 8015822:	db00      	blt.n	8015826 <USB_EPSetStall+0x16>
 8015824:	b9d3      	cbnz	r3, 801585c <USB_EPSetStall+0x4c>
    USBx_OUTEP(epnum)->DOEPCTL |= USB_OTG_DOEPCTL_STALL;
 8015826:	f8d0 3b00 	ldr.w	r3, [r0, #2816]	; 0xb00
 801582a:	f443 1300 	orr.w	r3, r3, #2097152	; 0x200000
 801582e:	f8c0 3b00 	str.w	r3, [r0, #2816]	; 0xb00
}
 8015832:	2000      	movs	r0, #0
 8015834:	4770      	bx	lr
    if (((USBx_INEP(epnum)->DIEPCTL & USB_OTG_DIEPCTL_EPENA) == 0U) && (epnum != 0U))
 8015836:	f8d0 2900 	ldr.w	r2, [r0, #2304]	; 0x900
 801583a:	2a00      	cmp	r2, #0
 801583c:	db06      	blt.n	801584c <USB_EPSetStall+0x3c>
 801583e:	b12b      	cbz	r3, 801584c <USB_EPSetStall+0x3c>
      USBx_INEP(epnum)->DIEPCTL &= ~(USB_OTG_DIEPCTL_EPDIS);
 8015840:	f8d0 3900 	ldr.w	r3, [r0, #2304]	; 0x900
 8015844:	f023 4380 	bic.w	r3, r3, #1073741824	; 0x40000000
 8015848:	f8c0 3900 	str.w	r3, [r0, #2304]	; 0x900
    USBx_INEP(epnum)->DIEPCTL |= USB_OTG_DIEPCTL_STALL;
 801584c:	f8d0 3900 	ldr.w	r3, [r0, #2304]	; 0x900
 8015850:	f443 1300 	orr.w	r3, r3, #2097152	; 0x200000
 8015854:	f8c0 3900 	str.w	r3, [r0, #2304]	; 0x900
}
 8015858:	2000      	movs	r0, #0
 801585a:	4770      	bx	lr
      USBx_OUTEP(epnum)->DOEPCTL &= ~(USB_OTG_DOEPCTL_EPDIS);
 801585c:	f8d0 3b00 	ldr.w	r3, [r0, #2816]	; 0xb00
 8015860:	f023 4380 	bic.w	r3, r3, #1073741824	; 0x40000000
 8015864:	f8c0 3b00 	str.w	r3, [r0, #2816]	; 0xb00
 8015868:	e7dd      	b.n	8015826 <USB_EPSetStall+0x16>
 801586a:	bf00      	nop

0801586c <USB_EPClearStall>:
  if (ep->is_in == 1U)
 801586c:	784a      	ldrb	r2, [r1, #1]
  uint32_t epnum = (uint32_t)ep->num;
 801586e:	780b      	ldrb	r3, [r1, #0]
  if (ep->is_in == 1U)
 8015870:	2a01      	cmp	r2, #1
    USBx_INEP(epnum)->DIEPCTL &= ~USB_OTG_DIEPCTL_STALL;
 8015872:	eb00 1043 	add.w	r0, r0, r3, lsl #5
  if (ep->is_in == 1U)
 8015876:	d013      	beq.n	80158a0 <USB_EPClearStall+0x34>
    USBx_OUTEP(epnum)->DOEPCTL &= ~USB_OTG_DOEPCTL_STALL;
 8015878:	f8d0 3b00 	ldr.w	r3, [r0, #2816]	; 0xb00
 801587c:	f423 1300 	bic.w	r3, r3, #2097152	; 0x200000
 8015880:	f8c0 3b00 	str.w	r3, [r0, #2816]	; 0xb00
    if ((ep->type == EP_TYPE_INTR) || (ep->type == EP_TYPE_BULK))
 8015884:	78cb      	ldrb	r3, [r1, #3]
 8015886:	3b02      	subs	r3, #2
 8015888:	2b01      	cmp	r3, #1
 801588a:	d901      	bls.n	8015890 <USB_EPClearStall+0x24>
}
 801588c:	2000      	movs	r0, #0
 801588e:	4770      	bx	lr
      USBx_OUTEP(epnum)->DOEPCTL |= USB_OTG_DOEPCTL_SD0PID_SEVNFRM; /* DATA0 */
 8015890:	f8d0 3b00 	ldr.w	r3, [r0, #2816]	; 0xb00
 8015894:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 8015898:	f8c0 3b00 	str.w	r3, [r0, #2816]	; 0xb00
}
 801589c:	2000      	movs	r0, #0
 801589e:	4770      	bx	lr
    USBx_INEP(epnum)->DIEPCTL &= ~USB_OTG_DIEPCTL_STALL;
 80158a0:	f8d0 3900 	ldr.w	r3, [r0, #2304]	; 0x900
 80158a4:	f423 1300 	bic.w	r3, r3, #2097152	; 0x200000
 80158a8:	f8c0 3900 	str.w	r3, [r0, #2304]	; 0x900
    if ((ep->type == EP_TYPE_INTR) || (ep->type == EP_TYPE_BULK))
 80158ac:	78cb      	ldrb	r3, [r1, #3]
 80158ae:	3b02      	subs	r3, #2
 80158b0:	2b01      	cmp	r3, #1
 80158b2:	d8eb      	bhi.n	801588c <USB_EPClearStall+0x20>
      USBx_INEP(epnum)->DIEPCTL |= USB_OTG_DIEPCTL_SD0PID_SEVNFRM; /* DATA0 */
 80158b4:	f8d0 3900 	ldr.w	r3, [r0, #2304]	; 0x900
 80158b8:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 80158bc:	f8c0 3900 	str.w	r3, [r0, #2304]	; 0x900
}
 80158c0:	2000      	movs	r0, #0
 80158c2:	4770      	bx	lr

080158c4 <USB_StopDevice>:
{
 80158c4:	b410      	push	{r4}
 80158c6:	f500 6310 	add.w	r3, r0, #2304	; 0x900
 80158ca:	f500 6c2e 	add.w	ip, r0, #2784	; 0xae0
    USBx_INEP(i)->DIEPINT = 0xFB7FU;
 80158ce:	f64f 327f 	movw	r2, #64383	; 0xfb7f
 80158d2:	609a      	str	r2, [r3, #8]
    USBx_OUTEP(i)->DOEPINT = 0xFB7FU;
 80158d4:	f503 7100 	add.w	r1, r3, #512	; 0x200
  for (i = 0U; i < 15U; i++)
 80158d8:	3320      	adds	r3, #32
 80158da:	4563      	cmp	r3, ip
    USBx_OUTEP(i)->DOEPINT = 0xFB7FU;
 80158dc:	608a      	str	r2, [r1, #8]
  for (i = 0U; i < 15U; i++)
 80158de:	d1f8      	bne.n	80158d2 <USB_StopDevice+0xe>
  USBx_DEVICE->DIEPMSK  = 0U;
 80158e0:	2100      	movs	r1, #0
  USBx->GRSTCTL = USB_OTG_GRSTCTL_RXFFLSH;
 80158e2:	2410      	movs	r4, #16
  USBx_DEVICE->DIEPMSK  = 0U;
 80158e4:	f8c0 1810 	str.w	r1, [r0, #2064]	; 0x810
  USBx->GRSTCTL = USB_OTG_GRSTCTL_RXFFLSH;
 80158e8:	4b0f      	ldr	r3, [pc, #60]	; (8015928 <USB_StopDevice+0x64>)
  USBx_DEVICE->DOEPMSK  = 0U;
 80158ea:	f8c0 1814 	str.w	r1, [r0, #2068]	; 0x814
  USBx_DEVICE->DAINTMSK = 0U;
 80158ee:	f8c0 181c 	str.w	r1, [r0, #2076]	; 0x81c
  USBx->GRSTCTL = USB_OTG_GRSTCTL_RXFFLSH;
 80158f2:	6104      	str	r4, [r0, #16]
    if (++count > 200000U)
 80158f4:	e001      	b.n	80158fa <USB_StopDevice+0x36>
 80158f6:	3b01      	subs	r3, #1
 80158f8:	d011      	beq.n	801591e <USB_StopDevice+0x5a>
  while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_RXFFLSH) == USB_OTG_GRSTCTL_RXFFLSH);
 80158fa:	6902      	ldr	r2, [r0, #16]
 80158fc:	06d2      	lsls	r2, r2, #27
 80158fe:	d4fa      	bmi.n	80158f6 <USB_StopDevice+0x32>
  USBx->GRSTCTL = (USB_OTG_GRSTCTL_TXFFLSH | (num << 6));
 8015900:	f44f 6384 	mov.w	r3, #1056	; 0x420
 8015904:	4a08      	ldr	r2, [pc, #32]	; (8015928 <USB_StopDevice+0x64>)
 8015906:	6103      	str	r3, [r0, #16]
    if (++count > 200000U)
 8015908:	e001      	b.n	801590e <USB_StopDevice+0x4a>
 801590a:	3a01      	subs	r2, #1
 801590c:	d007      	beq.n	801591e <USB_StopDevice+0x5a>
  while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_TXFFLSH) == USB_OTG_GRSTCTL_TXFFLSH);
 801590e:	6903      	ldr	r3, [r0, #16]
 8015910:	f013 0320 	ands.w	r3, r3, #32
 8015914:	d1f9      	bne.n	801590a <USB_StopDevice+0x46>
  return HAL_OK;
 8015916:	4618      	mov	r0, r3
}
 8015918:	f85d 4b04 	ldr.w	r4, [sp], #4
 801591c:	4770      	bx	lr
      return HAL_TIMEOUT;
 801591e:	2003      	movs	r0, #3
}
 8015920:	f85d 4b04 	ldr.w	r4, [sp], #4
 8015924:	4770      	bx	lr
 8015926:	bf00      	nop
 8015928:	00030d40 	.word	0x00030d40

0801592c <USB_SetDevAddress>:
  USBx_DEVICE->DCFG &= ~(USB_OTG_DCFG_DAD);
 801592c:	f8d0 3800 	ldr.w	r3, [r0, #2048]	; 0x800
 8015930:	f423 63fe 	bic.w	r3, r3, #2032	; 0x7f0
 8015934:	f8c0 3800 	str.w	r3, [r0, #2048]	; 0x800
  USBx_DEVICE->DCFG |= ((uint32_t)address << 4) & USB_OTG_DCFG_DAD;
 8015938:	f8d0 3800 	ldr.w	r3, [r0, #2048]	; 0x800
 801593c:	0109      	lsls	r1, r1, #4
 801593e:	f401 61fe 	and.w	r1, r1, #2032	; 0x7f0
 8015942:	4319      	orrs	r1, r3
 8015944:	f8c0 1800 	str.w	r1, [r0, #2048]	; 0x800
}
 8015948:	2000      	movs	r0, #0
 801594a:	4770      	bx	lr

0801594c <USB_DevConnect>:
{
 801594c:	b508      	push	{r3, lr}
 801594e:	4603      	mov	r3, r0
  HAL_Delay(3U);
 8015950:	2003      	movs	r0, #3
  USBx_DEVICE->DCTL &= ~USB_OTG_DCTL_SDIS;
 8015952:	f8d3 2804 	ldr.w	r2, [r3, #2052]	; 0x804
 8015956:	f022 0202 	bic.w	r2, r2, #2
 801595a:	f8c3 2804 	str.w	r2, [r3, #2052]	; 0x804
  HAL_Delay(3U);
 801595e:	f00d f82d 	bl	80229bc <HAL_Delay>
}
 8015962:	2000      	movs	r0, #0
 8015964:	bd08      	pop	{r3, pc}
 8015966:	bf00      	nop

08015968 <USB_DevDisconnect>:
{
 8015968:	b508      	push	{r3, lr}
 801596a:	4603      	mov	r3, r0
  HAL_Delay(3U);
 801596c:	2003      	movs	r0, #3
  USBx_DEVICE->DCTL |= USB_OTG_DCTL_SDIS;
 801596e:	f8d3 2804 	ldr.w	r2, [r3, #2052]	; 0x804
 8015972:	f042 0202 	orr.w	r2, r2, #2
 8015976:	f8c3 2804 	str.w	r2, [r3, #2052]	; 0x804
  HAL_Delay(3U);
 801597a:	f00d f81f 	bl	80229bc <HAL_Delay>
}
 801597e:	2000      	movs	r0, #0
 8015980:	bd08      	pop	{r3, pc}
 8015982:	bf00      	nop

08015984 <USB_ReadInterrupts>:
  tmpreg = USBx->GINTSTS;
 8015984:	6942      	ldr	r2, [r0, #20]
  tmpreg &= USBx->GINTMSK;
 8015986:	6980      	ldr	r0, [r0, #24]
}
 8015988:	4010      	ands	r0, r2
 801598a:	4770      	bx	lr

0801598c <USB_ReadDevAllOutEpInterrupt>:
  tmpreg  = USBx_DEVICE->DAINT;
 801598c:	f8d0 3818 	ldr.w	r3, [r0, #2072]	; 0x818
 8015990:	f500 6000 	add.w	r0, r0, #2048	; 0x800
  tmpreg &= USBx_DEVICE->DAINTMSK;
 8015994:	69c0      	ldr	r0, [r0, #28]
 8015996:	4018      	ands	r0, r3
}
 8015998:	0c00      	lsrs	r0, r0, #16
 801599a:	4770      	bx	lr

0801599c <USB_ReadDevAllInEpInterrupt>:
  tmpreg  = USBx_DEVICE->DAINT;
 801599c:	f8d0 3818 	ldr.w	r3, [r0, #2072]	; 0x818
 80159a0:	f500 6000 	add.w	r0, r0, #2048	; 0x800
  tmpreg &= USBx_DEVICE->DAINTMSK;
 80159a4:	69c0      	ldr	r0, [r0, #28]
 80159a6:	4018      	ands	r0, r3
}
 80159a8:	b280      	uxth	r0, r0
 80159aa:	4770      	bx	lr

080159ac <USB_ReadDevOutEPInterrupt>:
  tmpreg  = USBx_OUTEP((uint32_t)epnum)->DOEPINT;
 80159ac:	eb00 1141 	add.w	r1, r0, r1, lsl #5
  tmpreg &= USBx_DEVICE->DOEPMSK;
 80159b0:	f500 6000 	add.w	r0, r0, #2048	; 0x800
  tmpreg  = USBx_OUTEP((uint32_t)epnum)->DOEPINT;
 80159b4:	f8d1 2b08 	ldr.w	r2, [r1, #2824]	; 0xb08
  tmpreg &= USBx_DEVICE->DOEPMSK;
 80159b8:	6940      	ldr	r0, [r0, #20]
}
 80159ba:	4010      	ands	r0, r2
 80159bc:	4770      	bx	lr
 80159be:	bf00      	nop

080159c0 <USB_ReadDevInEPInterrupt>:
  msk = USBx_DEVICE->DIEPMSK;
 80159c0:	f8d0 2810 	ldr.w	r2, [r0, #2064]	; 0x810
  emp = USBx_DEVICE->DIEPEMPMSK;
 80159c4:	f8d0 3834 	ldr.w	r3, [r0, #2100]	; 0x834
  tmpreg = USBx_INEP((uint32_t)epnum)->DIEPINT & msk;
 80159c8:	eb00 1041 	add.w	r0, r0, r1, lsl #5
  msk |= ((emp >> (epnum & EP_ADDR_MSK)) & 0x1U) << 7;
 80159cc:	f001 010f 	and.w	r1, r1, #15
 80159d0:	40cb      	lsrs	r3, r1
 80159d2:	01db      	lsls	r3, r3, #7
  tmpreg = USBx_INEP((uint32_t)epnum)->DIEPINT & msk;
 80159d4:	f8d0 0908 	ldr.w	r0, [r0, #2312]	; 0x908
  msk |= ((emp >> (epnum & EP_ADDR_MSK)) & 0x1U) << 7;
 80159d8:	b2db      	uxtb	r3, r3
 80159da:	4313      	orrs	r3, r2
}
 80159dc:	4018      	ands	r0, r3
 80159de:	4770      	bx	lr

080159e0 <USB_GetMode>:
  return ((USBx->GINTSTS) & 0x1U);
 80159e0:	6940      	ldr	r0, [r0, #20]
}
 80159e2:	f000 0001 	and.w	r0, r0, #1
 80159e6:	4770      	bx	lr

080159e8 <USB_ActivateSetup>:
  USBx_INEP(0U)->DIEPCTL &= ~USB_OTG_DIEPCTL_MPSIZ;
 80159e8:	f8d0 3900 	ldr.w	r3, [r0, #2304]	; 0x900
 80159ec:	f423 63ff 	bic.w	r3, r3, #2040	; 0x7f8
 80159f0:	f023 0307 	bic.w	r3, r3, #7
  if ((USBx_DEVICE->DSTS & USB_OTG_DSTS_ENUMSPD) == DSTS_ENUMSPD_LS_PHY_6MHZ)
 80159f4:	f500 6200 	add.w	r2, r0, #2048	; 0x800
  USBx_INEP(0U)->DIEPCTL &= ~USB_OTG_DIEPCTL_MPSIZ;
 80159f8:	f8c0 3900 	str.w	r3, [r0, #2304]	; 0x900
  if ((USBx_DEVICE->DSTS & USB_OTG_DSTS_ENUMSPD) == DSTS_ENUMSPD_LS_PHY_6MHZ)
 80159fc:	6893      	ldr	r3, [r2, #8]
 80159fe:	f003 0306 	and.w	r3, r3, #6
 8015a02:	2b04      	cmp	r3, #4
 8015a04:	d105      	bne.n	8015a12 <USB_ActivateSetup+0x2a>
    USBx_INEP(0U)->DIEPCTL |= 3U;
 8015a06:	f8d0 3900 	ldr.w	r3, [r0, #2304]	; 0x900
 8015a0a:	f043 0303 	orr.w	r3, r3, #3
 8015a0e:	f8c0 3900 	str.w	r3, [r0, #2304]	; 0x900
  USBx_DEVICE->DCTL |= USB_OTG_DCTL_CGINAK;
 8015a12:	6853      	ldr	r3, [r2, #4]
 8015a14:	f443 7380 	orr.w	r3, r3, #256	; 0x100
}
 8015a18:	2000      	movs	r0, #0
  USBx_DEVICE->DCTL |= USB_OTG_DCTL_CGINAK;
 8015a1a:	6053      	str	r3, [r2, #4]
}
 8015a1c:	4770      	bx	lr
 8015a1e:	bf00      	nop

08015a20 <USB_EP0_OutStart>:
  if (gSNPSiD > USB_OTG_CORE_ID_300A)
 8015a20:	4b0e      	ldr	r3, [pc, #56]	; (8015a5c <USB_EP0_OutStart+0x3c>)
  uint32_t gSNPSiD = *(__IO uint32_t *)(&USBx->CID + 0x1U);
 8015a22:	6c02      	ldr	r2, [r0, #64]	; 0x40
  if (gSNPSiD > USB_OTG_CORE_ID_300A)
 8015a24:	429a      	cmp	r2, r3
 8015a26:	d811      	bhi.n	8015a4c <USB_EP0_OutStart+0x2c>
    if ((USBx_OUTEP(0U)->DOEPCTL & USB_OTG_DOEPCTL_EPENA) == USB_OTG_DOEPCTL_EPENA)
 8015a28:	f500 6030 	add.w	r0, r0, #2816	; 0xb00
  USBx_OUTEP(0U)->DOEPTSIZ = 0U;
 8015a2c:	2300      	movs	r3, #0
 8015a2e:	6103      	str	r3, [r0, #16]
  USBx_OUTEP(0U)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_PKTCNT & (1U << 19));
 8015a30:	6903      	ldr	r3, [r0, #16]
 8015a32:	f443 2300 	orr.w	r3, r3, #524288	; 0x80000
 8015a36:	6103      	str	r3, [r0, #16]
  USBx_OUTEP(0U)->DOEPTSIZ |= (3U * 8U);
 8015a38:	6903      	ldr	r3, [r0, #16]
 8015a3a:	f043 0318 	orr.w	r3, r3, #24
 8015a3e:	6103      	str	r3, [r0, #16]
  USBx_OUTEP(0U)->DOEPTSIZ |=  USB_OTG_DOEPTSIZ_STUPCNT;
 8015a40:	6903      	ldr	r3, [r0, #16]
 8015a42:	f043 43c0 	orr.w	r3, r3, #1610612736	; 0x60000000
 8015a46:	6103      	str	r3, [r0, #16]
}
 8015a48:	2000      	movs	r0, #0
 8015a4a:	4770      	bx	lr
    if ((USBx_OUTEP(0U)->DOEPCTL & USB_OTG_DOEPCTL_EPENA) == USB_OTG_DOEPCTL_EPENA)
 8015a4c:	f8d0 3b00 	ldr.w	r3, [r0, #2816]	; 0xb00
 8015a50:	2b00      	cmp	r3, #0
 8015a52:	f500 6030 	add.w	r0, r0, #2816	; 0xb00
 8015a56:	dae9      	bge.n	8015a2c <USB_EP0_OutStart+0xc>
}
 8015a58:	2000      	movs	r0, #0
 8015a5a:	4770      	bx	lr
 8015a5c:	4f54300a 	.word	0x4f54300a

08015a60 <disk_status>:
	BYTE pdrv		/* Physical drive number to identify the drive */
)
{
  DSTATUS stat;

  stat = disk.drv[pdrv]->disk_status(disk.lun[pdrv]);
 8015a60:	4b03      	ldr	r3, [pc, #12]	; (8015a70 <disk_status+0x10>)
 8015a62:	eb03 0280 	add.w	r2, r3, r0, lsl #2
 8015a66:	4403      	add	r3, r0
 8015a68:	6852      	ldr	r2, [r2, #4]
 8015a6a:	7a18      	ldrb	r0, [r3, #8]
 8015a6c:	6853      	ldr	r3, [r2, #4]
 8015a6e:	4718      	bx	r3
 8015a70:	20003338 	.word	0x20003338

08015a74 <disk_initialize>:
	BYTE pdrv				/* Physical drive nmuber to identify the drive */
)
{
  DSTATUS stat = RES_OK;

  if(disk.is_initialized[pdrv] == 0)
 8015a74:	4b06      	ldr	r3, [pc, #24]	; (8015a90 <disk_initialize+0x1c>)
 8015a76:	5c1a      	ldrb	r2, [r3, r0]
 8015a78:	b942      	cbnz	r2, 8015a8c <disk_initialize+0x18>
  {
    disk.is_initialized[pdrv] = 1;
    stat = disk.drv[pdrv]->disk_initialize(disk.lun[pdrv]);
 8015a7a:	eb03 0280 	add.w	r2, r3, r0, lsl #2
    disk.is_initialized[pdrv] = 1;
 8015a7e:	2101      	movs	r1, #1
 8015a80:	5419      	strb	r1, [r3, r0]
    stat = disk.drv[pdrv]->disk_initialize(disk.lun[pdrv]);
 8015a82:	6852      	ldr	r2, [r2, #4]
 8015a84:	4418      	add	r0, r3
 8015a86:	6813      	ldr	r3, [r2, #0]
 8015a88:	7a00      	ldrb	r0, [r0, #8]
 8015a8a:	4718      	bx	r3
  }
  return stat;
}
 8015a8c:	2000      	movs	r0, #0
 8015a8e:	4770      	bx	lr
 8015a90:	20003338 	.word	0x20003338

08015a94 <disk_read>:
	BYTE pdrv,		/* Physical drive nmuber to identify the drive */
	BYTE *buff,		/* Data buffer to store read data */
	DWORD sector,	        /* Sector address in LBA */
	UINT count		/* Number of sectors to read */
)
{
 8015a94:	b430      	push	{r4, r5}
  DRESULT res;

  res = disk.drv[pdrv]->disk_read(disk.lun[pdrv], buff, sector, count);
 8015a96:	4c05      	ldr	r4, [pc, #20]	; (8015aac <disk_read+0x18>)
 8015a98:	eb04 0580 	add.w	r5, r4, r0, lsl #2
 8015a9c:	4404      	add	r4, r0
 8015a9e:	686d      	ldr	r5, [r5, #4]
 8015aa0:	7a20      	ldrb	r0, [r4, #8]
 8015aa2:	68ac      	ldr	r4, [r5, #8]
 8015aa4:	46a4      	mov	ip, r4
  return res;
}
 8015aa6:	bc30      	pop	{r4, r5}
  res = disk.drv[pdrv]->disk_read(disk.lun[pdrv], buff, sector, count);
 8015aa8:	4760      	bx	ip
 8015aaa:	bf00      	nop
 8015aac:	20003338 	.word	0x20003338

08015ab0 <disk_write>:
	BYTE pdrv,		/* Physical drive nmuber to identify the drive */
	const BYTE *buff,	/* Data to be written */
	DWORD sector,		/* Sector address in LBA */
	UINT count        	/* Number of sectors to write */
)
{
 8015ab0:	b430      	push	{r4, r5}
  DRESULT res;

  res = disk.drv[pdrv]->disk_write(disk.lun[pdrv], buff, sector, count);
 8015ab2:	4c05      	ldr	r4, [pc, #20]	; (8015ac8 <disk_write+0x18>)
 8015ab4:	eb04 0580 	add.w	r5, r4, r0, lsl #2
 8015ab8:	4404      	add	r4, r0
 8015aba:	686d      	ldr	r5, [r5, #4]
 8015abc:	7a20      	ldrb	r0, [r4, #8]
 8015abe:	68ec      	ldr	r4, [r5, #12]
 8015ac0:	46a4      	mov	ip, r4
  return res;
}
 8015ac2:	bc30      	pop	{r4, r5}
  res = disk.drv[pdrv]->disk_write(disk.lun[pdrv], buff, sector, count);
 8015ac4:	4760      	bx	ip
 8015ac6:	bf00      	nop
 8015ac8:	20003338 	.word	0x20003338

08015acc <disk_ioctl>:
	void *buff		/* Buffer to send/receive control data */
)
{
  DRESULT res;

  res = disk.drv[pdrv]->disk_ioctl(disk.lun[pdrv], cmd, buff);
 8015acc:	4b04      	ldr	r3, [pc, #16]	; (8015ae0 <disk_ioctl+0x14>)
 8015ace:	eb03 0c00 	add.w	ip, r3, r0
 8015ad2:	eb03 0380 	add.w	r3, r3, r0, lsl #2
 8015ad6:	f89c 0008 	ldrb.w	r0, [ip, #8]
 8015ada:	685b      	ldr	r3, [r3, #4]
 8015adc:	691b      	ldr	r3, [r3, #16]
 8015ade:	4718      	bx	r3
 8015ae0:	20003338 	.word	0x20003338

08015ae4 <chk_lock>:
{
	UINT i, be;

	/* Search file semaphore table */
	for (i = be = 0; i < _FS_LOCK; i++) {
		if (Files[i].fs) {	/* Existing entry */
 8015ae4:	4a27      	ldr	r2, [pc, #156]	; (8015b84 <chk_lock+0xa0>)
 8015ae6:	6813      	ldr	r3, [r2, #0]
{
 8015ae8:	b470      	push	{r4, r5, r6}
		if (Files[i].fs) {	/* Existing entry */
 8015aea:	b33b      	cbz	r3, 8015b3c <chk_lock+0x58>
			if (Files[i].fs == dp->obj.fs &&	 	/* Check if the object matched with an open object */
 8015aec:	6804      	ldr	r4, [r0, #0]
 8015aee:	429c      	cmp	r4, r3
 8015af0:	d009      	beq.n	8015b06 <chk_lock+0x22>
		if (Files[i].fs) {	/* Existing entry */
 8015af2:	6913      	ldr	r3, [r2, #16]
 8015af4:	b33b      	cbz	r3, 8015b46 <chk_lock+0x62>
			if (Files[i].fs == dp->obj.fs &&	 	/* Check if the object matched with an open object */
 8015af6:	42a3      	cmp	r3, r4
 8015af8:	d03c      	beq.n	8015b74 <chk_lock+0x90>
		} else {			/* Blank entry */
			be = 1;
		}
	}
	if (i == _FS_LOCK) {	/* The object is not opened */
		return (be || acc == 2) ? FR_OK : FR_TOO_MANY_OPEN_FILES;	/* Is there a blank entry for new object? */
 8015afa:	2902      	cmp	r1, #2
 8015afc:	bf0c      	ite	eq
 8015afe:	2000      	moveq	r0, #0
 8015b00:	2012      	movne	r0, #18
	}

	/* The object has been opened. Reject any open against writing file and all write mode open */
	return (acc || Files[i].ctr == 0x100) ? FR_LOCKED : FR_OK;
}
 8015b02:	bc70      	pop	{r4, r5, r6}
 8015b04:	4770      	bx	lr
			if (Files[i].fs == dp->obj.fs &&	 	/* Check if the object matched with an open object */
 8015b06:	6853      	ldr	r3, [r2, #4]
 8015b08:	6885      	ldr	r5, [r0, #8]
 8015b0a:	42ab      	cmp	r3, r5
 8015b0c:	d01e      	beq.n	8015b4c <chk_lock+0x68>
		if (Files[i].fs) {	/* Existing entry */
 8015b0e:	6913      	ldr	r3, [r2, #16]
 8015b10:	b1cb      	cbz	r3, 8015b46 <chk_lock+0x62>
			if (Files[i].fs == dp->obj.fs &&	 	/* Check if the object matched with an open object */
 8015b12:	429c      	cmp	r4, r3
 8015b14:	d1f1      	bne.n	8015afa <chk_lock+0x16>
 8015b16:	6953      	ldr	r3, [r2, #20]
 8015b18:	42ab      	cmp	r3, r5
 8015b1a:	d1ee      	bne.n	8015afa <chk_lock+0x16>
				Files[i].clu == dp->obj.sclust &&
 8015b1c:	6994      	ldr	r4, [r2, #24]
 8015b1e:	6943      	ldr	r3, [r0, #20]
 8015b20:	429c      	cmp	r4, r3
 8015b22:	d1ea      	bne.n	8015afa <chk_lock+0x16>
	for (i = be = 0; i < _FS_LOCK; i++) {
 8015b24:	2301      	movs	r3, #1
	return (acc || Files[i].ctr == 0x100) ? FR_LOCKED : FR_OK;
 8015b26:	b9c1      	cbnz	r1, 8015b5a <chk_lock+0x76>
 8015b28:	eb02 1203 	add.w	r2, r2, r3, lsl #4
}
 8015b2c:	bc70      	pop	{r4, r5, r6}
	return (acc || Files[i].ctr == 0x100) ? FR_LOCKED : FR_OK;
 8015b2e:	8993      	ldrh	r3, [r2, #12]
 8015b30:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 8015b34:	bf14      	ite	ne
 8015b36:	2000      	movne	r0, #0
 8015b38:	2010      	moveq	r0, #16
}
 8015b3a:	4770      	bx	lr
		if (Files[i].fs) {	/* Existing entry */
 8015b3c:	6914      	ldr	r4, [r2, #16]
 8015b3e:	b1f4      	cbz	r4, 8015b7e <chk_lock+0x9a>
			if (Files[i].fs == dp->obj.fs &&	 	/* Check if the object matched with an open object */
 8015b40:	6805      	ldr	r5, [r0, #0]
 8015b42:	42a5      	cmp	r5, r4
 8015b44:	d00c      	beq.n	8015b60 <chk_lock+0x7c>
	return (acc || Files[i].ctr == 0x100) ? FR_LOCKED : FR_OK;
 8015b46:	4618      	mov	r0, r3
}
 8015b48:	bc70      	pop	{r4, r5, r6}
 8015b4a:	4770      	bx	lr
				Files[i].clu == dp->obj.sclust &&
 8015b4c:	6943      	ldr	r3, [r0, #20]
 8015b4e:	6896      	ldr	r6, [r2, #8]
 8015b50:	429e      	cmp	r6, r3
 8015b52:	d1dc      	bne.n	8015b0e <chk_lock+0x2a>
	for (i = be = 0; i < _FS_LOCK; i++) {
 8015b54:	2300      	movs	r3, #0
	return (acc || Files[i].ctr == 0x100) ? FR_LOCKED : FR_OK;
 8015b56:	2900      	cmp	r1, #0
 8015b58:	d0e6      	beq.n	8015b28 <chk_lock+0x44>
 8015b5a:	2010      	movs	r0, #16
}
 8015b5c:	bc70      	pop	{r4, r5, r6}
 8015b5e:	4770      	bx	lr
			if (Files[i].fs == dp->obj.fs &&	 	/* Check if the object matched with an open object */
 8015b60:	6955      	ldr	r5, [r2, #20]
 8015b62:	6884      	ldr	r4, [r0, #8]
 8015b64:	42a5      	cmp	r5, r4
 8015b66:	d1ee      	bne.n	8015b46 <chk_lock+0x62>
				Files[i].clu == dp->obj.sclust &&
 8015b68:	6994      	ldr	r4, [r2, #24]
 8015b6a:	6940      	ldr	r0, [r0, #20]
 8015b6c:	4284      	cmp	r4, r0
 8015b6e:	d0d9      	beq.n	8015b24 <chk_lock+0x40>
	return (acc || Files[i].ctr == 0x100) ? FR_LOCKED : FR_OK;
 8015b70:	4618      	mov	r0, r3
 8015b72:	e7e9      	b.n	8015b48 <chk_lock+0x64>
 8015b74:	6885      	ldr	r5, [r0, #8]
			if (Files[i].fs == dp->obj.fs &&	 	/* Check if the object matched with an open object */
 8015b76:	6953      	ldr	r3, [r2, #20]
 8015b78:	42ab      	cmp	r3, r5
 8015b7a:	d1be      	bne.n	8015afa <chk_lock+0x16>
 8015b7c:	e7ce      	b.n	8015b1c <chk_lock+0x38>
	return (acc || Files[i].ctr == 0x100) ? FR_LOCKED : FR_OK;
 8015b7e:	4620      	mov	r0, r4
 8015b80:	e7bf      	b.n	8015b02 <chk_lock+0x1e>
 8015b82:	bf00      	nop
 8015b84:	20003310 	.word	0x20003310

08015b88 <inc_lock>:
{
	UINT i;


	for (i = 0; i < _FS_LOCK; i++) {	/* Find the object */
		if (Files[i].fs == dp->obj.fs &&
 8015b88:	4b2a      	ldr	r3, [pc, #168]	; (8015c34 <inc_lock+0xac>)
{
 8015b8a:	b4f0      	push	{r4, r5, r6, r7}
		if (Files[i].fs == dp->obj.fs &&
 8015b8c:	681a      	ldr	r2, [r3, #0]
 8015b8e:	6805      	ldr	r5, [r0, #0]
 8015b90:	4295      	cmp	r5, r2
 8015b92:	d01d      	beq.n	8015bd0 <inc_lock+0x48>
 8015b94:	691c      	ldr	r4, [r3, #16]
 8015b96:	42ac      	cmp	r4, r5
 8015b98:	d007      	beq.n	8015baa <inc_lock+0x22>
			Files[i].clu == dp->obj.sclust &&
			Files[i].ofs == dp->dptr) break;
	}

	if (i == _FS_LOCK) {				/* Not opened. Register it as new. */
		for (i = 0; i < _FS_LOCK && Files[i].fs; i++) ;
 8015b9a:	2a00      	cmp	r2, #0
 8015b9c:	d02e      	beq.n	8015bfc <inc_lock+0x74>
 8015b9e:	2c00      	cmp	r4, #0
 8015ba0:	d044      	beq.n	8015c2c <inc_lock+0xa4>
		if (i == _FS_LOCK) return 0;	/* No free entry to register (int err) */
 8015ba2:	2400      	movs	r4, #0
	if (acc && Files[i].ctr) return 0;	/* Access violation (int err) */

	Files[i].ctr = acc ? 0x100 : Files[i].ctr + 1;	/* Set semaphore value */

	return i + 1;
}
 8015ba4:	4620      	mov	r0, r4
 8015ba6:	bcf0      	pop	{r4, r5, r6, r7}
 8015ba8:	4770      	bx	lr
		if (Files[i].fs == dp->obj.fs &&
 8015baa:	695e      	ldr	r6, [r3, #20]
 8015bac:	6887      	ldr	r7, [r0, #8]
 8015bae:	42be      	cmp	r6, r7
 8015bb0:	d1f3      	bne.n	8015b9a <inc_lock+0x12>
			Files[i].clu == dp->obj.sclust &&
 8015bb2:	699e      	ldr	r6, [r3, #24]
 8015bb4:	6947      	ldr	r7, [r0, #20]
 8015bb6:	42be      	cmp	r6, r7
 8015bb8:	d1ef      	bne.n	8015b9a <inc_lock+0x12>
	for (i = 0; i < _FS_LOCK; i++) {	/* Find the object */
 8015bba:	2201      	movs	r2, #1
	if (acc && Files[i].ctr) return 0;	/* Access violation (int err) */
 8015bbc:	b999      	cbnz	r1, 8015be6 <inc_lock+0x5e>
	Files[i].ctr = acc ? 0x100 : Files[i].ctr + 1;	/* Set semaphore value */
 8015bbe:	eb03 1102 	add.w	r1, r3, r2, lsl #4
 8015bc2:	ea4f 1c02 	mov.w	ip, r2, lsl #4
 8015bc6:	8989      	ldrh	r1, [r1, #12]
	return i + 1;
 8015bc8:	1c54      	adds	r4, r2, #1
	Files[i].ctr = acc ? 0x100 : Files[i].ctr + 1;	/* Set semaphore value */
 8015bca:	1c4a      	adds	r2, r1, #1
 8015bcc:	b292      	uxth	r2, r2
 8015bce:	e028      	b.n	8015c22 <inc_lock+0x9a>
		if (Files[i].fs == dp->obj.fs &&
 8015bd0:	6884      	ldr	r4, [r0, #8]
 8015bd2:	685e      	ldr	r6, [r3, #4]
 8015bd4:	42a6      	cmp	r6, r4
 8015bd6:	d1dd      	bne.n	8015b94 <inc_lock+0xc>
			Files[i].clu == dp->obj.sclust &&
 8015bd8:	689c      	ldr	r4, [r3, #8]
 8015bda:	6946      	ldr	r6, [r0, #20]
 8015bdc:	42a6      	cmp	r6, r4
 8015bde:	d1d9      	bne.n	8015b94 <inc_lock+0xc>
	for (i = 0; i < _FS_LOCK; i++) {	/* Find the object */
 8015be0:	2200      	movs	r2, #0
	if (acc && Files[i].ctr) return 0;	/* Access violation (int err) */
 8015be2:	2900      	cmp	r1, #0
 8015be4:	d0eb      	beq.n	8015bbe <inc_lock+0x36>
 8015be6:	eb03 1102 	add.w	r1, r3, r2, lsl #4
 8015bea:	ea4f 1c02 	mov.w	ip, r2, lsl #4
 8015bee:	8989      	ldrh	r1, [r1, #12]
 8015bf0:	2900      	cmp	r1, #0
 8015bf2:	d1d6      	bne.n	8015ba2 <inc_lock+0x1a>
	return i + 1;
 8015bf4:	1c54      	adds	r4, r2, #1
	Files[i].ctr = acc ? 0x100 : Files[i].ctr + 1;	/* Set semaphore value */
 8015bf6:	f44f 7280 	mov.w	r2, #256	; 0x100
 8015bfa:	e012      	b.n	8015c22 <inc_lock+0x9a>
		for (i = 0; i < _FS_LOCK && Files[i].fs; i++) ;
 8015bfc:	2401      	movs	r4, #1
	if (acc && Files[i].ctr) return 0;	/* Access violation (int err) */
 8015bfe:	2900      	cmp	r1, #0
		Files[i].fs = dp->obj.fs;
 8015c00:	eb03 1102 	add.w	r1, r3, r2, lsl #4
 8015c04:	ea4f 1c02 	mov.w	ip, r2, lsl #4
		Files[i].clu = dp->obj.sclust;
 8015c08:	6882      	ldr	r2, [r0, #8]
 8015c0a:	604a      	str	r2, [r1, #4]
		Files[i].ofs = dp->dptr;
 8015c0c:	6942      	ldr	r2, [r0, #20]
 8015c0e:	608a      	str	r2, [r1, #8]
		Files[i].fs = dp->obj.fs;
 8015c10:	f843 500c 	str.w	r5, [r3, ip]
		Files[i].ctr = 0;
 8015c14:	f04f 0200 	mov.w	r2, #0
 8015c18:	818a      	strh	r2, [r1, #12]
	if (acc && Files[i].ctr) return 0;	/* Access violation (int err) */
 8015c1a:	bf14      	ite	ne
 8015c1c:	f44f 7280 	movne.w	r2, #256	; 0x100
 8015c20:	2201      	moveq	r2, #1
	Files[i].ctr = acc ? 0x100 : Files[i].ctr + 1;	/* Set semaphore value */
 8015c22:	4463      	add	r3, ip
}
 8015c24:	4620      	mov	r0, r4
	Files[i].ctr = acc ? 0x100 : Files[i].ctr + 1;	/* Set semaphore value */
 8015c26:	819a      	strh	r2, [r3, #12]
}
 8015c28:	bcf0      	pop	{r4, r5, r6, r7}
 8015c2a:	4770      	bx	lr
		for (i = 0; i < _FS_LOCK && Files[i].fs; i++) ;
 8015c2c:	2402      	movs	r4, #2
 8015c2e:	2201      	movs	r2, #1
 8015c30:	e7e5      	b.n	8015bfe <inc_lock+0x76>
 8015c32:	bf00      	nop
 8015c34:	20003310 	.word	0x20003310

08015c38 <get_ldnumber>:
	char c;
	TCHAR tc;
#endif


	if (*path) {	/* If the pointer is not a null */
 8015c38:	6801      	ldr	r1, [r0, #0]
 8015c3a:	b181      	cbz	r1, 8015c5e <get_ldnumber+0x26>
		for (tt = *path; (UINT)*tt >= (_USE_LFN ? ' ' : '!') && *tt != ':'; tt++) ;	/* Find ':' in the path */
 8015c3c:	f891 c000 	ldrb.w	ip, [r1]
 8015c40:	f1bc 0f1f 	cmp.w	ip, #31
 8015c44:	d913      	bls.n	8015c6e <get_ldnumber+0x36>
 8015c46:	460a      	mov	r2, r1
 8015c48:	4663      	mov	r3, ip
 8015c4a:	e003      	b.n	8015c54 <get_ldnumber+0x1c>
 8015c4c:	f812 3f01 	ldrb.w	r3, [r2, #1]!
 8015c50:	2b1f      	cmp	r3, #31
 8015c52:	d90c      	bls.n	8015c6e <get_ldnumber+0x36>
 8015c54:	2b3a      	cmp	r3, #58	; 0x3a
 8015c56:	d1f9      	bne.n	8015c4c <get_ldnumber+0x14>
		if (*tt == ':') {	/* If a ':' is exist in the path name */
			tp = *path;
			i = *tp++ - '0';
 8015c58:	3101      	adds	r1, #1
			if (i < 10 && tp == tt) {	/* Is there a numeric drive id? */
 8015c5a:	428a      	cmp	r2, r1
 8015c5c:	d002      	beq.n	8015c64 <get_ldnumber+0x2c>
	int vol = -1;
 8015c5e:	f04f 30ff 	mov.w	r0, #4294967295
#else
		vol = 0;		/* Drive 0 */
#endif
	}
	return vol;
}
 8015c62:	4770      	bx	lr
				if (i < _VOLUMES) {	/* If a drive id is found, get the value and strip it */
 8015c64:	f1bc 0f30 	cmp.w	ip, #48	; 0x30
 8015c68:	d1f9      	bne.n	8015c5e <get_ldnumber+0x26>
					*path = ++tt;
 8015c6a:	3201      	adds	r2, #1
 8015c6c:	6002      	str	r2, [r0, #0]
 8015c6e:	2000      	movs	r0, #0
 8015c70:	4770      	bx	lr
 8015c72:	bf00      	nop

08015c74 <validate>:
static
FRESULT validate (	/* Returns FR_OK or FR_INVALID_OBJECT */
	_FDID* obj,		/* Pointer to the _OBJ, the 1st member in the FIL/DIR object, to check validity */
	FATFS** fs		/* Pointer to pointer to the owner file system object to return */
)
{
 8015c74:	b538      	push	{r3, r4, r5, lr}
 8015c76:	460d      	mov	r5, r1
	FRESULT res = FR_INVALID_OBJECT;


	if (obj && obj->fs && obj->fs->fs_type && obj->id == obj->fs->id) {	/* Test if the object is valid */
 8015c78:	b140      	cbz	r0, 8015c8c <validate+0x18>
 8015c7a:	6803      	ldr	r3, [r0, #0]
 8015c7c:	4604      	mov	r4, r0
 8015c7e:	b12b      	cbz	r3, 8015c8c <validate+0x18>
 8015c80:	781a      	ldrb	r2, [r3, #0]
 8015c82:	b11a      	cbz	r2, 8015c8c <validate+0x18>
 8015c84:	8880      	ldrh	r0, [r0, #4]
 8015c86:	88da      	ldrh	r2, [r3, #6]
 8015c88:	4290      	cmp	r0, r2
 8015c8a:	d003      	beq.n	8015c94 <validate+0x20>
	FRESULT res = FR_INVALID_OBJECT;
 8015c8c:	2009      	movs	r0, #9
		if (!(disk_status(obj->fs->drv) & STA_NOINIT)) { /* Test if the phsical drive is kept initialized */
			res = FR_OK;
		}
#endif
	}
	*fs = (res == FR_OK) ? obj->fs : 0;	/* Corresponding filesystem object */
 8015c8e:	2300      	movs	r3, #0
 8015c90:	602b      	str	r3, [r5, #0]
	return res;
}
 8015c92:	bd38      	pop	{r3, r4, r5, pc}
		if (!(disk_status(obj->fs->drv) & STA_NOINIT)) { /* Test if the phsical drive is kept initialized */
 8015c94:	7858      	ldrb	r0, [r3, #1]
 8015c96:	f7ff fee3 	bl	8015a60 <disk_status>
 8015c9a:	f010 0001 	ands.w	r0, r0, #1
 8015c9e:	d1f5      	bne.n	8015c8c <validate+0x18>
	*fs = (res == FR_OK) ? obj->fs : 0;	/* Corresponding filesystem object */
 8015ca0:	6823      	ldr	r3, [r4, #0]
 8015ca2:	e7f5      	b.n	8015c90 <validate+0x1c>

08015ca4 <get_fileinfo>:
{
 8015ca4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	fno->fname[0] = 0;		/* Invaidate file info */
 8015ca8:	2600      	movs	r6, #0
	FATFS *fs = dp->obj.fs;
 8015caa:	f8d0 8000 	ldr.w	r8, [r0]
	fno->fname[0] = 0;		/* Invaidate file info */
 8015cae:	758e      	strb	r6, [r1, #22]
	if (!dp->sect) return;	/* Exit if read pointer has reached end of directory */
 8015cb0:	69c3      	ldr	r3, [r0, #28]
 8015cb2:	2b00      	cmp	r3, #0
 8015cb4:	d05a      	beq.n	8015d6c <get_fileinfo+0xc8>
		if (dp->blk_ofs != 0xFFFFFFFF) {	/* Get LFN if available */
 8015cb6:	6b03      	ldr	r3, [r0, #48]	; 0x30
 8015cb8:	3301      	adds	r3, #1
 8015cba:	4607      	mov	r7, r0
 8015cbc:	460d      	mov	r5, r1
 8015cbe:	d01d      	beq.n	8015cfc <get_fileinfo+0x58>
			while ((w = fs->lfnbuf[j++]) != 0) {	/* Get an LFN character */
 8015cc0:	f8d8 300c 	ldr.w	r3, [r8, #12]
 8015cc4:	8818      	ldrh	r0, [r3, #0]
 8015cc6:	b1a0      	cbz	r0, 8015cf2 <get_fileinfo+0x4e>
 8015cc8:	f101 0615 	add.w	r6, r1, #21
 8015ccc:	2401      	movs	r4, #1
 8015cce:	e00b      	b.n	8015ce8 <get_fileinfo+0x44>
				if (i >= _MAX_LFN) { i = 0; break; }	/* No LFN if buffer overflow */
 8015cd0:	f5b4 7f80 	cmp.w	r4, #256	; 0x100
 8015cd4:	d00d      	beq.n	8015cf2 <get_fileinfo+0x4e>
				fno->fname[i++] = (TCHAR)w;
 8015cd6:	f806 0f01 	strb.w	r0, [r6, #1]!
			while ((w = fs->lfnbuf[j++]) != 0) {	/* Get an LFN character */
 8015cda:	f8d8 300c 	ldr.w	r3, [r8, #12]
 8015cde:	f833 0014 	ldrh.w	r0, [r3, r4, lsl #1]
 8015ce2:	1c62      	adds	r2, r4, #1
 8015ce4:	b130      	cbz	r0, 8015cf4 <get_fileinfo+0x50>
 8015ce6:	4614      	mov	r4, r2
				w = ff_convert(w, 0);		/* Unicode -> OEM */
 8015ce8:	2100      	movs	r1, #0
 8015cea:	f002 fd57 	bl	801879c <ff_convert>
				if (w == 0) { i = 0; break; }	/* No LFN if it could not be converted */
 8015cee:	2800      	cmp	r0, #0
 8015cf0:	d1ee      	bne.n	8015cd0 <get_fileinfo+0x2c>
			i = j = 0;
 8015cf2:	2400      	movs	r4, #0
			fno->fname[i] = 0;	/* Terminate the LFN */
 8015cf4:	442c      	add	r4, r5
 8015cf6:	2300      	movs	r3, #0
 8015cf8:	75a3      	strb	r3, [r4, #22]
	lfv = fno->fname[i];	/* LFN is exist if non-zero */
 8015cfa:	7dae      	ldrb	r6, [r5, #22]
		c = (TCHAR)dp->dir[i++];
 8015cfc:	f8d7 c020 	ldr.w	ip, [r7, #32]
	i = j = 0;
 8015d00:	2000      	movs	r0, #0
 8015d02:	f10c 31ff 	add.w	r1, ip, #4294967295
 8015d06:	4602      	mov	r2, r0
			fno->altname[j++] = '.';
 8015d08:	f04f 082e 	mov.w	r8, #46	; 0x2e
		c = (TCHAR)dp->dir[i++];
 8015d0c:	f811 3f01 	ldrb.w	r3, [r1, #1]!
		if (c == ' ') continue;				/* Skip padding spaces */
 8015d10:	2b20      	cmp	r3, #32
		c = (TCHAR)dp->dir[i++];
 8015d12:	f102 0201 	add.w	r2, r2, #1
		if (c == ' ') continue;				/* Skip padding spaces */
 8015d16:	d018      	beq.n	8015d4a <get_fileinfo+0xa6>
		if (c == RDDEM) c = (TCHAR)DDEM;	/* Restore replaced DDEM character */
 8015d18:	2b05      	cmp	r3, #5
 8015d1a:	bf08      	it	eq
 8015d1c:	23e5      	moveq	r3, #229	; 0xe5
		if (i == 9) {						/* Insert a . if extension is exist */
 8015d1e:	2a09      	cmp	r2, #9
 8015d20:	d026      	beq.n	8015d70 <get_fileinfo+0xcc>
		fno->altname[j] = c;
 8015d22:	182c      	adds	r4, r5, r0
 8015d24:	7263      	strb	r3, [r4, #9]
		if (!lfv) {
 8015d26:	b97e      	cbnz	r6, 8015d48 <get_fileinfo+0xa4>
			if (IsUpper(c) && (dp->dir[DIR_NTres] & ((i >= 9) ? NS_EXT : NS_BODY))) {
 8015d28:	f1a3 0741 	sub.w	r7, r3, #65	; 0x41
 8015d2c:	2f19      	cmp	r7, #25
 8015d2e:	d80a      	bhi.n	8015d46 <get_fileinfo+0xa2>
 8015d30:	2a08      	cmp	r2, #8
 8015d32:	f89c e00c 	ldrb.w	lr, [ip, #12]
 8015d36:	bf8c      	ite	hi
 8015d38:	2710      	movhi	r7, #16
 8015d3a:	2708      	movls	r7, #8
 8015d3c:	ea1e 0f07 	tst.w	lr, r7
				c += 0x20;			/* To lower */
 8015d40:	bf1c      	itt	ne
 8015d42:	3320      	addne	r3, #32
 8015d44:	b2db      	uxtbne	r3, r3
			fno->fname[j] = c;
 8015d46:	75a3      	strb	r3, [r4, #22]
		j++;
 8015d48:	3001      	adds	r0, #1
	while (i < 11) {		/* Copy name body and extension */
 8015d4a:	2a0b      	cmp	r2, #11
 8015d4c:	d1de      	bne.n	8015d0c <get_fileinfo+0x68>
		fno->fname[j] = 0;
 8015d4e:	182c      	adds	r4, r5, r0
	if (!lfv) {
 8015d50:	b1b6      	cbz	r6, 8015d80 <get_fileinfo+0xdc>
	fno->altname[j] = 0;	/* Terminate the SFN */
 8015d52:	2300      	movs	r3, #0
 8015d54:	7263      	strb	r3, [r4, #9]
	fno->fattrib = dp->dir[DIR_Attr];				/* Attribute */
 8015d56:	f89c 300b 	ldrb.w	r3, [ip, #11]
 8015d5a:	722b      	strb	r3, [r5, #8]
	rv = rv << 8 | ptr[0];
 8015d5c:	f8dc 301c 	ldr.w	r3, [ip, #28]
	fno->fsize = ld_dword(dp->dir + DIR_FileSize);	/* Size */
 8015d60:	602b      	str	r3, [r5, #0]
	rv = rv << 8 | ptr[0];
 8015d62:	f8dc 3016 	ldr.w	r3, [ip, #22]
	fno->ftime = (WORD)tm; fno->fdate = (WORD)(tm >> 16);
 8015d66:	80eb      	strh	r3, [r5, #6]
 8015d68:	0c1b      	lsrs	r3, r3, #16
 8015d6a:	80ab      	strh	r3, [r5, #4]
}
 8015d6c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
			if (!lfv) fno->fname[j] = '.';
 8015d70:	182c      	adds	r4, r5, r0
 8015d72:	b90e      	cbnz	r6, 8015d78 <get_fileinfo+0xd4>
 8015d74:	f884 8016 	strb.w	r8, [r4, #22]
			fno->altname[j++] = '.';
 8015d78:	f884 8009 	strb.w	r8, [r4, #9]
 8015d7c:	3001      	adds	r0, #1
 8015d7e:	e7d0      	b.n	8015d22 <get_fileinfo+0x7e>
		fno->fname[j] = 0;
 8015d80:	75a6      	strb	r6, [r4, #22]
		if (!dp->dir[DIR_NTres]) j = 0;	/* Altname is no longer needed if neither LFN nor case info is exist. */
 8015d82:	f89c 300c 	ldrb.w	r3, [ip, #12]
 8015d86:	2b00      	cmp	r3, #0
 8015d88:	bf08      	it	eq
 8015d8a:	462c      	moveq	r4, r5
 8015d8c:	e7e1      	b.n	8015d52 <get_fileinfo+0xae>
 8015d8e:	bf00      	nop

08015d90 <sync_window.part.0>:
FRESULT sync_window (	/* Returns FR_OK or FR_DISK_ERROR */
 8015d90:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
		wsect = fs->winsect;	/* Current sector number */
 8015d94:	6b05      	ldr	r5, [r0, #48]	; 0x30
		if (disk_write(fs->drv, fs->win, wsect, 1) != RES_OK) {
 8015d96:	f100 0834 	add.w	r8, r0, #52	; 0x34
FRESULT sync_window (	/* Returns FR_OK or FR_DISK_ERROR */
 8015d9a:	4604      	mov	r4, r0
		if (disk_write(fs->drv, fs->win, wsect, 1) != RES_OK) {
 8015d9c:	2301      	movs	r3, #1
 8015d9e:	7840      	ldrb	r0, [r0, #1]
 8015da0:	462a      	mov	r2, r5
 8015da2:	4641      	mov	r1, r8
 8015da4:	f7ff fe84 	bl	8015ab0 <disk_write>
 8015da8:	b9c0      	cbnz	r0, 8015ddc <sync_window.part.0+0x4c>
			if (wsect - fs->fatbase < fs->fsize) {		/* Is it in the FAT area? */
 8015daa:	6a62      	ldr	r2, [r4, #36]	; 0x24
 8015dac:	69e3      	ldr	r3, [r4, #28]
			fs->wflag = 0;
 8015dae:	70e0      	strb	r0, [r4, #3]
			if (wsect - fs->fatbase < fs->fsize) {		/* Is it in the FAT area? */
 8015db0:	1aaa      	subs	r2, r5, r2
 8015db2:	429a      	cmp	r2, r3
 8015db4:	4607      	mov	r7, r0
 8015db6:	d20e      	bcs.n	8015dd6 <sync_window.part.0+0x46>
				for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 8015db8:	78a6      	ldrb	r6, [r4, #2]
 8015dba:	2e01      	cmp	r6, #1
 8015dbc:	d801      	bhi.n	8015dc2 <sync_window.part.0+0x32>
 8015dbe:	e00a      	b.n	8015dd6 <sync_window.part.0+0x46>
					wsect += fs->fsize;
 8015dc0:	69e3      	ldr	r3, [r4, #28]
					disk_write(fs->drv, fs->win, wsect, 1);
 8015dc2:	7860      	ldrb	r0, [r4, #1]
					wsect += fs->fsize;
 8015dc4:	441d      	add	r5, r3
					disk_write(fs->drv, fs->win, wsect, 1);
 8015dc6:	462a      	mov	r2, r5
 8015dc8:	2301      	movs	r3, #1
 8015dca:	4641      	mov	r1, r8
				for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 8015dcc:	3e01      	subs	r6, #1
					disk_write(fs->drv, fs->win, wsect, 1);
 8015dce:	f7ff fe6f 	bl	8015ab0 <disk_write>
				for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 8015dd2:	2e01      	cmp	r6, #1
 8015dd4:	d1f4      	bne.n	8015dc0 <sync_window.part.0+0x30>
}
 8015dd6:	4638      	mov	r0, r7
 8015dd8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
			res = FR_DISK_ERR;
 8015ddc:	2701      	movs	r7, #1
}
 8015dde:	4638      	mov	r0, r7
 8015de0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

08015de4 <sync_fs>:
{
 8015de4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	if (fs->wflag) {	/* Write back the sector if it is dirty */
 8015de6:	78c3      	ldrb	r3, [r0, #3]
{
 8015de8:	4604      	mov	r4, r0
	if (fs->wflag) {	/* Write back the sector if it is dirty */
 8015dea:	b95b      	cbnz	r3, 8015e04 <sync_fs+0x20>
		if (fs->fs_type == FS_FAT32 && fs->fsi_flag == 1) {
 8015dec:	7823      	ldrb	r3, [r4, #0]
 8015dee:	2b03      	cmp	r3, #3
 8015df0:	d00f      	beq.n	8015e12 <sync_fs+0x2e>
		if (disk_ioctl(fs->drv, CTRL_SYNC, 0) != RES_OK) res = FR_DISK_ERR;
 8015df2:	2200      	movs	r2, #0
 8015df4:	7860      	ldrb	r0, [r4, #1]
 8015df6:	4611      	mov	r1, r2
 8015df8:	f7ff fe68 	bl	8015acc <disk_ioctl>
 8015dfc:	3800      	subs	r0, #0
 8015dfe:	bf18      	it	ne
 8015e00:	2001      	movne	r0, #1
}
 8015e02:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8015e04:	f7ff ffc4 	bl	8015d90 <sync_window.part.0>
	if (res == FR_OK) {
 8015e08:	2800      	cmp	r0, #0
 8015e0a:	d1fa      	bne.n	8015e02 <sync_fs+0x1e>
		if (fs->fs_type == FS_FAT32 && fs->fsi_flag == 1) {
 8015e0c:	7823      	ldrb	r3, [r4, #0]
 8015e0e:	2b03      	cmp	r3, #3
 8015e10:	d1ef      	bne.n	8015df2 <sync_fs+0xe>
 8015e12:	7926      	ldrb	r6, [r4, #4]
 8015e14:	2e01      	cmp	r6, #1
 8015e16:	d1ec      	bne.n	8015df2 <sync_fs+0xe>
			mem_set(fs->win, 0, SS(fs));
 8015e18:	f104 0734 	add.w	r7, r4, #52	; 0x34
		*d++ = (BYTE)val;
 8015e1c:	f44f 5280 	mov.w	r2, #4096	; 0x1000
 8015e20:	2100      	movs	r1, #0
 8015e22:	4638      	mov	r0, r7
 8015e24:	f011 fba8 	bl	8027578 <memset>
	*ptr++ = (BYTE)val; val >>= 8;
 8015e28:	2352      	movs	r3, #82	; 0x52
			st_dword(fs->win + FSI_Free_Count, fs->free_clst);
 8015e2a:	6965      	ldr	r5, [r4, #20]
	*ptr++ = (BYTE)val; val >>= 8;
 8015e2c:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
	*ptr++ = (BYTE)val; val >>= 8;
 8015e30:	f884 3035 	strb.w	r3, [r4, #53]	; 0x35
	*ptr++ = (BYTE)val;
 8015e34:	2341      	movs	r3, #65	; 0x41
 8015e36:	f884 3037 	strb.w	r3, [r4, #55]	; 0x37
	*ptr++ = (BYTE)val; val >>= 8;
 8015e3a:	f884 321a 	strb.w	r3, [r4, #538]	; 0x21a
			disk_write(fs->drv, fs->win, fs->winsect, 1);
 8015e3e:	4633      	mov	r3, r6
	*ptr++ = (BYTE)val; val >>= 8;
 8015e40:	2672      	movs	r6, #114	; 0x72
			st_dword(fs->win + FSI_Nxt_Free, fs->last_clst);
 8015e42:	6920      	ldr	r0, [r4, #16]
	*ptr++ = (BYTE)val; val >>= 8;
 8015e44:	f884 6218 	strb.w	r6, [r4, #536]	; 0x218
	*ptr++ = (BYTE)val; val >>= 8;
 8015e48:	f884 6219 	strb.w	r6, [r4, #537]	; 0x219
	*ptr++ = (BYTE)val; val >>= 8;
 8015e4c:	0a2e      	lsrs	r6, r5, #8
	*ptr++ = (BYTE)val; val >>= 8;
 8015e4e:	2261      	movs	r2, #97	; 0x61
	*ptr++ = (BYTE)val; val >>= 8;
 8015e50:	f884 521c 	strb.w	r5, [r4, #540]	; 0x21c
	*ptr++ = (BYTE)val; val >>= 8;
 8015e54:	f884 621d 	strb.w	r6, [r4, #541]	; 0x21d
 8015e58:	0c2e      	lsrs	r6, r5, #16
	*ptr++ = (BYTE)val; val >>= 8;
 8015e5a:	0e2d      	lsrs	r5, r5, #24
 8015e5c:	f884 2036 	strb.w	r2, [r4, #54]	; 0x36
	*ptr++ = (BYTE)val;
 8015e60:	f884 221b 	strb.w	r2, [r4, #539]	; 0x21b
 8015e64:	f884 521f 	strb.w	r5, [r4, #543]	; 0x21f
			fs->winsect = fs->volbase + 1;
 8015e68:	6a22      	ldr	r2, [r4, #32]
	*ptr++ = (BYTE)val; val >>= 8;
 8015e6a:	f884 0220 	strb.w	r0, [r4, #544]	; 0x220
 8015e6e:	0a05      	lsrs	r5, r0, #8
	*ptr++ = (BYTE)val; val >>= 8;
 8015e70:	f884 5221 	strb.w	r5, [r4, #545]	; 0x221
 8015e74:	0c05      	lsrs	r5, r0, #16
	*ptr++ = (BYTE)val; val >>= 8;
 8015e76:	0e00      	lsrs	r0, r0, #24
	*ptr++ = (BYTE)val; val >>= 8;
 8015e78:	2155      	movs	r1, #85	; 0x55
			fs->winsect = fs->volbase + 1;
 8015e7a:	3201      	adds	r2, #1
	*ptr++ = (BYTE)val;
 8015e7c:	f884 0223 	strb.w	r0, [r4, #547]	; 0x223
	*ptr++ = (BYTE)val;
 8015e80:	20aa      	movs	r0, #170	; 0xaa
	*ptr++ = (BYTE)val; val >>= 8;
 8015e82:	f884 1232 	strb.w	r1, [r4, #562]	; 0x232
	*ptr++ = (BYTE)val;
 8015e86:	f884 0233 	strb.w	r0, [r4, #563]	; 0x233
			disk_write(fs->drv, fs->win, fs->winsect, 1);
 8015e8a:	4639      	mov	r1, r7
 8015e8c:	7860      	ldrb	r0, [r4, #1]
			fs->winsect = fs->volbase + 1;
 8015e8e:	6322      	str	r2, [r4, #48]	; 0x30
	*ptr++ = (BYTE)val; val >>= 8;
 8015e90:	f884 621e 	strb.w	r6, [r4, #542]	; 0x21e
 8015e94:	f884 5222 	strb.w	r5, [r4, #546]	; 0x222
			disk_write(fs->drv, fs->win, fs->winsect, 1);
 8015e98:	f7ff fe0a 	bl	8015ab0 <disk_write>
			fs->fsi_flag = 0;
 8015e9c:	2300      	movs	r3, #0
 8015e9e:	7123      	strb	r3, [r4, #4]
 8015ea0:	e7a7      	b.n	8015df2 <sync_fs+0xe>
 8015ea2:	bf00      	nop

08015ea4 <move_window.part.0>:
FRESULT move_window (	/* Returns FR_OK or FR_DISK_ERROR */
 8015ea4:	b538      	push	{r3, r4, r5, lr}
	if (fs->wflag) {	/* Write back the sector if it is dirty */
 8015ea6:	78c3      	ldrb	r3, [r0, #3]
FRESULT move_window (	/* Returns FR_OK or FR_DISK_ERROR */
 8015ea8:	4604      	mov	r4, r0
 8015eaa:	460d      	mov	r5, r1
	if (fs->wflag) {	/* Write back the sector if it is dirty */
 8015eac:	b96b      	cbnz	r3, 8015eca <move_window.part.0+0x26>
			if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK) {
 8015eae:	462a      	mov	r2, r5
 8015eb0:	7860      	ldrb	r0, [r4, #1]
 8015eb2:	2301      	movs	r3, #1
 8015eb4:	f104 0134 	add.w	r1, r4, #52	; 0x34
 8015eb8:	f7ff fdec 	bl	8015a94 <disk_read>
				res = FR_DISK_ERR;
 8015ebc:	2800      	cmp	r0, #0
 8015ebe:	bf1c      	itt	ne
 8015ec0:	f04f 35ff 	movne.w	r5, #4294967295
 8015ec4:	2001      	movne	r0, #1
			fs->winsect = sector;
 8015ec6:	6325      	str	r5, [r4, #48]	; 0x30
}
 8015ec8:	bd38      	pop	{r3, r4, r5, pc}
 8015eca:	f7ff ff61 	bl	8015d90 <sync_window.part.0>
		if (res == FR_OK) {			/* Fill sector window with new data */
 8015ece:	2800      	cmp	r0, #0
 8015ed0:	d0ed      	beq.n	8015eae <move_window.part.0+0xa>
}
 8015ed2:	bd38      	pop	{r3, r4, r5, pc}

08015ed4 <check_fs>:
{
 8015ed4:	b570      	push	{r4, r5, r6, lr}
	fs->wflag = 0; fs->winsect = 0xFFFFFFFF;		/* Invaidate window */
 8015ed6:	f04f 36ff 	mov.w	r6, #4294967295
 8015eda:	2300      	movs	r3, #0
	if (sector != fs->winsect) {	/* Window offset changed? */
 8015edc:	42b1      	cmp	r1, r6
{
 8015ede:	4604      	mov	r4, r0
	fs->wflag = 0; fs->winsect = 0xFFFFFFFF;		/* Invaidate window */
 8015ee0:	70c3      	strb	r3, [r0, #3]
 8015ee2:	6306      	str	r6, [r0, #48]	; 0x30
	if (sector != fs->winsect) {	/* Window offset changed? */
 8015ee4:	d00c      	beq.n	8015f00 <check_fs+0x2c>
			if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK) {
 8015ee6:	460d      	mov	r5, r1
 8015ee8:	460a      	mov	r2, r1
 8015eea:	7840      	ldrb	r0, [r0, #1]
 8015eec:	2301      	movs	r3, #1
 8015eee:	f104 0134 	add.w	r1, r4, #52	; 0x34
 8015ef2:	f7ff fdcf 	bl	8015a94 <disk_read>
 8015ef6:	b110      	cbz	r0, 8015efe <check_fs+0x2a>
			fs->winsect = sector;
 8015ef8:	6326      	str	r6, [r4, #48]	; 0x30
	if (move_window(fs, sect) != FR_OK) return 4;	/* Load boot record */
 8015efa:	2004      	movs	r0, #4
}
 8015efc:	bd70      	pop	{r4, r5, r6, pc}
			fs->winsect = sector;
 8015efe:	6325      	str	r5, [r4, #48]	; 0x30
	if (ld_word(fs->win + BS_55AA) != 0xAA55) return 3;	/* Check boot record signature (always placed here even if the sector size is >512) */
 8015f00:	f8b4 2232 	ldrh.w	r2, [r4, #562]	; 0x232
 8015f04:	f64a 2355 	movw	r3, #43605	; 0xaa55
 8015f08:	429a      	cmp	r2, r3
 8015f0a:	d11a      	bne.n	8015f42 <check_fs+0x6e>
	if (fs->win[BS_JmpBoot] == 0xE9 || (fs->win[BS_JmpBoot] == 0xEB && fs->win[BS_JmpBoot + 2] == 0x90)) {
 8015f0c:	f894 3034 	ldrb.w	r3, [r4, #52]	; 0x34
 8015f10:	2be9      	cmp	r3, #233	; 0xe9
 8015f12:	d007      	beq.n	8015f24 <check_fs+0x50>
 8015f14:	6b63      	ldr	r3, [r4, #52]	; 0x34
 8015f16:	4a0d      	ldr	r2, [pc, #52]	; (8015f4c <check_fs+0x78>)
 8015f18:	f003 13ff 	and.w	r3, r3, #16711935	; 0xff00ff
 8015f1c:	4293      	cmp	r3, r2
 8015f1e:	d001      	beq.n	8015f24 <check_fs+0x50>
	return 2;
 8015f20:	2002      	movs	r0, #2
}
 8015f22:	bd70      	pop	{r4, r5, r6, pc}
	rv = rv << 8 | ptr[0];
 8015f24:	f8d4 306a 	ldr.w	r3, [r4, #106]	; 0x6a
		if ((ld_dword(fs->win + BS_FilSysType) & 0xFFFFFF) == 0x544146) return 0;	/* Check "FAT" string */
 8015f28:	4a09      	ldr	r2, [pc, #36]	; (8015f50 <check_fs+0x7c>)
 8015f2a:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
 8015f2e:	4293      	cmp	r3, r2
 8015f30:	d009      	beq.n	8015f46 <check_fs+0x72>
	rv = rv << 8 | ptr[0];
 8015f32:	f8d4 0086 	ldr.w	r0, [r4, #134]	; 0x86
		if (ld_dword(fs->win + BS_FilSysType32) == 0x33544146) return 0;			/* Check "FAT3" string */
 8015f36:	4b07      	ldr	r3, [pc, #28]	; (8015f54 <check_fs+0x80>)
 8015f38:	4298      	cmp	r0, r3
 8015f3a:	bf14      	ite	ne
 8015f3c:	2002      	movne	r0, #2
 8015f3e:	2000      	moveq	r0, #0
}
 8015f40:	bd70      	pop	{r4, r5, r6, pc}
	if (ld_word(fs->win + BS_55AA) != 0xAA55) return 3;	/* Check boot record signature (always placed here even if the sector size is >512) */
 8015f42:	2003      	movs	r0, #3
}
 8015f44:	bd70      	pop	{r4, r5, r6, pc}
		if (ld_dword(fs->win + BS_FilSysType32) == 0x33544146) return 0;			/* Check "FAT3" string */
 8015f46:	2000      	movs	r0, #0
}
 8015f48:	bd70      	pop	{r4, r5, r6, pc}
 8015f4a:	bf00      	nop
 8015f4c:	009000eb 	.word	0x009000eb
 8015f50:	00544146 	.word	0x00544146
 8015f54:	33544146 	.word	0x33544146

08015f58 <find_volume>:
{
 8015f58:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	*rfs = 0;
 8015f5c:	2300      	movs	r3, #0
{
 8015f5e:	b084      	sub	sp, #16
	*rfs = 0;
 8015f60:	600b      	str	r3, [r1, #0]
{
 8015f62:	460f      	mov	r7, r1
 8015f64:	4614      	mov	r4, r2
	vol = get_ldnumber(path);
 8015f66:	f7ff fe67 	bl	8015c38 <get_ldnumber>
	if (vol < 0) return FR_INVALID_DRIVE;
 8015f6a:	1e05      	subs	r5, r0, #0
 8015f6c:	f2c0 80ce 	blt.w	801610c <find_volume+0x1b4>
	fs = FatFs[vol];					/* Get pointer to the file system object */
 8015f70:	f8df 8258 	ldr.w	r8, [pc, #600]	; 80161cc <find_volume+0x274>
 8015f74:	eb08 0385 	add.w	r3, r8, r5, lsl #2
 8015f78:	6a1e      	ldr	r6, [r3, #32]
	if (!fs) return FR_NOT_ENABLED;		/* Is the file system object available? */
 8015f7a:	2e00      	cmp	r6, #0
 8015f7c:	f000 80d4 	beq.w	8016128 <find_volume+0x1d0>
	*rfs = fs;							/* Return pointer to the file system object */
 8015f80:	603e      	str	r6, [r7, #0]
	if (fs->fs_type) {					/* If the volume has been mounted */
 8015f82:	7833      	ldrb	r3, [r6, #0]
	mode &= (BYTE)~FA_READ;				/* Desired access mode, write access or not */
 8015f84:	f004 04fe 	and.w	r4, r4, #254	; 0xfe
	if (fs->fs_type) {					/* If the volume has been mounted */
 8015f88:	b183      	cbz	r3, 8015fac <find_volume+0x54>
		stat = disk_status(fs->drv);
 8015f8a:	7870      	ldrb	r0, [r6, #1]
 8015f8c:	f7ff fd68 	bl	8015a60 <disk_status>
		if (!(stat & STA_NOINIT)) {		/* and the physical drive is kept initialized */
 8015f90:	07c7      	lsls	r7, r0, #31
 8015f92:	d40b      	bmi.n	8015fac <find_volume+0x54>
			if (!_FS_READONLY && mode && (stat & STA_PROTECT)) {	/* Check write protection if needed */
 8015f94:	2c00      	cmp	r4, #0
 8015f96:	f000 80b0 	beq.w	80160fa <find_volume+0x1a2>
 8015f9a:	f010 0404 	ands.w	r4, r0, #4
 8015f9e:	f000 80ac 	beq.w	80160fa <find_volume+0x1a2>
				return FR_WRITE_PROTECTED;
 8015fa2:	240a      	movs	r4, #10
}
 8015fa4:	4620      	mov	r0, r4
 8015fa6:	b004      	add	sp, #16
 8015fa8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	fs->drv = LD2PD(vol);				/* Bind the logical drive and a physical drive */
 8015fac:	b2e8      	uxtb	r0, r5
	fs->fs_type = 0;					/* Clear the file system object */
 8015fae:	2300      	movs	r3, #0
 8015fb0:	7033      	strb	r3, [r6, #0]
	fs->drv = LD2PD(vol);				/* Bind the logical drive and a physical drive */
 8015fb2:	7070      	strb	r0, [r6, #1]
	stat = disk_initialize(fs->drv);	/* Initialize the physical drive */
 8015fb4:	f7ff fd5e 	bl	8015a74 <disk_initialize>
	if (stat & STA_NOINIT) { 			/* Check if the initialization succeeded */
 8015fb8:	07c5      	lsls	r5, r0, #31
 8015fba:	f100 80a2 	bmi.w	8016102 <find_volume+0x1aa>
	if (!_FS_READONLY && mode && (stat & STA_PROTECT)) { /* Check disk write protection if needed */
 8015fbe:	b10c      	cbz	r4, 8015fc4 <find_volume+0x6c>
 8015fc0:	0744      	lsls	r4, r0, #29
 8015fc2:	d4ee      	bmi.n	8015fa2 <find_volume+0x4a>
	fmt = check_fs(fs, bsect);			/* Load sector 0 and check if it is an FAT-VBR as SFD */
 8015fc4:	2100      	movs	r1, #0
 8015fc6:	4630      	mov	r0, r6
 8015fc8:	f7ff ff84 	bl	8015ed4 <check_fs>
	if (fmt == 2 || (fmt < 2 && LD2PT(vol) != 0)) {	/* Not an FAT-VBR or forced partition number */
 8015fcc:	2802      	cmp	r0, #2
 8015fce:	d07b      	beq.n	80160c8 <find_volume+0x170>
	if (fmt == 4) return FR_DISK_ERR;		/* An error occured in the disk I/O layer */
 8015fd0:	2804      	cmp	r0, #4
 8015fd2:	f000 80a0 	beq.w	8016116 <find_volume+0x1be>
	if (fmt >= 2) return FR_NO_FILESYSTEM;	/* No FAT volume is found */
 8015fd6:	2801      	cmp	r0, #1
	bsect = 0;
 8015fd8:	bf98      	it	ls
 8015fda:	2500      	movls	r5, #0
	if (fmt >= 2) return FR_NO_FILESYSTEM;	/* No FAT volume is found */
 8015fdc:	f200 808c 	bhi.w	80160f8 <find_volume+0x1a0>
		if (ld_word(fs->win + BPB_BytsPerSec) != SS(fs)) return FR_NO_FILESYSTEM;	/* (BPB_BytsPerSec must be equal to the physical sector size) */
 8015fe0:	f8b6 303f 	ldrh.w	r3, [r6, #63]	; 0x3f
 8015fe4:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
 8015fe8:	f040 8086 	bne.w	80160f8 <find_volume+0x1a0>
		fasize = ld_word(fs->win + BPB_FATSz16);		/* Number of sectors per FAT */
 8015fec:	f8b6 204a 	ldrh.w	r2, [r6, #74]	; 0x4a
		if (fasize == 0) fasize = ld_dword(fs->win + BPB_FATSz32);
 8015ff0:	b902      	cbnz	r2, 8015ff4 <find_volume+0x9c>
	rv = rv << 8 | ptr[0];
 8015ff2:	6db2      	ldr	r2, [r6, #88]	; 0x58
		fs->n_fats = fs->win[BPB_NumFATs];				/* Number of FATs */
 8015ff4:	f896 3044 	ldrb.w	r3, [r6, #68]	; 0x44
		fs->fsize = fasize;
 8015ff8:	61f2      	str	r2, [r6, #28]
		if (fs->n_fats != 1 && fs->n_fats != 2) return FR_NO_FILESYSTEM;	/* (Must be 1 or 2) */
 8015ffa:	1e59      	subs	r1, r3, #1
 8015ffc:	2901      	cmp	r1, #1
		fs->n_fats = fs->win[BPB_NumFATs];				/* Number of FATs */
 8015ffe:	70b3      	strb	r3, [r6, #2]
		if (fs->n_fats != 1 && fs->n_fats != 2) return FR_NO_FILESYSTEM;	/* (Must be 1 or 2) */
 8016000:	d87a      	bhi.n	80160f8 <find_volume+0x1a0>
		fs->csize = fs->win[BPB_SecPerClus];			/* Cluster size */
 8016002:	f896 1041 	ldrb.w	r1, [r6, #65]	; 0x41
 8016006:	b288      	uxth	r0, r1
 8016008:	8170      	strh	r0, [r6, #10]
		if (fs->csize == 0 || (fs->csize & (fs->csize - 1))) return FR_NO_FILESYSTEM;	/* (Must be power of 2) */
 801600a:	2800      	cmp	r0, #0
 801600c:	d074      	beq.n	80160f8 <find_volume+0x1a0>
 801600e:	1e48      	subs	r0, r1, #1
 8016010:	4208      	tst	r0, r1
 8016012:	d171      	bne.n	80160f8 <find_volume+0x1a0>
	rv = ptr[1];
 8016014:	f8b6 7045 	ldrh.w	r7, [r6, #69]	; 0x45
		fs->n_rootdir = ld_word(fs->win + BPB_RootEntCnt);	/* Number of root directory entries */
 8016018:	8137      	strh	r7, [r6, #8]
		if (fs->n_rootdir % (SS(fs) / SZDIRE)) return FR_NO_FILESYSTEM;	/* (Must be sector aligned) */
 801601a:	0678      	lsls	r0, r7, #25
 801601c:	d16c      	bne.n	80160f8 <find_volume+0x1a0>
		tsect = ld_word(fs->win + BPB_TotSec16);		/* Number of sectors on the volume */
 801601e:	f8b6 0047 	ldrh.w	r0, [r6, #71]	; 0x47
		if (tsect == 0) tsect = ld_dword(fs->win + BPB_TotSec32);
 8016022:	b900      	cbnz	r0, 8016026 <find_volume+0xce>
	rv = rv << 8 | ptr[0];
 8016024:	6d70      	ldr	r0, [r6, #84]	; 0x54
	rv = ptr[1];
 8016026:	f8b6 e042 	ldrh.w	lr, [r6, #66]	; 0x42
		if (nrsv == 0) return FR_NO_FILESYSTEM;			/* (Must not be 0) */
 801602a:	f1be 0f00 	cmp.w	lr, #0
 801602e:	d063      	beq.n	80160f8 <find_volume+0x1a0>
		fasize *= fs->n_fats;							/* Number of sectors for FAT area */
 8016030:	fb02 f303 	mul.w	r3, r2, r3
		sysect = nrsv + fasize + fs->n_rootdir / (SS(fs) / SZDIRE);	/* RSV + FAT + DIR */
 8016034:	eb0e 14d7 	add.w	r4, lr, r7, lsr #7
 8016038:	441c      	add	r4, r3
		if (tsect < sysect) return FR_NO_FILESYSTEM;	/* (Invalid volume size) */
 801603a:	42a0      	cmp	r0, r4
 801603c:	d35c      	bcc.n	80160f8 <find_volume+0x1a0>
		nclst = (tsect - sysect) / fs->csize;			/* Number of clusters */
 801603e:	1b00      	subs	r0, r0, r4
		if (nclst == 0) return FR_NO_FILESYSTEM;		/* (Invalid volume size) */
 8016040:	4288      	cmp	r0, r1
		nclst = (tsect - sysect) / fs->csize;			/* Number of clusters */
 8016042:	fbb0 fcf1 	udiv	ip, r0, r1
		if (nclst == 0) return FR_NO_FILESYSTEM;		/* (Invalid volume size) */
 8016046:	d357      	bcc.n	80160f8 <find_volume+0x1a0>
		if (nclst <= MAX_FAT16) fmt = FS_FAT16;
 8016048:	f64f 71f5 	movw	r1, #65525	; 0xfff5
 801604c:	458c      	cmp	ip, r1
 801604e:	d86d      	bhi.n	801612c <find_volume+0x1d4>
		if (nclst <= MAX_FAT12) fmt = FS_FAT12;
 8016050:	f640 71f5 	movw	r1, #4085	; 0xff5
 8016054:	458c      	cmp	ip, r1
		fs->fatbase = bsect + nrsv; 					/* FAT start sector */
 8016056:	eb0e 0005 	add.w	r0, lr, r5
		fs->n_fatent = nclst + 2;						/* Number of FAT entries */
 801605a:	f10c 0102 	add.w	r1, ip, #2
		fs->database = bsect + sysect;					/* Data start sector */
 801605e:	442c      	add	r4, r5
		fs->volbase = bsect;							/* Volume start sector */
 8016060:	6235      	str	r5, [r6, #32]
		fs->database = bsect + sysect;					/* Data start sector */
 8016062:	62f4      	str	r4, [r6, #44]	; 0x2c
		fs->n_fatent = nclst + 2;						/* Number of FAT entries */
 8016064:	61b1      	str	r1, [r6, #24]
		fs->fatbase = bsect + nrsv; 					/* FAT start sector */
 8016066:	6270      	str	r0, [r6, #36]	; 0x24
		if (nclst <= MAX_FAT12) fmt = FS_FAT12;
 8016068:	f200 8081 	bhi.w	801616e <find_volume+0x216>
			if (fs->n_rootdir == 0)	return FR_NO_FILESYSTEM;/* (BPB_RootEntCnt must not be 0) */
 801606c:	2f00      	cmp	r7, #0
 801606e:	d043      	beq.n	80160f8 <find_volume+0x1a0>
			fs->dirbase = fs->fatbase + fasize;			/* Root directory start sector */
 8016070:	4403      	add	r3, r0
 8016072:	62b3      	str	r3, [r6, #40]	; 0x28
				fs->n_fatent * 2 : fs->n_fatent * 3 / 2 + (fs->n_fatent & 1);
 8016074:	eb01 0041 	add.w	r0, r1, r1, lsl #1
 8016078:	f001 0301 	and.w	r3, r1, #1
 801607c:	eb03 0350 	add.w	r3, r3, r0, lsr #1
 8016080:	2101      	movs	r1, #1
		if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs)) return FR_NO_FILESYSTEM;	/* (BPB_FATSz must not be less than the size needed) */
 8016082:	f603 73ff 	addw	r3, r3, #4095	; 0xfff
 8016086:	ebb2 3f13 	cmp.w	r2, r3, lsr #12
 801608a:	d335      	bcc.n	80160f8 <find_volume+0x1a0>
		fs->last_clst = fs->free_clst = 0xFFFFFFFF;		/* Initialize cluster allocation information */
 801608c:	f04f 33ff 	mov.w	r3, #4294967295
 8016090:	e9c6 3304 	strd	r3, r3, [r6, #16]
		fs->fsi_flag = 0x80;
 8016094:	2280      	movs	r2, #128	; 0x80
 8016096:	7132      	strb	r2, [r6, #4]
	fs->id = ++Fsid;		/* File system mount ID */
 8016098:	f8b8 3024 	ldrh.w	r3, [r8, #36]	; 0x24
		if (Files[i].fs == fs) Files[i].fs = 0;
 801609c:	f8d8 2000 	ldr.w	r2, [r8]
	fs->fs_type = fmt;		/* FAT sub-type */
 80160a0:	7031      	strb	r1, [r6, #0]
	fs->id = ++Fsid;		/* File system mount ID */
 80160a2:	3301      	adds	r3, #1
 80160a4:	b29b      	uxth	r3, r3
		if (Files[i].fs == fs) Files[i].fs = 0;
 80160a6:	4296      	cmp	r6, r2
	fs->id = ++Fsid;		/* File system mount ID */
 80160a8:	f8a8 3024 	strh.w	r3, [r8, #36]	; 0x24
 80160ac:	80f3      	strh	r3, [r6, #6]
		if (Files[i].fs == fs) Files[i].fs = 0;
 80160ae:	bf04      	itt	eq
 80160b0:	2300      	moveq	r3, #0
 80160b2:	f8c8 3000 	streq.w	r3, [r8]
 80160b6:	f8d8 3010 	ldr.w	r3, [r8, #16]
 80160ba:	429e      	cmp	r6, r3
 80160bc:	f04f 0400 	mov.w	r4, #0
 80160c0:	d11b      	bne.n	80160fa <find_volume+0x1a2>
 80160c2:	f8c8 4010 	str.w	r4, [r8, #16]
 80160c6:	e018      	b.n	80160fa <find_volume+0x1a2>
 80160c8:	466c      	mov	r4, sp
 80160ca:	f506 73f9 	add.w	r3, r6, #498	; 0x1f2
 80160ce:	f206 2032 	addw	r0, r6, #562	; 0x232
	if (fmt == 2 || (fmt < 2 && LD2PT(vol) != 0)) {	/* Not an FAT-VBR or forced partition number */
 80160d2:	4621      	mov	r1, r4
			br[i] = pt[PTE_System] ? ld_dword(pt + PTE_StLba) : 0;
 80160d4:	791a      	ldrb	r2, [r3, #4]
 80160d6:	b102      	cbz	r2, 80160da <find_volume+0x182>
	rv = rv << 8 | ptr[0];
 80160d8:	689a      	ldr	r2, [r3, #8]
			br[i] = pt[PTE_System] ? ld_dword(pt + PTE_StLba) : 0;
 80160da:	f841 2b04 	str.w	r2, [r1], #4
		for (i = 0; i < 4; i++) {		/* Get partition offset */
 80160de:	3310      	adds	r3, #16
 80160e0:	4298      	cmp	r0, r3
 80160e2:	d1f7      	bne.n	80160d4 <find_volume+0x17c>
 80160e4:	f104 0710 	add.w	r7, r4, #16
			bsect = br[i];
 80160e8:	f854 5b04 	ldr.w	r5, [r4], #4
			fmt = bsect ? check_fs(fs, bsect) : 3;	/* Check the partition */
 80160ec:	2003      	movs	r0, #3
 80160ee:	b9a5      	cbnz	r5, 801611a <find_volume+0x1c2>
		} while (LD2PT(vol) == 0 && fmt >= 2 && ++i < 4);
 80160f0:	42bc      	cmp	r4, r7
 80160f2:	d1f9      	bne.n	80160e8 <find_volume+0x190>
	if (fmt == 4) return FR_DISK_ERR;		/* An error occured in the disk I/O layer */
 80160f4:	2804      	cmp	r0, #4
 80160f6:	d00e      	beq.n	8016116 <find_volume+0x1be>
	if (fmt >= 2) return FR_NO_FILESYSTEM;	/* No FAT volume is found */
 80160f8:	240d      	movs	r4, #13
}
 80160fa:	4620      	mov	r0, r4
 80160fc:	b004      	add	sp, #16
 80160fe:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		return FR_NOT_READY;			/* Failed to initialize due to no medium or hard error */
 8016102:	2403      	movs	r4, #3
}
 8016104:	4620      	mov	r0, r4
 8016106:	b004      	add	sp, #16
 8016108:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	if (vol < 0) return FR_INVALID_DRIVE;
 801610c:	240b      	movs	r4, #11
}
 801610e:	4620      	mov	r0, r4
 8016110:	b004      	add	sp, #16
 8016112:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	if (fmt == 4) return FR_DISK_ERR;		/* An error occured in the disk I/O layer */
 8016116:	2401      	movs	r4, #1
 8016118:	e7ef      	b.n	80160fa <find_volume+0x1a2>
			fmt = bsect ? check_fs(fs, bsect) : 3;	/* Check the partition */
 801611a:	4629      	mov	r1, r5
 801611c:	4630      	mov	r0, r6
 801611e:	f7ff fed9 	bl	8015ed4 <check_fs>
		} while (LD2PT(vol) == 0 && fmt >= 2 && ++i < 4);
 8016122:	2801      	cmp	r0, #1
 8016124:	d8e4      	bhi.n	80160f0 <find_volume+0x198>
 8016126:	e75b      	b.n	8015fe0 <find_volume+0x88>
	if (!fs) return FR_NOT_ENABLED;		/* Is the file system object available? */
 8016128:	240c      	movs	r4, #12
 801612a:	e7e6      	b.n	80160fa <find_volume+0x1a2>
		fs->fatbase = bsect + nrsv; 					/* FAT start sector */
 801612c:	eb0e 0105 	add.w	r1, lr, r5
 8016130:	6271      	str	r1, [r6, #36]	; 0x24
	rv = rv << 8 | ptr[0];
 8016132:	f8b6 105e 	ldrh.w	r1, [r6, #94]	; 0x5e
		fs->volbase = bsect;							/* Volume start sector */
 8016136:	6235      	str	r5, [r6, #32]
		fs->n_fatent = nclst + 2;						/* Number of FAT entries */
 8016138:	f10c 0302 	add.w	r3, ip, #2
		fs->database = bsect + sysect;					/* Data start sector */
 801613c:	442c      	add	r4, r5
			if (ld_word(fs->win + BPB_FSVer32) != 0) return FR_NO_FILESYSTEM;	/* (Must be FAT32 revision 0.0) */
 801613e:	4339      	orrs	r1, r7
		fs->database = bsect + sysect;					/* Data start sector */
 8016140:	62f4      	str	r4, [r6, #44]	; 0x2c
		fs->n_fatent = nclst + 2;						/* Number of FAT entries */
 8016142:	61b3      	str	r3, [r6, #24]
			if (ld_word(fs->win + BPB_FSVer32) != 0) return FR_NO_FILESYSTEM;	/* (Must be FAT32 revision 0.0) */
 8016144:	d1d8      	bne.n	80160f8 <find_volume+0x1a0>
			szbfat = fs->n_fatent * 4;					/* (Needed FAT size) */
 8016146:	009b      	lsls	r3, r3, #2
		if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs)) return FR_NO_FILESYSTEM;	/* (BPB_FATSz must not be less than the size needed) */
 8016148:	f603 73ff 	addw	r3, r3, #4095	; 0xfff
	rv = rv << 8 | ptr[0];
 801614c:	6e31      	ldr	r1, [r6, #96]	; 0x60
			fs->dirbase = ld_dword(fs->win + BPB_RootClus32);	/* Root directory start cluster */
 801614e:	62b1      	str	r1, [r6, #40]	; 0x28
		if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs)) return FR_NO_FILESYSTEM;	/* (BPB_FATSz must not be less than the size needed) */
 8016150:	ebb2 3f13 	cmp.w	r2, r3, lsr #12
 8016154:	d3d0      	bcc.n	80160f8 <find_volume+0x1a0>
		fs->last_clst = fs->free_clst = 0xFFFFFFFF;		/* Initialize cluster allocation information */
 8016156:	f04f 33ff 	mov.w	r3, #4294967295
 801615a:	e9c6 3304 	strd	r3, r3, [r6, #16]
			&& ld_word(fs->win + BPB_FSInfo32) == 1
 801615e:	f8b6 3064 	ldrh.w	r3, [r6, #100]	; 0x64
		fs->fsi_flag = 0x80;
 8016162:	2280      	movs	r2, #128	; 0x80
			&& ld_word(fs->win + BPB_FSInfo32) == 1
 8016164:	2b01      	cmp	r3, #1
		fs->fsi_flag = 0x80;
 8016166:	7132      	strb	r2, [r6, #4]
			&& ld_word(fs->win + BPB_FSInfo32) == 1
 8016168:	d008      	beq.n	801617c <find_volume+0x224>
				fs->last_clst = ld_dword(fs->win + FSI_Nxt_Free);
 801616a:	2103      	movs	r1, #3
 801616c:	e794      	b.n	8016098 <find_volume+0x140>
			if (fs->n_rootdir == 0)	return FR_NO_FILESYSTEM;/* (BPB_RootEntCnt must not be 0) */
 801616e:	2f00      	cmp	r7, #0
 8016170:	d0c2      	beq.n	80160f8 <find_volume+0x1a0>
			fs->dirbase = fs->fatbase + fasize;			/* Root directory start sector */
 8016172:	4403      	add	r3, r0
 8016174:	62b3      	str	r3, [r6, #40]	; 0x28
				fs->n_fatent * 2 : fs->n_fatent * 3 / 2 + (fs->n_fatent & 1);
 8016176:	004b      	lsls	r3, r1, #1
 8016178:	2102      	movs	r1, #2
 801617a:	e782      	b.n	8016082 <find_volume+0x12a>
	if (sector != fs->winsect) {	/* Window offset changed? */
 801617c:	6b33      	ldr	r3, [r6, #48]	; 0x30
			&& move_window(fs, bsect + 1) == FR_OK)
 801617e:	1c69      	adds	r1, r5, #1
	if (sector != fs->winsect) {	/* Window offset changed? */
 8016180:	4299      	cmp	r1, r3
 8016182:	d004      	beq.n	801618e <find_volume+0x236>
 8016184:	4630      	mov	r0, r6
 8016186:	f7ff fe8d 	bl	8015ea4 <move_window.part.0>
			&& move_window(fs, bsect + 1) == FR_OK)
 801618a:	2800      	cmp	r0, #0
 801618c:	d1ed      	bne.n	801616a <find_volume+0x212>
			if (ld_word(fs->win + BS_55AA) == 0xAA55	/* Load FSINFO data if available */
 801618e:	f8b6 2232 	ldrh.w	r2, [r6, #562]	; 0x232
 8016192:	f64a 2355 	movw	r3, #43605	; 0xaa55
			fs->fsi_flag = 0;
 8016196:	2100      	movs	r1, #0
			if (ld_word(fs->win + BS_55AA) == 0xAA55	/* Load FSINFO data if available */
 8016198:	429a      	cmp	r2, r3
			fs->fsi_flag = 0;
 801619a:	7131      	strb	r1, [r6, #4]
			if (ld_word(fs->win + BS_55AA) == 0xAA55	/* Load FSINFO data if available */
 801619c:	d1e5      	bne.n	801616a <find_volume+0x212>
	rv = rv << 8 | ptr[0];
 801619e:	6b72      	ldr	r2, [r6, #52]	; 0x34
				&& ld_dword(fs->win + FSI_LeadSig) == 0x41615252
 80161a0:	4b09      	ldr	r3, [pc, #36]	; (80161c8 <find_volume+0x270>)
 80161a2:	429a      	cmp	r2, r3
 80161a4:	d1e1      	bne.n	801616a <find_volume+0x212>
				&& ld_dword(fs->win + FSI_StrucSig) == 0x61417272)
 80161a6:	f103 53ff 	add.w	r3, r3, #534773760	; 0x1fe00000
	rv = rv << 8 | ptr[0];
 80161aa:	f8d6 2218 	ldr.w	r2, [r6, #536]	; 0x218
				&& ld_dword(fs->win + FSI_StrucSig) == 0x61417272)
 80161ae:	f503 5300 	add.w	r3, r3, #8192	; 0x2000
 80161b2:	3320      	adds	r3, #32
 80161b4:	429a      	cmp	r2, r3
 80161b6:	d1d8      	bne.n	801616a <find_volume+0x212>
	rv = rv << 8 | ptr[0];
 80161b8:	f8d6 221c 	ldr.w	r2, [r6, #540]	; 0x21c
 80161bc:	f8d6 3220 	ldr.w	r3, [r6, #544]	; 0x220
				fs->last_clst = ld_dword(fs->win + FSI_Nxt_Free);
 80161c0:	e9c6 3204 	strd	r3, r2, [r6, #16]
 80161c4:	e7d1      	b.n	801616a <find_volume+0x212>
 80161c6:	bf00      	nop
 80161c8:	41615252 	.word	0x41615252
 80161cc:	20003310 	.word	0x20003310

080161d0 <put_fat.part.0>:
FRESULT put_fat (	/* FR_OK(0):succeeded, !=0:error */
 80161d0:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
		switch (fs->fs_type) {
 80161d4:	7803      	ldrb	r3, [r0, #0]
 80161d6:	2b02      	cmp	r3, #2
FRESULT put_fat (	/* FR_OK(0):succeeded, !=0:error */
 80161d8:	4604      	mov	r4, r0
 80161da:	460d      	mov	r5, r1
 80161dc:	4616      	mov	r6, r2
		switch (fs->fs_type) {
 80161de:	d006      	beq.n	80161ee <put_fat.part.0+0x1e>
 80161e0:	2b03      	cmp	r3, #3
 80161e2:	d06b      	beq.n	80162bc <put_fat.part.0+0xec>
 80161e4:	2b01      	cmp	r3, #1
 80161e6:	d028      	beq.n	801623a <put_fat.part.0+0x6a>
 80161e8:	2002      	movs	r0, #2
}
 80161ea:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
			res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 2)));
 80161ee:	6a47      	ldr	r7, [r0, #36]	; 0x24
	if (sector != fs->winsect) {	/* Window offset changed? */
 80161f0:	6b03      	ldr	r3, [r0, #48]	; 0x30
			res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 2)));
 80161f2:	eb07 27d1 	add.w	r7, r7, r1, lsr #11
	if (sector != fs->winsect) {	/* Window offset changed? */
 80161f6:	429f      	cmp	r7, r3
 80161f8:	f000 8094 	beq.w	8016324 <put_fat.part.0+0x154>
	if (fs->wflag) {	/* Write back the sector if it is dirty */
 80161fc:	78c3      	ldrb	r3, [r0, #3]
 80161fe:	2b00      	cmp	r3, #0
 8016200:	f040 80ba 	bne.w	8016378 <put_fat.part.0+0x1a8>
			if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK) {
 8016204:	f104 0834 	add.w	r8, r4, #52	; 0x34
 8016208:	7860      	ldrb	r0, [r4, #1]
 801620a:	2301      	movs	r3, #1
 801620c:	463a      	mov	r2, r7
 801620e:	4641      	mov	r1, r8
 8016210:	f7ff fc40 	bl	8015a94 <disk_read>
 8016214:	2800      	cmp	r0, #0
 8016216:	d14b      	bne.n	80162b0 <put_fat.part.0+0xe0>
			fs->winsect = sector;
 8016218:	6327      	str	r7, [r4, #48]	; 0x30
			st_word(fs->win + clst * 2 % SS(fs), (WORD)val);
 801621a:	f640 73fe 	movw	r3, #4094	; 0xffe
 801621e:	ea03 0545 	and.w	r5, r3, r5, lsl #1
 8016222:	eb08 0105 	add.w	r1, r8, r5
	*ptr++ = (BYTE)val; val >>= 8;
 8016226:	f808 6005 	strb.w	r6, [r8, r5]
 801622a:	f3c6 2207 	ubfx	r2, r6, #8, #8
			fs->wflag = 1;
 801622e:	2301      	movs	r3, #1
	*ptr++ = (BYTE)val;
 8016230:	704a      	strb	r2, [r1, #1]
			fs->wflag = 1;
 8016232:	70e3      	strb	r3, [r4, #3]
			break;
 8016234:	2000      	movs	r0, #0
}
 8016236:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
 801623a:	6a42      	ldr	r2, [r0, #36]	; 0x24
	if (sector != fs->winsect) {	/* Window offset changed? */
 801623c:	6b03      	ldr	r3, [r0, #48]	; 0x30
			bc = (UINT)clst; bc += bc / 2;
 801623e:	eb01 0751 	add.w	r7, r1, r1, lsr #1
			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
 8016242:	eb02 3817 	add.w	r8, r2, r7, lsr #12
	if (sector != fs->winsect) {	/* Window offset changed? */
 8016246:	4598      	cmp	r8, r3
 8016248:	d066      	beq.n	8016318 <put_fat.part.0+0x148>
	if (fs->wflag) {	/* Write back the sector if it is dirty */
 801624a:	78c3      	ldrb	r3, [r0, #3]
 801624c:	2b00      	cmp	r3, #0
 801624e:	f040 808d 	bne.w	801636c <put_fat.part.0+0x19c>
			if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK) {
 8016252:	f104 0934 	add.w	r9, r4, #52	; 0x34
 8016256:	7860      	ldrb	r0, [r4, #1]
 8016258:	2301      	movs	r3, #1
 801625a:	4642      	mov	r2, r8
 801625c:	4649      	mov	r1, r9
 801625e:	f7ff fc19 	bl	8015a94 <disk_read>
 8016262:	bb28      	cbnz	r0, 80162b0 <put_fat.part.0+0xe0>
			fs->winsect = sector;
 8016264:	f8c4 8030 	str.w	r8, [r4, #48]	; 0x30
			*p = (clst & 1) ? ((*p & 0x0F) | ((BYTE)val << 4)) : (BYTE)val;
 8016268:	f015 0501 	ands.w	r5, r5, #1
			p = fs->win + bc++ % SS(fs);
 801626c:	f107 0801 	add.w	r8, r7, #1
 8016270:	f3c7 070b 	ubfx	r7, r7, #0, #12
			*p = (clst & 1) ? ((*p & 0x0F) | ((BYTE)val << 4)) : (BYTE)val;
 8016274:	d061      	beq.n	801633a <put_fat.part.0+0x16a>
 8016276:	f819 3007 	ldrb.w	r3, [r9, r7]
 801627a:	f003 030f 	and.w	r3, r3, #15
 801627e:	ea43 1306 	orr.w	r3, r3, r6, lsl #4
 8016282:	f809 3007 	strb.w	r3, [r9, r7]
			fs->wflag = 1;
 8016286:	2301      	movs	r3, #1
			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
 8016288:	6a67      	ldr	r7, [r4, #36]	; 0x24
			fs->wflag = 1;
 801628a:	70e3      	strb	r3, [r4, #3]
	if (sector != fs->winsect) {	/* Window offset changed? */
 801628c:	6b23      	ldr	r3, [r4, #48]	; 0x30
			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
 801628e:	eb07 3718 	add.w	r7, r7, r8, lsr #12
	if (sector != fs->winsect) {	/* Window offset changed? */
 8016292:	429f      	cmp	r7, r3
 8016294:	d07b      	beq.n	801638e <put_fat.part.0+0x1be>
	if (fs->wflag) {	/* Write back the sector if it is dirty */
 8016296:	4620      	mov	r0, r4
 8016298:	f7ff fd7a 	bl	8015d90 <sync_window.part.0>
		if (res == FR_OK) {			/* Fill sector window with new data */
 801629c:	2800      	cmp	r0, #0
 801629e:	d1a4      	bne.n	80161ea <put_fat.part.0+0x1a>
			if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK) {
 80162a0:	7860      	ldrb	r0, [r4, #1]
 80162a2:	2301      	movs	r3, #1
 80162a4:	463a      	mov	r2, r7
 80162a6:	4649      	mov	r1, r9
 80162a8:	f7ff fbf4 	bl	8015a94 <disk_read>
 80162ac:	2800      	cmp	r0, #0
 80162ae:	d03c      	beq.n	801632a <put_fat.part.0+0x15a>
			fs->winsect = sector;
 80162b0:	f04f 33ff 	mov.w	r3, #4294967295
 80162b4:	6323      	str	r3, [r4, #48]	; 0x30
				res = FR_DISK_ERR;
 80162b6:	2001      	movs	r0, #1
}
 80162b8:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
			res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 4)));
 80162bc:	6a47      	ldr	r7, [r0, #36]	; 0x24
	if (sector != fs->winsect) {	/* Window offset changed? */
 80162be:	6b03      	ldr	r3, [r0, #48]	; 0x30
			res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 4)));
 80162c0:	eb07 2791 	add.w	r7, r7, r1, lsr #10
	if (sector != fs->winsect) {	/* Window offset changed? */
 80162c4:	429f      	cmp	r7, r3
 80162c6:	d02a      	beq.n	801631e <put_fat.part.0+0x14e>
	if (fs->wflag) {	/* Write back the sector if it is dirty */
 80162c8:	78c3      	ldrb	r3, [r0, #3]
 80162ca:	2b00      	cmp	r3, #0
 80162cc:	d15a      	bne.n	8016384 <put_fat.part.0+0x1b4>
			if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK) {
 80162ce:	f104 0834 	add.w	r8, r4, #52	; 0x34
 80162d2:	7860      	ldrb	r0, [r4, #1]
 80162d4:	2301      	movs	r3, #1
 80162d6:	463a      	mov	r2, r7
 80162d8:	4641      	mov	r1, r8
 80162da:	f7ff fbdb 	bl	8015a94 <disk_read>
 80162de:	2800      	cmp	r0, #0
 80162e0:	d1e6      	bne.n	80162b0 <put_fat.part.0+0xe0>
			fs->winsect = sector;
 80162e2:	6327      	str	r7, [r4, #48]	; 0x30
				val = (val & 0x0FFFFFFF) | (ld_dword(fs->win + clst * 4 % SS(fs)) & 0xF0000000);
 80162e4:	f640 71fc 	movw	r1, #4092	; 0xffc
 80162e8:	ea01 0585 	and.w	r5, r1, r5, lsl #2
 80162ec:	f026 4270 	bic.w	r2, r6, #4026531840	; 0xf0000000
	rv = rv << 8 | ptr[0];
 80162f0:	f858 3005 	ldr.w	r3, [r8, r5]
				val = (val & 0x0FFFFFFF) | (ld_dword(fs->win + clst * 4 % SS(fs)) & 0xF0000000);
 80162f4:	f003 4370 	and.w	r3, r3, #4026531840	; 0xf0000000
 80162f8:	eb08 0105 	add.w	r1, r8, r5
 80162fc:	431a      	orrs	r2, r3
	*ptr++ = (BYTE)val; val >>= 8;
 80162fe:	0c13      	lsrs	r3, r2, #16
	*ptr++ = (BYTE)val; val >>= 8;
 8016300:	f808 2005 	strb.w	r2, [r8, r5]
 8016304:	0a10      	lsrs	r0, r2, #8
	*ptr++ = (BYTE)val; val >>= 8;
 8016306:	708b      	strb	r3, [r1, #2]
 8016308:	0e12      	lsrs	r2, r2, #24
			fs->wflag = 1;
 801630a:	2301      	movs	r3, #1
	*ptr++ = (BYTE)val; val >>= 8;
 801630c:	7048      	strb	r0, [r1, #1]
	*ptr++ = (BYTE)val;
 801630e:	70ca      	strb	r2, [r1, #3]
			fs->wflag = 1;
 8016310:	70e3      	strb	r3, [r4, #3]
			break;
 8016312:	2000      	movs	r0, #0
}
 8016314:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
			if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK) {
 8016318:	f100 0934 	add.w	r9, r0, #52	; 0x34
 801631c:	e7a4      	b.n	8016268 <put_fat.part.0+0x98>
 801631e:	f100 0834 	add.w	r8, r0, #52	; 0x34
 8016322:	e7df      	b.n	80162e4 <put_fat.part.0+0x114>
 8016324:	f100 0834 	add.w	r8, r0, #52	; 0x34
 8016328:	e777      	b.n	801621a <put_fat.part.0+0x4a>
			p = fs->win + bc % SS(fs);
 801632a:	f3c8 010b 	ubfx	r1, r8, #0, #12
			fs->winsect = sector;
 801632e:	6327      	str	r7, [r4, #48]	; 0x30
			p = fs->win + bc % SS(fs);
 8016330:	4449      	add	r1, r9
			*p = (clst & 1) ? (BYTE)(val >> 4) : ((*p & 0xF0) | ((BYTE)(val >> 8) & 0x0F));
 8016332:	b17d      	cbz	r5, 8016354 <put_fat.part.0+0x184>
 8016334:	f3c6 1207 	ubfx	r2, r6, #4, #8
 8016338:	e012      	b.n	8016360 <put_fat.part.0+0x190>
			*p = (clst & 1) ? ((*p & 0x0F) | ((BYTE)val << 4)) : (BYTE)val;
 801633a:	f809 6007 	strb.w	r6, [r9, r7]
			fs->wflag = 1;
 801633e:	2301      	movs	r3, #1
			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
 8016340:	6a67      	ldr	r7, [r4, #36]	; 0x24
			fs->wflag = 1;
 8016342:	70e3      	strb	r3, [r4, #3]
	if (sector != fs->winsect) {	/* Window offset changed? */
 8016344:	6b23      	ldr	r3, [r4, #48]	; 0x30
			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
 8016346:	eb07 3718 	add.w	r7, r7, r8, lsr #12
	if (sector != fs->winsect) {	/* Window offset changed? */
 801634a:	429f      	cmp	r7, r3
 801634c:	d1a3      	bne.n	8016296 <put_fat.part.0+0xc6>
			p = fs->win + bc % SS(fs);
 801634e:	f3c8 010b 	ubfx	r1, r8, #0, #12
 8016352:	4449      	add	r1, r9
			*p = (clst & 1) ? (BYTE)(val >> 4) : ((*p & 0xF0) | ((BYTE)(val >> 8) & 0x0F));
 8016354:	780b      	ldrb	r3, [r1, #0]
 8016356:	f3c6 2203 	ubfx	r2, r6, #8, #4
 801635a:	f023 060f 	bic.w	r6, r3, #15
 801635e:	4332      	orrs	r2, r6
			fs->wflag = 1;
 8016360:	2301      	movs	r3, #1
			*p = (clst & 1) ? (BYTE)(val >> 4) : ((*p & 0xF0) | ((BYTE)(val >> 8) & 0x0F));
 8016362:	700a      	strb	r2, [r1, #0]
			fs->wflag = 1;
 8016364:	70e3      	strb	r3, [r4, #3]
			break;
 8016366:	2000      	movs	r0, #0
}
 8016368:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 801636c:	f7ff fd10 	bl	8015d90 <sync_window.part.0>
		if (res == FR_OK) {			/* Fill sector window with new data */
 8016370:	2800      	cmp	r0, #0
 8016372:	f43f af6e 	beq.w	8016252 <put_fat.part.0+0x82>
 8016376:	e738      	b.n	80161ea <put_fat.part.0+0x1a>
 8016378:	f7ff fd0a 	bl	8015d90 <sync_window.part.0>
 801637c:	2800      	cmp	r0, #0
 801637e:	f43f af41 	beq.w	8016204 <put_fat.part.0+0x34>
 8016382:	e732      	b.n	80161ea <put_fat.part.0+0x1a>
 8016384:	f7ff fd04 	bl	8015d90 <sync_window.part.0>
 8016388:	2800      	cmp	r0, #0
 801638a:	d0a0      	beq.n	80162ce <put_fat.part.0+0xfe>
 801638c:	e72d      	b.n	80161ea <put_fat.part.0+0x1a>
			p = fs->win + bc % SS(fs);
 801638e:	f3c8 030b 	ubfx	r3, r8, #0, #12
 8016392:	eb09 0103 	add.w	r1, r9, r3
			*p = (clst & 1) ? (BYTE)(val >> 4) : ((*p & 0xF0) | ((BYTE)(val >> 8) & 0x0F));
 8016396:	e7cd      	b.n	8016334 <put_fat.part.0+0x164>

08016398 <get_fat.isra.0>:
	if (clst < 2 || clst >= fs->n_fatent) {	/* Check if in valid range */
 8016398:	2901      	cmp	r1, #1
 801639a:	d94c      	bls.n	8016436 <get_fat.isra.0+0x9e>
 801639c:	6983      	ldr	r3, [r0, #24]
 801639e:	4299      	cmp	r1, r3
DWORD get_fat (	/* 0xFFFFFFFF:Disk error, 1:Internal error, 2..0x7FFFFFFF:Cluster status */
 80163a0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80163a4:	460e      	mov	r6, r1
 80163a6:	4604      	mov	r4, r0
	if (clst < 2 || clst >= fs->n_fatent) {	/* Check if in valid range */
 80163a8:	d302      	bcc.n	80163b0 <get_fat.isra.0+0x18>
		switch (fs->fs_type) {
 80163aa:	2001      	movs	r0, #1
}
 80163ac:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		switch (fs->fs_type) {
 80163b0:	7803      	ldrb	r3, [r0, #0]
 80163b2:	2b02      	cmp	r3, #2
 80163b4:	d05b      	beq.n	801646e <get_fat.isra.0+0xd6>
 80163b6:	2b03      	cmp	r3, #3
 80163b8:	d03f      	beq.n	801643a <get_fat.isra.0+0xa2>
 80163ba:	2b01      	cmp	r3, #1
 80163bc:	d1f5      	bne.n	80163aa <get_fat.isra.0+0x12>
			if (move_window(fs, fs->fatbase + (bc / SS(fs))) != FR_OK) break;
 80163be:	6a42      	ldr	r2, [r0, #36]	; 0x24
			bc = (UINT)clst; bc += bc / 2;
 80163c0:	eb01 0751 	add.w	r7, r1, r1, lsr #1
	if (sector != fs->winsect) {	/* Window offset changed? */
 80163c4:	6b01      	ldr	r1, [r0, #48]	; 0x30
			if (move_window(fs, fs->fatbase + (bc / SS(fs))) != FR_OK) break;
 80163c6:	eb02 3517 	add.w	r5, r2, r7, lsr #12
	if (sector != fs->winsect) {	/* Window offset changed? */
 80163ca:	428d      	cmp	r5, r1
 80163cc:	d00e      	beq.n	80163ec <get_fat.isra.0+0x54>
	if (fs->wflag) {	/* Write back the sector if it is dirty */
 80163ce:	78c3      	ldrb	r3, [r0, #3]
 80163d0:	2b00      	cmp	r3, #0
 80163d2:	d17a      	bne.n	80164ca <get_fat.isra.0+0x132>
			if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK) {
 80163d4:	7860      	ldrb	r0, [r4, #1]
 80163d6:	2301      	movs	r3, #1
 80163d8:	462a      	mov	r2, r5
 80163da:	f104 0134 	add.w	r1, r4, #52	; 0x34
 80163de:	f7ff fb59 	bl	8015a94 <disk_read>
 80163e2:	2800      	cmp	r0, #0
 80163e4:	d161      	bne.n	80164aa <get_fat.isra.0+0x112>
			if (move_window(fs, fs->fatbase + (bc / SS(fs))) != FR_OK) break;
 80163e6:	6a62      	ldr	r2, [r4, #36]	; 0x24
			fs->winsect = sector;
 80163e8:	6325      	str	r5, [r4, #48]	; 0x30
			if (move_window(fs, fs->fatbase + (bc / SS(fs))) != FR_OK) break;
 80163ea:	4629      	mov	r1, r5
			wc = fs->win[bc++ % SS(fs)];
 80163ec:	f3c7 030b 	ubfx	r3, r7, #0, #12
 80163f0:	3701      	adds	r7, #1
 80163f2:	4423      	add	r3, r4
			if (move_window(fs, fs->fatbase + (bc / SS(fs))) != FR_OK) break;
 80163f4:	eb02 3817 	add.w	r8, r2, r7, lsr #12
	if (sector != fs->winsect) {	/* Window offset changed? */
 80163f8:	4541      	cmp	r1, r8
			wc = fs->win[bc++ % SS(fs)];
 80163fa:	f893 5034 	ldrb.w	r5, [r3, #52]	; 0x34
	if (sector != fs->winsect) {	/* Window offset changed? */
 80163fe:	d00d      	beq.n	801641c <get_fat.isra.0+0x84>
	if (fs->wflag) {	/* Write back the sector if it is dirty */
 8016400:	78e3      	ldrb	r3, [r4, #3]
 8016402:	2b00      	cmp	r3, #0
 8016404:	d166      	bne.n	80164d4 <get_fat.isra.0+0x13c>
			if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK) {
 8016406:	7860      	ldrb	r0, [r4, #1]
 8016408:	2301      	movs	r3, #1
 801640a:	4642      	mov	r2, r8
 801640c:	f104 0134 	add.w	r1, r4, #52	; 0x34
 8016410:	f7ff fb40 	bl	8015a94 <disk_read>
 8016414:	2800      	cmp	r0, #0
 8016416:	d148      	bne.n	80164aa <get_fat.isra.0+0x112>
			fs->winsect = sector;
 8016418:	f8c4 8030 	str.w	r8, [r4, #48]	; 0x30
			wc |= fs->win[bc % SS(fs)] << 8;
 801641c:	f3c7 070b 	ubfx	r7, r7, #0, #12
 8016420:	443c      	add	r4, r7
			val = (clst & 1) ? (wc >> 4) : (wc & 0xFFF);
 8016422:	07f3      	lsls	r3, r6, #31
			wc |= fs->win[bc % SS(fs)] << 8;
 8016424:	f894 0034 	ldrb.w	r0, [r4, #52]	; 0x34
 8016428:	ea45 2000 	orr.w	r0, r5, r0, lsl #8
			val = (clst & 1) ? (wc >> 4) : (wc & 0xFFF);
 801642c:	bf4c      	ite	mi
 801642e:	0900      	lsrmi	r0, r0, #4
 8016430:	f3c0 000b 	ubfxpl	r0, r0, #0, #12
 8016434:	e7ba      	b.n	80163ac <get_fat.isra.0+0x14>
		val = 1;	/* Internal error */
 8016436:	2001      	movs	r0, #1
}
 8016438:	4770      	bx	lr
			if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 4))) != FR_OK) break;
 801643a:	6a45      	ldr	r5, [r0, #36]	; 0x24
	if (sector != fs->winsect) {	/* Window offset changed? */
 801643c:	6b03      	ldr	r3, [r0, #48]	; 0x30
			if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 4))) != FR_OK) break;
 801643e:	eb05 2591 	add.w	r5, r5, r1, lsr #10
	if (sector != fs->winsect) {	/* Window offset changed? */
 8016442:	429d      	cmp	r5, r3
 8016444:	d02b      	beq.n	801649e <get_fat.isra.0+0x106>
	if (fs->wflag) {	/* Write back the sector if it is dirty */
 8016446:	78c3      	ldrb	r3, [r0, #3]
 8016448:	bb9b      	cbnz	r3, 80164b2 <get_fat.isra.0+0x11a>
			if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK) {
 801644a:	f104 0734 	add.w	r7, r4, #52	; 0x34
 801644e:	7860      	ldrb	r0, [r4, #1]
 8016450:	2301      	movs	r3, #1
 8016452:	462a      	mov	r2, r5
 8016454:	4639      	mov	r1, r7
 8016456:	f7ff fb1d 	bl	8015a94 <disk_read>
 801645a:	bb30      	cbnz	r0, 80164aa <get_fat.isra.0+0x112>
			fs->winsect = sector;
 801645c:	6325      	str	r5, [r4, #48]	; 0x30
			val = ld_dword(fs->win + clst * 4 % SS(fs)) & 0x0FFFFFFF;
 801645e:	f640 73fc 	movw	r3, #4092	; 0xffc
 8016462:	ea03 0686 	and.w	r6, r3, r6, lsl #2
	rv = rv << 8 | ptr[0];
 8016466:	59b8      	ldr	r0, [r7, r6]
			val = ld_dword(fs->win + clst * 4 % SS(fs)) & 0x0FFFFFFF;
 8016468:	f020 4070 	bic.w	r0, r0, #4026531840	; 0xf0000000
			break;
 801646c:	e79e      	b.n	80163ac <get_fat.isra.0+0x14>
			if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 2))) != FR_OK) break;
 801646e:	6a45      	ldr	r5, [r0, #36]	; 0x24
	if (sector != fs->winsect) {	/* Window offset changed? */
 8016470:	6b03      	ldr	r3, [r0, #48]	; 0x30
			if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 2))) != FR_OK) break;
 8016472:	eb05 25d1 	add.w	r5, r5, r1, lsr #11
	if (sector != fs->winsect) {	/* Window offset changed? */
 8016476:	429d      	cmp	r5, r3
 8016478:	d014      	beq.n	80164a4 <get_fat.isra.0+0x10c>
	if (fs->wflag) {	/* Write back the sector if it is dirty */
 801647a:	78c3      	ldrb	r3, [r0, #3]
 801647c:	bb03      	cbnz	r3, 80164c0 <get_fat.isra.0+0x128>
			if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK) {
 801647e:	f104 0734 	add.w	r7, r4, #52	; 0x34
 8016482:	7860      	ldrb	r0, [r4, #1]
 8016484:	2301      	movs	r3, #1
 8016486:	462a      	mov	r2, r5
 8016488:	4639      	mov	r1, r7
 801648a:	f7ff fb03 	bl	8015a94 <disk_read>
 801648e:	b960      	cbnz	r0, 80164aa <get_fat.isra.0+0x112>
			fs->winsect = sector;
 8016490:	6325      	str	r5, [r4, #48]	; 0x30
			val = ld_word(fs->win + clst * 2 % SS(fs));
 8016492:	f640 73fe 	movw	r3, #4094	; 0xffe
 8016496:	ea03 0646 	and.w	r6, r3, r6, lsl #1
 801649a:	5bb8      	ldrh	r0, [r7, r6]
			break;
 801649c:	e786      	b.n	80163ac <get_fat.isra.0+0x14>
			if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK) {
 801649e:	f100 0734 	add.w	r7, r0, #52	; 0x34
 80164a2:	e7dc      	b.n	801645e <get_fat.isra.0+0xc6>
 80164a4:	f100 0734 	add.w	r7, r0, #52	; 0x34
 80164a8:	e7f3      	b.n	8016492 <get_fat.isra.0+0xfa>
			fs->winsect = sector;
 80164aa:	f04f 30ff 	mov.w	r0, #4294967295
 80164ae:	6320      	str	r0, [r4, #48]	; 0x30
	return res;
 80164b0:	e77c      	b.n	80163ac <get_fat.isra.0+0x14>
 80164b2:	f7ff fc6d 	bl	8015d90 <sync_window.part.0>
		if (res == FR_OK) {			/* Fill sector window with new data */
 80164b6:	2800      	cmp	r0, #0
 80164b8:	d0c7      	beq.n	801644a <get_fat.isra.0+0xb2>
		val = 0xFFFFFFFF;	/* Default value falls on disk error */
 80164ba:	f04f 30ff 	mov.w	r0, #4294967295
 80164be:	e775      	b.n	80163ac <get_fat.isra.0+0x14>
 80164c0:	f7ff fc66 	bl	8015d90 <sync_window.part.0>
		if (res == FR_OK) {			/* Fill sector window with new data */
 80164c4:	2800      	cmp	r0, #0
 80164c6:	d0da      	beq.n	801647e <get_fat.isra.0+0xe6>
 80164c8:	e7f7      	b.n	80164ba <get_fat.isra.0+0x122>
 80164ca:	f7ff fc61 	bl	8015d90 <sync_window.part.0>
 80164ce:	2800      	cmp	r0, #0
 80164d0:	d080      	beq.n	80163d4 <get_fat.isra.0+0x3c>
 80164d2:	e7f2      	b.n	80164ba <get_fat.isra.0+0x122>
 80164d4:	4620      	mov	r0, r4
 80164d6:	f7ff fc5b 	bl	8015d90 <sync_window.part.0>
 80164da:	2800      	cmp	r0, #0
 80164dc:	d093      	beq.n	8016406 <get_fat.isra.0+0x6e>
 80164de:	e7ec      	b.n	80164ba <get_fat.isra.0+0x122>

080164e0 <remove_chain>:
	if (clst < 2 || clst >= fs->n_fatent) return FR_INT_ERR;	/* Check if in valid range */
 80164e0:	2901      	cmp	r1, #1
{
 80164e2:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	FATFS *fs = obj->fs;
 80164e4:	6806      	ldr	r6, [r0, #0]
{
 80164e6:	460d      	mov	r5, r1
	if (clst < 2 || clst >= fs->n_fatent) return FR_INT_ERR;	/* Check if in valid range */
 80164e8:	d92a      	bls.n	8016540 <remove_chain+0x60>
 80164ea:	69b3      	ldr	r3, [r6, #24]
 80164ec:	428b      	cmp	r3, r1
 80164ee:	d927      	bls.n	8016540 <remove_chain+0x60>
	if (pclst && (!_FS_EXFAT || fs->fs_type != FS_EXFAT || obj->stat != 2)) {
 80164f0:	4607      	mov	r7, r0
 80164f2:	4611      	mov	r1, r2
 80164f4:	bb32      	cbnz	r2, 8016544 <remove_chain+0x64>
 80164f6:	4630      	mov	r0, r6
 80164f8:	e014      	b.n	8016524 <remove_chain+0x44>
	if (clst >= 2 && clst < fs->n_fatent) {	/* Check if in valid range */
 80164fa:	69b3      	ldr	r3, [r6, #24]
 80164fc:	429d      	cmp	r5, r3
 80164fe:	d21f      	bcs.n	8016540 <remove_chain+0x60>
 8016500:	f7ff fe66 	bl	80161d0 <put_fat.part.0>
			if (res != FR_OK) return res;
 8016504:	b9e8      	cbnz	r0, 8016542 <remove_chain+0x62>
		if (fs->free_clst < fs->n_fatent - 2) {	/* Update FSINFO */
 8016506:	e9d6 3205 	ldrd	r3, r2, [r6, #20]
 801650a:	1e91      	subs	r1, r2, #2
 801650c:	428b      	cmp	r3, r1
 801650e:	d205      	bcs.n	801651c <remove_chain+0x3c>
			fs->fsi_flag |= 1;
 8016510:	7931      	ldrb	r1, [r6, #4]
			fs->free_clst++;
 8016512:	3301      	adds	r3, #1
			fs->fsi_flag |= 1;
 8016514:	f041 0101 	orr.w	r1, r1, #1
 8016518:	7131      	strb	r1, [r6, #4]
			fs->free_clst++;
 801651a:	6173      	str	r3, [r6, #20]
	} while (clst < fs->n_fatent);	/* Repeat while not the last link */
 801651c:	42a2      	cmp	r2, r4
 801651e:	d91e      	bls.n	801655e <remove_chain+0x7e>
 8016520:	6838      	ldr	r0, [r7, #0]
 8016522:	4625      	mov	r5, r4
		nxt = get_fat(obj, clst);			/* Get cluster status */
 8016524:	4629      	mov	r1, r5
 8016526:	f7ff ff37 	bl	8016398 <get_fat.isra.0>
 801652a:	4604      	mov	r4, r0
		if (nxt == 0) break;				/* Empty cluster? */
 801652c:	4629      	mov	r1, r5
 801652e:	2200      	movs	r2, #0
 8016530:	4630      	mov	r0, r6
 8016532:	b1a4      	cbz	r4, 801655e <remove_chain+0x7e>
		if (nxt == 1) return FR_INT_ERR;	/* Internal error? */
 8016534:	2c01      	cmp	r4, #1
 8016536:	d003      	beq.n	8016540 <remove_chain+0x60>
		if (nxt == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error? */
 8016538:	1c63      	adds	r3, r4, #1
 801653a:	d012      	beq.n	8016562 <remove_chain+0x82>
	if (clst >= 2 && clst < fs->n_fatent) {	/* Check if in valid range */
 801653c:	2d01      	cmp	r5, #1
 801653e:	d8dc      	bhi.n	80164fa <remove_chain+0x1a>
	if (clst < 2 || clst >= fs->n_fatent) return FR_INT_ERR;	/* Check if in valid range */
 8016540:	2002      	movs	r0, #2
}
 8016542:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	if (clst >= 2 && clst < fs->n_fatent) {	/* Check if in valid range */
 8016544:	2a01      	cmp	r2, #1
 8016546:	d0fb      	beq.n	8016540 <remove_chain+0x60>
 8016548:	4293      	cmp	r3, r2
 801654a:	d9f9      	bls.n	8016540 <remove_chain+0x60>
 801654c:	f04f 32ff 	mov.w	r2, #4294967295
 8016550:	4630      	mov	r0, r6
 8016552:	f7ff fe3d 	bl	80161d0 <put_fat.part.0>
		if (res != FR_OK) return res;
 8016556:	2800      	cmp	r0, #0
 8016558:	d1f3      	bne.n	8016542 <remove_chain+0x62>
 801655a:	6838      	ldr	r0, [r7, #0]
 801655c:	e7e2      	b.n	8016524 <remove_chain+0x44>
	return FR_OK;
 801655e:	2000      	movs	r0, #0
}
 8016560:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		if (nxt == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error? */
 8016562:	2001      	movs	r0, #1
}
 8016564:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8016566:	bf00      	nop

08016568 <create_chain>:
{
 8016568:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	FATFS *fs = obj->fs;
 801656c:	6807      	ldr	r7, [r0, #0]
{
 801656e:	4606      	mov	r6, r0
	if (clst == 0) {	/* Create a new chain */
 8016570:	4688      	mov	r8, r1
 8016572:	2900      	cmp	r1, #0
 8016574:	d14d      	bne.n	8016612 <create_chain+0xaa>
		scl = fs->last_clst;				/* Get suggested cluster to start from */
 8016576:	693d      	ldr	r5, [r7, #16]
			if (ncl >= fs->n_fatent) {		/* Check wrap-around */
 8016578:	69bb      	ldr	r3, [r7, #24]
		if (scl == 0 || scl >= fs->n_fatent) scl = 1;
 801657a:	2d00      	cmp	r5, #0
 801657c:	d13f      	bne.n	80165fe <create_chain+0x96>
 801657e:	2501      	movs	r5, #1
		ncl = scl;	/* Start cluster */
 8016580:	462c      	mov	r4, r5
 8016582:	e006      	b.n	8016592 <create_chain+0x2a>
			if (cs == 1 || cs == 0xFFFFFFFF) return cs;	/* An error occurred */
 8016584:	2801      	cmp	r0, #1
 8016586:	d040      	beq.n	801660a <create_chain+0xa2>
 8016588:	3001      	adds	r0, #1
 801658a:	d053      	beq.n	8016634 <create_chain+0xcc>
			if (ncl == scl) return 0;		/* No free cluster */
 801658c:	42ac      	cmp	r4, r5
 801658e:	d04d      	beq.n	801662c <create_chain+0xc4>
			if (ncl >= fs->n_fatent) {		/* Check wrap-around */
 8016590:	69bb      	ldr	r3, [r7, #24]
			ncl++;							/* Next cluster */
 8016592:	3401      	adds	r4, #1
			if (ncl >= fs->n_fatent) {		/* Check wrap-around */
 8016594:	429c      	cmp	r4, r3
 8016596:	d302      	bcc.n	801659e <create_chain+0x36>
				if (ncl > scl) return 0;	/* No free cluster */
 8016598:	2d01      	cmp	r5, #1
 801659a:	d047      	beq.n	801662c <create_chain+0xc4>
				ncl = 2;
 801659c:	2402      	movs	r4, #2
			cs = get_fat(obj, ncl);			/* Get the cluster status */
 801659e:	6830      	ldr	r0, [r6, #0]
 80165a0:	4621      	mov	r1, r4
 80165a2:	f7ff fef9 	bl	8016398 <get_fat.isra.0>
			if (cs == 0) break;				/* Found a free cluster */
 80165a6:	2800      	cmp	r0, #0
 80165a8:	d1ec      	bne.n	8016584 <create_chain+0x1c>
	if (clst >= 2 && clst < fs->n_fatent) {	/* Check if in valid range */
 80165aa:	2c01      	cmp	r4, #1
 80165ac:	d92d      	bls.n	801660a <create_chain+0xa2>
 80165ae:	69bb      	ldr	r3, [r7, #24]
 80165b0:	429c      	cmp	r4, r3
 80165b2:	d22a      	bcs.n	801660a <create_chain+0xa2>
 80165b4:	f04f 32ff 	mov.w	r2, #4294967295
 80165b8:	4621      	mov	r1, r4
 80165ba:	4638      	mov	r0, r7
 80165bc:	f7ff fe08 	bl	80161d0 <put_fat.part.0>
		if (res == FR_OK && clst != 0) {
 80165c0:	bb08      	cbnz	r0, 8016606 <create_chain+0x9e>
 80165c2:	f1b8 0f00 	cmp.w	r8, #0
 80165c6:	d00b      	beq.n	80165e0 <create_chain+0x78>
	if (clst >= 2 && clst < fs->n_fatent) {	/* Check if in valid range */
 80165c8:	f1b8 0f01 	cmp.w	r8, #1
 80165cc:	d01d      	beq.n	801660a <create_chain+0xa2>
 80165ce:	69bb      	ldr	r3, [r7, #24]
 80165d0:	4598      	cmp	r8, r3
 80165d2:	d21a      	bcs.n	801660a <create_chain+0xa2>
 80165d4:	4622      	mov	r2, r4
 80165d6:	4641      	mov	r1, r8
 80165d8:	4638      	mov	r0, r7
 80165da:	f7ff fdf9 	bl	80161d0 <put_fat.part.0>
	if (res == FR_OK) {			/* Update FSINFO if function succeeded. */
 80165de:	b990      	cbnz	r0, 8016606 <create_chain+0x9e>
		if (fs->free_clst <= fs->n_fatent - 2) fs->free_clst--;
 80165e0:	e9d7 2305 	ldrd	r2, r3, [r7, #20]
 80165e4:	3b02      	subs	r3, #2
 80165e6:	429a      	cmp	r2, r3
		fs->fsi_flag |= 1;
 80165e8:	793b      	ldrb	r3, [r7, #4]
		fs->last_clst = ncl;
 80165ea:	613c      	str	r4, [r7, #16]
		if (fs->free_clst <= fs->n_fatent - 2) fs->free_clst--;
 80165ec:	bf98      	it	ls
 80165ee:	f102 32ff 	addls.w	r2, r2, #4294967295
		fs->fsi_flag |= 1;
 80165f2:	f043 0301 	orr.w	r3, r3, #1
		if (fs->free_clst <= fs->n_fatent - 2) fs->free_clst--;
 80165f6:	bf98      	it	ls
 80165f8:	617a      	strls	r2, [r7, #20]
		fs->fsi_flag |= 1;
 80165fa:	713b      	strb	r3, [r7, #4]
 80165fc:	e006      	b.n	801660c <create_chain+0xa4>
		if (scl == 0 || scl >= fs->n_fatent) scl = 1;
 80165fe:	42ab      	cmp	r3, r5
 8016600:	bf98      	it	ls
 8016602:	2501      	movls	r5, #1
 8016604:	e7bc      	b.n	8016580 <create_chain+0x18>
		ncl = (res == FR_DISK_ERR) ? 0xFFFFFFFF : 1;	/* Failed. Generate error status */
 8016606:	2801      	cmp	r0, #1
 8016608:	d014      	beq.n	8016634 <create_chain+0xcc>
 801660a:	2401      	movs	r4, #1
}
 801660c:	4620      	mov	r0, r4
 801660e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		cs = get_fat(obj, clst);			/* Check the cluster status */
 8016612:	4638      	mov	r0, r7
 8016614:	f7ff fec0 	bl	8016398 <get_fat.isra.0>
		if (cs < 2) return 1;				/* Invalid FAT value */
 8016618:	2801      	cmp	r0, #1
		cs = get_fat(obj, clst);			/* Check the cluster status */
 801661a:	4604      	mov	r4, r0
		if (cs < 2) return 1;				/* Invalid FAT value */
 801661c:	d9f5      	bls.n	801660a <create_chain+0xa2>
		if (cs == 0xFFFFFFFF) return cs;	/* A disk error occurred */
 801661e:	1c43      	adds	r3, r0, #1
 8016620:	d008      	beq.n	8016634 <create_chain+0xcc>
		if (cs < fs->n_fatent) return cs;	/* It is already followed by next cluster */
 8016622:	69bb      	ldr	r3, [r7, #24]
 8016624:	4283      	cmp	r3, r0
 8016626:	d8f1      	bhi.n	801660c <create_chain+0xa4>
 8016628:	4645      	mov	r5, r8
 801662a:	e7a9      	b.n	8016580 <create_chain+0x18>
				if (ncl > scl) return 0;	/* No free cluster */
 801662c:	2400      	movs	r4, #0
}
 801662e:	4620      	mov	r0, r4
 8016630:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		if (cs == 0xFFFFFFFF) return cs;	/* A disk error occurred */
 8016634:	f04f 34ff 	mov.w	r4, #4294967295
}
 8016638:	4620      	mov	r0, r4
 801663a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 801663e:	bf00      	nop

08016640 <dir_next>:
{
 8016640:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	if (!dp->sect || ofs >= (DWORD)((_FS_EXFAT && fs->fs_type == FS_EXFAT) ? MAX_DIR_EX : MAX_DIR)) return FR_NO_FILE;	/* Report EOT when offset has reached max value */
 8016644:	69c3      	ldr	r3, [r0, #28]
	ofs = dp->dptr + SZDIRE;	/* Next entry */
 8016646:	6945      	ldr	r5, [r0, #20]
{
 8016648:	b083      	sub	sp, #12
	if (!dp->sect || ofs >= (DWORD)((_FS_EXFAT && fs->fs_type == FS_EXFAT) ? MAX_DIR_EX : MAX_DIR)) return FR_NO_FILE;	/* Report EOT when offset has reached max value */
 801664a:	2b00      	cmp	r3, #0
 801664c:	d03d      	beq.n	80166ca <dir_next+0x8a>
 801664e:	3520      	adds	r5, #32
 8016650:	f5b5 1f00 	cmp.w	r5, #2097152	; 0x200000
 8016654:	d239      	bcs.n	80166ca <dir_next+0x8a>
	if (ofs % SS(fs) == 0) {	/* Sector changed? */
 8016656:	f3c5 080b 	ubfx	r8, r5, #0, #12
	FATFS *fs = dp->obj.fs;
 801665a:	6807      	ldr	r7, [r0, #0]
	if (ofs % SS(fs) == 0) {	/* Sector changed? */
 801665c:	4604      	mov	r4, r0
 801665e:	f1b8 0f00 	cmp.w	r8, #0
 8016662:	d008      	beq.n	8016676 <dir_next+0x36>
					mem_set(fs->win, 0, SS(fs));				/* Clear window buffer */
 8016664:	f107 0634 	add.w	r6, r7, #52	; 0x34
	dp->dir = fs->win + ofs % SS(fs);	/* Pointer to the entry in the win[] */
 8016668:	4446      	add	r6, r8
	dp->dptr = ofs;						/* Current entry */
 801666a:	6165      	str	r5, [r4, #20]
	dp->dir = fs->win + ofs % SS(fs);	/* Pointer to the entry in the win[] */
 801666c:	6226      	str	r6, [r4, #32]
	return FR_OK;
 801666e:	2000      	movs	r0, #0
}
 8016670:	b003      	add	sp, #12
 8016672:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		dp->sect++;				/* Next sector */
 8016676:	460e      	mov	r6, r1
		if (!dp->clust) {		/* Static table */
 8016678:	6981      	ldr	r1, [r0, #24]
		dp->sect++;				/* Next sector */
 801667a:	3301      	adds	r3, #1
 801667c:	61c3      	str	r3, [r0, #28]
		if (!dp->clust) {		/* Static table */
 801667e:	b341      	cbz	r1, 80166d2 <dir_next+0x92>
			if ((ofs / SS(fs) & (fs->csize - 1)) == 0) {		/* Cluster changed? */
 8016680:	f8b7 900a 	ldrh.w	r9, [r7, #10]
 8016684:	f109 39ff 	add.w	r9, r9, #4294967295
 8016688:	ea19 3915 	ands.w	r9, r9, r5, lsr #12
 801668c:	d1ea      	bne.n	8016664 <dir_next+0x24>
				clst = get_fat(&dp->obj, dp->clust);			/* Get next cluster */
 801668e:	4638      	mov	r0, r7
 8016690:	f7ff fe82 	bl	8016398 <get_fat.isra.0>
				if (clst <= 1) return FR_INT_ERR;				/* Internal error */
 8016694:	2801      	cmp	r0, #1
				clst = get_fat(&dp->obj, dp->clust);			/* Get next cluster */
 8016696:	4683      	mov	fp, r0
				if (clst <= 1) return FR_INT_ERR;				/* Internal error */
 8016698:	d923      	bls.n	80166e2 <dir_next+0xa2>
				if (clst == 0xFFFFFFFF) return FR_DISK_ERR;		/* Disk error */
 801669a:	f1b0 3fff 	cmp.w	r0, #4294967295
 801669e:	d05b      	beq.n	8016758 <dir_next+0x118>
				if (clst >= fs->n_fatent) {						/* Reached end of dynamic table */
 80166a0:	69ba      	ldr	r2, [r7, #24]
 80166a2:	4282      	cmp	r2, r0
 80166a4:	d91f      	bls.n	80166e6 <dir_next+0xa6>
	clst -= 2;
 80166a6:	1e83      	subs	r3, r0, #2
					mem_set(fs->win, 0, SS(fs));				/* Clear window buffer */
 80166a8:	f107 0634 	add.w	r6, r7, #52	; 0x34
	clst -= 2;
 80166ac:	9301      	str	r3, [sp, #4]
	if (clst >= fs->n_fatent - 2) return 0;		/* Invalid cluster# */
 80166ae:	9901      	ldr	r1, [sp, #4]
				dp->clust = clst;		/* Initialize data for new cluster */
 80166b0:	f8c4 b018 	str.w	fp, [r4, #24]
	if (clst >= fs->n_fatent - 2) return 0;		/* Invalid cluster# */
 80166b4:	3a02      	subs	r2, #2
 80166b6:	428a      	cmp	r2, r1
 80166b8:	d904      	bls.n	80166c4 <dir_next+0x84>
	return clst * fs->csize + fs->database;
 80166ba:	f8b7 900a 	ldrh.w	r9, [r7, #10]
 80166be:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80166c0:	fb01 3909 	mla	r9, r1, r9, r3
				dp->sect = clust2sect(fs, clst);
 80166c4:	f8c4 901c 	str.w	r9, [r4, #28]
 80166c8:	e7ce      	b.n	8016668 <dir_next+0x28>
	if (!dp->sect || ofs >= (DWORD)((_FS_EXFAT && fs->fs_type == FS_EXFAT) ? MAX_DIR_EX : MAX_DIR)) return FR_NO_FILE;	/* Report EOT when offset has reached max value */
 80166ca:	2004      	movs	r0, #4
}
 80166cc:	b003      	add	sp, #12
 80166ce:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			if (ofs / SZDIRE >= fs->n_rootdir) {	/* Report EOT if it reached end of static table */
 80166d2:	893b      	ldrh	r3, [r7, #8]
 80166d4:	ebb3 1f55 	cmp.w	r3, r5, lsr #5
 80166d8:	d8c4      	bhi.n	8016664 <dir_next+0x24>
				dp->sect = 0; return FR_NO_FILE;
 80166da:	2300      	movs	r3, #0
 80166dc:	61e3      	str	r3, [r4, #28]
 80166de:	2004      	movs	r0, #4
 80166e0:	e7c6      	b.n	8016670 <dir_next+0x30>
				if (clst <= 1) return FR_INT_ERR;				/* Internal error */
 80166e2:	2002      	movs	r0, #2
 80166e4:	e7c4      	b.n	8016670 <dir_next+0x30>
					if (!stretch) {								/* If no stretch, report EOT */
 80166e6:	2e00      	cmp	r6, #0
 80166e8:	d0f7      	beq.n	80166da <dir_next+0x9a>
					clst = create_chain(&dp->obj, dp->clust);	/* Allocate a cluster */
 80166ea:	69a1      	ldr	r1, [r4, #24]
 80166ec:	4620      	mov	r0, r4
 80166ee:	f7ff ff3b 	bl	8016568 <create_chain>
					if (clst == 0) return FR_DENIED;			/* No free cluster */
 80166f2:	4683      	mov	fp, r0
 80166f4:	2800      	cmp	r0, #0
 80166f6:	d037      	beq.n	8016768 <dir_next+0x128>
					if (clst == 1) return FR_INT_ERR;			/* Internal error */
 80166f8:	2801      	cmp	r0, #1
 80166fa:	d0f2      	beq.n	80166e2 <dir_next+0xa2>
					if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
 80166fc:	f1b0 3fff 	cmp.w	r0, #4294967295
 8016700:	d02a      	beq.n	8016758 <dir_next+0x118>
	if (fs->wflag) {	/* Write back the sector if it is dirty */
 8016702:	78fa      	ldrb	r2, [r7, #3]
 8016704:	bb92      	cbnz	r2, 801676c <dir_next+0x12c>
					mem_set(fs->win, 0, SS(fs));				/* Clear window buffer */
 8016706:	f107 0634 	add.w	r6, r7, #52	; 0x34
		*d++ = (BYTE)val;
 801670a:	f44f 5280 	mov.w	r2, #4096	; 0x1000
 801670e:	2100      	movs	r1, #0
 8016710:	4630      	mov	r0, r6
 8016712:	f010 ff31 	bl	8027578 <memset>
	if (clst >= fs->n_fatent - 2) return 0;		/* Invalid cluster# */
 8016716:	69b8      	ldr	r0, [r7, #24]
	clst -= 2;
 8016718:	f1ab 0302 	sub.w	r3, fp, #2
	if (clst >= fs->n_fatent - 2) return 0;		/* Invalid cluster# */
 801671c:	1e82      	subs	r2, r0, #2
 801671e:	4293      	cmp	r3, r2
	clst -= 2;
 8016720:	9301      	str	r3, [sp, #4]
	if (clst >= fs->n_fatent - 2) return 0;		/* Invalid cluster# */
 8016722:	d229      	bcs.n	8016778 <dir_next+0x138>
	return clst * fs->csize + fs->database;
 8016724:	8979      	ldrh	r1, [r7, #10]
 8016726:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8016728:	9b01      	ldr	r3, [sp, #4]
 801672a:	fb03 2201 	mla	r2, r3, r1, r2
					for (n = 0, fs->winsect = clust2sect(fs, clst); n < fs->csize; n++, fs->winsect++) {	/* Fill the new cluster with 0 */
 801672e:	633a      	str	r2, [r7, #48]	; 0x30
 8016730:	b329      	cbz	r1, 801677e <dir_next+0x13e>
 8016732:	f04f 0a00 	mov.w	sl, #0
 8016736:	e005      	b.n	8016744 <dir_next+0x104>
 8016738:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 801673a:	8978      	ldrh	r0, [r7, #10]
 801673c:	3201      	adds	r2, #1
 801673e:	4550      	cmp	r0, sl
 8016740:	633a      	str	r2, [r7, #48]	; 0x30
 8016742:	d90b      	bls.n	801675c <dir_next+0x11c>
						fs->wflag = 1;
 8016744:	f04f 0301 	mov.w	r3, #1
 8016748:	70fb      	strb	r3, [r7, #3]
	if (fs->wflag) {	/* Write back the sector if it is dirty */
 801674a:	4638      	mov	r0, r7
					for (n = 0, fs->winsect = clust2sect(fs, clst); n < fs->csize; n++, fs->winsect++) {	/* Fill the new cluster with 0 */
 801674c:	f10a 0a01 	add.w	sl, sl, #1
 8016750:	f7ff fb1e 	bl	8015d90 <sync_window.part.0>
						if (sync_window(fs) != FR_OK) return FR_DISK_ERR;
 8016754:	2800      	cmp	r0, #0
 8016756:	d0ef      	beq.n	8016738 <dir_next+0xf8>
				if (clst == 0xFFFFFFFF) return FR_DISK_ERR;		/* Disk error */
 8016758:	2001      	movs	r0, #1
 801675a:	e789      	b.n	8016670 <dir_next+0x30>
 801675c:	69b8      	ldr	r0, [r7, #24]
					fs->winsect -= n;							/* Restore window offset */
 801675e:	eba2 020a 	sub.w	r2, r2, sl
 8016762:	633a      	str	r2, [r7, #48]	; 0x30
	if (clst >= fs->n_fatent - 2) return 0;		/* Invalid cluster# */
 8016764:	4602      	mov	r2, r0
 8016766:	e7a2      	b.n	80166ae <dir_next+0x6e>
					if (clst == 0) return FR_DENIED;			/* No free cluster */
 8016768:	2007      	movs	r0, #7
 801676a:	e781      	b.n	8016670 <dir_next+0x30>
 801676c:	4638      	mov	r0, r7
 801676e:	f7ff fb0f 	bl	8015d90 <sync_window.part.0>
					if (sync_window(fs) != FR_OK) return FR_DISK_ERR;	/* Flush disk access window */
 8016772:	2800      	cmp	r0, #0
 8016774:	d0c7      	beq.n	8016706 <dir_next+0xc6>
 8016776:	e7ef      	b.n	8016758 <dir_next+0x118>
	return clst * fs->csize + fs->database;
 8016778:	8979      	ldrh	r1, [r7, #10]
	if (clst >= fs->n_fatent - 2) return 0;		/* Invalid cluster# */
 801677a:	2200      	movs	r2, #0
 801677c:	e7d7      	b.n	801672e <dir_next+0xee>
					for (n = 0, fs->winsect = clust2sect(fs, clst); n < fs->csize; n++, fs->winsect++) {	/* Fill the new cluster with 0 */
 801677e:	468a      	mov	sl, r1
 8016780:	e7ed      	b.n	801675e <dir_next+0x11e>
 8016782:	bf00      	nop

08016784 <dir_read.constprop.0>:
FRESULT dir_read (
 8016784:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8016788:	4604      	mov	r4, r0
	FATFS *fs = dp->obj.fs;
 801678a:	6805      	ldr	r5, [r0, #0]
	while (dp->sect) {
 801678c:	f8d4 901c 	ldr.w	r9, [r4, #28]
	BYTE ord = 0xFF, sum = 0xFF;
 8016790:	f04f 08ff 	mov.w	r8, #255	; 0xff
 8016794:	4646      	mov	r6, r8
	FRESULT res = FR_NO_FILE;
 8016796:	2004      	movs	r0, #4
			if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK) {
 8016798:	f105 0734 	add.w	r7, r5, #52	; 0x34
	while (dp->sect) {
 801679c:	f1b9 0f00 	cmp.w	r9, #0
 80167a0:	d031      	beq.n	8016806 <dir_read.constprop.0+0x82>
	if (sector != fs->winsect) {	/* Window offset changed? */
 80167a2:	6b2b      	ldr	r3, [r5, #48]	; 0x30
 80167a4:	454b      	cmp	r3, r9
 80167a6:	d012      	beq.n	80167ce <dir_read.constprop.0+0x4a>
	if (fs->wflag) {	/* Write back the sector if it is dirty */
 80167a8:	78eb      	ldrb	r3, [r5, #3]
 80167aa:	bb8b      	cbnz	r3, 8016810 <dir_read.constprop.0+0x8c>
			if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK) {
 80167ac:	7868      	ldrb	r0, [r5, #1]
 80167ae:	2301      	movs	r3, #1
 80167b0:	464a      	mov	r2, r9
 80167b2:	4639      	mov	r1, r7
 80167b4:	f7ff f96e 	bl	8015a94 <disk_read>
 80167b8:	b138      	cbz	r0, 80167ca <dir_read.constprop.0+0x46>
			fs->winsect = sector;
 80167ba:	f04f 33ff 	mov.w	r3, #4294967295
 80167be:	632b      	str	r3, [r5, #48]	; 0x30
				res = FR_DISK_ERR;
 80167c0:	2001      	movs	r0, #1
	if (res != FR_OK) dp->sect = 0;		/* Terminate the read operation on error or EOT */
 80167c2:	2300      	movs	r3, #0
 80167c4:	61e3      	str	r3, [r4, #28]
}
 80167c6:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
			fs->winsect = sector;
 80167ca:	f8c5 9030 	str.w	r9, [r5, #48]	; 0x30
		c = dp->dir[DIR_Name];	/* Test for the entry type */
 80167ce:	6a21      	ldr	r1, [r4, #32]
 80167d0:	780a      	ldrb	r2, [r1, #0]
		if (c == 0) {
 80167d2:	2a00      	cmp	r2, #0
 80167d4:	d058      	beq.n	8016888 <dir_read.constprop.0+0x104>
			dp->obj.attr = a = dp->dir[DIR_Attr] & AM_MASK;	/* Get attribute */
 80167d6:	7acb      	ldrb	r3, [r1, #11]
			if (c == DDEM || c == '.' || (int)((a & ~AM_ARC) == AM_VOL) != vol) {	/* An entry without valid data */
 80167d8:	2ae5      	cmp	r2, #229	; 0xe5
			dp->obj.attr = a = dp->dir[DIR_Attr] & AM_MASK;	/* Get attribute */
 80167da:	f003 033f 	and.w	r3, r3, #63	; 0x3f
 80167de:	71a3      	strb	r3, [r4, #6]
			if (c == DDEM || c == '.' || (int)((a & ~AM_ARC) == AM_VOL) != vol) {	/* An entry without valid data */
 80167e0:	d005      	beq.n	80167ee <dir_read.constprop.0+0x6a>
 80167e2:	2a2e      	cmp	r2, #46	; 0x2e
 80167e4:	d003      	beq.n	80167ee <dir_read.constprop.0+0x6a>
 80167e6:	f023 0020 	bic.w	r0, r3, #32
 80167ea:	2808      	cmp	r0, #8
 80167ec:	d116      	bne.n	801681c <dir_read.constprop.0+0x98>
					ord = (c == ord && sum == dp->dir[LDIR_Chksum] && pick_lfn(fs->lfnbuf, dp->dir)) ? ord - 1 : 0xFF;
 80167ee:	26ff      	movs	r6, #255	; 0xff
		res = dir_next(dp, 0);		/* Next entry */
 80167f0:	2100      	movs	r1, #0
 80167f2:	4620      	mov	r0, r4
 80167f4:	f7ff ff24 	bl	8016640 <dir_next>
		if (res != FR_OK) break;
 80167f8:	2800      	cmp	r0, #0
 80167fa:	d1e2      	bne.n	80167c2 <dir_read.constprop.0+0x3e>
	while (dp->sect) {
 80167fc:	f8d4 901c 	ldr.w	r9, [r4, #28]
 8016800:	f1b9 0f00 	cmp.w	r9, #0
 8016804:	d1cd      	bne.n	80167a2 <dir_read.constprop.0+0x1e>
	if (res != FR_OK) dp->sect = 0;		/* Terminate the read operation on error or EOT */
 8016806:	2800      	cmp	r0, #0
 8016808:	d1db      	bne.n	80167c2 <dir_read.constprop.0+0x3e>
						dp->blk_ofs = 0xFFFFFFFF;			/* It has no LFN. */
 801680a:	2000      	movs	r0, #0
}
 801680c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8016810:	4628      	mov	r0, r5
 8016812:	f7ff fabd 	bl	8015d90 <sync_window.part.0>
		if (res == FR_OK) {			/* Fill sector window with new data */
 8016816:	2800      	cmp	r0, #0
 8016818:	d0c8      	beq.n	80167ac <dir_read.constprop.0+0x28>
 801681a:	e7d2      	b.n	80167c2 <dir_read.constprop.0+0x3e>
				if (a == AM_LFN) {			/* An LFN entry is found */
 801681c:	2b0f      	cmp	r3, #15
 801681e:	d140      	bne.n	80168a2 <dir_read.constprop.0+0x11e>
					if (c & LLEF) {			/* Is it start of an LFN sequence? */
 8016820:	0650      	lsls	r0, r2, #25
 8016822:	d52e      	bpl.n	8016882 <dir_read.constprop.0+0xfe>
						dp->blk_ofs = dp->dptr;
 8016824:	6963      	ldr	r3, [r4, #20]
						sum = dp->dir[LDIR_Chksum];
 8016826:	f891 800d 	ldrb.w	r8, [r1, #13]
						dp->blk_ofs = dp->dptr;
 801682a:	6323      	str	r3, [r4, #48]	; 0x30
						c &= (BYTE)~LLEF; ord = c;
 801682c:	f002 06bf 	and.w	r6, r2, #191	; 0xbf
					ord = (c == ord && sum == dp->dir[LDIR_Chksum] && pick_lfn(fs->lfnbuf, dp->dir)) ? ord - 1 : 0xFF;
 8016830:	7b4b      	ldrb	r3, [r1, #13]
 8016832:	4543      	cmp	r3, r8
 8016834:	d1db      	bne.n	80167ee <dir_read.constprop.0+0x6a>
	if (ld_word(dir + LDIR_FstClusLO) != 0) return 0;	/* Check LDIR_FstClusLO is 0 */
 8016836:	8b4b      	ldrh	r3, [r1, #26]
 8016838:	2b00      	cmp	r3, #0
 801683a:	d1d8      	bne.n	80167ee <dir_read.constprop.0+0x6a>
	i = ((dir[LDIR_Ord] & ~LLEF) - 1) * 13;	/* Offset in the LFN buffer */
 801683c:	780a      	ldrb	r2, [r1, #0]
 801683e:	4b22      	ldr	r3, [pc, #136]	; (80168c8 <dir_read.constprop.0+0x144>)
					ord = (c == ord && sum == dp->dir[LDIR_Chksum] && pick_lfn(fs->lfnbuf, dp->dir)) ? ord - 1 : 0xFF;
 8016840:	f8d5 a00c 	ldr.w	sl, [r5, #12]
	i = ((dir[LDIR_Ord] & ~LLEF) - 1) * 13;	/* Offset in the LFN buffer */
 8016844:	f022 0240 	bic.w	r2, r2, #64	; 0x40
 8016848:	3a01      	subs	r2, #1
 801684a:	eb02 0042 	add.w	r0, r2, r2, lsl #1
 801684e:	eb02 0280 	add.w	r2, r2, r0, lsl #2
 8016852:	2001      	movs	r0, #1
 8016854:	f103 0e0c 	add.w	lr, r3, #12
	for (wc = 1, s = 0; s < 13; s++) {		/* Process all characters in the entry */
 8016858:	4684      	mov	ip, r0
			if (uc != 0xFFFF) return 0;		/* Check filler */
 801685a:	f64f 79ff 	movw	r9, #65535	; 0xffff
 801685e:	e009      	b.n	8016874 <dir_read.constprop.0+0xf0>
			if (i >= _MAX_LFN) return 0;	/* Buffer overflow? */
 8016860:	2afe      	cmp	r2, #254	; 0xfe
 8016862:	d8c4      	bhi.n	80167ee <dir_read.constprop.0+0x6a>
			lfnbuf[i++] = wc = uc;			/* Store it */
 8016864:	f82a 0012 	strh.w	r0, [sl, r2, lsl #1]
 8016868:	4684      	mov	ip, r0
 801686a:	3201      	adds	r2, #1
	for (wc = 1, s = 0; s < 13; s++) {		/* Process all characters in the entry */
 801686c:	4573      	cmp	r3, lr
 801686e:	d00d      	beq.n	801688c <dir_read.constprop.0+0x108>
		uc = ld_word(dir + LfnOfs[s]);		/* Pick an LFN character */
 8016870:	f813 0f01 	ldrb.w	r0, [r3, #1]!
			if (uc != 0xFFFF) return 0;		/* Check filler */
 8016874:	5a08      	ldrh	r0, [r1, r0]
		if (wc) {
 8016876:	f1bc 0f00 	cmp.w	ip, #0
 801687a:	d1f1      	bne.n	8016860 <dir_read.constprop.0+0xdc>
			if (uc != 0xFFFF) return 0;		/* Check filler */
 801687c:	4548      	cmp	r0, r9
 801687e:	d0f5      	beq.n	801686c <dir_read.constprop.0+0xe8>
 8016880:	e7b5      	b.n	80167ee <dir_read.constprop.0+0x6a>
					ord = (c == ord && sum == dp->dir[LDIR_Chksum] && pick_lfn(fs->lfnbuf, dp->dir)) ? ord - 1 : 0xFF;
 8016882:	42b2      	cmp	r2, r6
 8016884:	d1b3      	bne.n	80167ee <dir_read.constprop.0+0x6a>
 8016886:	e7d3      	b.n	8016830 <dir_read.constprop.0+0xac>
			res = FR_NO_FILE; break; /* Reached to end of the directory */
 8016888:	2004      	movs	r0, #4
 801688a:	e79a      	b.n	80167c2 <dir_read.constprop.0+0x3e>
	if (dir[LDIR_Ord] & LLEF) {				/* Put terminator if it is the last LFN part */
 801688c:	780b      	ldrb	r3, [r1, #0]
 801688e:	065b      	lsls	r3, r3, #25
 8016890:	d504      	bpl.n	801689c <dir_read.constprop.0+0x118>
		if (i >= _MAX_LFN) return 0;		/* Buffer overflow? */
 8016892:	2afe      	cmp	r2, #254	; 0xfe
 8016894:	d8ab      	bhi.n	80167ee <dir_read.constprop.0+0x6a>
		lfnbuf[i] = 0;
 8016896:	2300      	movs	r3, #0
 8016898:	f82a 3012 	strh.w	r3, [sl, r2, lsl #1]
					ord = (c == ord && sum == dp->dir[LDIR_Chksum] && pick_lfn(fs->lfnbuf, dp->dir)) ? ord - 1 : 0xFF;
 801689c:	3e01      	subs	r6, #1
 801689e:	b2f6      	uxtb	r6, r6
 80168a0:	e7a6      	b.n	80167f0 <dir_read.constprop.0+0x6c>
					if (ord || sum != sum_sfn(dp->dir)) {	/* Is there a valid LFN? */
 80168a2:	b96e      	cbnz	r6, 80168c0 <dir_read.constprop.0+0x13c>
 80168a4:	f101 020b 	add.w	r2, r1, #11
		sum = (sum >> 1) + (sum << 7) + *dir++;
 80168a8:	01f3      	lsls	r3, r6, #7
 80168aa:	ea43 0656 	orr.w	r6, r3, r6, lsr #1
 80168ae:	f811 3b01 	ldrb.w	r3, [r1], #1
 80168b2:	fa53 f686 	uxtab	r6, r3, r6
	} while (--n);
 80168b6:	4291      	cmp	r1, r2
		sum = (sum >> 1) + (sum << 7) + *dir++;
 80168b8:	b2f6      	uxtb	r6, r6
	} while (--n);
 80168ba:	d1f5      	bne.n	80168a8 <dir_read.constprop.0+0x124>
					if (ord || sum != sum_sfn(dp->dir)) {	/* Is there a valid LFN? */
 80168bc:	4546      	cmp	r6, r8
 80168be:	d0a4      	beq.n	801680a <dir_read.constprop.0+0x86>
						dp->blk_ofs = 0xFFFFFFFF;			/* It has no LFN. */
 80168c0:	f04f 33ff 	mov.w	r3, #4294967295
 80168c4:	6323      	str	r3, [r4, #48]	; 0x30
 80168c6:	e7a0      	b.n	801680a <dir_read.constprop.0+0x86>
 80168c8:	0802d344 	.word	0x0802d344

080168cc <dir_sdi>:
	if (ofs >= (DWORD)((_FS_EXFAT && fs->fs_type == FS_EXFAT) ? MAX_DIR_EX : MAX_DIR) || ofs % SZDIRE) {	/* Check range of offset and alignment */
 80168cc:	f5b1 1f00 	cmp.w	r1, #2097152	; 0x200000
 80168d0:	d242      	bcs.n	8016958 <dir_sdi+0x8c>
 80168d2:	06ca      	lsls	r2, r1, #27
{
 80168d4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80168d6:	460d      	mov	r5, r1
	if (ofs >= (DWORD)((_FS_EXFAT && fs->fs_type == FS_EXFAT) ? MAX_DIR_EX : MAX_DIR) || ofs % SZDIRE) {	/* Check range of offset and alignment */
 80168d8:	d120      	bne.n	801691c <dir_sdi+0x50>
	clst = dp->obj.sclust;		/* Table start cluster (0:root) */
 80168da:	6881      	ldr	r1, [r0, #8]
	FATFS *fs = dp->obj.fs;
 80168dc:	6807      	ldr	r7, [r0, #0]
	dp->dptr = ofs;				/* Set current offset */
 80168de:	6145      	str	r5, [r0, #20]
	if (clst == 0 && fs->fs_type >= FS_FAT32) {	/* Replace cluster# 0 with root cluster# */
 80168e0:	4606      	mov	r6, r0
 80168e2:	b1e9      	cbz	r1, 8016920 <dir_sdi+0x54>
		csz = (DWORD)fs->csize * SS(fs);	/* Bytes per cluster */
 80168e4:	897b      	ldrh	r3, [r7, #10]
		while (ofs >= csz) {				/* Follow cluster chain */
 80168e6:	ebb5 3f03 	cmp.w	r5, r3, lsl #12
		csz = (DWORD)fs->csize * SS(fs);	/* Bytes per cluster */
 80168ea:	ea4f 3403 	mov.w	r4, r3, lsl #12
		while (ofs >= csz) {				/* Follow cluster chain */
 80168ee:	d335      	bcc.n	801695c <dir_sdi+0x90>
 80168f0:	4638      	mov	r0, r7
 80168f2:	e007      	b.n	8016904 <dir_sdi+0x38>
			if (clst < 2 || clst >= fs->n_fatent) return FR_INT_ERR;	/* Reached to end of table or internal error */
 80168f4:	2801      	cmp	r0, #1
 80168f6:	d911      	bls.n	801691c <dir_sdi+0x50>
 80168f8:	69bb      	ldr	r3, [r7, #24]
 80168fa:	4283      	cmp	r3, r0
 80168fc:	d90e      	bls.n	801691c <dir_sdi+0x50>
		while (ofs >= csz) {				/* Follow cluster chain */
 80168fe:	42ac      	cmp	r4, r5
 8016900:	d82d      	bhi.n	801695e <dir_sdi+0x92>
 8016902:	6830      	ldr	r0, [r6, #0]
			clst = get_fat(&dp->obj, clst);				/* Get next cluster */
 8016904:	f7ff fd48 	bl	8016398 <get_fat.isra.0>
			if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
 8016908:	1c43      	adds	r3, r0, #1
			clst = get_fat(&dp->obj, clst);				/* Get next cluster */
 801690a:	4601      	mov	r1, r0
			ofs -= csz;
 801690c:	eba5 0504 	sub.w	r5, r5, r4
			if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
 8016910:	d1f0      	bne.n	80168f4 <dir_sdi+0x28>
 8016912:	2001      	movs	r0, #1
}
 8016914:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		dp->sect = clust2sect(fs, clst);
 8016916:	2300      	movs	r3, #0
	dp->clust = clst;					/* Current cluster# */
 8016918:	e9c6 1306 	strd	r1, r3, [r6, #24]
		return FR_INT_ERR;
 801691c:	2002      	movs	r0, #2
}
 801691e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	if (clst == 0 && fs->fs_type >= FS_FAT32) {	/* Replace cluster# 0 with root cluster# */
 8016920:	783b      	ldrb	r3, [r7, #0]
 8016922:	2b02      	cmp	r3, #2
 8016924:	d813      	bhi.n	801694e <dir_sdi+0x82>
		if (ofs / SZDIRE >= fs->n_rootdir)	return FR_INT_ERR;	/* Is index out of range? */
 8016926:	893b      	ldrh	r3, [r7, #8]
 8016928:	ebb3 1f55 	cmp.w	r3, r5, lsr #5
 801692c:	d9f6      	bls.n	801691c <dir_sdi+0x50>
		dp->sect = fs->dirbase;
 801692e:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8016930:	61f2      	str	r2, [r6, #28]
	dp->clust = clst;					/* Current cluster# */
 8016932:	61b1      	str	r1, [r6, #24]
	if (!dp->sect) return FR_INT_ERR;
 8016934:	2a00      	cmp	r2, #0
 8016936:	d0f1      	beq.n	801691c <dir_sdi+0x50>
	dp->dir = fs->win + (ofs % SS(fs));	/* Pointer to the entry in the win[] */
 8016938:	f107 0334 	add.w	r3, r7, #52	; 0x34
 801693c:	f3c5 010b 	ubfx	r1, r5, #0, #12
	dp->sect += ofs / SS(fs);			/* Sector# of the directory entry */
 8016940:	eb02 3215 	add.w	r2, r2, r5, lsr #12
	dp->dir = fs->win + (ofs % SS(fs));	/* Pointer to the entry in the win[] */
 8016944:	440b      	add	r3, r1
 8016946:	e9c6 2307 	strd	r2, r3, [r6, #28]
	return FR_OK;
 801694a:	2000      	movs	r0, #0
}
 801694c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		clst = fs->dirbase;
 801694e:	6abb      	ldr	r3, [r7, #40]	; 0x28
	if (clst == 0) {	/* Static table (root-directory in FAT12/16) */
 8016950:	2b00      	cmp	r3, #0
 8016952:	d0e8      	beq.n	8016926 <dir_sdi+0x5a>
 8016954:	4619      	mov	r1, r3
 8016956:	e7c5      	b.n	80168e4 <dir_sdi+0x18>
		return FR_INT_ERR;
 8016958:	2002      	movs	r0, #2
}
 801695a:	4770      	bx	lr
	if (clst >= fs->n_fatent - 2) return 0;		/* Invalid cluster# */
 801695c:	69bb      	ldr	r3, [r7, #24]
 801695e:	3b02      	subs	r3, #2
	clst -= 2;
 8016960:	1e88      	subs	r0, r1, #2
	if (clst >= fs->n_fatent - 2) return 0;		/* Invalid cluster# */
 8016962:	4298      	cmp	r0, r3
 8016964:	d2d7      	bcs.n	8016916 <dir_sdi+0x4a>
	return clst * fs->csize + fs->database;
 8016966:	897b      	ldrh	r3, [r7, #10]
 8016968:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 801696a:	fb00 2203 	mla	r2, r0, r3, r2
		dp->sect = clust2sect(fs, clst);
 801696e:	61f2      	str	r2, [r6, #28]
 8016970:	e7df      	b.n	8016932 <dir_sdi+0x66>
 8016972:	bf00      	nop

08016974 <dir_remove>:
	res = (dp->blk_ofs == 0xFFFFFFFF) ? FR_OK : dir_sdi(dp, dp->blk_ofs);	/* Goto top of the entry block if LFN is exist */
 8016974:	6b01      	ldr	r1, [r0, #48]	; 0x30
 8016976:	1c4b      	adds	r3, r1, #1
{
 8016978:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	FATFS *fs = dp->obj.fs;
 801697c:	6805      	ldr	r5, [r0, #0]
	DWORD last = dp->dptr;
 801697e:	6946      	ldr	r6, [r0, #20]
{
 8016980:	4604      	mov	r4, r0
	res = (dp->blk_ofs == 0xFFFFFFFF) ? FR_OK : dir_sdi(dp, dp->blk_ofs);	/* Goto top of the entry block if LFN is exist */
 8016982:	d133      	bne.n	80169ec <dir_remove+0x78>
			if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK) {
 8016984:	f105 0934 	add.w	r9, r5, #52	; 0x34
 8016988:	f04f 0801 	mov.w	r8, #1
				dp->dir[DIR_Name] = DDEM;
 801698c:	27e5      	movs	r7, #229	; 0xe5
			res = move_window(fs, dp->sect);
 801698e:	f8d4 a01c 	ldr.w	sl, [r4, #28]
	if (sector != fs->winsect) {	/* Window offset changed? */
 8016992:	6b2b      	ldr	r3, [r5, #48]	; 0x30
 8016994:	459a      	cmp	sl, r3
 8016996:	d010      	beq.n	80169ba <dir_remove+0x46>
	if (fs->wflag) {	/* Write back the sector if it is dirty */
 8016998:	78eb      	ldrb	r3, [r5, #3]
 801699a:	b9eb      	cbnz	r3, 80169d8 <dir_remove+0x64>
			if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK) {
 801699c:	7868      	ldrb	r0, [r5, #1]
 801699e:	2301      	movs	r3, #1
 80169a0:	4652      	mov	r2, sl
 80169a2:	4649      	mov	r1, r9
 80169a4:	f7ff f876 	bl	8015a94 <disk_read>
 80169a8:	b128      	cbz	r0, 80169b6 <dir_remove+0x42>
			fs->winsect = sector;
 80169aa:	f04f 33ff 	mov.w	r3, #4294967295
 80169ae:	632b      	str	r3, [r5, #48]	; 0x30
				res = FR_DISK_ERR;
 80169b0:	2001      	movs	r0, #1
}
 80169b2:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
			fs->winsect = sector;
 80169b6:	f8c5 a030 	str.w	sl, [r5, #48]	; 0x30
				dp->dir[DIR_Name] = DDEM;
 80169ba:	6a23      	ldr	r3, [r4, #32]
 80169bc:	701f      	strb	r7, [r3, #0]
			fs->wflag = 1;
 80169be:	f885 8003 	strb.w	r8, [r5, #3]
			if (dp->dptr >= last) break;	/* If reached last entry then all entries of the object has been deleted. */
 80169c2:	6963      	ldr	r3, [r4, #20]
 80169c4:	42b3      	cmp	r3, r6
			res = dir_next(dp, 0);	/* Next entry */
 80169c6:	f04f 0100 	mov.w	r1, #0
 80169ca:	4620      	mov	r0, r4
			if (dp->dptr >= last) break;	/* If reached last entry then all entries of the object has been deleted. */
 80169cc:	d214      	bcs.n	80169f8 <dir_remove+0x84>
			res = dir_next(dp, 0);	/* Next entry */
 80169ce:	f7ff fe37 	bl	8016640 <dir_next>
		} while (res == FR_OK);
 80169d2:	2800      	cmp	r0, #0
 80169d4:	d0db      	beq.n	801698e <dir_remove+0x1a>
 80169d6:	e004      	b.n	80169e2 <dir_remove+0x6e>
 80169d8:	4628      	mov	r0, r5
 80169da:	f7ff f9d9 	bl	8015d90 <sync_window.part.0>
		if (res == FR_OK) {			/* Fill sector window with new data */
 80169de:	2800      	cmp	r0, #0
 80169e0:	d0dc      	beq.n	801699c <dir_remove+0x28>
		if (res == FR_NO_FILE) res = FR_INT_ERR;
 80169e2:	2804      	cmp	r0, #4
 80169e4:	bf08      	it	eq
 80169e6:	2002      	moveq	r0, #2
}
 80169e8:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	res = (dp->blk_ofs == 0xFFFFFFFF) ? FR_OK : dir_sdi(dp, dp->blk_ofs);	/* Goto top of the entry block if LFN is exist */
 80169ec:	f7ff ff6e 	bl	80168cc <dir_sdi>
	if (res == FR_OK) {
 80169f0:	2800      	cmp	r0, #0
 80169f2:	d0c7      	beq.n	8016984 <dir_remove+0x10>
}
 80169f4:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 80169f8:	2000      	movs	r0, #0
 80169fa:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 80169fe:	bf00      	nop

08016a00 <dir_find>:
{
 8016a00:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8016a04:	ed2d 8b02 	vpush	{d8}
	res = dir_sdi(dp, 0);			/* Rewind directory object */
 8016a08:	2100      	movs	r1, #0
{
 8016a0a:	b085      	sub	sp, #20
	FATFS *fs = dp->obj.fs;
 8016a0c:	6807      	ldr	r7, [r0, #0]
{
 8016a0e:	4605      	mov	r5, r0
	res = dir_sdi(dp, 0);			/* Rewind directory object */
 8016a10:	f7ff ff5c 	bl	80168cc <dir_sdi>
	if (res != FR_OK) return res;
 8016a14:	b9c8      	cbnz	r0, 8016a4a <dir_find+0x4a>
	ord = sum = 0xFF; dp->blk_ofs = 0xFFFFFFFF;	/* Reset LFN sequence */
 8016a16:	f04f 33ff 	mov.w	r3, #4294967295
 8016a1a:	f04f 09ff 	mov.w	r9, #255	; 0xff
 8016a1e:	632b      	str	r3, [r5, #48]	; 0x30
 8016a20:	46ca      	mov	sl, r9
			if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK) {
 8016a22:	f107 0834 	add.w	r8, r7, #52	; 0x34
		res = move_window(fs, dp->sect);
 8016a26:	69ec      	ldr	r4, [r5, #28]
	if (sector != fs->winsect) {	/* Window offset changed? */
 8016a28:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8016a2a:	429c      	cmp	r4, r3
 8016a2c:	d013      	beq.n	8016a56 <dir_find+0x56>
	if (fs->wflag) {	/* Write back the sector if it is dirty */
 8016a2e:	78fb      	ldrb	r3, [r7, #3]
 8016a30:	2b00      	cmp	r3, #0
 8016a32:	d14f      	bne.n	8016ad4 <dir_find+0xd4>
			if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK) {
 8016a34:	7878      	ldrb	r0, [r7, #1]
 8016a36:	2301      	movs	r3, #1
 8016a38:	4622      	mov	r2, r4
 8016a3a:	4641      	mov	r1, r8
 8016a3c:	f7ff f82a 	bl	8015a94 <disk_read>
 8016a40:	b140      	cbz	r0, 8016a54 <dir_find+0x54>
			fs->winsect = sector;
 8016a42:	f04f 33ff 	mov.w	r3, #4294967295
 8016a46:	633b      	str	r3, [r7, #48]	; 0x30
				res = FR_DISK_ERR;
 8016a48:	2001      	movs	r0, #1
}
 8016a4a:	b005      	add	sp, #20
 8016a4c:	ecbd 8b02 	vpop	{d8}
 8016a50:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			fs->winsect = sector;
 8016a54:	633c      	str	r4, [r7, #48]	; 0x30
		c = dp->dir[DIR_Name];
 8016a56:	6a2c      	ldr	r4, [r5, #32]
 8016a58:	7826      	ldrb	r6, [r4, #0]
		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
 8016a5a:	2e00      	cmp	r6, #0
 8016a5c:	f000 80ac 	beq.w	8016bb8 <dir_find+0x1b8>
		dp->obj.attr = a = dp->dir[DIR_Attr] & AM_MASK;
 8016a60:	7ae2      	ldrb	r2, [r4, #11]
		if (c == DDEM || ((a & AM_VOL) && a != AM_LFN)) {	/* An entry without valid data */
 8016a62:	2ee5      	cmp	r6, #229	; 0xe5
		dp->obj.attr = a = dp->dir[DIR_Attr] & AM_MASK;
 8016a64:	f002 033f 	and.w	r3, r2, #63	; 0x3f
 8016a68:	71ab      	strb	r3, [r5, #6]
		if (c == DDEM || ((a & AM_VOL) && a != AM_LFN)) {	/* An entry without valid data */
 8016a6a:	d003      	beq.n	8016a74 <dir_find+0x74>
 8016a6c:	0710      	lsls	r0, r2, #28
 8016a6e:	d511      	bpl.n	8016a94 <dir_find+0x94>
 8016a70:	2b0f      	cmp	r3, #15
 8016a72:	d039      	beq.n	8016ae8 <dir_find+0xe8>
				ord = 0xFF; dp->blk_ofs = 0xFFFFFFFF;	/* Reset LFN sequence */
 8016a74:	f04f 33ff 	mov.w	r3, #4294967295
 8016a78:	632b      	str	r3, [r5, #48]	; 0x30
 8016a7a:	f04f 0aff 	mov.w	sl, #255	; 0xff
		res = dir_next(dp, 0);	/* Next entry */
 8016a7e:	2100      	movs	r1, #0
 8016a80:	4628      	mov	r0, r5
 8016a82:	f7ff fddd 	bl	8016640 <dir_next>
	} while (res == FR_OK);
 8016a86:	2800      	cmp	r0, #0
 8016a88:	d0cd      	beq.n	8016a26 <dir_find+0x26>
}
 8016a8a:	b005      	add	sp, #20
 8016a8c:	ecbd 8b02 	vpop	{d8}
 8016a90:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			if (a == AM_LFN) {			/* An LFN entry is found */
 8016a94:	2b0f      	cmp	r3, #15
 8016a96:	d027      	beq.n	8016ae8 <dir_find+0xe8>
				if (!ord && sum == sum_sfn(dp->dir)) break;	/* LFN matched? */
 8016a98:	f1ba 0f00 	cmp.w	sl, #0
 8016a9c:	d078      	beq.n	8016b90 <dir_find+0x190>
				if (!(dp->fn[NSFLAG] & NS_LOSS) && !mem_cmp(dp->dir, dp->fn, 11)) break;	/* SFN matched? */
 8016a9e:	f895 002f 	ldrb.w	r0, [r5, #47]	; 0x2f
 8016aa2:	f010 0001 	ands.w	r0, r0, #1
 8016aa6:	d1e5      	bne.n	8016a74 <dir_find+0x74>
		r = *d++ - *s++;
 8016aa8:	4626      	mov	r6, r4
 8016aaa:	f895 2024 	ldrb.w	r2, [r5, #36]	; 0x24
 8016aae:	f816 3b0b 	ldrb.w	r3, [r6], #11
 8016ab2:	3401      	adds	r4, #1
 8016ab4:	1a9b      	subs	r3, r3, r2
 8016ab6:	f105 0225 	add.w	r2, r5, #37	; 0x25
	} while (--cnt && r == 0);
 8016aba:	2b00      	cmp	r3, #0
 8016abc:	d1da      	bne.n	8016a74 <dir_find+0x74>
		r = *d++ - *s++;
 8016abe:	f814 3b01 	ldrb.w	r3, [r4], #1
 8016ac2:	f812 1b01 	ldrb.w	r1, [r2], #1
	} while (--cnt && r == 0);
 8016ac6:	42b4      	cmp	r4, r6
		r = *d++ - *s++;
 8016ac8:	eba3 0301 	sub.w	r3, r3, r1
	} while (--cnt && r == 0);
 8016acc:	d1f5      	bne.n	8016aba <dir_find+0xba>
				if (!(dp->fn[NSFLAG] & NS_LOSS) && !mem_cmp(dp->dir, dp->fn, 11)) break;	/* SFN matched? */
 8016ace:	2b00      	cmp	r3, #0
 8016ad0:	d1d0      	bne.n	8016a74 <dir_find+0x74>
 8016ad2:	e7ba      	b.n	8016a4a <dir_find+0x4a>
 8016ad4:	4638      	mov	r0, r7
 8016ad6:	f7ff f95b 	bl	8015d90 <sync_window.part.0>
		if (res == FR_OK) {			/* Fill sector window with new data */
 8016ada:	2800      	cmp	r0, #0
 8016adc:	d0aa      	beq.n	8016a34 <dir_find+0x34>
}
 8016ade:	b005      	add	sp, #20
 8016ae0:	ecbd 8b02 	vpop	{d8}
 8016ae4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
				if (!(dp->fn[NSFLAG] & NS_NOLFN)) {
 8016ae8:	f895 302f 	ldrb.w	r3, [r5, #47]	; 0x2f
 8016aec:	0659      	lsls	r1, r3, #25
 8016aee:	d4c6      	bmi.n	8016a7e <dir_find+0x7e>
					if (c & LLEF) {		/* Is it start of LFN sequence? */
 8016af0:	0672      	lsls	r2, r6, #25
 8016af2:	d548      	bpl.n	8016b86 <dir_find+0x186>
						dp->blk_ofs = dp->dptr;	/* Start offset of LFN */
 8016af4:	696b      	ldr	r3, [r5, #20]
						sum = dp->dir[LDIR_Chksum];
 8016af6:	f894 900d 	ldrb.w	r9, [r4, #13]
						dp->blk_ofs = dp->dptr;	/* Start offset of LFN */
 8016afa:	632b      	str	r3, [r5, #48]	; 0x30
						c &= (BYTE)~LLEF; ord = c;	/* LFN start order */
 8016afc:	f006 06bf 	and.w	r6, r6, #191	; 0xbf
					ord = (c == ord && sum == dp->dir[LDIR_Chksum] && cmp_lfn(fs->lfnbuf, dp->dir)) ? ord - 1 : 0xFF;
 8016b00:	7b63      	ldrb	r3, [r4, #13]
 8016b02:	454b      	cmp	r3, r9
 8016b04:	d141      	bne.n	8016b8a <dir_find+0x18a>
	if (ld_word(dir + LDIR_FstClusLO) != 0) return 0;	/* Check LDIR_FstClusLO */
 8016b06:	8b63      	ldrh	r3, [r4, #26]
 8016b08:	2b00      	cmp	r3, #0
 8016b0a:	d13e      	bne.n	8016b8a <dir_find+0x18a>
	i = ((dir[LDIR_Ord] & 0x3F) - 1) * 13;	/* Offset in the LFN buffer */
 8016b0c:	f894 a000 	ldrb.w	sl, [r4]
					ord = (c == ord && sum == dp->dir[LDIR_Chksum] && cmp_lfn(fs->lfnbuf, dp->dir)) ? ord - 1 : 0xFF;
 8016b10:	68fa      	ldr	r2, [r7, #12]
 8016b12:	f8df b0d4 	ldr.w	fp, [pc, #212]	; 8016be8 <dir_find+0x1e8>
			if (uc != 0xFFFF) return 0;		/* Check filler */
 8016b16:	9602      	str	r6, [sp, #8]
	i = ((dir[LDIR_Ord] & 0x3F) - 1) * 13;	/* Offset in the LFN buffer */
 8016b18:	f00a 0a3f 	and.w	sl, sl, #63	; 0x3f
 8016b1c:	f10a 3aff 	add.w	sl, sl, #4294967295
 8016b20:	eb0a 034a 	add.w	r3, sl, sl, lsl #1
 8016b24:	eb0a 0a83 	add.w	sl, sl, r3, lsl #2
 8016b28:	2301      	movs	r3, #1
			if (uc != 0xFFFF) return 0;		/* Check filler */
 8016b2a:	9501      	str	r5, [sp, #4]
 8016b2c:	ee08 8a10 	vmov	s16, r8
					ord = (c == ord && sum == dp->dir[LDIR_Chksum] && cmp_lfn(fs->lfnbuf, dp->dir)) ? ord - 1 : 0xFF;
 8016b30:	9203      	str	r2, [sp, #12]
	for (wc = 1, s = 0; s < 13; s++) {		/* Process all characters in the entry */
 8016b32:	f10b 010c 	add.w	r1, fp, #12
 8016b36:	4618      	mov	r0, r3
			if (uc != 0xFFFF) return 0;		/* Check filler */
 8016b38:	4616      	mov	r6, r2
 8016b3a:	4625      	mov	r5, r4
 8016b3c:	e014      	b.n	8016b68 <dir_find+0x168>
			if (i >= _MAX_LFN || ff_wtoupper(uc) != ff_wtoupper(lfnbuf[i++])) {	/* Compare it */
 8016b3e:	f1ba 0ffe 	cmp.w	sl, #254	; 0xfe
 8016b42:	4620      	mov	r0, r4
 8016b44:	d819      	bhi.n	8016b7a <dir_find+0x17a>
 8016b46:	f001 fe49 	bl	80187dc <ff_wtoupper>
 8016b4a:	4603      	mov	r3, r0
 8016b4c:	f836 001a 	ldrh.w	r0, [r6, sl, lsl #1]
 8016b50:	469a      	mov	sl, r3
 8016b52:	f001 fe43 	bl	80187dc <ff_wtoupper>
 8016b56:	4582      	cmp	sl, r0
 8016b58:	d10f      	bne.n	8016b7a <dir_find+0x17a>
 8016b5a:	4922      	ldr	r1, [pc, #136]	; (8016be4 <dir_find+0x1e4>)
 8016b5c:	4620      	mov	r0, r4
 8016b5e:	46c2      	mov	sl, r8
	for (wc = 1, s = 0; s < 13; s++) {		/* Process all characters in the entry */
 8016b60:	458b      	cmp	fp, r1
 8016b62:	d02b      	beq.n	8016bbc <dir_find+0x1bc>
		uc = ld_word(dir + LfnOfs[s]);		/* Pick an LFN character */
 8016b64:	f81b 3f01 	ldrb.w	r3, [fp, #1]!
			if (uc != 0xFFFF) return 0;		/* Check filler */
 8016b68:	5aec      	ldrh	r4, [r5, r3]
			if (i >= _MAX_LFN || ff_wtoupper(uc) != ff_wtoupper(lfnbuf[i++])) {	/* Compare it */
 8016b6a:	f10a 0801 	add.w	r8, sl, #1
		if (wc) {
 8016b6e:	2800      	cmp	r0, #0
 8016b70:	d1e5      	bne.n	8016b3e <dir_find+0x13e>
			if (uc != 0xFFFF) return 0;		/* Check filler */
 8016b72:	f64f 73ff 	movw	r3, #65535	; 0xffff
 8016b76:	429c      	cmp	r4, r3
 8016b78:	d0f2      	beq.n	8016b60 <dir_find+0x160>
					ord = (c == ord && sum == dp->dir[LDIR_Chksum] && cmp_lfn(fs->lfnbuf, dp->dir)) ? ord - 1 : 0xFF;
 8016b7a:	9d01      	ldr	r5, [sp, #4]
 8016b7c:	ee18 8a10 	vmov	r8, s16
 8016b80:	f04f 0aff 	mov.w	sl, #255	; 0xff
 8016b84:	e77b      	b.n	8016a7e <dir_find+0x7e>
 8016b86:	45b2      	cmp	sl, r6
 8016b88:	d0ba      	beq.n	8016b00 <dir_find+0x100>
 8016b8a:	f04f 0aff 	mov.w	sl, #255	; 0xff
 8016b8e:	e776      	b.n	8016a7e <dir_find+0x7e>
 8016b90:	f104 000b 	add.w	r0, r4, #11
				if (!ord && sum == sum_sfn(dp->dir)) break;	/* LFN matched? */
 8016b94:	4622      	mov	r2, r4
		sum = (sum >> 1) + (sum << 7) + *dir++;
 8016b96:	f812 1b01 	ldrb.w	r1, [r2], #1
 8016b9a:	ea4f 13ca 	mov.w	r3, sl, lsl #7
 8016b9e:	ea43 0a5a 	orr.w	sl, r3, sl, lsr #1
 8016ba2:	fa51 fa8a 	uxtab	sl, r1, sl
	} while (--n);
 8016ba6:	4282      	cmp	r2, r0
		sum = (sum >> 1) + (sum << 7) + *dir++;
 8016ba8:	fa5f fa8a 	uxtb.w	sl, sl
	} while (--n);
 8016bac:	d1f3      	bne.n	8016b96 <dir_find+0x196>
				if (!ord && sum == sum_sfn(dp->dir)) break;	/* LFN matched? */
 8016bae:	45d1      	cmp	r9, sl
 8016bb0:	f47f af75 	bne.w	8016a9e <dir_find+0x9e>
 8016bb4:	2000      	movs	r0, #0
 8016bb6:	e748      	b.n	8016a4a <dir_find+0x4a>
		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
 8016bb8:	2004      	movs	r0, #4
 8016bba:	e746      	b.n	8016a4a <dir_find+0x4a>
	if ((dir[LDIR_Ord] & LLEF) && wc && lfnbuf[i]) return 0;	/* Last segment matched but different length */
 8016bbc:	462c      	mov	r4, r5
 8016bbe:	ee18 8a10 	vmov	r8, s16
 8016bc2:	7823      	ldrb	r3, [r4, #0]
 8016bc4:	065b      	lsls	r3, r3, #25
 8016bc6:	e9dd 5601 	ldrd	r5, r6, [sp, #4]
 8016bca:	d505      	bpl.n	8016bd8 <dir_find+0x1d8>
 8016bcc:	b120      	cbz	r0, 8016bd8 <dir_find+0x1d8>
 8016bce:	9b03      	ldr	r3, [sp, #12]
 8016bd0:	f833 301a 	ldrh.w	r3, [r3, sl, lsl #1]
 8016bd4:	2b00      	cmp	r3, #0
 8016bd6:	d1d8      	bne.n	8016b8a <dir_find+0x18a>
					ord = (c == ord && sum == dp->dir[LDIR_Chksum] && cmp_lfn(fs->lfnbuf, dp->dir)) ? ord - 1 : 0xFF;
 8016bd8:	f106 3aff 	add.w	sl, r6, #4294967295
 8016bdc:	fa5f fa8a 	uxtb.w	sl, sl
 8016be0:	e74d      	b.n	8016a7e <dir_find+0x7e>
 8016be2:	bf00      	nop
 8016be4:	0802d350 	.word	0x0802d350
 8016be8:	0802d344 	.word	0x0802d344

08016bec <follow_path>:
{
 8016bec:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	FATFS *fs = obj->fs;
 8016bf0:	6803      	ldr	r3, [r0, #0]
{
 8016bf2:	b083      	sub	sp, #12
 8016bf4:	4607      	mov	r7, r0
	FATFS *fs = obj->fs;
 8016bf6:	461a      	mov	r2, r3
		while (*path == '/' || *path == '\\') path++;	/* Strip heading separator */
 8016bf8:	460e      	mov	r6, r1
 8016bfa:	f811 3b01 	ldrb.w	r3, [r1], #1
 8016bfe:	2b2f      	cmp	r3, #47	; 0x2f
 8016c00:	d0fa      	beq.n	8016bf8 <follow_path+0xc>
 8016c02:	2b5c      	cmp	r3, #92	; 0x5c
 8016c04:	d0f8      	beq.n	8016bf8 <follow_path+0xc>
		obj->sclust = 0;					/* Start from root directory */
 8016c06:	2100      	movs	r1, #0
 8016c08:	60b9      	str	r1, [r7, #8]
	if ((UINT)*path < ' ') {				/* Null path name is the origin directory itself */
 8016c0a:	7833      	ldrb	r3, [r6, #0]
 8016c0c:	2b1f      	cmp	r3, #31
 8016c0e:	f240 811f 	bls.w	8016e50 <follow_path+0x264>
 8016c12:	4690      	mov	r8, r2
		if (w < ' ') break;				/* Break if end of the path name */
 8016c14:	2b1f      	cmp	r3, #31
	p = *path; lfn = dp->obj.fs->lfnbuf; si = di = 0;
 8016c16:	f8d2 900c 	ldr.w	r9, [r2, #12]
		w = p[si++];					/* Get a character */
 8016c1a:	b298      	uxth	r0, r3
		if (w < ' ') break;				/* Break if end of the path name */
 8016c1c:	d941      	bls.n	8016ca2 <follow_path+0xb6>
 8016c1e:	f1a9 0502 	sub.w	r5, r9, #2
 8016c22:	46b3      	mov	fp, r6
 8016c24:	46aa      	mov	sl, r5
		w = p[si++];					/* Get a character */
 8016c26:	2401      	movs	r4, #1
 8016c28:	e009      	b.n	8016c3e <follow_path+0x52>
		lfn[di++] = w;					/* Store the Unicode character */
 8016c2a:	f82a 0f02 	strh.w	r0, [sl, #2]!
		w = p[si++];					/* Get a character */
 8016c2e:	f81b 0f01 	ldrb.w	r0, [fp, #1]!
		if (w < ' ') break;				/* Break if end of the path name */
 8016c32:	281f      	cmp	r0, #31
		w = p[si++];					/* Get a character */
 8016c34:	f104 0301 	add.w	r3, r4, #1
		if (w < ' ') break;				/* Break if end of the path name */
 8016c38:	f240 80e7 	bls.w	8016e0a <follow_path+0x21e>
		w = p[si++];					/* Get a character */
 8016c3c:	461c      	mov	r4, r3
		if (w == '/' || w == '\\') {	/* Break if a separator is found */
 8016c3e:	282f      	cmp	r0, #47	; 0x2f
 8016c40:	f104 33ff 	add.w	r3, r4, #4294967295
 8016c44:	d017      	beq.n	8016c76 <follow_path+0x8a>
 8016c46:	285c      	cmp	r0, #92	; 0x5c
 8016c48:	d015      	beq.n	8016c76 <follow_path+0x8a>
		if (di >= _MAX_LFN) return FR_INVALID_NAME;	/* Reject too long name */
 8016c4a:	f5b4 7f80 	cmp.w	r4, #256	; 0x100
 8016c4e:	d00e      	beq.n	8016c6e <follow_path+0x82>
		w = ff_convert(w, 1);			/* Convert ANSI/OEM to Unicode */
 8016c50:	2101      	movs	r1, #1
 8016c52:	f001 fda3 	bl	801879c <ff_convert>
		if (!w) return FR_INVALID_NAME;	/* Reject invalid code */
 8016c56:	b150      	cbz	r0, 8016c6e <follow_path+0x82>
		if (w < 0x80 && chk_chr("\"*:<>\?|\x7F", w)) return FR_INVALID_NAME;	/* Reject illegal characters for LFN */
 8016c58:	287f      	cmp	r0, #127	; 0x7f
 8016c5a:	d8e6      	bhi.n	8016c2a <follow_path+0x3e>
 8016c5c:	4a91      	ldr	r2, [pc, #580]	; (8016ea4 <follow_path+0x2b8>)
	while (*str && *str != chr) str++;
 8016c5e:	2322      	movs	r3, #34	; 0x22
 8016c60:	e003      	b.n	8016c6a <follow_path+0x7e>
 8016c62:	f812 3f01 	ldrb.w	r3, [r2, #1]!
 8016c66:	2b00      	cmp	r3, #0
 8016c68:	d0df      	beq.n	8016c2a <follow_path+0x3e>
 8016c6a:	4298      	cmp	r0, r3
 8016c6c:	d1f9      	bne.n	8016c62 <follow_path+0x76>
	if (di == 0) return FR_INVALID_NAME;	/* Reject nul name */
 8016c6e:	2006      	movs	r0, #6
}
 8016c70:	b003      	add	sp, #12
 8016c72:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8016c76:	4434      	add	r4, r6
			while (p[si] == '/' || p[si] == '\\') si++;	/* Skip duplicated separator if exist */
 8016c78:	7822      	ldrb	r2, [r4, #0]
 8016c7a:	2a2f      	cmp	r2, #47	; 0x2f
 8016c7c:	4626      	mov	r6, r4
 8016c7e:	f104 0401 	add.w	r4, r4, #1
 8016c82:	d0f9      	beq.n	8016c78 <follow_path+0x8c>
 8016c84:	2a5c      	cmp	r2, #92	; 0x5c
 8016c86:	d0f7      	beq.n	8016c78 <follow_path+0x8c>
	while (di) {						/* Snip off trailing spaces and dots if exist */
 8016c88:	b15b      	cbz	r3, 8016ca2 <follow_path+0xb6>
	cf = (w < ' ') ? NS_LAST : 0;		/* Set last segment flag if end of the path */
 8016c8a:	f04f 0a00 	mov.w	sl, #0
 8016c8e:	eb09 0143 	add.w	r1, r9, r3, lsl #1
		w = lfn[di - 1];
 8016c92:	f831 2d02 	ldrh.w	r2, [r1, #-2]!
		if (w != ' ' && w != '.') break;
 8016c96:	2a20      	cmp	r2, #32
 8016c98:	d001      	beq.n	8016c9e <follow_path+0xb2>
 8016c9a:	2a2e      	cmp	r2, #46	; 0x2e
 8016c9c:	d105      	bne.n	8016caa <follow_path+0xbe>
	while (di) {						/* Snip off trailing spaces and dots if exist */
 8016c9e:	3b01      	subs	r3, #1
 8016ca0:	d1f7      	bne.n	8016c92 <follow_path+0xa6>
	lfn[di] = 0;						/* LFN is created */
 8016ca2:	2300      	movs	r3, #0
 8016ca4:	f8a9 3000 	strh.w	r3, [r9]
 8016ca8:	e7e1      	b.n	8016c6e <follow_path+0x82>
		*d++ = (BYTE)val;
 8016caa:	f04f 3220 	mov.w	r2, #538976288	; 0x20202020
	lfn[di] = 0;						/* LFN is created */
 8016cae:	2400      	movs	r4, #0
 8016cb0:	f829 4013 	strh.w	r4, [r9, r3, lsl #1]
		*d++ = (BYTE)val;
 8016cb4:	62ba      	str	r2, [r7, #40]	; 0x28
 8016cb6:	627a      	str	r2, [r7, #36]	; 0x24
 8016cb8:	f8c7 202b 	str.w	r2, [r7, #43]	; 0x2b
 8016cbc:	e000      	b.n	8016cc0 <follow_path+0xd4>
	for (si = 0; lfn[si] == ' ' || lfn[si] == '.'; si++) ;	/* Strip leading spaces and dots */
 8016cbe:	3401      	adds	r4, #1
 8016cc0:	f835 0f02 	ldrh.w	r0, [r5, #2]!
 8016cc4:	2820      	cmp	r0, #32
 8016cc6:	d0fa      	beq.n	8016cbe <follow_path+0xd2>
 8016cc8:	282e      	cmp	r0, #46	; 0x2e
 8016cca:	d0f8      	beq.n	8016cbe <follow_path+0xd2>
	if (si) cf |= NS_LOSS | NS_LFN;
 8016ccc:	b10c      	cbz	r4, 8016cd2 <follow_path+0xe6>
 8016cce:	f04a 0a03 	orr.w	sl, sl, #3
	while (di && lfn[di - 1] != '.') di--;	/* Find extension (di<=si: no extension) */
 8016cd2:	eb09 0243 	add.w	r2, r9, r3, lsl #1
 8016cd6:	f832 1d02 	ldrh.w	r1, [r2, #-2]!
 8016cda:	292e      	cmp	r1, #46	; 0x2e
 8016cdc:	d001      	beq.n	8016ce2 <follow_path+0xf6>
 8016cde:	3b01      	subs	r3, #1
 8016ce0:	d1f9      	bne.n	8016cd6 <follow_path+0xea>
		w = lfn[si++];					/* Get an LFN character */
 8016ce2:	3401      	adds	r4, #1
		if (!w) break;					/* Break on end of the LFN */
 8016ce4:	2800      	cmp	r0, #0
 8016ce6:	d043      	beq.n	8016d70 <follow_path+0x184>
 8016ce8:	2500      	movs	r5, #0
 8016cea:	f04f 0b08 	mov.w	fp, #8
 8016cee:	462a      	mov	r2, r5
		if (w == ' ' || (w == '.' && si != di)) {	/* Remove spaces and dots */
 8016cf0:	2820      	cmp	r0, #32
 8016cf2:	d05e      	beq.n	8016db2 <follow_path+0x1c6>
 8016cf4:	282e      	cmp	r0, #46	; 0x2e
 8016cf6:	d060      	beq.n	8016dba <follow_path+0x1ce>
		if (i >= ni || si == di) {		/* Extension or end of SFN */
 8016cf8:	4593      	cmp	fp, r2
 8016cfa:	d96a      	bls.n	8016dd2 <follow_path+0x1e6>
 8016cfc:	42a3      	cmp	r3, r4
 8016cfe:	d05e      	beq.n	8016dbe <follow_path+0x1d2>
		if (w >= 0x80) {				/* Non ASCII character */
 8016d00:	287f      	cmp	r0, #127	; 0x7f
 8016d02:	f200 8090 	bhi.w	8016e26 <follow_path+0x23a>
	while (*str && *str != chr) str++;
 8016d06:	f8df c1a4 	ldr.w	ip, [pc, #420]	; 8016eac <follow_path+0x2c0>
 8016d0a:	212b      	movs	r1, #43	; 0x2b
 8016d0c:	e004      	b.n	8016d18 <follow_path+0x12c>
 8016d0e:	f81c 1f01 	ldrb.w	r1, [ip, #1]!
 8016d12:	2900      	cmp	r1, #0
 8016d14:	f000 80a5 	beq.w	8016e62 <follow_path+0x276>
 8016d18:	4281      	cmp	r1, r0
 8016d1a:	d1f8      	bne.n	8016d0e <follow_path+0x122>
				w = '_'; cf |= NS_LOSS | NS_LFN;/* Lossy conversion */
 8016d1c:	f04a 0a03 	orr.w	sl, sl, #3
 8016d20:	205f      	movs	r0, #95	; 0x5f
		dp->fn[i++] = (BYTE)w;
 8016d22:	4621      	mov	r1, r4
 8016d24:	18bc      	adds	r4, r7, r2
 8016d26:	3201      	adds	r2, #1
 8016d28:	f884 0024 	strb.w	r0, [r4, #36]	; 0x24
		w = lfn[si++];					/* Get an LFN character */
 8016d2c:	f839 0011 	ldrh.w	r0, [r9, r1, lsl #1]
 8016d30:	1c4c      	adds	r4, r1, #1
		if (!w) break;					/* Break on end of the LFN */
 8016d32:	2800      	cmp	r0, #0
 8016d34:	d1dc      	bne.n	8016cf0 <follow_path+0x104>
	if (dp->fn[0] == DDEM) dp->fn[0] = RDDEM;	/* If the first character collides with DDEM, replace it with RDDEM */
 8016d36:	f897 3024 	ldrb.w	r3, [r7, #36]	; 0x24
 8016d3a:	2be5      	cmp	r3, #229	; 0xe5
 8016d3c:	bf04      	itt	eq
 8016d3e:	2305      	moveq	r3, #5
 8016d40:	f887 3024 	strbeq.w	r3, [r7, #36]	; 0x24
	if (ni == 8) b <<= 2;
 8016d44:	f1bb 0f08 	cmp.w	fp, #8
 8016d48:	d064      	beq.n	8016e14 <follow_path+0x228>
	if ((b & 0x0C) == 0x0C || (b & 0x03) == 0x03) cf |= NS_LFN;	/* Create LFN entry when there are composite capitals */
 8016d4a:	f005 030c 	and.w	r3, r5, #12
 8016d4e:	2b0c      	cmp	r3, #12
 8016d50:	d048      	beq.n	8016de4 <follow_path+0x1f8>
 8016d52:	f005 0503 	and.w	r5, r5, #3
 8016d56:	2d03      	cmp	r5, #3
 8016d58:	d044      	beq.n	8016de4 <follow_path+0x1f8>
	if (!(cf & NS_LFN)) {						/* When LFN is in 8.3 format without extended character, NT flags are created */
 8016d5a:	f01a 0f02 	tst.w	sl, #2
 8016d5e:	d107      	bne.n	8016d70 <follow_path+0x184>
		if ((b & 0x03) == 0x01) cf |= NS_EXT;	/* NT flag (Extension has only small capital) */
 8016d60:	2d01      	cmp	r5, #1
 8016d62:	bf08      	it	eq
 8016d64:	f04a 0a10 	orreq.w	sl, sl, #16
		if ((b & 0x0C) == 0x04) cf |= NS_BODY;	/* NT flag (Filename has only small capital) */
 8016d68:	2b04      	cmp	r3, #4
 8016d6a:	bf08      	it	eq
 8016d6c:	f04a 0a08 	orreq.w	sl, sl, #8
	dp->fn[NSFLAG] = cf;	/* SFN is created */
 8016d70:	f887 a02f 	strb.w	sl, [r7, #47]	; 0x2f
			res = dir_find(dp);				/* Find an object with the segment name */
 8016d74:	4638      	mov	r0, r7
 8016d76:	f7ff fe43 	bl	8016a00 <dir_find>
			ns = dp->fn[NSFLAG];
 8016d7a:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
			if (res != FR_OK) {				/* Failed to find the object */
 8016d7e:	2800      	cmp	r0, #0
 8016d80:	d13b      	bne.n	8016dfa <follow_path+0x20e>
			if (ns & NS_LAST) break;			/* Last segment matched. Function completed. */
 8016d82:	075a      	lsls	r2, r3, #29
 8016d84:	f53f af74 	bmi.w	8016c70 <follow_path+0x84>
			if (!(obj->attr & AM_DIR)) {		/* It is not a sub-directory and cannot follow */
 8016d88:	79bb      	ldrb	r3, [r7, #6]
 8016d8a:	06db      	lsls	r3, r3, #27
 8016d8c:	d57a      	bpl.n	8016e84 <follow_path+0x298>
				obj->sclust = ld_clust(fs, fs->win + dp->dptr % SS(fs));	/* Open next directory */
 8016d8e:	697a      	ldr	r2, [r7, #20]
	if (fs->fs_type == FS_FAT32) {
 8016d90:	f898 1000 	ldrb.w	r1, [r8]
				obj->sclust = ld_clust(fs, fs->win + dp->dptr % SS(fs));	/* Open next directory */
 8016d94:	f3c2 020b 	ubfx	r2, r2, #0, #12
 8016d98:	f108 0334 	add.w	r3, r8, #52	; 0x34
 8016d9c:	4413      	add	r3, r2
	if (fs->fs_type == FS_FAT32) {
 8016d9e:	2903      	cmp	r1, #3
	cl = ld_word(dir + DIR_FstClusLO);
 8016da0:	8b5a      	ldrh	r2, [r3, #26]
		cl |= (DWORD)ld_word(dir + DIR_FstClusHI) << 16;
 8016da2:	bf04      	itt	eq
 8016da4:	8a9b      	ldrheq	r3, [r3, #20]
 8016da6:	ea42 4203 	orreq.w	r2, r2, r3, lsl #16
				obj->sclust = ld_clust(fs, fs->win + dp->dptr % SS(fs));	/* Open next directory */
 8016daa:	60ba      	str	r2, [r7, #8]
		w = p[si++];					/* Get a character */
 8016dac:	7833      	ldrb	r3, [r6, #0]
	p = *path; lfn = dp->obj.fs->lfnbuf; si = di = 0;
 8016dae:	683a      	ldr	r2, [r7, #0]
			res = create_name(dp, &path);	/* Get a segment name of the path */
 8016db0:	e730      	b.n	8016c14 <follow_path+0x28>
			cf |= NS_LOSS | NS_LFN; continue;
 8016db2:	f04a 0a03 	orr.w	sl, sl, #3
 8016db6:	4621      	mov	r1, r4
 8016db8:	e7b8      	b.n	8016d2c <follow_path+0x140>
		if (w == ' ' || (w == '.' && si != di)) {	/* Remove spaces and dots */
 8016dba:	42a3      	cmp	r3, r4
 8016dbc:	d1f9      	bne.n	8016db2 <follow_path+0x1c6>
			if (ni == 11) {				/* Long extension */
 8016dbe:	f1bb 0f0b 	cmp.w	fp, #11
 8016dc2:	d063      	beq.n	8016e8c <follow_path+0x2a0>
			b <<= 2; continue;
 8016dc4:	00ad      	lsls	r5, r5, #2
 8016dc6:	b2ed      	uxtb	r5, r5
 8016dc8:	4619      	mov	r1, r3
			si = di; i = 8; ni = 11;	/* Enter extension section */
 8016dca:	f04f 0b0b 	mov.w	fp, #11
 8016dce:	2208      	movs	r2, #8
			b <<= 2; continue;
 8016dd0:	e7ac      	b.n	8016d2c <follow_path+0x140>
			if (ni == 11) {				/* Long extension */
 8016dd2:	f1bb 0f0b 	cmp.w	fp, #11
 8016dd6:	d059      	beq.n	8016e8c <follow_path+0x2a0>
			if (si != di) cf |= NS_LOSS | NS_LFN;	/* Out of 8.3 format */
 8016dd8:	42a3      	cmp	r3, r4
 8016dda:	d0f3      	beq.n	8016dc4 <follow_path+0x1d8>
 8016ddc:	f04a 0a03 	orr.w	sl, sl, #3
			if (si > di) break;			/* No extension */
 8016de0:	d3a9      	bcc.n	8016d36 <follow_path+0x14a>
 8016de2:	e7ef      	b.n	8016dc4 <follow_path+0x1d8>
	if ((b & 0x0C) == 0x0C || (b & 0x03) == 0x03) cf |= NS_LFN;	/* Create LFN entry when there are composite capitals */
 8016de4:	f04a 0a02 	orr.w	sl, sl, #2
	dp->fn[NSFLAG] = cf;	/* SFN is created */
 8016de8:	f887 a02f 	strb.w	sl, [r7, #47]	; 0x2f
			res = dir_find(dp);				/* Find an object with the segment name */
 8016dec:	4638      	mov	r0, r7
 8016dee:	f7ff fe07 	bl	8016a00 <dir_find>
			ns = dp->fn[NSFLAG];
 8016df2:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
			if (res != FR_OK) {				/* Failed to find the object */
 8016df6:	2800      	cmp	r0, #0
 8016df8:	d0c3      	beq.n	8016d82 <follow_path+0x196>
				if (res == FR_NO_FILE) {	/* Object is not found */
 8016dfa:	2804      	cmp	r0, #4
 8016dfc:	f47f af38 	bne.w	8016c70 <follow_path+0x84>
						if (!(ns & NS_LAST)) res = FR_NO_PATH;	/* Adjust error code if not last segment */
 8016e00:	f013 0f04 	tst.w	r3, #4
 8016e04:	bf08      	it	eq
 8016e06:	2005      	moveq	r0, #5
 8016e08:	e732      	b.n	8016c70 <follow_path+0x84>
	*path = &p[si];						/* Return pointer to the next segment */
 8016e0a:	441e      	add	r6, r3
	cf = (w < ' ') ? NS_LAST : 0;		/* Set last segment flag if end of the path */
 8016e0c:	f04f 0a04 	mov.w	sl, #4
	*path = &p[si];						/* Return pointer to the next segment */
 8016e10:	4623      	mov	r3, r4
 8016e12:	e73c      	b.n	8016c8e <follow_path+0xa2>
	if (ni == 8) b <<= 2;
 8016e14:	00ab      	lsls	r3, r5, #2
 8016e16:	f003 030c 	and.w	r3, r3, #12
	if ((b & 0x0C) == 0x0C || (b & 0x03) == 0x03) cf |= NS_LFN;	/* Create LFN entry when there are composite capitals */
 8016e1a:	2b0c      	cmp	r3, #12
 8016e1c:	d0e2      	beq.n	8016de4 <follow_path+0x1f8>
	if (!(cf & NS_LFN)) {						/* When LFN is in 8.3 format without extended character, NT flags are created */
 8016e1e:	f01a 0f02 	tst.w	sl, #2
 8016e22:	d0a1      	beq.n	8016d68 <follow_path+0x17c>
 8016e24:	e7a4      	b.n	8016d70 <follow_path+0x184>
			w = ff_convert(w, 0);		/* Unicode -> OEM code */
 8016e26:	2100      	movs	r1, #0
 8016e28:	e9cd 3200 	strd	r3, r2, [sp]
 8016e2c:	f001 fcb6 	bl	801879c <ff_convert>
			if (w) w = ExCvt[w - 0x80];	/* Convert extended character to upper (SBCS) */
 8016e30:	e9dd 3200 	ldrd	r3, r2, [sp]
 8016e34:	b148      	cbz	r0, 8016e4a <follow_path+0x25e>
 8016e36:	491c      	ldr	r1, [pc, #112]	; (8016ea8 <follow_path+0x2bc>)
 8016e38:	4408      	add	r0, r1
			cf |= NS_LFN;				/* Force create LFN entry */
 8016e3a:	f04a 0a02 	orr.w	sl, sl, #2
			if (w) w = ExCvt[w - 0x80];	/* Convert extended character to upper (SBCS) */
 8016e3e:	f810 0c70 	ldrb.w	r0, [r0, #-112]
			if (!w || chk_chr("+,;=[]", w)) {	/* Replace illegal characters for SFN */
 8016e42:	2800      	cmp	r0, #0
 8016e44:	f43f af6a 	beq.w	8016d1c <follow_path+0x130>
 8016e48:	e75d      	b.n	8016d06 <follow_path+0x11a>
			cf |= NS_LFN;				/* Force create LFN entry */
 8016e4a:	f04a 0a02 	orr.w	sl, sl, #2
			if (!w || chk_chr("+,;=[]", w)) {	/* Replace illegal characters for SFN */
 8016e4e:	e765      	b.n	8016d1c <follow_path+0x130>
		dp->fn[NSFLAG] = NS_NONAME;
 8016e50:	2380      	movs	r3, #128	; 0x80
		res = dir_sdi(dp, 0);
 8016e52:	4638      	mov	r0, r7
		dp->fn[NSFLAG] = NS_NONAME;
 8016e54:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
}
 8016e58:	b003      	add	sp, #12
 8016e5a:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
		res = dir_sdi(dp, 0);
 8016e5e:	f7ff bd35 	b.w	80168cc <dir_sdi>
				if (IsUpper(w)) {		/* ASCII large capital */
 8016e62:	f1a0 0141 	sub.w	r1, r0, #65	; 0x41
 8016e66:	2919      	cmp	r1, #25
 8016e68:	d803      	bhi.n	8016e72 <follow_path+0x286>
					b |= 2;
 8016e6a:	f045 0502 	orr.w	r5, r5, #2
		dp->fn[i++] = (BYTE)w;
 8016e6e:	b2c0      	uxtb	r0, r0
 8016e70:	e757      	b.n	8016d22 <follow_path+0x136>
					if (IsLower(w)) {	/* ASCII small capital */
 8016e72:	f1a0 0161 	sub.w	r1, r0, #97	; 0x61
 8016e76:	2919      	cmp	r1, #25
						b |= 1; w -= 0x20;
 8016e78:	bf9c      	itt	ls
 8016e7a:	3820      	subls	r0, #32
 8016e7c:	f045 0501 	orrls.w	r5, r5, #1
		dp->fn[i++] = (BYTE)w;
 8016e80:	b2c0      	uxtb	r0, r0
 8016e82:	e74e      	b.n	8016d22 <follow_path+0x136>
						if (!(ns & NS_LAST)) res = FR_NO_PATH;	/* Adjust error code if not last segment */
 8016e84:	2005      	movs	r0, #5
}
 8016e86:	b003      	add	sp, #12
 8016e88:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	if (dp->fn[0] == DDEM) dp->fn[0] = RDDEM;	/* If the first character collides with DDEM, replace it with RDDEM */
 8016e8c:	f897 3024 	ldrb.w	r3, [r7, #36]	; 0x24
 8016e90:	2be5      	cmp	r3, #229	; 0xe5
				cf |= NS_LOSS | NS_LFN; break;
 8016e92:	f04a 0a03 	orr.w	sl, sl, #3
	if (dp->fn[0] == DDEM) dp->fn[0] = RDDEM;	/* If the first character collides with DDEM, replace it with RDDEM */
 8016e96:	f47f af58 	bne.w	8016d4a <follow_path+0x15e>
 8016e9a:	2305      	movs	r3, #5
 8016e9c:	f887 3024 	strb.w	r3, [r7, #36]	; 0x24
	if (ni == 8) b <<= 2;
 8016ea0:	e753      	b.n	8016d4a <follow_path+0x15e>
 8016ea2:	bf00      	nop
 8016ea4:	080417e8 	.word	0x080417e8
 8016ea8:	0802d344 	.word	0x0802d344
 8016eac:	080417f4 	.word	0x080417f4

08016eb0 <dir_register>:
{
 8016eb0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8016eb4:	ed2d 8b02 	vpush	{d8}
	if (dp->fn[NSFLAG] & (NS_DOT | NS_NONAME)) return FR_INVALID_NAME;	/* Check name validity */
 8016eb8:	f890 302f 	ldrb.w	r3, [r0, #47]	; 0x2f
{
 8016ebc:	b08b      	sub	sp, #44	; 0x2c
	if (dp->fn[NSFLAG] & (NS_DOT | NS_NONAME)) return FR_INVALID_NAME;	/* Check name validity */
 8016ebe:	f013 02a0 	ands.w	r2, r3, #160	; 0xa0
 8016ec2:	9301      	str	r3, [sp, #4]
 8016ec4:	f040 8130 	bne.w	8017128 <dir_register+0x278>
	FATFS *fs = dp->obj.fs;
 8016ec8:	f8d0 a000 	ldr.w	sl, [r0]
	for (nlen = 0; fs->lfnbuf[nlen]; nlen++) ;	/* Get lfn length */
 8016ecc:	f8da e00c 	ldr.w	lr, [sl, #12]
 8016ed0:	f8be 3000 	ldrh.w	r3, [lr]
 8016ed4:	4606      	mov	r6, r0
 8016ed6:	2b00      	cmp	r3, #0
 8016ed8:	f000 81be 	beq.w	8017258 <dir_register+0x3a8>
 8016edc:	4693      	mov	fp, r2
 8016ede:	4672      	mov	r2, lr
 8016ee0:	f832 3f02 	ldrh.w	r3, [r2, #2]!
 8016ee4:	f10b 0b01 	add.w	fp, fp, #1
 8016ee8:	2b00      	cmp	r3, #0
 8016eea:	d1f9      	bne.n	8016ee0 <dir_register+0x30>
	mem_cpy(sn, dp->fn, 12);
 8016eec:	f106 0324 	add.w	r3, r6, #36	; 0x24
			*d++ = *s++;
 8016ef0:	e893 0007 	ldmia.w	r3, {r0, r1, r2}
 8016ef4:	f10d 081c 	add.w	r8, sp, #28
 8016ef8:	e888 0007 	stmia.w	r8, {r0, r1, r2}
	if (sn[NSFLAG] & NS_LOSS) {			/* When LFN is out of 8.3 format, generate a numbered name */
 8016efc:	9a01      	ldr	r2, [sp, #4]
			*d++ = *s++;
 8016efe:	9303      	str	r3, [sp, #12]
	if (sn[NSFLAG] & NS_LOSS) {			/* When LFN is out of 8.3 format, generate a numbered name */
 8016f00:	07d4      	lsls	r4, r2, #31
 8016f02:	d570      	bpl.n	8016fe6 <dir_register+0x136>
		dp->fn[NSFLAG] = NS_NOLFN;		/* Find only SFN */
 8016f04:	2240      	movs	r2, #64	; 0x40
 8016f06:	f06f 0523 	mvn.w	r5, #35	; 0x23
 8016f0a:	f886 202f 	strb.w	r2, [r6, #47]	; 0x2f
		for (n = 1; n < 100; n++) {
 8016f0e:	1bad      	subs	r5, r5, r6
 8016f10:	46b1      	mov	r9, r6
				if (sr & 0x10000) sr ^= 0x11021;
 8016f12:	4cad      	ldr	r4, [pc, #692]	; (80171c8 <dir_register+0x318>)
 8016f14:	9e03      	ldr	r6, [sp, #12]
		for (n = 1; n < 100; n++) {
 8016f16:	2701      	movs	r7, #1
 8016f18:	4673      	mov	r3, lr
			*d++ = *s++;
 8016f1a:	e898 0007 	ldmia.w	r8, {r0, r1, r2}
 8016f1e:	46b4      	mov	ip, r6
 8016f20:	e8ac 0003 	stmia.w	ip!, {r0, r1}
 8016f24:	f82c 2b02 	strh.w	r2, [ip], #2
	if (seq > 5) {	/* In case of many collisions, generate a hash number instead of sequential number */
 8016f28:	2f05      	cmp	r7, #5
			*d++ = *s++;
 8016f2a:	ea4f 4212 	mov.w	r2, r2, lsr #16
 8016f2e:	f88c 2000 	strb.w	r2, [ip]
	if (seq > 5) {	/* In case of many collisions, generate a hash number instead of sequential number */
 8016f32:	d974      	bls.n	801701e <dir_register+0x16e>
		while (*lfn) {	/* Create a CRC */
 8016f34:	881a      	ldrh	r2, [r3, #0]
 8016f36:	2a00      	cmp	r2, #0
 8016f38:	d071      	beq.n	801701e <dir_register+0x16e>
 8016f3a:	469c      	mov	ip, r3
 8016f3c:	463b      	mov	r3, r7
 8016f3e:	2110      	movs	r1, #16
				sr = (sr << 1) + (wc & 1);
 8016f40:	f002 0001 	and.w	r0, r2, #1
 8016f44:	eb00 0343 	add.w	r3, r0, r3, lsl #1
				if (sr & 0x10000) sr ^= 0x11021;
 8016f48:	03d8      	lsls	r0, r3, #15
 8016f4a:	bf48      	it	mi
 8016f4c:	4063      	eormi	r3, r4
			for (i = 0; i < 16; i++) {
 8016f4e:	3901      	subs	r1, #1
				wc >>= 1;
 8016f50:	ea4f 0252 	mov.w	r2, r2, lsr #1
			for (i = 0; i < 16; i++) {
 8016f54:	d1f4      	bne.n	8016f40 <dir_register+0x90>
		while (*lfn) {	/* Create a CRC */
 8016f56:	f83c 2f02 	ldrh.w	r2, [ip, #2]!
 8016f5a:	2a00      	cmp	r2, #0
 8016f5c:	d1ef      	bne.n	8016f3e <dir_register+0x8e>
 8016f5e:	f10d 0c1b 	add.w	ip, sp, #27
 8016f62:	2207      	movs	r2, #7
 8016f64:	e000      	b.n	8016f68 <dir_register+0xb8>
		seq /= 16;
 8016f66:	4673      	mov	r3, lr
		c = (BYTE)((seq % 16) + '0');
 8016f68:	f003 000f 	and.w	r0, r3, #15
 8016f6c:	f100 0130 	add.w	r1, r0, #48	; 0x30
		if (c > '9') c += 7;
 8016f70:	2939      	cmp	r1, #57	; 0x39
 8016f72:	bf88      	it	hi
 8016f74:	f100 0137 	addhi.w	r1, r0, #55	; 0x37
	} while (seq);
 8016f78:	2b0f      	cmp	r3, #15
		ns[i--] = c;
 8016f7a:	f80c 1901 	strb.w	r1, [ip], #-1
		seq /= 16;
 8016f7e:	ea4f 1e13 	mov.w	lr, r3, lsr #4
		ns[i--] = c;
 8016f82:	f102 32ff 	add.w	r2, r2, #4294967295
	} while (seq);
 8016f86:	d8ee      	bhi.n	8016f66 <dir_register+0xb6>
	ns[i] = '~';
 8016f88:	f102 0328 	add.w	r3, r2, #40	; 0x28
 8016f8c:	446b      	add	r3, sp
 8016f8e:	217e      	movs	r1, #126	; 0x7e
 8016f90:	f803 1c14 	strb.w	r1, [r3, #-20]
	for (j = 0; j < i && dst[j] != ' '; j++) {
 8016f94:	2a00      	cmp	r2, #0
 8016f96:	d044      	beq.n	8017022 <dir_register+0x172>
 8016f98:	f109 0123 	add.w	r1, r9, #35	; 0x23
 8016f9c:	2300      	movs	r3, #0
 8016f9e:	e002      	b.n	8016fa6 <dir_register+0xf6>
 8016fa0:	3301      	adds	r3, #1
 8016fa2:	429a      	cmp	r2, r3
 8016fa4:	d003      	beq.n	8016fae <dir_register+0xfe>
 8016fa6:	f811 0f01 	ldrb.w	r0, [r1, #1]!
 8016faa:	2820      	cmp	r0, #32
 8016fac:	d1f8      	bne.n	8016fa0 <dir_register+0xf0>
 8016fae:	3324      	adds	r3, #36	; 0x24
 8016fb0:	444b      	add	r3, r9
		dst[j++] = (i < 8) ? ns[i++] : ' ';
 8016fb2:	f102 0128 	add.w	r1, r2, #40	; 0x28
 8016fb6:	4469      	add	r1, sp
 8016fb8:	2a07      	cmp	r2, #7
 8016fba:	bf94      	ite	ls
 8016fbc:	f811 1c14 	ldrbls.w	r1, [r1, #-20]
 8016fc0:	2120      	movhi	r1, #32
 8016fc2:	f803 1b01 	strb.w	r1, [r3], #1
	} while (j < 8);
 8016fc6:	eb05 0103 	add.w	r1, r5, r3
		dst[j++] = (i < 8) ? ns[i++] : ' ';
 8016fca:	bf98      	it	ls
 8016fcc:	3201      	addls	r2, #1
	} while (j < 8);
 8016fce:	2907      	cmp	r1, #7
 8016fd0:	d9ef      	bls.n	8016fb2 <dir_register+0x102>
			res = dir_find(dp);				/* Check if the name collides with existing SFN */
 8016fd2:	4648      	mov	r0, r9
 8016fd4:	f7ff fd14 	bl	8016a00 <dir_find>
			if (res != FR_OK) break;
 8016fd8:	bb28      	cbnz	r0, 8017026 <dir_register+0x176>
		for (n = 1; n < 100; n++) {
 8016fda:	3701      	adds	r7, #1
 8016fdc:	2f64      	cmp	r7, #100	; 0x64
 8016fde:	d016      	beq.n	801700e <dir_register+0x15e>
			gen_numname(dp->fn, sn, fs->lfnbuf, n);	/* Generate a numbered name */
 8016fe0:	f8da 300c 	ldr.w	r3, [sl, #12]
 8016fe4:	e799      	b.n	8016f1a <dir_register+0x6a>
	nent = (sn[NSFLAG] & NS_LFN) ? (nlen + 12) / 13 + 1 : 1;	/* Number of entries to allocate */
 8016fe6:	9b01      	ldr	r3, [sp, #4]
 8016fe8:	079b      	lsls	r3, r3, #30
 8016fea:	4654      	mov	r4, sl
 8016fec:	d526      	bpl.n	801703c <dir_register+0x18c>
 8016fee:	4b77      	ldr	r3, [pc, #476]	; (80171cc <dir_register+0x31c>)
 8016ff0:	f10b 070c 	add.w	r7, fp, #12
	res = dir_sdi(dp, 0);
 8016ff4:	2100      	movs	r1, #0
 8016ff6:	4630      	mov	r0, r6
	nent = (sn[NSFLAG] & NS_LFN) ? (nlen + 12) / 13 + 1 : 1;	/* Number of entries to allocate */
 8016ff8:	fba3 3707 	umull	r3, r7, r3, r7
	res = dir_sdi(dp, 0);
 8016ffc:	f7ff fc66 	bl	80168cc <dir_sdi>
	nent = (sn[NSFLAG] & NS_LFN) ? (nlen + 12) / 13 + 1 : 1;	/* Number of entries to allocate */
 8017000:	08bf      	lsrs	r7, r7, #2
 8017002:	3701      	adds	r7, #1
	if (res == FR_OK) {
 8017004:	4681      	mov	r9, r0
 8017006:	b308      	cbz	r0, 801704c <dir_register+0x19c>
	if (res == FR_NO_FILE) res = FR_DENIED;	/* No directory entry to allocate */
 8017008:	2804      	cmp	r0, #4
 801700a:	f040 812c 	bne.w	8017266 <dir_register+0x3b6>
		if (n == 100) return FR_DENIED;		/* Abort if too many collisions */
 801700e:	f04f 0907 	mov.w	r9, #7
}
 8017012:	4648      	mov	r0, r9
 8017014:	b00b      	add	sp, #44	; 0x2c
 8017016:	ecbd 8b02 	vpop	{d8}
 801701a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		while (*lfn) {	/* Create a CRC */
 801701e:	463b      	mov	r3, r7
 8017020:	e79d      	b.n	8016f5e <dir_register+0xae>
	for (j = 0; j < i && dst[j] != ' '; j++) {
 8017022:	4613      	mov	r3, r2
 8017024:	e7c3      	b.n	8016fae <dir_register+0xfe>
		if (res != FR_NO_FILE) return res;	/* Abort if the result is other than 'not collided' */
 8017026:	2804      	cmp	r0, #4
 8017028:	464e      	mov	r6, r9
 801702a:	4681      	mov	r9, r0
 801702c:	d1f1      	bne.n	8017012 <dir_register+0x162>
		dp->fn[NSFLAG] = sn[NSFLAG];
 801702e:	9b01      	ldr	r3, [sp, #4]
 8017030:	f886 302f 	strb.w	r3, [r6, #47]	; 0x2f
	nent = (sn[NSFLAG] & NS_LFN) ? (nlen + 12) / 13 + 1 : 1;	/* Number of entries to allocate */
 8017034:	9b01      	ldr	r3, [sp, #4]
	FATFS *fs = dp->obj.fs;
 8017036:	6834      	ldr	r4, [r6, #0]
	nent = (sn[NSFLAG] & NS_LFN) ? (nlen + 12) / 13 + 1 : 1;	/* Number of entries to allocate */
 8017038:	079b      	lsls	r3, r3, #30
 801703a:	d4d8      	bmi.n	8016fee <dir_register+0x13e>
	res = dir_sdi(dp, 0);
 801703c:	2100      	movs	r1, #0
 801703e:	4630      	mov	r0, r6
 8017040:	f7ff fc44 	bl	80168cc <dir_sdi>
	nent = (sn[NSFLAG] & NS_LFN) ? (nlen + 12) / 13 + 1 : 1;	/* Number of entries to allocate */
 8017044:	2701      	movs	r7, #1
	if (res == FR_OK) {
 8017046:	4681      	mov	r9, r0
 8017048:	2800      	cmp	r0, #0
 801704a:	d1dd      	bne.n	8017008 <dir_register+0x158>
		n = 0;
 801704c:	4605      	mov	r5, r0
			if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK) {
 801704e:	f104 0834 	add.w	r8, r4, #52	; 0x34
			res = move_window(fs, dp->sect);
 8017052:	f8d6 b01c 	ldr.w	fp, [r6, #28]
	if (sector != fs->winsect) {	/* Window offset changed? */
 8017056:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8017058:	459b      	cmp	fp, r3
 801705a:	d016      	beq.n	801708a <dir_register+0x1da>
	if (fs->wflag) {	/* Write back the sector if it is dirty */
 801705c:	78e3      	ldrb	r3, [r4, #3]
 801705e:	2b00      	cmp	r3, #0
 8017060:	d15c      	bne.n	801711c <dir_register+0x26c>
			if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK) {
 8017062:	7860      	ldrb	r0, [r4, #1]
 8017064:	2301      	movs	r3, #1
 8017066:	465a      	mov	r2, fp
 8017068:	4641      	mov	r1, r8
 801706a:	f7fe fd13 	bl	8015a94 <disk_read>
 801706e:	b150      	cbz	r0, 8017086 <dir_register+0x1d6>
				res = FR_DISK_ERR;
 8017070:	f04f 0901 	mov.w	r9, #1
			fs->winsect = sector;
 8017074:	f04f 33ff 	mov.w	r3, #4294967295
}
 8017078:	4648      	mov	r0, r9
			fs->winsect = sector;
 801707a:	6323      	str	r3, [r4, #48]	; 0x30
}
 801707c:	b00b      	add	sp, #44	; 0x2c
 801707e:	ecbd 8b02 	vpop	{d8}
 8017082:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			fs->winsect = sector;
 8017086:	f8c4 b030 	str.w	fp, [r4, #48]	; 0x30
			if (dp->dir[DIR_Name] == DDEM || dp->dir[DIR_Name] == 0) {
 801708a:	6a33      	ldr	r3, [r6, #32]
 801708c:	781b      	ldrb	r3, [r3, #0]
 801708e:	2be5      	cmp	r3, #229	; 0xe5
 8017090:	d008      	beq.n	80170a4 <dir_register+0x1f4>
 8017092:	b13b      	cbz	r3, 80170a4 <dir_register+0x1f4>
				n = 0;					/* Not a blank entry. Restart to search */
 8017094:	2500      	movs	r5, #0
			res = dir_next(dp, 1);
 8017096:	2101      	movs	r1, #1
 8017098:	4630      	mov	r0, r6
 801709a:	f7ff fad1 	bl	8016640 <dir_next>
		} while (res == FR_OK);	/* Next entry with table stretch enabled */
 801709e:	2800      	cmp	r0, #0
 80170a0:	d0d7      	beq.n	8017052 <dir_register+0x1a2>
 80170a2:	e7b1      	b.n	8017008 <dir_register+0x158>
				if (++n == nent) break;	/* A block of contiguous free entries is found */
 80170a4:	3501      	adds	r5, #1
 80170a6:	42af      	cmp	r7, r5
 80170a8:	d1f5      	bne.n	8017096 <dir_register+0x1e6>
	if (res == FR_OK && --nent) {	/* Set LFN entry if needed */
 80170aa:	1e7b      	subs	r3, r7, #1
 80170ac:	9301      	str	r3, [sp, #4]
 80170ae:	d13e      	bne.n	801712e <dir_register+0x27e>
		res = move_window(fs, dp->sect);
 80170b0:	69f4      	ldr	r4, [r6, #28]
	if (sector != fs->winsect) {	/* Window offset changed? */
 80170b2:	f8da 3030 	ldr.w	r3, [sl, #48]	; 0x30
 80170b6:	429c      	cmp	r4, r3
 80170b8:	d011      	beq.n	80170de <dir_register+0x22e>
	if (fs->wflag) {	/* Write back the sector if it is dirty */
 80170ba:	f89a 3003 	ldrb.w	r3, [sl, #3]
 80170be:	2b00      	cmp	r3, #0
 80170c0:	f040 80d3 	bne.w	801726a <dir_register+0x3ba>
			if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK) {
 80170c4:	f89a 0001 	ldrb.w	r0, [sl, #1]
 80170c8:	2301      	movs	r3, #1
 80170ca:	4622      	mov	r2, r4
 80170cc:	f10a 0134 	add.w	r1, sl, #52	; 0x34
 80170d0:	f7fe fce0 	bl	8015a94 <disk_read>
 80170d4:	2800      	cmp	r0, #0
 80170d6:	f040 80b8 	bne.w	801724a <dir_register+0x39a>
			fs->winsect = sector;
 80170da:	f8ca 4030 	str.w	r4, [sl, #48]	; 0x30
		*d++ = (BYTE)val;
 80170de:	2220      	movs	r2, #32
 80170e0:	2100      	movs	r1, #0
 80170e2:	6a30      	ldr	r0, [r6, #32]
 80170e4:	f010 fa48 	bl	8027578 <memset>
void mem_cpy (void* dst, const void* src, UINT cnt) {
 80170e8:	6a33      	ldr	r3, [r6, #32]
 80170ea:	9a03      	ldr	r2, [sp, #12]
 80170ec:	3b01      	subs	r3, #1
 80170ee:	f106 012f 	add.w	r1, r6, #47	; 0x2f
			*d++ = *s++;
 80170f2:	f812 0b01 	ldrb.w	r0, [r2], #1
 80170f6:	f803 0f01 	strb.w	r0, [r3, #1]!
		} while (--cnt);
 80170fa:	4291      	cmp	r1, r2
 80170fc:	d1f9      	bne.n	80170f2 <dir_register+0x242>
			dp->dir[DIR_NTres] = dp->fn[NSFLAG] & (NS_BODY | NS_EXT);	/* Put NT flag */
 80170fe:	f896 302f 	ldrb.w	r3, [r6, #47]	; 0x2f
 8017102:	6a31      	ldr	r1, [r6, #32]
 8017104:	f003 0318 	and.w	r3, r3, #24
			fs->wflag = 1;
 8017108:	2201      	movs	r2, #1
}
 801710a:	4648      	mov	r0, r9
			dp->dir[DIR_NTres] = dp->fn[NSFLAG] & (NS_BODY | NS_EXT);	/* Put NT flag */
 801710c:	730b      	strb	r3, [r1, #12]
			fs->wflag = 1;
 801710e:	f88a 2003 	strb.w	r2, [sl, #3]
}
 8017112:	b00b      	add	sp, #44	; 0x2c
 8017114:	ecbd 8b02 	vpop	{d8}
 8017118:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 801711c:	4620      	mov	r0, r4
 801711e:	f7fe fe37 	bl	8015d90 <sync_window.part.0>
		if (res == FR_OK) {			/* Fill sector window with new data */
 8017122:	2800      	cmp	r0, #0
 8017124:	d09d      	beq.n	8017062 <dir_register+0x1b2>
 8017126:	e76f      	b.n	8017008 <dir_register+0x158>
	if (dp->fn[NSFLAG] & (NS_DOT | NS_NONAME)) return FR_INVALID_NAME;	/* Check name validity */
 8017128:	f04f 0906 	mov.w	r9, #6
 801712c:	e771      	b.n	8017012 <dir_register+0x162>
		res = dir_sdi(dp, dp->dptr - nent * SZDIRE);
 801712e:	6971      	ldr	r1, [r6, #20]
 8017130:	9b01      	ldr	r3, [sp, #4]
 8017132:	4630      	mov	r0, r6
 8017134:	eba1 1143 	sub.w	r1, r1, r3, lsl #5
 8017138:	f7ff fbc8 	bl	80168cc <dir_sdi>
		if (res == FR_OK) {
 801713c:	9002      	str	r0, [sp, #8]
 801713e:	2800      	cmp	r0, #0
 8017140:	f040 809b 	bne.w	801727a <dir_register+0x3ca>
 8017144:	9a03      	ldr	r2, [sp, #12]
 8017146:	f106 012f 	add.w	r1, r6, #47	; 0x2f
		sum = (sum >> 1) + (sum << 7) + *dir++;
 801714a:	01c3      	lsls	r3, r0, #7
 801714c:	ea43 0350 	orr.w	r3, r3, r0, lsr #1
 8017150:	f812 0b01 	ldrb.w	r0, [r2], #1
 8017154:	fa50 f383 	uxtab	r3, r0, r3
	} while (--n);
 8017158:	428a      	cmp	r2, r1
		sum = (sum >> 1) + (sum << 7) + *dir++;
 801715a:	b2d8      	uxtb	r0, r3
	} while (--n);
 801715c:	d1f5      	bne.n	801714a <dir_register+0x29a>
			if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK) {
 801715e:	f10a 0334 	add.w	r3, sl, #52	; 0x34
		st_word(dir + LfnOfs[s], wc);		/* Put it */
 8017162:	f8df b06c 	ldr.w	fp, [pc, #108]	; 80171d0 <dir_register+0x320>
 8017166:	9002      	str	r0, [sp, #8]
			if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK) {
 8017168:	ee08 3a10 	vmov	s16, r3
				res = move_window(fs, dp->sect);
 801716c:	69f4      	ldr	r4, [r6, #28]
	if (sector != fs->winsect) {	/* Window offset changed? */
 801716e:	f8da 3030 	ldr.w	r3, [sl, #48]	; 0x30
 8017172:	429c      	cmp	r4, r3
 8017174:	d00f      	beq.n	8017196 <dir_register+0x2e6>
	if (fs->wflag) {	/* Write back the sector if it is dirty */
 8017176:	f89a 3003 	ldrb.w	r3, [sl, #3]
 801717a:	2b00      	cmp	r3, #0
 801717c:	d16e      	bne.n	801725c <dir_register+0x3ac>
			if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK) {
 801717e:	f89a 0001 	ldrb.w	r0, [sl, #1]
 8017182:	ee18 1a10 	vmov	r1, s16
 8017186:	2301      	movs	r3, #1
 8017188:	4622      	mov	r2, r4
 801718a:	f7fe fc83 	bl	8015a94 <disk_read>
 801718e:	2800      	cmp	r0, #0
 8017190:	d15b      	bne.n	801724a <dir_register+0x39a>
			fs->winsect = sector;
 8017192:	f8ca 4030 	str.w	r4, [sl, #48]	; 0x30
				put_lfn(fs->lfnbuf, dp->dir, (BYTE)nent, sum);
 8017196:	f89d e004 	ldrb.w	lr, [sp, #4]
 801719a:	6a30      	ldr	r0, [r6, #32]
 801719c:	f8da 700c 	ldr.w	r7, [sl, #12]
	i = (ord - 1) * 13;				/* Get offset in the LFN working buffer */
 80171a0:	f10e 31ff 	add.w	r1, lr, #4294967295
	dir[LDIR_Attr] = AM_LFN;		/* Set attribute. LFN entry */
 80171a4:	240f      	movs	r4, #15
	dir[LDIR_Type] = 0;
 80171a6:	2200      	movs	r2, #0
	i = (ord - 1) * 13;				/* Get offset in the LFN working buffer */
 80171a8:	eb01 0341 	add.w	r3, r1, r1, lsl #1
	dir[LDIR_Attr] = AM_LFN;		/* Set attribute. LFN entry */
 80171ac:	72c4      	strb	r4, [r0, #11]
	dir[LDIR_Chksum] = sum;			/* Set checksum */
 80171ae:	9c02      	ldr	r4, [sp, #8]
 80171b0:	7344      	strb	r4, [r0, #13]
	i = (ord - 1) * 13;				/* Get offset in the LFN working buffer */
 80171b2:	eb01 0183 	add.w	r1, r1, r3, lsl #2
	dir[LDIR_Type] = 0;
 80171b6:	7302      	strb	r2, [r0, #12]
	s = wc = 0;
 80171b8:	4613      	mov	r3, r2
	*ptr++ = (BYTE)val; val >>= 8;
 80171ba:	7682      	strb	r2, [r0, #26]
	*ptr++ = (BYTE)val;
 80171bc:	76c2      	strb	r2, [r0, #27]
	i = (ord - 1) * 13;				/* Get offset in the LFN working buffer */
 80171be:	2401      	movs	r4, #1
		if (wc != 0xFFFF) wc = lfn[i++];	/* Get an effective character */
 80171c0:	f64f 7cff 	movw	ip, #65535	; 0xffff
	*ptr++ = (BYTE)val; val >>= 8;
 80171c4:	25ff      	movs	r5, #255	; 0xff
 80171c6:	e01e      	b.n	8017206 <dir_register+0x356>
 80171c8:	00011021 	.word	0x00011021
 80171cc:	4ec4ec4f 	.word	0x4ec4ec4f
 80171d0:	0802d344 	.word	0x0802d344
		if (wc != 0xFFFF) wc = lfn[i++];	/* Get an effective character */
 80171d4:	f837 3011 	ldrh.w	r3, [r7, r1, lsl #1]
	*ptr++ = (BYTE)val; val >>= 8;
 80171d8:	5503      	strb	r3, [r0, r4]
 80171da:	0a1c      	lsrs	r4, r3, #8
	*ptr++ = (BYTE)val;
 80171dc:	f888 4001 	strb.w	r4, [r8, #1]
		if (wc != 0xFFFF) wc = lfn[i++];	/* Get an effective character */
 80171e0:	3101      	adds	r1, #1
		if (wc == 0) wc = 0xFFFF;		/* Padding characters for left locations */
 80171e2:	b95b      	cbnz	r3, 80171fc <dir_register+0x34c>
	} while (++s < 13);
 80171e4:	3201      	adds	r2, #1
 80171e6:	2a0d      	cmp	r2, #13
 80171e8:	d01e      	beq.n	8017228 <dir_register+0x378>
		st_word(dir + LfnOfs[s], wc);		/* Put it */
 80171ea:	f81b 4002 	ldrb.w	r4, [fp, r2]
 80171ee:	eb00 0804 	add.w	r8, r0, r4
	*ptr++ = (BYTE)val; val >>= 8;
 80171f2:	5505      	strb	r5, [r0, r4]
		if (wc == 0) wc = 0xFFFF;		/* Padding characters for left locations */
 80171f4:	f64f 73ff 	movw	r3, #65535	; 0xffff
	*ptr++ = (BYTE)val;
 80171f8:	f888 5001 	strb.w	r5, [r8, #1]
	} while (++s < 13);
 80171fc:	3201      	adds	r2, #1
 80171fe:	2a0d      	cmp	r2, #13
 8017200:	d00b      	beq.n	801721a <dir_register+0x36a>
		st_word(dir + LfnOfs[s], wc);		/* Put it */
 8017202:	f81b 4002 	ldrb.w	r4, [fp, r2]
		if (wc != 0xFFFF) wc = lfn[i++];	/* Get an effective character */
 8017206:	4563      	cmp	r3, ip
		st_word(dir + LfnOfs[s], wc);		/* Put it */
 8017208:	eb00 0804 	add.w	r8, r0, r4
		if (wc != 0xFFFF) wc = lfn[i++];	/* Get an effective character */
 801720c:	d1e2      	bne.n	80171d4 <dir_register+0x324>
	*ptr++ = (BYTE)val; val >>= 8;
 801720e:	5505      	strb	r5, [r0, r4]
	} while (++s < 13);
 8017210:	3201      	adds	r2, #1
		st_word(dir + LfnOfs[s], wc);		/* Put it */
 8017212:	4404      	add	r4, r0
	} while (++s < 13);
 8017214:	2a0d      	cmp	r2, #13
	*ptr++ = (BYTE)val;
 8017216:	7065      	strb	r5, [r4, #1]
	} while (++s < 13);
 8017218:	d1f3      	bne.n	8017202 <dir_register+0x352>
	if (wc == 0xFFFF || !lfn[i]) ord |= LLEF;	/* Last LFN part is the start of LFN sequence */
 801721a:	f64f 72ff 	movw	r2, #65535	; 0xffff
 801721e:	4293      	cmp	r3, r2
 8017220:	d002      	beq.n	8017228 <dir_register+0x378>
 8017222:	f837 3011 	ldrh.w	r3, [r7, r1, lsl #1]
 8017226:	b90b      	cbnz	r3, 801722c <dir_register+0x37c>
 8017228:	f04e 0e40 	orr.w	lr, lr, #64	; 0x40
				fs->wflag = 1;
 801722c:	2301      	movs	r3, #1
	dir[LDIR_Ord] = ord;			/* Set the LFN order */
 801722e:	f880 e000 	strb.w	lr, [r0]
				res = dir_next(dp, 0);	/* Next entry */
 8017232:	2100      	movs	r1, #0
				fs->wflag = 1;
 8017234:	f88a 3003 	strb.w	r3, [sl, #3]
				res = dir_next(dp, 0);	/* Next entry */
 8017238:	4630      	mov	r0, r6
 801723a:	f7ff fa01 	bl	8016640 <dir_next>
			} while (res == FR_OK && --nent);
 801723e:	b990      	cbnz	r0, 8017266 <dir_register+0x3b6>
 8017240:	9b01      	ldr	r3, [sp, #4]
 8017242:	3b01      	subs	r3, #1
 8017244:	9301      	str	r3, [sp, #4]
 8017246:	d191      	bne.n	801716c <dir_register+0x2bc>
 8017248:	e732      	b.n	80170b0 <dir_register+0x200>
			fs->winsect = sector;
 801724a:	f04f 33ff 	mov.w	r3, #4294967295
 801724e:	f8ca 3030 	str.w	r3, [sl, #48]	; 0x30
				res = FR_DISK_ERR;
 8017252:	f04f 0901 	mov.w	r9, #1
 8017256:	e6dc      	b.n	8017012 <dir_register+0x162>
	for (nlen = 0; fs->lfnbuf[nlen]; nlen++) ;	/* Get lfn length */
 8017258:	469b      	mov	fp, r3
 801725a:	e647      	b.n	8016eec <dir_register+0x3c>
 801725c:	4650      	mov	r0, sl
 801725e:	f7fe fd97 	bl	8015d90 <sync_window.part.0>
		if (res == FR_OK) {			/* Fill sector window with new data */
 8017262:	2800      	cmp	r0, #0
 8017264:	d08b      	beq.n	801717e <dir_register+0x2ce>
	if (res == FR_NO_FILE) res = FR_DENIED;	/* No directory entry to allocate */
 8017266:	4681      	mov	r9, r0
 8017268:	e6d3      	b.n	8017012 <dir_register+0x162>
 801726a:	4650      	mov	r0, sl
 801726c:	f7fe fd90 	bl	8015d90 <sync_window.part.0>
		if (res == FR_OK) {			/* Fill sector window with new data */
 8017270:	2800      	cmp	r0, #0
 8017272:	f43f af27 	beq.w	80170c4 <dir_register+0x214>
	if (res == FR_NO_FILE) res = FR_DENIED;	/* No directory entry to allocate */
 8017276:	4681      	mov	r9, r0
 8017278:	e6cb      	b.n	8017012 <dir_register+0x162>
 801727a:	f8dd 9008 	ldr.w	r9, [sp, #8]
 801727e:	e6c8      	b.n	8017012 <dir_register+0x162>

08017280 <f_mount>:
FRESULT f_mount (
	FATFS* fs,			/* Pointer to the file system object (NULL:unmount)*/
	const TCHAR* path,	/* Logical drive number to be mounted/unmounted */
	BYTE opt			/* Mode option 0:Do not mount (delayed mount), 1:Mount immediately */
)
{
 8017280:	b510      	push	{r4, lr}
 8017282:	b084      	sub	sp, #16
 8017284:	4614      	mov	r4, r2
 8017286:	9001      	str	r0, [sp, #4]
	FRESULT res;
	const TCHAR *rp = path;


	/* Get logical drive number */
	vol = get_ldnumber(&rp);
 8017288:	a803      	add	r0, sp, #12
{
 801728a:	9100      	str	r1, [sp, #0]
	const TCHAR *rp = path;
 801728c:	9103      	str	r1, [sp, #12]
	vol = get_ldnumber(&rp);
 801728e:	f7fe fcd3 	bl	8015c38 <get_ldnumber>
	if (vol < 0) return FR_INVALID_DRIVE;
 8017292:	2800      	cmp	r0, #0
 8017294:	db22      	blt.n	80172dc <f_mount+0x5c>
	cfs = FatFs[vol];					/* Pointer to fs object */
 8017296:	4b15      	ldr	r3, [pc, #84]	; (80172ec <f_mount+0x6c>)
 8017298:	0081      	lsls	r1, r0, #2
 801729a:	eb03 0080 	add.w	r0, r3, r0, lsl #2
 801729e:	6a02      	ldr	r2, [r0, #32]

	if (cfs) {
 80172a0:	b15a      	cbz	r2, 80172ba <f_mount+0x3a>
		if (Files[i].fs == fs) Files[i].fs = 0;
 80172a2:	6818      	ldr	r0, [r3, #0]
 80172a4:	4282      	cmp	r2, r0
 80172a6:	bf04      	itt	eq
 80172a8:	2000      	moveq	r0, #0
 80172aa:	6018      	streq	r0, [r3, #0]
 80172ac:	6918      	ldr	r0, [r3, #16]
 80172ae:	4282      	cmp	r2, r0
 80172b0:	bf04      	itt	eq
 80172b2:	2000      	moveq	r0, #0
 80172b4:	6118      	streq	r0, [r3, #16]
		clear_lock(cfs);
#endif
#if _FS_REENTRANT						/* Discard sync object of the current volume */
		if (!ff_del_syncobj(cfs->sobj)) return FR_INT_ERR;
#endif
		cfs->fs_type = 0;				/* Clear old fs object */
 80172b6:	2000      	movs	r0, #0
 80172b8:	7010      	strb	r0, [r2, #0]
	}

	if (fs) {
 80172ba:	9a01      	ldr	r2, [sp, #4]
		fs->fs_type = 0;				/* Clear new fs object */
#if _FS_REENTRANT						/* Create sync object for the new volume */
		if (!ff_cre_syncobj((BYTE)vol, &fs->sobj)) return FR_INT_ERR;
#endif
	}
	FatFs[vol] = fs;					/* Register new fs object */
 80172bc:	440b      	add	r3, r1
	if (fs) {
 80172be:	b182      	cbz	r2, 80172e2 <f_mount+0x62>
		fs->fs_type = 0;				/* Clear new fs object */
 80172c0:	2000      	movs	r0, #0

	if (!fs || opt != 1) return FR_OK;	/* Do not mount now, it will be mounted later */
 80172c2:	2c01      	cmp	r4, #1
		fs->fs_type = 0;				/* Clear new fs object */
 80172c4:	7010      	strb	r0, [r2, #0]
	FatFs[vol] = fs;					/* Register new fs object */
 80172c6:	621a      	str	r2, [r3, #32]
	if (!fs || opt != 1) return FR_OK;	/* Do not mount now, it will be mounted later */
 80172c8:	d001      	beq.n	80172ce <f_mount+0x4e>

	res = find_volume(&path, &fs, 0);	/* Force mounted the volume */
	LEAVE_FF(fs, res);
}
 80172ca:	b004      	add	sp, #16
 80172cc:	bd10      	pop	{r4, pc}
	res = find_volume(&path, &fs, 0);	/* Force mounted the volume */
 80172ce:	4602      	mov	r2, r0
 80172d0:	a901      	add	r1, sp, #4
 80172d2:	4668      	mov	r0, sp
 80172d4:	f7fe fe40 	bl	8015f58 <find_volume>
}
 80172d8:	b004      	add	sp, #16
 80172da:	bd10      	pop	{r4, pc}
	if (vol < 0) return FR_INVALID_DRIVE;
 80172dc:	200b      	movs	r0, #11
}
 80172de:	b004      	add	sp, #16
 80172e0:	bd10      	pop	{r4, pc}
	if (!fs || opt != 1) return FR_OK;	/* Do not mount now, it will be mounted later */
 80172e2:	4610      	mov	r0, r2
	FatFs[vol] = fs;					/* Register new fs object */
 80172e4:	621a      	str	r2, [r3, #32]
}
 80172e6:	b004      	add	sp, #16
 80172e8:	bd10      	pop	{r4, pc}
 80172ea:	bf00      	nop
 80172ec:	20003310 	.word	0x20003310

080172f0 <f_open>:
FRESULT f_open (
	FIL* fp,			/* Pointer to the blank file object */
	const TCHAR* path,	/* Pointer to the file name */
	BYTE mode			/* Access mode and file open mode flags */
)
{
 80172f0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80172f4:	b091      	sub	sp, #68	; 0x44
 80172f6:	9101      	str	r1, [sp, #4]
	FSIZE_t ofs;
#endif
	DEF_NAMBUF


	if (!fp) return FR_INVALID_OBJECT;
 80172f8:	2800      	cmp	r0, #0
 80172fa:	d044      	beq.n	8017386 <f_open+0x96>

	/* Get logical drive */
	mode &= _FS_READONLY ? FA_READ : FA_READ | FA_WRITE | FA_CREATE_ALWAYS | FA_CREATE_NEW | FA_OPEN_ALWAYS | FA_OPEN_APPEND | FA_SEEKEND;
 80172fc:	f002 073f 	and.w	r7, r2, #63	; 0x3f
	res = find_volume(&path, &fs, mode);
 8017300:	4616      	mov	r6, r2
 8017302:	4604      	mov	r4, r0
 8017304:	463a      	mov	r2, r7
 8017306:	a902      	add	r1, sp, #8
 8017308:	a801      	add	r0, sp, #4
 801730a:	f7fe fe25 	bl	8015f58 <find_volume>
	if (res == FR_OK) {
 801730e:	4605      	mov	r5, r0
 8017310:	b128      	cbz	r0, 801731e <f_open+0x2e>
		}

		FREE_NAMBUF();
	}

	if (res != FR_OK) fp->obj.fs = 0;	/* Invalidate file object on error */
 8017312:	2300      	movs	r3, #0
 8017314:	6023      	str	r3, [r4, #0]

	LEAVE_FF(fs, res);
}
 8017316:	4628      	mov	r0, r5
 8017318:	b011      	add	sp, #68	; 0x44
 801731a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		dj.obj.fs = fs;
 801731e:	9b02      	ldr	r3, [sp, #8]
 8017320:	9303      	str	r3, [sp, #12]
		INIT_NAMBUF(fs);
 8017322:	f44f 7000 	mov.w	r0, #512	; 0x200
 8017326:	f001 fa35 	bl	8018794 <ff_memalloc>
 801732a:	4681      	mov	r9, r0
 801732c:	b380      	cbz	r0, 8017390 <f_open+0xa0>
 801732e:	9b02      	ldr	r3, [sp, #8]
		res = follow_path(&dj, path);	/* Follow the file path */
 8017330:	9901      	ldr	r1, [sp, #4]
		INIT_NAMBUF(fs);
 8017332:	60d8      	str	r0, [r3, #12]
		res = follow_path(&dj, path);	/* Follow the file path */
 8017334:	a803      	add	r0, sp, #12
 8017336:	f7ff fc59 	bl	8016bec <follow_path>
		if (res == FR_OK) {
 801733a:	4680      	mov	r8, r0
 801733c:	b9d8      	cbnz	r0, 8017376 <f_open+0x86>
			if (dj.fn[NSFLAG] & NS_NONAME) {	/* Origin directory itself? */
 801733e:	f99d 303b 	ldrsb.w	r3, [sp, #59]	; 0x3b
 8017342:	2b00      	cmp	r3, #0
 8017344:	db29      	blt.n	801739a <f_open+0xaa>
				res = chk_lock(&dj, (mode & ~FA_READ) ? 1 : 0);
 8017346:	f017 0f3e 	tst.w	r7, #62	; 0x3e
 801734a:	bf14      	ite	ne
 801734c:	2101      	movne	r1, #1
 801734e:	2100      	moveq	r1, #0
 8017350:	a803      	add	r0, sp, #12
 8017352:	f7fe fbc7 	bl	8015ae4 <chk_lock>
		if (mode & (FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW)) {
 8017356:	f016 0f1c 	tst.w	r6, #28
				res = chk_lock(&dj, (mode & ~FA_READ) ? 1 : 0);
 801735a:	4680      	mov	r8, r0
		if (mode & (FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW)) {
 801735c:	d020      	beq.n	80173a0 <f_open+0xb0>
			if (res != FR_OK) {					/* No file, create new */
 801735e:	bb78      	cbnz	r0, 80173c0 <f_open+0xd0>
				if (dj.obj.attr & (AM_RDO | AM_DIR)) {	/* Cannot overwrite it (R/O or DIR) */
 8017360:	f89d 3012 	ldrb.w	r3, [sp, #18]
 8017364:	f013 0f11 	tst.w	r3, #17
 8017368:	d114      	bne.n	8017394 <f_open+0xa4>
					if (mode & FA_CREATE_NEW) res = FR_EXIST;	/* Cannot create as new file */
 801736a:	0773      	lsls	r3, r6, #29
 801736c:	f140 80fc 	bpl.w	8017568 <f_open+0x278>
 8017370:	f04f 0808 	mov.w	r8, #8
 8017374:	e002      	b.n	801737c <f_open+0x8c>
		if (mode & (FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW)) {
 8017376:	f016 0f1c 	tst.w	r6, #28
 801737a:	d121      	bne.n	80173c0 <f_open+0xd0>
		FREE_NAMBUF();
 801737c:	4648      	mov	r0, r9
 801737e:	f001 fa0b 	bl	8018798 <ff_memfree>
 8017382:	4645      	mov	r5, r8
 8017384:	e7c5      	b.n	8017312 <f_open+0x22>
	if (!fp) return FR_INVALID_OBJECT;
 8017386:	2509      	movs	r5, #9
}
 8017388:	4628      	mov	r0, r5
 801738a:	b011      	add	sp, #68	; 0x44
 801738c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		INIT_NAMBUF(fs);
 8017390:	2511      	movs	r5, #17
 8017392:	e7c0      	b.n	8017316 <f_open+0x26>
					res = FR_DENIED;
 8017394:	f04f 0807 	mov.w	r8, #7
 8017398:	e7f0      	b.n	801737c <f_open+0x8c>
				res = FR_INVALID_NAME;
 801739a:	f04f 0806 	mov.w	r8, #6
 801739e:	e7ed      	b.n	801737c <f_open+0x8c>
			if (res == FR_OK) {					/* Following succeeded */
 80173a0:	2800      	cmp	r0, #0
 80173a2:	d1eb      	bne.n	801737c <f_open+0x8c>
				if (dj.obj.attr & AM_DIR) {		/* It is a directory */
 80173a4:	f89d 3012 	ldrb.w	r3, [sp, #18]
 80173a8:	06da      	lsls	r2, r3, #27
 80173aa:	f100 80e2 	bmi.w	8017572 <f_open+0x282>
					if ((mode & FA_WRITE) && (dj.obj.attr & AM_RDO)) { /* R/O violation */
 80173ae:	07b2      	lsls	r2, r6, #30
 80173b0:	d571      	bpl.n	8017496 <f_open+0x1a6>
 80173b2:	07de      	lsls	r6, r3, #31
 80173b4:	d56f      	bpl.n	8017496 <f_open+0x1a6>
		FREE_NAMBUF();
 80173b6:	4648      	mov	r0, r9
 80173b8:	f001 f9ee 	bl	8018798 <ff_memfree>
						res = FR_DENIED;
 80173bc:	2507      	movs	r5, #7
 80173be:	e7a8      	b.n	8017312 <f_open+0x22>
				if (res == FR_NO_FILE) {		/* There is no file to open, create a new entry */
 80173c0:	f1b8 0f04 	cmp.w	r8, #4
 80173c4:	d1da      	bne.n	801737c <f_open+0x8c>
	for (i = 0; i < _FS_LOCK && Files[i].fs; i++) ;
 80173c6:	4b89      	ldr	r3, [pc, #548]	; (80175ec <f_open+0x2fc>)
 80173c8:	681a      	ldr	r2, [r3, #0]
 80173ca:	b122      	cbz	r2, 80173d6 <f_open+0xe6>
 80173cc:	691b      	ldr	r3, [r3, #16]
					res = enq_lock() ? dir_register(&dj) : FR_TOO_MANY_OPEN_FILES;
 80173ce:	f04f 0812 	mov.w	r8, #18
	for (i = 0; i < _FS_LOCK && Files[i].fs; i++) ;
 80173d2:	2b00      	cmp	r3, #0
 80173d4:	d1d2      	bne.n	801737c <f_open+0x8c>
					res = enq_lock() ? dir_register(&dj) : FR_TOO_MANY_OPEN_FILES;
 80173d6:	a803      	add	r0, sp, #12
 80173d8:	f7ff fd6a 	bl	8016eb0 <dir_register>
				mode |= FA_CREATE_ALWAYS;		/* File is created */
 80173dc:	f047 0708 	orr.w	r7, r7, #8
			if (res == FR_OK && (mode & FA_CREATE_ALWAYS)) {	/* Truncate it if overwrite mode */
 80173e0:	4680      	mov	r8, r0
 80173e2:	2800      	cmp	r0, #0
 80173e4:	d1ca      	bne.n	801737c <f_open+0x8c>
				dw = GET_FATTIME();
 80173e6:	f007 fc5b 	bl	801eca0 <get_fattime>
					st_dword(dj.dir + DIR_CrtTime, dw);	/* Set created time */
 80173ea:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
	*ptr++ = (BYTE)val; val >>= 8;
 80173ec:	b2c6      	uxtb	r6, r0
	*ptr++ = (BYTE)val; val >>= 8;
 80173ee:	f3c0 2107 	ubfx	r1, r0, #8, #8
	*ptr++ = (BYTE)val; val >>= 8;
 80173f2:	f3c0 4207 	ubfx	r2, r0, #16, #8
	*ptr++ = (BYTE)val;
 80173f6:	0e00      	lsrs	r0, r0, #24
	*ptr++ = (BYTE)val; val >>= 8;
 80173f8:	739e      	strb	r6, [r3, #14]
	*ptr++ = (BYTE)val; val >>= 8;
 80173fa:	741a      	strb	r2, [r3, #16]
	*ptr++ = (BYTE)val; val >>= 8;
 80173fc:	73d9      	strb	r1, [r3, #15]
	*ptr++ = (BYTE)val;
 80173fe:	7458      	strb	r0, [r3, #17]
					st_dword(dj.dir + DIR_ModTime, dw);	/* Set modified time */
 8017400:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
	*ptr++ = (BYTE)val; val >>= 8;
 8017402:	759e      	strb	r6, [r3, #22]
	*ptr++ = (BYTE)val; val >>= 8;
 8017404:	761a      	strb	r2, [r3, #24]
	*ptr++ = (BYTE)val; val >>= 8;
 8017406:	75d9      	strb	r1, [r3, #23]
	*ptr++ = (BYTE)val;
 8017408:	7658      	strb	r0, [r3, #25]
					dj.dir[DIR_Attr] = AM_ARC;			/* Reset attribute */
 801740a:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
					cl = ld_clust(fs, dj.dir);			/* Get cluster chain */
 801740c:	9e02      	ldr	r6, [sp, #8]
					dj.dir[DIR_Attr] = AM_ARC;			/* Reset attribute */
 801740e:	2220      	movs	r2, #32
 8017410:	72da      	strb	r2, [r3, #11]
	if (fs->fs_type == FS_FAT32) {
 8017412:	7832      	ldrb	r2, [r6, #0]
					cl = ld_clust(fs, dj.dir);			/* Get cluster chain */
 8017414:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
	if (fs->fs_type == FS_FAT32) {
 8017416:	2a03      	cmp	r2, #3
	cl = ld_word(dir + DIR_FstClusLO);
 8017418:	f8b3 a01a 	ldrh.w	sl, [r3, #26]
		cl |= (DWORD)ld_word(dir + DIR_FstClusHI) << 16;
 801741c:	bf04      	itt	eq
 801741e:	8a9a      	ldrheq	r2, [r3, #20]
 8017420:	ea4a 4a02 	orreq.w	sl, sl, r2, lsl #16
	*ptr++ = (BYTE)val; val >>= 8;
 8017424:	2200      	movs	r2, #0
 8017426:	769a      	strb	r2, [r3, #26]
	*ptr++ = (BYTE)val;
 8017428:	76da      	strb	r2, [r3, #27]
	if (fs->fs_type == FS_FAT32) {
 801742a:	7831      	ldrb	r1, [r6, #0]
 801742c:	2903      	cmp	r1, #3
 801742e:	d101      	bne.n	8017434 <f_open+0x144>
	*ptr++ = (BYTE)val; val >>= 8;
 8017430:	751a      	strb	r2, [r3, #20]
	*ptr++ = (BYTE)val;
 8017432:	755a      	strb	r2, [r3, #21]
					st_dword(dj.dir + DIR_FileSize, 0);
 8017434:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
	*ptr++ = (BYTE)val; val >>= 8;
 8017436:	2200      	movs	r2, #0
 8017438:	771a      	strb	r2, [r3, #28]
	*ptr++ = (BYTE)val; val >>= 8;
 801743a:	775a      	strb	r2, [r3, #29]
	*ptr++ = (BYTE)val; val >>= 8;
 801743c:	779a      	strb	r2, [r3, #30]
	*ptr++ = (BYTE)val;
 801743e:	77da      	strb	r2, [r3, #31]
					fs->wflag = 1;
 8017440:	2301      	movs	r3, #1
 8017442:	70f3      	strb	r3, [r6, #3]
					if (cl) {							/* Remove the cluster chain if exist */
 8017444:	f1ba 0f00 	cmp.w	sl, #0
 8017448:	d026      	beq.n	8017498 <f_open+0x1a8>
						res = remove_chain(&dj.obj, cl, 0);
 801744a:	4651      	mov	r1, sl
 801744c:	a803      	add	r0, sp, #12
						dw = fs->winsect;
 801744e:	f8d6 b030 	ldr.w	fp, [r6, #48]	; 0x30
						res = remove_chain(&dj.obj, cl, 0);
 8017452:	f7ff f845 	bl	80164e0 <remove_chain>
						if (res == FR_OK) {
 8017456:	4680      	mov	r8, r0
 8017458:	2800      	cmp	r0, #0
 801745a:	d18f      	bne.n	801737c <f_open+0x8c>
							res = move_window(fs, dw);
 801745c:	9e02      	ldr	r6, [sp, #8]
	if (sector != fs->winsect) {	/* Window offset changed? */
 801745e:	6b33      	ldr	r3, [r6, #48]	; 0x30
 8017460:	459b      	cmp	fp, r3
 8017462:	f000 80ac 	beq.w	80175be <f_open+0x2ce>
	if (fs->wflag) {	/* Write back the sector if it is dirty */
 8017466:	78f3      	ldrb	r3, [r6, #3]
 8017468:	2b00      	cmp	r3, #0
 801746a:	f040 80b3 	bne.w	80175d4 <f_open+0x2e4>
			if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK) {
 801746e:	7870      	ldrb	r0, [r6, #1]
 8017470:	2301      	movs	r3, #1
 8017472:	465a      	mov	r2, fp
 8017474:	f106 0134 	add.w	r1, r6, #52	; 0x34
 8017478:	f7fe fb0c 	bl	8015a94 <disk_read>
 801747c:	2800      	cmp	r0, #0
 801747e:	f000 80a2 	beq.w	80175c6 <f_open+0x2d6>
			fs->winsect = sector;
 8017482:	f04f 33ff 	mov.w	r3, #4294967295
							fs->last_clst = cl - 1;		/* Reuse the cluster hole */
 8017486:	eb0a 0203 	add.w	r2, sl, r3
			fs->winsect = sector;
 801748a:	6333      	str	r3, [r6, #48]	; 0x30
							fs->last_clst = cl - 1;		/* Reuse the cluster hole */
 801748c:	9b02      	ldr	r3, [sp, #8]
				res = FR_DISK_ERR;
 801748e:	f04f 0801 	mov.w	r8, #1
							fs->last_clst = cl - 1;		/* Reuse the cluster hole */
 8017492:	611a      	str	r2, [r3, #16]
		if (res == FR_OK) {
 8017494:	e772      	b.n	801737c <f_open+0x8c>
			fp->dir_sect = fs->winsect;			/* Pointer to the directory entry */
 8017496:	9e02      	ldr	r6, [sp, #8]
			if (mode & FA_CREATE_ALWAYS)		/* Set file change flag if created or overwritten */
 8017498:	0738      	lsls	r0, r7, #28
 801749a:	d55f      	bpl.n	801755c <f_open+0x26c>
				mode |= FA_MODIFIED;
 801749c:	f047 0740 	orr.w	r7, r7, #64	; 0x40
 80174a0:	2101      	movs	r1, #1
			fp->dir_sect = fs->winsect;			/* Pointer to the directory entry */
 80174a2:	6b33      	ldr	r3, [r6, #48]	; 0x30
 80174a4:	6263      	str	r3, [r4, #36]	; 0x24
			fp->dir_ptr = dj.dir;
 80174a6:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 80174a8:	62a3      	str	r3, [r4, #40]	; 0x28
			fp->obj.lockid = inc_lock(&dj, (mode & ~FA_READ) ? 1 : 0);
 80174aa:	a803      	add	r0, sp, #12
 80174ac:	f7fe fb6c 	bl	8015b88 <inc_lock>
 80174b0:	6120      	str	r0, [r4, #16]
			if (!fp->obj.lockid) res = FR_INT_ERR;
 80174b2:	b920      	cbnz	r0, 80174be <f_open+0x1ce>
		FREE_NAMBUF();
 80174b4:	4648      	mov	r0, r9
 80174b6:	f001 f96f 	bl	8018798 <ff_memfree>
			if (!fp->obj.lockid) res = FR_INT_ERR;
 80174ba:	2502      	movs	r5, #2
 80174bc:	e729      	b.n	8017312 <f_open+0x22>
				fp->obj.sclust = ld_clust(fs, dj.dir);					/* Get object allocation info */
 80174be:	f8dd a008 	ldr.w	sl, [sp, #8]
 80174c2:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
	if (fs->fs_type == FS_FAT32) {
 80174c4:	f89a 2000 	ldrb.w	r2, [sl]
	cl = ld_word(dir + DIR_FstClusLO);
 80174c8:	8b5e      	ldrh	r6, [r3, #26]
	if (fs->fs_type == FS_FAT32) {
 80174ca:	2a03      	cmp	r2, #3
 80174cc:	d102      	bne.n	80174d4 <f_open+0x1e4>
		cl |= (DWORD)ld_word(dir + DIR_FstClusHI) << 16;
 80174ce:	8a9a      	ldrh	r2, [r3, #20]
 80174d0:	ea46 4602 	orr.w	r6, r6, r2, lsl #16
				fp->obj.sclust = ld_clust(fs, dj.dir);					/* Get object allocation info */
 80174d4:	60a6      	str	r6, [r4, #8]
	rv = rv << 8 | ptr[0];
 80174d6:	f8d3 801c 	ldr.w	r8, [r3, #28]
			fp->obj.id = fs->id;
 80174da:	f8ba 3006 	ldrh.w	r3, [sl, #6]
				fp->obj.objsize = ld_dword(dj.dir + DIR_FileSize);
 80174de:	f8c4 800c 	str.w	r8, [r4, #12]
			fp->cltbl = 0;			/* Disable fast seek mode */
 80174e2:	2100      	movs	r1, #0
			mem_set(fp->buf, 0, _MAX_SS);	/* Clear sector buffer */
 80174e4:	f104 0b30 	add.w	fp, r4, #48	; 0x30
			fp->flag = mode;		/* Set file access mode */
 80174e8:	7527      	strb	r7, [r4, #20]
			fp->obj.fs = fs;	 	/* Validate the file object */
 80174ea:	f8c4 a000 	str.w	sl, [r4]
			fp->obj.id = fs->id;
 80174ee:	80a3      	strh	r3, [r4, #4]
			fp->cltbl = 0;			/* Disable fast seek mode */
 80174f0:	62e1      	str	r1, [r4, #44]	; 0x2c
			fp->err = 0;			/* Clear error flag */
 80174f2:	7561      	strb	r1, [r4, #21]
			fp->sect = 0;			/* Invalidate current data sector */
 80174f4:	6221      	str	r1, [r4, #32]
			fp->fptr = 0;			/* Set file pointer top of the file */
 80174f6:	61a1      	str	r1, [r4, #24]
		*d++ = (BYTE)val;
 80174f8:	f44f 5280 	mov.w	r2, #4096	; 0x1000
 80174fc:	4658      	mov	r0, fp
 80174fe:	f010 f83b 	bl	8027578 <memset>
			if ((mode & FA_SEEKEND) && fp->obj.objsize > 0) {	/* Seek to end of file if FA_OPEN_APPEND is specified */
 8017502:	f017 0720 	ands.w	r7, r7, #32
 8017506:	d01d      	beq.n	8017544 <f_open+0x254>
 8017508:	f1b8 0f00 	cmp.w	r8, #0
 801750c:	d022      	beq.n	8017554 <f_open+0x264>
				bcs = (DWORD)fs->csize * SS(fs);	/* Cluster size in byte */
 801750e:	f8ba 300a 	ldrh.w	r3, [sl, #10]
				fp->fptr = fp->obj.objsize;			/* Offset to seek */
 8017512:	f8c4 8018 	str.w	r8, [r4, #24]
				for (ofs = fp->obj.objsize; res == FR_OK && ofs > bcs; ofs -= bcs) {
 8017516:	ebb8 3f03 	cmp.w	r8, r3, lsl #12
				bcs = (DWORD)fs->csize * SS(fs);	/* Cluster size in byte */
 801751a:	ea4f 3703 	mov.w	r7, r3, lsl #12
				for (ofs = fp->obj.objsize; res == FR_OK && ofs > bcs; ofs -= bcs) {
 801751e:	d806      	bhi.n	801752e <f_open+0x23e>
 8017520:	e02c      	b.n	801757c <f_open+0x28c>
					if (clst == 0xFFFFFFFF) res = FR_DISK_ERR;
 8017522:	1c41      	adds	r1, r0, #1
				for (ofs = fp->obj.objsize; res == FR_OK && ofs > bcs; ofs -= bcs) {
 8017524:	eba8 0807 	sub.w	r8, r8, r7
					if (clst == 0xFFFFFFFF) res = FR_DISK_ERR;
 8017528:	d011      	beq.n	801754e <f_open+0x25e>
				for (ofs = fp->obj.objsize; res == FR_OK && ofs > bcs; ofs -= bcs) {
 801752a:	4547      	cmp	r7, r8
 801752c:	d226      	bcs.n	801757c <f_open+0x28c>
					clst = get_fat(&fp->obj, clst);
 801752e:	4631      	mov	r1, r6
 8017530:	6820      	ldr	r0, [r4, #0]
 8017532:	f7fe ff31 	bl	8016398 <get_fat.isra.0>
					if (clst <= 1) res = FR_INT_ERR;
 8017536:	2801      	cmp	r0, #1
					clst = get_fat(&fp->obj, clst);
 8017538:	4606      	mov	r6, r0
					if (clst <= 1) res = FR_INT_ERR;
 801753a:	d8f2      	bhi.n	8017522 <f_open+0x232>
 801753c:	f04f 0802 	mov.w	r8, #2
				fp->clust = clst;
 8017540:	61e6      	str	r6, [r4, #28]
				if (res == FR_OK && ofs % SS(fs)) {	/* Fill sector buffer if not on the sector boundary */
 8017542:	e71b      	b.n	801737c <f_open+0x8c>
		FREE_NAMBUF();
 8017544:	4648      	mov	r0, r9
 8017546:	f001 f927 	bl	8018798 <ff_memfree>
 801754a:	463d      	mov	r5, r7
 801754c:	e6e3      	b.n	8017316 <f_open+0x26>
					if (clst == 0xFFFFFFFF) res = FR_DISK_ERR;
 801754e:	f04f 0801 	mov.w	r8, #1
 8017552:	e7f5      	b.n	8017540 <f_open+0x250>
		FREE_NAMBUF();
 8017554:	4648      	mov	r0, r9
 8017556:	f001 f91f 	bl	8018798 <ff_memfree>
	if (res != FR_OK) fp->obj.fs = 0;	/* Invalidate file object on error */
 801755a:	e6dc      	b.n	8017316 <f_open+0x26>
			fp->obj.lockid = inc_lock(&dj, (mode & ~FA_READ) ? 1 : 0);
 801755c:	f017 0ffe 	tst.w	r7, #254	; 0xfe
 8017560:	bf14      	ite	ne
 8017562:	2101      	movne	r1, #1
 8017564:	2100      	moveq	r1, #0
 8017566:	e79c      	b.n	80174a2 <f_open+0x1b2>
			if (res == FR_OK && (mode & FA_CREATE_ALWAYS)) {	/* Truncate it if overwrite mode */
 8017568:	0730      	lsls	r0, r6, #28
 801756a:	f53f af3c 	bmi.w	80173e6 <f_open+0xf6>
			fp->dir_sect = fs->winsect;			/* Pointer to the directory entry */
 801756e:	9e02      	ldr	r6, [sp, #8]
 8017570:	e797      	b.n	80174a2 <f_open+0x1b2>
		FREE_NAMBUF();
 8017572:	4648      	mov	r0, r9
 8017574:	f001 f910 	bl	8018798 <ff_memfree>
					res = FR_NO_FILE;
 8017578:	2504      	movs	r5, #4
 801757a:	e6ca      	b.n	8017312 <f_open+0x22>
				if (res == FR_OK && ofs % SS(fs)) {	/* Fill sector buffer if not on the sector boundary */
 801757c:	f3c8 030b 	ubfx	r3, r8, #0, #12
				fp->clust = clst;
 8017580:	61e6      	str	r6, [r4, #28]
				if (res == FR_OK && ofs % SS(fs)) {	/* Fill sector buffer if not on the sector boundary */
 8017582:	2b00      	cmp	r3, #0
 8017584:	d0e6      	beq.n	8017554 <f_open+0x264>
					if ((sc = clust2sect(fs, clst)) == 0) {
 8017586:	9902      	ldr	r1, [sp, #8]
	if (clst >= fs->n_fatent - 2) return 0;		/* Invalid cluster# */
 8017588:	698b      	ldr	r3, [r1, #24]
	clst -= 2;
 801758a:	3e02      	subs	r6, #2
	if (clst >= fs->n_fatent - 2) return 0;		/* Invalid cluster# */
 801758c:	3b02      	subs	r3, #2
 801758e:	429e      	cmp	r6, r3
 8017590:	d290      	bcs.n	80174b4 <f_open+0x1c4>
	return clst * fs->csize + fs->database;
 8017592:	894a      	ldrh	r2, [r1, #10]
 8017594:	6acb      	ldr	r3, [r1, #44]	; 0x2c
 8017596:	fb06 3202 	mla	r2, r6, r2, r3
					if ((sc = clust2sect(fs, clst)) == 0) {
 801759a:	2a00      	cmp	r2, #0
 801759c:	d08a      	beq.n	80174b4 <f_open+0x1c4>
						fp->sect = sc + (DWORD)(ofs / SS(fs));
 801759e:	eb02 3218 	add.w	r2, r2, r8, lsr #12
 80175a2:	6222      	str	r2, [r4, #32]
						if (disk_read(fs->drv, fp->buf, fp->sect, 1) != RES_OK) res = FR_DISK_ERR;
 80175a4:	7848      	ldrb	r0, [r1, #1]
 80175a6:	2301      	movs	r3, #1
 80175a8:	4659      	mov	r1, fp
 80175aa:	f7fe fa73 	bl	8015a94 <disk_read>
 80175ae:	4605      	mov	r5, r0
		FREE_NAMBUF();
 80175b0:	4648      	mov	r0, r9
						if (disk_read(fs->drv, fp->buf, fp->sect, 1) != RES_OK) res = FR_DISK_ERR;
 80175b2:	2d00      	cmp	r5, #0
 80175b4:	d0cf      	beq.n	8017556 <f_open+0x266>
		FREE_NAMBUF();
 80175b6:	f001 f8ef 	bl	8018798 <ff_memfree>
						if (disk_read(fs->drv, fp->buf, fp->sect, 1) != RES_OK) res = FR_DISK_ERR;
 80175ba:	2501      	movs	r5, #1
 80175bc:	e6a9      	b.n	8017312 <f_open+0x22>
							fs->last_clst = cl - 1;		/* Reuse the cluster hole */
 80175be:	f10a 32ff 	add.w	r2, sl, #4294967295
 80175c2:	6132      	str	r2, [r6, #16]
		if (res == FR_OK) {
 80175c4:	e768      	b.n	8017498 <f_open+0x1a8>
			fs->winsect = sector;
 80175c6:	f8c6 b030 	str.w	fp, [r6, #48]	; 0x30
							fs->last_clst = cl - 1;		/* Reuse the cluster hole */
 80175ca:	9e02      	ldr	r6, [sp, #8]
 80175cc:	f10a 32ff 	add.w	r2, sl, #4294967295
 80175d0:	6132      	str	r2, [r6, #16]
		if (res == FR_OK) {
 80175d2:	e761      	b.n	8017498 <f_open+0x1a8>
 80175d4:	4630      	mov	r0, r6
 80175d6:	f7fe fbdb 	bl	8015d90 <sync_window.part.0>
		if (res == FR_OK) {			/* Fill sector window with new data */
 80175da:	4680      	mov	r8, r0
 80175dc:	2800      	cmp	r0, #0
 80175de:	f43f af46 	beq.w	801746e <f_open+0x17e>
							fs->last_clst = cl - 1;		/* Reuse the cluster hole */
 80175e2:	9b02      	ldr	r3, [sp, #8]
 80175e4:	f10a 32ff 	add.w	r2, sl, #4294967295
 80175e8:	611a      	str	r2, [r3, #16]
		if (res == FR_OK) {
 80175ea:	e6c7      	b.n	801737c <f_open+0x8c>
 80175ec:	20003310 	.word	0x20003310

080175f0 <f_read>:
	FIL* fp, 	/* Pointer to the file object */
	void* buff,	/* Pointer to data buffer */
	UINT btr,	/* Number of bytes to read */
	UINT* br	/* Pointer to number of bytes read */
)
{
 80175f0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80175f4:	461e      	mov	r6, r3
 80175f6:	b085      	sub	sp, #20
	FSIZE_t remain;
	UINT rcnt, cc, csect;
	BYTE *rbuff = (BYTE*)buff;


	*br = 0;	/* Clear read byte counter */
 80175f8:	2300      	movs	r3, #0
{
 80175fa:	4688      	mov	r8, r1
	*br = 0;	/* Clear read byte counter */
 80175fc:	6033      	str	r3, [r6, #0]
	res = validate(&fp->obj, &fs);				/* Check validity of the file object */
 80175fe:	a903      	add	r1, sp, #12
{
 8017600:	4604      	mov	r4, r0
 8017602:	4617      	mov	r7, r2
	res = validate(&fp->obj, &fs);				/* Check validity of the file object */
 8017604:	f7fe fb36 	bl	8015c74 <validate>
	if (res != FR_OK || (res = (FRESULT)fp->err) != FR_OK) LEAVE_FF(fs, res);	/* Check validity */
 8017608:	4605      	mov	r5, r0
 801760a:	2800      	cmp	r0, #0
 801760c:	d151      	bne.n	80176b2 <f_read+0xc2>
 801760e:	7d65      	ldrb	r5, [r4, #21]
 8017610:	2d00      	cmp	r5, #0
 8017612:	d14e      	bne.n	80176b2 <f_read+0xc2>
	if (!(fp->flag & FA_READ)) LEAVE_FF(fs, FR_DENIED); /* Check access mode */
 8017614:	f894 9014 	ldrb.w	r9, [r4, #20]
 8017618:	f019 0901 	ands.w	r9, r9, #1
 801761c:	f000 80a5 	beq.w	801776a <f_read+0x17a>
	remain = fp->obj.objsize - fp->fptr;
 8017620:	69a1      	ldr	r1, [r4, #24]
 8017622:	68e3      	ldr	r3, [r4, #12]
 8017624:	1a5b      	subs	r3, r3, r1
 8017626:	429f      	cmp	r7, r3
 8017628:	bf28      	it	cs
 801762a:	461f      	movcs	r7, r3
	if (btr > remain) btr = (UINT)remain;		/* Truncate btr by remaining bytes */

	for ( ;  btr;								/* Repeat until all data read */
 801762c:	2f00      	cmp	r7, #0
 801762e:	d040      	beq.n	80176b2 <f_read+0xc2>
 8017630:	f504 5a81 	add.w	sl, r4, #4128	; 0x1020
 8017634:	f10a 0a10 	add.w	sl, sl, #16
 8017638:	9500      	str	r5, [sp, #0]
		rbuff += rcnt, fp->fptr += rcnt, *br += rcnt, btr -= rcnt) {
		if (fp->fptr % SS(fs) == 0) {			/* On the sector boundary? */
 801763a:	f3c1 000b 	ubfx	r0, r1, #0, #12
 801763e:	2800      	cmp	r0, #0
 8017640:	d146      	bne.n	80176d0 <f_read+0xe0>
			csect = (UINT)(fp->fptr / SS(fs) & (fs->csize - 1));	/* Sector offset in the cluster */
 8017642:	f8dd c00c 	ldr.w	ip, [sp, #12]
 8017646:	f8bc 200a 	ldrh.w	r2, [ip, #10]
 801764a:	3a01      	subs	r2, #1
			if (csect == 0) {					/* On the cluster boundary? */
 801764c:	ea12 3211 	ands.w	r2, r2, r1, lsr #12
			csect = (UINT)(fp->fptr / SS(fs) & (fs->csize - 1));	/* Sector offset in the cluster */
 8017650:	ea4f 3311 	mov.w	r3, r1, lsr #12
			if (csect == 0) {					/* On the cluster boundary? */
 8017654:	d031      	beq.n	80176ba <f_read+0xca>
				}
				if (clst < 2) ABORT(fs, FR_INT_ERR);
				if (clst == 0xFFFFFFFF) ABORT(fs, FR_DISK_ERR);
				fp->clust = clst;				/* Update current cluster */
			}
			sect = clust2sect(fs, fp->clust);	/* Get current sector */
 8017656:	69e0      	ldr	r0, [r4, #28]
	if (clst >= fs->n_fatent - 2) return 0;		/* Invalid cluster# */
 8017658:	f8dc 3018 	ldr.w	r3, [ip, #24]
	clst -= 2;
 801765c:	3802      	subs	r0, #2
	if (clst >= fs->n_fatent - 2) return 0;		/* Invalid cluster# */
 801765e:	3b02      	subs	r3, #2
 8017660:	4298      	cmp	r0, r3
 8017662:	d224      	bcs.n	80176ae <f_read+0xbe>
	return clst * fs->csize + fs->database;
 8017664:	f8bc 100a 	ldrh.w	r1, [ip, #10]
 8017668:	f8dc 302c 	ldr.w	r3, [ip, #44]	; 0x2c
 801766c:	fb01 3000 	mla	r0, r1, r0, r3
			if (!sect) ABORT(fs, FR_INT_ERR);
 8017670:	b1e8      	cbz	r0, 80176ae <f_read+0xbe>
			sect += csect;
			cc = btr / SS(fs);					/* When remaining bytes >= sector size, */
			if (cc) {							/* Read maximum contiguous sectors directly */
 8017672:	f5b7 5f80 	cmp.w	r7, #4096	; 0x1000
			sect += csect;
 8017676:	eb02 0b00 	add.w	fp, r2, r0
			if (cc) {							/* Read maximum contiguous sectors directly */
 801767a:	d246      	bcs.n	801770a <f_read+0x11a>
#endif
				rcnt = SS(fs) * cc;				/* Number of bytes transferred */
				continue;
			}
#if !_FS_TINY
			if (fp->sect != sect) {			/* Load data sector if not in cache */
 801767c:	6a22      	ldr	r2, [r4, #32]
 801767e:	455a      	cmp	r2, fp
 8017680:	d075      	beq.n	801776e <f_read+0x17e>
#if !_FS_READONLY
				if (fp->flag & FA_DIRTY) {		/* Write-back dirty sector cache */
 8017682:	f994 3014 	ldrsb.w	r3, [r4, #20]
 8017686:	2b00      	cmp	r3, #0
 8017688:	db74      	blt.n	8017774 <f_read+0x184>
					mem_cpy(rbuff + ((fp->sect - sect) * SS(fs)), fp->buf, SS(fs));
 801768a:	f104 0130 	add.w	r1, r4, #48	; 0x30
					if (disk_write(fs->drv, fp->buf, fp->sect, 1) != RES_OK) ABORT(fs, FR_DISK_ERR);
					fp->flag &= (BYTE)~FA_DIRTY;
				}
#endif
				if (disk_read(fs->drv, fp->buf, sect, 1) != RES_OK)	ABORT(fs, FR_DISK_ERR);	/* Fill sector cache */
 801768e:	f89c 0001 	ldrb.w	r0, [ip, #1]
 8017692:	9101      	str	r1, [sp, #4]
 8017694:	2301      	movs	r3, #1
 8017696:	465a      	mov	r2, fp
 8017698:	f7fe f9fc 	bl	8015a94 <disk_read>
 801769c:	9901      	ldr	r1, [sp, #4]
 801769e:	2800      	cmp	r0, #0
 80176a0:	d15c      	bne.n	801775c <f_read+0x16c>
			}
#endif
			fp->sect = sect;
		}
		rcnt = SS(fs) - (UINT)fp->fptr % SS(fs);	/* Number of bytes left in the sector */
 80176a2:	69a0      	ldr	r0, [r4, #24]
			fp->sect = sect;
 80176a4:	f8c4 b020 	str.w	fp, [r4, #32]
		rcnt = SS(fs) - (UINT)fp->fptr % SS(fs);	/* Number of bytes left in the sector */
 80176a8:	f3c0 000b 	ubfx	r0, r0, #0, #12
 80176ac:	e012      	b.n	80176d4 <f_read+0xe4>
				if (clst < 2) ABORT(fs, FR_INT_ERR);
 80176ae:	2502      	movs	r5, #2
 80176b0:	7565      	strb	r5, [r4, #21]
		mem_cpy(rbuff, fp->buf + fp->fptr % SS(fs), rcnt);	/* Extract partial sector */
#endif
	}

	LEAVE_FF(fs, FR_OK);
}
 80176b2:	4628      	mov	r0, r5
 80176b4:	b005      	add	sp, #20
 80176b6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
				if (fp->fptr == 0) {			/* On the top of the file? */
 80176ba:	2900      	cmp	r1, #0
 80176bc:	d13a      	bne.n	8017734 <f_read+0x144>
					clst = fp->obj.sclust;		/* Follow cluster chain from the origin */
 80176be:	68a0      	ldr	r0, [r4, #8]
				if (clst < 2) ABORT(fs, FR_INT_ERR);
 80176c0:	2801      	cmp	r0, #1
 80176c2:	d9f4      	bls.n	80176ae <f_read+0xbe>
				if (clst == 0xFFFFFFFF) ABORT(fs, FR_DISK_ERR);
 80176c4:	1c43      	adds	r3, r0, #1
 80176c6:	d049      	beq.n	801775c <f_read+0x16c>
			sect = clust2sect(fs, fp->clust);	/* Get current sector */
 80176c8:	f8dd c00c 	ldr.w	ip, [sp, #12]
				fp->clust = clst;				/* Update current cluster */
 80176cc:	61e0      	str	r0, [r4, #28]
 80176ce:	e7c3      	b.n	8017658 <f_read+0x68>
					mem_cpy(rbuff + ((fp->sect - sect) * SS(fs)), fp->buf, SS(fs));
 80176d0:	f104 0130 	add.w	r1, r4, #48	; 0x30
		mem_cpy(rbuff, fp->buf + fp->fptr % SS(fs), rcnt);	/* Extract partial sector */
 80176d4:	4401      	add	r1, r0
		rcnt = SS(fs) - (UINT)fp->fptr % SS(fs);	/* Number of bytes left in the sector */
 80176d6:	f5c0 5080 	rsb	r0, r0, #4096	; 0x1000
		if (rcnt > btr) rcnt = btr;					/* Clip it by btr if needed */
 80176da:	42b8      	cmp	r0, r7
 80176dc:	bf28      	it	cs
 80176de:	4638      	movcs	r0, r7
void mem_cpy (void* dst, const void* src, UINT cnt) {
 80176e0:	f108 33ff 	add.w	r3, r8, #4294967295
 80176e4:	eb01 0c00 	add.w	ip, r1, r0
			*d++ = *s++;
 80176e8:	f811 2b01 	ldrb.w	r2, [r1], #1
 80176ec:	f803 2f01 	strb.w	r2, [r3, #1]!
		} while (--cnt);
 80176f0:	4561      	cmp	r1, ip
 80176f2:	d1f9      	bne.n	80176e8 <f_read+0xf8>
		rbuff += rcnt, fp->fptr += rcnt, *br += rcnt, btr -= rcnt) {
 80176f4:	69a1      	ldr	r1, [r4, #24]
 80176f6:	6833      	ldr	r3, [r6, #0]
 80176f8:	4401      	add	r1, r0
 80176fa:	4403      	add	r3, r0
	for ( ;  btr;								/* Repeat until all data read */
 80176fc:	1a3f      	subs	r7, r7, r0
		rbuff += rcnt, fp->fptr += rcnt, *br += rcnt, btr -= rcnt) {
 80176fe:	61a1      	str	r1, [r4, #24]
 8017700:	4480      	add	r8, r0
 8017702:	6033      	str	r3, [r6, #0]
	for ( ;  btr;								/* Repeat until all data read */
 8017704:	d199      	bne.n	801763a <f_read+0x4a>
 8017706:	9d00      	ldr	r5, [sp, #0]
 8017708:	e7d3      	b.n	80176b2 <f_read+0xc2>
				if (csect + cc > fs->csize) {	/* Clip at cluster boundary */
 801770a:	eb02 3017 	add.w	r0, r2, r7, lsr #12
 801770e:	4288      	cmp	r0, r1
			cc = btr / SS(fs);					/* When remaining bytes >= sector size, */
 8017710:	ea4f 3517 	mov.w	r5, r7, lsr #12
					cc = fs->csize - csect;
 8017714:	bf88      	it	hi
 8017716:	1a8d      	subhi	r5, r1, r2
				if (disk_read(fs->drv, rbuff, sect, cc) != RES_OK) ABORT(fs, FR_DISK_ERR);
 8017718:	f89c 0001 	ldrb.w	r0, [ip, #1]
 801771c:	462b      	mov	r3, r5
 801771e:	465a      	mov	r2, fp
 8017720:	4641      	mov	r1, r8
 8017722:	f7fe f9b7 	bl	8015a94 <disk_read>
 8017726:	b9c8      	cbnz	r0, 801775c <f_read+0x16c>
				if ((fp->flag & FA_DIRTY) && fp->sect - sect < cc) {
 8017728:	f994 2014 	ldrsb.w	r2, [r4, #20]
 801772c:	2a00      	cmp	r2, #0
 801772e:	db3a      	blt.n	80177a6 <f_read+0x1b6>
				rcnt = SS(fs) * cc;				/* Number of bytes transferred */
 8017730:	0328      	lsls	r0, r5, #12
				continue;
 8017732:	e7df      	b.n	80176f4 <f_read+0x104>
					if (fp->cltbl) {
 8017734:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
 8017736:	b378      	cbz	r0, 8017798 <f_read+0x1a8>
	cl = (DWORD)(ofs / SS(fs) / fs->csize);	/* Cluster order from top of the file */
 8017738:	6821      	ldr	r1, [r4, #0]
 801773a:	8949      	ldrh	r1, [r1, #10]
 801773c:	fbb3 f3f1 	udiv	r3, r3, r1
		ncl = *tbl++;			/* Number of cluters in the fragment */
 8017740:	6841      	ldr	r1, [r0, #4]
	tbl = fp->cltbl + 1;	/* Top of CLMT */
 8017742:	3004      	adds	r0, #4
		if (ncl == 0) return 0;	/* End of table? (error) */
 8017744:	b929      	cbnz	r1, 8017752 <f_read+0x162>
 8017746:	e7b2      	b.n	80176ae <f_read+0xbe>
		cl -= ncl; tbl++;		/* Next fragment */
 8017748:	1a5b      	subs	r3, r3, r1
		ncl = *tbl++;			/* Number of cluters in the fragment */
 801774a:	f850 1f08 	ldr.w	r1, [r0, #8]!
		if (ncl == 0) return 0;	/* End of table? (error) */
 801774e:	2900      	cmp	r1, #0
 8017750:	d0ad      	beq.n	80176ae <f_read+0xbe>
		if (cl < ncl) break;	/* In this fragment? */
 8017752:	428b      	cmp	r3, r1
 8017754:	d2f8      	bcs.n	8017748 <f_read+0x158>
	return cl + *tbl;	/* Return the cluster number */
 8017756:	6840      	ldr	r0, [r0, #4]
 8017758:	4418      	add	r0, r3
 801775a:	e7b1      	b.n	80176c0 <f_read+0xd0>
				if (clst == 0xFFFFFFFF) ABORT(fs, FR_DISK_ERR);
 801775c:	464d      	mov	r5, r9
 801775e:	2301      	movs	r3, #1
}
 8017760:	4628      	mov	r0, r5
				if (clst == 0xFFFFFFFF) ABORT(fs, FR_DISK_ERR);
 8017762:	7563      	strb	r3, [r4, #21]
}
 8017764:	b005      	add	sp, #20
 8017766:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	if (!(fp->flag & FA_READ)) LEAVE_FF(fs, FR_DENIED); /* Check access mode */
 801776a:	2507      	movs	r5, #7
 801776c:	e7a1      	b.n	80176b2 <f_read+0xc2>
 801776e:	f104 0130 	add.w	r1, r4, #48	; 0x30
 8017772:	e796      	b.n	80176a2 <f_read+0xb2>
					if (disk_write(fs->drv, fp->buf, fp->sect, 1) != RES_OK) ABORT(fs, FR_DISK_ERR);
 8017774:	f104 0130 	add.w	r1, r4, #48	; 0x30
 8017778:	f89c 0001 	ldrb.w	r0, [ip, #1]
 801777c:	9101      	str	r1, [sp, #4]
 801777e:	2301      	movs	r3, #1
 8017780:	f7fe f996 	bl	8015ab0 <disk_write>
 8017784:	2800      	cmp	r0, #0
 8017786:	d1e9      	bne.n	801775c <f_read+0x16c>
					fp->flag &= (BYTE)~FA_DIRTY;
 8017788:	7d23      	ldrb	r3, [r4, #20]
				if (disk_read(fs->drv, fp->buf, sect, 1) != RES_OK)	ABORT(fs, FR_DISK_ERR);	/* Fill sector cache */
 801778a:	f8dd c00c 	ldr.w	ip, [sp, #12]
 801778e:	9901      	ldr	r1, [sp, #4]
					fp->flag &= (BYTE)~FA_DIRTY;
 8017790:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 8017794:	7523      	strb	r3, [r4, #20]
 8017796:	e77a      	b.n	801768e <f_read+0x9e>
						clst = get_fat(&fp->obj, fp->clust);	/* Follow cluster chain on the FAT */
 8017798:	69e1      	ldr	r1, [r4, #28]
 801779a:	6820      	ldr	r0, [r4, #0]
 801779c:	9201      	str	r2, [sp, #4]
 801779e:	f7fe fdfb 	bl	8016398 <get_fat.isra.0>
 80177a2:	9a01      	ldr	r2, [sp, #4]
 80177a4:	e78c      	b.n	80176c0 <f_read+0xd0>
				if ((fp->flag & FA_DIRTY) && fp->sect - sect < cc) {
 80177a6:	6a22      	ldr	r2, [r4, #32]
 80177a8:	eba2 0b0b 	sub.w	fp, r2, fp
 80177ac:	45ab      	cmp	fp, r5
 80177ae:	d2bf      	bcs.n	8017730 <f_read+0x140>
					mem_cpy(rbuff + ((fp->sect - sect) * SS(fs)), fp->buf, SS(fs));
 80177b0:	eb08 3b0b 	add.w	fp, r8, fp, lsl #12
 80177b4:	f10b 32ff 	add.w	r2, fp, #4294967295
 80177b8:	f104 0130 	add.w	r1, r4, #48	; 0x30
			*d++ = *s++;
 80177bc:	f811 3b01 	ldrb.w	r3, [r1], #1
 80177c0:	f802 3f01 	strb.w	r3, [r2, #1]!
		} while (--cnt);
 80177c4:	4551      	cmp	r1, sl
 80177c6:	d1f9      	bne.n	80177bc <f_read+0x1cc>
 80177c8:	e7b2      	b.n	8017730 <f_read+0x140>
 80177ca:	bf00      	nop

080177cc <f_write>:
	FIL* fp,			/* Pointer to the file object */
	const void* buff,	/* Pointer to the data to be written */
	UINT btw,			/* Number of bytes to write */
	UINT* bw			/* Pointer to number of bytes written */
)
{
 80177cc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80177d0:	4698      	mov	r8, r3
 80177d2:	b085      	sub	sp, #20
	DWORD clst, sect;
	UINT wcnt, cc, csect;
	const BYTE *wbuff = (const BYTE*)buff;


	*bw = 0;	/* Clear write byte counter */
 80177d4:	2300      	movs	r3, #0
{
 80177d6:	460c      	mov	r4, r1
	*bw = 0;	/* Clear write byte counter */
 80177d8:	f8c8 3000 	str.w	r3, [r8]
	res = validate(&fp->obj, &fs);			/* Check validity of the file object */
 80177dc:	a903      	add	r1, sp, #12
{
 80177de:	4605      	mov	r5, r0
 80177e0:	4617      	mov	r7, r2
	res = validate(&fp->obj, &fs);			/* Check validity of the file object */
 80177e2:	f7fe fa47 	bl	8015c74 <validate>
	if (res != FR_OK || (res = (FRESULT)fp->err) != FR_OK) LEAVE_FF(fs, res);	/* Check validity */
 80177e6:	4606      	mov	r6, r0
 80177e8:	2800      	cmp	r0, #0
 80177ea:	d15f      	bne.n	80178ac <f_write+0xe0>
 80177ec:	7d6e      	ldrb	r6, [r5, #21]
 80177ee:	2e00      	cmp	r6, #0
 80177f0:	d15c      	bne.n	80178ac <f_write+0xe0>
	if (!(fp->flag & FA_WRITE)) LEAVE_FF(fs, FR_DENIED);	/* Check access mode */
 80177f2:	7d2a      	ldrb	r2, [r5, #20]
 80177f4:	0791      	lsls	r1, r2, #30
 80177f6:	f140 80bc 	bpl.w	8017972 <f_write+0x1a6>

	/* Check fptr wrap-around (file size cannot reach 4GiB on FATxx) */
	if ((!_FS_EXFAT || fs->fs_type != FS_EXFAT) && (DWORD)(fp->fptr + btw) < (DWORD)fp->fptr) {
 80177fa:	69ab      	ldr	r3, [r5, #24]
 80177fc:	42fb      	cmn	r3, r7
		btw = (UINT)(0xFFFFFFFF - (DWORD)fp->fptr);
 80177fe:	bf28      	it	cs
 8017800:	43df      	mvncs	r7, r3
	}

	for ( ;  btw;							/* Repeat until all data written */
 8017802:	2f00      	cmp	r7, #0
 8017804:	f000 8087 	beq.w	8017916 <f_write+0x14a>
			}
#if _FS_TINY
			if (fs->winsect == fp->sect && sync_window(fs) != FR_OK) ABORT(fs, FR_DISK_ERR);	/* Write-back sector cache */
#else
			if (fp->flag & FA_DIRTY) {		/* Write-back sector cache */
				if (disk_write(fs->drv, fp->buf, fp->sect, 1) != RES_OK) ABORT(fs, FR_DISK_ERR);
 8017808:	f105 0930 	add.w	r9, r5, #48	; 0x30
		if (fp->fptr % SS(fs) == 0) {		/* On the sector boundary? */
 801780c:	f3c3 010b 	ubfx	r1, r3, #0, #12
 8017810:	2900      	cmp	r1, #0
 8017812:	d15a      	bne.n	80178ca <f_write+0xfe>
			csect = (UINT)(fp->fptr / SS(fs)) & (fs->csize - 1);	/* Sector offset in the cluster */
 8017814:	9803      	ldr	r0, [sp, #12]
 8017816:	f8b0 a00a 	ldrh.w	sl, [r0, #10]
 801781a:	f10a 3aff 	add.w	sl, sl, #4294967295
			if (csect == 0) {				/* On the cluster boundary? */
 801781e:	ea1a 3a13 	ands.w	sl, sl, r3, lsr #12
			csect = (UINT)(fp->fptr / SS(fs)) & (fs->csize - 1);	/* Sector offset in the cluster */
 8017822:	ea4f 3213 	mov.w	r2, r3, lsr #12
			if (csect == 0) {				/* On the cluster boundary? */
 8017826:	d10f      	bne.n	8017848 <f_write+0x7c>
				if (fp->fptr == 0) {		/* On the top of the file? */
 8017828:	2b00      	cmp	r3, #0
 801782a:	d178      	bne.n	801791e <f_write+0x152>
					clst = fp->obj.sclust;	/* Follow from the origin */
 801782c:	68a8      	ldr	r0, [r5, #8]
					if (clst == 0) {		/* If no cluster is allocated, */
 801782e:	2800      	cmp	r0, #0
 8017830:	f000 80a1 	beq.w	8017976 <f_write+0x1aa>
				if (clst == 1) ABORT(fs, FR_INT_ERR);
 8017834:	2801      	cmp	r0, #1
 8017836:	d037      	beq.n	80178a8 <f_write+0xdc>
				if (clst == 0xFFFFFFFF) ABORT(fs, FR_DISK_ERR);
 8017838:	1c43      	adds	r3, r0, #1
 801783a:	f000 8094 	beq.w	8017966 <f_write+0x19a>
				if (fp->obj.sclust == 0) fp->obj.sclust = clst;	/* Set start cluster if the first write */
 801783e:	68ab      	ldr	r3, [r5, #8]
				fp->clust = clst;			/* Update current cluster */
 8017840:	61e8      	str	r0, [r5, #28]
				if (fp->obj.sclust == 0) fp->obj.sclust = clst;	/* Set start cluster if the first write */
 8017842:	b903      	cbnz	r3, 8017846 <f_write+0x7a>
 8017844:	60a8      	str	r0, [r5, #8]
				if (disk_write(fs->drv, fp->buf, fp->sect, 1) != RES_OK) ABORT(fs, FR_DISK_ERR);
 8017846:	9803      	ldr	r0, [sp, #12]
			if (fp->flag & FA_DIRTY) {		/* Write-back sector cache */
 8017848:	f995 3014 	ldrsb.w	r3, [r5, #20]
 801784c:	2b00      	cmp	r3, #0
 801784e:	db7d      	blt.n	801794c <f_write+0x180>
	clst -= 2;
 8017850:	69ea      	ldr	r2, [r5, #28]
	if (clst >= fs->n_fatent - 2) return 0;		/* Invalid cluster# */
 8017852:	6983      	ldr	r3, [r0, #24]
	clst -= 2;
 8017854:	f1a2 0b02 	sub.w	fp, r2, #2
	if (clst >= fs->n_fatent - 2) return 0;		/* Invalid cluster# */
 8017858:	3b02      	subs	r3, #2
 801785a:	459b      	cmp	fp, r3
 801785c:	d224      	bcs.n	80178a8 <f_write+0xdc>
	return clst * fs->csize + fs->database;
 801785e:	8941      	ldrh	r1, [r0, #10]
 8017860:	6ac2      	ldr	r2, [r0, #44]	; 0x2c
 8017862:	fb01 220b 	mla	r2, r1, fp, r2
				fp->flag &= (BYTE)~FA_DIRTY;
			}
#endif
			sect = clust2sect(fs, fp->clust);	/* Get current sector */
			if (!sect) ABORT(fs, FR_INT_ERR);
 8017866:	b1fa      	cbz	r2, 80178a8 <f_write+0xdc>
			sect += csect;
			cc = btw / SS(fs);				/* When remaining bytes >= sector size, */
			if (cc) {						/* Write maximum contiguous sectors directly */
 8017868:	f5b7 5f80 	cmp.w	r7, #4096	; 0x1000
			sect += csect;
 801786c:	eb0a 0b02 	add.w	fp, sl, r2
			if (cc) {						/* Write maximum contiguous sectors directly */
 8017870:	d320      	bcc.n	80178b4 <f_write+0xe8>
				if (csect + cc > fs->csize) {	/* Clip at cluster boundary */
 8017872:	eb0a 3217 	add.w	r2, sl, r7, lsr #12
 8017876:	428a      	cmp	r2, r1
			cc = btw / SS(fs);				/* When remaining bytes >= sector size, */
 8017878:	ea4f 3317 	mov.w	r3, r7, lsr #12
					cc = fs->csize - csect;
				}
				if (disk_write(fs->drv, wbuff, sect, cc) != RES_OK) ABORT(fs, FR_DISK_ERR);
 801787c:	7840      	ldrb	r0, [r0, #1]
					cc = fs->csize - csect;
 801787e:	bf88      	it	hi
 8017880:	eba1 030a 	subhi.w	r3, r1, sl
				if (disk_write(fs->drv, wbuff, sect, cc) != RES_OK) ABORT(fs, FR_DISK_ERR);
 8017884:	465a      	mov	r2, fp
 8017886:	4621      	mov	r1, r4
 8017888:	9301      	str	r3, [sp, #4]
 801788a:	f7fe f911 	bl	8015ab0 <disk_write>
 801788e:	2800      	cmp	r0, #0
 8017890:	d169      	bne.n	8017966 <f_write+0x19a>
				if (fs->winsect - sect < cc) {	/* Refill sector cache if it gets invalidated by the direct write */
					mem_cpy(fs->win, wbuff + ((fs->winsect - sect) * SS(fs)), SS(fs));
					fs->wflag = 0;
				}
#else
				if (fp->sect - sect < cc) { /* Refill sector cache if it gets invalidated by the direct write */
 8017892:	6a2a      	ldr	r2, [r5, #32]
 8017894:	9b01      	ldr	r3, [sp, #4]
 8017896:	eba2 0b0b 	sub.w	fp, r2, fp
 801789a:	459b      	cmp	fp, r3
 801789c:	f0c0 8085 	bcc.w	80179aa <f_write+0x1de>
					mem_cpy(fp->buf, wbuff + ((fp->sect - sect) * SS(fs)), SS(fs));
					fp->flag &= (BYTE)~FA_DIRTY;
				}
#endif
#endif
				wcnt = SS(fs) * cc;		/* Number of bytes transferred */
 80178a0:	eb04 3203 	add.w	r2, r4, r3, lsl #12
 80178a4:	0318      	lsls	r0, r3, #12
				continue;
 80178a6:	e024      	b.n	80178f2 <f_write+0x126>
				if (clst == 1) ABORT(fs, FR_INT_ERR);
 80178a8:	2602      	movs	r6, #2
 80178aa:	756e      	strb	r6, [r5, #21]
	}

	fp->flag |= FA_MODIFIED;				/* Set file change flag */

	LEAVE_FF(fs, FR_OK);
}
 80178ac:	4630      	mov	r0, r6
 80178ae:	b005      	add	sp, #20
 80178b0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			if (fp->sect != sect && 		/* Fill sector cache with file data */
 80178b4:	6a2b      	ldr	r3, [r5, #32]
				fp->fptr < fp->obj.objsize &&
 80178b6:	69a9      	ldr	r1, [r5, #24]
			if (fp->sect != sect && 		/* Fill sector cache with file data */
 80178b8:	455b      	cmp	r3, fp
 80178ba:	d002      	beq.n	80178c2 <f_write+0xf6>
 80178bc:	68eb      	ldr	r3, [r5, #12]
 80178be:	4299      	cmp	r1, r3
 80178c0:	d369      	bcc.n	8017996 <f_write+0x1ca>
			fp->sect = sect;
 80178c2:	f8c5 b020 	str.w	fp, [r5, #32]
		wcnt = SS(fs) - (UINT)fp->fptr % SS(fs);	/* Number of bytes left in the sector */
 80178c6:	f3c1 010b 	ubfx	r1, r1, #0, #12
 80178ca:	f5c1 5380 	rsb	r3, r1, #4096	; 0x1000
		if (wcnt > btw) wcnt = btw;					/* Clip it by btw if needed */
 80178ce:	42bb      	cmp	r3, r7
 80178d0:	bf28      	it	cs
 80178d2:	463b      	movcs	r3, r7
 80178d4:	f101 3cff 	add.w	ip, r1, #4294967295
 80178d8:	4618      	mov	r0, r3
void mem_cpy (void* dst, const void* src, UINT cnt) {
 80178da:	44cc      	add	ip, r9
 80178dc:	18e2      	adds	r2, r4, r3
			*d++ = *s++;
 80178de:	f814 3b01 	ldrb.w	r3, [r4], #1
 80178e2:	f80c 3f01 	strb.w	r3, [ip, #1]!
		} while (--cnt);
 80178e6:	4294      	cmp	r4, r2
 80178e8:	d1f9      	bne.n	80178de <f_write+0x112>
		fp->flag |= FA_DIRTY;
 80178ea:	7d2b      	ldrb	r3, [r5, #20]
 80178ec:	f063 037f 	orn	r3, r3, #127	; 0x7f
 80178f0:	752b      	strb	r3, [r5, #20]
		wbuff += wcnt, fp->fptr += wcnt, fp->obj.objsize = (fp->fptr > fp->obj.objsize) ? fp->fptr : fp->obj.objsize, *bw += wcnt, btw -= wcnt) {
 80178f2:	69ab      	ldr	r3, [r5, #24]
 80178f4:	4614      	mov	r4, r2
 80178f6:	68ea      	ldr	r2, [r5, #12]
 80178f8:	4403      	add	r3, r0
 80178fa:	429a      	cmp	r2, r3
 80178fc:	bf38      	it	cc
 80178fe:	461a      	movcc	r2, r3
 8017900:	60ea      	str	r2, [r5, #12]
 8017902:	f8d8 2000 	ldr.w	r2, [r8]
 8017906:	61ab      	str	r3, [r5, #24]
 8017908:	4402      	add	r2, r0
	for ( ;  btw;							/* Repeat until all data written */
 801790a:	1a3f      	subs	r7, r7, r0
		wbuff += wcnt, fp->fptr += wcnt, fp->obj.objsize = (fp->fptr > fp->obj.objsize) ? fp->fptr : fp->obj.objsize, *bw += wcnt, btw -= wcnt) {
 801790c:	f8c8 2000 	str.w	r2, [r8]
	for ( ;  btw;							/* Repeat until all data written */
 8017910:	f47f af7c 	bne.w	801780c <f_write+0x40>
	fp->flag |= FA_MODIFIED;				/* Set file change flag */
 8017914:	7d2a      	ldrb	r2, [r5, #20]
 8017916:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 801791a:	752a      	strb	r2, [r5, #20]
	LEAVE_FF(fs, FR_OK);
 801791c:	e7c6      	b.n	80178ac <f_write+0xe0>
					if (fp->cltbl) {
 801791e:	6ae9      	ldr	r1, [r5, #44]	; 0x2c
 8017920:	b389      	cbz	r1, 8017986 <f_write+0x1ba>
	cl = (DWORD)(ofs / SS(fs) / fs->csize);	/* Cluster order from top of the file */
 8017922:	682b      	ldr	r3, [r5, #0]
 8017924:	895b      	ldrh	r3, [r3, #10]
 8017926:	fbb2 f3f3 	udiv	r3, r2, r3
		ncl = *tbl++;			/* Number of cluters in the fragment */
 801792a:	684a      	ldr	r2, [r1, #4]
	tbl = fp->cltbl + 1;	/* Top of CLMT */
 801792c:	3104      	adds	r1, #4
		if (ncl == 0) return 0;	/* End of table? (error) */
 801792e:	b92a      	cbnz	r2, 801793c <f_write+0x170>
 8017930:	e7f0      	b.n	8017914 <f_write+0x148>
		cl -= ncl; tbl++;		/* Next fragment */
 8017932:	1a9b      	subs	r3, r3, r2
		ncl = *tbl++;			/* Number of cluters in the fragment */
 8017934:	f851 2f08 	ldr.w	r2, [r1, #8]!
		if (ncl == 0) return 0;	/* End of table? (error) */
 8017938:	2a00      	cmp	r2, #0
 801793a:	d0eb      	beq.n	8017914 <f_write+0x148>
		if (cl < ncl) break;	/* In this fragment? */
 801793c:	4293      	cmp	r3, r2
 801793e:	d2f8      	bcs.n	8017932 <f_write+0x166>
	return cl + *tbl;	/* Return the cluster number */
 8017940:	6848      	ldr	r0, [r1, #4]
 8017942:	4418      	add	r0, r3
				if (clst == 0) break;		/* Could not allocate a new cluster (disk full) */
 8017944:	2800      	cmp	r0, #0
 8017946:	f47f af75 	bne.w	8017834 <f_write+0x68>
 801794a:	e7e3      	b.n	8017914 <f_write+0x148>
				if (disk_write(fs->drv, fp->buf, fp->sect, 1) != RES_OK) ABORT(fs, FR_DISK_ERR);
 801794c:	7840      	ldrb	r0, [r0, #1]
 801794e:	6a2a      	ldr	r2, [r5, #32]
 8017950:	2301      	movs	r3, #1
 8017952:	4649      	mov	r1, r9
 8017954:	f7fe f8ac 	bl	8015ab0 <disk_write>
 8017958:	b928      	cbnz	r0, 8017966 <f_write+0x19a>
				fp->flag &= (BYTE)~FA_DIRTY;
 801795a:	7d2b      	ldrb	r3, [r5, #20]
			sect = clust2sect(fs, fp->clust);	/* Get current sector */
 801795c:	9803      	ldr	r0, [sp, #12]
				fp->flag &= (BYTE)~FA_DIRTY;
 801795e:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 8017962:	752b      	strb	r3, [r5, #20]
 8017964:	e774      	b.n	8017850 <f_write+0x84>
				if (clst == 0xFFFFFFFF) ABORT(fs, FR_DISK_ERR);
 8017966:	2601      	movs	r6, #1
}
 8017968:	4630      	mov	r0, r6
				if (clst == 0xFFFFFFFF) ABORT(fs, FR_DISK_ERR);
 801796a:	756e      	strb	r6, [r5, #21]
}
 801796c:	b005      	add	sp, #20
 801796e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	if (!(fp->flag & FA_WRITE)) LEAVE_FF(fs, FR_DENIED);	/* Check access mode */
 8017972:	2607      	movs	r6, #7
 8017974:	e79a      	b.n	80178ac <f_write+0xe0>
						clst = create_chain(&fp->obj, 0);	/* create a new cluster chain */
 8017976:	4651      	mov	r1, sl
 8017978:	4628      	mov	r0, r5
 801797a:	f7fe fdf5 	bl	8016568 <create_chain>
				if (clst == 0) break;		/* Could not allocate a new cluster (disk full) */
 801797e:	2800      	cmp	r0, #0
 8017980:	f47f af58 	bne.w	8017834 <f_write+0x68>
 8017984:	e7c6      	b.n	8017914 <f_write+0x148>
						clst = create_chain(&fp->obj, fp->clust);	/* Follow or stretch cluster chain on the FAT */
 8017986:	69e9      	ldr	r1, [r5, #28]
 8017988:	4628      	mov	r0, r5
 801798a:	f7fe fded 	bl	8016568 <create_chain>
				if (clst == 0) break;		/* Could not allocate a new cluster (disk full) */
 801798e:	2800      	cmp	r0, #0
 8017990:	f47f af50 	bne.w	8017834 <f_write+0x68>
 8017994:	e7be      	b.n	8017914 <f_write+0x148>
				disk_read(fs->drv, fp->buf, sect, 1) != RES_OK) {
 8017996:	7840      	ldrb	r0, [r0, #1]
 8017998:	2301      	movs	r3, #1
 801799a:	465a      	mov	r2, fp
 801799c:	4649      	mov	r1, r9
 801799e:	f7fe f879 	bl	8015a94 <disk_read>
				fp->fptr < fp->obj.objsize &&
 80179a2:	2800      	cmp	r0, #0
 80179a4:	d1df      	bne.n	8017966 <f_write+0x19a>
		wcnt = SS(fs) - (UINT)fp->fptr % SS(fs);	/* Number of bytes left in the sector */
 80179a6:	69a9      	ldr	r1, [r5, #24]
 80179a8:	e78b      	b.n	80178c2 <f_write+0xf6>
					mem_cpy(fp->buf, wbuff + ((fp->sect - sect) * SS(fs)), SS(fs));
 80179aa:	eb04 320b 	add.w	r2, r4, fp, lsl #12
void mem_cpy (void* dst, const void* src, UINT cnt) {
 80179ae:	f105 012f 	add.w	r1, r5, #47	; 0x2f
 80179b2:	f502 5c80 	add.w	ip, r2, #4096	; 0x1000
			*d++ = *s++;
 80179b6:	f812 0b01 	ldrb.w	r0, [r2], #1
 80179ba:	f801 0f01 	strb.w	r0, [r1, #1]!
		} while (--cnt);
 80179be:	4562      	cmp	r2, ip
 80179c0:	d1f9      	bne.n	80179b6 <f_write+0x1ea>
					fp->flag &= (BYTE)~FA_DIRTY;
 80179c2:	7d2a      	ldrb	r2, [r5, #20]
 80179c4:	f002 027f 	and.w	r2, r2, #127	; 0x7f
 80179c8:	752a      	strb	r2, [r5, #20]
 80179ca:	e769      	b.n	80178a0 <f_write+0xd4>

080179cc <f_sync>:
	if (obj && obj->fs && obj->fs->fs_type && obj->id == obj->fs->id) {	/* Test if the object is valid */
 80179cc:	b370      	cbz	r0, 8017a2c <f_sync+0x60>
/*-----------------------------------------------------------------------*/

FRESULT f_sync (
	FIL* fp		/* Pointer to the file object */
)
{
 80179ce:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	if (obj && obj->fs && obj->fs->fs_type && obj->id == obj->fs->id) {	/* Test if the object is valid */
 80179d0:	6803      	ldr	r3, [r0, #0]
 80179d2:	4604      	mov	r4, r0
 80179d4:	b12b      	cbz	r3, 80179e2 <f_sync+0x16>
 80179d6:	781a      	ldrb	r2, [r3, #0]
 80179d8:	b11a      	cbz	r2, 80179e2 <f_sync+0x16>
 80179da:	8881      	ldrh	r1, [r0, #4]
 80179dc:	88da      	ldrh	r2, [r3, #6]
 80179de:	4291      	cmp	r1, r2
 80179e0:	d001      	beq.n	80179e6 <f_sync+0x1a>
	FRESULT res = FR_INVALID_OBJECT;
 80179e2:	2009      	movs	r0, #9
			}
		}
	}

	LEAVE_FF(fs, res);
}
 80179e4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		if (!(disk_status(obj->fs->drv) & STA_NOINIT)) { /* Test if the phsical drive is kept initialized */
 80179e6:	7858      	ldrb	r0, [r3, #1]
 80179e8:	f7fe f83a 	bl	8015a60 <disk_status>
 80179ec:	07c2      	lsls	r2, r0, #31
 80179ee:	d4f8      	bmi.n	80179e2 <f_sync+0x16>
		if (fp->flag & FA_MODIFIED) {	/* Is there any change to the file? */
 80179f0:	7d23      	ldrb	r3, [r4, #20]
 80179f2:	f013 0040 	ands.w	r0, r3, #64	; 0x40
 80179f6:	d0f5      	beq.n	80179e4 <f_sync+0x18>
			if (fp->flag & FA_DIRTY) {	/* Write-back cached data if needed */
 80179f8:	061b      	lsls	r3, r3, #24
	*fs = (res == FR_OK) ? obj->fs : 0;	/* Corresponding filesystem object */
 80179fa:	6826      	ldr	r6, [r4, #0]
			if (fp->flag & FA_DIRTY) {	/* Write-back cached data if needed */
 80179fc:	d447      	bmi.n	8017a8e <f_sync+0xc2>
			tm = GET_FATTIME();				/* Modified time */
 80179fe:	f007 f94f 	bl	801eca0 <get_fattime>
				res = move_window(fs, fp->dir_sect);
 8017a02:	6a67      	ldr	r7, [r4, #36]	; 0x24
	if (sector != fs->winsect) {	/* Window offset changed? */
 8017a04:	6b33      	ldr	r3, [r6, #48]	; 0x30
 8017a06:	429f      	cmp	r7, r3
			tm = GET_FATTIME();				/* Modified time */
 8017a08:	4605      	mov	r5, r0
	if (sector != fs->winsect) {	/* Window offset changed? */
 8017a0a:	d012      	beq.n	8017a32 <f_sync+0x66>
	if (fs->wflag) {	/* Write back the sector if it is dirty */
 8017a0c:	78f3      	ldrb	r3, [r6, #3]
 8017a0e:	2b00      	cmp	r3, #0
 8017a10:	d14a      	bne.n	8017aa8 <f_sync+0xdc>
			if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK) {
 8017a12:	7870      	ldrb	r0, [r6, #1]
 8017a14:	2301      	movs	r3, #1
 8017a16:	463a      	mov	r2, r7
 8017a18:	f106 0134 	add.w	r1, r6, #52	; 0x34
 8017a1c:	f7fe f83a 	bl	8015a94 <disk_read>
 8017a20:	b130      	cbz	r0, 8017a30 <f_sync+0x64>
			fs->winsect = sector;
 8017a22:	f04f 33ff 	mov.w	r3, #4294967295
 8017a26:	6333      	str	r3, [r6, #48]	; 0x30
				res = FR_DISK_ERR;
 8017a28:	2001      	movs	r0, #1
}
 8017a2a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	FRESULT res = FR_INVALID_OBJECT;
 8017a2c:	2009      	movs	r0, #9
}
 8017a2e:	4770      	bx	lr
			fs->winsect = sector;
 8017a30:	6337      	str	r7, [r6, #48]	; 0x30
					dir = fp->dir_ptr;
 8017a32:	6aa3      	ldr	r3, [r4, #40]	; 0x28
					dir[DIR_Attr] |= AM_ARC;						/* Set archive bit */
 8017a34:	7ada      	ldrb	r2, [r3, #11]
 8017a36:	f042 0220 	orr.w	r2, r2, #32
 8017a3a:	72da      	strb	r2, [r3, #11]
					st_clust(fp->obj.fs, dir, fp->obj.sclust);		/* Update file allocation info  */
 8017a3c:	68a2      	ldr	r2, [r4, #8]
 8017a3e:	6821      	ldr	r1, [r4, #0]
	*ptr++ = (BYTE)val; val >>= 8;
 8017a40:	769a      	strb	r2, [r3, #26]
 8017a42:	f3c2 2007 	ubfx	r0, r2, #8, #8
	*ptr++ = (BYTE)val;
 8017a46:	76d8      	strb	r0, [r3, #27]
	if (fs->fs_type == FS_FAT32) {
 8017a48:	7809      	ldrb	r1, [r1, #0]
 8017a4a:	2903      	cmp	r1, #3
 8017a4c:	d103      	bne.n	8017a56 <f_sync+0x8a>
		st_word(dir + DIR_FstClusHI, (WORD)(cl >> 16));
 8017a4e:	0c12      	lsrs	r2, r2, #16
	*ptr++ = (BYTE)val; val >>= 8;
 8017a50:	751a      	strb	r2, [r3, #20]
 8017a52:	0a12      	lsrs	r2, r2, #8
	*ptr++ = (BYTE)val;
 8017a54:	755a      	strb	r2, [r3, #21]
					st_dword(dir + DIR_FileSize, (DWORD)fp->obj.objsize);	/* Update file size */
 8017a56:	68e2      	ldr	r2, [r4, #12]
	*ptr++ = (BYTE)val; val >>= 8;
 8017a58:	771a      	strb	r2, [r3, #28]
 8017a5a:	0a11      	lsrs	r1, r2, #8
	*ptr++ = (BYTE)val; val >>= 8;
 8017a5c:	7759      	strb	r1, [r3, #29]
 8017a5e:	0c11      	lsrs	r1, r2, #16
	*ptr++ = (BYTE)val; val >>= 8;
 8017a60:	0e12      	lsrs	r2, r2, #24
	*ptr++ = (BYTE)val;
 8017a62:	77da      	strb	r2, [r3, #31]
	*ptr++ = (BYTE)val; val >>= 8;
 8017a64:	0a2a      	lsrs	r2, r5, #8
	*ptr++ = (BYTE)val; val >>= 8;
 8017a66:	75da      	strb	r2, [r3, #23]
 8017a68:	0c2a      	lsrs	r2, r5, #16
	*ptr++ = (BYTE)val; val >>= 8;
 8017a6a:	759d      	strb	r5, [r3, #22]
	*ptr++ = (BYTE)val; val >>= 8;
 8017a6c:	761a      	strb	r2, [r3, #24]
 8017a6e:	0e2d      	lsrs	r5, r5, #24
	*ptr++ = (BYTE)val; val >>= 8;
 8017a70:	2200      	movs	r2, #0
	*ptr++ = (BYTE)val; val >>= 8;
 8017a72:	7799      	strb	r1, [r3, #30]
	*ptr++ = (BYTE)val;
 8017a74:	765d      	strb	r5, [r3, #25]
	*ptr++ = (BYTE)val; val >>= 8;
 8017a76:	749a      	strb	r2, [r3, #18]
	*ptr++ = (BYTE)val;
 8017a78:	74da      	strb	r2, [r3, #19]
					fs->wflag = 1;
 8017a7a:	2301      	movs	r3, #1
 8017a7c:	70f3      	strb	r3, [r6, #3]
					res = sync_fs(fs);					/* Restore it to the directory */
 8017a7e:	4630      	mov	r0, r6
 8017a80:	f7fe f9b0 	bl	8015de4 <sync_fs>
					fp->flag &= (BYTE)~FA_MODIFIED;
 8017a84:	7d23      	ldrb	r3, [r4, #20]
 8017a86:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 8017a8a:	7523      	strb	r3, [r4, #20]
}
 8017a8c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
				if (disk_write(fs->drv, fp->buf, fp->sect, 1) != RES_OK) LEAVE_FF(fs, FR_DISK_ERR);
 8017a8e:	6a22      	ldr	r2, [r4, #32]
 8017a90:	7870      	ldrb	r0, [r6, #1]
 8017a92:	2301      	movs	r3, #1
 8017a94:	f104 0130 	add.w	r1, r4, #48	; 0x30
 8017a98:	f7fe f80a 	bl	8015ab0 <disk_write>
 8017a9c:	b950      	cbnz	r0, 8017ab4 <f_sync+0xe8>
				fp->flag &= (BYTE)~FA_DIRTY;
 8017a9e:	7d23      	ldrb	r3, [r4, #20]
 8017aa0:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 8017aa4:	7523      	strb	r3, [r4, #20]
 8017aa6:	e7aa      	b.n	80179fe <f_sync+0x32>
 8017aa8:	4630      	mov	r0, r6
 8017aaa:	f7fe f971 	bl	8015d90 <sync_window.part.0>
		if (res == FR_OK) {			/* Fill sector window with new data */
 8017aae:	2800      	cmp	r0, #0
 8017ab0:	d0af      	beq.n	8017a12 <f_sync+0x46>
}
 8017ab2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
				if (disk_write(fs->drv, fp->buf, fp->sect, 1) != RES_OK) LEAVE_FF(fs, FR_DISK_ERR);
 8017ab4:	2001      	movs	r0, #1
}
 8017ab6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

08017ab8 <f_close>:
/*-----------------------------------------------------------------------*/

FRESULT f_close (
	FIL* fp		/* Pointer to the file object to be closed */
)
{
 8017ab8:	b510      	push	{r4, lr}
 8017aba:	b082      	sub	sp, #8
 8017abc:	4604      	mov	r4, r0
	FRESULT res;
	FATFS *fs;

#if !_FS_READONLY
	res = f_sync(fp);					/* Flush cached data */
 8017abe:	f7ff ff85 	bl	80179cc <f_sync>
	if (res == FR_OK)
 8017ac2:	b108      	cbz	r0, 8017ac8 <f_close+0x10>
			unlock_fs(fs, FR_OK);		/* Unlock volume */
#endif
		}
	}
	return res;
}
 8017ac4:	b002      	add	sp, #8
 8017ac6:	bd10      	pop	{r4, pc}
		res = validate(&fp->obj, &fs);	/* Lock volume */
 8017ac8:	a901      	add	r1, sp, #4
 8017aca:	4620      	mov	r0, r4
 8017acc:	f7fe f8d2 	bl	8015c74 <validate>
		if (res == FR_OK) {
 8017ad0:	2800      	cmp	r0, #0
 8017ad2:	d1f7      	bne.n	8017ac4 <f_close+0xc>
	if (--i < _FS_LOCK) {	/* Shift index number origin from 0 */
 8017ad4:	6923      	ldr	r3, [r4, #16]
 8017ad6:	3b01      	subs	r3, #1
 8017ad8:	2b01      	cmp	r3, #1
 8017ada:	d815      	bhi.n	8017b08 <f_close+0x50>
		n = Files[i].ctr;
 8017adc:	490b      	ldr	r1, [pc, #44]	; (8017b0c <f_close+0x54>)
 8017ade:	ea4f 1c03 	mov.w	ip, r3, lsl #4
 8017ae2:	eb01 1303 	add.w	r3, r1, r3, lsl #4
 8017ae6:	899a      	ldrh	r2, [r3, #12]
		if (n == 0x100) n = 0;		/* If write mode open, delete the entry */
 8017ae8:	f5b2 7f80 	cmp.w	r2, #256	; 0x100
 8017aec:	d007      	beq.n	8017afe <f_close+0x46>
		if (n > 0) n--;				/* Decrement read mode open count */
 8017aee:	b13a      	cbz	r2, 8017b00 <f_close+0x48>
 8017af0:	3a01      	subs	r2, #1
 8017af2:	b292      	uxth	r2, r2
		Files[i].ctr = n;
 8017af4:	819a      	strh	r2, [r3, #12]
		if (n == 0) Files[i].fs = 0;	/* Delete the entry if open count gets zero */
 8017af6:	b11a      	cbz	r2, 8017b00 <f_close+0x48>
				fp->obj.fs = 0;			/* Invalidate file object */
 8017af8:	2300      	movs	r3, #0
 8017afa:	6023      	str	r3, [r4, #0]
 8017afc:	e7e2      	b.n	8017ac4 <f_close+0xc>
		Files[i].ctr = n;
 8017afe:	8198      	strh	r0, [r3, #12]
		if (n == 0) Files[i].fs = 0;	/* Delete the entry if open count gets zero */
 8017b00:	2300      	movs	r3, #0
 8017b02:	f841 300c 	str.w	r3, [r1, ip]
			if (res == FR_OK)
 8017b06:	e7f7      	b.n	8017af8 <f_close+0x40>
		res = FR_INT_ERR;			/* Invalid index nunber */
 8017b08:	2002      	movs	r0, #2
 8017b0a:	e7db      	b.n	8017ac4 <f_close+0xc>
 8017b0c:	20003310 	.word	0x20003310

08017b10 <f_lseek>:

FRESULT f_lseek (
	FIL* fp,		/* Pointer to the file object */
	FSIZE_t ofs		/* File pointer from top of file */
)
{
 8017b10:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8017b14:	b085      	sub	sp, #20
 8017b16:	460e      	mov	r6, r1
	FSIZE_t ifptr;
#if _USE_FASTSEEK
	DWORD cl, pcl, ncl, tcl, dsc, tlen, ulen, *tbl;
#endif

	res = validate(&fp->obj, &fs);		/* Check validity of the file object */
 8017b18:	a903      	add	r1, sp, #12
{
 8017b1a:	4604      	mov	r4, r0
	res = validate(&fp->obj, &fs);		/* Check validity of the file object */
 8017b1c:	f7fe f8aa 	bl	8015c74 <validate>
	if (res == FR_OK) res = (FRESULT)fp->err;
 8017b20:	4605      	mov	r5, r0
 8017b22:	b960      	cbnz	r0, 8017b3e <f_lseek+0x2e>
 8017b24:	7d65      	ldrb	r5, [r4, #21]
#if _FS_EXFAT && !_FS_READONLY
	if (res == FR_OK && fs->fs_type == FS_EXFAT) {
		res = fill_last_frag(&fp->obj, fp->clust, 0xFFFFFFFF);	/* Fill last fragment on the FAT if needed */
	}
#endif
	if (res != FR_OK) LEAVE_FF(fs, res);
 8017b26:	b955      	cbnz	r5, 8017b3e <f_lseek+0x2e>

#if _USE_FASTSEEK
	if (fp->cltbl) {	/* Fast seek */
 8017b28:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 8017b2a:	b163      	cbz	r3, 8017b46 <f_lseek+0x36>
		if (ofs == CREATE_LINKMAP) {	/* Create CLMT */
 8017b2c:	1c77      	adds	r7, r6, #1
 8017b2e:	d06e      	beq.n	8017c0e <f_lseek+0xfe>
				*tbl = 0;		/* Terminate table */
			} else {
				res = FR_NOT_ENOUGH_CORE;	/* Given table size is smaller than required */
			}
		} else {						/* Fast seek */
			if (ofs > fp->obj.objsize) ofs = fp->obj.objsize;	/* Clip offset at the file size */
 8017b30:	68e2      	ldr	r2, [r4, #12]
 8017b32:	4296      	cmp	r6, r2
 8017b34:	bf28      	it	cs
 8017b36:	4616      	movcs	r6, r2
			fp->fptr = ofs;				/* Set file pointer */
 8017b38:	61a6      	str	r6, [r4, #24]
			if (ofs) {
 8017b3a:	2e00      	cmp	r6, #0
 8017b3c:	d14c      	bne.n	8017bd8 <f_lseek+0xc8>
			fp->sect = nsect;
		}
	}

	LEAVE_FF(fs, res);
}
 8017b3e:	4628      	mov	r0, r5
 8017b40:	b005      	add	sp, #20
 8017b42:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		if (ofs > fp->obj.objsize && (_FS_READONLY || !(fp->flag & FA_WRITE))) {	/* In read-only mode, clip offset with the file size */
 8017b46:	68e3      	ldr	r3, [r4, #12]
 8017b48:	42b3      	cmp	r3, r6
 8017b4a:	d204      	bcs.n	8017b56 <f_lseek+0x46>
 8017b4c:	7d22      	ldrb	r2, [r4, #20]
 8017b4e:	f012 0f02 	tst.w	r2, #2
 8017b52:	bf08      	it	eq
 8017b54:	461e      	moveq	r6, r3
		fp->fptr = nsect = 0;
 8017b56:	2200      	movs	r2, #0
		ifptr = fp->fptr;
 8017b58:	69a3      	ldr	r3, [r4, #24]
		fp->fptr = nsect = 0;
 8017b5a:	61a2      	str	r2, [r4, #24]
		if (ofs) {
 8017b5c:	2e00      	cmp	r6, #0
 8017b5e:	d0ee      	beq.n	8017b3e <f_lseek+0x2e>
			bcs = (DWORD)fs->csize * SS(fs);	/* Cluster size (byte) */
 8017b60:	9a03      	ldr	r2, [sp, #12]
 8017b62:	f8b2 800a 	ldrh.w	r8, [r2, #10]
 8017b66:	ea4f 3808 	mov.w	r8, r8, lsl #12
			if (ifptr > 0 &&
 8017b6a:	2b00      	cmp	r3, #0
 8017b6c:	d049      	beq.n	8017c02 <f_lseek+0xf2>
				(ofs - 1) / bcs >= (ifptr - 1) / bcs) {	/* When seek to same or following cluster, */
 8017b6e:	3b01      	subs	r3, #1
 8017b70:	1e72      	subs	r2, r6, #1
 8017b72:	fbb3 f1f8 	udiv	r1, r3, r8
 8017b76:	fbb2 f2f8 	udiv	r2, r2, r8
			if (ifptr > 0 &&
 8017b7a:	428a      	cmp	r2, r1
 8017b7c:	d341      	bcc.n	8017c02 <f_lseek+0xf2>
				fp->fptr = (ifptr - 1) & ~(FSIZE_t)(bcs - 1);	/* start from the current cluster */
 8017b7e:	f1c8 0200 	rsb	r2, r8, #0
 8017b82:	4013      	ands	r3, r2
				clst = fp->clust;
 8017b84:	69e7      	ldr	r7, [r4, #28]
				fp->fptr = (ifptr - 1) & ~(FSIZE_t)(bcs - 1);	/* start from the current cluster */
 8017b86:	61a3      	str	r3, [r4, #24]
				ofs -= fp->fptr;
 8017b88:	1af6      	subs	r6, r6, r3
			if (clst != 0) {
 8017b8a:	2f00      	cmp	r7, #0
 8017b8c:	f000 80b0 	beq.w	8017cf0 <f_lseek+0x1e0>
				while (ofs > bcs) {						/* Cluster following loop */
 8017b90:	4546      	cmp	r6, r8
 8017b92:	d813      	bhi.n	8017bbc <f_lseek+0xac>
 8017b94:	e0e1      	b.n	8017d5a <f_lseek+0x24a>
						clst = create_chain(&fp->obj, clst);	/* Follow chain with forceed stretch */
 8017b96:	f7fe fce7 	bl	8016568 <create_chain>
						if (clst == 0) {				/* Clip file size in case of disk full */
 8017b9a:	4607      	mov	r7, r0
 8017b9c:	2800      	cmp	r0, #0
 8017b9e:	f000 80a6 	beq.w	8017cee <f_lseek+0x1de>
					if (clst == 0xFFFFFFFF) ABORT(fs, FR_DISK_ERR);
 8017ba2:	1c7b      	adds	r3, r7, #1
 8017ba4:	d06a      	beq.n	8017c7c <f_lseek+0x16c>
					if (clst <= 1 || clst >= fs->n_fatent) ABORT(fs, FR_INT_ERR);
 8017ba6:	2f01      	cmp	r7, #1
 8017ba8:	d962      	bls.n	8017c70 <f_lseek+0x160>
 8017baa:	9b03      	ldr	r3, [sp, #12]
 8017bac:	699b      	ldr	r3, [r3, #24]
 8017bae:	42bb      	cmp	r3, r7
 8017bb0:	d95e      	bls.n	8017c70 <f_lseek+0x160>
				while (ofs > bcs) {						/* Cluster following loop */
 8017bb2:	45b0      	cmp	r8, r6
					ofs -= bcs; fp->fptr += bcs;
 8017bb4:	69a3      	ldr	r3, [r4, #24]
					fp->clust = clst;
 8017bb6:	61e7      	str	r7, [r4, #28]
				while (ofs > bcs) {						/* Cluster following loop */
 8017bb8:	f080 80cf 	bcs.w	8017d5a <f_lseek+0x24a>
					if (fp->flag & FA_WRITE) {			/* Check if in write mode or not */
 8017bbc:	7d22      	ldrb	r2, [r4, #20]
					ofs -= bcs; fp->fptr += bcs;
 8017bbe:	4443      	add	r3, r8
					if (fp->flag & FA_WRITE) {			/* Check if in write mode or not */
 8017bc0:	0792      	lsls	r2, r2, #30
						clst = create_chain(&fp->obj, clst);	/* Follow chain with forceed stretch */
 8017bc2:	4639      	mov	r1, r7
 8017bc4:	4620      	mov	r0, r4
					ofs -= bcs; fp->fptr += bcs;
 8017bc6:	61a3      	str	r3, [r4, #24]
 8017bc8:	eba6 0608 	sub.w	r6, r6, r8
					if (fp->flag & FA_WRITE) {			/* Check if in write mode or not */
 8017bcc:	d4e3      	bmi.n	8017b96 <f_lseek+0x86>
						clst = get_fat(&fp->obj, clst);	/* Follow cluster chain if not in write mode */
 8017bce:	6820      	ldr	r0, [r4, #0]
 8017bd0:	f7fe fbe2 	bl	8016398 <get_fat.isra.0>
 8017bd4:	4607      	mov	r7, r0
 8017bd6:	e7e4      	b.n	8017ba2 <f_lseek+0x92>
	cl = (DWORD)(ofs / SS(fs) / fs->csize);	/* Cluster order from top of the file */
 8017bd8:	6822      	ldr	r2, [r4, #0]
	tbl = fp->cltbl + 1;	/* Top of CLMT */
 8017bda:	1d19      	adds	r1, r3, #4
		ncl = *tbl++;			/* Number of cluters in the fragment */
 8017bdc:	685b      	ldr	r3, [r3, #4]
	cl = (DWORD)(ofs / SS(fs) / fs->csize);	/* Cluster order from top of the file */
 8017bde:	8952      	ldrh	r2, [r2, #10]
				fp->clust = clmt_clust(fp, ofs - 1);
 8017be0:	1e70      	subs	r0, r6, #1
	cl = (DWORD)(ofs / SS(fs) / fs->csize);	/* Cluster order from top of the file */
 8017be2:	0b00      	lsrs	r0, r0, #12
 8017be4:	fbb0 f2f2 	udiv	r2, r0, r2
		if (ncl == 0) return 0;	/* End of table? (error) */
 8017be8:	b92b      	cbnz	r3, 8017bf6 <f_lseek+0xe6>
 8017bea:	e04a      	b.n	8017c82 <f_lseek+0x172>
		cl -= ncl; tbl++;		/* Next fragment */
 8017bec:	1ad2      	subs	r2, r2, r3
		ncl = *tbl++;			/* Number of cluters in the fragment */
 8017bee:	f851 3f08 	ldr.w	r3, [r1, #8]!
		if (ncl == 0) return 0;	/* End of table? (error) */
 8017bf2:	2b00      	cmp	r3, #0
 8017bf4:	d045      	beq.n	8017c82 <f_lseek+0x172>
		if (cl < ncl) break;	/* In this fragment? */
 8017bf6:	4293      	cmp	r3, r2
 8017bf8:	d9f8      	bls.n	8017bec <f_lseek+0xdc>
	return cl + *tbl;	/* Return the cluster number */
 8017bfa:	684b      	ldr	r3, [r1, #4]
 8017bfc:	4413      	add	r3, r2
	clst -= 2;
 8017bfe:	1e9a      	subs	r2, r3, #2
	return cl + *tbl;	/* Return the cluster number */
 8017c00:	e041      	b.n	8017c86 <f_lseek+0x176>
				clst = fp->obj.sclust;					/* start from the first cluster */
 8017c02:	68a7      	ldr	r7, [r4, #8]
				if (clst == 0) {						/* If no cluster chain, create a new chain */
 8017c04:	2f00      	cmp	r7, #0
 8017c06:	d066      	beq.n	8017cd6 <f_lseek+0x1c6>
 8017c08:	2300      	movs	r3, #0
				fp->clust = clst;
 8017c0a:	61e7      	str	r7, [r4, #28]
 8017c0c:	e7bd      	b.n	8017b8a <f_lseek+0x7a>
			tlen = *tbl++; ulen = 2;	/* Given table size and required table size */
 8017c0e:	461e      	mov	r6, r3
			cl = fp->obj.sclust;		/* Origin of the chain */
 8017c10:	68a7      	ldr	r7, [r4, #8]
			tlen = *tbl++; ulen = 2;	/* Given table size and required table size */
 8017c12:	f856 9b04 	ldr.w	r9, [r6], #4
 8017c16:	f04f 0802 	mov.w	r8, #2
			if (cl) {
 8017c1a:	b9b7      	cbnz	r7, 8017c4a <f_lseek+0x13a>
			if (ulen <= tlen) {
 8017c1c:	45c8      	cmp	r8, r9
			*fp->cltbl = ulen;	/* Number of items used */
 8017c1e:	f8c3 8000 	str.w	r8, [r3]
			if (ulen <= tlen) {
 8017c22:	f200 8088 	bhi.w	8017d36 <f_lseek+0x226>
				*tbl = 0;		/* Terminate table */
 8017c26:	2300      	movs	r3, #0
 8017c28:	6033      	str	r3, [r6, #0]
 8017c2a:	e788      	b.n	8017b3e <f_lseek+0x2e>
					tcl = cl; ncl = 0; ulen += 2;	/* Top, length and used items */
 8017c2c:	f108 0802 	add.w	r8, r8, #2
					if (ulen <= tlen) {		/* Store the length and top of the fragment */
 8017c30:	45c1      	cmp	r9, r8
 8017c32:	d304      	bcc.n	8017c3e <f_lseek+0x12e>
						*tbl++ = ncl; *tbl++ = tcl;
 8017c34:	4633      	mov	r3, r6
 8017c36:	f843 bb08 	str.w	fp, [r3], #8
 8017c3a:	6077      	str	r7, [r6, #4]
 8017c3c:	461e      	mov	r6, r3
				} while (cl < fs->n_fatent);	/* Repeat until end of chain */
 8017c3e:	9b03      	ldr	r3, [sp, #12]
 8017c40:	699b      	ldr	r3, [r3, #24]
 8017c42:	428b      	cmp	r3, r1
 8017c44:	f240 80b0 	bls.w	8017da8 <f_lseek+0x298>
 8017c48:	460f      	mov	r7, r1
					tcl = cl; ncl = 0; ulen += 2;	/* Top, length and used items */
 8017c4a:	4639      	mov	r1, r7
 8017c4c:	f04f 0b00 	mov.w	fp, #0
 8017c50:	e003      	b.n	8017c5a <f_lseek+0x14a>
						if (cl == 0xFFFFFFFF) ABORT(fs, FR_DISK_ERR);
 8017c52:	1c48      	adds	r0, r1, #1
 8017c54:	d012      	beq.n	8017c7c <f_lseek+0x16c>
					} while (cl == pcl + 1);
 8017c56:	458a      	cmp	sl, r1
 8017c58:	d1e8      	bne.n	8017c2c <f_lseek+0x11c>
						cl = get_fat(&fp->obj, cl);
 8017c5a:	6820      	ldr	r0, [r4, #0]
 8017c5c:	468a      	mov	sl, r1
 8017c5e:	f7fe fb9b 	bl	8016398 <get_fat.isra.0>
						if (cl <= 1) ABORT(fs, FR_INT_ERR);
 8017c62:	2801      	cmp	r0, #1
						cl = get_fat(&fp->obj, cl);
 8017c64:	4601      	mov	r1, r0
					} while (cl == pcl + 1);
 8017c66:	f10a 0a01 	add.w	sl, sl, #1
						pcl = cl; ncl++;
 8017c6a:	f10b 0b01 	add.w	fp, fp, #1
						if (cl <= 1) ABORT(fs, FR_INT_ERR);
 8017c6e:	d8f0      	bhi.n	8017c52 <f_lseek+0x142>
 8017c70:	2502      	movs	r5, #2
}
 8017c72:	4628      	mov	r0, r5
						if (cl <= 1) ABORT(fs, FR_INT_ERR);
 8017c74:	7565      	strb	r5, [r4, #21]
}
 8017c76:	b005      	add	sp, #20
 8017c78:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
						if (cl == 0xFFFFFFFF) ABORT(fs, FR_DISK_ERR);
 8017c7c:	2501      	movs	r5, #1
 8017c7e:	7565      	strb	r5, [r4, #21]
 8017c80:	e75d      	b.n	8017b3e <f_lseek+0x2e>
 8017c82:	f06f 0201 	mvn.w	r2, #1
				dsc = clust2sect(fs, fp->clust);
 8017c86:	9f03      	ldr	r7, [sp, #12]
				fp->clust = clmt_clust(fp, ofs - 1);
 8017c88:	61e3      	str	r3, [r4, #28]
	if (clst >= fs->n_fatent - 2) return 0;		/* Invalid cluster# */
 8017c8a:	69bb      	ldr	r3, [r7, #24]
 8017c8c:	3b02      	subs	r3, #2
 8017c8e:	4293      	cmp	r3, r2
 8017c90:	d9ee      	bls.n	8017c70 <f_lseek+0x160>
	return clst * fs->csize + fs->database;
 8017c92:	8979      	ldrh	r1, [r7, #10]
 8017c94:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8017c96:	fb02 3301 	mla	r3, r2, r1, r3
				if (!dsc) ABORT(fs, FR_INT_ERR);
 8017c9a:	2b00      	cmp	r3, #0
 8017c9c:	d0e8      	beq.n	8017c70 <f_lseek+0x160>
				if (fp->fptr % SS(fs) && dsc != fp->sect) {	/* Refill sector cache if needed */
 8017c9e:	f3c6 060b 	ubfx	r6, r6, #0, #12
 8017ca2:	2e00      	cmp	r6, #0
 8017ca4:	f43f af4b 	beq.w	8017b3e <f_lseek+0x2e>
				dsc += (DWORD)((ofs - 1) / SS(fs)) & (fs->csize - 1);
 8017ca8:	3901      	subs	r1, #1
				if (fp->fptr % SS(fs) && dsc != fp->sect) {	/* Refill sector cache if needed */
 8017caa:	6a22      	ldr	r2, [r4, #32]
				dsc += (DWORD)((ofs - 1) / SS(fs)) & (fs->csize - 1);
 8017cac:	4008      	ands	r0, r1
 8017cae:	18c6      	adds	r6, r0, r3
				if (fp->fptr % SS(fs) && dsc != fp->sect) {	/* Refill sector cache if needed */
 8017cb0:	42b2      	cmp	r2, r6
 8017cb2:	f43f af44 	beq.w	8017b3e <f_lseek+0x2e>
					if (fp->flag & FA_DIRTY) {		/* Write-back dirty sector cache */
 8017cb6:	f994 3014 	ldrsb.w	r3, [r4, #20]
 8017cba:	2b00      	cmp	r3, #0
						if (disk_write(fs->drv, fp->buf, fp->sect, 1) != RES_OK) ABORT(fs, FR_DISK_ERR);
 8017cbc:	f104 0130 	add.w	r1, r4, #48	; 0x30
					if (fp->flag & FA_DIRTY) {		/* Write-back dirty sector cache */
 8017cc0:	db61      	blt.n	8017d86 <f_lseek+0x276>
					if (disk_read(fs->drv, fp->buf, dsc, 1) != RES_OK) ABORT(fs, FR_DISK_ERR);	/* Load current sector */
 8017cc2:	7878      	ldrb	r0, [r7, #1]
 8017cc4:	2301      	movs	r3, #1
 8017cc6:	4632      	mov	r2, r6
 8017cc8:	f7fd fee4 	bl	8015a94 <disk_read>
 8017ccc:	4605      	mov	r5, r0
 8017cce:	2800      	cmp	r0, #0
 8017cd0:	d1d4      	bne.n	8017c7c <f_lseek+0x16c>
					fp->sect = dsc;
 8017cd2:	6226      	str	r6, [r4, #32]
 8017cd4:	e733      	b.n	8017b3e <f_lseek+0x2e>
					clst = create_chain(&fp->obj, 0);
 8017cd6:	4639      	mov	r1, r7
 8017cd8:	4620      	mov	r0, r4
 8017cda:	f7fe fc45 	bl	8016568 <create_chain>
					if (clst == 1) ABORT(fs, FR_INT_ERR);
 8017cde:	2801      	cmp	r0, #1
					clst = create_chain(&fp->obj, 0);
 8017ce0:	4607      	mov	r7, r0
					if (clst == 1) ABORT(fs, FR_INT_ERR);
 8017ce2:	d0c5      	beq.n	8017c70 <f_lseek+0x160>
					if (clst == 0xFFFFFFFF) ABORT(fs, FR_DISK_ERR);
 8017ce4:	1c41      	adds	r1, r0, #1
 8017ce6:	d0c9      	beq.n	8017c7c <f_lseek+0x16c>
					ofs -= bcs; fp->fptr += bcs;
 8017ce8:	69a3      	ldr	r3, [r4, #24]
					fp->obj.sclust = clst;
 8017cea:	60a0      	str	r0, [r4, #8]
 8017cec:	e78d      	b.n	8017c0a <f_lseek+0xfa>
		if (!_FS_READONLY && fp->fptr > fp->obj.objsize) {		/* Set file change flag if the file size is extended */
 8017cee:	69a3      	ldr	r3, [r4, #24]
 8017cf0:	68e2      	ldr	r2, [r4, #12]
 8017cf2:	429a      	cmp	r2, r3
			fp->flag |= FA_MODIFIED;
 8017cf4:	bf3e      	ittt	cc
 8017cf6:	7d22      	ldrbcc	r2, [r4, #20]
			fp->obj.objsize = fp->fptr;
 8017cf8:	60e3      	strcc	r3, [r4, #12]
			fp->flag |= FA_MODIFIED;
 8017cfa:	f042 0240 	orrcc.w	r2, r2, #64	; 0x40
		if (fp->fptr % SS(fs) && nsect != fp->sect) {	/* Fill sector cache if needed */
 8017cfe:	f3c3 030b 	ubfx	r3, r3, #0, #12
			fp->flag |= FA_MODIFIED;
 8017d02:	bf38      	it	cc
 8017d04:	7522      	strbcc	r2, [r4, #20]
		if (fp->fptr % SS(fs) && nsect != fp->sect) {	/* Fill sector cache if needed */
 8017d06:	2b00      	cmp	r3, #0
 8017d08:	f43f af19 	beq.w	8017b3e <f_lseek+0x2e>
 8017d0c:	6a22      	ldr	r2, [r4, #32]
 8017d0e:	42ba      	cmp	r2, r7
 8017d10:	f43f af15 	beq.w	8017b3e <f_lseek+0x2e>
			if (fp->flag & FA_DIRTY) {			/* Write-back dirty sector cache */
 8017d14:	f994 3014 	ldrsb.w	r3, [r4, #20]
 8017d18:	2b00      	cmp	r3, #0
 8017d1a:	db0e      	blt.n	8017d3a <f_lseek+0x22a>
						if (disk_write(fs->drv, fp->buf, fp->sect, 1) != RES_OK) ABORT(fs, FR_DISK_ERR);
 8017d1c:	f104 0130 	add.w	r1, r4, #48	; 0x30
			if (disk_read(fs->drv, fp->buf, nsect, 1) != RES_OK) ABORT(fs, FR_DISK_ERR);	/* Fill sector cache */
 8017d20:	9a03      	ldr	r2, [sp, #12]
 8017d22:	2301      	movs	r3, #1
 8017d24:	7850      	ldrb	r0, [r2, #1]
 8017d26:	463a      	mov	r2, r7
 8017d28:	f7fd feb4 	bl	8015a94 <disk_read>
 8017d2c:	4605      	mov	r5, r0
 8017d2e:	2800      	cmp	r0, #0
 8017d30:	d1a4      	bne.n	8017c7c <f_lseek+0x16c>
			fp->sect = nsect;
 8017d32:	6227      	str	r7, [r4, #32]
 8017d34:	e703      	b.n	8017b3e <f_lseek+0x2e>
				res = FR_NOT_ENOUGH_CORE;	/* Given table size is smaller than required */
 8017d36:	2511      	movs	r5, #17
 8017d38:	e701      	b.n	8017b3e <f_lseek+0x2e>
				if (disk_write(fs->drv, fp->buf, fp->sect, 1) != RES_OK) ABORT(fs, FR_DISK_ERR);
 8017d3a:	9b03      	ldr	r3, [sp, #12]
 8017d3c:	f104 0130 	add.w	r1, r4, #48	; 0x30
 8017d40:	7858      	ldrb	r0, [r3, #1]
 8017d42:	9101      	str	r1, [sp, #4]
 8017d44:	2301      	movs	r3, #1
 8017d46:	f7fd feb3 	bl	8015ab0 <disk_write>
 8017d4a:	2800      	cmp	r0, #0
 8017d4c:	d196      	bne.n	8017c7c <f_lseek+0x16c>
				fp->flag &= (BYTE)~FA_DIRTY;
 8017d4e:	7d23      	ldrb	r3, [r4, #20]
 8017d50:	9901      	ldr	r1, [sp, #4]
 8017d52:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 8017d56:	7523      	strb	r3, [r4, #20]
 8017d58:	e7e2      	b.n	8017d20 <f_lseek+0x210>
				fp->fptr += ofs;
 8017d5a:	4433      	add	r3, r6
				if (ofs % SS(fs)) {
 8017d5c:	f3c6 020b 	ubfx	r2, r6, #0, #12
				fp->fptr += ofs;
 8017d60:	61a3      	str	r3, [r4, #24]
				if (ofs % SS(fs)) {
 8017d62:	b1fa      	cbz	r2, 8017da4 <f_lseek+0x294>
					nsect = clust2sect(fs, clst);	/* Current sector */
 8017d64:	9903      	ldr	r1, [sp, #12]
	if (clst >= fs->n_fatent - 2) return 0;		/* Invalid cluster# */
 8017d66:	698a      	ldr	r2, [r1, #24]
	clst -= 2;
 8017d68:	1eb8      	subs	r0, r7, #2
	if (clst >= fs->n_fatent - 2) return 0;		/* Invalid cluster# */
 8017d6a:	3a02      	subs	r2, #2
 8017d6c:	4290      	cmp	r0, r2
 8017d6e:	f4bf af7f 	bcs.w	8017c70 <f_lseek+0x160>
	return clst * fs->csize + fs->database;
 8017d72:	894a      	ldrh	r2, [r1, #10]
 8017d74:	6acf      	ldr	r7, [r1, #44]	; 0x2c
 8017d76:	fb00 7702 	mla	r7, r0, r2, r7
					if (!nsect) ABORT(fs, FR_INT_ERR);
 8017d7a:	2f00      	cmp	r7, #0
 8017d7c:	f43f af78 	beq.w	8017c70 <f_lseek+0x160>
					nsect += (DWORD)(ofs / SS(fs));
 8017d80:	eb07 3716 	add.w	r7, r7, r6, lsr #12
 8017d84:	e7b4      	b.n	8017cf0 <f_lseek+0x1e0>
						if (disk_write(fs->drv, fp->buf, fp->sect, 1) != RES_OK) ABORT(fs, FR_DISK_ERR);
 8017d86:	7878      	ldrb	r0, [r7, #1]
 8017d88:	9101      	str	r1, [sp, #4]
 8017d8a:	2301      	movs	r3, #1
 8017d8c:	f7fd fe90 	bl	8015ab0 <disk_write>
 8017d90:	2800      	cmp	r0, #0
 8017d92:	f47f af73 	bne.w	8017c7c <f_lseek+0x16c>
						fp->flag &= (BYTE)~FA_DIRTY;
 8017d96:	7d23      	ldrb	r3, [r4, #20]
					if (disk_read(fs->drv, fp->buf, dsc, 1) != RES_OK) ABORT(fs, FR_DISK_ERR);	/* Load current sector */
 8017d98:	9f03      	ldr	r7, [sp, #12]
						fp->flag &= (BYTE)~FA_DIRTY;
 8017d9a:	9901      	ldr	r1, [sp, #4]
 8017d9c:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 8017da0:	7523      	strb	r3, [r4, #20]
 8017da2:	e78e      	b.n	8017cc2 <f_lseek+0x1b2>
		fp->fptr = nsect = 0;
 8017da4:	4617      	mov	r7, r2
 8017da6:	e7a3      	b.n	8017cf0 <f_lseek+0x1e0>
			*fp->cltbl = ulen;	/* Number of items used */
 8017da8:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 8017daa:	e737      	b.n	8017c1c <f_lseek+0x10c>

08017dac <f_opendir>:

FRESULT f_opendir (
	DIR* dp,			/* Pointer to directory object to create */
	const TCHAR* path	/* Pointer to the directory path */
)
{
 8017dac:	b570      	push	{r4, r5, r6, lr}
 8017dae:	b084      	sub	sp, #16
 8017db0:	9101      	str	r1, [sp, #4]
	FATFS *fs;
	_FDID *obj;
	DEF_NAMBUF


	if (!dp) return FR_INVALID_OBJECT;
 8017db2:	2800      	cmp	r0, #0
 8017db4:	d044      	beq.n	8017e40 <f_opendir+0x94>

	/* Get logical drive */
	obj = &dp->obj;
 8017db6:	4605      	mov	r5, r0
	res = find_volume(&path, &fs, 0);
 8017db8:	2200      	movs	r2, #0
 8017dba:	a903      	add	r1, sp, #12
 8017dbc:	a801      	add	r0, sp, #4
 8017dbe:	f7fe f8cb 	bl	8015f58 <find_volume>
	if (res == FR_OK) {
 8017dc2:	4604      	mov	r4, r0
 8017dc4:	b120      	cbz	r0, 8017dd0 <f_opendir+0x24>
			}
		}
		FREE_NAMBUF();
		if (res == FR_NO_FILE) res = FR_NO_PATH;
	}
	if (res != FR_OK) obj->fs = 0;		/* Invalidate the directory object if function faild */
 8017dc6:	2300      	movs	r3, #0
 8017dc8:	602b      	str	r3, [r5, #0]

	LEAVE_FF(fs, res);
}
 8017dca:	4620      	mov	r0, r4
 8017dcc:	b004      	add	sp, #16
 8017dce:	bd70      	pop	{r4, r5, r6, pc}
		obj->fs = fs;
 8017dd0:	9b03      	ldr	r3, [sp, #12]
 8017dd2:	602b      	str	r3, [r5, #0]
		INIT_NAMBUF(fs);
 8017dd4:	f44f 7000 	mov.w	r0, #512	; 0x200
 8017dd8:	f000 fcdc 	bl	8018794 <ff_memalloc>
 8017ddc:	4606      	mov	r6, r0
 8017dde:	2800      	cmp	r0, #0
 8017de0:	d032      	beq.n	8017e48 <f_opendir+0x9c>
 8017de2:	9b03      	ldr	r3, [sp, #12]
		res = follow_path(dp, path);			/* Follow the path to the directory */
 8017de4:	9901      	ldr	r1, [sp, #4]
		INIT_NAMBUF(fs);
 8017de6:	60d8      	str	r0, [r3, #12]
		res = follow_path(dp, path);			/* Follow the path to the directory */
 8017de8:	4628      	mov	r0, r5
 8017dea:	f7fe feff 	bl	8016bec <follow_path>
		if (res == FR_OK) {						/* Follow completed */
 8017dee:	4604      	mov	r4, r0
 8017df0:	b9f8      	cbnz	r0, 8017e32 <f_opendir+0x86>
			if (!(dp->fn[NSFLAG] & NS_NONAME)) {	/* It is not the origin directory itself */
 8017df2:	f995 302f 	ldrsb.w	r3, [r5, #47]	; 0x2f
 8017df6:	2b00      	cmp	r3, #0
 8017df8:	db2d      	blt.n	8017e56 <f_opendir+0xaa>
				if (obj->attr & AM_DIR) {		/* This object is a sub-directory */
 8017dfa:	79ab      	ldrb	r3, [r5, #6]
 8017dfc:	06db      	lsls	r3, r3, #27
 8017dfe:	d525      	bpl.n	8017e4c <f_opendir+0xa0>
						obj->sclust = ld_clust(fs, dp->dir);	/* Get object allocation info */
 8017e00:	9b03      	ldr	r3, [sp, #12]
 8017e02:	6a29      	ldr	r1, [r5, #32]
	if (fs->fs_type == FS_FAT32) {
 8017e04:	7818      	ldrb	r0, [r3, #0]
	cl = ld_word(dir + DIR_FstClusLO);
 8017e06:	8b4a      	ldrh	r2, [r1, #26]
	if (fs->fs_type == FS_FAT32) {
 8017e08:	2803      	cmp	r0, #3
		cl |= (DWORD)ld_word(dir + DIR_FstClusHI) << 16;
 8017e0a:	bf04      	itt	eq
 8017e0c:	8a89      	ldrheq	r1, [r1, #20]
 8017e0e:	ea42 4201 	orreq.w	r2, r2, r1, lsl #16
						obj->sclust = ld_clust(fs, dp->dir);	/* Get object allocation info */
 8017e12:	60aa      	str	r2, [r5, #8]
				obj->id = fs->id;
 8017e14:	88db      	ldrh	r3, [r3, #6]
 8017e16:	80ab      	strh	r3, [r5, #4]
				res = dir_sdi(dp, 0);			/* Rewind directory */
 8017e18:	2100      	movs	r1, #0
 8017e1a:	4628      	mov	r0, r5
 8017e1c:	f7fe fd56 	bl	80168cc <dir_sdi>
				if (res == FR_OK) {
 8017e20:	4604      	mov	r4, r0
 8017e22:	b930      	cbnz	r0, 8017e32 <f_opendir+0x86>
					if (obj->sclust) {
 8017e24:	68ab      	ldr	r3, [r5, #8]
 8017e26:	b9c3      	cbnz	r3, 8017e5a <f_opendir+0xae>
						obj->lockid = 0;	/* Root directory need not to be locked */
 8017e28:	6128      	str	r0, [r5, #16]
		FREE_NAMBUF();
 8017e2a:	4630      	mov	r0, r6
 8017e2c:	f000 fcb4 	bl	8018798 <ff_memfree>
	if (res != FR_OK) obj->fs = 0;		/* Invalidate the directory object if function faild */
 8017e30:	e7cb      	b.n	8017dca <f_opendir+0x1e>
		FREE_NAMBUF();
 8017e32:	4630      	mov	r0, r6
 8017e34:	f000 fcb0 	bl	8018798 <ff_memfree>
		if (res == FR_NO_FILE) res = FR_NO_PATH;
 8017e38:	2c04      	cmp	r4, #4
 8017e3a:	bf08      	it	eq
 8017e3c:	2405      	moveq	r4, #5
 8017e3e:	e7c2      	b.n	8017dc6 <f_opendir+0x1a>
	if (!dp) return FR_INVALID_OBJECT;
 8017e40:	2409      	movs	r4, #9
}
 8017e42:	4620      	mov	r0, r4
 8017e44:	b004      	add	sp, #16
 8017e46:	bd70      	pop	{r4, r5, r6, pc}
		INIT_NAMBUF(fs);
 8017e48:	2411      	movs	r4, #17
 8017e4a:	e7be      	b.n	8017dca <f_opendir+0x1e>
		FREE_NAMBUF();
 8017e4c:	4630      	mov	r0, r6
 8017e4e:	f000 fca3 	bl	8018798 <ff_memfree>
					res = FR_NO_PATH;
 8017e52:	2405      	movs	r4, #5
 8017e54:	e7b7      	b.n	8017dc6 <f_opendir+0x1a>
						obj->sclust = ld_clust(fs, dp->dir);	/* Get object allocation info */
 8017e56:	9b03      	ldr	r3, [sp, #12]
 8017e58:	e7dc      	b.n	8017e14 <f_opendir+0x68>
						obj->lockid = inc_lock(dp, 0);	/* Lock the sub directory */
 8017e5a:	4601      	mov	r1, r0
 8017e5c:	4628      	mov	r0, r5
 8017e5e:	f7fd fe93 	bl	8015b88 <inc_lock>
 8017e62:	6128      	str	r0, [r5, #16]
						if (!obj->lockid) res = FR_TOO_MANY_OPEN_FILES;
 8017e64:	b920      	cbnz	r0, 8017e70 <f_opendir+0xc4>
		FREE_NAMBUF();
 8017e66:	4630      	mov	r0, r6
 8017e68:	f000 fc96 	bl	8018798 <ff_memfree>
						if (!obj->lockid) res = FR_TOO_MANY_OPEN_FILES;
 8017e6c:	2412      	movs	r4, #18
 8017e6e:	e7aa      	b.n	8017dc6 <f_opendir+0x1a>
		FREE_NAMBUF();
 8017e70:	4630      	mov	r0, r6
 8017e72:	f000 fc91 	bl	8018798 <ff_memfree>
	if (res != FR_OK) obj->fs = 0;		/* Invalidate the directory object if function faild */
 8017e76:	e7a8      	b.n	8017dca <f_opendir+0x1e>

08017e78 <f_closedir>:
	if (obj && obj->fs && obj->fs->fs_type && obj->id == obj->fs->id) {	/* Test if the object is valid */
 8017e78:	b1b0      	cbz	r0, 8017ea8 <f_closedir+0x30>
 8017e7a:	6803      	ldr	r3, [r0, #0]
/*-----------------------------------------------------------------------*/

FRESULT f_closedir (
	DIR *dp		/* Pointer to the directory object to be closed */
)
{
 8017e7c:	b510      	push	{r4, lr}
 8017e7e:	4604      	mov	r4, r0
	if (obj && obj->fs && obj->fs->fs_type && obj->id == obj->fs->id) {	/* Test if the object is valid */
 8017e80:	b12b      	cbz	r3, 8017e8e <f_closedir+0x16>
 8017e82:	781a      	ldrb	r2, [r3, #0]
 8017e84:	b11a      	cbz	r2, 8017e8e <f_closedir+0x16>
 8017e86:	8881      	ldrh	r1, [r0, #4]
 8017e88:	88da      	ldrh	r2, [r3, #6]
 8017e8a:	4291      	cmp	r1, r2
 8017e8c:	d001      	beq.n	8017e92 <f_closedir+0x1a>
	FRESULT res = FR_INVALID_OBJECT;
 8017e8e:	2009      	movs	r0, #9
#if _FS_REENTRANT
		unlock_fs(fs, FR_OK);		/* Unlock volume */
#endif
	}
	return res;
}
 8017e90:	bd10      	pop	{r4, pc}
		if (!(disk_status(obj->fs->drv) & STA_NOINIT)) { /* Test if the phsical drive is kept initialized */
 8017e92:	7858      	ldrb	r0, [r3, #1]
 8017e94:	f7fd fde4 	bl	8015a60 <disk_status>
 8017e98:	f010 0001 	ands.w	r0, r0, #1
 8017e9c:	d1f7      	bne.n	8017e8e <f_closedir+0x16>
		if (dp->obj.lockid) {				/* Decrement sub-directory open counter */
 8017e9e:	6923      	ldr	r3, [r4, #16]
 8017ea0:	b923      	cbnz	r3, 8017eac <f_closedir+0x34>
			dp->obj.fs = 0;			/* Invalidate directory object */
 8017ea2:	2300      	movs	r3, #0
 8017ea4:	6023      	str	r3, [r4, #0]
}
 8017ea6:	bd10      	pop	{r4, pc}
	FRESULT res = FR_INVALID_OBJECT;
 8017ea8:	2009      	movs	r0, #9
}
 8017eaa:	4770      	bx	lr
	if (--i < _FS_LOCK) {	/* Shift index number origin from 0 */
 8017eac:	3b01      	subs	r3, #1
 8017eae:	2b01      	cmp	r3, #1
 8017eb0:	d812      	bhi.n	8017ed8 <f_closedir+0x60>
		n = Files[i].ctr;
 8017eb2:	490b      	ldr	r1, [pc, #44]	; (8017ee0 <f_closedir+0x68>)
 8017eb4:	ea4f 1c03 	mov.w	ip, r3, lsl #4
 8017eb8:	eb01 1303 	add.w	r3, r1, r3, lsl #4
 8017ebc:	899a      	ldrh	r2, [r3, #12]
		if (n == 0x100) n = 0;		/* If write mode open, delete the entry */
 8017ebe:	f5b2 7f80 	cmp.w	r2, #256	; 0x100
 8017ec2:	d00b      	beq.n	8017edc <f_closedir+0x64>
		if (n > 0) n--;				/* Decrement read mode open count */
 8017ec4:	b122      	cbz	r2, 8017ed0 <f_closedir+0x58>
 8017ec6:	3a01      	subs	r2, #1
 8017ec8:	b292      	uxth	r2, r2
		Files[i].ctr = n;
 8017eca:	819a      	strh	r2, [r3, #12]
		if (n == 0) Files[i].fs = 0;	/* Delete the entry if open count gets zero */
 8017ecc:	2a00      	cmp	r2, #0
 8017ece:	d1e8      	bne.n	8017ea2 <f_closedir+0x2a>
 8017ed0:	2300      	movs	r3, #0
 8017ed2:	f841 300c 	str.w	r3, [r1, ip]
		if (res == FR_OK)
 8017ed6:	e7e4      	b.n	8017ea2 <f_closedir+0x2a>
		res = FR_INT_ERR;			/* Invalid index nunber */
 8017ed8:	2002      	movs	r0, #2
}
 8017eda:	bd10      	pop	{r4, pc}
		Files[i].ctr = n;
 8017edc:	8198      	strh	r0, [r3, #12]
		if (n == 0) Files[i].fs = 0;	/* Delete the entry if open count gets zero */
 8017ede:	e7f7      	b.n	8017ed0 <f_closedir+0x58>
 8017ee0:	20003310 	.word	0x20003310

08017ee4 <f_readdir>:

FRESULT f_readdir (
	DIR* dp,			/* Pointer to the open directory object */
	FILINFO* fno		/* Pointer to file information to return */
)
{
 8017ee4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	if (obj && obj->fs && obj->fs->fs_type && obj->id == obj->fs->id) {	/* Test if the object is valid */
 8017ee8:	b148      	cbz	r0, 8017efe <f_readdir+0x1a>
 8017eea:	6803      	ldr	r3, [r0, #0]
 8017eec:	4604      	mov	r4, r0
 8017eee:	b133      	cbz	r3, 8017efe <f_readdir+0x1a>
 8017ef0:	781a      	ldrb	r2, [r3, #0]
 8017ef2:	b122      	cbz	r2, 8017efe <f_readdir+0x1a>
 8017ef4:	88da      	ldrh	r2, [r3, #6]
 8017ef6:	460e      	mov	r6, r1
 8017ef8:	8881      	ldrh	r1, [r0, #4]
 8017efa:	4291      	cmp	r1, r2
 8017efc:	d003      	beq.n	8017f06 <f_readdir+0x22>
	FRESULT res = FR_INVALID_OBJECT;
 8017efe:	2509      	movs	r5, #9
			}
			FREE_NAMBUF();
		}
	}
	LEAVE_FF(fs, res);
}
 8017f00:	4628      	mov	r0, r5
 8017f02:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		if (!(disk_status(obj->fs->drv) & STA_NOINIT)) { /* Test if the phsical drive is kept initialized */
 8017f06:	7858      	ldrb	r0, [r3, #1]
 8017f08:	f7fd fdaa 	bl	8015a60 <disk_status>
 8017f0c:	07c3      	lsls	r3, r0, #31
 8017f0e:	d4f6      	bmi.n	8017efe <f_readdir+0x1a>
		if (!fno) {
 8017f10:	b306      	cbz	r6, 8017f54 <f_readdir+0x70>
			INIT_NAMBUF(fs);
 8017f12:	f44f 7000 	mov.w	r0, #512	; 0x200
	*fs = (res == FR_OK) ? obj->fs : 0;	/* Corresponding filesystem object */
 8017f16:	6825      	ldr	r5, [r4, #0]
			INIT_NAMBUF(fs);
 8017f18:	f000 fc3c 	bl	8018794 <ff_memalloc>
 8017f1c:	4607      	mov	r7, r0
 8017f1e:	b1f8      	cbz	r0, 8017f60 <f_readdir+0x7c>
 8017f20:	60e8      	str	r0, [r5, #12]
			res = dir_read(dp, 0);			/* Read an item */
 8017f22:	4620      	mov	r0, r4
 8017f24:	f7fe fc2e 	bl	8016784 <dir_read.constprop.0>
			if (res == FR_OK) {				/* A valid entry is found */
 8017f28:	f010 08fb 	ands.w	r8, r0, #251	; 0xfb
			res = dir_read(dp, 0);			/* Read an item */
 8017f2c:	4605      	mov	r5, r0
			if (res == FR_OK) {				/* A valid entry is found */
 8017f2e:	d10b      	bne.n	8017f48 <f_readdir+0x64>
				get_fileinfo(dp, fno);		/* Get the object information */
 8017f30:	4631      	mov	r1, r6
 8017f32:	4620      	mov	r0, r4
 8017f34:	f7fd feb6 	bl	8015ca4 <get_fileinfo>
				res = dir_next(dp, 0);		/* Increment index for next */
 8017f38:	4641      	mov	r1, r8
 8017f3a:	4620      	mov	r0, r4
 8017f3c:	f7fe fb80 	bl	8016640 <dir_next>
				if (res == FR_NO_FILE) res = FR_OK;	/* Ignore end of directory now */
 8017f40:	2804      	cmp	r0, #4
				res = dir_next(dp, 0);		/* Increment index for next */
 8017f42:	4605      	mov	r5, r0
				if (res == FR_NO_FILE) res = FR_OK;	/* Ignore end of directory now */
 8017f44:	bf08      	it	eq
 8017f46:	2500      	moveq	r5, #0
			FREE_NAMBUF();
 8017f48:	4638      	mov	r0, r7
 8017f4a:	f000 fc25 	bl	8018798 <ff_memfree>
}
 8017f4e:	4628      	mov	r0, r5
 8017f50:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
			res = dir_sdi(dp, 0);			/* Rewind the directory object */
 8017f54:	4631      	mov	r1, r6
 8017f56:	4620      	mov	r0, r4
}
 8017f58:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
			res = dir_sdi(dp, 0);			/* Rewind the directory object */
 8017f5c:	f7fe bcb6 	b.w	80168cc <dir_sdi>
			INIT_NAMBUF(fs);
 8017f60:	2511      	movs	r5, #17
 8017f62:	e7cd      	b.n	8017f00 <f_readdir+0x1c>

08017f64 <f_unlink>:
/*-----------------------------------------------------------------------*/

FRESULT f_unlink (
	const TCHAR* path		/* Pointer to the file or directory path */
)
{
 8017f64:	b570      	push	{r4, r5, r6, lr}
 8017f66:	b09e      	sub	sp, #120	; 0x78
#endif
	DEF_NAMBUF


	/* Get logical drive */
	res = find_volume(&path, &fs, FA_WRITE);
 8017f68:	2202      	movs	r2, #2
{
 8017f6a:	9001      	str	r0, [sp, #4]
	res = find_volume(&path, &fs, FA_WRITE);
 8017f6c:	a903      	add	r1, sp, #12
 8017f6e:	a801      	add	r0, sp, #4
 8017f70:	f7fd fff2 	bl	8015f58 <find_volume>
	dj.obj.fs = fs;
 8017f74:	9b03      	ldr	r3, [sp, #12]
 8017f76:	9304      	str	r3, [sp, #16]
	if (res == FR_OK) {
 8017f78:	4604      	mov	r4, r0
 8017f7a:	b110      	cbz	r0, 8017f82 <f_unlink+0x1e>
		}
		FREE_NAMBUF();
	}

	LEAVE_FF(fs, res);
}
 8017f7c:	4620      	mov	r0, r4
 8017f7e:	b01e      	add	sp, #120	; 0x78
 8017f80:	bd70      	pop	{r4, r5, r6, pc}
		INIT_NAMBUF(fs);
 8017f82:	f44f 7000 	mov.w	r0, #512	; 0x200
 8017f86:	f000 fc05 	bl	8018794 <ff_memalloc>
 8017f8a:	4605      	mov	r5, r0
 8017f8c:	b380      	cbz	r0, 8017ff0 <f_unlink+0x8c>
 8017f8e:	9b03      	ldr	r3, [sp, #12]
		res = follow_path(&dj, path);		/* Follow the file path */
 8017f90:	9901      	ldr	r1, [sp, #4]
		INIT_NAMBUF(fs);
 8017f92:	60d8      	str	r0, [r3, #12]
		res = follow_path(&dj, path);		/* Follow the file path */
 8017f94:	a804      	add	r0, sp, #16
 8017f96:	f7fe fe29 	bl	8016bec <follow_path>
		if (res == FR_OK) res = chk_lock(&dj, 2);	/* Check if it is an open object */
 8017f9a:	4604      	mov	r4, r0
 8017f9c:	bb10      	cbnz	r0, 8017fe4 <f_unlink+0x80>
 8017f9e:	2102      	movs	r1, #2
 8017fa0:	a804      	add	r0, sp, #16
 8017fa2:	f7fd fd9f 	bl	8015ae4 <chk_lock>
		if (res == FR_OK) {					/* The object is accessible */
 8017fa6:	4604      	mov	r4, r0
 8017fa8:	b9e0      	cbnz	r0, 8017fe4 <f_unlink+0x80>
			if (dj.fn[NSFLAG] & NS_NONAME) {
 8017faa:	f99d 303f 	ldrsb.w	r3, [sp, #63]	; 0x3f
 8017fae:	2b00      	cmp	r3, #0
 8017fb0:	db20      	blt.n	8017ff4 <f_unlink+0x90>
				if (dj.obj.attr & AM_RDO) {
 8017fb2:	f89d 3016 	ldrb.w	r3, [sp, #22]
 8017fb6:	07da      	lsls	r2, r3, #31
 8017fb8:	d41e      	bmi.n	8017ff8 <f_unlink+0x94>
					dclst = ld_clust(fs, dj.dir);
 8017fba:	9903      	ldr	r1, [sp, #12]
 8017fbc:	9a0c      	ldr	r2, [sp, #48]	; 0x30
	if (fs->fs_type == FS_FAT32) {
 8017fbe:	7808      	ldrb	r0, [r1, #0]
	cl = ld_word(dir + DIR_FstClusLO);
 8017fc0:	8b56      	ldrh	r6, [r2, #26]
	if (fs->fs_type == FS_FAT32) {
 8017fc2:	2803      	cmp	r0, #3
		cl |= (DWORD)ld_word(dir + DIR_FstClusHI) << 16;
 8017fc4:	bf04      	itt	eq
 8017fc6:	8a92      	ldrheq	r2, [r2, #20]
 8017fc8:	ea46 4602 	orreq.w	r6, r6, r2, lsl #16
				if (dj.obj.attr & AM_DIR) {			/* Is it a sub-directory? */
 8017fcc:	06db      	lsls	r3, r3, #27
 8017fce:	d415      	bmi.n	8017ffc <f_unlink+0x98>
				res = dir_remove(&dj);			/* Remove the directory entry */
 8017fd0:	a804      	add	r0, sp, #16
 8017fd2:	f7fe fccf 	bl	8016974 <dir_remove>
				if (res == FR_OK && dclst) {	/* Remove the cluster chain if exist */
 8017fd6:	4604      	mov	r4, r0
 8017fd8:	b920      	cbnz	r0, 8017fe4 <f_unlink+0x80>
 8017fda:	bb0e      	cbnz	r6, 8018020 <f_unlink+0xbc>
				if (res == FR_OK) res = sync_fs(fs);
 8017fdc:	9803      	ldr	r0, [sp, #12]
 8017fde:	f7fd ff01 	bl	8015de4 <sync_fs>
 8017fe2:	4604      	mov	r4, r0
		FREE_NAMBUF();
 8017fe4:	4628      	mov	r0, r5
 8017fe6:	f000 fbd7 	bl	8018798 <ff_memfree>
}
 8017fea:	4620      	mov	r0, r4
 8017fec:	b01e      	add	sp, #120	; 0x78
 8017fee:	bd70      	pop	{r4, r5, r6, pc}
		INIT_NAMBUF(fs);
 8017ff0:	2411      	movs	r4, #17
 8017ff2:	e7c3      	b.n	8017f7c <f_unlink+0x18>
				res = FR_INVALID_NAME;		/* Cannot remove the origin directory */
 8017ff4:	2406      	movs	r4, #6
 8017ff6:	e7f5      	b.n	8017fe4 <f_unlink+0x80>
					res = FR_DENIED;		/* Cannot remove R/O object */
 8017ff8:	2407      	movs	r4, #7
 8017ffa:	e7f3      	b.n	8017fe4 <f_unlink+0x80>
						sdj.obj.fs = fs;						/* Open the sub-directory */
 8017ffc:	9111      	str	r1, [sp, #68]	; 0x44
						res = dir_sdi(&sdj, 0);
 8017ffe:	a811      	add	r0, sp, #68	; 0x44
 8018000:	2100      	movs	r1, #0
						sdj.obj.sclust = dclst;
 8018002:	9613      	str	r6, [sp, #76]	; 0x4c
						res = dir_sdi(&sdj, 0);
 8018004:	f7fe fc62 	bl	80168cc <dir_sdi>
						if (res == FR_OK) {
 8018008:	4604      	mov	r4, r0
 801800a:	2800      	cmp	r0, #0
 801800c:	d1ea      	bne.n	8017fe4 <f_unlink+0x80>
							res = dir_read(&sdj, 0);			/* Read an item */
 801800e:	a811      	add	r0, sp, #68	; 0x44
 8018010:	f7fe fbb8 	bl	8016784 <dir_read.constprop.0>
							if (res == FR_OK) res = FR_DENIED;	/* Not empty? */
 8018014:	4604      	mov	r4, r0
 8018016:	2800      	cmp	r0, #0
 8018018:	d0ee      	beq.n	8017ff8 <f_unlink+0x94>
							if (res == FR_NO_FILE) res = FR_OK;	/* Empty? */
 801801a:	2804      	cmp	r0, #4
 801801c:	d1e2      	bne.n	8017fe4 <f_unlink+0x80>
 801801e:	e7d7      	b.n	8017fd0 <f_unlink+0x6c>
					res = remove_chain(&dj.obj, dclst, 0);
 8018020:	4602      	mov	r2, r0
 8018022:	4631      	mov	r1, r6
 8018024:	a804      	add	r0, sp, #16
 8018026:	f7fe fa5b 	bl	80164e0 <remove_chain>
				if (res == FR_OK) res = sync_fs(fs);
 801802a:	4604      	mov	r4, r0
 801802c:	2800      	cmp	r0, #0
 801802e:	d1d9      	bne.n	8017fe4 <f_unlink+0x80>
 8018030:	e7d4      	b.n	8017fdc <f_unlink+0x78>
 8018032:	bf00      	nop

08018034 <f_mkfs>:
	BYTE opt,			/* Format option */
	DWORD au,			/* Size of allocation unit (cluster) [byte] */
	void* work,			/* Pointer to working buffer */
	UINT len			/* Size of working buffer */
)
{
 8018034:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8018038:	b08b      	sub	sp, #44	; 0x2c
 801803a:	460f      	mov	r7, r1
 801803c:	9007      	str	r0, [sp, #28]
	DWORD tbl[3];
#endif


	/* Check mounted drive and clear work area */
	vol = get_ldnumber(&path);					/* Get target logical drive */
 801803e:	a807      	add	r0, sp, #28
{
 8018040:	4690      	mov	r8, r2
 8018042:	461d      	mov	r5, r3
	vol = get_ldnumber(&path);					/* Get target logical drive */
 8018044:	f7fd fdf8 	bl	8015c38 <get_ldnumber>
	if (vol < 0) return FR_INVALID_DRIVE;
 8018048:	2800      	cmp	r0, #0
 801804a:	f2c0 80dd 	blt.w	8018208 <f_mkfs+0x1d4>
	if (FatFs[vol]) FatFs[vol]->fs_type = 0;	/* Clear the volume */
 801804e:	4bbf      	ldr	r3, [pc, #764]	; (801834c <f_mkfs+0x318>)
 8018050:	eb03 0380 	add.w	r3, r3, r0, lsl #2
 8018054:	6a1b      	ldr	r3, [r3, #32]
 8018056:	b10b      	cbz	r3, 801805c <f_mkfs+0x28>
 8018058:	2200      	movs	r2, #0
 801805a:	701a      	strb	r2, [r3, #0]
	pdrv = LD2PD(vol);	/* Physical drive */
 801805c:	b2c4      	uxtb	r4, r0
	part = LD2PT(vol);	/* Partition (0:create as new, 1-4:get from partition table) */

	/* Check physical drive status */
	stat = disk_initialize(pdrv);
 801805e:	4620      	mov	r0, r4
 8018060:	f7fd fd08 	bl	8015a74 <disk_initialize>
	if (stat & STA_NOINIT) return FR_NOT_READY;
 8018064:	07c3      	lsls	r3, r0, #31
 8018066:	f100 80cb 	bmi.w	8018200 <f_mkfs+0x1cc>
	if (stat & STA_PROTECT) return FR_WRITE_PROTECTED;
 801806a:	0746      	lsls	r6, r0, #29
 801806c:	d41e      	bmi.n	80180ac <f_mkfs+0x78>
	if (disk_ioctl(pdrv, GET_BLOCK_SIZE, &sz_blk) != RES_OK || !sz_blk || sz_blk > 32768 || (sz_blk & (sz_blk - 1))) sz_blk = 1;	/* Erase block to align data area */
 801806e:	aa08      	add	r2, sp, #32
 8018070:	2103      	movs	r1, #3
 8018072:	4620      	mov	r0, r4
 8018074:	f7fd fd2a 	bl	8015acc <disk_ioctl>
 8018078:	b928      	cbnz	r0, 8018086 <f_mkfs+0x52>
 801807a:	9a08      	ldr	r2, [sp, #32]
 801807c:	1e53      	subs	r3, r2, #1
 801807e:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
 8018082:	f0c0 80ad 	bcc.w	80181e0 <f_mkfs+0x1ac>
 8018086:	2301      	movs	r3, #1
 8018088:	9308      	str	r3, [sp, #32]
	if (disk_ioctl(pdrv, GET_SECTOR_SIZE, &ss) != RES_OK) return FR_DISK_ERR;
	if (ss > _MAX_SS || ss < _MIN_SS || (ss & (ss - 1))) return FR_DISK_ERR;
#else
	ss = _MAX_SS;
#endif
	if ((au != 0 && au < ss) || au > 0x1000000 || (au & (au - 1))) return FR_INVALID_PARAMETER;	/* Check if au is valid */
 801808a:	f1b8 0f00 	cmp.w	r8, #0
 801808e:	d011      	beq.n	80180b4 <f_mkfs+0x80>
 8018090:	4baf      	ldr	r3, [pc, #700]	; (8018350 <f_mkfs+0x31c>)
 8018092:	f5a8 5280 	sub.w	r2, r8, #4096	; 0x1000
 8018096:	429a      	cmp	r2, r3
 8018098:	d804      	bhi.n	80180a4 <f_mkfs+0x70>
 801809a:	f108 33ff 	add.w	r3, r8, #4294967295
 801809e:	ea13 0f08 	tst.w	r3, r8
 80180a2:	d007      	beq.n	80180b4 <f_mkfs+0x80>
 80180a4:	2013      	movs	r0, #19
	}

	if (disk_ioctl(pdrv, CTRL_SYNC, 0) != RES_OK) return FR_DISK_ERR;

	return FR_OK;
}
 80180a6:	b00b      	add	sp, #44	; 0x2c
 80180a8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	if (stat & STA_PROTECT) return FR_WRITE_PROTECTED;
 80180ac:	200a      	movs	r0, #10
}
 80180ae:	b00b      	add	sp, #44	; 0x2c
 80180b0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	szb_buf = sz_buf * ss;	/* Size of working buffer (byte) */
 80180b4:	9b14      	ldr	r3, [sp, #80]	; 0x50
 80180b6:	f423 667f 	bic.w	r6, r3, #4080	; 0xff0
 80180ba:	f026 060f 	bic.w	r6, r6, #15
	if (!szb_buf) return FR_MKFS_ABORTED;
 80180be:	2e00      	cmp	r6, #0
 80180c0:	f000 809a 	beq.w	80181f8 <f_mkfs+0x1c4>
		if (disk_ioctl(pdrv, GET_SECTOR_COUNT, &sz_vol) != RES_OK) return FR_DISK_ERR;
 80180c4:	aa09      	add	r2, sp, #36	; 0x24
 80180c6:	2101      	movs	r1, #1
 80180c8:	4620      	mov	r0, r4
 80180ca:	f7fd fcff 	bl	8015acc <disk_ioctl>
 80180ce:	4681      	mov	r9, r0
 80180d0:	2800      	cmp	r0, #0
 80180d2:	f040 815b 	bne.w	801838c <f_mkfs+0x358>
		b_vol = (opt & FM_SFD) ? 0 : 63;		/* Volume start sector */
 80180d6:	f017 0308 	ands.w	r3, r7, #8
 80180da:	9304      	str	r3, [sp, #16]
		if (sz_vol < b_vol) return FR_MKFS_ABORTED;
 80180dc:	9b09      	ldr	r3, [sp, #36]	; 0x24
		b_vol = (opt & FM_SFD) ? 0 : 63;		/* Volume start sector */
 80180de:	f040 8157 	bne.w	8018390 <f_mkfs+0x35c>
		if (sz_vol < b_vol) return FR_MKFS_ABORTED;
 80180e2:	2b3e      	cmp	r3, #62	; 0x3e
 80180e4:	f240 8088 	bls.w	80181f8 <f_mkfs+0x1c4>
 80180e8:	3b3f      	subs	r3, #63	; 0x3f
		b_vol = (opt & FM_SFD) ? 0 : 63;		/* Volume start sector */
 80180ea:	f04f 0a3f 	mov.w	sl, #63	; 0x3f
	if (sz_vol < 128) return FR_MKFS_ABORTED;	/* Check if volume size is >=128s */
 80180ee:	2b7f      	cmp	r3, #127	; 0x7f
		sz_vol -= b_vol;						/* Volume size */
 80180f0:	9309      	str	r3, [sp, #36]	; 0x24
	if (sz_vol < 128) return FR_MKFS_ABORTED;	/* Check if volume size is >=128s */
 80180f2:	f240 8081 	bls.w	80181f8 <f_mkfs+0x1c4>
		if (au > 128) return FR_INVALID_PARAMETER;	/* Too large au for FAT/FAT32 */
 80180f6:	f5b8 2f01 	cmp.w	r8, #528384	; 0x81000
 80180fa:	d2d3      	bcs.n	80180a4 <f_mkfs+0x70>
		if (opt & FM_FAT32) {	/* FAT32 possible? */
 80180fc:	f017 0102 	ands.w	r1, r7, #2
	au /= ss;	/* Cluster size in unit of sector */
 8018100:	ea4f 3218 	mov.w	r2, r8, lsr #12
		if (opt & FM_FAT32) {	/* FAT32 possible? */
 8018104:	9106      	str	r1, [sp, #24]
 8018106:	f000 8177 	beq.w	80183f8 <f_mkfs+0x3c4>
			if ((opt & FM_ANY) == FM_FAT32 || !(opt & FM_FAT)) {	/* FAT32 only or no-FAT? */
 801810a:	f007 0107 	and.w	r1, r7, #7
 801810e:	2902      	cmp	r1, #2
 8018110:	f000 8144 	beq.w	801839c <f_mkfs+0x368>
 8018114:	07f8      	lsls	r0, r7, #31
 8018116:	f140 8141 	bpl.w	801839c <f_mkfs+0x368>
 801811a:	9908      	ldr	r1, [sp, #32]
 801811c:	9103      	str	r1, [sp, #12]
				if (!pau) {	/* au auto-selection */
 801811e:	2a00      	cmp	r2, #0
 8018120:	f000 816e 	beq.w	8018400 <f_mkfs+0x3cc>
 8018124:	4617      	mov	r7, r2
				if (n_clst > MAX_FAT12) {
 8018126:	f640 7cf5 	movw	ip, #4085	; 0xff5
				n_clst = sz_vol / pau;
 801812a:	fbb3 f1f7 	udiv	r1, r3, r7
				if (n_clst > MAX_FAT12) {
 801812e:	4561      	cmp	r1, ip
 8018130:	d94e      	bls.n	80181d0 <f_mkfs+0x19c>
					n = n_clst * 2 + 4;		/* FAT size [byte] */
 8018132:	3102      	adds	r1, #2
 8018134:	0049      	lsls	r1, r1, #1
 8018136:	f04f 0b02 	mov.w	fp, #2
			n = ((b_data + sz_blk - 1) & ~(sz_blk - 1)) - b_data;	/* Next nearest erase block from current data base */
 801813a:	9803      	ldr	r0, [sp, #12]
			b_data = b_fat + sz_fat * n_fats + sz_dir;	/* Data base */
 801813c:	f10a 0c05 	add.w	ip, sl, #5
				sz_fat = (n + ss - 1) / ss;		/* FAT size [sector] */
 8018140:	f601 71ff 	addw	r1, r1, #4095	; 0xfff
			b_data = b_fat + sz_fat * n_fats + sz_dir;	/* Data base */
 8018144:	eb0c 3111 	add.w	r1, ip, r1, lsr #12
			n = ((b_data + sz_blk - 1) & ~(sz_blk - 1)) - b_data;	/* Next nearest erase block from current data base */
 8018148:	f100 3cff 	add.w	ip, r0, #4294967295
 801814c:	f1c0 0e00 	rsb	lr, r0, #0
 8018150:	448c      	add	ip, r1
 8018152:	ea0c 0c0e 	and.w	ip, ip, lr
				sz_fat += n / n_fats;
 8018156:	ebac 0c0a 	sub.w	ip, ip, sl
 801815a:	f1ac 0005 	sub.w	r0, ip, #5
 801815e:	9000      	str	r0, [sp, #0]
			b_fat = b_vol + sz_rsv;						/* FAT base */
 8018160:	f10a 0001 	add.w	r0, sl, #1
 8018164:	9005      	str	r0, [sp, #20]
				sz_rsv = 1;						/* Number of reserved sectors */
 8018166:	f04f 0c04 	mov.w	ip, #4
 801816a:	2001      	movs	r0, #1
 801816c:	e9cd 0c01 	strd	r0, ip, [sp, #4]
			if (sz_vol < b_data + pau * 16 - b_vol) return FR_MKFS_ABORTED;	/* Too small volume */
 8018170:	eba1 010a 	sub.w	r1, r1, sl
 8018174:	eb01 1107 	add.w	r1, r1, r7, lsl #4
 8018178:	4299      	cmp	r1, r3
 801817a:	d83d      	bhi.n	80181f8 <f_mkfs+0x1c4>
			n_clst = (sz_vol - sz_rsv - sz_fat * n_fats - sz_dir) / pau;
 801817c:	e9dd 0100 	ldrd	r0, r1, [sp]
 8018180:	eb01 0800 	add.w	r8, r1, r0
 8018184:	9902      	ldr	r1, [sp, #8]
 8018186:	eba3 0808 	sub.w	r8, r3, r8
			if (fmt == FS_FAT32) {
 801818a:	f1bb 0f03 	cmp.w	fp, #3
			n_clst = (sz_vol - sz_rsv - sz_fat * n_fats - sz_dir) / pau;
 801818e:	eba8 0801 	sub.w	r8, r8, r1
 8018192:	fbb8 f8f7 	udiv	r8, r8, r7
			if (fmt == FS_FAT32) {
 8018196:	d03b      	beq.n	8018210 <f_mkfs+0x1dc>
			if (fmt == FS_FAT16) {
 8018198:	f1bb 0f02 	cmp.w	fp, #2
 801819c:	f040 8227 	bne.w	80185ee <f_mkfs+0x5ba>
				if (n_clst > MAX_FAT16) {	/* Too many clusters for FAT16 */
 80181a0:	f64f 71f5 	movw	r1, #65525	; 0xfff5
 80181a4:	4588      	cmp	r8, r1
 80181a6:	d91f      	bls.n	80181e8 <f_mkfs+0x1b4>
					if (!au && (pau * 2) <= 64) {
 80181a8:	2a00      	cmp	r2, #0
 80181aa:	f040 80f3 	bne.w	8018394 <f_mkfs+0x360>
 80181ae:	007f      	lsls	r7, r7, #1
 80181b0:	2f40      	cmp	r7, #64	; 0x40
 80181b2:	f240 814b 	bls.w	801844c <f_mkfs+0x418>
					if ((opt & FM_FAT32)) {
 80181b6:	9a06      	ldr	r2, [sp, #24]
 80181b8:	2a00      	cmp	r2, #0
 80181ba:	f040 8139 	bne.w	8018430 <f_mkfs+0x3fc>
					if (!au && (au = pau * 2) <= 128) continue;	/* Adjust cluster size and retry */
 80181be:	2f80      	cmp	r7, #128	; 0x80
 80181c0:	d81a      	bhi.n	80181f8 <f_mkfs+0x1c4>
				n_clst = sz_vol / pau;
 80181c2:	fbb3 f1f7 	udiv	r1, r3, r7
				if (n_clst > MAX_FAT12) {
 80181c6:	f640 7cf5 	movw	ip, #4085	; 0xff5
 80181ca:	4561      	cmp	r1, ip
 80181cc:	463a      	mov	r2, r7
 80181ce:	d8b0      	bhi.n	8018132 <f_mkfs+0xfe>
					n = (n_clst * 3 + 1) / 2 + 3;	/* FAT size [byte] */
 80181d0:	eb01 0141 	add.w	r1, r1, r1, lsl #1
 80181d4:	3101      	adds	r1, #1
 80181d6:	0849      	lsrs	r1, r1, #1
 80181d8:	3103      	adds	r1, #3
					fmt = FS_FAT12;
 80181da:	f04f 0b01 	mov.w	fp, #1
 80181de:	e7ac      	b.n	801813a <f_mkfs+0x106>
	if (disk_ioctl(pdrv, GET_BLOCK_SIZE, &sz_blk) != RES_OK || !sz_blk || sz_blk > 32768 || (sz_blk & (sz_blk - 1))) sz_blk = 1;	/* Erase block to align data area */
 80181e0:	421a      	tst	r2, r3
 80181e2:	f43f af52 	beq.w	801808a <f_mkfs+0x56>
 80181e6:	e74e      	b.n	8018086 <f_mkfs+0x52>
				if  (n_clst <= MAX_FAT12) {	/* Too few clusters for FAT16 */
 80181e8:	f640 71f5 	movw	r1, #4085	; 0xff5
 80181ec:	4588      	cmp	r8, r1
 80181ee:	d814      	bhi.n	801821a <f_mkfs+0x1e6>
					if (!au && (au = pau * 2) <= 128) continue;	/* Adjust cluster size and retry */
 80181f0:	b912      	cbnz	r2, 80181f8 <f_mkfs+0x1c4>
 80181f2:	007a      	lsls	r2, r7, #1
 80181f4:	2a80      	cmp	r2, #128	; 0x80
 80181f6:	d992      	bls.n	801811e <f_mkfs+0xea>
	if (!szb_buf) return FR_MKFS_ABORTED;
 80181f8:	200e      	movs	r0, #14
}
 80181fa:	b00b      	add	sp, #44	; 0x2c
 80181fc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	if (stat & STA_NOINIT) return FR_NOT_READY;
 8018200:	2003      	movs	r0, #3
}
 8018202:	b00b      	add	sp, #44	; 0x2c
 8018204:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	if (vol < 0) return FR_INVALID_DRIVE;
 8018208:	200b      	movs	r0, #11
}
 801820a:	b00b      	add	sp, #44	; 0x2c
 801820c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
				if (n_clst <= MAX_FAT16) {	/* Too few clusters for FAT32 */
 8018210:	f64f 71f5 	movw	r1, #65525	; 0xfff5
 8018214:	4588      	cmp	r8, r1
 8018216:	f240 8103 	bls.w	8018420 <f_mkfs+0x3ec>
		*d++ = (BYTE)val;
 801821a:	f44f 5280 	mov.w	r2, #4096	; 0x1000
 801821e:	2100      	movs	r1, #0
 8018220:	4628      	mov	r0, r5
 8018222:	9303      	str	r3, [sp, #12]
 8018224:	f00f f9a8 	bl	8027578 <memset>
 8018228:	484a      	ldr	r0, [pc, #296]	; (8018354 <f_mkfs+0x320>)
 801822a:	9b03      	ldr	r3, [sp, #12]
 801822c:	f105 0c0b 	add.w	ip, r5, #11
 8018230:	462a      	mov	r2, r5
 8018232:	21eb      	movs	r1, #235	; 0xeb
 8018234:	e001      	b.n	801823a <f_mkfs+0x206>
			*d++ = *s++;
 8018236:	f810 1f01 	ldrb.w	r1, [r0, #1]!
 801823a:	f802 1b01 	strb.w	r1, [r2], #1
		} while (--cnt);
 801823e:	4562      	cmp	r2, ip
 8018240:	d1f9      	bne.n	8018236 <f_mkfs+0x202>
	*ptr++ = (BYTE)val; val >>= 8;
 8018242:	9a01      	ldr	r2, [sp, #4]
 8018244:	73aa      	strb	r2, [r5, #14]
 8018246:	f3c2 2207 	ubfx	r2, r2, #8, #8
	*ptr++ = (BYTE)val;
 801824a:	73ea      	strb	r2, [r5, #15]
	*ptr++ = (BYTE)val; val >>= 8;
 801824c:	2200      	movs	r2, #0
		st_word(buf + BPB_RootEntCnt, (WORD)((fmt == FS_FAT32) ? 0 : n_rootdir));	/* Number of root directory entries */
 801824e:	f1bb 0f03 	cmp.w	fp, #3
	*ptr++ = (BYTE)val; val >>= 8;
 8018252:	72ea      	strb	r2, [r5, #11]
 8018254:	746a      	strb	r2, [r5, #17]
	*ptr++ = (BYTE)val;
 8018256:	f04f 0210 	mov.w	r2, #16
		st_word(buf + BPB_RootEntCnt, (WORD)((fmt == FS_FAT32) ? 0 : n_rootdir));	/* Number of root directory entries */
 801825a:	bf18      	it	ne
 801825c:	f04f 0902 	movne.w	r9, #2
	*ptr++ = (BYTE)val;
 8018260:	732a      	strb	r2, [r5, #12]
		if (sz_vol < 0x10000) {
 8018262:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
		buf[BPB_NumFATs] = (BYTE)n_fats;				/* Number of FATs */
 8018266:	f04f 0201 	mov.w	r2, #1
	*ptr++ = (BYTE)val;
 801826a:	f885 9012 	strb.w	r9, [r5, #18]
		buf[BPB_SecPerClus] = (BYTE)pau;				/* Cluster size [sector] */
 801826e:	736f      	strb	r7, [r5, #13]
		buf[BPB_NumFATs] = (BYTE)n_fats;				/* Number of FATs */
 8018270:	742a      	strb	r2, [r5, #16]
		if (sz_vol < 0x10000) {
 8018272:	f080 80ed 	bcs.w	8018450 <f_mkfs+0x41c>
	*ptr++ = (BYTE)val; val >>= 8;
 8018276:	74eb      	strb	r3, [r5, #19]
 8018278:	f3c3 2307 	ubfx	r3, r3, #8, #8
	*ptr++ = (BYTE)val;
 801827c:	752b      	strb	r3, [r5, #20]
		buf[BPB_Media] = 0xF8;							/* Media descriptor byte */
 801827e:	23f8      	movs	r3, #248	; 0xf8
 8018280:	756b      	strb	r3, [r5, #21]
	*ptr++ = (BYTE)val; val >>= 8;
 8018282:	233f      	movs	r3, #63	; 0x3f
 8018284:	762b      	strb	r3, [r5, #24]
 8018286:	23ff      	movs	r3, #255	; 0xff
	*ptr++ = (BYTE)val;
 8018288:	f04f 0900 	mov.w	r9, #0
	*ptr++ = (BYTE)val; val >>= 8;
 801828c:	76ab      	strb	r3, [r5, #26]
		if (fmt == FS_FAT32) {
 801828e:	f1bb 0f03 	cmp.w	fp, #3
	*ptr++ = (BYTE)val; val >>= 8;
 8018292:	fa5f f38a 	uxtb.w	r3, sl
	*ptr++ = (BYTE)val;
 8018296:	f885 9019 	strb.w	r9, [r5, #25]
 801829a:	f885 901b 	strb.w	r9, [r5, #27]
	*ptr++ = (BYTE)val; val >>= 8;
 801829e:	f885 901d 	strb.w	r9, [r5, #29]
	*ptr++ = (BYTE)val; val >>= 8;
 80182a2:	f885 901e 	strb.w	r9, [r5, #30]
	*ptr++ = (BYTE)val;
 80182a6:	f885 901f 	strb.w	r9, [r5, #31]
	*ptr++ = (BYTE)val; val >>= 8;
 80182aa:	9301      	str	r3, [sp, #4]
 80182ac:	772b      	strb	r3, [r5, #28]
		if (fmt == FS_FAT32) {
 80182ae:	f000 80f4 	beq.w	801849a <f_mkfs+0x466>
			st_dword(buf + BS_VolID, GET_FATTIME());	/* VSN */
 80182b2:	f006 fcf5 	bl	801eca0 <get_fattime>
	*ptr++ = (BYTE)val; val >>= 8;
 80182b6:	9900      	ldr	r1, [sp, #0]
 80182b8:	4b27      	ldr	r3, [pc, #156]	; (8018358 <f_mkfs+0x324>)
	*ptr++ = (BYTE)val; val >>= 8;
 80182ba:	f885 0027 	strb.w	r0, [r5, #39]	; 0x27
 80182be:	0a02      	lsrs	r2, r0, #8
	*ptr++ = (BYTE)val; val >>= 8;
 80182c0:	f885 2028 	strb.w	r2, [r5, #40]	; 0x28
 80182c4:	0c02      	lsrs	r2, r0, #16
	*ptr++ = (BYTE)val; val >>= 8;
 80182c6:	f885 2029 	strb.w	r2, [r5, #41]	; 0x29
	*ptr++ = (BYTE)val; val >>= 8;
 80182ca:	f3c1 2207 	ubfx	r2, r1, #8, #8
	*ptr++ = (BYTE)val;
 80182ce:	75ea      	strb	r2, [r5, #23]
			buf[BS_DrvNum] = 0x80;						/* Drive number (for int13) */
 80182d0:	2280      	movs	r2, #128	; 0x80
	*ptr++ = (BYTE)val; val >>= 8;
 80182d2:	0e00      	lsrs	r0, r0, #24
			buf[BS_DrvNum] = 0x80;						/* Drive number (for int13) */
 80182d4:	f885 2024 	strb.w	r2, [r5, #36]	; 0x24
			buf[BS_BootSig] = 0x29;						/* Extended boot signature */
 80182d8:	2229      	movs	r2, #41	; 0x29
	*ptr++ = (BYTE)val; val >>= 8;
 80182da:	75a9      	strb	r1, [r5, #22]
	*ptr++ = (BYTE)val;
 80182dc:	f885 002a 	strb.w	r0, [r5, #42]	; 0x2a
			buf[BS_BootSig] = 0x29;						/* Extended boot signature */
 80182e0:	f885 2026 	strb.w	r2, [r5, #38]	; 0x26
			mem_cpy(buf + BS_VolLab, "NO NAME    " "FAT     ", 19);	/* Volume label, FAT signature */
 80182e4:	f103 0012 	add.w	r0, r3, #18
 80182e8:	f105 022b 	add.w	r2, r5, #43	; 0x2b
 80182ec:	214e      	movs	r1, #78	; 0x4e
 80182ee:	e001      	b.n	80182f4 <f_mkfs+0x2c0>
			*d++ = *s++;
 80182f0:	f813 1f01 	ldrb.w	r1, [r3, #1]!
 80182f4:	f802 1b01 	strb.w	r1, [r2], #1
		} while (--cnt);
 80182f8:	4298      	cmp	r0, r3
 80182fa:	d1f9      	bne.n	80182f0 <f_mkfs+0x2bc>
	*ptr++ = (BYTE)val; val >>= 8;
 80182fc:	2355      	movs	r3, #85	; 0x55
 80182fe:	f885 31fe 	strb.w	r3, [r5, #510]	; 0x1fe
	*ptr++ = (BYTE)val;
 8018302:	23aa      	movs	r3, #170	; 0xaa
 8018304:	f885 31ff 	strb.w	r3, [r5, #511]	; 0x1ff
		if (disk_write(pdrv, buf, b_vol, 1) != RES_OK) return FR_DISK_ERR;	/* Write it to the VBR sector */
 8018308:	4629      	mov	r1, r5
 801830a:	2301      	movs	r3, #1
 801830c:	4652      	mov	r2, sl
 801830e:	4620      	mov	r0, r4
 8018310:	f7fd fbce 	bl	8015ab0 <disk_write>
 8018314:	4601      	mov	r1, r0
 8018316:	2800      	cmp	r0, #0
 8018318:	d138      	bne.n	801838c <f_mkfs+0x358>
		*d++ = (BYTE)val;
 801831a:	4632      	mov	r2, r6
 801831c:	4628      	mov	r0, r5
 801831e:	f00f f92b 	bl	8027578 <memset>
				st_dword(buf + 0, (fmt == FS_FAT12) ? 0xFFFFF8 : 0xFFFFFFF8);	/* Entry 0 and 1 */
 8018322:	4b0e      	ldr	r3, [pc, #56]	; (801835c <f_mkfs+0x328>)
 8018324:	f1bb 0f01 	cmp.w	fp, #1
 8018328:	bf18      	it	ne
 801832a:	f06f 0307 	mvnne.w	r3, #7
	*ptr++ = (BYTE)val; val >>= 8;
 801832e:	0e1b      	lsrs	r3, r3, #24
	*ptr++ = (BYTE)val;
 8018330:	70eb      	strb	r3, [r5, #3]
	*ptr++ = (BYTE)val; val >>= 8;
 8018332:	23ff      	movs	r3, #255	; 0xff
 8018334:	706b      	strb	r3, [r5, #1]
	*ptr++ = (BYTE)val; val >>= 8;
 8018336:	70ab      	strb	r3, [r5, #2]
	*ptr++ = (BYTE)val; val >>= 8;
 8018338:	23f8      	movs	r3, #248	; 0xf8
 801833a:	702b      	strb	r3, [r5, #0]
	sz_buf = len / ss;		/* Size of working buffer (sector) */
 801833c:	9b14      	ldr	r3, [sp, #80]	; 0x50
 801833e:	f8dd 8000 	ldr.w	r8, [sp]
 8018342:	f8dd 9014 	ldr.w	r9, [sp, #20]
 8018346:	9700      	str	r7, [sp, #0]
 8018348:	0b1e      	lsrs	r6, r3, #12
 801834a:	e00e      	b.n	801836a <f_mkfs+0x336>
 801834c:	20003310 	.word	0x20003310
 8018350:	00fff000 	.word	0x00fff000
 8018354:	08041810 	.word	0x08041810
 8018358:	0804181c 	.word	0x0804181c
 801835c:	00fffff8 	.word	0x00fffff8
		*d++ = (BYTE)val;
 8018360:	f00f f90a 	bl	8027578 <memset>
			} while (nsect);
 8018364:	ebb8 0807 	subs.w	r8, r8, r7
 8018368:	d07e      	beq.n	8018468 <f_mkfs+0x434>
				n = (nsect > sz_buf) ? sz_buf : nsect;
 801836a:	45b0      	cmp	r8, r6
 801836c:	4647      	mov	r7, r8
 801836e:	bf28      	it	cs
 8018370:	4637      	movcs	r7, r6
				if (disk_write(pdrv, buf, sect, (UINT)n) != RES_OK) return FR_DISK_ERR;
 8018372:	464a      	mov	r2, r9
 8018374:	4629      	mov	r1, r5
 8018376:	463b      	mov	r3, r7
 8018378:	4620      	mov	r0, r4
 801837a:	f7fd fb99 	bl	8015ab0 <disk_write>
 801837e:	4601      	mov	r1, r0
				sect += n; nsect -= n;
 8018380:	44b9      	add	r9, r7
		*d++ = (BYTE)val;
 8018382:	f44f 5280 	mov.w	r2, #4096	; 0x1000
 8018386:	4628      	mov	r0, r5
				if (disk_write(pdrv, buf, sect, (UINT)n) != RES_OK) return FR_DISK_ERR;
 8018388:	2900      	cmp	r1, #0
 801838a:	d0e9      	beq.n	8018360 <f_mkfs+0x32c>
		if (disk_ioctl(pdrv, GET_SECTOR_COUNT, &sz_vol) != RES_OK) return FR_DISK_ERR;
 801838c:	2001      	movs	r0, #1
 801838e:	e68e      	b.n	80180ae <f_mkfs+0x7a>
		b_vol = (opt & FM_SFD) ? 0 : 63;		/* Volume start sector */
 8018390:	4682      	mov	sl, r0
 8018392:	e6ac      	b.n	80180ee <f_mkfs+0xba>
					if ((opt & FM_FAT32)) {
 8018394:	9906      	ldr	r1, [sp, #24]
 8018396:	2900      	cmp	r1, #0
 8018398:	f43f af2e 	beq.w	80181f8 <f_mkfs+0x1c4>
				if (!pau) {	/* au auto-selection */
 801839c:	2a00      	cmp	r2, #0
 801839e:	d047      	beq.n	8018430 <f_mkfs+0x3fc>
 80183a0:	4611      	mov	r1, r2
				n_clst = sz_vol / pau;	/* Number of clusters */
 80183a2:	fbb3 f0f2 	udiv	r0, r3, r2
				sz_fat = (n_clst * 4 + 8 + ss - 1) / ss;	/* FAT size [sector] */
 80183a6:	0087      	lsls	r7, r0, #2
 80183a8:	f507 5780 	add.w	r7, r7, #4096	; 0x1000
 80183ac:	3707      	adds	r7, #7
 80183ae:	0b3f      	lsrs	r7, r7, #12
				if (n_clst <= MAX_FAT16 || n_clst > MAX_FAT32) return FR_MKFS_ABORTED;
 80183b0:	f5a0 407f 	sub.w	r0, r0, #65280	; 0xff00
				sz_fat = (n_clst * 4 + 8 + ss - 1) / ss;	/* FAT size [sector] */
 80183b4:	9700      	str	r7, [sp, #0]
				if (n_clst <= MAX_FAT16 || n_clst > MAX_FAT32) return FR_MKFS_ABORTED;
 80183b6:	4fbd      	ldr	r7, [pc, #756]	; (80186ac <f_mkfs+0x678>)
 80183b8:	38f6      	subs	r0, #246	; 0xf6
 80183ba:	42b8      	cmp	r0, r7
 80183bc:	f63f af1c 	bhi.w	80181f8 <f_mkfs+0x1c4>
			n = ((b_data + sz_blk - 1) & ~(sz_blk - 1)) - b_data;	/* Next nearest erase block from current data base */
 80183c0:	9808      	ldr	r0, [sp, #32]
 80183c2:	9003      	str	r0, [sp, #12]
 80183c4:	4617      	mov	r7, r2
 80183c6:	460a      	mov	r2, r1
			b_data = b_fat + sz_fat * n_fats + sz_dir;	/* Data base */
 80183c8:	9900      	ldr	r1, [sp, #0]
			b_fat = b_vol + sz_rsv;						/* FAT base */
 80183ca:	f10a 0e20 	add.w	lr, sl, #32
			b_data = b_fat + sz_fat * n_fats + sz_dir;	/* Data base */
 80183ce:	4471      	add	r1, lr
			n = ((b_data + sz_blk - 1) & ~(sz_blk - 1)) - b_data;	/* Next nearest erase block from current data base */
 80183d0:	f100 3cff 	add.w	ip, r0, #4294967295
 80183d4:	f1c0 0800 	rsb	r8, r0, #0
 80183d8:	448c      	add	ip, r1
 80183da:	ea0c 0b08 	and.w	fp, ip, r8
 80183de:	ebab 0b01 	sub.w	fp, fp, r1
				sz_rsv += n; b_fat += n;
 80183e2:	eb0e 000b 	add.w	r0, lr, fp
 80183e6:	9005      	str	r0, [sp, #20]
 80183e8:	f10b 0020 	add.w	r0, fp, #32
 80183ec:	9001      	str	r0, [sp, #4]
 80183ee:	2000      	movs	r0, #0
 80183f0:	f04f 0b03 	mov.w	fp, #3
 80183f4:	9002      	str	r0, [sp, #8]
 80183f6:	e6bb      	b.n	8018170 <f_mkfs+0x13c>
		if (!(opt & FM_FAT)) return FR_INVALID_PARAMETER;	/* no-FAT? */
 80183f8:	07f9      	lsls	r1, r7, #31
 80183fa:	f57f ae53 	bpl.w	80180a4 <f_mkfs+0x70>
 80183fe:	e68c      	b.n	801811a <f_mkfs+0xe6>
					for (i = 0, pau = 1; cst[i] && cst[i] <= n; i++, pau <<= 1) ;	/* Get from table */
 8018400:	2701      	movs	r7, #1
 8018402:	f8df c2b4 	ldr.w	ip, [pc, #692]	; 80186b8 <f_mkfs+0x684>
 8018406:	9803      	ldr	r0, [sp, #12]
					n = sz_vol / 0x1000;	/* Volume size in unit of 4KS */
 8018408:	ea4f 3e13 	mov.w	lr, r3, lsr #12
					for (i = 0, pau = 1; cst[i] && cst[i] <= n; i++, pau <<= 1) ;	/* Get from table */
 801840c:	4639      	mov	r1, r7
 801840e:	e003      	b.n	8018418 <f_mkfs+0x3e4>
 8018410:	f83c 1b02 	ldrh.w	r1, [ip], #2
 8018414:	007f      	lsls	r7, r7, #1
 8018416:	b109      	cbz	r1, 801841c <f_mkfs+0x3e8>
 8018418:	4571      	cmp	r1, lr
 801841a:	d9f9      	bls.n	8018410 <f_mkfs+0x3dc>
 801841c:	9003      	str	r0, [sp, #12]
 801841e:	e682      	b.n	8018126 <f_mkfs+0xf2>
					if (!au && (au = pau / 2) != 0) continue;	/* Adjust cluster size and retry */
 8018420:	2a00      	cmp	r2, #0
 8018422:	f47f aee9 	bne.w	80181f8 <f_mkfs+0x1c4>
 8018426:	2f01      	cmp	r7, #1
 8018428:	f67f aee6 	bls.w	80181f8 <f_mkfs+0x1c4>
 801842c:	087a      	lsrs	r2, r7, #1
 801842e:	e7b5      	b.n	801839c <f_mkfs+0x368>
					for (i = 0, pau = 1; cst32[i] && cst32[i] <= n; i++, pau <<= 1) ;	/* Get from table */
 8018430:	2201      	movs	r2, #1
 8018432:	489f      	ldr	r0, [pc, #636]	; (80186b0 <f_mkfs+0x67c>)
					n = sz_vol / 0x20000;	/* Volume size in unit of 128KS */
 8018434:	0c5f      	lsrs	r7, r3, #17
					for (i = 0, pau = 1; cst32[i] && cst32[i] <= n; i++, pau <<= 1) ;	/* Get from table */
 8018436:	4611      	mov	r1, r2
 8018438:	e004      	b.n	8018444 <f_mkfs+0x410>
 801843a:	f830 1b02 	ldrh.w	r1, [r0], #2
 801843e:	0052      	lsls	r2, r2, #1
 8018440:	2900      	cmp	r1, #0
 8018442:	d0ae      	beq.n	80183a2 <f_mkfs+0x36e>
 8018444:	42b9      	cmp	r1, r7
 8018446:	d9f8      	bls.n	801843a <f_mkfs+0x406>
 8018448:	2100      	movs	r1, #0
 801844a:	e7aa      	b.n	80183a2 <f_mkfs+0x36e>
 801844c:	463a      	mov	r2, r7
 801844e:	e666      	b.n	801811e <f_mkfs+0xea>
	*ptr++ = (BYTE)val; val >>= 8;
 8018450:	0a1a      	lsrs	r2, r3, #8
 8018452:	f885 3020 	strb.w	r3, [r5, #32]
	*ptr++ = (BYTE)val; val >>= 8;
 8018456:	f885 2021 	strb.w	r2, [r5, #33]	; 0x21
 801845a:	0c1a      	lsrs	r2, r3, #16
	*ptr++ = (BYTE)val; val >>= 8;
 801845c:	0e1b      	lsrs	r3, r3, #24
 801845e:	f885 2022 	strb.w	r2, [r5, #34]	; 0x22
	*ptr++ = (BYTE)val;
 8018462:	f885 3023 	strb.w	r3, [r5, #35]	; 0x23
}
 8018466:	e70a      	b.n	801827e <f_mkfs+0x24a>
		nsect = (fmt == FS_FAT32) ? pau : sz_dir;	/* Number of root directory sectors */
 8018468:	9f00      	ldr	r7, [sp, #0]
 801846a:	9b02      	ldr	r3, [sp, #8]
 801846c:	f1bb 0f03 	cmp.w	fp, #3
 8018470:	bf18      	it	ne
 8018472:	461f      	movne	r7, r3
 8018474:	e003      	b.n	801847e <f_mkfs+0x44a>
		} while (nsect);
 8018476:	ebb7 0708 	subs.w	r7, r7, r8
 801847a:	f000 80c0 	beq.w	80185fe <f_mkfs+0x5ca>
			n = (nsect > sz_buf) ? sz_buf : nsect;
 801847e:	42b7      	cmp	r7, r6
 8018480:	46b8      	mov	r8, r7
 8018482:	bf28      	it	cs
 8018484:	46b0      	movcs	r8, r6
			if (disk_write(pdrv, buf, sect, (UINT)n) != RES_OK) return FR_DISK_ERR;
 8018486:	464a      	mov	r2, r9
 8018488:	4643      	mov	r3, r8
 801848a:	4629      	mov	r1, r5
 801848c:	4620      	mov	r0, r4
			sect += n; nsect -= n;
 801848e:	44c1      	add	r9, r8
			if (disk_write(pdrv, buf, sect, (UINT)n) != RES_OK) return FR_DISK_ERR;
 8018490:	f7fd fb0e 	bl	8015ab0 <disk_write>
 8018494:	2800      	cmp	r0, #0
 8018496:	d0ee      	beq.n	8018476 <f_mkfs+0x442>
 8018498:	e778      	b.n	801838c <f_mkfs+0x358>
			st_dword(buf + BS_VolID32, GET_FATTIME());	/* VSN */
 801849a:	f006 fc01 	bl	801eca0 <get_fattime>
	*ptr++ = (BYTE)val; val >>= 8;
 801849e:	9900      	ldr	r1, [sp, #0]
	const BYTE *s = (const BYTE*)src;
 80184a0:	4b84      	ldr	r3, [pc, #528]	; (80186b4 <f_mkfs+0x680>)
	*ptr++ = (BYTE)val; val >>= 8;
 80184a2:	f885 0043 	strb.w	r0, [r5, #67]	; 0x43
 80184a6:	0a02      	lsrs	r2, r0, #8
	*ptr++ = (BYTE)val; val >>= 8;
 80184a8:	f885 2044 	strb.w	r2, [r5, #68]	; 0x44
 80184ac:	0c02      	lsrs	r2, r0, #16
	*ptr++ = (BYTE)val; val >>= 8;
 80184ae:	f885 2045 	strb.w	r2, [r5, #69]	; 0x45
	*ptr++ = (BYTE)val; val >>= 8;
 80184b2:	0a0a      	lsrs	r2, r1, #8
	*ptr++ = (BYTE)val; val >>= 8;
 80184b4:	f885 2025 	strb.w	r2, [r5, #37]	; 0x25
 80184b8:	0c0a      	lsrs	r2, r1, #16
	*ptr++ = (BYTE)val; val >>= 8;
 80184ba:	f885 2026 	strb.w	r2, [r5, #38]	; 0x26
 80184be:	0e0a      	lsrs	r2, r1, #24
	*ptr++ = (BYTE)val;
 80184c0:	f885 2027 	strb.w	r2, [r5, #39]	; 0x27
	*ptr++ = (BYTE)val; val >>= 8;
 80184c4:	2202      	movs	r2, #2
 80184c6:	f885 202c 	strb.w	r2, [r5, #44]	; 0x2c
	*ptr++ = (BYTE)val; val >>= 8;
 80184ca:	2201      	movs	r2, #1
 80184cc:	f885 2030 	strb.w	r2, [r5, #48]	; 0x30
 80184d0:	2206      	movs	r2, #6
 80184d2:	f885 2032 	strb.w	r2, [r5, #50]	; 0x32
			buf[BS_DrvNum32] = 0x80;					/* Drive number (for int13) */
 80184d6:	2280      	movs	r2, #128	; 0x80
	*ptr++ = (BYTE)val; val >>= 8;
 80184d8:	0e00      	lsrs	r0, r0, #24
			buf[BS_DrvNum32] = 0x80;					/* Drive number (for int13) */
 80184da:	f885 2040 	strb.w	r2, [r5, #64]	; 0x40
			buf[BS_BootSig32] = 0x29;					/* Extended boot signature */
 80184de:	2229      	movs	r2, #41	; 0x29
	*ptr++ = (BYTE)val;
 80184e0:	f885 0046 	strb.w	r0, [r5, #70]	; 0x46
			buf[BS_BootSig32] = 0x29;					/* Extended boot signature */
 80184e4:	f885 2042 	strb.w	r2, [r5, #66]	; 0x42
	*ptr++ = (BYTE)val; val >>= 8;
 80184e8:	f885 1024 	strb.w	r1, [r5, #36]	; 0x24
	*ptr++ = (BYTE)val; val >>= 8;
 80184ec:	f885 902d 	strb.w	r9, [r5, #45]	; 0x2d
	*ptr++ = (BYTE)val; val >>= 8;
 80184f0:	f885 902e 	strb.w	r9, [r5, #46]	; 0x2e
	*ptr++ = (BYTE)val;
 80184f4:	f885 902f 	strb.w	r9, [r5, #47]	; 0x2f
	*ptr++ = (BYTE)val;
 80184f8:	f885 9031 	strb.w	r9, [r5, #49]	; 0x31
 80184fc:	f885 9033 	strb.w	r9, [r5, #51]	; 0x33
 8018500:	f105 0246 	add.w	r2, r5, #70	; 0x46
 8018504:	f103 0013 	add.w	r0, r3, #19
			*d++ = *s++;
 8018508:	f813 1b01 	ldrb.w	r1, [r3], #1
 801850c:	f802 1f01 	strb.w	r1, [r2, #1]!
		} while (--cnt);
 8018510:	4283      	cmp	r3, r0
 8018512:	d1f9      	bne.n	8018508 <f_mkfs+0x4d4>
	*ptr++ = (BYTE)val; val >>= 8;
 8018514:	f04f 0355 	mov.w	r3, #85	; 0x55
 8018518:	f885 31fe 	strb.w	r3, [r5, #510]	; 0x1fe
	*ptr++ = (BYTE)val;
 801851c:	f06f 0355 	mvn.w	r3, #85	; 0x55
 8018520:	f885 31ff 	strb.w	r3, [r5, #511]	; 0x1ff
		if (disk_write(pdrv, buf, b_vol, 1) != RES_OK) return FR_DISK_ERR;	/* Write it to the VBR sector */
 8018524:	4652      	mov	r2, sl
 8018526:	2301      	movs	r3, #1
 8018528:	4629      	mov	r1, r5
 801852a:	4620      	mov	r0, r4
 801852c:	f7fd fac0 	bl	8015ab0 <disk_write>
 8018530:	4681      	mov	r9, r0
 8018532:	2800      	cmp	r0, #0
 8018534:	f47f af2a 	bne.w	801838c <f_mkfs+0x358>
			disk_write(pdrv, buf, b_vol + 6, 1);		/* Write backup VBR (VBR + 6) */
 8018538:	2301      	movs	r3, #1
 801853a:	f10a 0206 	add.w	r2, sl, #6
 801853e:	4629      	mov	r1, r5
 8018540:	4620      	mov	r0, r4
 8018542:	f7fd fab5 	bl	8015ab0 <disk_write>
		*d++ = (BYTE)val;
 8018546:	f44f 5280 	mov.w	r2, #4096	; 0x1000
 801854a:	4649      	mov	r1, r9
 801854c:	4628      	mov	r0, r5
 801854e:	f00f f813 	bl	8027578 <memset>
	*ptr++ = (BYTE)val; val >>= 8;
 8018552:	f04f 0355 	mov.w	r3, #85	; 0x55
 8018556:	f885 31fe 	strb.w	r3, [r5, #510]	; 0x1fe
	*ptr++ = (BYTE)val;
 801855a:	f06f 0355 	mvn.w	r3, #85	; 0x55
 801855e:	f885 31ff 	strb.w	r3, [r5, #511]	; 0x1ff
	*ptr++ = (BYTE)val; val >>= 8;
 8018562:	2352      	movs	r3, #82	; 0x52
 8018564:	702b      	strb	r3, [r5, #0]
	*ptr++ = (BYTE)val; val >>= 8;
 8018566:	706b      	strb	r3, [r5, #1]
	*ptr++ = (BYTE)val; val >>= 8;
 8018568:	2361      	movs	r3, #97	; 0x61
 801856a:	70ab      	strb	r3, [r5, #2]
	*ptr++ = (BYTE)val;
 801856c:	f885 31e7 	strb.w	r3, [r5, #487]	; 0x1e7
 8018570:	2341      	movs	r3, #65	; 0x41
			st_dword(buf + FSI_Free_Count, n_clst - 1);	/* Number of free clusters */
 8018572:	f108 38ff 	add.w	r8, r8, #4294967295
	*ptr++ = (BYTE)val;
 8018576:	70eb      	strb	r3, [r5, #3]
	*ptr++ = (BYTE)val; val >>= 8;
 8018578:	f885 31e6 	strb.w	r3, [r5, #486]	; 0x1e6
	*ptr++ = (BYTE)val; val >>= 8;
 801857c:	2372      	movs	r3, #114	; 0x72
 801857e:	f885 31e4 	strb.w	r3, [r5, #484]	; 0x1e4
	*ptr++ = (BYTE)val; val >>= 8;
 8018582:	f885 31e5 	strb.w	r3, [r5, #485]	; 0x1e5
	*ptr++ = (BYTE)val; val >>= 8;
 8018586:	ea4f 2318 	mov.w	r3, r8, lsr #8
	*ptr++ = (BYTE)val; val >>= 8;
 801858a:	f885 31e9 	strb.w	r3, [r5, #489]	; 0x1e9
 801858e:	ea4f 4318 	mov.w	r3, r8, lsr #16
	*ptr++ = (BYTE)val; val >>= 8;
 8018592:	f885 81e8 	strb.w	r8, [r5, #488]	; 0x1e8
	*ptr++ = (BYTE)val; val >>= 8;
 8018596:	f885 31ea 	strb.w	r3, [r5, #490]	; 0x1ea
 801859a:	ea4f 6818 	mov.w	r8, r8, lsr #24
	*ptr++ = (BYTE)val; val >>= 8;
 801859e:	2302      	movs	r3, #2
 80185a0:	f885 31ec 	strb.w	r3, [r5, #492]	; 0x1ec
			disk_write(pdrv, buf, b_vol + 7, 1);		/* Write backup FSINFO (VBR + 7) */
 80185a4:	f10a 0207 	add.w	r2, sl, #7
 80185a8:	2301      	movs	r3, #1
 80185aa:	4629      	mov	r1, r5
	*ptr++ = (BYTE)val;
 80185ac:	f885 81eb 	strb.w	r8, [r5, #491]	; 0x1eb
			disk_write(pdrv, buf, b_vol + 7, 1);		/* Write backup FSINFO (VBR + 7) */
 80185b0:	4620      	mov	r0, r4
 80185b2:	f7fd fa7d 	bl	8015ab0 <disk_write>
			disk_write(pdrv, buf, b_vol + 1, 1);		/* Write original FSINFO (VBR + 1) */
 80185b6:	2301      	movs	r3, #1
 80185b8:	eb0a 0203 	add.w	r2, sl, r3
 80185bc:	4629      	mov	r1, r5
 80185be:	4620      	mov	r0, r4
 80185c0:	f7fd fa76 	bl	8015ab0 <disk_write>
		*d++ = (BYTE)val;
 80185c4:	4632      	mov	r2, r6
 80185c6:	4649      	mov	r1, r9
 80185c8:	4628      	mov	r0, r5
 80185ca:	f00e ffd5 	bl	8027578 <memset>
	*ptr++ = (BYTE)val; val >>= 8;
 80185ce:	23ff      	movs	r3, #255	; 0xff
 80185d0:	706b      	strb	r3, [r5, #1]
	*ptr++ = (BYTE)val; val >>= 8;
 80185d2:	70ab      	strb	r3, [r5, #2]
	*ptr++ = (BYTE)val;
 80185d4:	70eb      	strb	r3, [r5, #3]
	*ptr++ = (BYTE)val; val >>= 8;
 80185d6:	712b      	strb	r3, [r5, #4]
	*ptr++ = (BYTE)val; val >>= 8;
 80185d8:	716b      	strb	r3, [r5, #5]
	*ptr++ = (BYTE)val; val >>= 8;
 80185da:	71ab      	strb	r3, [r5, #6]
	*ptr++ = (BYTE)val;
 80185dc:	71eb      	strb	r3, [r5, #7]
	*ptr++ = (BYTE)val; val >>= 8;
 80185de:	722b      	strb	r3, [r5, #8]
	*ptr++ = (BYTE)val; val >>= 8;
 80185e0:	726b      	strb	r3, [r5, #9]
	*ptr++ = (BYTE)val; val >>= 8;
 80185e2:	72ab      	strb	r3, [r5, #10]
	*ptr++ = (BYTE)val; val >>= 8;
 80185e4:	23f8      	movs	r3, #248	; 0xf8
 80185e6:	702b      	strb	r3, [r5, #0]
	*ptr++ = (BYTE)val;
 80185e8:	230f      	movs	r3, #15
 80185ea:	72eb      	strb	r3, [r5, #11]
}
 80185ec:	e6a6      	b.n	801833c <f_mkfs+0x308>
			if (fmt == FS_FAT12 && n_clst > MAX_FAT12) return FR_MKFS_ABORTED;	/* Too many clusters for FAT12 */
 80185ee:	f640 72f5 	movw	r2, #4085	; 0xff5
 80185f2:	4590      	cmp	r8, r2
 80185f4:	f63f ae00 	bhi.w	80181f8 <f_mkfs+0x1c4>
 80185f8:	f04f 0b01 	mov.w	fp, #1
 80185fc:	e60d      	b.n	801821a <f_mkfs+0x1e6>
		if (fmt == FS_FAT32) {
 80185fe:	f1bb 0f03 	cmp.w	fp, #3
 8018602:	d050      	beq.n	80186a6 <f_mkfs+0x672>
			if (sz_vol >= 0x10000) {
 8018604:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8018606:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 801860a:	d24a      	bcs.n	80186a2 <f_mkfs+0x66e>
				sys = (fmt == FS_FAT16) ? 0x04 : 0x01;	/* FAT16 (<64KS) : FAT12 (<64KS) */
 801860c:	f1bb 0f02 	cmp.w	fp, #2
 8018610:	bf0c      	ite	eq
 8018612:	2604      	moveq	r6, #4
 8018614:	2601      	movne	r6, #1
		if (!(opt & FM_SFD)) {	/* Create partition table if in FDISK format */
 8018616:	9b04      	ldr	r3, [sp, #16]
 8018618:	bbd3      	cbnz	r3, 8018690 <f_mkfs+0x65c>
		*d++ = (BYTE)val;
 801861a:	9f04      	ldr	r7, [sp, #16]
 801861c:	f44f 5280 	mov.w	r2, #4096	; 0x1000
 8018620:	4639      	mov	r1, r7
 8018622:	4628      	mov	r0, r5
 8018624:	f00e ffa8 	bl	8027578 <memset>
			n = (b_vol + sz_vol) / (63 * 255);	/* (End CHS may be invalid) */
 8018628:	9909      	ldr	r1, [sp, #36]	; 0x24
	*ptr++ = (BYTE)val; val >>= 8;
 801862a:	9b01      	ldr	r3, [sp, #4]
 801862c:	f885 31c6 	strb.w	r3, [r5, #454]	; 0x1c6
			n = (b_vol + sz_vol) / (63 * 255);	/* (End CHS may be invalid) */
 8018630:	f643 60c1 	movw	r0, #16065	; 0x3ec1
 8018634:	eb01 030a 	add.w	r3, r1, sl
 8018638:	fbb3 f3f0 	udiv	r3, r3, r0
			pte[PTE_EdCyl] = (BYTE)n;			/* End cylinder */
 801863c:	f885 31c5 	strb.w	r3, [r5, #453]	; 0x1c5
			pte[PTE_EdSec] = (BYTE)(n >> 2 | 63);	/* End sector */
 8018640:	089b      	lsrs	r3, r3, #2
 8018642:	f043 033f 	orr.w	r3, r3, #63	; 0x3f
			pte[PTE_System] = sys;				/* System type */
 8018646:	f885 61c2 	strb.w	r6, [r5, #450]	; 0x1c2
			pte[PTE_EdSec] = (BYTE)(n >> 2 | 63);	/* End sector */
 801864a:	f885 31c4 	strb.w	r3, [r5, #452]	; 0x1c4
	*ptr++ = (BYTE)val; val >>= 8;
 801864e:	2655      	movs	r6, #85	; 0x55
	*ptr++ = (BYTE)val; val >>= 8;
 8018650:	0a0b      	lsrs	r3, r1, #8
	*ptr++ = (BYTE)val; val >>= 8;
 8018652:	f885 31cb 	strb.w	r3, [r5, #459]	; 0x1cb
	*ptr++ = (BYTE)val; val >>= 8;
 8018656:	f885 61fe 	strb.w	r6, [r5, #510]	; 0x1fe
	*ptr++ = (BYTE)val; val >>= 8;
 801865a:	0c0b      	lsrs	r3, r1, #16
	*ptr++ = (BYTE)val;
 801865c:	26aa      	movs	r6, #170	; 0xaa
	*ptr++ = (BYTE)val; val >>= 8;
 801865e:	f885 11ca 	strb.w	r1, [r5, #458]	; 0x1ca
	*ptr++ = (BYTE)val; val >>= 8;
 8018662:	f885 31cc 	strb.w	r3, [r5, #460]	; 0x1cc
 8018666:	0e09      	lsrs	r1, r1, #24
			pte[PTE_StHead] = 1;				/* Start head */
 8018668:	2301      	movs	r3, #1
	*ptr++ = (BYTE)val;
 801866a:	f885 61ff 	strb.w	r6, [r5, #511]	; 0x1ff
			pte[PTE_EdHead] = 254;				/* End head */
 801866e:	26fe      	movs	r6, #254	; 0xfe
	*ptr++ = (BYTE)val;
 8018670:	f885 11cd 	strb.w	r1, [r5, #461]	; 0x1cd
			if (disk_write(pdrv, buf, 0, 1) != RES_OK) return FR_DISK_ERR;	/* Write it to the MBR */
 8018674:	463a      	mov	r2, r7
 8018676:	4629      	mov	r1, r5
 8018678:	4620      	mov	r0, r4
			pte[PTE_StHead] = 1;				/* Start head */
 801867a:	f885 31bf 	strb.w	r3, [r5, #447]	; 0x1bf
			pte[PTE_StSec] = 1;					/* Start sector */
 801867e:	f885 31c0 	strb.w	r3, [r5, #448]	; 0x1c0
			pte[PTE_EdHead] = 254;				/* End head */
 8018682:	f885 61c3 	strb.w	r6, [r5, #451]	; 0x1c3
			if (disk_write(pdrv, buf, 0, 1) != RES_OK) return FR_DISK_ERR;	/* Write it to the MBR */
 8018686:	f7fd fa13 	bl	8015ab0 <disk_write>
 801868a:	2800      	cmp	r0, #0
 801868c:	f47f ae7e 	bne.w	801838c <f_mkfs+0x358>
	if (disk_ioctl(pdrv, CTRL_SYNC, 0) != RES_OK) return FR_DISK_ERR;
 8018690:	2200      	movs	r2, #0
 8018692:	4611      	mov	r1, r2
 8018694:	4620      	mov	r0, r4
 8018696:	f7fd fa19 	bl	8015acc <disk_ioctl>
	if (vol < 0) return FR_INVALID_DRIVE;
 801869a:	3800      	subs	r0, #0
 801869c:	bf18      	it	ne
 801869e:	2001      	movne	r0, #1
 80186a0:	e505      	b.n	80180ae <f_mkfs+0x7a>
				sys = 0x06;	/* FAT12/16 (>=64KS) */
 80186a2:	2606      	movs	r6, #6
 80186a4:	e7b7      	b.n	8018616 <f_mkfs+0x5e2>
			sys = 0x0C;		/* FAT32X */
 80186a6:	260c      	movs	r6, #12
 80186a8:	e7b5      	b.n	8018616 <f_mkfs+0x5e2>
 80186aa:	bf00      	nop
 80186ac:	0ffeffff 	.word	0x0ffeffff
 80186b0:	0802d3d6 	.word	0x0802d3d6
 80186b4:	080417fc 	.word	0x080417fc
 80186b8:	0802d3e6 	.word	0x0802d3e6

080186bc <f_gets>:
TCHAR* f_gets (
	TCHAR* buff,	/* Pointer to the string buffer to read */
	int len,		/* Size of string buffer (characters) */
	FIL* fp			/* Pointer to the file object */
)
{
 80186bc:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80186c0:	4680      	mov	r8, r0
 80186c2:	b082      	sub	sp, #8
 80186c4:	4617      	mov	r7, r2
	TCHAR c, *p = buff;
	BYTE s[2];
	UINT rc;


	while (n < len - 1) {	/* Read characters until buffer gets filled */
 80186c6:	1e4e      	subs	r6, r1, #1
	TCHAR c, *p = buff;
 80186c8:	4605      	mov	r5, r0
	int n = 0;
 80186ca:	2400      	movs	r4, #0
	while (n < len - 1) {	/* Read characters until buffer gets filled */
 80186cc:	42b4      	cmp	r4, r6
		}
		c = ff_convert(c, 1);	/* OEM -> Unicode */
		if (!c) c = '?';
#endif
#else						/* Read a character without conversion */
		f_read(fp, s, 1, &rc);
 80186ce:	ab01      	add	r3, sp, #4
 80186d0:	f04f 0201 	mov.w	r2, #1
 80186d4:	4669      	mov	r1, sp
 80186d6:	4638      	mov	r0, r7
	while (n < len - 1) {	/* Read characters until buffer gets filled */
 80186d8:	da14      	bge.n	8018704 <f_gets+0x48>
		f_read(fp, s, 1, &rc);
 80186da:	f7fe ff89 	bl	80175f0 <f_read>
		if (rc != 1) break;
 80186de:	9b01      	ldr	r3, [sp, #4]
 80186e0:	2b01      	cmp	r3, #1
 80186e2:	d10f      	bne.n	8018704 <f_gets+0x48>
		c = s[0];
 80186e4:	f89d 3000 	ldrb.w	r3, [sp]
#endif
		if (_USE_STRFUNC == 2 && c == '\r') continue;	/* Strip '\r' */
 80186e8:	2b0d      	cmp	r3, #13
 80186ea:	d0ef      	beq.n	80186cc <f_gets+0x10>
		*p++ = c;
		n++;
		if (c == '\n') break;		/* Break on EOL */
 80186ec:	2b0a      	cmp	r3, #10
		*p++ = c;
 80186ee:	f805 3b01 	strb.w	r3, [r5], #1
		n++;
 80186f2:	f104 0401 	add.w	r4, r4, #1
		if (c == '\n') break;		/* Break on EOL */
 80186f6:	d1e9      	bne.n	80186cc <f_gets+0x10>
	}
	*p = 0;
 80186f8:	2300      	movs	r3, #0
	return n ? buff : 0;			/* When no data read (eof or error), return with error. */
}
 80186fa:	4640      	mov	r0, r8
	*p = 0;
 80186fc:	702b      	strb	r3, [r5, #0]
}
 80186fe:	b002      	add	sp, #8
 8018700:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	*p = 0;
 8018704:	2300      	movs	r3, #0
	return n ? buff : 0;			/* When no data read (eof or error), return with error. */
 8018706:	429c      	cmp	r4, r3
 8018708:	bf08      	it	eq
 801870a:	4698      	moveq	r8, r3
}
 801870c:	4640      	mov	r0, r8
	*p = 0;
 801870e:	702b      	strb	r3, [r5, #0]
}
 8018710:	b002      	add	sp, #8
 8018712:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8018716:	bf00      	nop

08018718 <FATFS_LinkDriver>:
  * @param  drv: pointer to the disk IO Driver structure
  * @param  path: pointer to the logical drive path
  * @retval Returns 0 in case of success, otherwise 1.
  */
uint8_t FATFS_LinkDriver(const Diskio_drvTypeDef *drv, char *path)
{
 8018718:	b410      	push	{r4}
  if(disk.nbr < _VOLUMES)
 801871a:	4b10      	ldr	r3, [pc, #64]	; (801875c <FATFS_LinkDriver+0x44>)
 801871c:	7a5c      	ldrb	r4, [r3, #9]
 801871e:	b9cc      	cbnz	r4, 8018754 <FATFS_LinkDriver+0x3c>
 8018720:	4602      	mov	r2, r0
    disk.is_initialized[disk.nbr] = 0;
 8018722:	f004 00ff 	and.w	r0, r4, #255	; 0xff
 8018726:	7a5c      	ldrb	r4, [r3, #9]
 8018728:	5518      	strb	r0, [r3, r4]
    disk.drv[disk.nbr] = drv;
 801872a:	7a5c      	ldrb	r4, [r3, #9]
 801872c:	eb03 0484 	add.w	r4, r3, r4, lsl #2
 8018730:	6062      	str	r2, [r4, #4]
    disk.lun[disk.nbr] = lun;
 8018732:	7a5c      	ldrb	r4, [r3, #9]
    DiskNum = disk.nbr++;
 8018734:	7a5a      	ldrb	r2, [r3, #9]
    disk.lun[disk.nbr] = lun;
 8018736:	441c      	add	r4, r3
 8018738:	7220      	strb	r0, [r4, #8]
    DiskNum = disk.nbr++;
 801873a:	1c54      	adds	r4, r2, #1
 801873c:	b2e4      	uxtb	r4, r4
 801873e:	725c      	strb	r4, [r3, #9]
    path[0] = DiskNum + '0';
 8018740:	3230      	adds	r2, #48	; 0x30
    path[1] = ':';
 8018742:	243a      	movs	r4, #58	; 0x3a
    path[2] = '/';
 8018744:	232f      	movs	r3, #47	; 0x2f
    path[1] = ':';
 8018746:	704c      	strb	r4, [r1, #1]
    path[0] = DiskNum + '0';
 8018748:	700a      	strb	r2, [r1, #0]
  return FATFS_LinkDriverEx(drv, path, 0);
}
 801874a:	f85d 4b04 	ldr.w	r4, [sp], #4
    path[2] = '/';
 801874e:	708b      	strb	r3, [r1, #2]
    path[3] = 0;
 8018750:	70c8      	strb	r0, [r1, #3]
}
 8018752:	4770      	bx	lr
  uint8_t ret = 1;
 8018754:	2001      	movs	r0, #1
}
 8018756:	f85d 4b04 	ldr.w	r4, [sp], #4
 801875a:	4770      	bx	lr
 801875c:	20003338 	.word	0x20003338

08018760 <FATFS_UnLinkDriver>:
uint8_t FATFS_UnLinkDriverEx(char *path, uint8_t lun)
{
  uint8_t DiskNum = 0;
  uint8_t ret = 1;

  if(disk.nbr >= 1)
 8018760:	4a0b      	ldr	r2, [pc, #44]	; (8018790 <FATFS_UnLinkDriver+0x30>)
 8018762:	7a53      	ldrb	r3, [r2, #9]
 8018764:	b18b      	cbz	r3, 801878a <FATFS_UnLinkDriver+0x2a>
  {
    DiskNum = path[0] - '0';
 8018766:	7803      	ldrb	r3, [r0, #0]
 8018768:	3b30      	subs	r3, #48	; 0x30
    if(disk.drv[DiskNum] != 0)
 801876a:	b2db      	uxtb	r3, r3
 801876c:	eb02 0c83 	add.w	ip, r2, r3, lsl #2
 8018770:	f8dc 1004 	ldr.w	r1, [ip, #4]
 8018774:	b149      	cbz	r1, 801878a <FATFS_UnLinkDriver+0x2a>
    {
      disk.drv[DiskNum] = 0;
      disk.lun[DiskNum] = 0;
      disk.nbr--;
 8018776:	7a51      	ldrb	r1, [r2, #9]
      disk.lun[DiskNum] = 0;
 8018778:	4413      	add	r3, r2
      disk.nbr--;
 801877a:	3901      	subs	r1, #1
      disk.drv[DiskNum] = 0;
 801877c:	2000      	movs	r0, #0
      disk.nbr--;
 801877e:	b2c9      	uxtb	r1, r1
      disk.drv[DiskNum] = 0;
 8018780:	f8cc 0004 	str.w	r0, [ip, #4]
      disk.lun[DiskNum] = 0;
 8018784:	7218      	strb	r0, [r3, #8]
      disk.nbr--;
 8018786:	7251      	strb	r1, [r2, #9]
      ret = 0;
 8018788:	4770      	bx	lr
  uint8_t ret = 1;
 801878a:	2001      	movs	r0, #1
  * @retval Returns 0 in case of success, otherwise 1.
  */
uint8_t FATFS_UnLinkDriver(char *path)
{
  return FATFS_UnLinkDriverEx(path, 0);
}
 801878c:	4770      	bx	lr
 801878e:	bf00      	nop
 8018790:	20003338 	.word	0x20003338

08018794 <ff_memalloc>:

void* ff_memalloc (	/* Returns pointer to the allocated memory block */
	UINT msize		/* Number of bytes to allocate */
)
{
	return ff_malloc(msize);	/* Allocate a new memory block with POSIX API */
 8018794:	f00e bea8 	b.w	80274e8 <malloc>

08018798 <ff_memfree>:

void ff_memfree (
	void* mblock	/* Pointer to the memory block to free */
)
{
	ff_free(mblock);	/* Discard the memory block with POSIX API */
 8018798:	f00e beae 	b.w	80274f8 <free>

0801879c <ff_convert>:
)
{
	WCHAR c;


	if (chr < 0x80) {	/* ASCII */
 801879c:	287f      	cmp	r0, #127	; 0x7f
 801879e:	d914      	bls.n	80187ca <ff_convert+0x2e>
		c = chr;

	} else {
		if (dir) {		/* OEM code to Unicode */
 80187a0:	b981      	cbnz	r1, 80187c4 <ff_convert+0x28>
 80187a2:	4a0d      	ldr	r2, [pc, #52]	; (80187d8 <ff_convert+0x3c>)
 80187a4:	23c7      	movs	r3, #199	; 0xc7
 80187a6:	e003      	b.n	80187b0 <ff_convert+0x14>
			c = (chr >= 0x100) ? 0 : Tbl[chr - 0x80];

		} else {		/* Unicode to OEM code */
			for (c = 0; c < 0x80; c++) {
 80187a8:	2980      	cmp	r1, #128	; 0x80
 80187aa:	d00d      	beq.n	80187c8 <ff_convert+0x2c>
				if (chr == Tbl[c]) break;
 80187ac:	f832 3f02 	ldrh.w	r3, [r2, #2]!
 80187b0:	4298      	cmp	r0, r3
 80187b2:	fa1f fc81 	uxth.w	ip, r1
			for (c = 0; c < 0x80; c++) {
 80187b6:	f101 0101 	add.w	r1, r1, #1
				if (chr == Tbl[c]) break;
 80187ba:	d1f5      	bne.n	80187a8 <ff_convert+0xc>
			}
			c = (c + 0x80) & 0xFF;
 80187bc:	f10c 0080 	add.w	r0, ip, #128	; 0x80
 80187c0:	b280      	uxth	r0, r0
 80187c2:	4770      	bx	lr
			c = (chr >= 0x100) ? 0 : Tbl[chr - 0x80];
 80187c4:	28ff      	cmp	r0, #255	; 0xff
 80187c6:	d901      	bls.n	80187cc <ff_convert+0x30>
 80187c8:	2000      	movs	r0, #0
		}
	}

	return c;
}
 80187ca:	4770      	bx	lr
			c = (chr >= 0x100) ? 0 : Tbl[chr - 0x80];
 80187cc:	4b02      	ldr	r3, [pc, #8]	; (80187d8 <ff_convert+0x3c>)
 80187ce:	3880      	subs	r0, #128	; 0x80
 80187d0:	f833 0010 	ldrh.w	r0, [r3, r0, lsl #1]
 80187d4:	4770      	bx	lr
 80187d6:	bf00      	nop
 80187d8:	0802d3f4 	.word	0x0802d3f4

080187dc <ff_wtoupper>:


WCHAR ff_wtoupper (	/* Returns upper converted character */
	WCHAR chr		/* Unicode character to be upper converted (BMP only) */
)
{
 80187dc:	b510      	push	{r4, lr}
	};
	const WCHAR *p;
	WCHAR bc, nc, cmd;


	p = chr < 0x1000 ? cvt1 : cvt2;
 80187de:	4b27      	ldr	r3, [pc, #156]	; (801887c <ff_wtoupper+0xa0>)
 80187e0:	f5b0 5f80 	cmp.w	r0, #4096	; 0x1000
 80187e4:	f503 72fa 	add.w	r2, r3, #500	; 0x1f4
 80187e8:	f641 517d 	movw	r1, #7549	; 0x1d7d
 80187ec:	bf2c      	ite	cs
 80187ee:	4613      	movcs	r3, r2
 80187f0:	2161      	movcc	r1, #97	; 0x61
 80187f2:	3304      	adds	r3, #4
 80187f4:	e00f      	b.n	8018816 <ff_wtoupper+0x3a>
	for (;;) {
		bc = *p++;								/* Get block base */
		if (!bc || chr < bc) break;
 80187f6:	4281      	cmp	r1, r0
 80187f8:	d810      	bhi.n	801881c <ff_wtoupper+0x40>
		nc = *p++; cmd = nc >> 8; nc &= 0xFF;	/* Get processing command and block size */
 80187fa:	f833 2c02 	ldrh.w	r2, [r3, #-2]
 80187fe:	fa5f fc82 	uxtb.w	ip, r2
		if (chr < bc + nc) {	/* In the block? */
 8018802:	eb0c 0e01 	add.w	lr, ip, r1
 8018806:	4570      	cmp	r0, lr
		nc = *p++; cmd = nc >> 8; nc &= 0xFF;	/* Get processing command and block size */
 8018808:	ea4f 2212 	mov.w	r2, r2, lsr #8
		if (chr < bc + nc) {	/* In the block? */
 801880c:	db07      	blt.n	801881e <ff_wtoupper+0x42>
			case 7: chr -= 80; break;				/* Shift -80 */
			case 8:	chr -= 0x1C60; break;			/* Shift -0x1C60 */
			}
			break;
		}
		if (!cmd) p += nc;
 801880e:	3304      	adds	r3, #4
 8018810:	b172      	cbz	r2, 8018830 <ff_wtoupper+0x54>
		bc = *p++;								/* Get block base */
 8018812:	f833 1c04 	ldrh.w	r1, [r3, #-4]
		nc = *p++; cmd = nc >> 8; nc &= 0xFF;	/* Get processing command and block size */
 8018816:	461c      	mov	r4, r3
		if (!bc || chr < bc) break;
 8018818:	2900      	cmp	r1, #0
 801881a:	d1ec      	bne.n	80187f6 <ff_wtoupper+0x1a>
	}

	return chr;
}
 801881c:	bd10      	pop	{r4, pc}
			switch (cmd) {
 801881e:	2a08      	cmp	r2, #8
 8018820:	d8fc      	bhi.n	801881c <ff_wtoupper+0x40>
 8018822:	e8df f002 	tbb	[pc, r2]
 8018826:	120e      	.short	0x120e
 8018828:	211e1b18 	.word	0x211e1b18
 801882c:	2724      	.short	0x2724
 801882e:	0a          	.byte	0x0a
 801882f:	00          	.byte	0x00
		bc = *p++;								/* Get block base */
 8018830:	f834 101c 	ldrh.w	r1, [r4, ip, lsl #1]
		if (!cmd) p += nc;
 8018834:	eb04 034c 	add.w	r3, r4, ip, lsl #1
 8018838:	e7db      	b.n	80187f2 <ff_wtoupper+0x16>
			case 8:	chr -= 0x1C60; break;			/* Shift -0x1C60 */
 801883a:	f5a0 50e3 	sub.w	r0, r0, #7264	; 0x1c60
 801883e:	b280      	uxth	r0, r0
}
 8018840:	bd10      	pop	{r4, pc}
			case 0:	chr = p[chr - bc]; break;		/* Table conversion */
 8018842:	1a41      	subs	r1, r0, r1
 8018844:	f833 0011 	ldrh.w	r0, [r3, r1, lsl #1]
}
 8018848:	bd10      	pop	{r4, pc}
			case 1:	chr -= (chr - bc) & 1; break;	/* Case pairs */
 801884a:	1a43      	subs	r3, r0, r1
 801884c:	f003 0301 	and.w	r3, r3, #1
 8018850:	1ac0      	subs	r0, r0, r3
 8018852:	b280      	uxth	r0, r0
}
 8018854:	bd10      	pop	{r4, pc}
			case 2: chr -= 16; break;				/* Shift -16 */
 8018856:	3810      	subs	r0, #16
 8018858:	b280      	uxth	r0, r0
}
 801885a:	bd10      	pop	{r4, pc}
			case 3:	chr -= 32; break;				/* Shift -32 */
 801885c:	3820      	subs	r0, #32
 801885e:	b280      	uxth	r0, r0
}
 8018860:	bd10      	pop	{r4, pc}
			case 4:	chr -= 48; break;				/* Shift -48 */
 8018862:	3830      	subs	r0, #48	; 0x30
 8018864:	b280      	uxth	r0, r0
}
 8018866:	bd10      	pop	{r4, pc}
			case 5:	chr -= 26; break;				/* Shift -26 */
 8018868:	381a      	subs	r0, #26
 801886a:	b280      	uxth	r0, r0
}
 801886c:	bd10      	pop	{r4, pc}
			case 6:	chr += 8; break;				/* Shift +8 */
 801886e:	3008      	adds	r0, #8
 8018870:	b280      	uxth	r0, r0
}
 8018872:	bd10      	pop	{r4, pc}
			case 7: chr -= 80; break;				/* Shift -80 */
 8018874:	3850      	subs	r0, #80	; 0x50
 8018876:	b280      	uxth	r0, r0
}
 8018878:	bd10      	pop	{r4, pc}
 801887a:	bf00      	nop
 801887c:	0802d4f4 	.word	0x0802d4f4

08018880 <osKernelStart>:
* @param  argument      pointer that is passed to the thread function as start argument.
* @retval status code that indicates the execution status of the function
* @note   MUST REMAIN UNCHANGED: \b osKernelStart shall be consistent in every CMSIS-RTOS.
*/
osStatus osKernelStart (void)
{
 8018880:	b508      	push	{r3, lr}
  vTaskStartScheduler();
 8018882:	f001 fb6b 	bl	8019f5c <vTaskStartScheduler>
  
  return osOK;
}
 8018886:	2000      	movs	r0, #0
 8018888:	bd08      	pop	{r3, pc}
 801888a:	bf00      	nop

0801888c <osThreadCreate>:
* @param  argument      pointer that is passed to the thread function as start argument.
* @retval thread ID for reference by other functions or NULL in case of error.
* @note   MUST REMAIN UNCHANGED: \b osThreadCreate shall be consistent in every CMSIS-RTOS.
*/
osThreadId osThreadCreate (const osThreadDef_t *thread_def, void *argument)
{
 801888c:	b510      	push	{r4, lr}
 801888e:	4684      	mov	ip, r0
 8018890:	460b      	mov	r3, r1

    handle = xTaskCreateStatic((TaskFunction_t)thread_def->pthread,(const portCHAR *)thread_def->name,
              thread_def->stacksize, argument, makeFreeRtosPriority(thread_def->tpriority),
              thread_def->buffer, thread_def->controlblock);
#else
  if (xTaskCreate((TaskFunction_t)thread_def->pthread,(const portCHAR *)thread_def->name,
 8018892:	f8bc 2010 	ldrh.w	r2, [ip, #16]
 8018896:	f8dc 1000 	ldr.w	r1, [ip]
 801889a:	f9bc c008 	ldrsh.w	ip, [ip, #8]
 801889e:	6840      	ldr	r0, [r0, #4]
{
 80188a0:	b084      	sub	sp, #16
  if (priority != osPriorityError) {
 80188a2:	f1bc 0f84 	cmp.w	ip, #132	; 0x84
    fpriority += (priority - osPriorityIdle);
 80188a6:	bf14      	ite	ne
 80188a8:	f10c 0403 	addne.w	r4, ip, #3
  unsigned portBASE_TYPE fpriority = tskIDLE_PRIORITY;
 80188ac:	2400      	moveq	r4, #0
  if (xTaskCreate((TaskFunction_t)thread_def->pthread,(const portCHAR *)thread_def->name,
 80188ae:	9400      	str	r4, [sp, #0]
 80188b0:	ac03      	add	r4, sp, #12
 80188b2:	9401      	str	r4, [sp, #4]
 80188b4:	f001 fa82 	bl	8019dbc <xTaskCreate>
 80188b8:	2801      	cmp	r0, #1
                   &handle) != pdPASS)  {
    return NULL;
  }     
#endif
  
  return handle;
 80188ba:	bf0c      	ite	eq
 80188bc:	9803      	ldreq	r0, [sp, #12]
    return NULL;
 80188be:	2000      	movne	r0, #0
}
 80188c0:	b004      	add	sp, #16
 80188c2:	bd10      	pop	{r4, pc}

080188c4 <osDelay>:
* @brief   Wait for Timeout (Time Delay)
* @param   millisec      time delay value
* @retval  status code that indicates the execution status of the function.
*/
osStatus osDelay (uint32_t millisec)
{
 80188c4:	b508      	push	{r3, lr}
#if INCLUDE_vTaskDelay
  TickType_t ticks = millisec / portTICK_PERIOD_MS;
  
  vTaskDelay(ticks ? ticks : 1);          /* Minimum delay = 1 tick */
 80188c6:	2801      	cmp	r0, #1
 80188c8:	bf38      	it	cc
 80188ca:	2001      	movcc	r0, #1
 80188cc:	f001 fd0e 	bl	801a2ec <vTaskDelay>
#else
  (void) millisec;
  
  return osErrorResource;
#endif
}
 80188d0:	2000      	movs	r0, #0
 80188d2:	bd08      	pop	{r3, pc}

080188d4 <osTimerCreate>:
* @param  argument      argument to the timer call back function.
* @retval  timer ID for reference by other functions or NULL in case of error.
* @note   MUST REMAIN UNCHANGED: \b osTimerCreate shall be consistent in every CMSIS-RTOS.
*/
osTimerId osTimerCreate (const osTimerDef_t *timer_def, os_timer_type type, void *argument)
{
 80188d4:	b500      	push	{lr}
 80188d6:	b083      	sub	sp, #12
 80188d8:	4613      	mov	r3, r2
                      (type == osTimerPeriodic) ? pdTRUE : pdFALSE,
                      (void *) argument,
                      (TaskFunction_t)timer_def->ptimer,
                      (StaticTimer_t *)timer_def->controlblock);  
#else
  return xTimerCreate((const char *)"",
 80188da:	6802      	ldr	r2, [r0, #0]
 80188dc:	9200      	str	r2, [sp, #0]
 80188de:	f1a1 0201 	sub.w	r2, r1, #1
 80188e2:	fab2 f282 	clz	r2, r2
 80188e6:	0952      	lsrs	r2, r2, #5
 80188e8:	2101      	movs	r1, #1
 80188ea:	4803      	ldr	r0, [pc, #12]	; (80188f8 <osTimerCreate+0x24>)
 80188ec:	f001 ff8a 	bl	801a804 <xTimerCreate>
#endif

#else 
	return NULL;
#endif
}
 80188f0:	b003      	add	sp, #12
 80188f2:	f85d fb04 	ldr.w	pc, [sp], #4
 80188f6:	bf00      	nop
 80188f8:	080437e0 	.word	0x080437e0

080188fc <osTimerStart>:
* @param  millisec      time delay value of the timer.
* @retval  status code that indicates the execution status of the function
* @note   MUST REMAIN UNCHANGED: \b osTimerStart shall be consistent in every CMSIS-RTOS.
*/
osStatus osTimerStart (osTimerId timer_id, uint32_t millisec)
{
 80188fc:	b510      	push	{r4, lr}
 80188fe:	b084      	sub	sp, #16
  osStatus result = osOK;
#if (configUSE_TIMERS == 1)  
  portBASE_TYPE taskWoken = pdFALSE;
 8018900:	2400      	movs	r4, #0
 8018902:	2901      	cmp	r1, #1
 8018904:	460a      	mov	r2, r1
 8018906:	9403      	str	r4, [sp, #12]
  TickType_t ticks = millisec / portTICK_PERIOD_MS;

  if (ticks == 0)
 8018908:	bf38      	it	cc
 801890a:	2201      	movcc	r2, #1
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 801890c:	f3ef 8305 	mrs	r3, IPSR
    ticks = 1;
    
  if (inHandlerMode()) 
 8018910:	b14b      	cbz	r3, 8018926 <osTimerStart+0x2a>
  {
    if (xTimerChangePeriodFromISR(timer_id, ticks, &taskWoken) != pdPASS)
 8018912:	9400      	str	r4, [sp, #0]
 8018914:	ab03      	add	r3, sp, #12
 8018916:	2109      	movs	r1, #9
 8018918:	f001 ff98 	bl	801a84c <xTimerGenericCommand>
 801891c:	2801      	cmp	r0, #1
 801891e:	d00b      	beq.n	8018938 <osTimerStart+0x3c>
    }
  }
  else 
  {
    if (xTimerChangePeriod(timer_id, ticks, 0) != pdPASS)
      result = osErrorOS;
 8018920:	20ff      	movs	r0, #255	; 0xff

#else 
  result = osErrorOS;
#endif
  return result;
}
 8018922:	b004      	add	sp, #16
 8018924:	bd10      	pop	{r4, pc}
    if (xTimerChangePeriod(timer_id, ticks, 0) != pdPASS)
 8018926:	9300      	str	r3, [sp, #0]
 8018928:	2104      	movs	r1, #4
 801892a:	f001 ff8f 	bl	801a84c <xTimerGenericCommand>
 801892e:	2801      	cmp	r0, #1
 8018930:	d1f6      	bne.n	8018920 <osTimerStart+0x24>
  osStatus result = osOK;
 8018932:	2000      	movs	r0, #0
}
 8018934:	b004      	add	sp, #16
 8018936:	bd10      	pop	{r4, pc}
      portEND_SWITCHING_ISR(taskWoken);     
 8018938:	9b03      	ldr	r3, [sp, #12]
 801893a:	2b00      	cmp	r3, #0
 801893c:	d0f9      	beq.n	8018932 <osTimerStart+0x36>
 801893e:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
 8018942:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8018946:	f8c3 2d04 	str.w	r2, [r3, #3332]	; 0xd04
 801894a:	f3bf 8f4f 	dsb	sy
 801894e:	f3bf 8f6f 	isb	sy
  osStatus result = osOK;
 8018952:	4620      	mov	r0, r4
}
 8018954:	b004      	add	sp, #16
 8018956:	bd10      	pop	{r4, pc}

08018958 <osTimerStop>:
* @param  timer_id      timer ID obtained by \ref osTimerCreate
* @retval  status code that indicates the execution status of the function.
* @note   MUST REMAIN UNCHANGED: \b osTimerStop shall be consistent in every CMSIS-RTOS.
*/
osStatus osTimerStop (osTimerId timer_id)
{
 8018958:	b510      	push	{r4, lr}
 801895a:	b084      	sub	sp, #16
  osStatus result = osOK;
#if (configUSE_TIMERS == 1)  
  portBASE_TYPE taskWoken = pdFALSE;
 801895c:	2400      	movs	r4, #0
 801895e:	9403      	str	r4, [sp, #12]
 8018960:	f3ef 8305 	mrs	r3, IPSR

  if (inHandlerMode()) {
 8018964:	b1b3      	cbz	r3, 8018994 <osTimerStop+0x3c>
    if (xTimerStopFromISR(timer_id, &taskWoken) != pdPASS) {
 8018966:	9400      	str	r4, [sp, #0]
 8018968:	ab03      	add	r3, sp, #12
 801896a:	4622      	mov	r2, r4
 801896c:	2108      	movs	r1, #8
 801896e:	f001 ff6d 	bl	801a84c <xTimerGenericCommand>
 8018972:	2801      	cmp	r0, #1
 8018974:	d115      	bne.n	80189a2 <osTimerStop+0x4a>
      return osErrorOS;
    }
    portEND_SWITCHING_ISR(taskWoken);
 8018976:	9b03      	ldr	r3, [sp, #12]
 8018978:	b1b3      	cbz	r3, 80189a8 <osTimerStop+0x50>
 801897a:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
 801897e:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8018982:	f8c3 2d04 	str.w	r2, [r3, #3332]	; 0xd04
 8018986:	f3bf 8f4f 	dsb	sy
 801898a:	f3bf 8f6f 	isb	sy
  osStatus result = osOK;
 801898e:	4620      	mov	r0, r4
  }
#else 
  result = osErrorOS;
#endif 
  return result;
}
 8018990:	b004      	add	sp, #16
 8018992:	bd10      	pop	{r4, pc}
    if (xTimerStop(timer_id, 0) != pdPASS) {
 8018994:	9300      	str	r3, [sp, #0]
 8018996:	461a      	mov	r2, r3
 8018998:	2103      	movs	r1, #3
 801899a:	f001 ff57 	bl	801a84c <xTimerGenericCommand>
 801899e:	2801      	cmp	r0, #1
 80189a0:	d002      	beq.n	80189a8 <osTimerStop+0x50>
      result = osErrorOS;
 80189a2:	20ff      	movs	r0, #255	; 0xff
}
 80189a4:	b004      	add	sp, #16
 80189a6:	bd10      	pop	{r4, pc}
  osStatus result = osOK;
 80189a8:	2000      	movs	r0, #0
}
 80189aa:	b004      	add	sp, #16
 80189ac:	bd10      	pop	{r4, pc}
 80189ae:	bf00      	nop

080189b0 <osTimerDelete>:
* @param  timer_id      timer ID obtained by \ref osTimerCreate
* @retval  status code that indicates the execution status of the function.
* @note   MUST REMAIN UNCHANGED: \b osTimerDelete shall be consistent in every CMSIS-RTOS.
*/
osStatus osTimerDelete (osTimerId timer_id)
{
 80189b0:	b510      	push	{r4, lr}
 80189b2:	b082      	sub	sp, #8
 80189b4:	f3ef 8405 	mrs	r4, IPSR
osStatus result = osOK;

#if (configUSE_TIMERS == 1)

   if (inHandlerMode()) {
 80189b8:	b96c      	cbnz	r4, 80189d6 <osTimerDelete+0x26>
     return osErrorISR;
  }
  else { 
    if ((xTimerDelete(timer_id, osWaitForever )) != pdPASS) {
 80189ba:	f04f 31ff 	mov.w	r1, #4294967295
 80189be:	4623      	mov	r3, r4
 80189c0:	4622      	mov	r2, r4
 80189c2:	9100      	str	r1, [sp, #0]
 80189c4:	2105      	movs	r1, #5
 80189c6:	f001 ff41 	bl	801a84c <xTimerGenericCommand>
      result = osErrorOS;
 80189ca:	2801      	cmp	r0, #1
 80189cc:	bf18      	it	ne
 80189ce:	24ff      	movne	r4, #255	; 0xff
#else 
  result = osErrorOS;
#endif 
 
  return result;
}
 80189d0:	4620      	mov	r0, r4
 80189d2:	b002      	add	sp, #8
 80189d4:	bd10      	pop	{r4, pc}
     return osErrorISR;
 80189d6:	2482      	movs	r4, #130	; 0x82
}
 80189d8:	4620      	mov	r0, r4
 80189da:	b002      	add	sp, #8
 80189dc:	bd10      	pop	{r4, pc}
 80189de:	bf00      	nop

080189e0 <osSemaphoreCreate>:
#endif    
  }
#else  // configSUPPORT_STATIC_ALLOCATION == 0  && configSUPPORT_DYNAMIC_ALLOCATION == 1
  osSemaphoreId sema;
 
  if (count == 1) {
 80189e0:	2901      	cmp	r1, #1
{ 
 80189e2:	4608      	mov	r0, r1
  if (count == 1) {
 80189e4:	d001      	beq.n	80189ea <osSemaphoreCreate+0xa>
    vSemaphoreCreateBinary(sema);
    return sema;
  }
  else {
#if (configUSE_COUNTING_SEMAPHORES == 1 )	
    return xSemaphoreCreateCounting(count, count);
 80189e6:	f000 bd91 	b.w	801950c <xQueueCreateCountingSemaphore>
{ 
 80189ea:	b510      	push	{r4, lr}
    vSemaphoreCreateBinary(sema);
 80189ec:	2203      	movs	r2, #3
 80189ee:	2100      	movs	r1, #0
 80189f0:	f000 fd62 	bl	80194b8 <xQueueGenericCreate>
 80189f4:	4604      	mov	r4, r0
 80189f6:	b120      	cbz	r0, 8018a02 <osSemaphoreCreate+0x22>
 80189f8:	2300      	movs	r3, #0
 80189fa:	461a      	mov	r2, r3
 80189fc:	4619      	mov	r1, r3
 80189fe:	f000 fdad 	bl	801955c <xQueueGenericSend>
#else
    return NULL;
#endif
  }
#endif
}
 8018a02:	4620      	mov	r0, r4
 8018a04:	bd10      	pop	{r4, pc}
 8018a06:	bf00      	nop

08018a08 <osSemaphoreWait>:
* @param  millisec      timeout value or 0 in case of no time-out.
* @retval  number of available tokens, or -1 in case of incorrect parameters.
* @note   MUST REMAIN UNCHANGED: \b osSemaphoreWait shall be consistent in every CMSIS-RTOS.
*/
int32_t osSemaphoreWait (osSemaphoreId semaphore_id, uint32_t millisec)
{
 8018a08:	b510      	push	{r4, lr}
 8018a0a:	b082      	sub	sp, #8
  TickType_t ticks;
  portBASE_TYPE taskWoken = pdFALSE;  
 8018a0c:	2400      	movs	r4, #0
 8018a0e:	9401      	str	r4, [sp, #4]
  
  
  if (semaphore_id == NULL) {
 8018a10:	b310      	cbz	r0, 8018a58 <osSemaphoreWait+0x50>
 8018a12:	f3ef 8305 	mrs	r3, IPSR
    if (ticks == 0) {
      ticks = 1;
    }
  }
  
  if (inHandlerMode()) {
 8018a16:	b933      	cbnz	r3, 8018a26 <osSemaphoreWait+0x1e>
    if (xSemaphoreTakeFromISR(semaphore_id, &taskWoken) != pdTRUE) {
      return osErrorOS;
    }
	portEND_SWITCHING_ISR(taskWoken);
  }  
  else if (xSemaphoreTake(semaphore_id, ticks) != pdTRUE) {
 8018a18:	f000 ffde 	bl	80199d8 <xQueueSemaphoreTake>
 8018a1c:	2801      	cmp	r0, #1
 8018a1e:	d118      	bne.n	8018a52 <osSemaphoreWait+0x4a>
    return osErrorOS;
  }
  
  return osOK;
 8018a20:	2000      	movs	r0, #0
}
 8018a22:	b002      	add	sp, #8
 8018a24:	bd10      	pop	{r4, pc}
    if (xSemaphoreTakeFromISR(semaphore_id, &taskWoken) != pdTRUE) {
 8018a26:	aa01      	add	r2, sp, #4
 8018a28:	4621      	mov	r1, r4
 8018a2a:	f001 f8b3 	bl	8019b94 <xQueueReceiveFromISR>
 8018a2e:	2801      	cmp	r0, #1
 8018a30:	d10f      	bne.n	8018a52 <osSemaphoreWait+0x4a>
	portEND_SWITCHING_ISR(taskWoken);
 8018a32:	9b01      	ldr	r3, [sp, #4]
 8018a34:	2b00      	cmp	r3, #0
 8018a36:	d0f3      	beq.n	8018a20 <osSemaphoreWait+0x18>
 8018a38:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
 8018a3c:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8018a40:	f8c3 2d04 	str.w	r2, [r3, #3332]	; 0xd04
 8018a44:	f3bf 8f4f 	dsb	sy
 8018a48:	f3bf 8f6f 	isb	sy
  return osOK;
 8018a4c:	4620      	mov	r0, r4
}
 8018a4e:	b002      	add	sp, #8
 8018a50:	bd10      	pop	{r4, pc}
    return osErrorOS;
 8018a52:	20ff      	movs	r0, #255	; 0xff
}
 8018a54:	b002      	add	sp, #8
 8018a56:	bd10      	pop	{r4, pc}
    return osErrorParameter;
 8018a58:	2080      	movs	r0, #128	; 0x80
}
 8018a5a:	b002      	add	sp, #8
 8018a5c:	bd10      	pop	{r4, pc}
 8018a5e:	bf00      	nop

08018a60 <osSemaphoreRelease>:
 8018a60:	b510      	push	{r4, lr}
 8018a62:	b082      	sub	sp, #8
 8018a64:	2400      	movs	r4, #0
 8018a66:	9401      	str	r4, [sp, #4]
 8018a68:	f3ef 8305 	mrs	r3, IPSR
 8018a6c:	b19b      	cbz	r3, 8018a96 <osSemaphoreRelease+0x36>
 8018a6e:	a901      	add	r1, sp, #4
 8018a70:	f000 fe98 	bl	80197a4 <xQueueGiveFromISR>
 8018a74:	2801      	cmp	r0, #1
 8018a76:	d114      	bne.n	8018aa2 <osSemaphoreRelease+0x42>
 8018a78:	9b01      	ldr	r3, [sp, #4]
 8018a7a:	b1ab      	cbz	r3, 8018aa8 <osSemaphoreRelease+0x48>
 8018a7c:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
 8018a80:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8018a84:	f8c3 2d04 	str.w	r2, [r3, #3332]	; 0xd04
 8018a88:	f3bf 8f4f 	dsb	sy
 8018a8c:	f3bf 8f6f 	isb	sy
 8018a90:	4620      	mov	r0, r4
 8018a92:	b002      	add	sp, #8
 8018a94:	bd10      	pop	{r4, pc}
 8018a96:	461a      	mov	r2, r3
 8018a98:	4619      	mov	r1, r3
 8018a9a:	f000 fd5f 	bl	801955c <xQueueGenericSend>
 8018a9e:	2801      	cmp	r0, #1
 8018aa0:	d002      	beq.n	8018aa8 <osSemaphoreRelease+0x48>
 8018aa2:	20ff      	movs	r0, #255	; 0xff
 8018aa4:	b002      	add	sp, #8
 8018aa6:	bd10      	pop	{r4, pc}
 8018aa8:	2000      	movs	r0, #0
 8018aaa:	b002      	add	sp, #8
 8018aac:	bd10      	pop	{r4, pc}
 8018aae:	bf00      	nop

08018ab0 <osPoolCreate>:
* @param  pool_def      memory pool definition referenced with \ref osPool.
* @retval  memory pool ID for reference by other functions or NULL in case of error.
* @note   MUST REMAIN UNCHANGED: \b osPoolCreate shall be consistent in every CMSIS-RTOS.
*/
osPoolId osPoolCreate (const osPoolDef_t *pool_def)
{
 8018ab0:	b5f0      	push	{r4, r5, r6, r7, lr}
 8018ab2:	4606      	mov	r6, r0
 8018ab4:	b083      	sub	sp, #12
  osPoolId thePool;
  int itemSize = 4 * ((pool_def->item_sz + 3) / 4);
  uint32_t i;
  
  /* First have to allocate memory for the pool control block. */
 thePool = pvPortMalloc(sizeof(os_pool_cb_t));
 8018ab6:	2014      	movs	r0, #20
  int itemSize = 4 * ((pool_def->item_sz + 3) / 4);
 8018ab8:	6874      	ldr	r4, [r6, #4]
 thePool = pvPortMalloc(sizeof(os_pool_cb_t));
 8018aba:	f000 f975 	bl	8018da8 <pvPortMalloc>

  
  if (thePool) {
 8018abe:	4605      	mov	r5, r0
 8018ac0:	b1e8      	cbz	r0, 8018afe <osPoolCreate+0x4e>
    thePool->pool_sz = pool_def->pool_sz;
 8018ac2:	6830      	ldr	r0, [r6, #0]
  int itemSize = 4 * ((pool_def->item_sz + 3) / 4);
 8018ac4:	3403      	adds	r4, #3
 8018ac6:	f024 0703 	bic.w	r7, r4, #3
    thePool->item_sz = itemSize;
    thePool->currentIndex = 0;
 8018aca:	2400      	movs	r4, #0
    thePool->item_sz = itemSize;
 8018acc:	e9c5 0702 	strd	r0, r7, [r5, #8]
    thePool->currentIndex = 0;
 8018ad0:	612c      	str	r4, [r5, #16]
    
    /* Memory for markers */
    thePool->markers = pvPortMalloc(pool_def->pool_sz);
 8018ad2:	f000 f969 	bl	8018da8 <pvPortMalloc>
 8018ad6:	6068      	str	r0, [r5, #4]
   
    if (thePool->markers) {
 8018ad8:	b1a0      	cbz	r0, 8018b04 <osPoolCreate+0x54>
      /* Now allocate the pool itself. */
     thePool->pool = pvPortMalloc(pool_def->pool_sz * itemSize);
 8018ada:	6830      	ldr	r0, [r6, #0]
 8018adc:	fb07 f000 	mul.w	r0, r7, r0
 8018ae0:	f000 f962 	bl	8018da8 <pvPortMalloc>
 8018ae4:	4607      	mov	r7, r0
 8018ae6:	6028      	str	r0, [r5, #0]
      
      if (thePool->pool) {
 8018ae8:	b198      	cbz	r0, 8018b12 <osPoolCreate+0x62>
        for (i = 0; i < pool_def->pool_sz; i++) {
 8018aea:	6833      	ldr	r3, [r6, #0]
 8018aec:	b13b      	cbz	r3, 8018afe <osPoolCreate+0x4e>
 8018aee:	4623      	mov	r3, r4
          thePool->markers[i] = 0;
 8018af0:	4621      	mov	r1, r4
 8018af2:	686a      	ldr	r2, [r5, #4]
 8018af4:	54d1      	strb	r1, [r2, r3]
        for (i = 0; i < pool_def->pool_sz; i++) {
 8018af6:	6832      	ldr	r2, [r6, #0]
 8018af8:	3301      	adds	r3, #1
 8018afa:	429a      	cmp	r2, r3
 8018afc:	d8f9      	bhi.n	8018af2 <osPoolCreate+0x42>
  return thePool;
 
#else
  return NULL;
#endif
}
 8018afe:	4628      	mov	r0, r5
 8018b00:	b003      	add	sp, #12
 8018b02:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8018b04:	9001      	str	r0, [sp, #4]
      vPortFree(thePool);
 8018b06:	4628      	mov	r0, r5
 8018b08:	f000 f9cc 	bl	8018ea4 <vPortFree>
      thePool = NULL;
 8018b0c:	9b01      	ldr	r3, [sp, #4]
 8018b0e:	461d      	mov	r5, r3
  return thePool;
 8018b10:	e7f5      	b.n	8018afe <osPoolCreate+0x4e>
        vPortFree(thePool->markers);
 8018b12:	6868      	ldr	r0, [r5, #4]
 8018b14:	f000 f9c6 	bl	8018ea4 <vPortFree>
        vPortFree(thePool);
 8018b18:	4628      	mov	r0, r5
 8018b1a:	f000 f9c3 	bl	8018ea4 <vPortFree>
        thePool = NULL;
 8018b1e:	463d      	mov	r5, r7
 8018b20:	e7ed      	b.n	8018afe <osPoolCreate+0x4e>
 8018b22:	bf00      	nop

08018b24 <osPoolAlloc>:
* @param pool_id       memory pool ID obtain referenced with \ref osPoolCreate.
* @retval  address of the allocated memory block or NULL in case of no memory available.
* @note   MUST REMAIN UNCHANGED: \b osPoolAlloc shall be consistent in every CMSIS-RTOS.
*/
void *osPoolAlloc (osPoolId pool_id)
{
 8018b24:	b5f0      	push	{r4, r5, r6, r7, lr}
 8018b26:	4606      	mov	r6, r0
 8018b28:	b083      	sub	sp, #12
 8018b2a:	f3ef 8705 	mrs	r7, IPSR
  int dummy = 0;
  void *p = NULL;
  uint32_t i;
  uint32_t index;
  
  if (inHandlerMode()) {
 8018b2e:	2f00      	cmp	r7, #0
 8018b30:	d037      	beq.n	8018ba2 <osPoolAlloc+0x7e>

portFORCE_INLINE static uint32_t ulPortRaiseBASEPRI( void )
{
uint32_t ulOriginalBASEPRI, ulNewBASEPRI;

	__asm volatile
 8018b32:	f3ef 8411 	mrs	r4, BASEPRI
 8018b36:	f04f 0350 	mov.w	r3, #80	; 0x50
 8018b3a:	f383 8811 	msr	BASEPRI, r3
 8018b3e:	f3bf 8f6f 	isb	sy
 8018b42:	f3bf 8f4f 	dsb	sy
    dummy = portSET_INTERRUPT_MASK_FROM_ISR();
 8018b46:	4627      	mov	r7, r4
  }
  else {
    vPortEnterCritical();
  }
  
  for (i = 0; i < pool_id->pool_sz; i++) {
 8018b48:	68b0      	ldr	r0, [r6, #8]
 8018b4a:	b1c0      	cbz	r0, 8018b7e <osPoolAlloc+0x5a>
    index = (pool_id->currentIndex + i) % pool_id->pool_sz;
 8018b4c:	6933      	ldr	r3, [r6, #16]
    
    if (pool_id->markers[index] == 0) {
 8018b4e:	6874      	ldr	r4, [r6, #4]
 8018b50:	eb03 0e00 	add.w	lr, r3, r0
 8018b54:	e001      	b.n	8018b5a <osPoolAlloc+0x36>
  for (i = 0; i < pool_id->pool_sz; i++) {
 8018b56:	459e      	cmp	lr, r3
 8018b58:	d018      	beq.n	8018b8c <osPoolAlloc+0x68>
    index = (pool_id->currentIndex + i) % pool_id->pool_sz;
 8018b5a:	fbb3 f2f0 	udiv	r2, r3, r0
 8018b5e:	fb00 3212 	mls	r2, r0, r2, r3
    if (pool_id->markers[index] == 0) {
 8018b62:	eb04 0c02 	add.w	ip, r4, r2
 8018b66:	5ca5      	ldrb	r5, [r4, r2]
  for (i = 0; i < pool_id->pool_sz; i++) {
 8018b68:	3301      	adds	r3, #1
    if (pool_id->markers[index] == 0) {
 8018b6a:	2d00      	cmp	r5, #0
 8018b6c:	d1f3      	bne.n	8018b56 <osPoolAlloc+0x32>
      pool_id->markers[index] = 1;
 8018b6e:	2301      	movs	r3, #1
 8018b70:	f88c 3000 	strb.w	r3, [ip]
      p = (void *)((uint32_t)(pool_id->pool) + (index * pool_id->item_sz));
 8018b74:	68f0      	ldr	r0, [r6, #12]
 8018b76:	6831      	ldr	r1, [r6, #0]
      pool_id->currentIndex = index;
 8018b78:	6132      	str	r2, [r6, #16]
      p = (void *)((uint32_t)(pool_id->pool) + (index * pool_id->item_sz));
 8018b7a:	fb00 1002 	mla	r0, r0, r2, r1
 8018b7e:	f3ef 8305 	mrs	r3, IPSR
      break;
    }
  }
  
  if (inHandlerMode()) {
 8018b82:	b143      	cbz	r3, 8018b96 <osPoolAlloc+0x72>
}
/*-----------------------------------------------------------*/

portFORCE_INLINE static void vPortSetBASEPRI( uint32_t ulNewMaskValue )
{
	__asm volatile
 8018b84:	f387 8811 	msr	BASEPRI, r7
  else {
    vPortExitCritical();
  }
  
  return p;
}
 8018b88:	b003      	add	sp, #12
 8018b8a:	bdf0      	pop	{r4, r5, r6, r7, pc}
  void *p = NULL;
 8018b8c:	2000      	movs	r0, #0
 8018b8e:	f3ef 8305 	mrs	r3, IPSR
  if (inHandlerMode()) {
 8018b92:	2b00      	cmp	r3, #0
 8018b94:	d1f6      	bne.n	8018b84 <osPoolAlloc+0x60>
 8018b96:	9001      	str	r0, [sp, #4]
    vPortExitCritical();
 8018b98:	f000 fa46 	bl	8019028 <vPortExitCritical>
 8018b9c:	9801      	ldr	r0, [sp, #4]
}
 8018b9e:	b003      	add	sp, #12
 8018ba0:	bdf0      	pop	{r4, r5, r6, r7, pc}
    vPortEnterCritical();
 8018ba2:	f000 fa1f 	bl	8018fe4 <vPortEnterCritical>
 8018ba6:	e7cf      	b.n	8018b48 <osPoolAlloc+0x24>

08018ba8 <osMailCreate>:
* @param   thread_id     thread ID (obtained by \ref osThreadCreate or \ref osThreadGetId) or NULL.
* @retval mail queue ID for reference by other functions or NULL in case of error.
* @note   MUST REMAIN UNCHANGED: \b osMailCreate shall be consistent in every CMSIS-RTOS.
*/
osMailQId osMailCreate (const osMailQDef_t *queue_def, osThreadId thread_id)
{
 8018ba8:	b570      	push	{r4, r5, r6, lr}
#if (configSUPPORT_DYNAMIC_ALLOCATION == 1)
  (void) thread_id;
  
  osPoolDef_t pool_def = {queue_def->queue_sz, queue_def->item_sz, NULL};
 8018baa:	e9d0 2300 	ldrd	r2, r3, [r0]
{
 8018bae:	b084      	sub	sp, #16
  
  /* Create a mail queue control block */

  *(queue_def->cb) = pvPortMalloc(sizeof(struct os_mailQ_cb));
 8018bb0:	6885      	ldr	r5, [r0, #8]
{
 8018bb2:	4604      	mov	r4, r0
  osPoolDef_t pool_def = {queue_def->queue_sz, queue_def->item_sz, NULL};
 8018bb4:	2600      	movs	r6, #0
  *(queue_def->cb) = pvPortMalloc(sizeof(struct os_mailQ_cb));
 8018bb6:	200c      	movs	r0, #12
  osPoolDef_t pool_def = {queue_def->queue_sz, queue_def->item_sz, NULL};
 8018bb8:	e9cd 2301 	strd	r2, r3, [sp, #4]
 8018bbc:	9603      	str	r6, [sp, #12]
  *(queue_def->cb) = pvPortMalloc(sizeof(struct os_mailQ_cb));
 8018bbe:	f000 f8f3 	bl	8018da8 <pvPortMalloc>

  if (*(queue_def->cb) == NULL) {
 8018bc2:	68a3      	ldr	r3, [r4, #8]
  *(queue_def->cb) = pvPortMalloc(sizeof(struct os_mailQ_cb));
 8018bc4:	6028      	str	r0, [r5, #0]
  if (*(queue_def->cb) == NULL) {
 8018bc6:	681d      	ldr	r5, [r3, #0]
 8018bc8:	b195      	cbz	r5, 8018bf0 <osMailCreate+0x48>
    return NULL;
  }
  (*(queue_def->cb))->queue_def = queue_def;
 8018bca:	602c      	str	r4, [r5, #0]
  
  /* Create a queue in FreeRTOS */
  (*(queue_def->cb))->handle = xQueueCreate(queue_def->queue_sz, sizeof(void *));
 8018bcc:	4632      	mov	r2, r6
 8018bce:	6820      	ldr	r0, [r4, #0]
 8018bd0:	2104      	movs	r1, #4
 8018bd2:	f000 fc71 	bl	80194b8 <xQueueGenericCreate>


  if ((*(queue_def->cb))->handle == NULL) {
 8018bd6:	68a3      	ldr	r3, [r4, #8]
  (*(queue_def->cb))->handle = xQueueCreate(queue_def->queue_sz, sizeof(void *));
 8018bd8:	6068      	str	r0, [r5, #4]
  if ((*(queue_def->cb))->handle == NULL) {
 8018bda:	681e      	ldr	r6, [r3, #0]
 8018bdc:	6875      	ldr	r5, [r6, #4]
 8018bde:	b155      	cbz	r5, 8018bf6 <osMailCreate+0x4e>
    vPortFree(*(queue_def->cb));
    return NULL;
  }
  
  /* Create a mail pool */
  (*(queue_def->cb))->pool = osPoolCreate(&pool_def);
 8018be0:	a801      	add	r0, sp, #4
 8018be2:	f7ff ff65 	bl	8018ab0 <osPoolCreate>
  if ((*(queue_def->cb))->pool == NULL) {
 8018be6:	68a3      	ldr	r3, [r4, #8]
  (*(queue_def->cb))->pool = osPoolCreate(&pool_def);
 8018be8:	60b0      	str	r0, [r6, #8]
  if ((*(queue_def->cb))->pool == NULL) {
 8018bea:	681d      	ldr	r5, [r3, #0]
 8018bec:	68ac      	ldr	r4, [r5, #8]
 8018bee:	b134      	cbz	r4, 8018bfe <osMailCreate+0x56>
  
  return *(queue_def->cb);
#else
  return NULL;
#endif
}
 8018bf0:	4628      	mov	r0, r5
 8018bf2:	b004      	add	sp, #16
 8018bf4:	bd70      	pop	{r4, r5, r6, pc}
    vPortFree(*(queue_def->cb));
 8018bf6:	4630      	mov	r0, r6
 8018bf8:	f000 f954 	bl	8018ea4 <vPortFree>
    return NULL;
 8018bfc:	e7f8      	b.n	8018bf0 <osMailCreate+0x48>
    vPortFree(*(queue_def->cb));
 8018bfe:	4628      	mov	r0, r5
 8018c00:	f000 f950 	bl	8018ea4 <vPortFree>
    return NULL;
 8018c04:	4625      	mov	r5, r4
 8018c06:	e7f3      	b.n	8018bf0 <osMailCreate+0x48>

08018c08 <osMailAlloc>:
{
  (void) millisec;
  void *p;
  
  
  if (queue_id == NULL) {
 8018c08:	b110      	cbz	r0, 8018c10 <osMailAlloc+0x8>
    return NULL;
  }
  
  p = osPoolAlloc(queue_id->pool);
 8018c0a:	6880      	ldr	r0, [r0, #8]
 8018c0c:	f7ff bf8a 	b.w	8018b24 <osPoolAlloc>
  
  return p;
}
 8018c10:	4770      	bx	lr
 8018c12:	bf00      	nop

08018c14 <osMailPut>:
* @param  mail          memory block previously allocated with \ref osMailAlloc or \ref osMailCAlloc.
* @retval status code that indicates the execution status of the function.
* @note   MUST REMAIN UNCHANGED: \b osMailPut shall be consistent in every CMSIS-RTOS.
*/
osStatus osMailPut (osMailQId queue_id, void *mail)
{
 8018c14:	b510      	push	{r4, lr}
 8018c16:	b084      	sub	sp, #16
 8018c18:	9101      	str	r1, [sp, #4]
  portBASE_TYPE taskWoken;
  
  
  if (queue_id == NULL) {
 8018c1a:	b340      	cbz	r0, 8018c6e <osMailPut+0x5a>
    return osErrorParameter;
  }
  
  taskWoken = pdFALSE;
 8018c1c:	2400      	movs	r4, #0
 8018c1e:	9403      	str	r4, [sp, #12]
 8018c20:	f3ef 8305 	mrs	r3, IPSR
  
  if (inHandlerMode()) {
    if (xQueueSendFromISR(queue_id->handle, &mail, &taskWoken) != pdTRUE) {
 8018c24:	6840      	ldr	r0, [r0, #4]
  if (inHandlerMode()) {
 8018c26:	b943      	cbnz	r3, 8018c3a <osMailPut+0x26>
      return osErrorOS;
    }
    portEND_SWITCHING_ISR(taskWoken);
  }
  else {
    if (xQueueSend(queue_id->handle, &mail, 0) != pdTRUE) { 
 8018c28:	461a      	mov	r2, r3
 8018c2a:	a901      	add	r1, sp, #4
 8018c2c:	f000 fc96 	bl	801955c <xQueueGenericSend>
 8018c30:	2801      	cmp	r0, #1
 8018c32:	d119      	bne.n	8018c68 <osMailPut+0x54>
      return osErrorOS;
    }
  }
  
  return osOK;
 8018c34:	2000      	movs	r0, #0
}
 8018c36:	b004      	add	sp, #16
 8018c38:	bd10      	pop	{r4, pc}
    if (xQueueSendFromISR(queue_id->handle, &mail, &taskWoken) != pdTRUE) {
 8018c3a:	4623      	mov	r3, r4
 8018c3c:	aa03      	add	r2, sp, #12
 8018c3e:	a901      	add	r1, sp, #4
 8018c40:	f000 fd4c 	bl	80196dc <xQueueGenericSendFromISR>
 8018c44:	2801      	cmp	r0, #1
 8018c46:	d10f      	bne.n	8018c68 <osMailPut+0x54>
    portEND_SWITCHING_ISR(taskWoken);
 8018c48:	9b03      	ldr	r3, [sp, #12]
 8018c4a:	2b00      	cmp	r3, #0
 8018c4c:	d0f2      	beq.n	8018c34 <osMailPut+0x20>
 8018c4e:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
 8018c52:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8018c56:	f8c3 2d04 	str.w	r2, [r3, #3332]	; 0xd04
 8018c5a:	f3bf 8f4f 	dsb	sy
 8018c5e:	f3bf 8f6f 	isb	sy
  return osOK;
 8018c62:	4620      	mov	r0, r4
}
 8018c64:	b004      	add	sp, #16
 8018c66:	bd10      	pop	{r4, pc}
      return osErrorOS;
 8018c68:	20ff      	movs	r0, #255	; 0xff
}
 8018c6a:	b004      	add	sp, #16
 8018c6c:	bd10      	pop	{r4, pc}
    return osErrorParameter;
 8018c6e:	2080      	movs	r0, #128	; 0x80
}
 8018c70:	b004      	add	sp, #16
 8018c72:	bd10      	pop	{r4, pc}

08018c74 <osMailGet>:
* @param millisec    timeout value or 0 in case of no time-out
* @retval event that contains mail information or error code.
* @note   MUST REMAIN UNCHANGED: \b osMailGet shall be consistent in every CMSIS-RTOS.
*/
osEvent osMailGet (osMailQId queue_id, uint32_t millisec)
{
 8018c74:	b530      	push	{r4, r5, lr}
 8018c76:	b085      	sub	sp, #20
 8018c78:	4604      	mov	r4, r0
  portBASE_TYPE taskWoken;
  TickType_t ticks;
  osEvent event;
  
  event.def.mail_id = queue_id;
 8018c7a:	9103      	str	r1, [sp, #12]
  
  if (queue_id == NULL) {
 8018c7c:	b379      	cbz	r1, 8018cde <osMailGet+0x6a>
    event.status = osErrorParameter;
    return event;
  }
  
  taskWoken = pdFALSE;
 8018c7e:	2300      	movs	r3, #0
 8018c80:	9300      	str	r3, [sp, #0]
 8018c82:	f3ef 8305 	mrs	r3, IPSR
    if (ticks == 0) {
      ticks = 1;
    }
  }
  
  if (inHandlerMode()) {
 8018c86:	b993      	cbnz	r3, 8018cae <osMailGet+0x3a>
      event.status = osOK;
    }
    portEND_SWITCHING_ISR(taskWoken);
  }
  else {
    if (xQueueReceive(queue_id->handle, &event.value.p, ticks) == pdTRUE) {
 8018c88:	6848      	ldr	r0, [r1, #4]
 8018c8a:	a902      	add	r1, sp, #8
 8018c8c:	4615      	mov	r5, r2
 8018c8e:	f000 fde1 	bl	8019854 <xQueueReceive>
 8018c92:	2801      	cmp	r0, #1
 8018c94:	d02d      	beq.n	8018cf2 <osMailGet+0x7e>
      /* We have mail */
      event.status = osEventMail;
    }
    else {
      event.status = (ticks == 0) ? osOK : osEventTimeout;
 8018c96:	2d00      	cmp	r5, #0
 8018c98:	bf18      	it	ne
 8018c9a:	2540      	movne	r5, #64	; 0x40
 8018c9c:	9501      	str	r5, [sp, #4]
    }
  }
  
  return event;
 8018c9e:	ab04      	add	r3, sp, #16
 8018ca0:	e913 0007 	ldmdb	r3, {r0, r1, r2}
 8018ca4:	e884 0007 	stmia.w	r4, {r0, r1, r2}
}
 8018ca8:	4620      	mov	r0, r4
 8018caa:	b005      	add	sp, #20
 8018cac:	bd30      	pop	{r4, r5, pc}
    if (xQueueReceiveFromISR(queue_id->handle, &event.value.p, &taskWoken) == pdTRUE) {
 8018cae:	466a      	mov	r2, sp
 8018cb0:	6848      	ldr	r0, [r1, #4]
 8018cb2:	a902      	add	r1, sp, #8
 8018cb4:	f000 ff6e 	bl	8019b94 <xQueueReceiveFromISR>
    portEND_SWITCHING_ISR(taskWoken);
 8018cb8:	9b00      	ldr	r3, [sp, #0]
      event.status = osOK;
 8018cba:	2801      	cmp	r0, #1
 8018cbc:	bf0c      	ite	eq
 8018cbe:	2220      	moveq	r2, #32
 8018cc0:	2200      	movne	r2, #0
 8018cc2:	9201      	str	r2, [sp, #4]
    portEND_SWITCHING_ISR(taskWoken);
 8018cc4:	2b00      	cmp	r3, #0
 8018cc6:	d0ea      	beq.n	8018c9e <osMailGet+0x2a>
 8018cc8:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
 8018ccc:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8018cd0:	f8c3 2d04 	str.w	r2, [r3, #3332]	; 0xd04
 8018cd4:	f3bf 8f4f 	dsb	sy
 8018cd8:	f3bf 8f6f 	isb	sy
 8018cdc:	e7df      	b.n	8018c9e <osMailGet+0x2a>
    event.status = osErrorParameter;
 8018cde:	2380      	movs	r3, #128	; 0x80
 8018ce0:	9301      	str	r3, [sp, #4]
    return event;
 8018ce2:	ab04      	add	r3, sp, #16
 8018ce4:	e913 0007 	ldmdb	r3, {r0, r1, r2}
 8018ce8:	e884 0007 	stmia.w	r4, {r0, r1, r2}
}
 8018cec:	4620      	mov	r0, r4
 8018cee:	b005      	add	sp, #20
 8018cf0:	bd30      	pop	{r4, r5, pc}
      event.status = osEventMail;
 8018cf2:	2320      	movs	r3, #32
 8018cf4:	9301      	str	r3, [sp, #4]
 8018cf6:	e7d2      	b.n	8018c9e <osMailGet+0x2a>

08018cf8 <osMailFree>:
* @retval status code that indicates the execution status of the function.
* @note   MUST REMAIN UNCHANGED: \b osMailFree shall be consistent in every CMSIS-RTOS.
*/
osStatus osMailFree (osMailQId queue_id, void *mail)
{
  if (queue_id == NULL) {
 8018cf8:	b1a8      	cbz	r0, 8018d26 <osMailFree+0x2e>
    return osErrorParameter;
  }
  
  return osPoolFree(queue_id->pool, mail);
 8018cfa:	6883      	ldr	r3, [r0, #8]
  if (pool_id == NULL) {
 8018cfc:	b19b      	cbz	r3, 8018d26 <osMailFree+0x2e>
  if (block == NULL) {
 8018cfe:	b191      	cbz	r1, 8018d26 <osMailFree+0x2e>
  if (block < pool_id->pool) {
 8018d00:	6818      	ldr	r0, [r3, #0]
 8018d02:	4281      	cmp	r1, r0
 8018d04:	d30f      	bcc.n	8018d26 <osMailFree+0x2e>
{
 8018d06:	b410      	push	{r4}
  if (index % pool_id->item_sz) {
 8018d08:	68dc      	ldr	r4, [r3, #12]
  index = (uint32_t)block - (uint32_t)(pool_id->pool);
 8018d0a:	1a09      	subs	r1, r1, r0
  if (index % pool_id->item_sz) {
 8018d0c:	fbb1 f2f4 	udiv	r2, r1, r4
 8018d10:	fb04 1012 	mls	r0, r4, r2, r1
 8018d14:	b948      	cbnz	r0, 8018d2a <osMailFree+0x32>
  if (index >= pool_id->pool_sz) {
 8018d16:	6899      	ldr	r1, [r3, #8]
 8018d18:	428a      	cmp	r2, r1
 8018d1a:	d206      	bcs.n	8018d2a <osMailFree+0x32>
  pool_id->markers[index] = 0;
 8018d1c:	685b      	ldr	r3, [r3, #4]
 8018d1e:	5498      	strb	r0, [r3, r2]
}
 8018d20:	f85d 4b04 	ldr.w	r4, [sp], #4
 8018d24:	4770      	bx	lr
    return osErrorParameter;
 8018d26:	2080      	movs	r0, #128	; 0x80
}
 8018d28:	4770      	bx	lr
    return osErrorParameter;
 8018d2a:	2080      	movs	r0, #128	; 0x80
}
 8018d2c:	f85d 4b04 	ldr.w	r4, [sp], #4
 8018d30:	4770      	bx	lr
 8018d32:	bf00      	nop

08018d34 <osSystickHandler>:
* @brief  Handles the tick increment
* @param  none.
* @retval none.
*/
void osSystickHandler(void)
{
 8018d34:	b508      	push	{r3, lr}

#if (INCLUDE_xTaskGetSchedulerState  == 1 )
  if (xTaskGetSchedulerState() != taskSCHEDULER_NOT_STARTED)
 8018d36:	f001 fbf1 	bl	801a51c <xTaskGetSchedulerState>
 8018d3a:	2801      	cmp	r0, #1
 8018d3c:	d100      	bne.n	8018d40 <osSystickHandler+0xc>
#endif  /* INCLUDE_xTaskGetSchedulerState */  
    xPortSysTickHandler();
#if (INCLUDE_xTaskGetSchedulerState  == 1 )
  }
#endif  /* INCLUDE_xTaskGetSchedulerState */  
}
 8018d3e:	bd08      	pop	{r3, pc}
 8018d40:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    xPortSysTickHandler();
 8018d44:	f000 b9b6 	b.w	80190b4 <xPortSysTickHandler>

08018d48 <prvInsertBlockIntoFreeList>:
	xBlockAllocatedBit = ( ( size_t ) 1 ) << ( ( sizeof( size_t ) * heapBITS_PER_BYTE ) - 1 );
}
/*-----------------------------------------------------------*/

static void prvInsertBlockIntoFreeList( BlockLink_t *pxBlockToInsert )
{
 8018d48:	b410      	push	{r4}
BlockLink_t *pxIterator;
uint8_t *puc;

	/* Iterate through the list until a block is found that has a higher address
	than the block being inserted. */
	for( pxIterator = &xStart; pxIterator->pxNextFreeBlock < pxBlockToInsert; pxIterator = pxIterator->pxNextFreeBlock )
 8018d4a:	4c16      	ldr	r4, [pc, #88]	; (8018da4 <prvInsertBlockIntoFreeList+0x5c>)
 8018d4c:	4623      	mov	r3, r4
 8018d4e:	461a      	mov	r2, r3
 8018d50:	681b      	ldr	r3, [r3, #0]
 8018d52:	4283      	cmp	r3, r0
 8018d54:	d3fb      	bcc.n	8018d4e <prvInsertBlockIntoFreeList+0x6>
	}

	/* Do the block being inserted, and the block it is being inserted after
	make a contiguous block of memory? */
	puc = ( uint8_t * ) pxIterator;
	if( ( puc + pxIterator->xBlockSize ) == ( uint8_t * ) pxBlockToInsert )
 8018d56:	6851      	ldr	r1, [r2, #4]
 8018d58:	eb02 0c01 	add.w	ip, r2, r1
 8018d5c:	4560      	cmp	r0, ip
 8018d5e:	d00b      	beq.n	8018d78 <prvInsertBlockIntoFreeList+0x30>
	}

	/* Do the block being inserted, and the block it is being inserted before
	make a contiguous block of memory? */
	puc = ( uint8_t * ) pxBlockToInsert;
	if( ( puc + pxBlockToInsert->xBlockSize ) == ( uint8_t * ) pxIterator->pxNextFreeBlock )
 8018d60:	6841      	ldr	r1, [r0, #4]
 8018d62:	eb00 0c01 	add.w	ip, r0, r1
 8018d66:	4563      	cmp	r3, ip
 8018d68:	d00e      	beq.n	8018d88 <prvInsertBlockIntoFreeList+0x40>

	/* If the block being inserted plugged a gab, so was merged with the block
	before and the block after, then it's pxNextFreeBlock pointer will have
	already been set, and should not be set here as that would make it point
	to itself. */
	if( pxIterator != pxBlockToInsert )
 8018d6a:	4290      	cmp	r0, r2
		pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock;
 8018d6c:	6003      	str	r3, [r0, #0]
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}
}
 8018d6e:	f85d 4b04 	ldr.w	r4, [sp], #4
		pxIterator->pxNextFreeBlock = pxBlockToInsert;
 8018d72:	bf18      	it	ne
 8018d74:	6010      	strne	r0, [r2, #0]
}
 8018d76:	4770      	bx	lr
		pxIterator->xBlockSize += pxBlockToInsert->xBlockSize;
 8018d78:	6840      	ldr	r0, [r0, #4]
 8018d7a:	4401      	add	r1, r0
 8018d7c:	4610      	mov	r0, r2
	if( ( puc + pxBlockToInsert->xBlockSize ) == ( uint8_t * ) pxIterator->pxNextFreeBlock )
 8018d7e:	eb00 0c01 	add.w	ip, r0, r1
 8018d82:	4563      	cmp	r3, ip
		pxIterator->xBlockSize += pxBlockToInsert->xBlockSize;
 8018d84:	6051      	str	r1, [r2, #4]
	if( ( puc + pxBlockToInsert->xBlockSize ) == ( uint8_t * ) pxIterator->pxNextFreeBlock )
 8018d86:	d1f0      	bne.n	8018d6a <prvInsertBlockIntoFreeList+0x22>
		if( pxIterator->pxNextFreeBlock != pxEnd )
 8018d88:	68a4      	ldr	r4, [r4, #8]
 8018d8a:	42a3      	cmp	r3, r4
 8018d8c:	d0ed      	beq.n	8018d6a <prvInsertBlockIntoFreeList+0x22>
			pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock->pxNextFreeBlock;
 8018d8e:	e9d3 3400 	ldrd	r3, r4, [r3]
	if( pxIterator != pxBlockToInsert )
 8018d92:	4290      	cmp	r0, r2
			pxBlockToInsert->xBlockSize += pxIterator->pxNextFreeBlock->xBlockSize;
 8018d94:	4421      	add	r1, r4
			pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock->pxNextFreeBlock;
 8018d96:	e9c0 3100 	strd	r3, r1, [r0]
}
 8018d9a:	f85d 4b04 	ldr.w	r4, [sp], #4
		pxIterator->pxNextFreeBlock = pxBlockToInsert;
 8018d9e:	bf18      	it	ne
 8018da0:	6010      	strne	r0, [r2, #0]
}
 8018da2:	4770      	bx	lr
 8018da4:	20003344 	.word	0x20003344

08018da8 <pvPortMalloc>:
{
 8018da8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
		if( pxEnd == NULL )
 8018dac:	4d3a      	ldr	r5, [pc, #232]	; (8018e98 <pvPortMalloc+0xf0>)
{
 8018dae:	4604      	mov	r4, r0
	vTaskSuspendAll();
 8018db0:	f001 f90e 	bl	8019fd0 <vTaskSuspendAll>
		if( pxEnd == NULL )
 8018db4:	68ab      	ldr	r3, [r5, #8]
 8018db6:	2b00      	cmp	r3, #0
 8018db8:	d053      	beq.n	8018e62 <pvPortMalloc+0xba>
		if( ( xWantedSize & xBlockAllocatedBit ) == 0 )
 8018dba:	68ee      	ldr	r6, [r5, #12]
 8018dbc:	4234      	tst	r4, r6
 8018dbe:	d12d      	bne.n	8018e1c <pvPortMalloc+0x74>
			if( xWantedSize > 0 )
 8018dc0:	b364      	cbz	r4, 8018e1c <pvPortMalloc+0x74>
				xWantedSize += xHeapStructSize;
 8018dc2:	f104 0108 	add.w	r1, r4, #8
				if( ( xWantedSize & portBYTE_ALIGNMENT_MASK ) != 0x00 )
 8018dc6:	0760      	lsls	r0, r4, #29
					xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
 8018dc8:	bf1c      	itt	ne
 8018dca:	f021 0107 	bicne.w	r1, r1, #7
 8018dce:	3108      	addne	r1, #8
			if( ( xWantedSize > 0 ) && ( xWantedSize <= xFreeBytesRemaining ) )
 8018dd0:	b321      	cbz	r1, 8018e1c <pvPortMalloc+0x74>
 8018dd2:	f8d5 8014 	ldr.w	r8, [r5, #20]
 8018dd6:	4588      	cmp	r8, r1
 8018dd8:	d320      	bcc.n	8018e1c <pvPortMalloc+0x74>
				pxBlock = xStart.pxNextFreeBlock;
 8018dda:	682c      	ldr	r4, [r5, #0]
				pxPreviousBlock = &xStart;
 8018ddc:	482e      	ldr	r0, [pc, #184]	; (8018e98 <pvPortMalloc+0xf0>)
				while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
 8018dde:	e003      	b.n	8018de8 <pvPortMalloc+0x40>
 8018de0:	6823      	ldr	r3, [r4, #0]
 8018de2:	b123      	cbz	r3, 8018dee <pvPortMalloc+0x46>
 8018de4:	4620      	mov	r0, r4
 8018de6:	461c      	mov	r4, r3
 8018de8:	6862      	ldr	r2, [r4, #4]
 8018dea:	428a      	cmp	r2, r1
 8018dec:	d3f8      	bcc.n	8018de0 <pvPortMalloc+0x38>
				if( pxBlock != pxEnd )
 8018dee:	68ab      	ldr	r3, [r5, #8]
 8018df0:	42a3      	cmp	r3, r4
 8018df2:	d013      	beq.n	8018e1c <pvPortMalloc+0x74>
					pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
 8018df4:	6823      	ldr	r3, [r4, #0]
					pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + xHeapStructSize );
 8018df6:	6807      	ldr	r7, [r0, #0]
					pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
 8018df8:	6003      	str	r3, [r0, #0]
					if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
 8018dfa:	1a53      	subs	r3, r2, r1
 8018dfc:	2b10      	cmp	r3, #16
					pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + xHeapStructSize );
 8018dfe:	f107 0708 	add.w	r7, r7, #8
					if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
 8018e02:	d916      	bls.n	8018e32 <pvPortMalloc+0x8a>
						pxNewBlockLink = ( void * ) ( ( ( uint8_t * ) pxBlock ) + xWantedSize );
 8018e04:	1860      	adds	r0, r4, r1
						configASSERT( ( ( ( size_t ) pxNewBlockLink ) & portBYTE_ALIGNMENT_MASK ) == 0 );
 8018e06:	0742      	lsls	r2, r0, #29
 8018e08:	d00e      	beq.n	8018e28 <pvPortMalloc+0x80>
	__asm volatile
 8018e0a:	f04f 0350 	mov.w	r3, #80	; 0x50
 8018e0e:	f383 8811 	msr	BASEPRI, r3
 8018e12:	f3bf 8f6f 	isb	sy
 8018e16:	f3bf 8f4f 	dsb	sy
 8018e1a:	e7fe      	b.n	8018e1a <pvPortMalloc+0x72>
	( void ) xTaskResumeAll();
 8018e1c:	f001 f9d8 	bl	801a1d0 <xTaskResumeAll>
 8018e20:	2700      	movs	r7, #0
}
 8018e22:	4638      	mov	r0, r7
 8018e24:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
						pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
 8018e28:	6043      	str	r3, [r0, #4]
						pxBlock->xBlockSize = xWantedSize;
 8018e2a:	6061      	str	r1, [r4, #4]
						prvInsertBlockIntoFreeList( pxNewBlockLink );
 8018e2c:	f7ff ff8c 	bl	8018d48 <prvInsertBlockIntoFreeList>
					xFreeBytesRemaining -= pxBlock->xBlockSize;
 8018e30:	6862      	ldr	r2, [r4, #4]
					if( xFreeBytesRemaining < xMinimumEverFreeBytesRemaining )
 8018e32:	6929      	ldr	r1, [r5, #16]
					xFreeBytesRemaining -= pxBlock->xBlockSize;
 8018e34:	eba8 0302 	sub.w	r3, r8, r2
					if( xFreeBytesRemaining < xMinimumEverFreeBytesRemaining )
 8018e38:	428b      	cmp	r3, r1
						xMinimumEverFreeBytesRemaining = xFreeBytesRemaining;
 8018e3a:	bf38      	it	cc
 8018e3c:	612b      	strcc	r3, [r5, #16]
					xFreeBytesRemaining -= pxBlock->xBlockSize;
 8018e3e:	616b      	str	r3, [r5, #20]
					pxBlock->xBlockSize |= xBlockAllocatedBit;
 8018e40:	4332      	orrs	r2, r6
					pxBlock->pxNextFreeBlock = NULL;
 8018e42:	2300      	movs	r3, #0
 8018e44:	e9c4 3200 	strd	r3, r2, [r4]
	( void ) xTaskResumeAll();
 8018e48:	f001 f9c2 	bl	801a1d0 <xTaskResumeAll>
	configASSERT( ( ( ( size_t ) pvReturn ) & ( size_t ) portBYTE_ALIGNMENT_MASK ) == 0 );
 8018e4c:	077b      	lsls	r3, r7, #29
 8018e4e:	d0e8      	beq.n	8018e22 <pvPortMalloc+0x7a>
 8018e50:	f04f 0350 	mov.w	r3, #80	; 0x50
 8018e54:	f383 8811 	msr	BASEPRI, r3
 8018e58:	f3bf 8f6f 	isb	sy
 8018e5c:	f3bf 8f4f 	dsb	sy
 8018e60:	e7fe      	b.n	8018e60 <pvPortMalloc+0xb8>
	uxAddress = ( size_t ) ucHeap;
 8018e62:	4b0e      	ldr	r3, [pc, #56]	; (8018e9c <pvPortMalloc+0xf4>)
	if( ( uxAddress & portBYTE_ALIGNMENT_MASK ) != 0 )
 8018e64:	4a0e      	ldr	r2, [pc, #56]	; (8018ea0 <pvPortMalloc+0xf8>)
 8018e66:	075e      	lsls	r6, r3, #29
		uxAddress += ( portBYTE_ALIGNMENT - 1 );
 8018e68:	bf1c      	itt	ne
 8018e6a:	3307      	addne	r3, #7
		uxAddress &= ~( ( size_t ) portBYTE_ALIGNMENT_MASK );
 8018e6c:	f023 0307 	bicne.w	r3, r3, #7
	uxAddress -= xHeapStructSize;
 8018e70:	3a08      	subs	r2, #8
	uxAddress &= ~( ( size_t ) portBYTE_ALIGNMENT_MASK );
 8018e72:	f022 0107 	bic.w	r1, r2, #7
	pucAlignedHeap = ( uint8_t * ) uxAddress;
 8018e76:	4618      	mov	r0, r3
	xStart.xBlockSize = ( size_t ) 0;
 8018e78:	2200      	movs	r2, #0
	pxFirstFreeBlock->xBlockSize = uxAddress - ( size_t ) pxFirstFreeBlock;
 8018e7a:	1acb      	subs	r3, r1, r3
	xBlockAllocatedBit = ( ( size_t ) 1 ) << ( ( sizeof( size_t ) * heapBITS_PER_BYTE ) - 1 );
 8018e7c:	f04f 4600 	mov.w	r6, #2147483648	; 0x80000000
	xStart.xBlockSize = ( size_t ) 0;
 8018e80:	606a      	str	r2, [r5, #4]
	xStart.pxNextFreeBlock = ( void * ) pucAlignedHeap;
 8018e82:	6028      	str	r0, [r5, #0]
	xFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
 8018e84:	e9c5 3304 	strd	r3, r3, [r5, #16]
	pxEnd->pxNextFreeBlock = NULL;
 8018e88:	e9c1 2200 	strd	r2, r2, [r1]
	pxEnd = ( void * ) uxAddress;
 8018e8c:	60a9      	str	r1, [r5, #8]
	pxFirstFreeBlock->xBlockSize = uxAddress - ( size_t ) pxFirstFreeBlock;
 8018e8e:	6043      	str	r3, [r0, #4]
	pxFirstFreeBlock->pxNextFreeBlock = pxEnd;
 8018e90:	6001      	str	r1, [r0, #0]
	xBlockAllocatedBit = ( ( size_t ) 1 ) << ( ( sizeof( size_t ) * heapBITS_PER_BYTE ) - 1 );
 8018e92:	60ee      	str	r6, [r5, #12]
}
 8018e94:	e792      	b.n	8018dbc <pvPortMalloc+0x14>
 8018e96:	bf00      	nop
 8018e98:	20003344 	.word	0x20003344
 8018e9c:	2000335c 	.word	0x2000335c
 8018ea0:	20007f2a 	.word	0x20007f2a

08018ea4 <vPortFree>:
	if( pv != NULL )
 8018ea4:	b1e0      	cbz	r0, 8018ee0 <vPortFree+0x3c>
{
 8018ea6:	b510      	push	{r4, lr}
		configASSERT( ( pxLink->xBlockSize & xBlockAllocatedBit ) != 0 );
 8018ea8:	4c18      	ldr	r4, [pc, #96]	; (8018f0c <vPortFree+0x68>)
 8018eaa:	f850 3c04 	ldr.w	r3, [r0, #-4]
 8018eae:	68e2      	ldr	r2, [r4, #12]
 8018eb0:	4213      	tst	r3, r2
{
 8018eb2:	b082      	sub	sp, #8
		configASSERT( ( pxLink->xBlockSize & xBlockAllocatedBit ) != 0 );
 8018eb4:	d00b      	beq.n	8018ece <vPortFree+0x2a>
		configASSERT( pxLink->pxNextFreeBlock == NULL );
 8018eb6:	f850 1c08 	ldr.w	r1, [r0, #-8]
 8018eba:	b191      	cbz	r1, 8018ee2 <vPortFree+0x3e>
 8018ebc:	f04f 0350 	mov.w	r3, #80	; 0x50
 8018ec0:	f383 8811 	msr	BASEPRI, r3
 8018ec4:	f3bf 8f6f 	isb	sy
 8018ec8:	f3bf 8f4f 	dsb	sy
 8018ecc:	e7fe      	b.n	8018ecc <vPortFree+0x28>
 8018ece:	f04f 0350 	mov.w	r3, #80	; 0x50
 8018ed2:	f383 8811 	msr	BASEPRI, r3
 8018ed6:	f3bf 8f6f 	isb	sy
 8018eda:	f3bf 8f4f 	dsb	sy
		configASSERT( ( pxLink->xBlockSize & xBlockAllocatedBit ) != 0 );
 8018ede:	e7fe      	b.n	8018ede <vPortFree+0x3a>
 8018ee0:	4770      	bx	lr
				pxLink->xBlockSize &= ~xBlockAllocatedBit;
 8018ee2:	ea23 0302 	bic.w	r3, r3, r2
 8018ee6:	f840 3c04 	str.w	r3, [r0, #-4]
 8018eea:	9001      	str	r0, [sp, #4]
				vTaskSuspendAll();
 8018eec:	f001 f870 	bl	8019fd0 <vTaskSuspendAll>
					xFreeBytesRemaining += pxLink->xBlockSize;
 8018ef0:	9801      	ldr	r0, [sp, #4]
 8018ef2:	6962      	ldr	r2, [r4, #20]
 8018ef4:	f850 3c04 	ldr.w	r3, [r0, #-4]
					prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );
 8018ef8:	3808      	subs	r0, #8
					xFreeBytesRemaining += pxLink->xBlockSize;
 8018efa:	4413      	add	r3, r2
 8018efc:	6163      	str	r3, [r4, #20]
					prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );
 8018efe:	f7ff ff23 	bl	8018d48 <prvInsertBlockIntoFreeList>
}
 8018f02:	b002      	add	sp, #8
 8018f04:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
				( void ) xTaskResumeAll();
 8018f08:	f001 b962 	b.w	801a1d0 <xTaskResumeAll>
 8018f0c:	20003344 	.word	0x20003344

08018f10 <prvPortStartFirstTask>:
{
	/* Start the first task.  This also clears the bit that indicates the FPU is
	in use in case the FPU was used before the scheduler was started - which
	would otherwise result in the unnecessary leaving of space in the SVC stack
	for lazy saving of FPU registers. */
	__asm volatile(
 8018f10:	4808      	ldr	r0, [pc, #32]	; (8018f34 <prvPortStartFirstTask+0x24>)
 8018f12:	6800      	ldr	r0, [r0, #0]
 8018f14:	6800      	ldr	r0, [r0, #0]
 8018f16:	f380 8808 	msr	MSP, r0
 8018f1a:	f04f 0000 	mov.w	r0, #0
 8018f1e:	f380 8814 	msr	CONTROL, r0
 8018f22:	b662      	cpsie	i
 8018f24:	b661      	cpsie	f
 8018f26:	f3bf 8f4f 	dsb	sy
 8018f2a:	f3bf 8f6f 	isb	sy
 8018f2e:	df00      	svc	0
 8018f30:	bf00      	nop
					" dsb					\n"
					" isb					\n"
					" svc 0					\n" /* System call to start first task. */
					" nop					\n"
				);
}
 8018f32:	0000      	.short	0x0000
 8018f34:	e000ed08 	.word	0xe000ed08

08018f38 <vPortEnableVFP>:
/*-----------------------------------------------------------*/

/* This is a naked function. */
static void vPortEnableVFP( void )
{
	__asm volatile
 8018f38:	f8df 000c 	ldr.w	r0, [pc, #12]	; 8018f48 <vPortEnableVFP+0x10>
 8018f3c:	6801      	ldr	r1, [r0, #0]
 8018f3e:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
 8018f42:	6001      	str	r1, [r0, #0]
 8018f44:	4770      	bx	lr
		"								\n"
		"	orr r1, r1, #( 0xf << 20 )	\n" /* Enable CP10 and CP11 coprocessors, then save back. */
		"	str r1, [r0]				\n"
		"	bx r14						"
	);
}
 8018f46:	0000      	.short	0x0000
 8018f48:	e000ed88 	.word	0xe000ed88

08018f4c <prvTaskExitError>:
	configASSERT( uxCriticalNesting == ~0UL );
 8018f4c:	4b0e      	ldr	r3, [pc, #56]	; (8018f88 <prvTaskExitError+0x3c>)
 8018f4e:	681b      	ldr	r3, [r3, #0]
{
 8018f50:	b082      	sub	sp, #8
volatile uint32_t ulDummy = 0;
 8018f52:	2200      	movs	r2, #0
	configASSERT( uxCriticalNesting == ~0UL );
 8018f54:	3301      	adds	r3, #1
volatile uint32_t ulDummy = 0;
 8018f56:	9201      	str	r2, [sp, #4]
	configASSERT( uxCriticalNesting == ~0UL );
 8018f58:	d008      	beq.n	8018f6c <prvTaskExitError+0x20>
 8018f5a:	f04f 0350 	mov.w	r3, #80	; 0x50
 8018f5e:	f383 8811 	msr	BASEPRI, r3
 8018f62:	f3bf 8f6f 	isb	sy
 8018f66:	f3bf 8f4f 	dsb	sy
 8018f6a:	e7fe      	b.n	8018f6a <prvTaskExitError+0x1e>
 8018f6c:	f04f 0350 	mov.w	r3, #80	; 0x50
 8018f70:	f383 8811 	msr	BASEPRI, r3
 8018f74:	f3bf 8f6f 	isb	sy
 8018f78:	f3bf 8f4f 	dsb	sy
	while( ulDummy == 0 )
 8018f7c:	9b01      	ldr	r3, [sp, #4]
 8018f7e:	2b00      	cmp	r3, #0
 8018f80:	d0fc      	beq.n	8018f7c <prvTaskExitError+0x30>
}
 8018f82:	b002      	add	sp, #8
 8018f84:	4770      	bx	lr
 8018f86:	bf00      	nop
 8018f88:	20000148 	.word	0x20000148

08018f8c <pxPortInitialiseStack>:
{
 8018f8c:	b410      	push	{r4}
	*pxTopOfStack = portINITIAL_XPSR;	/* xPSR */
 8018f8e:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
	*pxTopOfStack = ( StackType_t ) portTASK_RETURN_ADDRESS;	/* LR */
 8018f92:	4c07      	ldr	r4, [pc, #28]	; (8018fb0 <pxPortInitialiseStack+0x24>)
	*pxTopOfStack = portINITIAL_XPSR;	/* xPSR */
 8018f94:	f840 3c04 	str.w	r3, [r0, #-4]
	*pxTopOfStack = ( ( StackType_t ) pxCode ) & portSTART_ADDRESS_MASK;	/* PC */
 8018f98:	f021 0101 	bic.w	r1, r1, #1
	*pxTopOfStack = portINITIAL_EXC_RETURN;
 8018f9c:	f06f 0302 	mvn.w	r3, #2
	*pxTopOfStack = ( StackType_t ) portTASK_RETURN_ADDRESS;	/* LR */
 8018fa0:	e940 4103 	strd	r4, r1, [r0, #-12]
	*pxTopOfStack = portINITIAL_EXC_RETURN;
 8018fa4:	e940 3209 	strd	r3, r2, [r0, #-36]	; 0x24
}
 8018fa8:	f85d 4b04 	ldr.w	r4, [sp], #4
 8018fac:	3844      	subs	r0, #68	; 0x44
 8018fae:	4770      	bx	lr
 8018fb0:	08018f4d 	.word	0x08018f4d
	...

08018fc0 <SVC_Handler>:
	__asm volatile (
 8018fc0:	4b07      	ldr	r3, [pc, #28]	; (8018fe0 <pxCurrentTCBConst2>)
 8018fc2:	6819      	ldr	r1, [r3, #0]
 8018fc4:	6808      	ldr	r0, [r1, #0]
 8018fc6:	e8b0 4ff0 	ldmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8018fca:	f380 8809 	msr	PSP, r0
 8018fce:	f3bf 8f6f 	isb	sy
 8018fd2:	f04f 0000 	mov.w	r0, #0
 8018fd6:	f380 8811 	msr	BASEPRI, r0
 8018fda:	4770      	bx	lr
 8018fdc:	f3af 8000 	nop.w

08018fe0 <pxCurrentTCBConst2>:
 8018fe0:	20007f84 	.word	0x20007f84

08018fe4 <vPortEnterCritical>:
 8018fe4:	f04f 0350 	mov.w	r3, #80	; 0x50
 8018fe8:	f383 8811 	msr	BASEPRI, r3
 8018fec:	f3bf 8f6f 	isb	sy
 8018ff0:	f3bf 8f4f 	dsb	sy
	uxCriticalNesting++;
 8018ff4:	4a0b      	ldr	r2, [pc, #44]	; (8019024 <vPortEnterCritical+0x40>)
 8018ff6:	6813      	ldr	r3, [r2, #0]
 8018ff8:	3301      	adds	r3, #1
	if( uxCriticalNesting == 1 )
 8018ffa:	2b01      	cmp	r3, #1
	uxCriticalNesting++;
 8018ffc:	6013      	str	r3, [r2, #0]
	if( uxCriticalNesting == 1 )
 8018ffe:	d000      	beq.n	8019002 <vPortEnterCritical+0x1e>
}
 8019000:	4770      	bx	lr
		configASSERT( ( portNVIC_INT_CTRL_REG & portVECTACTIVE_MASK ) == 0 );
 8019002:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
 8019006:	f8d3 3d04 	ldr.w	r3, [r3, #3332]	; 0xd04
 801900a:	b2db      	uxtb	r3, r3
 801900c:	2b00      	cmp	r3, #0
 801900e:	d0f7      	beq.n	8019000 <vPortEnterCritical+0x1c>
 8019010:	f04f 0350 	mov.w	r3, #80	; 0x50
 8019014:	f383 8811 	msr	BASEPRI, r3
 8019018:	f3bf 8f6f 	isb	sy
 801901c:	f3bf 8f4f 	dsb	sy
 8019020:	e7fe      	b.n	8019020 <vPortEnterCritical+0x3c>
 8019022:	bf00      	nop
 8019024:	20000148 	.word	0x20000148

08019028 <vPortExitCritical>:
	configASSERT( uxCriticalNesting );
 8019028:	4a08      	ldr	r2, [pc, #32]	; (801904c <vPortExitCritical+0x24>)
 801902a:	6813      	ldr	r3, [r2, #0]
 801902c:	b943      	cbnz	r3, 8019040 <vPortExitCritical+0x18>
 801902e:	f04f 0350 	mov.w	r3, #80	; 0x50
 8019032:	f383 8811 	msr	BASEPRI, r3
 8019036:	f3bf 8f6f 	isb	sy
 801903a:	f3bf 8f4f 	dsb	sy
 801903e:	e7fe      	b.n	801903e <vPortExitCritical+0x16>
	uxCriticalNesting--;
 8019040:	3b01      	subs	r3, #1
 8019042:	6013      	str	r3, [r2, #0]
	if( uxCriticalNesting == 0 )
 8019044:	b90b      	cbnz	r3, 801904a <vPortExitCritical+0x22>
	__asm volatile
 8019046:	f383 8811 	msr	BASEPRI, r3
}
 801904a:	4770      	bx	lr
 801904c:	20000148 	.word	0x20000148

08019050 <PendSV_Handler>:
	__asm volatile
 8019050:	f3ef 8009 	mrs	r0, PSP
 8019054:	f3bf 8f6f 	isb	sy
 8019058:	4b15      	ldr	r3, [pc, #84]	; (80190b0 <pxCurrentTCBConst>)
 801905a:	681a      	ldr	r2, [r3, #0]
 801905c:	f01e 0f10 	tst.w	lr, #16
 8019060:	bf08      	it	eq
 8019062:	ed20 8a10 	vstmdbeq	r0!, {s16-s31}
 8019066:	e920 4ff0 	stmdb	r0!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 801906a:	6010      	str	r0, [r2, #0]
 801906c:	e92d 0009 	stmdb	sp!, {r0, r3}
 8019070:	f04f 0050 	mov.w	r0, #80	; 0x50
 8019074:	f380 8811 	msr	BASEPRI, r0
 8019078:	f3bf 8f4f 	dsb	sy
 801907c:	f3bf 8f6f 	isb	sy
 8019080:	f001 f968 	bl	801a354 <vTaskSwitchContext>
 8019084:	f04f 0000 	mov.w	r0, #0
 8019088:	f380 8811 	msr	BASEPRI, r0
 801908c:	bc09      	pop	{r0, r3}
 801908e:	6819      	ldr	r1, [r3, #0]
 8019090:	6808      	ldr	r0, [r1, #0]
 8019092:	e8b0 4ff0 	ldmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8019096:	f01e 0f10 	tst.w	lr, #16
 801909a:	bf08      	it	eq
 801909c:	ecb0 8a10 	vldmiaeq	r0!, {s16-s31}
 80190a0:	f380 8809 	msr	PSP, r0
 80190a4:	f3bf 8f6f 	isb	sy
 80190a8:	4770      	bx	lr
 80190aa:	bf00      	nop
 80190ac:	f3af 8000 	nop.w

080190b0 <pxCurrentTCBConst>:
 80190b0:	20007f84 	.word	0x20007f84

080190b4 <xPortSysTickHandler>:
{
 80190b4:	b508      	push	{r3, lr}
	__asm volatile
 80190b6:	f04f 0350 	mov.w	r3, #80	; 0x50
 80190ba:	f383 8811 	msr	BASEPRI, r3
 80190be:	f3bf 8f6f 	isb	sy
 80190c2:	f3bf 8f4f 	dsb	sy
		if( xTaskIncrementTick() != pdFALSE )
 80190c6:	f000 ff93 	bl	8019ff0 <xTaskIncrementTick>
 80190ca:	b128      	cbz	r0, 80190d8 <xPortSysTickHandler+0x24>
			portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;
 80190cc:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
 80190d0:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 80190d4:	f8c3 2d04 	str.w	r2, [r3, #3332]	; 0xd04
	__asm volatile
 80190d8:	2300      	movs	r3, #0
 80190da:	f383 8811 	msr	BASEPRI, r3
}
 80190de:	bd08      	pop	{r3, pc}

080190e0 <vPortSetupTimerInterrupt>:
		ulTimerCountsForOneTick = ( configSYSTICK_CLOCK_HZ / configTICK_RATE_HZ );
 80190e0:	4b0f      	ldr	r3, [pc, #60]	; (8019120 <vPortSetupTimerInterrupt+0x40>)
 80190e2:	4910      	ldr	r1, [pc, #64]	; (8019124 <vPortSetupTimerInterrupt+0x44>)
 80190e4:	681a      	ldr	r2, [r3, #0]
{
 80190e6:	b410      	push	{r4}
		ulTimerCountsForOneTick = ( configSYSTICK_CLOCK_HZ / configTICK_RATE_HZ );
 80190e8:	4c0f      	ldr	r4, [pc, #60]	; (8019128 <vPortSetupTimerInterrupt+0x48>)
 80190ea:	fba4 0202 	umull	r0, r2, r4, r2
 80190ee:	0992      	lsrs	r2, r2, #6
		xMaximumPossibleSuppressedTicks = portMAX_24_BIT_NUMBER / ulTimerCountsForOneTick;
 80190f0:	f06f 407f 	mvn.w	r0, #4278190080	; 0xff000000
 80190f4:	fbb0 f0f2 	udiv	r0, r0, r2
 80190f8:	6008      	str	r0, [r1, #0]
		ulStoppedTimerCompensation = portMISSED_COUNTS_FACTOR / ( configCPU_CLOCK_HZ / configSYSTICK_CLOCK_HZ );
 80190fa:	202d      	movs	r0, #45	; 0x2d
 80190fc:	e9c1 2001 	strd	r2, r0, [r1, #4]
	portNVIC_SYSTICK_CTRL_REG = 0UL;
 8019100:	f04f 22e0 	mov.w	r2, #3758153728	; 0xe000e000
 8019104:	2100      	movs	r1, #0
 8019106:	6111      	str	r1, [r2, #16]
	portNVIC_SYSTICK_CURRENT_VALUE_REG = 0UL;
 8019108:	6191      	str	r1, [r2, #24]
	portNVIC_SYSTICK_LOAD_REG = ( configSYSTICK_CLOCK_HZ / configTICK_RATE_HZ ) - 1UL;
 801910a:	681b      	ldr	r3, [r3, #0]
 801910c:	fba4 0303 	umull	r0, r3, r4, r3
 8019110:	099b      	lsrs	r3, r3, #6
	portNVIC_SYSTICK_CTRL_REG = ( portNVIC_SYSTICK_CLK_BIT | portNVIC_SYSTICK_INT_BIT | portNVIC_SYSTICK_ENABLE_BIT );
 8019112:	2107      	movs	r1, #7
	portNVIC_SYSTICK_LOAD_REG = ( configSYSTICK_CLOCK_HZ / configTICK_RATE_HZ ) - 1UL;
 8019114:	3b01      	subs	r3, #1
 8019116:	6153      	str	r3, [r2, #20]
}
 8019118:	f85d 4b04 	ldr.w	r4, [sp], #4
	portNVIC_SYSTICK_CTRL_REG = ( portNVIC_SYSTICK_CLK_BIT | portNVIC_SYSTICK_INT_BIT | portNVIC_SYSTICK_ENABLE_BIT );
 801911c:	6111      	str	r1, [r2, #16]
}
 801911e:	4770      	bx	lr
 8019120:	2000011c 	.word	0x2000011c
 8019124:	20007f2c 	.word	0x20007f2c
 8019128:	10624dd3 	.word	0x10624dd3

0801912c <xPortStartScheduler>:
	configASSERT( portCPUID != portCORTEX_M7_r0p1_ID );
 801912c:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
 8019130:	4a3c      	ldr	r2, [pc, #240]	; (8019224 <xPortStartScheduler+0xf8>)
 8019132:	f8d3 1d00 	ldr.w	r1, [r3, #3328]	; 0xd00
 8019136:	4291      	cmp	r1, r2
 8019138:	d040      	beq.n	80191bc <xPortStartScheduler+0x90>
	configASSERT( portCPUID != portCORTEX_M7_r0p0_ID );
 801913a:	f8d3 2d00 	ldr.w	r2, [r3, #3328]	; 0xd00
 801913e:	4b3a      	ldr	r3, [pc, #232]	; (8019228 <xPortStartScheduler+0xfc>)
 8019140:	429a      	cmp	r2, r3
 8019142:	d032      	beq.n	80191aa <xPortStartScheduler+0x7e>
{
 8019144:	b530      	push	{r4, r5, lr}
		ulOriginalPriority = *pucFirstUserPriorityRegister;
 8019146:	4b39      	ldr	r3, [pc, #228]	; (801922c <xPortStartScheduler+0x100>)
		ucMaxSysCallPriority = configMAX_SYSCALL_INTERRUPT_PRIORITY & ucMaxPriorityValue;
 8019148:	4839      	ldr	r0, [pc, #228]	; (8019230 <xPortStartScheduler+0x104>)
		ulOriginalPriority = *pucFirstUserPriorityRegister;
 801914a:	781a      	ldrb	r2, [r3, #0]
{
 801914c:	b083      	sub	sp, #12
		*pucFirstUserPriorityRegister = portMAX_8_BIT_VALUE;
 801914e:	21ff      	movs	r1, #255	; 0xff
		ulOriginalPriority = *pucFirstUserPriorityRegister;
 8019150:	b2d2      	uxtb	r2, r2
 8019152:	9201      	str	r2, [sp, #4]
		*pucFirstUserPriorityRegister = portMAX_8_BIT_VALUE;
 8019154:	7019      	strb	r1, [r3, #0]
		ucMaxPriorityValue = *pucFirstUserPriorityRegister;
 8019156:	781b      	ldrb	r3, [r3, #0]
 8019158:	b2db      	uxtb	r3, r3
 801915a:	f88d 3003 	strb.w	r3, [sp, #3]
		ucMaxSysCallPriority = configMAX_SYSCALL_INTERRUPT_PRIORITY & ucMaxPriorityValue;
 801915e:	f89d 3003 	ldrb.w	r3, [sp, #3]
		while( ( ucMaxPriorityValue & portTOP_BIT_OF_BYTE ) == portTOP_BIT_OF_BYTE )
 8019162:	f89d 2003 	ldrb.w	r2, [sp, #3]
		ucMaxSysCallPriority = configMAX_SYSCALL_INTERRUPT_PRIORITY & ucMaxPriorityValue;
 8019166:	f003 0350 	and.w	r3, r3, #80	; 0x50
		ulMaxPRIGROUPValue = portMAX_PRIGROUP_BITS;
 801916a:	2107      	movs	r1, #7
		while( ( ucMaxPriorityValue & portTOP_BIT_OF_BYTE ) == portTOP_BIT_OF_BYTE )
 801916c:	0612      	lsls	r2, r2, #24
		ucMaxSysCallPriority = configMAX_SYSCALL_INTERRUPT_PRIORITY & ucMaxPriorityValue;
 801916e:	7303      	strb	r3, [r0, #12]
		ulMaxPRIGROUPValue = portMAX_PRIGROUP_BITS;
 8019170:	6101      	str	r1, [r0, #16]
		while( ( ucMaxPriorityValue & portTOP_BIT_OF_BYTE ) == portTOP_BIT_OF_BYTE )
 8019172:	bf48      	it	mi
 8019174:	2206      	movmi	r2, #6
 8019176:	d50f      	bpl.n	8019198 <xPortStartScheduler+0x6c>
			ucMaxPriorityValue <<= ( uint8_t ) 0x01;
 8019178:	f89d 3003 	ldrb.w	r3, [sp, #3]
 801917c:	005b      	lsls	r3, r3, #1
 801917e:	b2db      	uxtb	r3, r3
 8019180:	f88d 3003 	strb.w	r3, [sp, #3]
		while( ( ucMaxPriorityValue & portTOP_BIT_OF_BYTE ) == portTOP_BIT_OF_BYTE )
 8019184:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8019188:	061b      	lsls	r3, r3, #24
 801918a:	4611      	mov	r1, r2
 801918c:	f102 32ff 	add.w	r2, r2, #4294967295
 8019190:	d4f2      	bmi.n	8019178 <xPortStartScheduler+0x4c>
			configASSERT( ( portMAX_PRIGROUP_BITS - ulMaxPRIGROUPValue ) == configPRIO_BITS );
 8019192:	2903      	cmp	r1, #3
 8019194:	d01b      	beq.n	80191ce <xPortStartScheduler+0xa2>
 8019196:	6101      	str	r1, [r0, #16]
	__asm volatile
 8019198:	f04f 0350 	mov.w	r3, #80	; 0x50
 801919c:	f383 8811 	msr	BASEPRI, r3
 80191a0:	f3bf 8f6f 	isb	sy
 80191a4:	f3bf 8f4f 	dsb	sy
 80191a8:	e7fe      	b.n	80191a8 <xPortStartScheduler+0x7c>
 80191aa:	f04f 0350 	mov.w	r3, #80	; 0x50
 80191ae:	f383 8811 	msr	BASEPRI, r3
 80191b2:	f3bf 8f6f 	isb	sy
 80191b6:	f3bf 8f4f 	dsb	sy
	configASSERT( portCPUID != portCORTEX_M7_r0p0_ID );
 80191ba:	e7fe      	b.n	80191ba <xPortStartScheduler+0x8e>
 80191bc:	f04f 0350 	mov.w	r3, #80	; 0x50
 80191c0:	f383 8811 	msr	BASEPRI, r3
 80191c4:	f3bf 8f6f 	isb	sy
 80191c8:	f3bf 8f4f 	dsb	sy
	configASSERT( portCPUID != portCORTEX_M7_r0p1_ID );
 80191cc:	e7fe      	b.n	80191cc <xPortStartScheduler+0xa0>
		*pucFirstUserPriorityRegister = ulOriginalPriority;
 80191ce:	9b01      	ldr	r3, [sp, #4]
 80191d0:	4a16      	ldr	r2, [pc, #88]	; (801922c <xPortStartScheduler+0x100>)
	portNVIC_SYSPRI2_REG |= portNVIC_PENDSV_PRI;
 80191d2:	f04f 24e0 	mov.w	r4, #3758153728	; 0xe000e000
		*pucFirstUserPriorityRegister = ulOriginalPriority;
 80191d6:	b2db      	uxtb	r3, r3
 80191d8:	7013      	strb	r3, [r2, #0]
	portNVIC_SYSPRI2_REG |= portNVIC_PENDSV_PRI;
 80191da:	f8d4 3d20 	ldr.w	r3, [r4, #3360]	; 0xd20
 80191de:	f443 0370 	orr.w	r3, r3, #15728640	; 0xf00000
 80191e2:	f8c4 3d20 	str.w	r3, [r4, #3360]	; 0xd20
	portNVIC_SYSPRI2_REG |= portNVIC_SYSTICK_PRI;
 80191e6:	f8d4 3d20 	ldr.w	r3, [r4, #3360]	; 0xd20
		ulMaxPRIGROUPValue &= portPRIORITY_GROUP_MASK;
 80191ea:	f44f 7240 	mov.w	r2, #768	; 0x300
	portNVIC_SYSPRI2_REG |= portNVIC_SYSTICK_PRI;
 80191ee:	f043 4370 	orr.w	r3, r3, #4026531840	; 0xf0000000
		ulMaxPRIGROUPValue &= portPRIORITY_GROUP_MASK;
 80191f2:	6102      	str	r2, [r0, #16]
	portNVIC_SYSPRI2_REG |= portNVIC_SYSTICK_PRI;
 80191f4:	f8c4 3d20 	str.w	r3, [r4, #3360]	; 0xd20
	vPortSetupTimerInterrupt();
 80191f8:	f7ff ff72 	bl	80190e0 <vPortSetupTimerInterrupt>
	uxCriticalNesting = 0;
 80191fc:	4b0d      	ldr	r3, [pc, #52]	; (8019234 <xPortStartScheduler+0x108>)
 80191fe:	2500      	movs	r5, #0
 8019200:	601d      	str	r5, [r3, #0]
	vPortEnableVFP();
 8019202:	f7ff fe99 	bl	8018f38 <vPortEnableVFP>
	*( portFPCCR ) |= portASPEN_AND_LSPEN_BITS;
 8019206:	f8d4 3f34 	ldr.w	r3, [r4, #3892]	; 0xf34
 801920a:	f043 4340 	orr.w	r3, r3, #3221225472	; 0xc0000000
 801920e:	f8c4 3f34 	str.w	r3, [r4, #3892]	; 0xf34
	prvPortStartFirstTask();
 8019212:	f7ff fe7d 	bl	8018f10 <prvPortStartFirstTask>
	vTaskSwitchContext();
 8019216:	f001 f89d 	bl	801a354 <vTaskSwitchContext>
	prvTaskExitError();
 801921a:	f7ff fe97 	bl	8018f4c <prvTaskExitError>
}
 801921e:	4628      	mov	r0, r5
 8019220:	b003      	add	sp, #12
 8019222:	bd30      	pop	{r4, r5, pc}
 8019224:	410fc271 	.word	0x410fc271
 8019228:	410fc270 	.word	0x410fc270
 801922c:	e000e400 	.word	0xe000e400
 8019230:	20007f2c 	.word	0x20007f2c
 8019234:	20000148 	.word	0x20000148

08019238 <vPortValidateInterruptPriority>:
	{
	uint32_t ulCurrentInterrupt;
	uint8_t ucCurrentPriority;

		/* Obtain the number of the currently executing interrupt. */
		__asm volatile( "mrs %0, ipsr" : "=r"( ulCurrentInterrupt ) :: "memory" );
 8019238:	f3ef 8305 	mrs	r3, IPSR

		/* Is the interrupt number a user defined interrupt? */
		if( ulCurrentInterrupt >= portFIRST_USER_INTERRUPT_NUMBER )
 801923c:	2b0f      	cmp	r3, #15
 801923e:	d812      	bhi.n	8019266 <vPortValidateInterruptPriority+0x2e>
 8019240:	4a11      	ldr	r2, [pc, #68]	; (8019288 <vPortValidateInterruptPriority+0x50>)
		configuration then the correct setting can be achieved on all Cortex-M
		devices by calling NVIC_SetPriorityGrouping( 0 ); before starting the
		scheduler.  Note however that some vendor specific peripheral libraries
		assume a non-zero priority group setting, in which cases using a value
		of zero will result in unpredictable behaviour. */
		configASSERT( ( portAIRCR_REG & portPRIORITY_GROUP_MASK ) <= ulMaxPRIGROUPValue );
 8019242:	6912      	ldr	r2, [r2, #16]
 8019244:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
 8019248:	f8d3 3d0c 	ldr.w	r3, [r3, #3340]	; 0xd0c
 801924c:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
 8019250:	4293      	cmp	r3, r2
 8019252:	d917      	bls.n	8019284 <vPortValidateInterruptPriority+0x4c>
 8019254:	f04f 0350 	mov.w	r3, #80	; 0x50
 8019258:	f383 8811 	msr	BASEPRI, r3
 801925c:	f3bf 8f6f 	isb	sy
 8019260:	f3bf 8f4f 	dsb	sy
 8019264:	e7fe      	b.n	8019264 <vPortValidateInterruptPriority+0x2c>
			ucCurrentPriority = pcInterruptPriorityRegisters[ ulCurrentInterrupt ];
 8019266:	4909      	ldr	r1, [pc, #36]	; (801928c <vPortValidateInterruptPriority+0x54>)
			configASSERT( ucCurrentPriority >= ucMaxSysCallPriority );
 8019268:	4a07      	ldr	r2, [pc, #28]	; (8019288 <vPortValidateInterruptPriority+0x50>)
			ucCurrentPriority = pcInterruptPriorityRegisters[ ulCurrentInterrupt ];
 801926a:	5c5b      	ldrb	r3, [r3, r1]
			configASSERT( ucCurrentPriority >= ucMaxSysCallPriority );
 801926c:	7b11      	ldrb	r1, [r2, #12]
 801926e:	4299      	cmp	r1, r3
 8019270:	d9e7      	bls.n	8019242 <vPortValidateInterruptPriority+0xa>
 8019272:	f04f 0350 	mov.w	r3, #80	; 0x50
 8019276:	f383 8811 	msr	BASEPRI, r3
 801927a:	f3bf 8f6f 	isb	sy
 801927e:	f3bf 8f4f 	dsb	sy
 8019282:	e7fe      	b.n	8019282 <vPortValidateInterruptPriority+0x4a>
	}
 8019284:	4770      	bx	lr
 8019286:	bf00      	nop
 8019288:	20007f2c 	.word	0x20007f2c
 801928c:	e000e3f0 	.word	0xe000e3f0

08019290 <vListInitialise>:
void vListInitialise( List_t * const pxList )
{
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 8019290:	f100 0308 	add.w	r3, r0, #8

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
 8019294:	f04f 31ff 	mov.w	r1, #4294967295
	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
 8019298:	2200      	movs	r2, #0
	pxList->xListEnd.xItemValue = portMAX_DELAY;
 801929a:	e9c0 3101 	strd	r3, r1, [r0, #4]
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 801929e:	e9c0 3303 	strd	r3, r3, [r0, #12]
	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
 80192a2:	6002      	str	r2, [r0, #0]

	/* Write known values into the list if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList );
	listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList );
}
 80192a4:	4770      	bx	lr
 80192a6:	bf00      	nop

080192a8 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
 80192a8:	2300      	movs	r3, #0
 80192aa:	6103      	str	r3, [r0, #16]

	/* Write known values into the list item if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
 80192ac:	4770      	bx	lr
 80192ae:	bf00      	nop

080192b0 <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
ListItem_t * const pxIndex = pxList->pxIndex;
 80192b0:	6843      	ldr	r3, [r0, #4]

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
 80192b2:	689a      	ldr	r2, [r3, #8]
 80192b4:	608a      	str	r2, [r1, #8]
	pxIndex->pxPrevious = pxNewListItem;

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;

	( pxList->uxNumberOfItems )++;
 80192b6:	6802      	ldr	r2, [r0, #0]
{
 80192b8:	b410      	push	{r4}
	pxIndex->pxPrevious->pxNext = pxNewListItem;
 80192ba:	689c      	ldr	r4, [r3, #8]
	pxNewListItem->pxNext = pxIndex;
 80192bc:	604b      	str	r3, [r1, #4]
	( pxList->uxNumberOfItems )++;
 80192be:	3201      	adds	r2, #1
	pxIndex->pxPrevious->pxNext = pxNewListItem;
 80192c0:	6061      	str	r1, [r4, #4]
	pxIndex->pxPrevious = pxNewListItem;
 80192c2:	6099      	str	r1, [r3, #8]
}
 80192c4:	f85d 4b04 	ldr.w	r4, [sp], #4
	pxNewListItem->pvContainer = ( void * ) pxList;
 80192c8:	6108      	str	r0, [r1, #16]
	( pxList->uxNumberOfItems )++;
 80192ca:	6002      	str	r2, [r0, #0]
}
 80192cc:	4770      	bx	lr
 80192ce:	bf00      	nop

080192d0 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
 80192d0:	b430      	push	{r4, r5}
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
 80192d2:	680d      	ldr	r5, [r1, #0]
	new list item should be placed after it.  This ensures that TCB's which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
 80192d4:	1c6b      	adds	r3, r5, #1
 80192d6:	d010      	beq.n	80192fa <vListInsert+0x2a>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 80192d8:	f100 0308 	add.w	r3, r0, #8
 80192dc:	461c      	mov	r4, r3
 80192de:	685b      	ldr	r3, [r3, #4]
 80192e0:	681a      	ldr	r2, [r3, #0]
 80192e2:	42aa      	cmp	r2, r5
 80192e4:	d9fa      	bls.n	80192dc <vListInsert+0xc>

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;

	( pxList->uxNumberOfItems )++;
 80192e6:	6802      	ldr	r2, [r0, #0]
	pxNewListItem->pxNext = pxIterator->pxNext;
 80192e8:	604b      	str	r3, [r1, #4]
	( pxList->uxNumberOfItems )++;
 80192ea:	3201      	adds	r2, #1
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
 80192ec:	6099      	str	r1, [r3, #8]
	pxNewListItem->pxPrevious = pxIterator;
 80192ee:	608c      	str	r4, [r1, #8]
	pxIterator->pxNext = pxNewListItem;
 80192f0:	6061      	str	r1, [r4, #4]
	pxNewListItem->pvContainer = ( void * ) pxList;
 80192f2:	6108      	str	r0, [r1, #16]
}
 80192f4:	bc30      	pop	{r4, r5}
	( pxList->uxNumberOfItems )++;
 80192f6:	6002      	str	r2, [r0, #0]
}
 80192f8:	4770      	bx	lr
		pxIterator = pxList->xListEnd.pxPrevious;
 80192fa:	6904      	ldr	r4, [r0, #16]
	pxNewListItem->pxNext = pxIterator->pxNext;
 80192fc:	6863      	ldr	r3, [r4, #4]
 80192fe:	e7f2      	b.n	80192e6 <vListInsert+0x16>

08019300 <uxListRemove>:

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
 8019300:	6903      	ldr	r3, [r0, #16]
{
 8019302:	b410      	push	{r4}

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
 8019304:	e9d0 1201 	ldrd	r1, r2, [r0, #4]

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
 8019308:	685c      	ldr	r4, [r3, #4]
	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
 801930a:	608a      	str	r2, [r1, #8]
	if( pxList->pxIndex == pxItemToRemove )
 801930c:	4284      	cmp	r4, r0
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
 801930e:	6051      	str	r1, [r2, #4]
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
 8019310:	bf08      	it	eq
 8019312:	605a      	streq	r2, [r3, #4]
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
	( pxList->uxNumberOfItems )--;
 8019314:	681a      	ldr	r2, [r3, #0]

	return pxList->uxNumberOfItems;
}
 8019316:	f85d 4b04 	ldr.w	r4, [sp], #4
	pxItemToRemove->pvContainer = NULL;
 801931a:	2100      	movs	r1, #0
	( pxList->uxNumberOfItems )--;
 801931c:	3a01      	subs	r2, #1
	pxItemToRemove->pvContainer = NULL;
 801931e:	6101      	str	r1, [r0, #16]
	( pxList->uxNumberOfItems )--;
 8019320:	601a      	str	r2, [r3, #0]
	return pxList->uxNumberOfItems;
 8019322:	6818      	ldr	r0, [r3, #0]
}
 8019324:	4770      	bx	lr
 8019326:	bf00      	nop

08019328 <prvCopyDataToQueue>:

#endif /* configUSE_MUTEXES */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
 8019328:	b570      	push	{r4, r5, r6, lr}
 801932a:	4604      	mov	r4, r0

	/* This function is called from a critical section. */

	uxMessagesWaiting = pxQueue->uxMessagesWaiting;

	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
 801932c:	6c00      	ldr	r0, [r0, #64]	; 0x40
	uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 801932e:	6ba6      	ldr	r6, [r4, #56]	; 0x38
	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
 8019330:	b920      	cbnz	r0, 801933c <prvCopyDataToQueue+0x14>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 8019332:	6825      	ldr	r5, [r4, #0]
 8019334:	b34d      	cbz	r5, 801938a <prvCopyDataToQueue+0x62>
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
 8019336:	3601      	adds	r6, #1
 8019338:	63a6      	str	r6, [r4, #56]	; 0x38

	return xReturn;
}
 801933a:	bd70      	pop	{r4, r5, r6, pc}
	else if( xPosition == queueSEND_TO_BACK )
 801933c:	4615      	mov	r5, r2
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0. */
 801933e:	4602      	mov	r2, r0
	else if( xPosition == queueSEND_TO_BACK )
 8019340:	b97d      	cbnz	r5, 8019362 <prvCopyDataToQueue+0x3a>
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0. */
 8019342:	68a0      	ldr	r0, [r4, #8]
 8019344:	f00e f8f0 	bl	8027528 <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
 8019348:	68a3      	ldr	r3, [r4, #8]
 801934a:	6c22      	ldr	r2, [r4, #64]	; 0x40
 801934c:	4413      	add	r3, r2
		if( pxQueue->pcWriteTo >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
 801934e:	6862      	ldr	r2, [r4, #4]
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
 8019350:	60a3      	str	r3, [r4, #8]
		if( pxQueue->pcWriteTo >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
 8019352:	4293      	cmp	r3, r2
			pxQueue->pcWriteTo = pxQueue->pcHead;
 8019354:	bf24      	itt	cs
 8019356:	6823      	ldrcs	r3, [r4, #0]
 8019358:	60a3      	strcs	r3, [r4, #8]
	pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
 801935a:	3601      	adds	r6, #1
BaseType_t xReturn = pdFALSE;
 801935c:	4628      	mov	r0, r5
	pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
 801935e:	63a6      	str	r6, [r4, #56]	; 0x38
}
 8019360:	bd70      	pop	{r4, r5, r6, pc}
		( void ) memcpy( ( void * ) pxQueue->u.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8019362:	68e0      	ldr	r0, [r4, #12]
 8019364:	f00e f8e0 	bl	8027528 <memcpy>
		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
 8019368:	6c22      	ldr	r2, [r4, #64]	; 0x40
 801936a:	68e3      	ldr	r3, [r4, #12]
 801936c:	4251      	negs	r1, r2
 801936e:	1a9b      	subs	r3, r3, r2
		if( pxQueue->u.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
 8019370:	6822      	ldr	r2, [r4, #0]
		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
 8019372:	60e3      	str	r3, [r4, #12]
		if( pxQueue->u.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
 8019374:	4293      	cmp	r3, r2
 8019376:	d202      	bcs.n	801937e <prvCopyDataToQueue+0x56>
			pxQueue->u.pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
 8019378:	6863      	ldr	r3, [r4, #4]
 801937a:	440b      	add	r3, r1
 801937c:	60e3      	str	r3, [r4, #12]
		if( xPosition == queueOVERWRITE )
 801937e:	2d02      	cmp	r5, #2
 8019380:	d008      	beq.n	8019394 <prvCopyDataToQueue+0x6c>
	pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
 8019382:	3601      	adds	r6, #1
BaseType_t xReturn = pdFALSE;
 8019384:	2000      	movs	r0, #0
	pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
 8019386:	63a6      	str	r6, [r4, #56]	; 0x38
}
 8019388:	bd70      	pop	{r4, r5, r6, pc}
				xReturn = xTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
 801938a:	6860      	ldr	r0, [r4, #4]
 801938c:	f001 f92a 	bl	801a5e4 <xTaskPriorityDisinherit>
				pxQueue->pxMutexHolder = NULL;
 8019390:	6065      	str	r5, [r4, #4]
 8019392:	e7d0      	b.n	8019336 <prvCopyDataToQueue+0xe>
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
 8019394:	2e01      	cmp	r6, #1
 8019396:	bf38      	it	cc
 8019398:	2601      	movcc	r6, #1
BaseType_t xReturn = pdFALSE;
 801939a:	2000      	movs	r0, #0
 801939c:	e7cc      	b.n	8019338 <prvCopyDataToQueue+0x10>
 801939e:	bf00      	nop

080193a0 <prvUnlockQueue>:
	}
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( Queue_t * const pxQueue )
{
 80193a0:	b570      	push	{r4, r5, r6, lr}
 80193a2:	4605      	mov	r5, r0

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
 80193a4:	f7ff fe1e 	bl	8018fe4 <vPortEnterCritical>
	{
		int8_t cTxLock = pxQueue->cTxLock;
 80193a8:	f895 3045 	ldrb.w	r3, [r5, #69]	; 0x45
 80193ac:	b25c      	sxtb	r4, r3

		/* See if data was added to the queue while it was locked. */
		while( cTxLock > queueLOCKED_UNMODIFIED )
 80193ae:	2c00      	cmp	r4, #0
 80193b0:	dd14      	ble.n	80193dc <prvUnlockQueue+0x3c>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 80193b2:	f105 0624 	add.w	r6, r5, #36	; 0x24
 80193b6:	e003      	b.n	80193c0 <prvUnlockQueue+0x20>
					break;
				}
			}
			#endif /* configUSE_QUEUE_SETS */

			--cTxLock;
 80193b8:	1e63      	subs	r3, r4, #1
 80193ba:	b2da      	uxtb	r2, r3
 80193bc:	b25c      	sxtb	r4, r3
		while( cTxLock > queueLOCKED_UNMODIFIED )
 80193be:	b16a      	cbz	r2, 80193dc <prvUnlockQueue+0x3c>
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 80193c0:	6a6b      	ldr	r3, [r5, #36]	; 0x24
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 80193c2:	4630      	mov	r0, r6
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 80193c4:	b153      	cbz	r3, 80193dc <prvUnlockQueue+0x3c>
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 80193c6:	f001 f809 	bl	801a3dc <xTaskRemoveFromEventList>
 80193ca:	2800      	cmp	r0, #0
 80193cc:	d0f4      	beq.n	80193b8 <prvUnlockQueue+0x18>
						vTaskMissedYield();
 80193ce:	f001 f89f 	bl	801a510 <vTaskMissedYield>
			--cTxLock;
 80193d2:	1e63      	subs	r3, r4, #1
 80193d4:	b2da      	uxtb	r2, r3
 80193d6:	b25c      	sxtb	r4, r3
		while( cTxLock > queueLOCKED_UNMODIFIED )
 80193d8:	2a00      	cmp	r2, #0
 80193da:	d1f1      	bne.n	80193c0 <prvUnlockQueue+0x20>
		}

		pxQueue->cTxLock = queueUNLOCKED;
 80193dc:	23ff      	movs	r3, #255	; 0xff
 80193de:	f885 3045 	strb.w	r3, [r5, #69]	; 0x45
	}
	taskEXIT_CRITICAL();
 80193e2:	f7ff fe21 	bl	8019028 <vPortExitCritical>

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
 80193e6:	f7ff fdfd 	bl	8018fe4 <vPortEnterCritical>
	{
		int8_t cRxLock = pxQueue->cRxLock;
 80193ea:	f895 3044 	ldrb.w	r3, [r5, #68]	; 0x44
 80193ee:	b25c      	sxtb	r4, r3

		while( cRxLock > queueLOCKED_UNMODIFIED )
 80193f0:	2c00      	cmp	r4, #0
 80193f2:	dd14      	ble.n	801941e <prvUnlockQueue+0x7e>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 80193f4:	f105 0610 	add.w	r6, r5, #16
 80193f8:	e003      	b.n	8019402 <prvUnlockQueue+0x62>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				--cRxLock;
 80193fa:	1e63      	subs	r3, r4, #1
 80193fc:	b2da      	uxtb	r2, r3
 80193fe:	b25c      	sxtb	r4, r3
		while( cRxLock > queueLOCKED_UNMODIFIED )
 8019400:	b16a      	cbz	r2, 801941e <prvUnlockQueue+0x7e>
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 8019402:	692b      	ldr	r3, [r5, #16]
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 8019404:	4630      	mov	r0, r6
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 8019406:	b153      	cbz	r3, 801941e <prvUnlockQueue+0x7e>
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 8019408:	f000 ffe8 	bl	801a3dc <xTaskRemoveFromEventList>
 801940c:	2800      	cmp	r0, #0
 801940e:	d0f4      	beq.n	80193fa <prvUnlockQueue+0x5a>
					vTaskMissedYield();
 8019410:	f001 f87e 	bl	801a510 <vTaskMissedYield>
				--cRxLock;
 8019414:	1e63      	subs	r3, r4, #1
 8019416:	b2da      	uxtb	r2, r3
 8019418:	b25c      	sxtb	r4, r3
		while( cRxLock > queueLOCKED_UNMODIFIED )
 801941a:	2a00      	cmp	r2, #0
 801941c:	d1f1      	bne.n	8019402 <prvUnlockQueue+0x62>
			{
				break;
			}
		}

		pxQueue->cRxLock = queueUNLOCKED;
 801941e:	23ff      	movs	r3, #255	; 0xff
 8019420:	f885 3044 	strb.w	r3, [r5, #68]	; 0x44
	}
	taskEXIT_CRITICAL();
}
 8019424:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	taskEXIT_CRITICAL();
 8019428:	f7ff bdfe 	b.w	8019028 <vPortExitCritical>

0801942c <xQueueGenericReset>:
{
 801942c:	b538      	push	{r3, r4, r5, lr}
	configASSERT( pxQueue );
 801942e:	b1e0      	cbz	r0, 801946a <xQueueGenericReset+0x3e>
 8019430:	4604      	mov	r4, r0
 8019432:	460d      	mov	r5, r1
	taskENTER_CRITICAL();
 8019434:	f7ff fdd6 	bl	8018fe4 <vPortEnterCritical>
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
 8019438:	e9d4 230f 	ldrd	r2, r3, [r4, #60]	; 0x3c
 801943c:	6821      	ldr	r1, [r4, #0]
 801943e:	fb03 f202 	mul.w	r2, r3, r2
		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( UBaseType_t ) 1U ) * pxQueue->uxItemSize );
 8019442:	1ad3      	subs	r3, r2, r3
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
 8019444:	440a      	add	r2, r1
 8019446:	6062      	str	r2, [r4, #4]
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
 8019448:	2200      	movs	r2, #0
 801944a:	63a2      	str	r2, [r4, #56]	; 0x38
		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( UBaseType_t ) 1U ) * pxQueue->uxItemSize );
 801944c:	440b      	add	r3, r1
		pxQueue->cRxLock = queueUNLOCKED;
 801944e:	22ff      	movs	r2, #255	; 0xff
 8019450:	f884 2044 	strb.w	r2, [r4, #68]	; 0x44
		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( UBaseType_t ) 1U ) * pxQueue->uxItemSize );
 8019454:	e9c4 1302 	strd	r1, r3, [r4, #8]
		pxQueue->cTxLock = queueUNLOCKED;
 8019458:	f884 2045 	strb.w	r2, [r4, #69]	; 0x45
		if( xNewQueue == pdFALSE )
 801945c:	b975      	cbnz	r5, 801947c <xQueueGenericReset+0x50>
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 801945e:	6923      	ldr	r3, [r4, #16]
 8019460:	b9c3      	cbnz	r3, 8019494 <xQueueGenericReset+0x68>
	taskEXIT_CRITICAL();
 8019462:	f7ff fde1 	bl	8019028 <vPortExitCritical>
}
 8019466:	2001      	movs	r0, #1
 8019468:	bd38      	pop	{r3, r4, r5, pc}
 801946a:	f04f 0350 	mov.w	r3, #80	; 0x50
 801946e:	f383 8811 	msr	BASEPRI, r3
 8019472:	f3bf 8f6f 	isb	sy
 8019476:	f3bf 8f4f 	dsb	sy
	configASSERT( pxQueue );
 801947a:	e7fe      	b.n	801947a <xQueueGenericReset+0x4e>
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
 801947c:	f104 0010 	add.w	r0, r4, #16
 8019480:	f7ff ff06 	bl	8019290 <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
 8019484:	f104 0024 	add.w	r0, r4, #36	; 0x24
 8019488:	f7ff ff02 	bl	8019290 <vListInitialise>
	taskEXIT_CRITICAL();
 801948c:	f7ff fdcc 	bl	8019028 <vPortExitCritical>
}
 8019490:	2001      	movs	r0, #1
 8019492:	bd38      	pop	{r3, r4, r5, pc}
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 8019494:	f104 0010 	add.w	r0, r4, #16
 8019498:	f000 ffa0 	bl	801a3dc <xTaskRemoveFromEventList>
 801949c:	2800      	cmp	r0, #0
 801949e:	d0e0      	beq.n	8019462 <xQueueGenericReset+0x36>
					queueYIELD_IF_USING_PREEMPTION();
 80194a0:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
 80194a4:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 80194a8:	f8c3 2d04 	str.w	r2, [r3, #3332]	; 0xd04
 80194ac:	f3bf 8f4f 	dsb	sy
 80194b0:	f3bf 8f6f 	isb	sy
 80194b4:	e7d5      	b.n	8019462 <xQueueGenericReset+0x36>
 80194b6:	bf00      	nop

080194b8 <xQueueGenericCreate>:
		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );
 80194b8:	b940      	cbnz	r0, 80194cc <xQueueGenericCreate+0x14>
 80194ba:	f04f 0350 	mov.w	r3, #80	; 0x50
 80194be:	f383 8811 	msr	BASEPRI, r3
 80194c2:	f3bf 8f6f 	isb	sy
 80194c6:	f3bf 8f4f 	dsb	sy
 80194ca:	e7fe      	b.n	80194ca <xQueueGenericCreate+0x12>
	{
 80194cc:	b570      	push	{r4, r5, r6, lr}
 80194ce:	460e      	mov	r6, r1
 80194d0:	4604      	mov	r4, r0
		if( uxItemSize == ( UBaseType_t ) 0 )
 80194d2:	b969      	cbnz	r1, 80194f0 <xQueueGenericCreate+0x38>
		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes );
 80194d4:	2048      	movs	r0, #72	; 0x48
 80194d6:	f7ff fc67 	bl	8018da8 <pvPortMalloc>
		if( pxNewQueue != NULL )
 80194da:	4605      	mov	r5, r0
 80194dc:	b198      	cbz	r0, 8019506 <xQueueGenericCreate+0x4e>
		pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
 80194de:	602d      	str	r5, [r5, #0]
	pxNewQueue->uxItemSize = uxItemSize;
 80194e0:	e9c5 460f 	strd	r4, r6, [r5, #60]	; 0x3c
	( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
 80194e4:	2101      	movs	r1, #1
 80194e6:	4628      	mov	r0, r5
 80194e8:	f7ff ffa0 	bl	801942c <xQueueGenericReset>
	}
 80194ec:	4628      	mov	r0, r5
 80194ee:	bd70      	pop	{r4, r5, r6, pc}
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 80194f0:	fb01 f000 	mul.w	r0, r1, r0
		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes );
 80194f4:	3048      	adds	r0, #72	; 0x48
 80194f6:	f7ff fc57 	bl	8018da8 <pvPortMalloc>
		if( pxNewQueue != NULL )
 80194fa:	4605      	mov	r5, r0
 80194fc:	b118      	cbz	r0, 8019506 <xQueueGenericCreate+0x4e>
			pucQueueStorage = ( ( uint8_t * ) pxNewQueue ) + sizeof( Queue_t );
 80194fe:	f100 0348 	add.w	r3, r0, #72	; 0x48
		pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
 8019502:	6003      	str	r3, [r0, #0]
 8019504:	e7ec      	b.n	80194e0 <xQueueGenericCreate+0x28>
		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes );
 8019506:	2500      	movs	r5, #0
	}
 8019508:	4628      	mov	r0, r5
 801950a:	bd70      	pop	{r4, r5, r6, pc}

0801950c <xQueueCreateCountingSemaphore>:
		configASSERT( uxMaxCount != 0 );
 801950c:	b940      	cbnz	r0, 8019520 <xQueueCreateCountingSemaphore+0x14>
 801950e:	f04f 0350 	mov.w	r3, #80	; 0x50
 8019512:	f383 8811 	msr	BASEPRI, r3
 8019516:	f3bf 8f6f 	isb	sy
 801951a:	f3bf 8f4f 	dsb	sy
 801951e:	e7fe      	b.n	801951e <xQueueCreateCountingSemaphore+0x12>
		configASSERT( uxInitialCount <= uxMaxCount );
 8019520:	4288      	cmp	r0, r1
	{
 8019522:	b570      	push	{r4, r5, r6, lr}
 8019524:	460d      	mov	r5, r1
 8019526:	4604      	mov	r4, r0
		configASSERT( uxInitialCount <= uxMaxCount );
 8019528:	d208      	bcs.n	801953c <xQueueCreateCountingSemaphore+0x30>
 801952a:	f04f 0350 	mov.w	r3, #80	; 0x50
 801952e:	f383 8811 	msr	BASEPRI, r3
 8019532:	f3bf 8f6f 	isb	sy
 8019536:	f3bf 8f4f 	dsb	sy
 801953a:	e7fe      	b.n	801953a <xQueueCreateCountingSemaphore+0x2e>
		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes );
 801953c:	2048      	movs	r0, #72	; 0x48
 801953e:	f7ff fc33 	bl	8018da8 <pvPortMalloc>
		if( pxNewQueue != NULL )
 8019542:	4606      	mov	r6, r0
 8019544:	b138      	cbz	r0, 8019556 <xQueueCreateCountingSemaphore+0x4a>
	pxNewQueue->uxItemSize = uxItemSize;
 8019546:	2300      	movs	r3, #0
 8019548:	e9c0 430f 	strd	r4, r3, [r0, #60]	; 0x3c
		pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
 801954c:	6000      	str	r0, [r0, #0]
	( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
 801954e:	2101      	movs	r1, #1
 8019550:	f7ff ff6c 	bl	801942c <xQueueGenericReset>
			( ( Queue_t * ) xHandle )->uxMessagesWaiting = uxInitialCount;
 8019554:	63b5      	str	r5, [r6, #56]	; 0x38
	}
 8019556:	4630      	mov	r0, r6
 8019558:	bd70      	pop	{r4, r5, r6, pc}
 801955a:	bf00      	nop

0801955c <xQueueGenericSend>:
{
 801955c:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 8019560:	b085      	sub	sp, #20
 8019562:	9201      	str	r2, [sp, #4]
	configASSERT( pxQueue );
 8019564:	2800      	cmp	r0, #0
 8019566:	d075      	beq.n	8019654 <xQueueGenericSend+0xf8>
	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 8019568:	4688      	mov	r8, r1
 801956a:	461e      	mov	r6, r3
 801956c:	4604      	mov	r4, r0
 801956e:	2900      	cmp	r1, #0
 8019570:	d064      	beq.n	801963c <xQueueGenericSend+0xe0>
	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
 8019572:	2e02      	cmp	r6, #2
 8019574:	d10b      	bne.n	801958e <xQueueGenericSend+0x32>
 8019576:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 8019578:	2b01      	cmp	r3, #1
 801957a:	d008      	beq.n	801958e <xQueueGenericSend+0x32>
 801957c:	f04f 0350 	mov.w	r3, #80	; 0x50
 8019580:	f383 8811 	msr	BASEPRI, r3
 8019584:	f3bf 8f6f 	isb	sy
 8019588:	f3bf 8f4f 	dsb	sy
 801958c:	e7fe      	b.n	801958c <xQueueGenericSend+0x30>
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
 801958e:	f000 ffc5 	bl	801a51c <xTaskGetSchedulerState>
 8019592:	4605      	mov	r5, r0
 8019594:	2800      	cmp	r0, #0
 8019596:	d066      	beq.n	8019666 <xQueueGenericSend+0x10a>
 8019598:	2500      	movs	r5, #0
		prvLockQueue( pxQueue );
 801959a:	f04f 0900 	mov.w	r9, #0
 801959e:	e007      	b.n	80195b0 <xQueueGenericSend+0x54>
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
 80195a0:	f7ff fd42 	bl	8019028 <vPortExitCritical>
				prvUnlockQueue( pxQueue );
 80195a4:	4620      	mov	r0, r4
 80195a6:	f7ff fefb 	bl	80193a0 <prvUnlockQueue>
				( void ) xTaskResumeAll();
 80195aa:	f000 fe11 	bl	801a1d0 <xTaskResumeAll>
 80195ae:	2501      	movs	r5, #1
		taskENTER_CRITICAL();
 80195b0:	f7ff fd18 	bl	8018fe4 <vPortEnterCritical>
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
 80195b4:	6ba2      	ldr	r2, [r4, #56]	; 0x38
 80195b6:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 80195b8:	429a      	cmp	r2, r3
 80195ba:	d364      	bcc.n	8019686 <xQueueGenericSend+0x12a>
 80195bc:	2e02      	cmp	r6, #2
 80195be:	d062      	beq.n	8019686 <xQueueGenericSend+0x12a>
				if( xTicksToWait == ( TickType_t ) 0 )
 80195c0:	9f01      	ldr	r7, [sp, #4]
 80195c2:	2f00      	cmp	r7, #0
 80195c4:	d077      	beq.n	80196b6 <xQueueGenericSend+0x15a>
				else if( xEntryTimeSet == pdFALSE )
 80195c6:	2d00      	cmp	r5, #0
 80195c8:	d059      	beq.n	801967e <xQueueGenericSend+0x122>
		taskEXIT_CRITICAL();
 80195ca:	f7ff fd2d 	bl	8019028 <vPortExitCritical>
		vTaskSuspendAll();
 80195ce:	f000 fcff 	bl	8019fd0 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
 80195d2:	f7ff fd07 	bl	8018fe4 <vPortEnterCritical>
 80195d6:	f894 3044 	ldrb.w	r3, [r4, #68]	; 0x44
 80195da:	2bff      	cmp	r3, #255	; 0xff
 80195dc:	bf08      	it	eq
 80195de:	f884 9044 	strbeq.w	r9, [r4, #68]	; 0x44
 80195e2:	f894 3045 	ldrb.w	r3, [r4, #69]	; 0x45
 80195e6:	2bff      	cmp	r3, #255	; 0xff
 80195e8:	bf08      	it	eq
 80195ea:	f884 9045 	strbeq.w	r9, [r4, #69]	; 0x45
 80195ee:	f7ff fd1b 	bl	8019028 <vPortExitCritical>
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 80195f2:	a901      	add	r1, sp, #4
 80195f4:	a802      	add	r0, sp, #8
 80195f6:	f000 ff47 	bl	801a488 <xTaskCheckForTimeOut>
 80195fa:	2800      	cmp	r0, #0
 80195fc:	d15f      	bne.n	80196be <xQueueGenericSend+0x162>
	taskENTER_CRITICAL();
 80195fe:	f7ff fcf1 	bl	8018fe4 <vPortEnterCritical>
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
 8019602:	6ba2      	ldr	r2, [r4, #56]	; 0x38
 8019604:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 8019606:	429a      	cmp	r2, r3
 8019608:	d1ca      	bne.n	80195a0 <xQueueGenericSend+0x44>
	taskEXIT_CRITICAL();
 801960a:	f7ff fd0d 	bl	8019028 <vPortExitCritical>
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
 801960e:	9901      	ldr	r1, [sp, #4]
 8019610:	f104 0010 	add.w	r0, r4, #16
 8019614:	f000 feaa 	bl	801a36c <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
 8019618:	4620      	mov	r0, r4
 801961a:	f7ff fec1 	bl	80193a0 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
 801961e:	f000 fdd7 	bl	801a1d0 <xTaskResumeAll>
 8019622:	2800      	cmp	r0, #0
 8019624:	d1c3      	bne.n	80195ae <xQueueGenericSend+0x52>
					portYIELD_WITHIN_API();
 8019626:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
 801962a:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 801962e:	f8c3 2d04 	str.w	r2, [r3, #3332]	; 0xd04
 8019632:	f3bf 8f4f 	dsb	sy
 8019636:	f3bf 8f6f 	isb	sy
 801963a:	e7b8      	b.n	80195ae <xQueueGenericSend+0x52>
	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 801963c:	6c03      	ldr	r3, [r0, #64]	; 0x40
 801963e:	2b00      	cmp	r3, #0
 8019640:	d097      	beq.n	8019572 <xQueueGenericSend+0x16>
 8019642:	f04f 0350 	mov.w	r3, #80	; 0x50
 8019646:	f383 8811 	msr	BASEPRI, r3
 801964a:	f3bf 8f6f 	isb	sy
 801964e:	f3bf 8f4f 	dsb	sy
 8019652:	e7fe      	b.n	8019652 <xQueueGenericSend+0xf6>
 8019654:	f04f 0350 	mov.w	r3, #80	; 0x50
 8019658:	f383 8811 	msr	BASEPRI, r3
 801965c:	f3bf 8f6f 	isb	sy
 8019660:	f3bf 8f4f 	dsb	sy
	configASSERT( pxQueue );
 8019664:	e7fe      	b.n	8019664 <xQueueGenericSend+0x108>
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
 8019666:	9b01      	ldr	r3, [sp, #4]
 8019668:	2b00      	cmp	r3, #0
 801966a:	d096      	beq.n	801959a <xQueueGenericSend+0x3e>
 801966c:	f04f 0350 	mov.w	r3, #80	; 0x50
 8019670:	f383 8811 	msr	BASEPRI, r3
 8019674:	f3bf 8f6f 	isb	sy
 8019678:	f3bf 8f4f 	dsb	sy
 801967c:	e7fe      	b.n	801967c <xQueueGenericSend+0x120>
					vTaskInternalSetTimeOutState( &xTimeOut );
 801967e:	a802      	add	r0, sp, #8
 8019680:	f000 fef8 	bl	801a474 <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
 8019684:	e7a1      	b.n	80195ca <xQueueGenericSend+0x6e>
				xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 8019686:	4632      	mov	r2, r6
 8019688:	4641      	mov	r1, r8
 801968a:	4620      	mov	r0, r4
 801968c:	f7ff fe4c 	bl	8019328 <prvCopyDataToQueue>
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 8019690:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8019692:	b9db      	cbnz	r3, 80196cc <xQueueGenericSend+0x170>
					else if( xYieldRequired != pdFALSE )
 8019694:	b148      	cbz	r0, 80196aa <xQueueGenericSend+0x14e>
						queueYIELD_IF_USING_PREEMPTION();
 8019696:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
 801969a:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 801969e:	f8c3 2d04 	str.w	r2, [r3, #3332]	; 0xd04
 80196a2:	f3bf 8f4f 	dsb	sy
 80196a6:	f3bf 8f6f 	isb	sy
				taskEXIT_CRITICAL();
 80196aa:	f7ff fcbd 	bl	8019028 <vPortExitCritical>
				return pdPASS;
 80196ae:	2001      	movs	r0, #1
}
 80196b0:	b005      	add	sp, #20
 80196b2:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
					taskEXIT_CRITICAL();
 80196b6:	f7ff fcb7 	bl	8019028 <vPortExitCritical>
					return errQUEUE_FULL;
 80196ba:	4638      	mov	r0, r7
 80196bc:	e7f8      	b.n	80196b0 <xQueueGenericSend+0x154>
			prvUnlockQueue( pxQueue );
 80196be:	4620      	mov	r0, r4
 80196c0:	f7ff fe6e 	bl	80193a0 <prvUnlockQueue>
			( void ) xTaskResumeAll();
 80196c4:	f000 fd84 	bl	801a1d0 <xTaskResumeAll>
			return errQUEUE_FULL;
 80196c8:	2000      	movs	r0, #0
 80196ca:	e7f1      	b.n	80196b0 <xQueueGenericSend+0x154>
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 80196cc:	f104 0024 	add.w	r0, r4, #36	; 0x24
 80196d0:	f000 fe84 	bl	801a3dc <xTaskRemoveFromEventList>
 80196d4:	2800      	cmp	r0, #0
 80196d6:	d0e8      	beq.n	80196aa <xQueueGenericSend+0x14e>
 80196d8:	e7dd      	b.n	8019696 <xQueueGenericSend+0x13a>
 80196da:	bf00      	nop

080196dc <xQueueGenericSendFromISR>:
	configASSERT( pxQueue );
 80196dc:	2800      	cmp	r0, #0
 80196de:	d04a      	beq.n	8019776 <xQueueGenericSendFromISR+0x9a>
{
 80196e0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80196e4:	460e      	mov	r6, r1
 80196e6:	4617      	mov	r7, r2
 80196e8:	461d      	mov	r5, r3
 80196ea:	4604      	mov	r4, r0
	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 80196ec:	b321      	cbz	r1, 8019738 <xQueueGenericSendFromISR+0x5c>
	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
 80196ee:	2d02      	cmp	r5, #2
 80196f0:	d10b      	bne.n	801970a <xQueueGenericSendFromISR+0x2e>
 80196f2:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 80196f4:	2b01      	cmp	r3, #1
 80196f6:	d008      	beq.n	801970a <xQueueGenericSendFromISR+0x2e>
 80196f8:	f04f 0350 	mov.w	r3, #80	; 0x50
 80196fc:	f383 8811 	msr	BASEPRI, r3
 8019700:	f3bf 8f6f 	isb	sy
 8019704:	f3bf 8f4f 	dsb	sy
 8019708:	e7fe      	b.n	8019708 <xQueueGenericSendFromISR+0x2c>
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
 801970a:	f7ff fd95 	bl	8019238 <vPortValidateInterruptPriority>
	__asm volatile
 801970e:	f3ef 8811 	mrs	r8, BASEPRI
 8019712:	f04f 0350 	mov.w	r3, #80	; 0x50
 8019716:	f383 8811 	msr	BASEPRI, r3
 801971a:	f3bf 8f6f 	isb	sy
 801971e:	f3bf 8f4f 	dsb	sy
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
 8019722:	6ba2      	ldr	r2, [r4, #56]	; 0x38
 8019724:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 8019726:	429a      	cmp	r2, r3
 8019728:	d312      	bcc.n	8019750 <xQueueGenericSendFromISR+0x74>
 801972a:	2d02      	cmp	r5, #2
 801972c:	d010      	beq.n	8019750 <xQueueGenericSendFromISR+0x74>
			xReturn = errQUEUE_FULL;
 801972e:	2000      	movs	r0, #0
	__asm volatile
 8019730:	f388 8811 	msr	BASEPRI, r8
}
 8019734:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 8019738:	6c03      	ldr	r3, [r0, #64]	; 0x40
 801973a:	2b00      	cmp	r3, #0
 801973c:	d0d7      	beq.n	80196ee <xQueueGenericSendFromISR+0x12>
	__asm volatile
 801973e:	f04f 0350 	mov.w	r3, #80	; 0x50
 8019742:	f383 8811 	msr	BASEPRI, r3
 8019746:	f3bf 8f6f 	isb	sy
 801974a:	f3bf 8f4f 	dsb	sy
 801974e:	e7fe      	b.n	801974e <xQueueGenericSendFromISR+0x72>
			( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 8019750:	462a      	mov	r2, r5
			const int8_t cTxLock = pxQueue->cTxLock;
 8019752:	f894 5045 	ldrb.w	r5, [r4, #69]	; 0x45
			( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 8019756:	4631      	mov	r1, r6
			const int8_t cTxLock = pxQueue->cTxLock;
 8019758:	b26d      	sxtb	r5, r5
			( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 801975a:	4620      	mov	r0, r4
 801975c:	f7ff fde4 	bl	8019328 <prvCopyDataToQueue>
			if( cTxLock == queueUNLOCKED )
 8019760:	1c6b      	adds	r3, r5, #1
 8019762:	d011      	beq.n	8019788 <xQueueGenericSendFromISR+0xac>
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
 8019764:	1c6b      	adds	r3, r5, #1
 8019766:	b25b      	sxtb	r3, r3
 8019768:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
			xReturn = pdPASS;
 801976c:	2001      	movs	r0, #1
	__asm volatile
 801976e:	f388 8811 	msr	BASEPRI, r8
}
 8019772:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	__asm volatile
 8019776:	f04f 0350 	mov.w	r3, #80	; 0x50
 801977a:	f383 8811 	msr	BASEPRI, r3
 801977e:	f3bf 8f6f 	isb	sy
 8019782:	f3bf 8f4f 	dsb	sy
	configASSERT( pxQueue );
 8019786:	e7fe      	b.n	8019786 <xQueueGenericSendFromISR+0xaa>
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 8019788:	6a63      	ldr	r3, [r4, #36]	; 0x24
 801978a:	2b00      	cmp	r3, #0
 801978c:	d0ee      	beq.n	801976c <xQueueGenericSendFromISR+0x90>
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 801978e:	f104 0024 	add.w	r0, r4, #36	; 0x24
 8019792:	f000 fe23 	bl	801a3dc <xTaskRemoveFromEventList>
 8019796:	2800      	cmp	r0, #0
 8019798:	d0e8      	beq.n	801976c <xQueueGenericSendFromISR+0x90>
							if( pxHigherPriorityTaskWoken != NULL )
 801979a:	2f00      	cmp	r7, #0
 801979c:	d0e6      	beq.n	801976c <xQueueGenericSendFromISR+0x90>
								*pxHigherPriorityTaskWoken = pdTRUE;
 801979e:	2001      	movs	r0, #1
 80197a0:	6038      	str	r0, [r7, #0]
 80197a2:	e7c5      	b.n	8019730 <xQueueGenericSendFromISR+0x54>

080197a4 <xQueueGiveFromISR>:
	configASSERT( pxQueue );
 80197a4:	b370      	cbz	r0, 8019804 <xQueueGiveFromISR+0x60>
	configASSERT( pxQueue->uxItemSize == 0 );
 80197a6:	6c03      	ldr	r3, [r0, #64]	; 0x40
{
 80197a8:	b570      	push	{r4, r5, r6, lr}
 80197aa:	4606      	mov	r6, r0
	configASSERT( pxQueue->uxItemSize == 0 );
 80197ac:	b143      	cbz	r3, 80197c0 <xQueueGiveFromISR+0x1c>
 80197ae:	f04f 0350 	mov.w	r3, #80	; 0x50
 80197b2:	f383 8811 	msr	BASEPRI, r3
 80197b6:	f3bf 8f6f 	isb	sy
 80197ba:	f3bf 8f4f 	dsb	sy
 80197be:	e7fe      	b.n	80197be <xQueueGiveFromISR+0x1a>
	configASSERT( !( ( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX ) && ( pxQueue->pxMutexHolder != NULL ) ) );
 80197c0:	6803      	ldr	r3, [r0, #0]
 80197c2:	460c      	mov	r4, r1
 80197c4:	b33b      	cbz	r3, 8019816 <xQueueGiveFromISR+0x72>
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
 80197c6:	f7ff fd37 	bl	8019238 <vPortValidateInterruptPriority>
	__asm volatile
 80197ca:	f3ef 8511 	mrs	r5, BASEPRI
 80197ce:	f04f 0350 	mov.w	r3, #80	; 0x50
 80197d2:	f383 8811 	msr	BASEPRI, r3
 80197d6:	f3bf 8f6f 	isb	sy
 80197da:	f3bf 8f4f 	dsb	sy
		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 80197de:	6bb3      	ldr	r3, [r6, #56]	; 0x38
		if( uxMessagesWaiting < pxQueue->uxLength )
 80197e0:	6bf2      	ldr	r2, [r6, #60]	; 0x3c
 80197e2:	429a      	cmp	r2, r3
 80197e4:	d923      	bls.n	801982e <xQueueGiveFromISR+0x8a>
			const int8_t cTxLock = pxQueue->cTxLock;
 80197e6:	f896 2045 	ldrb.w	r2, [r6, #69]	; 0x45
			pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
 80197ea:	3301      	adds	r3, #1
			if( cTxLock == queueUNLOCKED )
 80197ec:	2aff      	cmp	r2, #255	; 0xff
			pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
 80197ee:	63b3      	str	r3, [r6, #56]	; 0x38
			const int8_t cTxLock = pxQueue->cTxLock;
 80197f0:	b253      	sxtb	r3, r2
			if( cTxLock == queueUNLOCKED )
 80197f2:	d020      	beq.n	8019836 <xQueueGiveFromISR+0x92>
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
 80197f4:	3301      	adds	r3, #1
 80197f6:	b25b      	sxtb	r3, r3
 80197f8:	f886 3045 	strb.w	r3, [r6, #69]	; 0x45
			xReturn = pdPASS;
 80197fc:	2001      	movs	r0, #1
	__asm volatile
 80197fe:	f385 8811 	msr	BASEPRI, r5
}
 8019802:	bd70      	pop	{r4, r5, r6, pc}
	__asm volatile
 8019804:	f04f 0350 	mov.w	r3, #80	; 0x50
 8019808:	f383 8811 	msr	BASEPRI, r3
 801980c:	f3bf 8f6f 	isb	sy
 8019810:	f3bf 8f4f 	dsb	sy
	configASSERT( pxQueue );
 8019814:	e7fe      	b.n	8019814 <xQueueGiveFromISR+0x70>
	configASSERT( !( ( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX ) && ( pxQueue->pxMutexHolder != NULL ) ) );
 8019816:	6843      	ldr	r3, [r0, #4]
 8019818:	2b00      	cmp	r3, #0
 801981a:	d0d4      	beq.n	80197c6 <xQueueGiveFromISR+0x22>
 801981c:	f04f 0350 	mov.w	r3, #80	; 0x50
 8019820:	f383 8811 	msr	BASEPRI, r3
 8019824:	f3bf 8f6f 	isb	sy
 8019828:	f3bf 8f4f 	dsb	sy
 801982c:	e7fe      	b.n	801982c <xQueueGiveFromISR+0x88>
			xReturn = errQUEUE_FULL;
 801982e:	2000      	movs	r0, #0
	__asm volatile
 8019830:	f385 8811 	msr	BASEPRI, r5
}
 8019834:	bd70      	pop	{r4, r5, r6, pc}
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 8019836:	6a73      	ldr	r3, [r6, #36]	; 0x24
 8019838:	2b00      	cmp	r3, #0
 801983a:	d0df      	beq.n	80197fc <xQueueGiveFromISR+0x58>
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 801983c:	f106 0024 	add.w	r0, r6, #36	; 0x24
 8019840:	f000 fdcc 	bl	801a3dc <xTaskRemoveFromEventList>
 8019844:	2800      	cmp	r0, #0
 8019846:	d0d9      	beq.n	80197fc <xQueueGiveFromISR+0x58>
							if( pxHigherPriorityTaskWoken != NULL )
 8019848:	2c00      	cmp	r4, #0
 801984a:	d0d7      	beq.n	80197fc <xQueueGiveFromISR+0x58>
								*pxHigherPriorityTaskWoken = pdTRUE;
 801984c:	2001      	movs	r0, #1
 801984e:	6020      	str	r0, [r4, #0]
 8019850:	e7ee      	b.n	8019830 <xQueueGiveFromISR+0x8c>
 8019852:	bf00      	nop

08019854 <xQueueReceive>:
{
 8019854:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 8019858:	b085      	sub	sp, #20
 801985a:	9201      	str	r2, [sp, #4]
	configASSERT( ( pxQueue ) );
 801985c:	2800      	cmp	r0, #0
 801985e:	f000 80a0 	beq.w	80199a2 <xQueueReceive+0x14e>
	configASSERT( !( ( ( pvBuffer ) == NULL ) && ( ( pxQueue )->uxItemSize != ( UBaseType_t ) 0U ) ) );
 8019862:	460d      	mov	r5, r1
 8019864:	4604      	mov	r4, r0
 8019866:	2900      	cmp	r1, #0
 8019868:	d047      	beq.n	80198fa <xQueueReceive+0xa6>
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
 801986a:	f000 fe57 	bl	801a51c <xTaskGetSchedulerState>
 801986e:	2800      	cmp	r0, #0
 8019870:	d04f      	beq.n	8019912 <xQueueReceive+0xbe>
		taskENTER_CRITICAL();
 8019872:	f7ff fbb7 	bl	8018fe4 <vPortEnterCritical>
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 8019876:	6ba6      	ldr	r6, [r4, #56]	; 0x38
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
 8019878:	2e00      	cmp	r6, #0
 801987a:	d167      	bne.n	801994c <xQueueReceive+0xf8>
				if( xTicksToWait == ( TickType_t ) 0 )
 801987c:	9b01      	ldr	r3, [sp, #4]
 801987e:	2b00      	cmp	r3, #0
 8019880:	d035      	beq.n	80198ee <xQueueReceive+0x9a>
					vTaskInternalSetTimeOutState( &xTimeOut );
 8019882:	a802      	add	r0, sp, #8
 8019884:	f000 fdf6 	bl	801a474 <vTaskInternalSetTimeOutState>
		prvLockQueue( pxQueue );
 8019888:	4637      	mov	r7, r6
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
 801988a:	f104 0824 	add.w	r8, r4, #36	; 0x24
					portYIELD_WITHIN_API();
 801988e:	f04f 29e0 	mov.w	r9, #3758153728	; 0xe000e000
		taskEXIT_CRITICAL();
 8019892:	f7ff fbc9 	bl	8019028 <vPortExitCritical>
		vTaskSuspendAll();
 8019896:	f000 fb9b 	bl	8019fd0 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
 801989a:	f7ff fba3 	bl	8018fe4 <vPortEnterCritical>
 801989e:	f894 3044 	ldrb.w	r3, [r4, #68]	; 0x44
 80198a2:	2bff      	cmp	r3, #255	; 0xff
 80198a4:	bf08      	it	eq
 80198a6:	f884 7044 	strbeq.w	r7, [r4, #68]	; 0x44
 80198aa:	f894 3045 	ldrb.w	r3, [r4, #69]	; 0x45
 80198ae:	2bff      	cmp	r3, #255	; 0xff
 80198b0:	bf08      	it	eq
 80198b2:	f884 7045 	strbeq.w	r7, [r4, #69]	; 0x45
 80198b6:	f7ff fbb7 	bl	8019028 <vPortExitCritical>
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 80198ba:	a901      	add	r1, sp, #4
 80198bc:	a802      	add	r0, sp, #8
 80198be:	f000 fde3 	bl	801a488 <xTaskCheckForTimeOut>
 80198c2:	2800      	cmp	r0, #0
 80198c4:	d131      	bne.n	801992a <xQueueReceive+0xd6>
	taskENTER_CRITICAL();
 80198c6:	f7ff fb8d 	bl	8018fe4 <vPortEnterCritical>
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
 80198ca:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 80198cc:	2b00      	cmp	r3, #0
 80198ce:	d052      	beq.n	8019976 <xQueueReceive+0x122>
	taskEXIT_CRITICAL();
 80198d0:	f7ff fbaa 	bl	8019028 <vPortExitCritical>
				prvUnlockQueue( pxQueue );
 80198d4:	4620      	mov	r0, r4
 80198d6:	f7ff fd63 	bl	80193a0 <prvUnlockQueue>
				( void ) xTaskResumeAll();
 80198da:	f000 fc79 	bl	801a1d0 <xTaskResumeAll>
		taskENTER_CRITICAL();
 80198de:	f7ff fb81 	bl	8018fe4 <vPortEnterCritical>
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 80198e2:	6ba6      	ldr	r6, [r4, #56]	; 0x38
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
 80198e4:	2e00      	cmp	r6, #0
 80198e6:	d131      	bne.n	801994c <xQueueReceive+0xf8>
				if( xTicksToWait == ( TickType_t ) 0 )
 80198e8:	9b01      	ldr	r3, [sp, #4]
 80198ea:	2b00      	cmp	r3, #0
 80198ec:	d1d1      	bne.n	8019892 <xQueueReceive+0x3e>
					taskEXIT_CRITICAL();
 80198ee:	f7ff fb9b 	bl	8019028 <vPortExitCritical>
					return errQUEUE_EMPTY;
 80198f2:	2000      	movs	r0, #0
}
 80198f4:	b005      	add	sp, #20
 80198f6:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	configASSERT( !( ( ( pvBuffer ) == NULL ) && ( ( pxQueue )->uxItemSize != ( UBaseType_t ) 0U ) ) );
 80198fa:	6c03      	ldr	r3, [r0, #64]	; 0x40
 80198fc:	2b00      	cmp	r3, #0
 80198fe:	d0b4      	beq.n	801986a <xQueueReceive+0x16>
	__asm volatile
 8019900:	f04f 0350 	mov.w	r3, #80	; 0x50
 8019904:	f383 8811 	msr	BASEPRI, r3
 8019908:	f3bf 8f6f 	isb	sy
 801990c:	f3bf 8f4f 	dsb	sy
 8019910:	e7fe      	b.n	8019910 <xQueueReceive+0xbc>
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
 8019912:	9b01      	ldr	r3, [sp, #4]
 8019914:	2b00      	cmp	r3, #0
 8019916:	d0ac      	beq.n	8019872 <xQueueReceive+0x1e>
 8019918:	f04f 0350 	mov.w	r3, #80	; 0x50
 801991c:	f383 8811 	msr	BASEPRI, r3
 8019920:	f3bf 8f6f 	isb	sy
 8019924:	f3bf 8f4f 	dsb	sy
 8019928:	e7fe      	b.n	8019928 <xQueueReceive+0xd4>
			prvUnlockQueue( pxQueue );
 801992a:	4620      	mov	r0, r4
 801992c:	f7ff fd38 	bl	80193a0 <prvUnlockQueue>
			( void ) xTaskResumeAll();
 8019930:	f000 fc4e 	bl	801a1d0 <xTaskResumeAll>
	taskENTER_CRITICAL();
 8019934:	f7ff fb56 	bl	8018fe4 <vPortEnterCritical>
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
 8019938:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 801993a:	2b00      	cmp	r3, #0
 801993c:	d0d7      	beq.n	80198ee <xQueueReceive+0x9a>
	taskEXIT_CRITICAL();
 801993e:	f7ff fb73 	bl	8019028 <vPortExitCritical>
		taskENTER_CRITICAL();
 8019942:	f7ff fb4f 	bl	8018fe4 <vPortEnterCritical>
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 8019946:	6ba6      	ldr	r6, [r4, #56]	; 0x38
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
 8019948:	2e00      	cmp	r6, #0
 801994a:	d0cd      	beq.n	80198e8 <xQueueReceive+0x94>
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
 801994c:	6c22      	ldr	r2, [r4, #64]	; 0x40
 801994e:	b152      	cbz	r2, 8019966 <xQueueReceive+0x112>
		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
 8019950:	68e1      	ldr	r1, [r4, #12]
		if( pxQueue->u.pcReadFrom >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
 8019952:	6863      	ldr	r3, [r4, #4]
		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
 8019954:	4411      	add	r1, r2
		if( pxQueue->u.pcReadFrom >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
 8019956:	4299      	cmp	r1, r3
		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
 8019958:	60e1      	str	r1, [r4, #12]
			pxQueue->u.pcReadFrom = pxQueue->pcHead;
 801995a:	bf24      	itt	cs
 801995c:	6821      	ldrcs	r1, [r4, #0]
 801995e:	60e1      	strcs	r1, [r4, #12]
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0. */
 8019960:	4628      	mov	r0, r5
 8019962:	f00d fde1 	bl	8027528 <memcpy>
				pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
 8019966:	3e01      	subs	r6, #1
 8019968:	63a6      	str	r6, [r4, #56]	; 0x38
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 801996a:	6923      	ldr	r3, [r4, #16]
 801996c:	bb13      	cbnz	r3, 80199b4 <xQueueReceive+0x160>
				taskEXIT_CRITICAL();
 801996e:	f7ff fb5b 	bl	8019028 <vPortExitCritical>
				return pdPASS;
 8019972:	2001      	movs	r0, #1
 8019974:	e7be      	b.n	80198f4 <xQueueReceive+0xa0>
	taskEXIT_CRITICAL();
 8019976:	f7ff fb57 	bl	8019028 <vPortExitCritical>
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
 801997a:	9901      	ldr	r1, [sp, #4]
 801997c:	4640      	mov	r0, r8
 801997e:	f000 fcf5 	bl	801a36c <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
 8019982:	4620      	mov	r0, r4
 8019984:	f7ff fd0c 	bl	80193a0 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
 8019988:	f000 fc22 	bl	801a1d0 <xTaskResumeAll>
 801998c:	2800      	cmp	r0, #0
 801998e:	d1d8      	bne.n	8019942 <xQueueReceive+0xee>
					portYIELD_WITHIN_API();
 8019990:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
 8019994:	f8c9 3d04 	str.w	r3, [r9, #3332]	; 0xd04
 8019998:	f3bf 8f4f 	dsb	sy
 801999c:	f3bf 8f6f 	isb	sy
		taskENTER_CRITICAL();
 80199a0:	e7cf      	b.n	8019942 <xQueueReceive+0xee>
 80199a2:	f04f 0350 	mov.w	r3, #80	; 0x50
 80199a6:	f383 8811 	msr	BASEPRI, r3
 80199aa:	f3bf 8f6f 	isb	sy
 80199ae:	f3bf 8f4f 	dsb	sy
	configASSERT( ( pxQueue ) );
 80199b2:	e7fe      	b.n	80199b2 <xQueueReceive+0x15e>
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 80199b4:	f104 0010 	add.w	r0, r4, #16
 80199b8:	f000 fd10 	bl	801a3dc <xTaskRemoveFromEventList>
 80199bc:	2800      	cmp	r0, #0
 80199be:	d0d6      	beq.n	801996e <xQueueReceive+0x11a>
						queueYIELD_IF_USING_PREEMPTION();
 80199c0:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
 80199c4:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 80199c8:	f8c3 2d04 	str.w	r2, [r3, #3332]	; 0xd04
 80199cc:	f3bf 8f4f 	dsb	sy
 80199d0:	f3bf 8f6f 	isb	sy
 80199d4:	e7cb      	b.n	801996e <xQueueReceive+0x11a>
 80199d6:	bf00      	nop

080199d8 <xQueueSemaphoreTake>:
{
 80199d8:	b5f0      	push	{r4, r5, r6, r7, lr}
 80199da:	b085      	sub	sp, #20
 80199dc:	9101      	str	r1, [sp, #4]
	configASSERT( ( pxQueue ) );
 80199de:	2800      	cmp	r0, #0
 80199e0:	d055      	beq.n	8019a8e <xQueueSemaphoreTake+0xb6>
	configASSERT( pxQueue->uxItemSize == 0 );
 80199e2:	6c06      	ldr	r6, [r0, #64]	; 0x40
 80199e4:	4604      	mov	r4, r0
 80199e6:	b146      	cbz	r6, 80199fa <xQueueSemaphoreTake+0x22>
 80199e8:	f04f 0350 	mov.w	r3, #80	; 0x50
 80199ec:	f383 8811 	msr	BASEPRI, r3
 80199f0:	f3bf 8f6f 	isb	sy
 80199f4:	f3bf 8f4f 	dsb	sy
 80199f8:	e7fe      	b.n	80199f8 <xQueueSemaphoreTake+0x20>
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
 80199fa:	f000 fd8f 	bl	801a51c <xTaskGetSchedulerState>
 80199fe:	4605      	mov	r5, r0
 8019a00:	2800      	cmp	r0, #0
 8019a02:	d04d      	beq.n	8019aa0 <xQueueSemaphoreTake+0xc8>
 8019a04:	4635      	mov	r5, r6
		taskENTER_CRITICAL();
 8019a06:	f7ff faed 	bl	8018fe4 <vPortEnterCritical>
			const UBaseType_t uxSemaphoreCount = pxQueue->uxMessagesWaiting;
 8019a0a:	6ba3      	ldr	r3, [r4, #56]	; 0x38
		prvLockQueue( pxQueue );
 8019a0c:	2700      	movs	r7, #0
			if( uxSemaphoreCount > ( UBaseType_t ) 0 )
 8019a0e:	bb8b      	cbnz	r3, 8019a74 <xQueueSemaphoreTake+0x9c>
				if( xTicksToWait == ( TickType_t ) 0 )
 8019a10:	9b01      	ldr	r3, [sp, #4]
 8019a12:	2b00      	cmp	r3, #0
 8019a14:	f000 809b 	beq.w	8019b4e <xQueueSemaphoreTake+0x176>
				else if( xEntryTimeSet == pdFALSE )
 8019a18:	2d00      	cmp	r5, #0
 8019a1a:	d059      	beq.n	8019ad0 <xQueueSemaphoreTake+0xf8>
		taskEXIT_CRITICAL();
 8019a1c:	f7ff fb04 	bl	8019028 <vPortExitCritical>
		vTaskSuspendAll();
 8019a20:	f000 fad6 	bl	8019fd0 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
 8019a24:	f7ff fade 	bl	8018fe4 <vPortEnterCritical>
 8019a28:	f894 3044 	ldrb.w	r3, [r4, #68]	; 0x44
 8019a2c:	2bff      	cmp	r3, #255	; 0xff
 8019a2e:	bf08      	it	eq
 8019a30:	f884 7044 	strbeq.w	r7, [r4, #68]	; 0x44
 8019a34:	f894 3045 	ldrb.w	r3, [r4, #69]	; 0x45
 8019a38:	2bff      	cmp	r3, #255	; 0xff
 8019a3a:	bf08      	it	eq
 8019a3c:	f884 7045 	strbeq.w	r7, [r4, #69]	; 0x45
 8019a40:	f7ff faf2 	bl	8019028 <vPortExitCritical>
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 8019a44:	a901      	add	r1, sp, #4
 8019a46:	a802      	add	r0, sp, #8
 8019a48:	f000 fd1e 	bl	801a488 <xTaskCheckForTimeOut>
 8019a4c:	2800      	cmp	r0, #0
 8019a4e:	d133      	bne.n	8019ab8 <xQueueSemaphoreTake+0xe0>
	taskENTER_CRITICAL();
 8019a50:	f7ff fac8 	bl	8018fe4 <vPortEnterCritical>
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
 8019a54:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8019a56:	2b00      	cmp	r3, #0
 8019a58:	d044      	beq.n	8019ae4 <xQueueSemaphoreTake+0x10c>
	taskEXIT_CRITICAL();
 8019a5a:	f7ff fae5 	bl	8019028 <vPortExitCritical>
				prvUnlockQueue( pxQueue );
 8019a5e:	4620      	mov	r0, r4
 8019a60:	f7ff fc9e 	bl	80193a0 <prvUnlockQueue>
				( void ) xTaskResumeAll();
 8019a64:	f000 fbb4 	bl	801a1d0 <xTaskResumeAll>
		taskENTER_CRITICAL();
 8019a68:	f7ff fabc 	bl	8018fe4 <vPortEnterCritical>
			const UBaseType_t uxSemaphoreCount = pxQueue->uxMessagesWaiting;
 8019a6c:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8019a6e:	2501      	movs	r5, #1
			if( uxSemaphoreCount > ( UBaseType_t ) 0 )
 8019a70:	2b00      	cmp	r3, #0
 8019a72:	d0cd      	beq.n	8019a10 <xQueueSemaphoreTake+0x38>
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 8019a74:	6822      	ldr	r2, [r4, #0]
				pxQueue->uxMessagesWaiting = uxSemaphoreCount - ( UBaseType_t ) 1;
 8019a76:	3b01      	subs	r3, #1
 8019a78:	63a3      	str	r3, [r4, #56]	; 0x38
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 8019a7a:	2a00      	cmp	r2, #0
 8019a7c:	f000 8085 	beq.w	8019b8a <xQueueSemaphoreTake+0x1b2>
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 8019a80:	6923      	ldr	r3, [r4, #16]
 8019a82:	2b00      	cmp	r3, #0
 8019a84:	d170      	bne.n	8019b68 <xQueueSemaphoreTake+0x190>
				taskEXIT_CRITICAL();
 8019a86:	f7ff facf 	bl	8019028 <vPortExitCritical>
				return pdPASS;
 8019a8a:	2601      	movs	r6, #1
 8019a8c:	e027      	b.n	8019ade <xQueueSemaphoreTake+0x106>
 8019a8e:	f04f 0350 	mov.w	r3, #80	; 0x50
 8019a92:	f383 8811 	msr	BASEPRI, r3
 8019a96:	f3bf 8f6f 	isb	sy
 8019a9a:	f3bf 8f4f 	dsb	sy
	configASSERT( ( pxQueue ) );
 8019a9e:	e7fe      	b.n	8019a9e <xQueueSemaphoreTake+0xc6>
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
 8019aa0:	9b01      	ldr	r3, [sp, #4]
 8019aa2:	2b00      	cmp	r3, #0
 8019aa4:	d039      	beq.n	8019b1a <xQueueSemaphoreTake+0x142>
 8019aa6:	f04f 0350 	mov.w	r3, #80	; 0x50
 8019aaa:	f383 8811 	msr	BASEPRI, r3
 8019aae:	f3bf 8f6f 	isb	sy
 8019ab2:	f3bf 8f4f 	dsb	sy
 8019ab6:	e7fe      	b.n	8019ab6 <xQueueSemaphoreTake+0xde>
			prvUnlockQueue( pxQueue );
 8019ab8:	4620      	mov	r0, r4
 8019aba:	f7ff fc71 	bl	80193a0 <prvUnlockQueue>
			( void ) xTaskResumeAll();
 8019abe:	f000 fb87 	bl	801a1d0 <xTaskResumeAll>
	taskENTER_CRITICAL();
 8019ac2:	f7ff fa8f 	bl	8018fe4 <vPortEnterCritical>
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
 8019ac6:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8019ac8:	b133      	cbz	r3, 8019ad8 <xQueueSemaphoreTake+0x100>
	taskEXIT_CRITICAL();
 8019aca:	f7ff faad 	bl	8019028 <vPortExitCritical>
	return xReturn;
 8019ace:	e7cb      	b.n	8019a68 <xQueueSemaphoreTake+0x90>
					vTaskInternalSetTimeOutState( &xTimeOut );
 8019ad0:	a802      	add	r0, sp, #8
 8019ad2:	f000 fccf 	bl	801a474 <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
 8019ad6:	e7a1      	b.n	8019a1c <xQueueSemaphoreTake+0x44>
	taskEXIT_CRITICAL();
 8019ad8:	f7ff faa6 	bl	8019028 <vPortExitCritical>
					if( xInheritanceOccurred != pdFALSE )
 8019adc:	b9fe      	cbnz	r6, 8019b1e <xQueueSemaphoreTake+0x146>
}
 8019ade:	4630      	mov	r0, r6
 8019ae0:	b005      	add	sp, #20
 8019ae2:	bdf0      	pop	{r4, r5, r6, r7, pc}
	taskEXIT_CRITICAL();
 8019ae4:	f7ff faa0 	bl	8019028 <vPortExitCritical>
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 8019ae8:	6823      	ldr	r3, [r4, #0]
 8019aea:	b33b      	cbz	r3, 8019b3c <xQueueSemaphoreTake+0x164>
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
 8019aec:	9901      	ldr	r1, [sp, #4]
 8019aee:	f104 0024 	add.w	r0, r4, #36	; 0x24
 8019af2:	f000 fc3b 	bl	801a36c <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
 8019af6:	4620      	mov	r0, r4
 8019af8:	f7ff fc52 	bl	80193a0 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
 8019afc:	f000 fb68 	bl	801a1d0 <xTaskResumeAll>
 8019b00:	2800      	cmp	r0, #0
 8019b02:	d1b1      	bne.n	8019a68 <xQueueSemaphoreTake+0x90>
					portYIELD_WITHIN_API();
 8019b04:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
 8019b08:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8019b0c:	f8c3 2d04 	str.w	r2, [r3, #3332]	; 0xd04
 8019b10:	f3bf 8f4f 	dsb	sy
 8019b14:	f3bf 8f6f 	isb	sy
 8019b18:	e7a6      	b.n	8019a68 <xQueueSemaphoreTake+0x90>
 8019b1a:	4606      	mov	r6, r0
 8019b1c:	e773      	b.n	8019a06 <xQueueSemaphoreTake+0x2e>
						taskENTER_CRITICAL();
 8019b1e:	f7ff fa61 	bl	8018fe4 <vPortEnterCritical>
		if( listCURRENT_LIST_LENGTH( &( pxQueue->xTasksWaitingToReceive ) ) > 0 )
 8019b22:	6a61      	ldr	r1, [r4, #36]	; 0x24
 8019b24:	b119      	cbz	r1, 8019b2e <xQueueSemaphoreTake+0x156>
			uxHighestPriorityOfWaitingTasks = configMAX_PRIORITIES - listGET_ITEM_VALUE_OF_HEAD_ENTRY( &( pxQueue->xTasksWaitingToReceive ) );
 8019b26:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8019b28:	6819      	ldr	r1, [r3, #0]
 8019b2a:	f1c1 0107 	rsb	r1, r1, #7
							vTaskPriorityDisinheritAfterTimeout( ( void * ) pxQueue->pxMutexHolder, uxHighestWaitingPriority );
 8019b2e:	6860      	ldr	r0, [r4, #4]
 8019b30:	f000 fdac 	bl	801a68c <vTaskPriorityDisinheritAfterTimeout>
				return errQUEUE_EMPTY;
 8019b34:	2600      	movs	r6, #0
						taskEXIT_CRITICAL();
 8019b36:	f7ff fa77 	bl	8019028 <vPortExitCritical>
 8019b3a:	e7d0      	b.n	8019ade <xQueueSemaphoreTake+0x106>
						taskENTER_CRITICAL();
 8019b3c:	f7ff fa52 	bl	8018fe4 <vPortEnterCritical>
							xInheritanceOccurred = xTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
 8019b40:	6860      	ldr	r0, [r4, #4]
 8019b42:	f000 fcfb 	bl	801a53c <xTaskPriorityInherit>
 8019b46:	4606      	mov	r6, r0
						taskEXIT_CRITICAL();
 8019b48:	f7ff fa6e 	bl	8019028 <vPortExitCritical>
 8019b4c:	e7ce      	b.n	8019aec <xQueueSemaphoreTake+0x114>
						configASSERT( xInheritanceOccurred == pdFALSE );
 8019b4e:	b146      	cbz	r6, 8019b62 <xQueueSemaphoreTake+0x18a>
 8019b50:	f04f 0350 	mov.w	r3, #80	; 0x50
 8019b54:	f383 8811 	msr	BASEPRI, r3
 8019b58:	f3bf 8f6f 	isb	sy
 8019b5c:	f3bf 8f4f 	dsb	sy
 8019b60:	e7fe      	b.n	8019b60 <xQueueSemaphoreTake+0x188>
					taskEXIT_CRITICAL();
 8019b62:	f7ff fa61 	bl	8019028 <vPortExitCritical>
					return errQUEUE_EMPTY;
 8019b66:	e7ba      	b.n	8019ade <xQueueSemaphoreTake+0x106>
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 8019b68:	f104 0010 	add.w	r0, r4, #16
 8019b6c:	f000 fc36 	bl	801a3dc <xTaskRemoveFromEventList>
 8019b70:	2800      	cmp	r0, #0
 8019b72:	d088      	beq.n	8019a86 <xQueueSemaphoreTake+0xae>
						queueYIELD_IF_USING_PREEMPTION();
 8019b74:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
 8019b78:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8019b7c:	f8c3 2d04 	str.w	r2, [r3, #3332]	; 0xd04
 8019b80:	f3bf 8f4f 	dsb	sy
 8019b84:	f3bf 8f6f 	isb	sy
 8019b88:	e77d      	b.n	8019a86 <xQueueSemaphoreTake+0xae>
						pxQueue->pxMutexHolder = ( int8_t * ) pvTaskIncrementMutexHeldCount(); /*lint !e961 Cast is not redundant as TaskHandle_t is a typedef. */
 8019b8a:	f000 fde3 	bl	801a754 <pvTaskIncrementMutexHeldCount>
 8019b8e:	6060      	str	r0, [r4, #4]
 8019b90:	e776      	b.n	8019a80 <xQueueSemaphoreTake+0xa8>
 8019b92:	bf00      	nop

08019b94 <xQueueReceiveFromISR>:
{
 8019b94:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	configASSERT( pxQueue );
 8019b98:	b310      	cbz	r0, 8019be0 <xQueueReceiveFromISR+0x4c>
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 8019b9a:	460e      	mov	r6, r1
 8019b9c:	4617      	mov	r7, r2
 8019b9e:	4604      	mov	r4, r0
 8019ba0:	b191      	cbz	r1, 8019bc8 <xQueueReceiveFromISR+0x34>
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
 8019ba2:	f7ff fb49 	bl	8019238 <vPortValidateInterruptPriority>
	__asm volatile
 8019ba6:	f3ef 8911 	mrs	r9, BASEPRI
 8019baa:	f04f 0350 	mov.w	r3, #80	; 0x50
 8019bae:	f383 8811 	msr	BASEPRI, r3
 8019bb2:	f3bf 8f6f 	isb	sy
 8019bb6:	f3bf 8f4f 	dsb	sy
		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 8019bba:	6ba5      	ldr	r5, [r4, #56]	; 0x38
		if( uxMessagesWaiting > ( UBaseType_t ) 0 )
 8019bbc:	b9cd      	cbnz	r5, 8019bf2 <xQueueReceiveFromISR+0x5e>
			xReturn = pdFAIL;
 8019bbe:	4628      	mov	r0, r5
	__asm volatile
 8019bc0:	f389 8811 	msr	BASEPRI, r9
}
 8019bc4:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 8019bc8:	6c03      	ldr	r3, [r0, #64]	; 0x40
 8019bca:	2b00      	cmp	r3, #0
 8019bcc:	d0e9      	beq.n	8019ba2 <xQueueReceiveFromISR+0xe>
	__asm volatile
 8019bce:	f04f 0350 	mov.w	r3, #80	; 0x50
 8019bd2:	f383 8811 	msr	BASEPRI, r3
 8019bd6:	f3bf 8f6f 	isb	sy
 8019bda:	f3bf 8f4f 	dsb	sy
 8019bde:	e7fe      	b.n	8019bde <xQueueReceiveFromISR+0x4a>
 8019be0:	f04f 0350 	mov.w	r3, #80	; 0x50
 8019be4:	f383 8811 	msr	BASEPRI, r3
 8019be8:	f3bf 8f6f 	isb	sy
 8019bec:	f3bf 8f4f 	dsb	sy
	configASSERT( pxQueue );
 8019bf0:	e7fe      	b.n	8019bf0 <xQueueReceiveFromISR+0x5c>
			const int8_t cRxLock = pxQueue->cRxLock;
 8019bf2:	f894 8044 	ldrb.w	r8, [r4, #68]	; 0x44
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
 8019bf6:	6c22      	ldr	r2, [r4, #64]	; 0x40
			const int8_t cRxLock = pxQueue->cRxLock;
 8019bf8:	fa4f f888 	sxtb.w	r8, r8
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
 8019bfc:	b152      	cbz	r2, 8019c14 <xQueueReceiveFromISR+0x80>
		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
 8019bfe:	68e1      	ldr	r1, [r4, #12]
		if( pxQueue->u.pcReadFrom >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
 8019c00:	6863      	ldr	r3, [r4, #4]
		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
 8019c02:	4411      	add	r1, r2
		if( pxQueue->u.pcReadFrom >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
 8019c04:	4299      	cmp	r1, r3
		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
 8019c06:	60e1      	str	r1, [r4, #12]
			pxQueue->u.pcReadFrom = pxQueue->pcHead;
 8019c08:	bf24      	itt	cs
 8019c0a:	6821      	ldrcs	r1, [r4, #0]
 8019c0c:	60e1      	strcs	r1, [r4, #12]
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0. */
 8019c0e:	4630      	mov	r0, r6
 8019c10:	f00d fc8a 	bl	8027528 <memcpy>
			pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
 8019c14:	3d01      	subs	r5, #1
			if( cRxLock == queueUNLOCKED )
 8019c16:	f1b8 3fff 	cmp.w	r8, #4294967295
			pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
 8019c1a:	63a5      	str	r5, [r4, #56]	; 0x38
			if( cRxLock == queueUNLOCKED )
 8019c1c:	d009      	beq.n	8019c32 <xQueueReceiveFromISR+0x9e>
				pxQueue->cRxLock = ( int8_t ) ( cRxLock + 1 );
 8019c1e:	f108 0301 	add.w	r3, r8, #1
 8019c22:	b25b      	sxtb	r3, r3
 8019c24:	f884 3044 	strb.w	r3, [r4, #68]	; 0x44
			xReturn = pdPASS;
 8019c28:	2001      	movs	r0, #1
	__asm volatile
 8019c2a:	f389 8811 	msr	BASEPRI, r9
}
 8019c2e:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 8019c32:	6923      	ldr	r3, [r4, #16]
 8019c34:	2b00      	cmp	r3, #0
 8019c36:	d0f7      	beq.n	8019c28 <xQueueReceiveFromISR+0x94>
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 8019c38:	f104 0010 	add.w	r0, r4, #16
 8019c3c:	f000 fbce 	bl	801a3dc <xTaskRemoveFromEventList>
 8019c40:	2800      	cmp	r0, #0
 8019c42:	d0f1      	beq.n	8019c28 <xQueueReceiveFromISR+0x94>
						if( pxHigherPriorityTaskWoken != NULL )
 8019c44:	2f00      	cmp	r7, #0
 8019c46:	d0ef      	beq.n	8019c28 <xQueueReceiveFromISR+0x94>
							*pxHigherPriorityTaskWoken = pdTRUE;
 8019c48:	2001      	movs	r0, #1
 8019c4a:	6038      	str	r0, [r7, #0]
 8019c4c:	e7b8      	b.n	8019bc0 <xQueueReceiveFromISR+0x2c>
 8019c4e:	bf00      	nop

08019c50 <vQueueAddToRegistry>:
/*-----------------------------------------------------------*/

#if ( configQUEUE_REGISTRY_SIZE > 0 )

	void vQueueAddToRegistry( QueueHandle_t xQueue, const char *pcQueueName ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
	{
 8019c50:	b410      	push	{r4}
 8019c52:	4c09      	ldr	r4, [pc, #36]	; (8019c78 <vQueueAddToRegistry+0x28>)
	UBaseType_t ux;

		/* See if there is an empty space in the registry.  A NULL name denotes
		a free slot. */
		for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
 8019c54:	2300      	movs	r3, #0
		{
			if( xQueueRegistry[ ux ].pcQueueName == NULL )
 8019c56:	f854 2033 	ldr.w	r2, [r4, r3, lsl #3]
 8019c5a:	b12a      	cbz	r2, 8019c68 <vQueueAddToRegistry+0x18>
		for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
 8019c5c:	3301      	adds	r3, #1
 8019c5e:	2b08      	cmp	r3, #8
 8019c60:	d1f9      	bne.n	8019c56 <vQueueAddToRegistry+0x6>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
 8019c62:	f85d 4b04 	ldr.w	r4, [sp], #4
 8019c66:	4770      	bx	lr
				xQueueRegistry[ ux ].xHandle = xQueue;
 8019c68:	eb04 02c3 	add.w	r2, r4, r3, lsl #3
				xQueueRegistry[ ux ].pcQueueName = pcQueueName;
 8019c6c:	f844 1033 	str.w	r1, [r4, r3, lsl #3]
				xQueueRegistry[ ux ].xHandle = xQueue;
 8019c70:	6050      	str	r0, [r2, #4]
	}
 8019c72:	f85d 4b04 	ldr.w	r4, [sp], #4
 8019c76:	4770      	bx	lr
 8019c78:	20007f40 	.word	0x20007f40

08019c7c <vQueueWaitForMessageRestricted>:
/*-----------------------------------------------------------*/

#if ( configUSE_TIMERS == 1 )

	void vQueueWaitForMessageRestricted( QueueHandle_t xQueue, TickType_t xTicksToWait, const BaseType_t xWaitIndefinitely )
	{
 8019c7c:	b570      	push	{r4, r5, r6, lr}
 8019c7e:	4604      	mov	r4, r0
 8019c80:	460e      	mov	r6, r1
 8019c82:	4615      	mov	r5, r2
		will not actually cause the task to block, just place it on a blocked
		list.  It will not block until the scheduler is unlocked - at which
		time a yield will be performed.  If an item is added to the queue while
		the queue is locked, and the calling task blocks on the queue, then the
		calling task will be immediately unblocked when the queue is unlocked. */
		prvLockQueue( pxQueue );
 8019c84:	f7ff f9ae 	bl	8018fe4 <vPortEnterCritical>
 8019c88:	f894 3044 	ldrb.w	r3, [r4, #68]	; 0x44
 8019c8c:	2bff      	cmp	r3, #255	; 0xff
 8019c8e:	bf04      	itt	eq
 8019c90:	2300      	moveq	r3, #0
 8019c92:	f884 3044 	strbeq.w	r3, [r4, #68]	; 0x44
 8019c96:	f894 3045 	ldrb.w	r3, [r4, #69]	; 0x45
 8019c9a:	2bff      	cmp	r3, #255	; 0xff
 8019c9c:	bf04      	itt	eq
 8019c9e:	2300      	moveq	r3, #0
 8019ca0:	f884 3045 	strbeq.w	r3, [r4, #69]	; 0x45
 8019ca4:	f7ff f9c0 	bl	8019028 <vPortExitCritical>
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0U )
 8019ca8:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8019caa:	b123      	cbz	r3, 8019cb6 <vQueueWaitForMessageRestricted+0x3a>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		prvUnlockQueue( pxQueue );
 8019cac:	4620      	mov	r0, r4
	}
 8019cae:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		prvUnlockQueue( pxQueue );
 8019cb2:	f7ff bb75 	b.w	80193a0 <prvUnlockQueue>
			vTaskPlaceOnEventListRestricted( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait, xWaitIndefinitely );
 8019cb6:	f104 0024 	add.w	r0, r4, #36	; 0x24
 8019cba:	462a      	mov	r2, r5
 8019cbc:	4631      	mov	r1, r6
 8019cbe:	f000 fb6f 	bl	801a3a0 <vTaskPlaceOnEventListRestricted>
		prvUnlockQueue( pxQueue );
 8019cc2:	4620      	mov	r0, r4
	}
 8019cc4:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		prvUnlockQueue( pxQueue );
 8019cc8:	f7ff bb6a 	b.w	80193a0 <prvUnlockQueue>

08019ccc <prvAddCurrentTaskToDelayedList>:
#endif /* configUSE_TASK_NOTIFICATIONS */
/*-----------------------------------------------------------*/


static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait, const BaseType_t xCanBlockIndefinitely )
{
 8019ccc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
TickType_t xTimeToWake;
const TickType_t xConstTickCount = xTickCount;
 8019cce:	4c18      	ldr	r4, [pc, #96]	; (8019d30 <prvAddCurrentTaskToDelayedList+0x64>)
{
 8019cd0:	4606      	mov	r6, r0
const TickType_t xConstTickCount = xTickCount;
 8019cd2:	6825      	ldr	r5, [r4, #0]
	}
	#endif

	/* Remove the task from the ready list before adding it to the blocked list
	as the same list item is used for both lists. */
	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 8019cd4:	6860      	ldr	r0, [r4, #4]
 8019cd6:	3004      	adds	r0, #4
{
 8019cd8:	460f      	mov	r7, r1
	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 8019cda:	f7ff fb11 	bl	8019300 <uxListRemove>
 8019cde:	b938      	cbnz	r0, 8019cf0 <prvAddCurrentTaskToDelayedList+0x24>
	{
		/* The current task must be in a ready list, so there is no need to
		check, and the port reset macro can be called directly. */
		portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
 8019ce0:	6863      	ldr	r3, [r4, #4]
 8019ce2:	6ad9      	ldr	r1, [r3, #44]	; 0x2c
 8019ce4:	68a3      	ldr	r3, [r4, #8]
 8019ce6:	2201      	movs	r2, #1
 8019ce8:	408a      	lsls	r2, r1
 8019cea:	ea23 0302 	bic.w	r3, r3, r2
 8019cee:	60a3      	str	r3, [r4, #8]
		mtCOVERAGE_TEST_MARKER();
	}

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
 8019cf0:	1c73      	adds	r3, r6, #1
 8019cf2:	d014      	beq.n	8019d1e <prvAddCurrentTaskToDelayedList+0x52>
			does not occur.  This may overflow but this doesn't matter, the
			kernel will manage it correctly. */
			xTimeToWake = xConstTickCount + xTicksToWait;

			/* The list item will be inserted in wake time order. */
			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
 8019cf4:	6863      	ldr	r3, [r4, #4]
 8019cf6:	19ad      	adds	r5, r5, r6
 8019cf8:	605d      	str	r5, [r3, #4]

			if( xTimeToWake < xConstTickCount )
 8019cfa:	d306      	bcc.n	8019d0a <prvAddCurrentTaskToDelayedList+0x3e>
			{
				/* Wake time has overflowed.  Place this item in the overflow
				list. */
				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
 8019cfc:	6a20      	ldr	r0, [r4, #32]
 8019cfe:	6861      	ldr	r1, [r4, #4]

		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
		( void ) xCanBlockIndefinitely;
	}
	#endif /* INCLUDE_vTaskSuspend */
}
 8019d00:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
 8019d04:	3104      	adds	r1, #4
 8019d06:	f7ff bae3 	b.w	80192d0 <vListInsert>
				vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
 8019d0a:	6a60      	ldr	r0, [r4, #36]	; 0x24
 8019d0c:	6861      	ldr	r1, [r4, #4]
 8019d0e:	3104      	adds	r1, #4
 8019d10:	f7ff fade 	bl	80192d0 <vListInsert>
				if( xTimeToWake < xNextTaskUnblockTime )
 8019d14:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 8019d16:	42ab      	cmp	r3, r5
					xNextTaskUnblockTime = xTimeToWake;
 8019d18:	bf88      	it	hi
 8019d1a:	62a5      	strhi	r5, [r4, #40]	; 0x28
}
 8019d1c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
 8019d1e:	2f00      	cmp	r7, #0
 8019d20:	d0e8      	beq.n	8019cf4 <prvAddCurrentTaskToDelayedList+0x28>
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
 8019d22:	6861      	ldr	r1, [r4, #4]
 8019d24:	4803      	ldr	r0, [pc, #12]	; (8019d34 <prvAddCurrentTaskToDelayedList+0x68>)
}
 8019d26:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
 8019d2a:	3104      	adds	r1, #4
 8019d2c:	f7ff bac0 	b.w	80192b0 <vListInsertEnd>
 8019d30:	20007f80 	.word	0x20007f80
 8019d34:	20007f8c 	.word	0x20007f8c

08019d38 <vTaskSwitchContext.part.0>:
void vTaskSwitchContext( void )
 8019d38:	b510      	push	{r4, lr}
		xYieldPending = pdFALSE;
 8019d3a:	4c1e      	ldr	r4, [pc, #120]	; (8019db4 <vTaskSwitchContext.part.0+0x7c>)
 8019d3c:	2300      	movs	r3, #0
 8019d3e:	62e3      	str	r3, [r4, #44]	; 0x2c
		taskCHECK_FOR_STACK_OVERFLOW();
 8019d40:	6863      	ldr	r3, [r4, #4]
 8019d42:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8019d44:	681a      	ldr	r2, [r3, #0]
 8019d46:	f1b2 3fa5 	cmp.w	r2, #2779096485	; 0xa5a5a5a5
 8019d4a:	d103      	bne.n	8019d54 <vTaskSwitchContext.part.0+0x1c>
 8019d4c:	685a      	ldr	r2, [r3, #4]
 8019d4e:	f1b2 3fa5 	cmp.w	r2, #2779096485	; 0xa5a5a5a5
 8019d52:	d026      	beq.n	8019da2 <vTaskSwitchContext.part.0+0x6a>
 8019d54:	6860      	ldr	r0, [r4, #4]
 8019d56:	6861      	ldr	r1, [r4, #4]
 8019d58:	3134      	adds	r1, #52	; 0x34
 8019d5a:	f008 ff79 	bl	8022c50 <vApplicationStackOverflowHook>
		taskSELECT_HIGHEST_PRIORITY_TASK();
 8019d5e:	68a3      	ldr	r3, [r4, #8]
		__asm volatile ( "clz %0, %1" : "=r" ( ucReturn ) : "r" ( ulBitmap ) : "memory" );
 8019d60:	fab3 f383 	clz	r3, r3
 8019d64:	b2db      	uxtb	r3, r3
 8019d66:	f1c3 031f 	rsb	r3, r3, #31
 8019d6a:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 8019d6e:	eb04 0283 	add.w	r2, r4, r3, lsl #2
 8019d72:	009b      	lsls	r3, r3, #2
 8019d74:	6b11      	ldr	r1, [r2, #48]	; 0x30
 8019d76:	b941      	cbnz	r1, 8019d8a <vTaskSwitchContext.part.0+0x52>
	__asm volatile
 8019d78:	f04f 0350 	mov.w	r3, #80	; 0x50
 8019d7c:	f383 8811 	msr	BASEPRI, r3
 8019d80:	f3bf 8f6f 	isb	sy
 8019d84:	f3bf 8f4f 	dsb	sy
 8019d88:	e7fe      	b.n	8019d88 <vTaskSwitchContext.part.0+0x50>
 8019d8a:	6b51      	ldr	r1, [r2, #52]	; 0x34
 8019d8c:	480a      	ldr	r0, [pc, #40]	; (8019db8 <vTaskSwitchContext.part.0+0x80>)
 8019d8e:	6849      	ldr	r1, [r1, #4]
 8019d90:	6351      	str	r1, [r2, #52]	; 0x34
 8019d92:	4403      	add	r3, r0
 8019d94:	4299      	cmp	r1, r3
 8019d96:	bf04      	itt	eq
 8019d98:	6849      	ldreq	r1, [r1, #4]
 8019d9a:	6351      	streq	r1, [r2, #52]	; 0x34
 8019d9c:	68cb      	ldr	r3, [r1, #12]
 8019d9e:	6063      	str	r3, [r4, #4]
}
 8019da0:	bd10      	pop	{r4, pc}
		taskCHECK_FOR_STACK_OVERFLOW();
 8019da2:	689a      	ldr	r2, [r3, #8]
 8019da4:	f1b2 3fa5 	cmp.w	r2, #2779096485	; 0xa5a5a5a5
 8019da8:	d1d4      	bne.n	8019d54 <vTaskSwitchContext.part.0+0x1c>
 8019daa:	68db      	ldr	r3, [r3, #12]
 8019dac:	f1b3 3fa5 	cmp.w	r3, #2779096485	; 0xa5a5a5a5
 8019db0:	d1d0      	bne.n	8019d54 <vTaskSwitchContext.part.0+0x1c>
 8019db2:	e7d4      	b.n	8019d5e <vTaskSwitchContext.part.0+0x26>
 8019db4:	20007f80 	.word	0x20007f80
 8019db8:	20007fb8 	.word	0x20007fb8

08019dbc <xTaskCreate>:
	{
 8019dbc:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
			pxStack = ( StackType_t * ) pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8019dc0:	0096      	lsls	r6, r2, #2
	{
 8019dc2:	4607      	mov	r7, r0
			pxStack = ( StackType_t * ) pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8019dc4:	4630      	mov	r0, r6
	{
 8019dc6:	4689      	mov	r9, r1
 8019dc8:	4698      	mov	r8, r3
			pxStack = ( StackType_t * ) pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8019dca:	f7fe ffed 	bl	8018da8 <pvPortMalloc>
			if( pxStack != NULL )
 8019dce:	2800      	cmp	r0, #0
 8019dd0:	d07f      	beq.n	8019ed2 <xTaskCreate+0x116>
				pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e961 MISRA exception as the casts are only redundant for some paths. */
 8019dd2:	4605      	mov	r5, r0
 8019dd4:	2054      	movs	r0, #84	; 0x54
 8019dd6:	f7fe ffe7 	bl	8018da8 <pvPortMalloc>
				if( pxNewTCB != NULL )
 8019dda:	4604      	mov	r4, r0
 8019ddc:	2800      	cmp	r0, #0
 8019dde:	f000 8085 	beq.w	8019eec <xTaskCreate+0x130>
					pxNewTCB->pxStack = pxStack;
 8019de2:	6305      	str	r5, [r0, #48]	; 0x30
		( void ) memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) ulStackDepth * sizeof( StackType_t ) );
 8019de4:	21a5      	movs	r1, #165	; 0xa5
 8019de6:	4628      	mov	r0, r5
 8019de8:	4632      	mov	r2, r6
 8019dea:	f00d fbc5 	bl	8027578 <memset>
		pxTopOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
 8019dee:	f8d4 a030 	ldr.w	sl, [r4, #48]	; 0x30
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
 8019df2:	f109 3cff 	add.w	ip, r9, #4294967295
 8019df6:	f109 010f 	add.w	r1, r9, #15
 8019dfa:	f104 0e33 	add.w	lr, r4, #51	; 0x33
		pxNewTCB->pcTaskName[ x ] = pcName[ x ];
 8019dfe:	f81c 5f01 	ldrb.w	r5, [ip, #1]!
 8019e02:	f80e 5f01 	strb.w	r5, [lr, #1]!
		if( pcName[ x ] == 0x00 )
 8019e06:	b10d      	cbz	r5, 8019e0c <xTaskCreate+0x50>
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
 8019e08:	458c      	cmp	ip, r1
 8019e0a:	d1f8      	bne.n	8019dfe <xTaskCreate+0x42>
	pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
 8019e0c:	9d0a      	ldr	r5, [sp, #40]	; 0x28
 8019e0e:	2d06      	cmp	r5, #6
 8019e10:	bf28      	it	cs
 8019e12:	2506      	movcs	r5, #6
 8019e14:	f04f 0b00 	mov.w	fp, #0
	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
 8019e18:	f104 0904 	add.w	r9, r4, #4
	pxNewTCB->uxPriority = uxPriority;
 8019e1c:	62e5      	str	r5, [r4, #44]	; 0x2c
		pxNewTCB->uxBasePriority = uxPriority;
 8019e1e:	6465      	str	r5, [r4, #68]	; 0x44
	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
 8019e20:	4648      	mov	r0, r9
	pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
 8019e22:	f884 b043 	strb.w	fp, [r4, #67]	; 0x43
		pxNewTCB->uxMutexesHeld = 0;
 8019e26:	f8c4 b048 	str.w	fp, [r4, #72]	; 0x48
		pxTopOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
 8019e2a:	3e04      	subs	r6, #4
	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
 8019e2c:	f7ff fa3c 	bl	80192a8 <vListInitialiseItem>
		pxTopOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
 8019e30:	4456      	add	r6, sl
	vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
 8019e32:	f104 0018 	add.w	r0, r4, #24
	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8019e36:	f1c5 0507 	rsb	r5, r5, #7
	vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
 8019e3a:	f7ff fa35 	bl	80192a8 <vListInitialiseItem>
		pxNewTCB->ulNotifiedValue = 0;
 8019e3e:	f8c4 b04c 	str.w	fp, [r4, #76]	; 0x4c
	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8019e42:	61a5      	str	r5, [r4, #24]
		pxNewTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
 8019e44:	f884 b050 	strb.w	fp, [r4, #80]	; 0x50
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
 8019e48:	6124      	str	r4, [r4, #16]
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
 8019e4a:	6264      	str	r4, [r4, #36]	; 0x24
		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
 8019e4c:	4642      	mov	r2, r8
 8019e4e:	4639      	mov	r1, r7
 8019e50:	f026 0007 	bic.w	r0, r6, #7
 8019e54:	f7ff f89a 	bl	8018f8c <pxPortInitialiseStack>
	if( ( void * ) pxCreatedTask != NULL )
 8019e58:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
 8019e5a:	6020      	str	r0, [r4, #0]
	if( ( void * ) pxCreatedTask != NULL )
 8019e5c:	b103      	cbz	r3, 8019e60 <xTaskCreate+0xa4>
		*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
 8019e5e:	601c      	str	r4, [r3, #0]
		uxCurrentNumberOfTasks++;
 8019e60:	4d3c      	ldr	r5, [pc, #240]	; (8019f54 <xTaskCreate+0x198>)
	taskENTER_CRITICAL();
 8019e62:	f7ff f8bf 	bl	8018fe4 <vPortEnterCritical>
		uxCurrentNumberOfTasks++;
 8019e66:	f8d5 30bc 	ldr.w	r3, [r5, #188]	; 0xbc
 8019e6a:	3301      	adds	r3, #1
 8019e6c:	f8c5 30bc 	str.w	r3, [r5, #188]	; 0xbc
		if( pxCurrentTCB == NULL )
 8019e70:	686b      	ldr	r3, [r5, #4]
 8019e72:	2b00      	cmp	r3, #0
 8019e74:	d043      	beq.n	8019efe <xTaskCreate+0x142>
			if( xSchedulerRunning == pdFALSE )
 8019e76:	f8d5 3110 	ldr.w	r3, [r5, #272]	; 0x110
 8019e7a:	b373      	cbz	r3, 8019eda <xTaskCreate+0x11e>
		prvAddTaskToReadyList( pxNewTCB );
 8019e7c:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
 8019e7e:	f105 0730 	add.w	r7, r5, #48	; 0x30
		uxTaskNumber++;
 8019e82:	f8d5 3114 	ldr.w	r3, [r5, #276]	; 0x114
		prvAddTaskToReadyList( pxNewTCB );
 8019e86:	68aa      	ldr	r2, [r5, #8]
		uxTaskNumber++;
 8019e88:	3301      	adds	r3, #1
		prvAddTaskToReadyList( pxNewTCB );
 8019e8a:	2601      	movs	r6, #1
		uxTaskNumber++;
 8019e8c:	f8c5 3114 	str.w	r3, [r5, #276]	; 0x114
		prvAddTaskToReadyList( pxNewTCB );
 8019e90:	fa06 f300 	lsl.w	r3, r6, r0
 8019e94:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 8019e98:	4313      	orrs	r3, r2
 8019e9a:	4649      	mov	r1, r9
 8019e9c:	eb07 0080 	add.w	r0, r7, r0, lsl #2
 8019ea0:	60ab      	str	r3, [r5, #8]
 8019ea2:	f7ff fa05 	bl	80192b0 <vListInsertEnd>
	taskEXIT_CRITICAL();
 8019ea6:	f7ff f8bf 	bl	8019028 <vPortExitCritical>
	if( xSchedulerRunning != pdFALSE )
 8019eaa:	f8d5 3110 	ldr.w	r3, [r5, #272]	; 0x110
 8019eae:	b31b      	cbz	r3, 8019ef8 <xTaskCreate+0x13c>
		if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
 8019eb0:	686a      	ldr	r2, [r5, #4]
 8019eb2:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 8019eb4:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
 8019eb6:	429a      	cmp	r2, r3
 8019eb8:	d21e      	bcs.n	8019ef8 <xTaskCreate+0x13c>
			taskYIELD_IF_USING_PREEMPTION();
 8019eba:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
 8019ebe:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8019ec2:	f8c3 2d04 	str.w	r2, [r3, #3332]	; 0xd04
 8019ec6:	f3bf 8f4f 	dsb	sy
 8019eca:	f3bf 8f6f 	isb	sy
			xReturn = pdPASS;
 8019ece:	4630      	mov	r0, r6
 8019ed0:	e001      	b.n	8019ed6 <xTaskCreate+0x11a>
			xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
 8019ed2:	f04f 30ff 	mov.w	r0, #4294967295
	}
 8019ed6:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
				if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
 8019eda:	686b      	ldr	r3, [r5, #4]
 8019edc:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
 8019ede:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8019ee0:	4283      	cmp	r3, r0
					pxCurrentTCB = pxNewTCB;
 8019ee2:	bf98      	it	ls
 8019ee4:	606c      	strls	r4, [r5, #4]
 8019ee6:	f105 0730 	add.w	r7, r5, #48	; 0x30
 8019eea:	e7ca      	b.n	8019e82 <xTaskCreate+0xc6>
					vPortFree( pxStack );
 8019eec:	4628      	mov	r0, r5
 8019eee:	f7fe ffd9 	bl	8018ea4 <vPortFree>
			xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
 8019ef2:	f04f 30ff 	mov.w	r0, #4294967295
 8019ef6:	e7ee      	b.n	8019ed6 <xTaskCreate+0x11a>
			xReturn = pdPASS;
 8019ef8:	4630      	mov	r0, r6
	}
 8019efa:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
			pxCurrentTCB = pxNewTCB;
 8019efe:	606c      	str	r4, [r5, #4]
			if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
 8019f00:	f8d5 30bc 	ldr.w	r3, [r5, #188]	; 0xbc
 8019f04:	2b01      	cmp	r3, #1
 8019f06:	d1b9      	bne.n	8019e7c <xTaskCreate+0xc0>
 8019f08:	f105 0730 	add.w	r7, r5, #48	; 0x30
 8019f0c:	463e      	mov	r6, r7
 8019f0e:	f105 08bc 	add.w	r8, r5, #188	; 0xbc
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
 8019f12:	4630      	mov	r0, r6
	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
 8019f14:	3614      	adds	r6, #20
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
 8019f16:	f7ff f9bb 	bl	8019290 <vListInitialise>
	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
 8019f1a:	45b0      	cmp	r8, r6
 8019f1c:	d1f9      	bne.n	8019f12 <xTaskCreate+0x156>
	vListInitialise( &xDelayedTaskList1 );
 8019f1e:	4e0e      	ldr	r6, [pc, #56]	; (8019f58 <xTaskCreate+0x19c>)
 8019f20:	4630      	mov	r0, r6
	vListInitialise( &xDelayedTaskList2 );
 8019f22:	f106 0814 	add.w	r8, r6, #20
	vListInitialise( &xDelayedTaskList1 );
 8019f26:	f7ff f9b3 	bl	8019290 <vListInitialise>
	vListInitialise( &xDelayedTaskList2 );
 8019f2a:	4640      	mov	r0, r8
 8019f2c:	f7ff f9b0 	bl	8019290 <vListInitialise>
	vListInitialise( &xPendingReadyList );
 8019f30:	f106 0028 	add.w	r0, r6, #40	; 0x28
 8019f34:	f7ff f9ac 	bl	8019290 <vListInitialise>
		vListInitialise( &xTasksWaitingTermination );
 8019f38:	f106 003c 	add.w	r0, r6, #60	; 0x3c
 8019f3c:	f7ff f9a8 	bl	8019290 <vListInitialise>
		vListInitialise( &xSuspendedTaskList );
 8019f40:	f1a6 00b4 	sub.w	r0, r6, #180	; 0xb4
 8019f44:	f7ff f9a4 	bl	8019290 <vListInitialise>
	pxDelayedTaskList = &xDelayedTaskList1;
 8019f48:	626e      	str	r6, [r5, #36]	; 0x24
		prvAddTaskToReadyList( pxNewTCB );
 8019f4a:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
 8019f4c:	f8c5 8020 	str.w	r8, [r5, #32]
}
 8019f50:	e797      	b.n	8019e82 <xTaskCreate+0xc6>
 8019f52:	bf00      	nop
 8019f54:	20007f80 	.word	0x20007f80
 8019f58:	20008040 	.word	0x20008040

08019f5c <vTaskStartScheduler>:
{
 8019f5c:	b530      	push	{r4, r5, lr}
		xReturn = xTaskCreate(	prvIdleTask,
 8019f5e:	4d19      	ldr	r5, [pc, #100]	; (8019fc4 <vTaskStartScheduler+0x68>)
 8019f60:	4919      	ldr	r1, [pc, #100]	; (8019fc8 <vTaskStartScheduler+0x6c>)
 8019f62:	481a      	ldr	r0, [pc, #104]	; (8019fcc <vTaskStartScheduler+0x70>)
{
 8019f64:	b083      	sub	sp, #12
		xReturn = xTaskCreate(	prvIdleTask,
 8019f66:	2400      	movs	r4, #0
 8019f68:	f505 7390 	add.w	r3, r5, #288	; 0x120
 8019f6c:	e9cd 4300 	strd	r4, r3, [sp]
 8019f70:	2280      	movs	r2, #128	; 0x80
 8019f72:	4623      	mov	r3, r4
 8019f74:	f7ff ff22 	bl	8019dbc <xTaskCreate>
		if( xReturn == pdPASS )
 8019f78:	2801      	cmp	r0, #1
 8019f7a:	d00c      	beq.n	8019f96 <vTaskStartScheduler+0x3a>
		configASSERT( xReturn != errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY );
 8019f7c:	3001      	adds	r0, #1
 8019f7e:	d001      	beq.n	8019f84 <vTaskStartScheduler+0x28>
}
 8019f80:	b003      	add	sp, #12
 8019f82:	bd30      	pop	{r4, r5, pc}
 8019f84:	f04f 0350 	mov.w	r3, #80	; 0x50
 8019f88:	f383 8811 	msr	BASEPRI, r3
 8019f8c:	f3bf 8f6f 	isb	sy
 8019f90:	f3bf 8f4f 	dsb	sy
		configASSERT( xReturn != errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY );
 8019f94:	e7fe      	b.n	8019f94 <vTaskStartScheduler+0x38>
			xReturn = xTimerCreateTimerTask();
 8019f96:	f000 fc0f 	bl	801a7b8 <xTimerCreateTimerTask>
	if( xReturn == pdPASS )
 8019f9a:	2801      	cmp	r0, #1
 8019f9c:	d1ee      	bne.n	8019f7c <vTaskStartScheduler+0x20>
 8019f9e:	f04f 0350 	mov.w	r3, #80	; 0x50
 8019fa2:	f383 8811 	msr	BASEPRI, r3
 8019fa6:	f3bf 8f6f 	isb	sy
 8019faa:	f3bf 8f4f 	dsb	sy
		xNextTaskUnblockTime = portMAX_DELAY;
 8019fae:	f04f 33ff 	mov.w	r3, #4294967295
 8019fb2:	62ab      	str	r3, [r5, #40]	; 0x28
		xSchedulerRunning = pdTRUE;
 8019fb4:	f8c5 0110 	str.w	r0, [r5, #272]	; 0x110
		xTickCount = ( TickType_t ) 0U;
 8019fb8:	602c      	str	r4, [r5, #0]
}
 8019fba:	b003      	add	sp, #12
 8019fbc:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
		if( xPortStartScheduler() != pdFALSE )
 8019fc0:	f7ff b8b4 	b.w	801912c <xPortStartScheduler>
 8019fc4:	20007f80 	.word	0x20007f80
 8019fc8:	08041830 	.word	0x08041830
 8019fcc:	0801a1f5 	.word	0x0801a1f5

08019fd0 <vTaskSuspendAll>:
	++uxSchedulerSuspended;
 8019fd0:	4a03      	ldr	r2, [pc, #12]	; (8019fe0 <vTaskSuspendAll+0x10>)
 8019fd2:	f8d2 311c 	ldr.w	r3, [r2, #284]	; 0x11c
 8019fd6:	3301      	adds	r3, #1
 8019fd8:	f8c2 311c 	str.w	r3, [r2, #284]	; 0x11c
}
 8019fdc:	4770      	bx	lr
 8019fde:	bf00      	nop
 8019fe0:	20007f80 	.word	0x20007f80

08019fe4 <xTaskGetTickCount>:
		xTicks = xTickCount;
 8019fe4:	4b01      	ldr	r3, [pc, #4]	; (8019fec <xTaskGetTickCount+0x8>)
 8019fe6:	6818      	ldr	r0, [r3, #0]
}
 8019fe8:	4770      	bx	lr
 8019fea:	bf00      	nop
 8019fec:	20007f80 	.word	0x20007f80

08019ff0 <xTaskIncrementTick>:
{
 8019ff0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 8019ff4:	4c3e      	ldr	r4, [pc, #248]	; (801a0f0 <xTaskIncrementTick+0x100>)
 8019ff6:	f8d4 311c 	ldr.w	r3, [r4, #284]	; 0x11c
 8019ffa:	b97b      	cbnz	r3, 801a01c <xTaskIncrementTick+0x2c>
		const TickType_t xConstTickCount = xTickCount + ( TickType_t ) 1;
 8019ffc:	6827      	ldr	r7, [r4, #0]
 8019ffe:	3701      	adds	r7, #1
		xTickCount = xConstTickCount;
 801a000:	6027      	str	r7, [r4, #0]
		if( xConstTickCount == ( TickType_t ) 0U ) /*lint !e774 'if' does not always evaluate to false as it is looking for an overflow. */
 801a002:	bb57      	cbnz	r7, 801a05a <xTaskIncrementTick+0x6a>
			taskSWITCH_DELAYED_LISTS();
 801a004:	6a63      	ldr	r3, [r4, #36]	; 0x24
 801a006:	681b      	ldr	r3, [r3, #0]
 801a008:	b1ab      	cbz	r3, 801a036 <xTaskIncrementTick+0x46>
 801a00a:	f04f 0350 	mov.w	r3, #80	; 0x50
 801a00e:	f383 8811 	msr	BASEPRI, r3
 801a012:	f3bf 8f6f 	isb	sy
 801a016:	f3bf 8f4f 	dsb	sy
 801a01a:	e7fe      	b.n	801a01a <xTaskIncrementTick+0x2a>
		++uxPendedTicks;
 801a01c:	f8d4 3128 	ldr.w	r3, [r4, #296]	; 0x128
 801a020:	3301      	adds	r3, #1
BaseType_t xSwitchRequired = pdFALSE;
 801a022:	2600      	movs	r6, #0
		++uxPendedTicks;
 801a024:	f8c4 3128 	str.w	r3, [r4, #296]	; 0x128
		if( xYieldPending != pdFALSE )
 801a028:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
			xSwitchRequired = pdTRUE;
 801a02a:	2b00      	cmp	r3, #0
}
 801a02c:	bf0c      	ite	eq
 801a02e:	4630      	moveq	r0, r6
 801a030:	2001      	movne	r0, #1
 801a032:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
			taskSWITCH_DELAYED_LISTS();
 801a036:	6a63      	ldr	r3, [r4, #36]	; 0x24
 801a038:	6a22      	ldr	r2, [r4, #32]
 801a03a:	6262      	str	r2, [r4, #36]	; 0x24
 801a03c:	6223      	str	r3, [r4, #32]
 801a03e:	f8d4 3124 	ldr.w	r3, [r4, #292]	; 0x124
 801a042:	3301      	adds	r3, #1
 801a044:	f8c4 3124 	str.w	r3, [r4, #292]	; 0x124
	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 801a048:	6a63      	ldr	r3, [r4, #36]	; 0x24
 801a04a:	681b      	ldr	r3, [r3, #0]
 801a04c:	2b00      	cmp	r3, #0
 801a04e:	d04a      	beq.n	801a0e6 <xTaskIncrementTick+0xf6>
		( pxTCB ) = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
 801a050:	6a63      	ldr	r3, [r4, #36]	; 0x24
 801a052:	68db      	ldr	r3, [r3, #12]
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
 801a054:	68db      	ldr	r3, [r3, #12]
 801a056:	685b      	ldr	r3, [r3, #4]
 801a058:	62a3      	str	r3, [r4, #40]	; 0x28
		if( xConstTickCount >= xNextTaskUnblockTime )
 801a05a:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 801a05c:	42bb      	cmp	r3, r7
 801a05e:	d832      	bhi.n	801a0c6 <xTaskIncrementTick+0xd6>
				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 801a060:	6a63      	ldr	r3, [r4, #36]	; 0x24
 801a062:	681e      	ldr	r6, [r3, #0]
 801a064:	2e00      	cmp	r6, #0
 801a066:	d03a      	beq.n	801a0de <xTaskIncrementTick+0xee>
					prvAddTaskToReadyList( pxTCB );
 801a068:	f8df 9088 	ldr.w	r9, [pc, #136]	; 801a0f4 <xTaskIncrementTick+0x104>
BaseType_t xSwitchRequired = pdFALSE;
 801a06c:	2600      	movs	r6, #0
					prvAddTaskToReadyList( pxTCB );
 801a06e:	f04f 0801 	mov.w	r8, #1
 801a072:	e01d      	b.n	801a0b0 <xTaskIncrementTick+0xc0>
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 801a074:	f7ff f944 	bl	8019300 <uxListRemove>
					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
 801a078:	6aab      	ldr	r3, [r5, #40]	; 0x28
						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 801a07a:	f105 0018 	add.w	r0, r5, #24
					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
 801a07e:	b10b      	cbz	r3, 801a084 <xTaskIncrementTick+0x94>
						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 801a080:	f7ff f93e 	bl	8019300 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
 801a084:	6ae8      	ldr	r0, [r5, #44]	; 0x2c
 801a086:	68a2      	ldr	r2, [r4, #8]
 801a088:	fa08 f300 	lsl.w	r3, r8, r0
 801a08c:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 801a090:	4313      	orrs	r3, r2
 801a092:	4651      	mov	r1, sl
 801a094:	eb09 0080 	add.w	r0, r9, r0, lsl #2
 801a098:	60a3      	str	r3, [r4, #8]
 801a09a:	f7ff f909 	bl	80192b0 <vListInsertEnd>
						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 801a09e:	6862      	ldr	r2, [r4, #4]
				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 801a0a0:	6a63      	ldr	r3, [r4, #36]	; 0x24
						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 801a0a2:	6ae9      	ldr	r1, [r5, #44]	; 0x2c
 801a0a4:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 801a0a6:	681b      	ldr	r3, [r3, #0]
							xSwitchRequired = pdTRUE;
 801a0a8:	4291      	cmp	r1, r2
 801a0aa:	bf28      	it	cs
 801a0ac:	2601      	movcs	r6, #1
				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 801a0ae:	b1b3      	cbz	r3, 801a0de <xTaskIncrementTick+0xee>
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
 801a0b0:	6a63      	ldr	r3, [r4, #36]	; 0x24
 801a0b2:	68db      	ldr	r3, [r3, #12]
 801a0b4:	68dd      	ldr	r5, [r3, #12]
					xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
 801a0b6:	686b      	ldr	r3, [r5, #4]
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 801a0b8:	f105 0a04 	add.w	sl, r5, #4
					if( xConstTickCount < xItemValue )
 801a0bc:	429f      	cmp	r7, r3
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 801a0be:	4650      	mov	r0, sl
					if( xConstTickCount < xItemValue )
 801a0c0:	d2d8      	bcs.n	801a074 <xTaskIncrementTick+0x84>
						xNextTaskUnblockTime = xItemValue;
 801a0c2:	62a3      	str	r3, [r4, #40]	; 0x28
						break;
 801a0c4:	e000      	b.n	801a0c8 <xTaskIncrementTick+0xd8>
BaseType_t xSwitchRequired = pdFALSE;
 801a0c6:	2600      	movs	r6, #0
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
 801a0c8:	6863      	ldr	r3, [r4, #4]
 801a0ca:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 801a0cc:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 801a0d0:	eb04 0383 	add.w	r3, r4, r3, lsl #2
 801a0d4:	6b1b      	ldr	r3, [r3, #48]	; 0x30
				xSwitchRequired = pdTRUE;
 801a0d6:	2b02      	cmp	r3, #2
 801a0d8:	bf28      	it	cs
 801a0da:	2601      	movcs	r6, #1
 801a0dc:	e7a4      	b.n	801a028 <xTaskIncrementTick+0x38>
					xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 801a0de:	f04f 33ff 	mov.w	r3, #4294967295
 801a0e2:	62a3      	str	r3, [r4, #40]	; 0x28
					break;
 801a0e4:	e7f0      	b.n	801a0c8 <xTaskIncrementTick+0xd8>
		xNextTaskUnblockTime = portMAX_DELAY;
 801a0e6:	f04f 33ff 	mov.w	r3, #4294967295
 801a0ea:	62a3      	str	r3, [r4, #40]	; 0x28
 801a0ec:	e7b5      	b.n	801a05a <xTaskIncrementTick+0x6a>
 801a0ee:	bf00      	nop
 801a0f0:	20007f80 	.word	0x20007f80
 801a0f4:	20007fb0 	.word	0x20007fb0

0801a0f8 <xTaskResumeAll.part.0>:
BaseType_t xTaskResumeAll( void )
 801a0f8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
		--uxSchedulerSuspended;
 801a0fc:	4c33      	ldr	r4, [pc, #204]	; (801a1cc <xTaskResumeAll.part.0+0xd4>)
BaseType_t xTaskResumeAll( void )
 801a0fe:	b082      	sub	sp, #8
	taskENTER_CRITICAL();
 801a100:	f7fe ff70 	bl	8018fe4 <vPortEnterCritical>
		--uxSchedulerSuspended;
 801a104:	f8d4 311c 	ldr.w	r3, [r4, #284]	; 0x11c
 801a108:	3b01      	subs	r3, #1
 801a10a:	f8c4 311c 	str.w	r3, [r4, #284]	; 0x11c
		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 801a10e:	f8d4 311c 	ldr.w	r3, [r4, #284]	; 0x11c
 801a112:	2b00      	cmp	r3, #0
 801a114:	d140      	bne.n	801a198 <xTaskResumeAll.part.0+0xa0>
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
 801a116:	f8d4 30bc 	ldr.w	r3, [r4, #188]	; 0xbc
 801a11a:	2b00      	cmp	r3, #0
 801a11c:	d03c      	beq.n	801a198 <xTaskResumeAll.part.0+0xa0>
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
 801a11e:	f8d4 30e8 	ldr.w	r3, [r4, #232]	; 0xe8
 801a122:	b35b      	cbz	r3, 801a17c <xTaskResumeAll.part.0+0x84>
 801a124:	f104 0730 	add.w	r7, r4, #48	; 0x30
					prvAddTaskToReadyList( pxTCB );
 801a128:	2601      	movs	r6, #1
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
 801a12a:	f8d4 30f4 	ldr.w	r3, [r4, #244]	; 0xf4
 801a12e:	68dd      	ldr	r5, [r3, #12]
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 801a130:	f105 0804 	add.w	r8, r5, #4
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 801a134:	f105 0018 	add.w	r0, r5, #24
 801a138:	f7ff f8e2 	bl	8019300 <uxListRemove>
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 801a13c:	4640      	mov	r0, r8
 801a13e:	f7ff f8df 	bl	8019300 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
 801a142:	6ae8      	ldr	r0, [r5, #44]	; 0x2c
 801a144:	68a2      	ldr	r2, [r4, #8]
 801a146:	fa06 f300 	lsl.w	r3, r6, r0
 801a14a:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 801a14e:	4313      	orrs	r3, r2
 801a150:	4641      	mov	r1, r8
 801a152:	eb07 0080 	add.w	r0, r7, r0, lsl #2
 801a156:	60a3      	str	r3, [r4, #8]
 801a158:	f7ff f8aa 	bl	80192b0 <vListInsertEnd>
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 801a15c:	6863      	ldr	r3, [r4, #4]
 801a15e:	6aea      	ldr	r2, [r5, #44]	; 0x2c
 801a160:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 801a162:	429a      	cmp	r2, r3
						xYieldPending = pdTRUE;
 801a164:	bf28      	it	cs
 801a166:	62e6      	strcs	r6, [r4, #44]	; 0x2c
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
 801a168:	f8d4 30e8 	ldr.w	r3, [r4, #232]	; 0xe8
 801a16c:	2b00      	cmp	r3, #0
 801a16e:	d1dc      	bne.n	801a12a <xTaskResumeAll.part.0+0x32>
	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 801a170:	6a63      	ldr	r3, [r4, #36]	; 0x24
 801a172:	681b      	ldr	r3, [r3, #0]
 801a174:	bb23      	cbnz	r3, 801a1c0 <xTaskResumeAll.part.0+0xc8>
		xNextTaskUnblockTime = portMAX_DELAY;
 801a176:	f04f 33ff 	mov.w	r3, #4294967295
 801a17a:	62a3      	str	r3, [r4, #40]	; 0x28
					UBaseType_t uxPendedCounts = uxPendedTicks; /* Non-volatile copy. */
 801a17c:	f8d4 5128 	ldr.w	r5, [r4, #296]	; 0x128
					if( uxPendedCounts > ( UBaseType_t ) 0U )
 801a180:	b145      	cbz	r5, 801a194 <xTaskResumeAll.part.0+0x9c>
								xYieldPending = pdTRUE;
 801a182:	2601      	movs	r6, #1
							if( xTaskIncrementTick() != pdFALSE )
 801a184:	f7ff ff34 	bl	8019ff0 <xTaskIncrementTick>
 801a188:	b100      	cbz	r0, 801a18c <xTaskResumeAll.part.0+0x94>
								xYieldPending = pdTRUE;
 801a18a:	62e6      	str	r6, [r4, #44]	; 0x2c
						} while( uxPendedCounts > ( UBaseType_t ) 0U );
 801a18c:	3d01      	subs	r5, #1
 801a18e:	d1f9      	bne.n	801a184 <xTaskResumeAll.part.0+0x8c>
						uxPendedTicks = 0;
 801a190:	f8c4 5128 	str.w	r5, [r4, #296]	; 0x128
				if( xYieldPending != pdFALSE )
 801a194:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 801a196:	b93b      	cbnz	r3, 801a1a8 <xTaskResumeAll.part.0+0xb0>
BaseType_t xAlreadyYielded = pdFALSE;
 801a198:	2000      	movs	r0, #0
 801a19a:	9001      	str	r0, [sp, #4]
	taskEXIT_CRITICAL();
 801a19c:	f7fe ff44 	bl	8019028 <vPortExitCritical>
}
 801a1a0:	9801      	ldr	r0, [sp, #4]
 801a1a2:	b002      	add	sp, #8
 801a1a4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
					taskYIELD_IF_USING_PREEMPTION();
 801a1a8:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
 801a1ac:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 801a1b0:	f8c3 2d04 	str.w	r2, [r3, #3332]	; 0xd04
 801a1b4:	f3bf 8f4f 	dsb	sy
 801a1b8:	f3bf 8f6f 	isb	sy
						xAlreadyYielded = pdTRUE;
 801a1bc:	2001      	movs	r0, #1
 801a1be:	e7ec      	b.n	801a19a <xTaskResumeAll.part.0+0xa2>
		( pxTCB ) = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
 801a1c0:	6a63      	ldr	r3, [r4, #36]	; 0x24
 801a1c2:	68db      	ldr	r3, [r3, #12]
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
 801a1c4:	68db      	ldr	r3, [r3, #12]
 801a1c6:	685b      	ldr	r3, [r3, #4]
 801a1c8:	62a3      	str	r3, [r4, #40]	; 0x28
}
 801a1ca:	e7d7      	b.n	801a17c <xTaskResumeAll.part.0+0x84>
 801a1cc:	20007f80 	.word	0x20007f80

0801a1d0 <xTaskResumeAll>:
	configASSERT( uxSchedulerSuspended );
 801a1d0:	4b07      	ldr	r3, [pc, #28]	; (801a1f0 <xTaskResumeAll+0x20>)
 801a1d2:	f8d3 311c 	ldr.w	r3, [r3, #284]	; 0x11c
 801a1d6:	b943      	cbnz	r3, 801a1ea <xTaskResumeAll+0x1a>
 801a1d8:	f04f 0350 	mov.w	r3, #80	; 0x50
 801a1dc:	f383 8811 	msr	BASEPRI, r3
 801a1e0:	f3bf 8f6f 	isb	sy
 801a1e4:	f3bf 8f4f 	dsb	sy
 801a1e8:	e7fe      	b.n	801a1e8 <xTaskResumeAll+0x18>
 801a1ea:	f7ff bf85 	b.w	801a0f8 <xTaskResumeAll.part.0>
 801a1ee:	bf00      	nop
 801a1f0:	20007f80 	.word	0x20007f80

0801a1f4 <prvIdleTask>:
{
 801a1f4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 801a1f6:	4c3c      	ldr	r4, [pc, #240]	; (801a2e8 <prvIdleTask+0xf4>)
				taskYIELD();
 801a1f8:	f04f 27e0 	mov.w	r7, #3758153728	; 0xe000e000
 801a1fc:	f04f 5680 	mov.w	r6, #268435456	; 0x10000000
 801a200:	e019      	b.n	801a236 <prvIdleTask+0x42>
			taskENTER_CRITICAL();
 801a202:	f7fe feef 	bl	8018fe4 <vPortEnterCritical>
				pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) );
 801a206:	f8d4 3108 	ldr.w	r3, [r4, #264]	; 0x108
 801a20a:	68dd      	ldr	r5, [r3, #12]
				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 801a20c:	1d28      	adds	r0, r5, #4
 801a20e:	f7ff f877 	bl	8019300 <uxListRemove>
				--uxCurrentNumberOfTasks;
 801a212:	f8d4 30bc 	ldr.w	r3, [r4, #188]	; 0xbc
 801a216:	3b01      	subs	r3, #1
 801a218:	f8c4 30bc 	str.w	r3, [r4, #188]	; 0xbc
				--uxDeletedTasksWaitingCleanUp;
 801a21c:	f8d4 3118 	ldr.w	r3, [r4, #280]	; 0x118
 801a220:	3b01      	subs	r3, #1
 801a222:	f8c4 3118 	str.w	r3, [r4, #280]	; 0x118
			taskEXIT_CRITICAL();
 801a226:	f7fe feff 	bl	8019028 <vPortExitCritical>
			vPortFree( pxTCB->pxStack );
 801a22a:	6b28      	ldr	r0, [r5, #48]	; 0x30
 801a22c:	f7fe fe3a 	bl	8018ea4 <vPortFree>
			vPortFree( pxTCB );
 801a230:	4628      	mov	r0, r5
 801a232:	f7fe fe37 	bl	8018ea4 <vPortFree>
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
 801a236:	f8d4 3118 	ldr.w	r3, [r4, #280]	; 0x118
 801a23a:	2b00      	cmp	r3, #0
 801a23c:	d1e1      	bne.n	801a202 <prvIdleTask+0xe>
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
 801a23e:	6b23      	ldr	r3, [r4, #48]	; 0x30
 801a240:	2b01      	cmp	r3, #1
 801a242:	d905      	bls.n	801a250 <prvIdleTask+0x5c>
				taskYIELD();
 801a244:	f8c7 6d04 	str.w	r6, [r7, #3332]	; 0xd04
 801a248:	f3bf 8f4f 	dsb	sy
 801a24c:	f3bf 8f6f 	isb	sy
			vApplicationIdleHook();
 801a250:	f004 ffec 	bl	801f22c <vApplicationIdleHook>
			if( uxTopReadyPriority > uxLeastSignificantBit )
 801a254:	68a3      	ldr	r3, [r4, #8]
 801a256:	2b01      	cmp	r3, #1
		if( pxCurrentTCB->uxPriority > tskIDLE_PRIORITY )
 801a258:	6863      	ldr	r3, [r4, #4]
 801a25a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
			if( uxTopReadyPriority > uxLeastSignificantBit )
 801a25c:	d903      	bls.n	801a266 <prvIdleTask+0x72>
		if( pxCurrentTCB->uxPriority > tskIDLE_PRIORITY )
 801a25e:	2b00      	cmp	r3, #0
 801a260:	d1e9      	bne.n	801a236 <prvIdleTask+0x42>
		else if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > 1 )
 801a262:	6b23      	ldr	r3, [r4, #48]	; 0x30
 801a264:	e7e7      	b.n	801a236 <prvIdleTask+0x42>
		if( pxCurrentTCB->uxPriority > tskIDLE_PRIORITY )
 801a266:	2b00      	cmp	r3, #0
 801a268:	d1e5      	bne.n	801a236 <prvIdleTask+0x42>
		else if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > 1 )
 801a26a:	6b23      	ldr	r3, [r4, #48]	; 0x30
 801a26c:	2b01      	cmp	r3, #1
 801a26e:	d8e2      	bhi.n	801a236 <prvIdleTask+0x42>
			xReturn = xNextTaskUnblockTime - xTickCount;
 801a270:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 801a272:	6822      	ldr	r2, [r4, #0]
 801a274:	1a9b      	subs	r3, r3, r2
			if( xExpectedIdleTime >= configEXPECTED_IDLE_TIME_BEFORE_SLEEP )
 801a276:	2b02      	cmp	r3, #2
 801a278:	d9dd      	bls.n	801a236 <prvIdleTask+0x42>
	++uxSchedulerSuspended;
 801a27a:	f8d4 311c 	ldr.w	r3, [r4, #284]	; 0x11c
 801a27e:	3301      	adds	r3, #1
 801a280:	f8c4 311c 	str.w	r3, [r4, #284]	; 0x11c
					configASSERT( xNextTaskUnblockTime >= xTickCount );
 801a284:	6aa2      	ldr	r2, [r4, #40]	; 0x28
 801a286:	6823      	ldr	r3, [r4, #0]
 801a288:	429a      	cmp	r2, r3
 801a28a:	d323      	bcc.n	801a2d4 <prvIdleTask+0xe0>
			if( uxTopReadyPriority > uxLeastSignificantBit )
 801a28c:	68a3      	ldr	r3, [r4, #8]
 801a28e:	2b01      	cmp	r3, #1
		if( pxCurrentTCB->uxPriority > tskIDLE_PRIORITY )
 801a290:	6863      	ldr	r3, [r4, #4]
 801a292:	6adb      	ldr	r3, [r3, #44]	; 0x2c
			if( uxTopReadyPriority > uxLeastSignificantBit )
 801a294:	d90c      	bls.n	801a2b0 <prvIdleTask+0xbc>
		if( pxCurrentTCB->uxPriority > tskIDLE_PRIORITY )
 801a296:	b1c3      	cbz	r3, 801a2ca <prvIdleTask+0xd6>
	configASSERT( uxSchedulerSuspended );
 801a298:	f8d4 311c 	ldr.w	r3, [r4, #284]	; 0x11c
 801a29c:	b9bb      	cbnz	r3, 801a2ce <prvIdleTask+0xda>
 801a29e:	f04f 0350 	mov.w	r3, #80	; 0x50
 801a2a2:	f383 8811 	msr	BASEPRI, r3
 801a2a6:	f3bf 8f6f 	isb	sy
 801a2aa:	f3bf 8f4f 	dsb	sy
 801a2ae:	e7fe      	b.n	801a2ae <prvIdleTask+0xba>
		if( pxCurrentTCB->uxPriority > tskIDLE_PRIORITY )
 801a2b0:	2b00      	cmp	r3, #0
 801a2b2:	d1f1      	bne.n	801a298 <prvIdleTask+0xa4>
		else if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > 1 )
 801a2b4:	6b23      	ldr	r3, [r4, #48]	; 0x30
 801a2b6:	2b01      	cmp	r3, #1
 801a2b8:	d8ee      	bhi.n	801a298 <prvIdleTask+0xa4>
			xReturn = xNextTaskUnblockTime - xTickCount;
 801a2ba:	6aa0      	ldr	r0, [r4, #40]	; 0x28
 801a2bc:	6823      	ldr	r3, [r4, #0]
 801a2be:	1ac0      	subs	r0, r0, r3
					if( xExpectedIdleTime >= configEXPECTED_IDLE_TIME_BEFORE_SLEEP )
 801a2c0:	2802      	cmp	r0, #2
 801a2c2:	d9e9      	bls.n	801a298 <prvIdleTask+0xa4>
						portSUPPRESS_TICKS_AND_SLEEP( xExpectedIdleTime );
 801a2c4:	f004 ffe2 	bl	801f28c <vPortSuppressTicksAndSleep>
						traceLOW_POWER_IDLE_END();
 801a2c8:	e7e6      	b.n	801a298 <prvIdleTask+0xa4>
		else if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > 1 )
 801a2ca:	6b23      	ldr	r3, [r4, #48]	; 0x30
 801a2cc:	e7e4      	b.n	801a298 <prvIdleTask+0xa4>
 801a2ce:	f7ff ff13 	bl	801a0f8 <xTaskResumeAll.part.0>
 801a2d2:	e7b0      	b.n	801a236 <prvIdleTask+0x42>
 801a2d4:	f04f 0350 	mov.w	r3, #80	; 0x50
 801a2d8:	f383 8811 	msr	BASEPRI, r3
 801a2dc:	f3bf 8f6f 	isb	sy
 801a2e0:	f3bf 8f4f 	dsb	sy
					configASSERT( xNextTaskUnblockTime >= xTickCount );
 801a2e4:	e7fe      	b.n	801a2e4 <prvIdleTask+0xf0>
 801a2e6:	bf00      	nop
 801a2e8:	20007f80 	.word	0x20007f80

0801a2ec <vTaskDelay>:
	{
 801a2ec:	b510      	push	{r4, lr}
		if( xTicksToDelay > ( TickType_t ) 0U )
 801a2ee:	b950      	cbnz	r0, 801a306 <vTaskDelay+0x1a>
			portYIELD_WITHIN_API();
 801a2f0:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
 801a2f4:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 801a2f8:	f8c3 2d04 	str.w	r2, [r3, #3332]	; 0xd04
 801a2fc:	f3bf 8f4f 	dsb	sy
 801a300:	f3bf 8f6f 	isb	sy
	}
 801a304:	bd10      	pop	{r4, pc}
			configASSERT( uxSchedulerSuspended == 0 );
 801a306:	4c12      	ldr	r4, [pc, #72]	; (801a350 <vTaskDelay+0x64>)
 801a308:	f8d4 111c 	ldr.w	r1, [r4, #284]	; 0x11c
 801a30c:	b141      	cbz	r1, 801a320 <vTaskDelay+0x34>
 801a30e:	f04f 0350 	mov.w	r3, #80	; 0x50
 801a312:	f383 8811 	msr	BASEPRI, r3
 801a316:	f3bf 8f6f 	isb	sy
 801a31a:	f3bf 8f4f 	dsb	sy
 801a31e:	e7fe      	b.n	801a31e <vTaskDelay+0x32>
	++uxSchedulerSuspended;
 801a320:	f8d4 311c 	ldr.w	r3, [r4, #284]	; 0x11c
 801a324:	3301      	adds	r3, #1
 801a326:	f8c4 311c 	str.w	r3, [r4, #284]	; 0x11c
				prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
 801a32a:	f7ff fccf 	bl	8019ccc <prvAddCurrentTaskToDelayedList>
	configASSERT( uxSchedulerSuspended );
 801a32e:	f8d4 311c 	ldr.w	r3, [r4, #284]	; 0x11c
 801a332:	b943      	cbnz	r3, 801a346 <vTaskDelay+0x5a>
 801a334:	f04f 0350 	mov.w	r3, #80	; 0x50
 801a338:	f383 8811 	msr	BASEPRI, r3
 801a33c:	f3bf 8f6f 	isb	sy
 801a340:	f3bf 8f4f 	dsb	sy
 801a344:	e7fe      	b.n	801a344 <vTaskDelay+0x58>
 801a346:	f7ff fed7 	bl	801a0f8 <xTaskResumeAll.part.0>
		if( xAlreadyYielded == pdFALSE )
 801a34a:	2800      	cmp	r0, #0
 801a34c:	d0d0      	beq.n	801a2f0 <vTaskDelay+0x4>
	}
 801a34e:	bd10      	pop	{r4, pc}
 801a350:	20007f80 	.word	0x20007f80

0801a354 <vTaskSwitchContext>:
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
 801a354:	4b04      	ldr	r3, [pc, #16]	; (801a368 <vTaskSwitchContext+0x14>)
 801a356:	f8d3 211c 	ldr.w	r2, [r3, #284]	; 0x11c
 801a35a:	b112      	cbz	r2, 801a362 <vTaskSwitchContext+0xe>
		xYieldPending = pdTRUE;
 801a35c:	2201      	movs	r2, #1
 801a35e:	62da      	str	r2, [r3, #44]	; 0x2c
}
 801a360:	4770      	bx	lr
 801a362:	f7ff bce9 	b.w	8019d38 <vTaskSwitchContext.part.0>
 801a366:	bf00      	nop
 801a368:	20007f80 	.word	0x20007f80

0801a36c <vTaskPlaceOnEventList>:
	configASSERT( pxEventList );
 801a36c:	b160      	cbz	r0, 801a388 <vTaskPlaceOnEventList+0x1c>
{
 801a36e:	b510      	push	{r4, lr}
	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
 801a370:	4b0a      	ldr	r3, [pc, #40]	; (801a39c <vTaskPlaceOnEventList+0x30>)
 801a372:	460c      	mov	r4, r1
 801a374:	6859      	ldr	r1, [r3, #4]
 801a376:	3118      	adds	r1, #24
 801a378:	f7fe ffaa 	bl	80192d0 <vListInsert>
	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
 801a37c:	4620      	mov	r0, r4
 801a37e:	2101      	movs	r1, #1
}
 801a380:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
 801a384:	f7ff bca2 	b.w	8019ccc <prvAddCurrentTaskToDelayedList>
 801a388:	f04f 0350 	mov.w	r3, #80	; 0x50
 801a38c:	f383 8811 	msr	BASEPRI, r3
 801a390:	f3bf 8f6f 	isb	sy
 801a394:	f3bf 8f4f 	dsb	sy
	configASSERT( pxEventList );
 801a398:	e7fe      	b.n	801a398 <vTaskPlaceOnEventList+0x2c>
 801a39a:	bf00      	nop
 801a39c:	20007f80 	.word	0x20007f80

0801a3a0 <vTaskPlaceOnEventListRestricted>:
	{
 801a3a0:	b538      	push	{r3, r4, r5, lr}
		configASSERT( pxEventList );
 801a3a2:	b180      	cbz	r0, 801a3c6 <vTaskPlaceOnEventListRestricted+0x26>
		vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
 801a3a4:	4b0c      	ldr	r3, [pc, #48]	; (801a3d8 <vTaskPlaceOnEventListRestricted+0x38>)
 801a3a6:	460d      	mov	r5, r1
 801a3a8:	6859      	ldr	r1, [r3, #4]
 801a3aa:	4614      	mov	r4, r2
 801a3ac:	3118      	adds	r1, #24
 801a3ae:	f7fe ff7f 	bl	80192b0 <vListInsertEnd>
			xTicksToWait = portMAX_DELAY;
 801a3b2:	2c00      	cmp	r4, #0
		prvAddCurrentTaskToDelayedList( xTicksToWait, xWaitIndefinitely );
 801a3b4:	4621      	mov	r1, r4
 801a3b6:	bf0c      	ite	eq
 801a3b8:	4628      	moveq	r0, r5
 801a3ba:	f04f 30ff 	movne.w	r0, #4294967295
	}
 801a3be:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
		prvAddCurrentTaskToDelayedList( xTicksToWait, xWaitIndefinitely );
 801a3c2:	f7ff bc83 	b.w	8019ccc <prvAddCurrentTaskToDelayedList>
 801a3c6:	f04f 0350 	mov.w	r3, #80	; 0x50
 801a3ca:	f383 8811 	msr	BASEPRI, r3
 801a3ce:	f3bf 8f6f 	isb	sy
 801a3d2:	f3bf 8f4f 	dsb	sy
		configASSERT( pxEventList );
 801a3d6:	e7fe      	b.n	801a3d6 <vTaskPlaceOnEventListRestricted+0x36>
 801a3d8:	20007f80 	.word	0x20007f80

0801a3dc <xTaskRemoveFromEventList>:
{
 801a3dc:	b570      	push	{r4, r5, r6, lr}
	pxUnblockedTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
 801a3de:	68c3      	ldr	r3, [r0, #12]
 801a3e0:	68dd      	ldr	r5, [r3, #12]
{
 801a3e2:	b082      	sub	sp, #8
	configASSERT( pxUnblockedTCB );
 801a3e4:	2d00      	cmp	r5, #0
 801a3e6:	d033      	beq.n	801a450 <xTaskRemoveFromEventList+0x74>
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 801a3e8:	4c21      	ldr	r4, [pc, #132]	; (801a470 <xTaskRemoveFromEventList+0x94>)
	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
 801a3ea:	f105 0618 	add.w	r6, r5, #24
 801a3ee:	4630      	mov	r0, r6
 801a3f0:	f7fe ff86 	bl	8019300 <uxListRemove>
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 801a3f4:	f8d4 311c 	ldr.w	r3, [r4, #284]	; 0x11c
 801a3f8:	b1ab      	cbz	r3, 801a426 <xTaskRemoveFromEventList+0x4a>
		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
 801a3fa:	4631      	mov	r1, r6
 801a3fc:	f104 00e8 	add.w	r0, r4, #232	; 0xe8
 801a400:	f7fe ff56 	bl	80192b0 <vListInsertEnd>
	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
 801a404:	6863      	ldr	r3, [r4, #4]
 801a406:	6aea      	ldr	r2, [r5, #44]	; 0x2c
 801a408:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 801a40a:	429a      	cmp	r2, r3
		xYieldPending = pdTRUE;
 801a40c:	bf84      	itt	hi
 801a40e:	2001      	movhi	r0, #1
 801a410:	62e0      	strhi	r0, [r4, #44]	; 0x2c
	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 801a412:	6a63      	ldr	r3, [r4, #36]	; 0x24
 801a414:	681b      	ldr	r3, [r3, #0]
		xReturn = pdFALSE;
 801a416:	bf98      	it	ls
 801a418:	2000      	movls	r0, #0
	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 801a41a:	bb13      	cbnz	r3, 801a462 <xTaskRemoveFromEventList+0x86>
		xNextTaskUnblockTime = portMAX_DELAY;
 801a41c:	f04f 33ff 	mov.w	r3, #4294967295
 801a420:	62a3      	str	r3, [r4, #40]	; 0x28
}
 801a422:	b002      	add	sp, #8
 801a424:	bd70      	pop	{r4, r5, r6, pc}
		( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
 801a426:	1d29      	adds	r1, r5, #4
 801a428:	4608      	mov	r0, r1
 801a42a:	9101      	str	r1, [sp, #4]
 801a42c:	f7fe ff68 	bl	8019300 <uxListRemove>
		prvAddTaskToReadyList( pxUnblockedTCB );
 801a430:	6ae8      	ldr	r0, [r5, #44]	; 0x2c
 801a432:	68a2      	ldr	r2, [r4, #8]
 801a434:	9901      	ldr	r1, [sp, #4]
 801a436:	2301      	movs	r3, #1
 801a438:	4083      	lsls	r3, r0
 801a43a:	4313      	orrs	r3, r2
 801a43c:	60a3      	str	r3, [r4, #8]
 801a43e:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 801a442:	f104 0330 	add.w	r3, r4, #48	; 0x30
 801a446:	eb03 0080 	add.w	r0, r3, r0, lsl #2
 801a44a:	f7fe ff31 	bl	80192b0 <vListInsertEnd>
 801a44e:	e7d9      	b.n	801a404 <xTaskRemoveFromEventList+0x28>
 801a450:	f04f 0350 	mov.w	r3, #80	; 0x50
 801a454:	f383 8811 	msr	BASEPRI, r3
 801a458:	f3bf 8f6f 	isb	sy
 801a45c:	f3bf 8f4f 	dsb	sy
	configASSERT( pxUnblockedTCB );
 801a460:	e7fe      	b.n	801a460 <xTaskRemoveFromEventList+0x84>
		( pxTCB ) = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
 801a462:	6a63      	ldr	r3, [r4, #36]	; 0x24
 801a464:	68db      	ldr	r3, [r3, #12]
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
 801a466:	68db      	ldr	r3, [r3, #12]
 801a468:	685b      	ldr	r3, [r3, #4]
 801a46a:	62a3      	str	r3, [r4, #40]	; 0x28
}
 801a46c:	b002      	add	sp, #8
 801a46e:	bd70      	pop	{r4, r5, r6, pc}
 801a470:	20007f80 	.word	0x20007f80

0801a474 <vTaskInternalSetTimeOutState>:
	pxTimeOut->xOverflowCount = xNumOfOverflows;
 801a474:	4b03      	ldr	r3, [pc, #12]	; (801a484 <vTaskInternalSetTimeOutState+0x10>)
 801a476:	f8d3 2124 	ldr.w	r2, [r3, #292]	; 0x124
	pxTimeOut->xTimeOnEntering = xTickCount;
 801a47a:	681b      	ldr	r3, [r3, #0]
 801a47c:	e9c0 2300 	strd	r2, r3, [r0]
}
 801a480:	4770      	bx	lr
 801a482:	bf00      	nop
 801a484:	20007f80 	.word	0x20007f80

0801a488 <xTaskCheckForTimeOut>:
	configASSERT( pxTimeOut );
 801a488:	b318      	cbz	r0, 801a4d2 <xTaskCheckForTimeOut+0x4a>
{
 801a48a:	b5f0      	push	{r4, r5, r6, r7, lr}
 801a48c:	460d      	mov	r5, r1
 801a48e:	b083      	sub	sp, #12
	configASSERT( pxTicksToWait );
 801a490:	b1b1      	cbz	r1, 801a4c0 <xTaskCheckForTimeOut+0x38>
 801a492:	4604      	mov	r4, r0
	taskENTER_CRITICAL();
 801a494:	f7fe fda6 	bl	8018fe4 <vPortEnterCritical>
			if( *pxTicksToWait == portMAX_DELAY )
 801a498:	682b      	ldr	r3, [r5, #0]
		const TickType_t xConstTickCount = xTickCount;
 801a49a:	4a1c      	ldr	r2, [pc, #112]	; (801a50c <xTaskCheckForTimeOut+0x84>)
			if( *pxTicksToWait == portMAX_DELAY )
 801a49c:	1c58      	adds	r0, r3, #1
		const TickType_t xConstTickCount = xTickCount;
 801a49e:	6811      	ldr	r1, [r2, #0]
			if( *pxTicksToWait == portMAX_DELAY )
 801a4a0:	d02e      	beq.n	801a500 <xTaskCheckForTimeOut+0x78>
		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
 801a4a2:	e9d4 7000 	ldrd	r7, r0, [r4]
 801a4a6:	f8d2 6124 	ldr.w	r6, [r2, #292]	; 0x124
 801a4aa:	42b7      	cmp	r7, r6
 801a4ac:	d01a      	beq.n	801a4e4 <xTaskCheckForTimeOut+0x5c>
 801a4ae:	4288      	cmp	r0, r1
 801a4b0:	d818      	bhi.n	801a4e4 <xTaskCheckForTimeOut+0x5c>
			xReturn = pdTRUE;
 801a4b2:	2001      	movs	r0, #1
 801a4b4:	9001      	str	r0, [sp, #4]
	taskEXIT_CRITICAL();
 801a4b6:	f7fe fdb7 	bl	8019028 <vPortExitCritical>
}
 801a4ba:	9801      	ldr	r0, [sp, #4]
 801a4bc:	b003      	add	sp, #12
 801a4be:	bdf0      	pop	{r4, r5, r6, r7, pc}
 801a4c0:	f04f 0350 	mov.w	r3, #80	; 0x50
 801a4c4:	f383 8811 	msr	BASEPRI, r3
 801a4c8:	f3bf 8f6f 	isb	sy
 801a4cc:	f3bf 8f4f 	dsb	sy
	configASSERT( pxTicksToWait );
 801a4d0:	e7fe      	b.n	801a4d0 <xTaskCheckForTimeOut+0x48>
 801a4d2:	f04f 0350 	mov.w	r3, #80	; 0x50
 801a4d6:	f383 8811 	msr	BASEPRI, r3
 801a4da:	f3bf 8f6f 	isb	sy
 801a4de:	f3bf 8f4f 	dsb	sy
	configASSERT( pxTimeOut );
 801a4e2:	e7fe      	b.n	801a4e2 <xTaskCheckForTimeOut+0x5a>
		const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
 801a4e4:	eba1 0c00 	sub.w	ip, r1, r0
		else if( xElapsedTime < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
 801a4e8:	4563      	cmp	r3, ip
 801a4ea:	d90b      	bls.n	801a504 <xTaskCheckForTimeOut+0x7c>
			*pxTicksToWait -= xElapsedTime;
 801a4ec:	1a5b      	subs	r3, r3, r1
	pxTimeOut->xOverflowCount = xNumOfOverflows;
 801a4ee:	f8d2 1124 	ldr.w	r1, [r2, #292]	; 0x124
	pxTimeOut->xTimeOnEntering = xTickCount;
 801a4f2:	6812      	ldr	r2, [r2, #0]
			*pxTicksToWait -= xElapsedTime;
 801a4f4:	4403      	add	r3, r0
 801a4f6:	602b      	str	r3, [r5, #0]
			xReturn = pdFALSE;
 801a4f8:	2000      	movs	r0, #0
	pxTimeOut->xTimeOnEntering = xTickCount;
 801a4fa:	e9c4 1200 	strd	r1, r2, [r4]
			xReturn = pdFALSE;
 801a4fe:	e7d9      	b.n	801a4b4 <xTaskCheckForTimeOut+0x2c>
				xReturn = pdFALSE;
 801a500:	2000      	movs	r0, #0
 801a502:	e7d7      	b.n	801a4b4 <xTaskCheckForTimeOut+0x2c>
			*pxTicksToWait = 0;
 801a504:	2300      	movs	r3, #0
 801a506:	602b      	str	r3, [r5, #0]
			xReturn = pdTRUE;
 801a508:	2001      	movs	r0, #1
 801a50a:	e7d3      	b.n	801a4b4 <xTaskCheckForTimeOut+0x2c>
 801a50c:	20007f80 	.word	0x20007f80

0801a510 <vTaskMissedYield>:
	xYieldPending = pdTRUE;
 801a510:	4b01      	ldr	r3, [pc, #4]	; (801a518 <vTaskMissedYield+0x8>)
 801a512:	2201      	movs	r2, #1
 801a514:	62da      	str	r2, [r3, #44]	; 0x2c
}
 801a516:	4770      	bx	lr
 801a518:	20007f80 	.word	0x20007f80

0801a51c <xTaskGetSchedulerState>:
		if( xSchedulerRunning == pdFALSE )
 801a51c:	4b06      	ldr	r3, [pc, #24]	; (801a538 <xTaskGetSchedulerState+0x1c>)
 801a51e:	f8d3 2110 	ldr.w	r2, [r3, #272]	; 0x110
 801a522:	b132      	cbz	r2, 801a532 <xTaskGetSchedulerState+0x16>
			if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 801a524:	f8d3 311c 	ldr.w	r3, [r3, #284]	; 0x11c
				xReturn = taskSCHEDULER_SUSPENDED;
 801a528:	2b00      	cmp	r3, #0
 801a52a:	bf0c      	ite	eq
 801a52c:	2002      	moveq	r0, #2
 801a52e:	2000      	movne	r0, #0
 801a530:	4770      	bx	lr
			xReturn = taskSCHEDULER_NOT_STARTED;
 801a532:	2001      	movs	r0, #1
	}
 801a534:	4770      	bx	lr
 801a536:	bf00      	nop
 801a538:	20007f80 	.word	0x20007f80

0801a53c <xTaskPriorityInherit>:
	{
 801a53c:	b570      	push	{r4, r5, r6, lr}
		if( pxMutexHolder != NULL )
 801a53e:	4604      	mov	r4, r0
	{
 801a540:	b082      	sub	sp, #8
		if( pxMutexHolder != NULL )
 801a542:	b1c8      	cbz	r0, 801a578 <xTaskPriorityInherit+0x3c>
			if( pxMutexHolderTCB->uxPriority < pxCurrentTCB->uxPriority )
 801a544:	4d25      	ldr	r5, [pc, #148]	; (801a5dc <xTaskPriorityInherit+0xa0>)
 801a546:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
 801a548:	686a      	ldr	r2, [r5, #4]
 801a54a:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
 801a54c:	4293      	cmp	r3, r2
 801a54e:	d215      	bcs.n	801a57c <xTaskPriorityInherit+0x40>
				if( ( listGET_LIST_ITEM_VALUE( &( pxMutexHolderTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
 801a550:	6982      	ldr	r2, [r0, #24]
 801a552:	2a00      	cmp	r2, #0
 801a554:	db04      	blt.n	801a560 <xTaskPriorityInherit+0x24>
					listSET_LIST_ITEM_VALUE( &( pxMutexHolderTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 801a556:	686a      	ldr	r2, [r5, #4]
 801a558:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
 801a55a:	f1c2 0207 	rsb	r2, r2, #7
 801a55e:	6182      	str	r2, [r0, #24]
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxMutexHolderTCB->uxPriority ] ), &( pxMutexHolderTCB->xStateListItem ) ) != pdFALSE )
 801a560:	4e1f      	ldr	r6, [pc, #124]	; (801a5e0 <xTaskPriorityInherit+0xa4>)
 801a562:	6962      	ldr	r2, [r4, #20]
 801a564:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 801a568:	eb06 0383 	add.w	r3, r6, r3, lsl #2
 801a56c:	429a      	cmp	r2, r3
 801a56e:	d00e      	beq.n	801a58e <xTaskPriorityInherit+0x52>
					pxMutexHolderTCB->uxPriority = pxCurrentTCB->uxPriority;
 801a570:	686b      	ldr	r3, [r5, #4]
 801a572:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 801a574:	62e3      	str	r3, [r4, #44]	; 0x2c
				xReturn = pdTRUE;
 801a576:	2001      	movs	r0, #1
	}
 801a578:	b002      	add	sp, #8
 801a57a:	bd70      	pop	{r4, r5, r6, pc}
				if( pxMutexHolderTCB->uxBasePriority < pxCurrentTCB->uxPriority )
 801a57c:	686b      	ldr	r3, [r5, #4]
 801a57e:	6c40      	ldr	r0, [r0, #68]	; 0x44
 801a580:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 801a582:	4298      	cmp	r0, r3
 801a584:	bf2c      	ite	cs
 801a586:	2000      	movcs	r0, #0
 801a588:	2001      	movcc	r0, #1
	}
 801a58a:	b002      	add	sp, #8
 801a58c:	bd70      	pop	{r4, r5, r6, pc}
					if( uxListRemove( &( pxMutexHolderTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 801a58e:	1d21      	adds	r1, r4, #4
 801a590:	4608      	mov	r0, r1
 801a592:	9101      	str	r1, [sp, #4]
 801a594:	f7fe feb4 	bl	8019300 <uxListRemove>
 801a598:	9901      	ldr	r1, [sp, #4]
 801a59a:	b968      	cbnz	r0, 801a5b8 <xTaskPriorityInherit+0x7c>
						taskRESET_READY_PRIORITY( pxMutexHolderTCB->uxPriority );
 801a59c:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 801a59e:	eb02 0382 	add.w	r3, r2, r2, lsl #2
 801a5a2:	eb05 0383 	add.w	r3, r5, r3, lsl #2
 801a5a6:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 801a5a8:	b933      	cbnz	r3, 801a5b8 <xTaskPriorityInherit+0x7c>
 801a5aa:	68ab      	ldr	r3, [r5, #8]
 801a5ac:	2001      	movs	r0, #1
 801a5ae:	fa00 f202 	lsl.w	r2, r0, r2
 801a5b2:	ea23 0302 	bic.w	r3, r3, r2
 801a5b6:	60ab      	str	r3, [r5, #8]
					pxMutexHolderTCB->uxPriority = pxCurrentTCB->uxPriority;
 801a5b8:	686b      	ldr	r3, [r5, #4]
					prvAddTaskToReadyList( pxMutexHolderTCB );
 801a5ba:	68aa      	ldr	r2, [r5, #8]
					pxMutexHolderTCB->uxPriority = pxCurrentTCB->uxPriority;
 801a5bc:	6ad8      	ldr	r0, [r3, #44]	; 0x2c
 801a5be:	62e0      	str	r0, [r4, #44]	; 0x2c
					prvAddTaskToReadyList( pxMutexHolderTCB );
 801a5c0:	2401      	movs	r4, #1
 801a5c2:	fa04 f300 	lsl.w	r3, r4, r0
 801a5c6:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 801a5ca:	4313      	orrs	r3, r2
 801a5cc:	eb06 0080 	add.w	r0, r6, r0, lsl #2
 801a5d0:	60ab      	str	r3, [r5, #8]
 801a5d2:	f7fe fe6d 	bl	80192b0 <vListInsertEnd>
				xReturn = pdTRUE;
 801a5d6:	4620      	mov	r0, r4
 801a5d8:	e7ce      	b.n	801a578 <xTaskPriorityInherit+0x3c>
 801a5da:	bf00      	nop
 801a5dc:	20007f80 	.word	0x20007f80
 801a5e0:	20007fb0 	.word	0x20007fb0

0801a5e4 <xTaskPriorityDisinherit>:
		if( pxMutexHolder != NULL )
 801a5e4:	b320      	cbz	r0, 801a630 <xTaskPriorityDisinherit+0x4c>
	{
 801a5e6:	b570      	push	{r4, r5, r6, lr}
			configASSERT( pxTCB == pxCurrentTCB );
 801a5e8:	4d26      	ldr	r5, [pc, #152]	; (801a684 <xTaskPriorityDisinherit+0xa0>)
 801a5ea:	686b      	ldr	r3, [r5, #4]
 801a5ec:	4283      	cmp	r3, r0
	{
 801a5ee:	b082      	sub	sp, #8
 801a5f0:	4604      	mov	r4, r0
			configASSERT( pxTCB == pxCurrentTCB );
 801a5f2:	d008      	beq.n	801a606 <xTaskPriorityDisinherit+0x22>
 801a5f4:	f04f 0350 	mov.w	r3, #80	; 0x50
 801a5f8:	f383 8811 	msr	BASEPRI, r3
 801a5fc:	f3bf 8f6f 	isb	sy
 801a600:	f3bf 8f4f 	dsb	sy
 801a604:	e7fe      	b.n	801a604 <xTaskPriorityDisinherit+0x20>
			configASSERT( pxTCB->uxMutexesHeld );
 801a606:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 801a608:	b14b      	cbz	r3, 801a61e <xTaskPriorityDisinherit+0x3a>
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
 801a60a:	6ac1      	ldr	r1, [r0, #44]	; 0x2c
 801a60c:	6c42      	ldr	r2, [r0, #68]	; 0x44
			( pxTCB->uxMutexesHeld )--;
 801a60e:	3b01      	subs	r3, #1
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
 801a610:	4291      	cmp	r1, r2
			( pxTCB->uxMutexesHeld )--;
 801a612:	6483      	str	r3, [r0, #72]	; 0x48
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
 801a614:	d000      	beq.n	801a618 <xTaskPriorityDisinherit+0x34>
				if( pxTCB->uxMutexesHeld == ( UBaseType_t ) 0 )
 801a616:	b16b      	cbz	r3, 801a634 <xTaskPriorityDisinherit+0x50>
	BaseType_t xReturn = pdFALSE;
 801a618:	2000      	movs	r0, #0
	}
 801a61a:	b002      	add	sp, #8
 801a61c:	bd70      	pop	{r4, r5, r6, pc}
 801a61e:	f04f 0350 	mov.w	r3, #80	; 0x50
 801a622:	f383 8811 	msr	BASEPRI, r3
 801a626:	f3bf 8f6f 	isb	sy
 801a62a:	f3bf 8f4f 	dsb	sy
			configASSERT( pxTCB->uxMutexesHeld );
 801a62e:	e7fe      	b.n	801a62e <xTaskPriorityDisinherit+0x4a>
	BaseType_t xReturn = pdFALSE;
 801a630:	2000      	movs	r0, #0
	}
 801a632:	4770      	bx	lr
					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 801a634:	1d01      	adds	r1, r0, #4
 801a636:	4608      	mov	r0, r1
 801a638:	9101      	str	r1, [sp, #4]
 801a63a:	f7fe fe61 	bl	8019300 <uxListRemove>
 801a63e:	9901      	ldr	r1, [sp, #4]
 801a640:	b960      	cbnz	r0, 801a65c <xTaskPriorityDisinherit+0x78>
						taskRESET_READY_PRIORITY( pxTCB->uxPriority );
 801a642:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
 801a644:	eb00 0380 	add.w	r3, r0, r0, lsl #2
 801a648:	eb05 0383 	add.w	r3, r5, r3, lsl #2
 801a64c:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 801a64e:	b92b      	cbnz	r3, 801a65c <xTaskPriorityDisinherit+0x78>
 801a650:	68ab      	ldr	r3, [r5, #8]
 801a652:	2201      	movs	r2, #1
 801a654:	4082      	lsls	r2, r0
 801a656:	ea23 0302 	bic.w	r3, r3, r2
 801a65a:	60ab      	str	r3, [r5, #8]
					pxTCB->uxPriority = pxTCB->uxBasePriority;
 801a65c:	6c63      	ldr	r3, [r4, #68]	; 0x44
					prvAddTaskToReadyList( pxTCB );
 801a65e:	68ae      	ldr	r6, [r5, #8]
					pxTCB->uxPriority = pxTCB->uxBasePriority;
 801a660:	62e3      	str	r3, [r4, #44]	; 0x2c
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 801a662:	f1c3 0207 	rsb	r2, r3, #7
 801a666:	61a2      	str	r2, [r4, #24]
					prvAddTaskToReadyList( pxTCB );
 801a668:	4807      	ldr	r0, [pc, #28]	; (801a688 <xTaskPriorityDisinherit+0xa4>)
 801a66a:	2401      	movs	r4, #1
 801a66c:	fa04 f203 	lsl.w	r2, r4, r3
 801a670:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 801a674:	4332      	orrs	r2, r6
 801a676:	eb00 0083 	add.w	r0, r0, r3, lsl #2
 801a67a:	60aa      	str	r2, [r5, #8]
 801a67c:	f7fe fe18 	bl	80192b0 <vListInsertEnd>
					xReturn = pdTRUE;
 801a680:	4620      	mov	r0, r4
		return xReturn;
 801a682:	e7ca      	b.n	801a61a <xTaskPriorityDisinherit+0x36>
 801a684:	20007f80 	.word	0x20007f80
 801a688:	20007fb0 	.word	0x20007fb0

0801a68c <vTaskPriorityDisinheritAfterTimeout>:
		if( pxMutexHolder != NULL )
 801a68c:	2800      	cmp	r0, #0
 801a68e:	d042      	beq.n	801a716 <vTaskPriorityDisinheritAfterTimeout+0x8a>
	{
 801a690:	b570      	push	{r4, r5, r6, lr}
			configASSERT( pxTCB->uxMutexesHeld );
 801a692:	6c83      	ldr	r3, [r0, #72]	; 0x48
	{
 801a694:	b082      	sub	sp, #8
 801a696:	4604      	mov	r4, r0
			configASSERT( pxTCB->uxMutexesHeld );
 801a698:	b153      	cbz	r3, 801a6b0 <vTaskPriorityDisinheritAfterTimeout+0x24>
			if( pxTCB->uxBasePriority < uxHighestPriorityWaitingTask )
 801a69a:	6c40      	ldr	r0, [r0, #68]	; 0x44
			if( pxTCB->uxPriority != uxPriorityToUse )
 801a69c:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 801a69e:	4281      	cmp	r1, r0
 801a6a0:	bf38      	it	cc
 801a6a2:	4601      	movcc	r1, r0
 801a6a4:	428a      	cmp	r2, r1
 801a6a6:	d001      	beq.n	801a6ac <vTaskPriorityDisinheritAfterTimeout+0x20>
				if( pxTCB->uxMutexesHeld == uxOnlyOneMutexHeld )
 801a6a8:	2b01      	cmp	r3, #1
 801a6aa:	d00a      	beq.n	801a6c2 <vTaskPriorityDisinheritAfterTimeout+0x36>
	}
 801a6ac:	b002      	add	sp, #8
 801a6ae:	bd70      	pop	{r4, r5, r6, pc}
 801a6b0:	f04f 0350 	mov.w	r3, #80	; 0x50
 801a6b4:	f383 8811 	msr	BASEPRI, r3
 801a6b8:	f3bf 8f6f 	isb	sy
 801a6bc:	f3bf 8f4f 	dsb	sy
			configASSERT( pxTCB->uxMutexesHeld );
 801a6c0:	e7fe      	b.n	801a6c0 <vTaskPriorityDisinheritAfterTimeout+0x34>
					configASSERT( pxTCB != pxCurrentTCB );
 801a6c2:	4d22      	ldr	r5, [pc, #136]	; (801a74c <vTaskPriorityDisinheritAfterTimeout+0xc0>)
 801a6c4:	686b      	ldr	r3, [r5, #4]
 801a6c6:	42a3      	cmp	r3, r4
 801a6c8:	d026      	beq.n	801a718 <vTaskPriorityDisinheritAfterTimeout+0x8c>
					if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
 801a6ca:	69a3      	ldr	r3, [r4, #24]
					pxTCB->uxPriority = uxPriorityToUse;
 801a6cc:	62e1      	str	r1, [r4, #44]	; 0x2c
					if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
 801a6ce:	2b00      	cmp	r3, #0
						listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriorityToUse ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 801a6d0:	bfa8      	it	ge
 801a6d2:	f1c1 0107 	rsbge	r1, r1, #7
					if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xStateListItem ) ) != pdFALSE )
 801a6d6:	4e1e      	ldr	r6, [pc, #120]	; (801a750 <vTaskPriorityDisinheritAfterTimeout+0xc4>)
						listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriorityToUse ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 801a6d8:	bfa8      	it	ge
 801a6da:	61a1      	strge	r1, [r4, #24]
					if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xStateListItem ) ) != pdFALSE )
 801a6dc:	eb02 0282 	add.w	r2, r2, r2, lsl #2
 801a6e0:	6961      	ldr	r1, [r4, #20]
 801a6e2:	eb06 0382 	add.w	r3, r6, r2, lsl #2
 801a6e6:	4299      	cmp	r1, r3
 801a6e8:	d1e0      	bne.n	801a6ac <vTaskPriorityDisinheritAfterTimeout+0x20>
						if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 801a6ea:	1d21      	adds	r1, r4, #4
 801a6ec:	4608      	mov	r0, r1
 801a6ee:	9101      	str	r1, [sp, #4]
 801a6f0:	f7fe fe06 	bl	8019300 <uxListRemove>
 801a6f4:	9901      	ldr	r1, [sp, #4]
							taskRESET_READY_PRIORITY( pxTCB->uxPriority );
 801a6f6:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
						if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 801a6f8:	b1b8      	cbz	r0, 801a72a <vTaskPriorityDisinheritAfterTimeout+0x9e>
							taskRESET_READY_PRIORITY( pxTCB->uxPriority );
 801a6fa:	2301      	movs	r3, #1
 801a6fc:	4093      	lsls	r3, r2
 801a6fe:	0090      	lsls	r0, r2, #2
						prvAddTaskToReadyList( pxTCB );
 801a700:	4410      	add	r0, r2
 801a702:	68aa      	ldr	r2, [r5, #8]
 801a704:	eb06 0080 	add.w	r0, r6, r0, lsl #2
 801a708:	4313      	orrs	r3, r2
 801a70a:	60ab      	str	r3, [r5, #8]
	}
 801a70c:	b002      	add	sp, #8
 801a70e:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
						prvAddTaskToReadyList( pxTCB );
 801a712:	f7fe bdcd 	b.w	80192b0 <vListInsertEnd>
 801a716:	4770      	bx	lr
 801a718:	f04f 0350 	mov.w	r3, #80	; 0x50
 801a71c:	f383 8811 	msr	BASEPRI, r3
 801a720:	f3bf 8f6f 	isb	sy
 801a724:	f3bf 8f4f 	dsb	sy
					configASSERT( pxTCB != pxCurrentTCB );
 801a728:	e7fe      	b.n	801a728 <vTaskPriorityDisinheritAfterTimeout+0x9c>
							taskRESET_READY_PRIORITY( pxTCB->uxPriority );
 801a72a:	eb02 0382 	add.w	r3, r2, r2, lsl #2
 801a72e:	eb05 0383 	add.w	r3, r5, r3, lsl #2
 801a732:	0090      	lsls	r0, r2, #2
 801a734:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 801a736:	b113      	cbz	r3, 801a73e <vTaskPriorityDisinheritAfterTimeout+0xb2>
 801a738:	2301      	movs	r3, #1
 801a73a:	4093      	lsls	r3, r2
 801a73c:	e7e0      	b.n	801a700 <vTaskPriorityDisinheritAfterTimeout+0x74>
 801a73e:	68ac      	ldr	r4, [r5, #8]
 801a740:	2301      	movs	r3, #1
 801a742:	4093      	lsls	r3, r2
 801a744:	ea24 0403 	bic.w	r4, r4, r3
 801a748:	60ac      	str	r4, [r5, #8]
 801a74a:	e7d9      	b.n	801a700 <vTaskPriorityDisinheritAfterTimeout+0x74>
 801a74c:	20007f80 	.word	0x20007f80
 801a750:	20007fb0 	.word	0x20007fb0

0801a754 <pvTaskIncrementMutexHeldCount>:
		if( pxCurrentTCB != NULL )
 801a754:	4b04      	ldr	r3, [pc, #16]	; (801a768 <pvTaskIncrementMutexHeldCount+0x14>)
 801a756:	685a      	ldr	r2, [r3, #4]
 801a758:	b11a      	cbz	r2, 801a762 <pvTaskIncrementMutexHeldCount+0xe>
			( pxCurrentTCB->uxMutexesHeld )++;
 801a75a:	6859      	ldr	r1, [r3, #4]
 801a75c:	6c8a      	ldr	r2, [r1, #72]	; 0x48
 801a75e:	3201      	adds	r2, #1
 801a760:	648a      	str	r2, [r1, #72]	; 0x48
		return pxCurrentTCB;
 801a762:	6858      	ldr	r0, [r3, #4]
	}
 801a764:	4770      	bx	lr
 801a766:	bf00      	nop
 801a768:	20007f80 	.word	0x20007f80

0801a76c <prvCheckForValidListAndQueue>:
	pxOverflowTimerList = pxTemp;
}
/*-----------------------------------------------------------*/

static void prvCheckForValidListAndQueue( void )
{
 801a76c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	/* Check that the list from which active timers are referenced, and the
	queue used to communicate with the timer service, have been
	initialised. */
	taskENTER_CRITICAL();
	{
		if( xTimerQueue == NULL )
 801a76e:	4c10      	ldr	r4, [pc, #64]	; (801a7b0 <prvCheckForValidListAndQueue+0x44>)
	taskENTER_CRITICAL();
 801a770:	f7fe fc38 	bl	8018fe4 <vPortEnterCritical>
		if( xTimerQueue == NULL )
 801a774:	6825      	ldr	r5, [r4, #0]
 801a776:	b11d      	cbz	r5, 801a780 <prvCheckForValidListAndQueue+0x14>
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
}
 801a778:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
	taskEXIT_CRITICAL();
 801a77c:	f7fe bc54 	b.w	8019028 <vPortExitCritical>
			vListInitialise( &xActiveTimerList1 );
 801a780:	1d27      	adds	r7, r4, #4
 801a782:	4638      	mov	r0, r7
			vListInitialise( &xActiveTimerList2 );
 801a784:	f104 0618 	add.w	r6, r4, #24
			vListInitialise( &xActiveTimerList1 );
 801a788:	f7fe fd82 	bl	8019290 <vListInitialise>
			vListInitialise( &xActiveTimerList2 );
 801a78c:	4630      	mov	r0, r6
 801a78e:	f7fe fd7f 	bl	8019290 <vListInitialise>
				xTimerQueue = xQueueCreate( ( UBaseType_t ) configTIMER_QUEUE_LENGTH, sizeof( DaemonTaskMessage_t ) );
 801a792:	462a      	mov	r2, r5
 801a794:	210c      	movs	r1, #12
 801a796:	200a      	movs	r0, #10
			pxOverflowTimerList = &xActiveTimerList2;
 801a798:	e9c4 760b 	strd	r7, r6, [r4, #44]	; 0x2c
				xTimerQueue = xQueueCreate( ( UBaseType_t ) configTIMER_QUEUE_LENGTH, sizeof( DaemonTaskMessage_t ) );
 801a79c:	f7fe fe8c 	bl	80194b8 <xQueueGenericCreate>
 801a7a0:	6020      	str	r0, [r4, #0]
				if( xTimerQueue != NULL )
 801a7a2:	2800      	cmp	r0, #0
 801a7a4:	d0e8      	beq.n	801a778 <prvCheckForValidListAndQueue+0xc>
					vQueueAddToRegistry( xTimerQueue, "TmrQ" );
 801a7a6:	4903      	ldr	r1, [pc, #12]	; (801a7b4 <prvCheckForValidListAndQueue+0x48>)
 801a7a8:	f7ff fa52 	bl	8019c50 <vQueueAddToRegistry>
 801a7ac:	e7e4      	b.n	801a778 <prvCheckForValidListAndQueue+0xc>
 801a7ae:	bf00      	nop
 801a7b0:	200080ac 	.word	0x200080ac
 801a7b4:	08041838 	.word	0x08041838

0801a7b8 <xTimerCreateTimerTask>:
{
 801a7b8:	b500      	push	{lr}
 801a7ba:	b083      	sub	sp, #12
	prvCheckForValidListAndQueue();
 801a7bc:	f7ff ffd6 	bl	801a76c <prvCheckForValidListAndQueue>
	if( xTimerQueue != NULL )
 801a7c0:	4b0d      	ldr	r3, [pc, #52]	; (801a7f8 <xTimerCreateTimerTask+0x40>)
 801a7c2:	681a      	ldr	r2, [r3, #0]
 801a7c4:	b15a      	cbz	r2, 801a7de <xTimerCreateTimerTask+0x26>
			xReturn = xTaskCreate(	prvTimerTask,
 801a7c6:	3334      	adds	r3, #52	; 0x34
 801a7c8:	2202      	movs	r2, #2
 801a7ca:	e9cd 2300 	strd	r2, r3, [sp]
 801a7ce:	490b      	ldr	r1, [pc, #44]	; (801a7fc <xTimerCreateTimerTask+0x44>)
 801a7d0:	480b      	ldr	r0, [pc, #44]	; (801a800 <xTimerCreateTimerTask+0x48>)
 801a7d2:	2300      	movs	r3, #0
 801a7d4:	f44f 7280 	mov.w	r2, #256	; 0x100
 801a7d8:	f7ff faf0 	bl	8019dbc <xTaskCreate>
	configASSERT( xReturn );
 801a7dc:	b940      	cbnz	r0, 801a7f0 <xTimerCreateTimerTask+0x38>
 801a7de:	f04f 0350 	mov.w	r3, #80	; 0x50
 801a7e2:	f383 8811 	msr	BASEPRI, r3
 801a7e6:	f3bf 8f6f 	isb	sy
 801a7ea:	f3bf 8f4f 	dsb	sy
 801a7ee:	e7fe      	b.n	801a7ee <xTimerCreateTimerTask+0x36>
}
 801a7f0:	b003      	add	sp, #12
 801a7f2:	f85d fb04 	ldr.w	pc, [sp], #4
 801a7f6:	bf00      	nop
 801a7f8:	200080ac 	.word	0x200080ac
 801a7fc:	08041840 	.word	0x08041840
 801a800:	0801a93d 	.word	0x0801a93d

0801a804 <xTimerCreate>:
	{
 801a804:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 801a808:	4607      	mov	r7, r0
		pxNewTimer = ( Timer_t * ) pvPortMalloc( sizeof( Timer_t ) );
 801a80a:	2028      	movs	r0, #40	; 0x28
	{
 801a80c:	460d      	mov	r5, r1
 801a80e:	4690      	mov	r8, r2
 801a810:	461e      	mov	r6, r3
		pxNewTimer = ( Timer_t * ) pvPortMalloc( sizeof( Timer_t ) );
 801a812:	f7fe fac9 	bl	8018da8 <pvPortMalloc>
		if( pxNewTimer != NULL )
 801a816:	4604      	mov	r4, r0
 801a818:	b1a0      	cbz	r0, 801a844 <xTimerCreate+0x40>
	configASSERT( ( xTimerPeriodInTicks > 0 ) );
 801a81a:	b945      	cbnz	r5, 801a82e <xTimerCreate+0x2a>
 801a81c:	f04f 0350 	mov.w	r3, #80	; 0x50
 801a820:	f383 8811 	msr	BASEPRI, r3
 801a824:	f3bf 8f6f 	isb	sy
 801a828:	f3bf 8f4f 	dsb	sy
 801a82c:	e7fe      	b.n	801a82c <xTimerCreate+0x28>
		prvCheckForValidListAndQueue();
 801a82e:	f7ff ff9d 	bl	801a76c <prvCheckForValidListAndQueue>
		pxNewTimer->pxCallbackFunction = pxCallbackFunction;
 801a832:	9b06      	ldr	r3, [sp, #24]
		pxNewTimer->pcTimerName = pcTimerName;
 801a834:	6027      	str	r7, [r4, #0]
		pxNewTimer->uxAutoReload = uxAutoReload;
 801a836:	e9c4 5806 	strd	r5, r8, [r4, #24]
		pxNewTimer->pvTimerID = pvTimerID;
 801a83a:	6226      	str	r6, [r4, #32]
		pxNewTimer->pxCallbackFunction = pxCallbackFunction;
 801a83c:	6263      	str	r3, [r4, #36]	; 0x24
		vListInitialiseItem( &( pxNewTimer->xTimerListItem ) );
 801a83e:	1d20      	adds	r0, r4, #4
 801a840:	f7fe fd32 	bl	80192a8 <vListInitialiseItem>
	}
 801a844:	4620      	mov	r0, r4
 801a846:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 801a84a:	bf00      	nop

0801a84c <xTimerGenericCommand>:
	configASSERT( xTimer );
 801a84c:	b1c0      	cbz	r0, 801a880 <xTimerGenericCommand+0x34>
{
 801a84e:	b530      	push	{r4, r5, lr}
	if( xTimerQueue != NULL )
 801a850:	4d18      	ldr	r5, [pc, #96]	; (801a8b4 <xTimerGenericCommand+0x68>)
 801a852:	682c      	ldr	r4, [r5, #0]
{
 801a854:	b085      	sub	sp, #20
	if( xTimerQueue != NULL )
 801a856:	b184      	cbz	r4, 801a87a <xTimerGenericCommand+0x2e>
		if( xCommandID < tmrFIRST_FROM_ISR_COMMAND )
 801a858:	2905      	cmp	r1, #5
		xMessage.xMessageID = xCommandID;
 801a85a:	e9cd 1201 	strd	r1, r2, [sp, #4]
		xMessage.u.xTimerParameters.pxTimer = ( Timer_t * ) xTimer;
 801a85e:	9003      	str	r0, [sp, #12]
		if( xCommandID < tmrFIRST_FROM_ISR_COMMAND )
 801a860:	dc17      	bgt.n	801a892 <xTimerGenericCommand+0x46>
			if( xTaskGetSchedulerState() == taskSCHEDULER_RUNNING )
 801a862:	f7ff fe5b 	bl	801a51c <xTaskGetSchedulerState>
 801a866:	2802      	cmp	r0, #2
 801a868:	d01c      	beq.n	801a8a4 <xTimerGenericCommand+0x58>
				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, tmrNO_DELAY );
 801a86a:	2300      	movs	r3, #0
 801a86c:	6828      	ldr	r0, [r5, #0]
 801a86e:	461a      	mov	r2, r3
 801a870:	a901      	add	r1, sp, #4
 801a872:	f7fe fe73 	bl	801955c <xQueueGenericSend>
}
 801a876:	b005      	add	sp, #20
 801a878:	bd30      	pop	{r4, r5, pc}
BaseType_t xReturn = pdFAIL;
 801a87a:	4620      	mov	r0, r4
}
 801a87c:	b005      	add	sp, #20
 801a87e:	bd30      	pop	{r4, r5, pc}
 801a880:	f04f 0350 	mov.w	r3, #80	; 0x50
 801a884:	f383 8811 	msr	BASEPRI, r3
 801a888:	f3bf 8f6f 	isb	sy
 801a88c:	f3bf 8f4f 	dsb	sy
	configASSERT( xTimer );
 801a890:	e7fe      	b.n	801a890 <xTimerGenericCommand+0x44>
			xReturn = xQueueSendToBackFromISR( xTimerQueue, &xMessage, pxHigherPriorityTaskWoken );
 801a892:	469c      	mov	ip, r3
 801a894:	4662      	mov	r2, ip
 801a896:	2300      	movs	r3, #0
 801a898:	a901      	add	r1, sp, #4
 801a89a:	4620      	mov	r0, r4
 801a89c:	f7fe ff1e 	bl	80196dc <xQueueGenericSendFromISR>
}
 801a8a0:	b005      	add	sp, #20
 801a8a2:	bd30      	pop	{r4, r5, pc}
				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xTicksToWait );
 801a8a4:	6828      	ldr	r0, [r5, #0]
 801a8a6:	9a08      	ldr	r2, [sp, #32]
 801a8a8:	2300      	movs	r3, #0
 801a8aa:	a901      	add	r1, sp, #4
 801a8ac:	f7fe fe56 	bl	801955c <xQueueGenericSend>
 801a8b0:	e7e4      	b.n	801a87c <xTimerGenericCommand+0x30>
 801a8b2:	bf00      	nop
 801a8b4:	200080ac 	.word	0x200080ac

0801a8b8 <prvSwitchTimerLists>:
{
 801a8b8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 801a8bc:	4e1e      	ldr	r6, [pc, #120]	; (801a938 <prvSwitchTimerLists+0x80>)
 801a8be:	b082      	sub	sp, #8
				xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
 801a8c0:	f04f 0800 	mov.w	r8, #0
	while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
 801a8c4:	e00c      	b.n	801a8e0 <prvSwitchTimerLists+0x28>
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
 801a8c6:	68db      	ldr	r3, [r3, #12]
		pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList );
 801a8c8:	68dc      	ldr	r4, [r3, #12]
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
 801a8ca:	681f      	ldr	r7, [r3, #0]
		( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
 801a8cc:	1d25      	adds	r5, r4, #4
 801a8ce:	4628      	mov	r0, r5
 801a8d0:	f7fe fd16 	bl	8019300 <uxListRemove>
		pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
 801a8d4:	6a63      	ldr	r3, [r4, #36]	; 0x24
 801a8d6:	4620      	mov	r0, r4
 801a8d8:	4798      	blx	r3
		if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
 801a8da:	69e3      	ldr	r3, [r4, #28]
 801a8dc:	2b01      	cmp	r3, #1
 801a8de:	d009      	beq.n	801a8f4 <prvSwitchTimerLists+0x3c>
	while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
 801a8e0:	6af3      	ldr	r3, [r6, #44]	; 0x2c
 801a8e2:	681a      	ldr	r2, [r3, #0]
 801a8e4:	2a00      	cmp	r2, #0
 801a8e6:	d1ee      	bne.n	801a8c6 <prvSwitchTimerLists+0xe>
	pxCurrentTimerList = pxOverflowTimerList;
 801a8e8:	6b32      	ldr	r2, [r6, #48]	; 0x30
	pxOverflowTimerList = pxTemp;
 801a8ea:	e9c6 230b 	strd	r2, r3, [r6, #44]	; 0x2c
}
 801a8ee:	b002      	add	sp, #8
 801a8f0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
			xReloadTime = ( xNextExpireTime + pxTimer->xTimerPeriodInTicks );
 801a8f4:	69a2      	ldr	r2, [r4, #24]
 801a8f6:	eb07 0c02 	add.w	ip, r7, r2
			if( xReloadTime > xNextExpireTime )
 801a8fa:	4567      	cmp	r7, ip
				xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
 801a8fc:	f04f 0300 	mov.w	r3, #0
 801a900:	4620      	mov	r0, r4
 801a902:	463a      	mov	r2, r7
				vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
 801a904:	4629      	mov	r1, r5
			if( xReloadTime > xNextExpireTime )
 801a906:	d206      	bcs.n	801a916 <prvSwitchTimerLists+0x5e>
				vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
 801a908:	6af0      	ldr	r0, [r6, #44]	; 0x2c
				listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xReloadTime );
 801a90a:	f8c4 c004 	str.w	ip, [r4, #4]
				listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
 801a90e:	6124      	str	r4, [r4, #16]
				vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
 801a910:	f7fe fcde 	bl	80192d0 <vListInsert>
 801a914:	e7e4      	b.n	801a8e0 <prvSwitchTimerLists+0x28>
				xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
 801a916:	f8cd 8000 	str.w	r8, [sp]
 801a91a:	4619      	mov	r1, r3
 801a91c:	f7ff ff96 	bl	801a84c <xTimerGenericCommand>
				configASSERT( xResult );
 801a920:	2800      	cmp	r0, #0
 801a922:	d1dd      	bne.n	801a8e0 <prvSwitchTimerLists+0x28>
 801a924:	f04f 0350 	mov.w	r3, #80	; 0x50
 801a928:	f383 8811 	msr	BASEPRI, r3
 801a92c:	f3bf 8f6f 	isb	sy
 801a930:	f3bf 8f4f 	dsb	sy
 801a934:	e7fe      	b.n	801a934 <prvSwitchTimerLists+0x7c>
 801a936:	bf00      	nop
 801a938:	200080ac 	.word	0x200080ac

0801a93c <prvTimerTask>:
{
 801a93c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 801a940:	4c7e      	ldr	r4, [pc, #504]	; (801ab3c <prvTimerTask+0x200>)
 801a942:	b087      	sub	sp, #28
					portYIELD_WITHIN_API();
 801a944:	f04f 27e0 	mov.w	r7, #3758153728	; 0xe000e000
 801a948:	f04f 5980 	mov.w	r9, #268435456	; 0x10000000
 801a94c:	f04f 0800 	mov.w	r8, #0
	*pxListWasEmpty = listLIST_IS_EMPTY( pxCurrentTimerList );
 801a950:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 801a952:	681e      	ldr	r6, [r3, #0]
	if( *pxListWasEmpty == pdFALSE )
 801a954:	2e00      	cmp	r6, #0
 801a956:	f000 8089 	beq.w	801aa6c <prvTimerTask+0x130>
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
 801a95a:	68db      	ldr	r3, [r3, #12]
 801a95c:	681e      	ldr	r6, [r3, #0]
	vTaskSuspendAll();
 801a95e:	f7ff fb37 	bl	8019fd0 <vTaskSuspendAll>
	xTimeNow = xTaskGetTickCount();
 801a962:	f7ff fb3f 	bl	8019fe4 <xTaskGetTickCount>
	if( xTimeNow < xLastTime )
 801a966:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 801a968:	4283      	cmp	r3, r0
	xTimeNow = xTaskGetTickCount();
 801a96a:	4605      	mov	r5, r0
	if( xTimeNow < xLastTime )
 801a96c:	f200 808d 	bhi.w	801aa8a <prvTimerTask+0x14e>
			if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
 801a970:	4286      	cmp	r6, r0
	xLastTime = xTimeNow;
 801a972:	63a0      	str	r0, [r4, #56]	; 0x38
			if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
 801a974:	f240 809b 	bls.w	801aaae <prvTimerTask+0x172>
 801a978:	2200      	movs	r2, #0
				vQueueWaitForMessageRestricted( xTimerQueue, ( xNextExpireTime - xTimeNow ), xListWasEmpty );
 801a97a:	6820      	ldr	r0, [r4, #0]
 801a97c:	1b71      	subs	r1, r6, r5
 801a97e:	f7ff f97d 	bl	8019c7c <vQueueWaitForMessageRestricted>
				if( xTaskResumeAll() == pdFALSE )
 801a982:	f7ff fc25 	bl	801a1d0 <xTaskResumeAll>
 801a986:	b928      	cbnz	r0, 801a994 <prvTimerTask+0x58>
					portYIELD_WITHIN_API();
 801a988:	f8c7 9d04 	str.w	r9, [r7, #3332]	; 0xd04
 801a98c:	f3bf 8f4f 	dsb	sy
 801a990:	f3bf 8f6f 	isb	sy
	while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
 801a994:	6820      	ldr	r0, [r4, #0]
 801a996:	2200      	movs	r2, #0
 801a998:	a903      	add	r1, sp, #12
 801a99a:	f7fe ff5b 	bl	8019854 <xQueueReceive>
 801a99e:	2800      	cmp	r0, #0
 801a9a0:	d0d6      	beq.n	801a950 <prvTimerTask+0x14>
		if( xMessage.xMessageID >= ( BaseType_t ) 0 )
 801a9a2:	9b03      	ldr	r3, [sp, #12]
 801a9a4:	2b00      	cmp	r3, #0
 801a9a6:	dbf5      	blt.n	801a994 <prvTimerTask+0x58>
			pxTimer = xMessage.u.xTimerParameters.pxTimer;
 801a9a8:	9d05      	ldr	r5, [sp, #20]
			if( listIS_CONTAINED_WITHIN( NULL, &( pxTimer->xTimerListItem ) ) == pdFALSE ) /*lint !e961. The cast is only redundant when NULL is passed into the macro. */
 801a9aa:	696b      	ldr	r3, [r5, #20]
 801a9ac:	b113      	cbz	r3, 801a9b4 <prvTimerTask+0x78>
				( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
 801a9ae:	1d28      	adds	r0, r5, #4
 801a9b0:	f7fe fca6 	bl	8019300 <uxListRemove>
	xTimeNow = xTaskGetTickCount();
 801a9b4:	f7ff fb16 	bl	8019fe4 <xTaskGetTickCount>
	if( xTimeNow < xLastTime )
 801a9b8:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 801a9ba:	4298      	cmp	r0, r3
	xTimeNow = xTaskGetTickCount();
 801a9bc:	4606      	mov	r6, r0
	if( xTimeNow < xLastTime )
 801a9be:	d36a      	bcc.n	801aa96 <prvTimerTask+0x15a>
			switch( xMessage.xMessageID )
 801a9c0:	9b03      	ldr	r3, [sp, #12]
	xLastTime = xTimeNow;
 801a9c2:	63a6      	str	r6, [r4, #56]	; 0x38
			switch( xMessage.xMessageID )
 801a9c4:	2b09      	cmp	r3, #9
 801a9c6:	d8e5      	bhi.n	801a994 <prvTimerTask+0x58>
 801a9c8:	a201      	add	r2, pc, #4	; (adr r2, 801a9d0 <prvTimerTask+0x94>)
 801a9ca:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 801a9ce:	bf00      	nop
 801a9d0:	0801a9f9 	.word	0x0801a9f9
 801a9d4:	0801a9f9 	.word	0x0801a9f9
 801a9d8:	0801a9f9 	.word	0x0801a9f9
 801a9dc:	0801a995 	.word	0x0801a995
 801a9e0:	0801aa49 	.word	0x0801aa49
 801a9e4:	0801aa65 	.word	0x0801aa65
 801a9e8:	0801a9f9 	.word	0x0801a9f9
 801a9ec:	0801a9f9 	.word	0x0801a9f9
 801a9f0:	0801a995 	.word	0x0801a995
 801a9f4:	0801aa49 	.word	0x0801aa49
					if( prvInsertTimerInActiveList( pxTimer,  xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, xTimeNow, xMessage.u.xTimerParameters.xMessageValue ) != pdFALSE )
 801a9f8:	9b04      	ldr	r3, [sp, #16]
 801a9fa:	69aa      	ldr	r2, [r5, #24]
	listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
 801a9fc:	612d      	str	r5, [r5, #16]
 801a9fe:	1899      	adds	r1, r3, r2
 801aa00:	bf2c      	ite	cs
 801aa02:	2001      	movcs	r0, #1
 801aa04:	2000      	movcc	r0, #0
	if( xNextExpiryTime <= xTimeNow )
 801aa06:	42b1      	cmp	r1, r6
	listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xNextExpiryTime );
 801aa08:	6069      	str	r1, [r5, #4]
	if( xNextExpiryTime <= xTimeNow )
 801aa0a:	d847      	bhi.n	801aa9c <prvTimerTask+0x160>
		if( ( ( TickType_t ) ( xTimeNow - xCommandTime ) ) >= pxTimer->xTimerPeriodInTicks ) /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 801aa0c:	1af3      	subs	r3, r6, r3
 801aa0e:	429a      	cmp	r2, r3
 801aa10:	d823      	bhi.n	801aa5a <prvTimerTask+0x11e>
						pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
 801aa12:	6a6b      	ldr	r3, [r5, #36]	; 0x24
 801aa14:	4628      	mov	r0, r5
 801aa16:	4798      	blx	r3
						if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
 801aa18:	69eb      	ldr	r3, [r5, #28]
 801aa1a:	2b01      	cmp	r3, #1
 801aa1c:	d1ba      	bne.n	801a994 <prvTimerTask+0x58>
							xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, NULL, tmrNO_DELAY );
 801aa1e:	69aa      	ldr	r2, [r5, #24]
 801aa20:	9904      	ldr	r1, [sp, #16]
 801aa22:	f8cd 8000 	str.w	r8, [sp]
 801aa26:	2300      	movs	r3, #0
 801aa28:	440a      	add	r2, r1
 801aa2a:	4628      	mov	r0, r5
 801aa2c:	4619      	mov	r1, r3
 801aa2e:	f7ff ff0d 	bl	801a84c <xTimerGenericCommand>
							configASSERT( xResult );
 801aa32:	2800      	cmp	r0, #0
 801aa34:	d1ae      	bne.n	801a994 <prvTimerTask+0x58>
 801aa36:	f04f 0350 	mov.w	r3, #80	; 0x50
 801aa3a:	f383 8811 	msr	BASEPRI, r3
 801aa3e:	f3bf 8f6f 	isb	sy
 801aa42:	f3bf 8f4f 	dsb	sy
 801aa46:	e7fe      	b.n	801aa46 <prvTimerTask+0x10a>
					pxTimer->xTimerPeriodInTicks = xMessage.u.xTimerParameters.xMessageValue;
 801aa48:	9b04      	ldr	r3, [sp, #16]
 801aa4a:	61ab      	str	r3, [r5, #24]
					configASSERT( ( pxTimer->xTimerPeriodInTicks > 0 ) );
 801aa4c:	2b00      	cmp	r3, #0
 801aa4e:	d066      	beq.n	801ab1e <prvTimerTask+0x1e2>
					( void ) prvInsertTimerInActiveList( pxTimer, ( xTimeNow + pxTimer->xTimerPeriodInTicks ), xTimeNow, xTimeNow );
 801aa50:	4433      	add	r3, r6
	if( xNextExpiryTime <= xTimeNow )
 801aa52:	42b3      	cmp	r3, r6
	listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xNextExpiryTime );
 801aa54:	606b      	str	r3, [r5, #4]
	listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
 801aa56:	612d      	str	r5, [r5, #16]
	if( xNextExpiryTime <= xTimeNow )
 801aa58:	d824      	bhi.n	801aaa4 <prvTimerTask+0x168>
			vListInsert( pxOverflowTimerList, &( pxTimer->xTimerListItem ) );
 801aa5a:	6b20      	ldr	r0, [r4, #48]	; 0x30
 801aa5c:	1d29      	adds	r1, r5, #4
 801aa5e:	f7fe fc37 	bl	80192d0 <vListInsert>
	return xProcessTimerNow;
 801aa62:	e797      	b.n	801a994 <prvTimerTask+0x58>
						vPortFree( pxTimer );
 801aa64:	4628      	mov	r0, r5
 801aa66:	f7fe fa1d 	bl	8018ea4 <vPortFree>
					break;
 801aa6a:	e793      	b.n	801a994 <prvTimerTask+0x58>
	vTaskSuspendAll();
 801aa6c:	f7ff fab0 	bl	8019fd0 <vTaskSuspendAll>
	xTimeNow = xTaskGetTickCount();
 801aa70:	f7ff fab8 	bl	8019fe4 <xTaskGetTickCount>
	if( xTimeNow < xLastTime )
 801aa74:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 801aa76:	4298      	cmp	r0, r3
	xTimeNow = xTaskGetTickCount();
 801aa78:	4605      	mov	r5, r0
	if( xTimeNow < xLastTime )
 801aa7a:	d306      	bcc.n	801aa8a <prvTimerTask+0x14e>
					xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
 801aa7c:	6b23      	ldr	r3, [r4, #48]	; 0x30
	xLastTime = xTimeNow;
 801aa7e:	63a5      	str	r5, [r4, #56]	; 0x38
					xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
 801aa80:	681a      	ldr	r2, [r3, #0]
 801aa82:	fab2 f282 	clz	r2, r2
 801aa86:	0952      	lsrs	r2, r2, #5
 801aa88:	e777      	b.n	801a97a <prvTimerTask+0x3e>
		prvSwitchTimerLists();
 801aa8a:	f7ff ff15 	bl	801a8b8 <prvSwitchTimerLists>
	xLastTime = xTimeNow;
 801aa8e:	63a5      	str	r5, [r4, #56]	; 0x38
			( void ) xTaskResumeAll();
 801aa90:	f7ff fb9e 	bl	801a1d0 <xTaskResumeAll>
 801aa94:	e77e      	b.n	801a994 <prvTimerTask+0x58>
		prvSwitchTimerLists();
 801aa96:	f7ff ff0f 	bl	801a8b8 <prvSwitchTimerLists>
		*pxTimerListsWereSwitched = pdTRUE;
 801aa9a:	e791      	b.n	801a9c0 <prvTimerTask+0x84>
		if( ( xTimeNow < xCommandTime ) && ( xNextExpiryTime >= xCommandTime ) )
 801aa9c:	42b3      	cmp	r3, r6
 801aa9e:	d901      	bls.n	801aaa4 <prvTimerTask+0x168>
 801aaa0:	2800      	cmp	r0, #0
 801aaa2:	d0b6      	beq.n	801aa12 <prvTimerTask+0xd6>
			vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
 801aaa4:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
 801aaa6:	1d29      	adds	r1, r5, #4
 801aaa8:	f7fe fc12 	bl	80192d0 <vListInsert>
 801aaac:	e772      	b.n	801a994 <prvTimerTask+0x58>
				( void ) xTaskResumeAll();
 801aaae:	f7ff fb8f 	bl	801a1d0 <xTaskResumeAll>
Timer_t * const pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList );
 801aab2:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 801aab4:	68db      	ldr	r3, [r3, #12]
 801aab6:	f8d3 a00c 	ldr.w	sl, [r3, #12]
	( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
 801aaba:	f10a 0b04 	add.w	fp, sl, #4
 801aabe:	4658      	mov	r0, fp
 801aac0:	f7fe fc1e 	bl	8019300 <uxListRemove>
	if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
 801aac4:	f8da 301c 	ldr.w	r3, [sl, #28]
 801aac8:	2b01      	cmp	r3, #1
 801aaca:	d004      	beq.n	801aad6 <prvTimerTask+0x19a>
	pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
 801aacc:	f8da 3024 	ldr.w	r3, [sl, #36]	; 0x24
 801aad0:	4650      	mov	r0, sl
 801aad2:	4798      	blx	r3
}
 801aad4:	e75e      	b.n	801a994 <prvTimerTask+0x58>
		if( prvInsertTimerInActiveList( pxTimer, ( xNextExpireTime + pxTimer->xTimerPeriodInTicks ), xTimeNow, xNextExpireTime ) != pdFALSE )
 801aad6:	f8da 3018 	ldr.w	r3, [sl, #24]
	listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
 801aada:	f8ca a010 	str.w	sl, [sl, #16]
		if( prvInsertTimerInActiveList( pxTimer, ( xNextExpireTime + pxTimer->xTimerPeriodInTicks ), xTimeNow, xNextExpireTime ) != pdFALSE )
 801aade:	18f2      	adds	r2, r6, r3
	if( xNextExpiryTime <= xTimeNow )
 801aae0:	42aa      	cmp	r2, r5
	listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xNextExpiryTime );
 801aae2:	f8ca 2004 	str.w	r2, [sl, #4]
	if( xNextExpiryTime <= xTimeNow )
 801aae6:	d904      	bls.n	801aaf2 <prvTimerTask+0x1b6>
			vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
 801aae8:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
 801aaea:	4659      	mov	r1, fp
 801aaec:	f7fe fbf0 	bl	80192d0 <vListInsert>
	return xProcessTimerNow;
 801aaf0:	e7ec      	b.n	801aacc <prvTimerTask+0x190>
		if( ( ( TickType_t ) ( xTimeNow - xCommandTime ) ) >= pxTimer->xTimerPeriodInTicks ) /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 801aaf2:	1bad      	subs	r5, r5, r6
 801aaf4:	42ab      	cmp	r3, r5
 801aaf6:	d81b      	bhi.n	801ab30 <prvTimerTask+0x1f4>
			xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
 801aaf8:	2300      	movs	r3, #0
 801aafa:	f8cd 8000 	str.w	r8, [sp]
 801aafe:	4632      	mov	r2, r6
 801ab00:	4619      	mov	r1, r3
 801ab02:	4650      	mov	r0, sl
 801ab04:	f7ff fea2 	bl	801a84c <xTimerGenericCommand>
			configASSERT( xResult );
 801ab08:	2800      	cmp	r0, #0
 801ab0a:	d1df      	bne.n	801aacc <prvTimerTask+0x190>
 801ab0c:	f04f 0350 	mov.w	r3, #80	; 0x50
 801ab10:	f383 8811 	msr	BASEPRI, r3
 801ab14:	f3bf 8f6f 	isb	sy
 801ab18:	f3bf 8f4f 	dsb	sy
 801ab1c:	e7fe      	b.n	801ab1c <prvTimerTask+0x1e0>
 801ab1e:	f04f 0350 	mov.w	r3, #80	; 0x50
 801ab22:	f383 8811 	msr	BASEPRI, r3
 801ab26:	f3bf 8f6f 	isb	sy
 801ab2a:	f3bf 8f4f 	dsb	sy
					configASSERT( ( pxTimer->xTimerPeriodInTicks > 0 ) );
 801ab2e:	e7fe      	b.n	801ab2e <prvTimerTask+0x1f2>
			vListInsert( pxOverflowTimerList, &( pxTimer->xTimerListItem ) );
 801ab30:	6b20      	ldr	r0, [r4, #48]	; 0x30
 801ab32:	4659      	mov	r1, fp
 801ab34:	f7fe fbcc 	bl	80192d0 <vListInsert>
	return xProcessTimerNow;
 801ab38:	e7c8      	b.n	801aacc <prvTimerTask+0x190>
 801ab3a:	bf00      	nop
 801ab3c:	200080ac 	.word	0x200080ac

0801ab40 <ReseMetaDataManager>:
void ReseMetaDataManager(void) {
  MDM_OsxLicenseType_t osxLic;
  MDM_GenericMetaDataType_t GMD;

  NecessityToSaveMetaDataManager=1;
  puint8_RW_MetaData = ((uint8_t *) uint64_MetaDataVector)+8;
 801ab40:	4a12      	ldr	r2, [pc, #72]	; (801ab8c <ReseMetaDataManager+0x4c>)
 801ab42:	4913      	ldr	r1, [pc, #76]	; (801ab90 <ReseMetaDataManager+0x50>)
 801ab44:	4613      	mov	r3, r2
void ReseMetaDataManager(void) {
 801ab46:	b430      	push	{r4, r5}
  pMetaDataManagerHeader->IsIntialized = MDM_VALID_META_DATA_MANAGER;
 801ab48:	4d12      	ldr	r5, [pc, #72]	; (801ab94 <ReseMetaDataManager+0x54>)
 801ab4a:	f841 5c08 	str.w	r5, [r1, #-8]
 801ab4e:	f1a1 0008 	sub.w	r0, r1, #8
  puint8_RW_MetaData = ((uint8_t *) uint64_MetaDataVector)+8;
 801ab52:	f843 1b04 	str.w	r1, [r3], #4
  pMetaDataManagerHeader->Version = MDM_VERSION;
  /* add the MetaData Teminitation */
  *((uint32_t *) puint8_RW_MetaData)     = MDM_DATA_TYPE_END;
 801ab56:	f44f 3580 	mov.w	r5, #65536	; 0x10000
 801ab5a:	21ff      	movs	r1, #255	; 0xff
 801ab5c:	e9c0 5101 	strd	r5, r1, [r0, #4]
  NecessityToSaveMetaDataManager=1;
 801ab60:	4c0d      	ldr	r4, [pc, #52]	; (801ab98 <ReseMetaDataManager+0x58>)
  *((uint32_t *) (puint8_RW_MetaData+4)) = 0; /* No Payload */
 801ab62:	2100      	movs	r1, #0
 801ab64:	60c1      	str	r1, [r0, #12]
  NecessityToSaveMetaDataManager=1;
 801ab66:	2001      	movs	r0, #1
 801ab68:	f502 7292 	add.w	r2, r2, #292	; 0x124
 801ab6c:	6020      	str	r0, [r4, #0]

  /* Reset all the Payload pointers */
  for(osxLic=OSX_MOTION_FX;osxLic<OSX_LICENSE_NUM;osxLic++) {
    MDM_LicTable[osxLic].Address =0;
 801ab6e:	63d9      	str	r1, [r3, #60]	; 0x3c
  for(osxLic=OSX_MOTION_FX;osxLic<OSX_LICENSE_NUM;osxLic++) {
 801ab70:	3320      	adds	r3, #32
 801ab72:	4293      	cmp	r3, r2
 801ab74:	d1fb      	bne.n	801ab6e <ReseMetaDataManager+0x2e>
 801ab76:	4b09      	ldr	r3, [pc, #36]	; (801ab9c <ReseMetaDataManager+0x5c>)
  }
  for(GMD=GMD_WIFI;GMD<GMD_NUM;GMD++){
    MDM_GMDTable[GMD].Address =0;
 801ab78:	2100      	movs	r1, #0
 801ab7a:	f503 72b6 	add.w	r2, r3, #364	; 0x16c
 801ab7e:	6359      	str	r1, [r3, #52]	; 0x34
  for(GMD=GMD_WIFI;GMD<GMD_NUM;GMD++){
 801ab80:	331c      	adds	r3, #28
 801ab82:	429a      	cmp	r2, r3
 801ab84:	d1fb      	bne.n	801ab7e <ReseMetaDataManager+0x3e>
  }
}
 801ab86:	bc30      	pop	{r4, r5}
 801ab88:	4770      	bx	lr
 801ab8a:	bf00      	nop
 801ab8c:	2000014c 	.word	0x2000014c
 801ab90:	20008138 	.word	0x20008138
 801ab94:	12345678 	.word	0x12345678
 801ab98:	200080e8 	.word	0x200080e8
 801ab9c:	20000290 	.word	0x20000290

0801aba0 <InitMetaDataManager>:
void InitMetaDataManager(void *Ptr,...) {
 801aba0:	b40f      	push	{r0, r1, r2, r3}
 801aba2:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  __IO uint32_t data32 = *(__IO uint32_t*) Address;
 801aba6:	4bb4      	ldr	r3, [pc, #720]	; (801ae78 <InitMetaDataManager+0x2d8>)
  puint8_RW_MetaData = ((uint8_t *) uint64_MetaDataVector)+8;
 801aba8:	4db4      	ldr	r5, [pc, #720]	; (801ae7c <InitMetaDataManager+0x2dc>)
 801abaa:	4ab5      	ldr	r2, [pc, #724]	; (801ae80 <InitMetaDataManager+0x2e0>)
 801abac:	602a      	str	r2, [r5, #0]
void InitMetaDataManager(void *Ptr,...) {
 801abae:	b087      	sub	sp, #28
  __IO uint32_t data32 = *(__IO uint32_t*) Address;
 801abb0:	681a      	ldr	r2, [r3, #0]
 801abb2:	9205      	str	r2, [sp, #20]
  if(data32== MDM_VALID_META_DATA_MANAGER){
 801abb4:	9905      	ldr	r1, [sp, #20]
 801abb6:	4ab3      	ldr	r2, [pc, #716]	; (801ae84 <InitMetaDataManager+0x2e4>)
void InitMetaDataManager(void *Ptr,...) {
 801abb8:	9f10      	ldr	r7, [sp, #64]	; 0x40
  if(data32== MDM_VALID_META_DATA_MANAGER){
 801abba:	4291      	cmp	r1, r2
 801abbc:	f000 8185 	beq.w	801aeca <InitMetaDataManager+0x32a>
    MDM_PRINTF("Meta Data Manager not present in FLASH\r\n");
 801abc0:	4bb1      	ldr	r3, [pc, #708]	; (801ae88 <InitMetaDataManager+0x2e8>)
 801abc2:	9303      	str	r3, [sp, #12]
 801abc4:	781b      	ldrb	r3, [r3, #0]
 801abc6:	2b00      	cmp	r3, #0
 801abc8:	f040 8097 	bne.w	801acfa <InitMetaDataManager+0x15a>
    ReseMetaDataManager();
 801abcc:	f7ff ffb8 	bl	801ab40 <ReseMetaDataManager>
  va_start (ap, Ptr);
 801abd0:	ab11      	add	r3, sp, #68	; 0x44
 801abd2:	9304      	str	r3, [sp, #16]
  while(KnownMetaDataTable!=NULL) {
 801abd4:	2f00      	cmp	r7, #0
 801abd6:	f000 8254 	beq.w	801b082 <InitMetaDataManager+0x4e2>
    MDM_MetaDataType_t  MetaDataType = (MDM_MetaDataType_t) va_arg(ap,int);
 801abda:	f04f 0a00 	mov.w	sl, #0
 801abde:	ab13      	add	r3, sp, #76	; 0x4c
 801abe0:	f8df b2ac 	ldr.w	fp, [pc, #684]	; 801ae90 <InitMetaDataManager+0x2f0>
 801abe4:	9301      	str	r3, [sp, #4]
 801abe6:	4656      	mov	r6, sl
            MDM_PRINTF("Adding=%s%s Version=%s\r\n",MDM_LicTable[known_OsxLic[Index].LicEnum].LicType,MDM_LicTable[known_OsxLic[Index].LicEnum].LicName,PayLoad->osxLibVersion);
 801abe8:	46d1      	mov	r9, sl
    switch(MetaDataType) {
 801abea:	9b01      	ldr	r3, [sp, #4]
 801abec:	f813 2c08 	ldrb.w	r2, [r3, #-8]
 801abf0:	9202      	str	r2, [sp, #8]
    MDM_MetaDataType_t  MetaDataType = (MDM_MetaDataType_t) va_arg(ap,int);
 801abf2:	3b04      	subs	r3, #4
 801abf4:	9304      	str	r3, [sp, #16]
    switch(MetaDataType) {
 801abf6:	2a00      	cmp	r2, #0
 801abf8:	f000 8156 	beq.w	801aea8 <InitMetaDataManager+0x308>
 801abfc:	2a01      	cmp	r2, #1
 801abfe:	f040 8131 	bne.w	801ae64 <InitMetaDataManager+0x2c4>
        for(Index =0; known_GMD[Index].GMDType!=GMD_END ;Index++) {
 801ac02:	783b      	ldrb	r3, [r7, #0]
 801ac04:	2b00      	cmp	r3, #0
 801ac06:	f000 8233 	beq.w	801b070 <InitMetaDataManager+0x4d0>
 801ac0a:	f8db 3008 	ldr.w	r3, [fp, #8]
 801ac0e:	3301      	adds	r3, #1
 801ac10:	ebc3 7143 	rsb	r1, r3, r3, lsl #29
 801ac14:	eb07 01c1 	add.w	r1, r7, r1, lsl #3
 801ac18:	4618      	mov	r0, r3
 801ac1a:	3301      	adds	r3, #1
 801ac1c:	f811 2033 	ldrb.w	r2, [r1, r3, lsl #3]
 801ac20:	2a00      	cmp	r2, #0
 801ac22:	d1f9      	bne.n	801ac18 <InitMetaDataManager+0x78>
 801ac24:	463c      	mov	r4, r7
 801ac26:	f8cb 0008 	str.w	r0, [fp, #8]
    MDM_knownOsxLicense_t *known_OsxLic=NULL;
 801ac2a:	4617      	mov	r7, r2
    while(pMetaDataHeader->Type!=MDM_DATA_TYPE_END) {
 801ac2c:	4b97      	ldr	r3, [pc, #604]	; (801ae8c <InitMetaDataManager+0x2ec>)
 801ac2e:	689b      	ldr	r3, [r3, #8]
 801ac30:	2bff      	cmp	r3, #255	; 0xff
 801ac32:	d013      	beq.n	801ac5c <InitMetaDataManager+0xbc>
        for(Index =0; ((Index<NumberOfKnownLic) & (found==0));Index++) {
 801ac34:	f8db 2004 	ldr.w	r2, [fp, #4]
        for(Index =0; ((Index<NumberOfKnownGMD) & (found==0));Index++) {
 801ac38:	f8db 8008 	ldr.w	r8, [fp, #8]
    pMetaDataHeader = (MDM_MetaDataHeader_t *) pMetaDataManagerHeader->puint8_MetaData;
 801ac3c:	4990      	ldr	r1, [pc, #576]	; (801ae80 <InitMetaDataManager+0x2e0>)
        for(Index =0; ((Index<NumberOfKnownLic) & (found==0));Index++) {
 801ac3e:	9200      	str	r2, [sp, #0]
 801ac40:	eb02 0e42 	add.w	lr, r2, r2, lsl #1
 801ac44:	ebce 1e0e 	rsb	lr, lr, lr, lsl #4
 801ac48:	44be      	add	lr, r7
      if(pMetaDataHeader->Type == MDM_DATA_TYPE_LIC) {
 801ac4a:	2b00      	cmp	r3, #0
 801ac4c:	d059      	beq.n	801ad02 <InitMetaDataManager+0x162>
      } else if(pMetaDataHeader->Type == MDM_DATA_TYPE_GMD) {
 801ac4e:	2b01      	cmp	r3, #1
 801ac50:	d06c      	beq.n	801ad2c <InitMetaDataManager+0x18c>
      pMetaDataHeader = (MDM_MetaDataHeader_t *) (((uint32_t) pMetaDataHeader)+pMetaDataHeader->Lenght);
 801ac52:	684b      	ldr	r3, [r1, #4]
 801ac54:	4419      	add	r1, r3
    while(pMetaDataHeader->Type!=MDM_DATA_TYPE_END) {
 801ac56:	680b      	ldr	r3, [r1, #0]
 801ac58:	2bff      	cmp	r3, #255	; 0xff
 801ac5a:	d1f6      	bne.n	801ac4a <InitMetaDataManager+0xaa>
    if(MetaDataType==MDM_DATA_TYPE_LIC) {
 801ac5c:	9b02      	ldr	r3, [sp, #8]
 801ac5e:	2b00      	cmp	r3, #0
 801ac60:	f040 809a 	bne.w	801ad98 <InitMetaDataManager+0x1f8>
      if(NumberofFoundedLic<NumberOfKnownLic) {
 801ac64:	f8db 2004 	ldr.w	r2, [fp, #4]
 801ac68:	42b2      	cmp	r2, r6
 801ac6a:	f200 8183 	bhi.w	801af74 <InitMetaDataManager+0x3d4>
    KnownMetaDataTable= va_arg(ap,void *);
 801ac6e:	9b01      	ldr	r3, [sp, #4]
 801ac70:	9304      	str	r3, [sp, #16]
 801ac72:	f853 7c04 	ldr.w	r7, [r3, #-4]
  while(KnownMetaDataTable!=NULL) {
 801ac76:	3308      	adds	r3, #8
 801ac78:	9301      	str	r3, [sp, #4]
 801ac7a:	2f00      	cmp	r7, #0
 801ac7c:	d1b5      	bne.n	801abea <InitMetaDataManager+0x4a>
 801ac7e:	46ca      	mov	sl, r9
  if(NecessityToSaveMetaDataManager) {
 801ac80:	4c83      	ldr	r4, [pc, #524]	; (801ae90 <InitMetaDataManager+0x2f0>)
 801ac82:	6823      	ldr	r3, [r4, #0]
 801ac84:	2b00      	cmp	r3, #0
 801ac86:	f040 8204 	bne.w	801b092 <InitMetaDataManager+0x4f2>
  MDM_PRINTF("Meta Data Manager version=%ld.%ld.%ld\r\n",
 801ac8a:	9b03      	ldr	r3, [sp, #12]
 801ac8c:	781b      	ldrb	r3, [r3, #0]
 801ac8e:	b143      	cbz	r3, 801aca2 <InitMetaDataManager+0x102>
 801ac90:	4b7e      	ldr	r3, [pc, #504]	; (801ae8c <InitMetaDataManager+0x2ec>)
 801ac92:	4880      	ldr	r0, [pc, #512]	; (801ae94 <InitMetaDataManager+0x2f4>)
 801ac94:	6859      	ldr	r1, [r3, #4]
 801ac96:	b2cb      	uxtb	r3, r1
 801ac98:	f3c1 2207 	ubfx	r2, r1, #8, #8
 801ac9c:	0c09      	lsrs	r1, r1, #16
 801ac9e:	f00d f9bd 	bl	802801c <iprintf>
  if((NumberOfKnownGMD!=0) | (NumberofFoundedGMD!=0)) {
 801aca2:	68a3      	ldr	r3, [r4, #8]
 801aca4:	ea5a 0303 	orrs.w	r3, sl, r3
 801aca8:	f000 80e0 	beq.w	801ae6c <InitMetaDataManager+0x2cc>
 * @retval None
 */
static void PrintOut_MDM_GMDStatus(void)
{
  MDM_GenericMetaDataType_t GMD;
  MDM_PRINTF("\tGeneric Meta Data found:\r\n");
 801acac:	9b03      	ldr	r3, [sp, #12]
 801acae:	781b      	ldrb	r3, [r3, #0]
 801acb0:	2b00      	cmp	r3, #0
 801acb2:	f040 8229 	bne.w	801b108 <InitMetaDataManager+0x568>
 801acb6:	4f78      	ldr	r7, [pc, #480]	; (801ae98 <InitMetaDataManager+0x2f8>)
  for(GMD=GMD_WIFI;GMD<GMD_NUM;GMD++) {
    MDM_PayLoadGMD_t *PayLoad = (MDM_PayLoadGMD_t *) MDM_GMDTable[GMD].Address;
    if(PayLoad) {
      MDM_PRINTF("\t\t %s Size=%ld [bytes]\r\n",MDM_GMDTable[PayLoad->GMDTypeEnum].GMDName,
 801acb8:	f8df 81e8 	ldr.w	r8, [pc, #488]	; 801aea4 <InitMetaDataManager+0x304>
 801acbc:	f8dd 900c 	ldr.w	r9, [sp, #12]
 801acc0:	463c      	mov	r4, r7
 801acc2:	f507 76b6 	add.w	r6, r7, #364	; 0x16c
 801acc6:	e002      	b.n	801acce <InitMetaDataManager+0x12e>
  for(GMD=GMD_WIFI;GMD<GMD_NUM;GMD++) {
 801acc8:	42a6      	cmp	r6, r4
 801acca:	f000 80cf 	beq.w	801ae6c <InitMetaDataManager+0x2cc>
    MDM_PayLoadGMD_t *PayLoad = (MDM_PayLoadGMD_t *) MDM_GMDTable[GMD].Address;
 801acce:	6b63      	ldr	r3, [r4, #52]	; 0x34
  for(GMD=GMD_WIFI;GMD<GMD_NUM;GMD++) {
 801acd0:	341c      	adds	r4, #28
    if(PayLoad) {
 801acd2:	2b00      	cmp	r3, #0
 801acd4:	d0f8      	beq.n	801acc8 <InitMetaDataManager+0x128>
      MDM_PRINTF("\t\t %s Size=%ld [bytes]\r\n",MDM_GMDTable[PayLoad->GMDTypeEnum].GMDName,
 801acd6:	f899 2000 	ldrb.w	r2, [r9]
 801acda:	2a00      	cmp	r2, #0
 801acdc:	d0f4      	beq.n	801acc8 <InitMetaDataManager+0x128>
 801acde:	681b      	ldr	r3, [r3, #0]
 801ace0:	ebc3 03c3 	rsb	r3, r3, r3, lsl #3
 801ace4:	eb05 0283 	add.w	r2, r5, r3, lsl #2
 801ace8:	eb07 0383 	add.w	r3, r7, r3, lsl #2
 801acec:	f8d2 2158 	ldr.w	r2, [r2, #344]	; 0x158
 801acf0:	1d19      	adds	r1, r3, #4
 801acf2:	4640      	mov	r0, r8
 801acf4:	f00d f992 	bl	802801c <iprintf>
 801acf8:	e7e6      	b.n	801acc8 <InitMetaDataManager+0x128>
    MDM_PRINTF("Meta Data Manager not present in FLASH\r\n");
 801acfa:	4868      	ldr	r0, [pc, #416]	; (801ae9c <InitMetaDataManager+0x2fc>)
 801acfc:	f00d fa2a 	bl	8028154 <puts>
 801ad00:	e764      	b.n	801abcc <InitMetaDataManager+0x2c>
        for(Index =0; ((Index<NumberOfKnownLic) & (found==0));Index++) {
 801ad02:	9b00      	ldr	r3, [sp, #0]
        MDM_PayLoadLic_t *PayLoad = (MDM_PayLoadLic_t *) pMetaDataHeader->puint8_PayLoad;
 801ad04:	f101 0008 	add.w	r0, r1, #8
        for(Index =0; ((Index<NumberOfKnownLic) & (found==0));Index++) {
 801ad08:	2b00      	cmp	r3, #0
 801ad0a:	d0a2      	beq.n	801ac52 <InitMetaDataManager+0xb2>
          if(known_OsxLic[Index].LicEnum==PayLoad->LicEnum) {
 801ad0c:	688a      	ldr	r2, [r1, #8]
 801ad0e:	463b      	mov	r3, r7
 801ad10:	e001      	b.n	801ad16 <InitMetaDataManager+0x176>
        for(Index =0; ((Index<NumberOfKnownLic) & (found==0));Index++) {
 801ad12:	4573      	cmp	r3, lr
 801ad14:	d09d      	beq.n	801ac52 <InitMetaDataManager+0xb2>
          if(known_OsxLic[Index].LicEnum==PayLoad->LicEnum) {
 801ad16:	f893 c000 	ldrb.w	ip, [r3]
 801ad1a:	4594      	cmp	ip, r2
        for(Index =0; ((Index<NumberOfKnownLic) & (found==0));Index++) {
 801ad1c:	f103 032d 	add.w	r3, r3, #45	; 0x2d
          if(known_OsxLic[Index].LicEnum==PayLoad->LicEnum) {
 801ad20:	d1f7      	bne.n	801ad12 <InitMetaDataManager+0x172>
            MDM_LicTable[PayLoad->LicEnum].Address = (uint32_t)PayLoad;
 801ad22:	eb05 1242 	add.w	r2, r5, r2, lsl #5
            NumberofFoundedLic++;
 801ad26:	3601      	adds	r6, #1
            MDM_LicTable[PayLoad->LicEnum].Address = (uint32_t)PayLoad;
 801ad28:	6210      	str	r0, [r2, #32]
        for(Index =0; ((Index<NumberOfKnownLic) & (found==0));Index++) {
 801ad2a:	e792      	b.n	801ac52 <InitMetaDataManager+0xb2>
        MDM_PayLoadGMD_t *PayLoad = (MDM_PayLoadGMD_t *) pMetaDataHeader->puint8_PayLoad;
 801ad2c:	f101 0a08 	add.w	sl, r1, #8
        for(Index =0; ((Index<NumberOfKnownGMD) & (found==0));Index++) {
 801ad30:	f1b8 0f00 	cmp.w	r8, #0
 801ad34:	d08d      	beq.n	801ac52 <InitMetaDataManager+0xb2>
          if(known_GMD[Index].GMDType==PayLoad->GMDTypeEnum) {
 801ad36:	688a      	ldr	r2, [r1, #8]
 801ad38:	4620      	mov	r0, r4
        for(Index =0; ((Index<NumberOfKnownGMD) & (found==0));Index++) {
 801ad3a:	2300      	movs	r3, #0
 801ad3c:	e003      	b.n	801ad46 <InitMetaDataManager+0x1a6>
 801ad3e:	4543      	cmp	r3, r8
 801ad40:	f100 0008 	add.w	r0, r0, #8
 801ad44:	d085      	beq.n	801ac52 <InitMetaDataManager+0xb2>
          if(known_GMD[Index].GMDType==PayLoad->GMDTypeEnum) {
 801ad46:	f814 c033 	ldrb.w	ip, [r4, r3, lsl #3]
 801ad4a:	4594      	cmp	ip, r2
        for(Index =0; ((Index<NumberOfKnownGMD) & (found==0));Index++) {
 801ad4c:	f103 0301 	add.w	r3, r3, #1
          if(known_GMD[Index].GMDType==PayLoad->GMDTypeEnum) {
 801ad50:	d1f5      	bne.n	801ad3e <InitMetaDataManager+0x19e>
            if(known_GMD[Index].GMDSize!=PayLoad->GMDSize) {
 801ad52:	6843      	ldr	r3, [r0, #4]
            MDM_GMDTable[PayLoad->GMDTypeEnum].GMDSize = PayLoad->GMDSize;
 801ad54:	f8d1 c00c 	ldr.w	ip, [r1, #12]
            MDM_GMDTable[PayLoad->GMDTypeEnum].Address = (uint32_t)PayLoad;
 801ad58:	ebc2 02c2 	rsb	r2, r2, r2, lsl #3
 801ad5c:	eb05 0082 	add.w	r0, r5, r2, lsl #2
            if(known_GMD[Index].GMDSize!=PayLoad->GMDSize) {
 801ad60:	459c      	cmp	ip, r3
            NumberofFoundedGMD++;
 801ad62:	f109 0901 	add.w	r9, r9, #1
            MDM_GMDTable[PayLoad->GMDTypeEnum].Address = (uint32_t)PayLoad;
 801ad66:	f8c0 a15c 	str.w	sl, [r0, #348]	; 0x15c
 801ad6a:	ea4f 0282 	mov.w	r2, r2, lsl #2
            MDM_GMDTable[PayLoad->GMDTypeEnum].GMDSize = PayLoad->GMDSize;
 801ad6e:	f8c0 c158 	str.w	ip, [r0, #344]	; 0x158
            if(known_GMD[Index].GMDSize!=PayLoad->GMDSize) {
 801ad72:	f43f af6e 	beq.w	801ac52 <InitMetaDataManager+0xb2>
              MDM_PRINTF("Warning: The Meta Data Manager Contains for %s Generic Meta Data a size=%ld different from what we need =%ld\r\n\tIt will be ERASED\r\n",
 801ad76:	4611      	mov	r1, r2
 801ad78:	4662      	mov	r2, ip
 801ad7a:	468c      	mov	ip, r1
 801ad7c:	9903      	ldr	r1, [sp, #12]
 801ad7e:	7809      	ldrb	r1, [r1, #0]
 801ad80:	2900      	cmp	r1, #0
 801ad82:	f040 816b 	bne.w	801b05c <InitMetaDataManager+0x4bc>
              ReseMetaDataManager();
 801ad86:	f7ff fedb 	bl	801ab40 <ReseMetaDataManager>
    if(MetaDataType==MDM_DATA_TYPE_LIC) {
 801ad8a:	9b02      	ldr	r3, [sp, #8]
              NumberofFoundedGMD=0;
 801ad8c:	f04f 0900 	mov.w	r9, #0
              NumberofFoundedLic=0;
 801ad90:	464e      	mov	r6, r9
    if(MetaDataType==MDM_DATA_TYPE_LIC) {
 801ad92:	2b00      	cmp	r3, #0
 801ad94:	f43f af66 	beq.w	801ac64 <InitMetaDataManager+0xc4>
    } else if(MetaDataType==MDM_DATA_TYPE_GMD){
 801ad98:	9b02      	ldr	r3, [sp, #8]
 801ad9a:	2b01      	cmp	r3, #1
 801ad9c:	f47f af67 	bne.w	801ac6e <InitMetaDataManager+0xce>
      if(NumberofFoundedGMD<NumberOfKnownGMD) {
 801ada0:	f8db 0008 	ldr.w	r0, [fp, #8]
 801ada4:	4548      	cmp	r0, r9
 801ada6:	f67f af62 	bls.w	801ac6e <InitMetaDataManager+0xce>
        NecessityToSaveMetaDataManager = 1;
 801adaa:	f8cb 3000 	str.w	r3, [fp]
        for(Index =0; Index<NumberOfKnownGMD ;Index++) {
 801adae:	2800      	cmp	r0, #0
 801adb0:	f000 8191 	beq.w	801b0d6 <InitMetaDataManager+0x536>
 801adb4:	4622      	mov	r2, r4
 801adb6:	eb04 0cc0 	add.w	ip, r4, r0, lsl #3
        uint32_t HowManyExtraSpaceINeed =0;
 801adba:	2100      	movs	r1, #0
          if(MDM_GMDTable[known_GMD[Index].GMDType].Address==0) {
 801adbc:	7813      	ldrb	r3, [r2, #0]
 801adbe:	ebc3 03c3 	rsb	r3, r3, r3, lsl #3
 801adc2:	eb05 0383 	add.w	r3, r5, r3, lsl #2
 801adc6:	f101 0710 	add.w	r7, r1, #16
 801adca:	f8d3 315c 	ldr.w	r3, [r3, #348]	; 0x15c
 801adce:	b923      	cbnz	r3, 801adda <InitMetaDataManager+0x23a>
            HowManyExtraSpaceINeed += (((known_GMD[Index].GMDSize+7)>>3)<<3) /* Round to Multiple of 8 bytes */ + 
 801add0:	6853      	ldr	r3, [r2, #4]
 801add2:	1dd9      	adds	r1, r3, #7
 801add4:	f021 0107 	bic.w	r1, r1, #7
 801add8:	4439      	add	r1, r7
        for(Index =0; Index<NumberOfKnownGMD ;Index++) {
 801adda:	3208      	adds	r2, #8
 801addc:	4594      	cmp	ip, r2
 801adde:	d1ed      	bne.n	801adbc <InitMetaDataManager+0x21c>
        if(((((uint32_t) puint8_RW_MetaData)+8/* for the MDM_DATA_TYPE_END */) -
 801ade0:	682f      	ldr	r7, [r5, #0]
             ((uint32_t)uint64_MetaDataVector) +
 801ade2:	4b2a      	ldr	r3, [pc, #168]	; (801ae8c <InitMetaDataManager+0x2ec>)
 801ade4:	1afb      	subs	r3, r7, r3
 801ade6:	3308      	adds	r3, #8
 801ade8:	4419      	add	r1, r3
        if(((((uint32_t) puint8_RW_MetaData)+8/* for the MDM_DATA_TYPE_END */) -
 801adea:	f5b1 5f80 	cmp.w	r1, #4096	; 0x1000
 801adee:	f200 8179 	bhi.w	801b0e4 <InitMetaDataManager+0x544>
            pMetaDataHeader->Type = MDM_DATA_TYPE_GMD;
 801adf2:	9600      	str	r6, [sp, #0]
          NumberofFoundedGMD = 0;
 801adf4:	f04f 0800 	mov.w	r8, #0
            pMetaDataHeader->Type = MDM_DATA_TYPE_GMD;
 801adf8:	9e03      	ldr	r6, [sp, #12]
 801adfa:	e008      	b.n	801ae0e <InitMetaDataManager+0x26e>
            puint8_RW_MetaData +=pMetaDataHeader->Lenght;
 801adfc:	4407      	add	r7, r0
 801adfe:	602f      	str	r7, [r5, #0]
        for(Index=0;Index<NumberOfKnownGMD; Index++) {
 801ae00:	f8db 3008 	ldr.w	r3, [fp, #8]
 801ae04:	f108 0801 	add.w	r8, r8, #1
 801ae08:	4543      	cmp	r3, r8
 801ae0a:	f240 8134 	bls.w	801b076 <InitMetaDataManager+0x4d6>
          if(MDM_GMDTable[known_GMD[Index].GMDType].Address==0) {
 801ae0e:	f814 2038 	ldrb.w	r2, [r4, r8, lsl #3]
 801ae12:	ebc2 01c2 	rsb	r1, r2, r2, lsl #3
 801ae16:	eb05 0c81 	add.w	ip, r5, r1, lsl #2
            pMetaDataHeader->Lenght = (((known_GMD[Index].GMDSize+7)>>3)<<3) /* Round to Multiple of 8 bytes */ + 
 801ae1a:	1d20      	adds	r0, r4, #4
          if(MDM_GMDTable[known_GMD[Index].GMDType].Address==0) {
 801ae1c:	f8dc 315c 	ldr.w	r3, [ip, #348]	; 0x15c
 801ae20:	0089      	lsls	r1, r1, #2
 801ae22:	2b00      	cmp	r3, #0
 801ae24:	d1ec      	bne.n	801ae00 <InitMetaDataManager+0x260>
            pMetaDataHeader->Type = MDM_DATA_TYPE_GMD;
 801ae26:	2301      	movs	r3, #1
 801ae28:	603b      	str	r3, [r7, #0]
            pMetaDataHeader->Lenght = (((known_GMD[Index].GMDSize+7)>>3)<<3) /* Round to Multiple of 8 bytes */ + 
 801ae2a:	f850 3038 	ldr.w	r3, [r0, r8, lsl #3]
            MDM_PRINTF("Adding=%s (Pos=%d) Size=%ld\r\n",MDM_GMDTable[known_GMD[Index].GMDType].GMDName,
 801ae2e:	f896 e000 	ldrb.w	lr, [r6]
            pMetaDataHeader->Lenght = (((known_GMD[Index].GMDSize+7)>>3)<<3) /* Round to Multiple of 8 bytes */ + 
 801ae32:	1dd8      	adds	r0, r3, #7
 801ae34:	f020 0007 	bic.w	r0, r0, #7
              8 + 8 /* For Meta Data Header */;
 801ae38:	3010      	adds	r0, #16
            PayLoad = (MDM_PayLoadGMD_t *) pMetaDataHeader->puint8_PayLoad;
 801ae3a:	f107 0a08 	add.w	sl, r7, #8
            PayLoad->GMDTypeEnum = known_GMD[Index].GMDType;
 801ae3e:	e9c7 2302 	strd	r2, r3, [r7, #8]
            pMetaDataHeader->Lenght = (((known_GMD[Index].GMDSize+7)>>3)<<3) /* Round to Multiple of 8 bytes */ + 
 801ae42:	6078      	str	r0, [r7, #4]
            MDM_GMDTable[known_GMD[Index].GMDType].GMDSize = PayLoad->GMDSize;
 801ae44:	f8cc 3158 	str.w	r3, [ip, #344]	; 0x158
            MDM_GMDTable[known_GMD[Index].GMDType].Address = (uint32_t)PayLoad;
 801ae48:	f8cc a15c 	str.w	sl, [ip, #348]	; 0x15c
            MDM_PRINTF("Adding=%s (Pos=%d) Size=%ld\r\n",MDM_GMDTable[known_GMD[Index].GMDType].GMDName,
 801ae4c:	f1be 0f00 	cmp.w	lr, #0
 801ae50:	d0d4      	beq.n	801adfc <InitMetaDataManager+0x25c>
 801ae52:	4811      	ldr	r0, [pc, #68]	; (801ae98 <InitMetaDataManager+0x2f8>)
 801ae54:	3104      	adds	r1, #4
 801ae56:	4401      	add	r1, r0
 801ae58:	4811      	ldr	r0, [pc, #68]	; (801aea0 <InitMetaDataManager+0x300>)
 801ae5a:	f00d f8df 	bl	802801c <iprintf>
            puint8_RW_MetaData +=pMetaDataHeader->Lenght;
 801ae5e:	6878      	ldr	r0, [r7, #4]
 801ae60:	682f      	ldr	r7, [r5, #0]
 801ae62:	e7cb      	b.n	801adfc <InitMetaDataManager+0x25c>
        MDM_PRINTF("Error Unknow Meta Data Type\r\n");
 801ae64:	9b03      	ldr	r3, [sp, #12]
 801ae66:	781b      	ldrb	r3, [r3, #0]
 801ae68:	2b00      	cmp	r3, #0
 801ae6a:	d17b      	bne.n	801af64 <InitMetaDataManager+0x3c4>
}
 801ae6c:	b007      	add	sp, #28
 801ae6e:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 801ae72:	b004      	add	sp, #16
 801ae74:	4770      	bx	lr
 801ae76:	bf00      	nop
 801ae78:	080ff000 	.word	0x080ff000
 801ae7c:	2000014c 	.word	0x2000014c
 801ae80:	20008138 	.word	0x20008138
 801ae84:	12345678 	.word	0x12345678
 801ae88:	20000d84 	.word	0x20000d84
 801ae8c:	20008130 	.word	0x20008130
 801ae90:	200080e8 	.word	0x200080e8
 801ae94:	08041a50 	.word	0x08041a50
 801ae98:	20000290 	.word	0x20000290
 801ae9c:	080418bc 	.word	0x080418bc
 801aea0:	080419e8 	.word	0x080419e8
 801aea4:	08041a94 	.word	0x08041a94
        for(Index =0; known_OsxLic[Index].LicEnum!=OSX_END ;Index++) {
 801aea8:	783b      	ldrb	r3, [r7, #0]
 801aeaa:	2b00      	cmp	r3, #0
 801aeac:	f000 80de 	beq.w	801b06c <InitMetaDataManager+0x4cc>
 801aeb0:	f8db 3004 	ldr.w	r3, [fp, #4]
 801aeb4:	463a      	mov	r2, r7
 801aeb6:	3301      	adds	r3, #1
 801aeb8:	f812 4f2d 	ldrb.w	r4, [r2, #45]!
 801aebc:	4619      	mov	r1, r3
 801aebe:	3301      	adds	r3, #1
 801aec0:	2c00      	cmp	r4, #0
 801aec2:	d1f9      	bne.n	801aeb8 <InitMetaDataManager+0x318>
 801aec4:	f8cb 1004 	str.w	r1, [fp, #4]
 801aec8:	e6b0      	b.n	801ac2c <InitMetaDataManager+0x8c>
    pMetaDataManagerHeader->IsIntialized = data32;
 801aeca:	499c      	ldr	r1, [pc, #624]	; (801b13c <InitMetaDataManager+0x59c>)
 801aecc:	9a05      	ldr	r2, [sp, #20]
 801aece:	f841 2c08 	str.w	r2, [r1, #-8]
    data32 = *(__IO uint32_t*) Address;
 801aed2:	685a      	ldr	r2, [r3, #4]
 801aed4:	9205      	str	r2, [sp, #20]
    pMetaDataManagerHeader->Version = data32;
 801aed6:	9a05      	ldr	r2, [sp, #20]
 801aed8:	f841 2c04 	str.w	r2, [r1, #-4]
    if(pMetaDataManagerHeader->Version !=  MDM_VERSION) {
 801aedc:	f5b2 3f80 	cmp.w	r2, #65536	; 0x10000
    pMetaDataManagerHeader->IsIntialized = data32;
 801aee0:	f1a1 0108 	sub.w	r1, r1, #8
    if(pMetaDataManagerHeader->Version !=  MDM_VERSION) {
 801aee4:	f040 80a0 	bne.w	801b028 <InitMetaDataManager+0x488>
    data32 = *(__IO uint32_t*) Address;
 801aee8:	689b      	ldr	r3, [r3, #8]
 801aeea:	9305      	str	r3, [sp, #20]
    while(data32!=MDM_DATA_TYPE_END) {
 801aeec:	9b05      	ldr	r3, [sp, #20]
 801aeee:	2bff      	cmp	r3, #255	; 0xff
 801aef0:	f000 80e4 	beq.w	801b0bc <InitMetaDataManager+0x51c>
    Address+=4;
 801aef4:	f8df 827c 	ldr.w	r8, [pc, #636]	; 801b174 <InitMetaDataManager+0x5d4>
    while(data32!=MDM_DATA_TYPE_END) {
 801aef8:	f8df e240 	ldr.w	lr, [pc, #576]	; 801b13c <InitMetaDataManager+0x59c>
 801aefc:	46bc      	mov	ip, r7
      Type = (MDM_MetaDataType_t) data32;
 801aefe:	9b05      	ldr	r3, [sp, #20]
      data32 = *(__IO uint32_t*) Address;
 801af00:	f8d8 2004 	ldr.w	r2, [r8, #4]
 801af04:	9205      	str	r2, [sp, #20]
      Lenght = data32;
 801af06:	9f05      	ldr	r7, [sp, #20]
      pMetaDataHeader->Type = Type;
 801af08:	b2db      	uxtb	r3, r3
      for(Index=0;Index<(Lenght-8);Index+=4) {
 801af0a:	f1b7 0408 	subs.w	r4, r7, #8
      pMetaDataHeader->Lenght =  Lenght;      
 801af0e:	e9ce 3700 	strd	r3, r7, [lr]
      puint32_MetaData = (uint32_t *) pMetaDataHeader->puint8_PayLoad;
 801af12:	f10e 0008 	add.w	r0, lr, #8
      for(Index=0;Index<(Lenght-8);Index+=4) {
 801af16:	d00b      	beq.n	801af30 <InitMetaDataManager+0x390>
 801af18:	2300      	movs	r3, #0
 801af1a:	f108 0608 	add.w	r6, r8, #8
        data32 = *(__IO uint32_t*) (Address+Index);
 801af1e:	58f2      	ldr	r2, [r6, r3]
 801af20:	9205      	str	r2, [sp, #20]
        puint32_MetaData[Index>>2] = data32;
 801af22:	089a      	lsrs	r2, r3, #2
      for(Index=0;Index<(Lenght-8);Index+=4) {
 801af24:	3304      	adds	r3, #4
        puint32_MetaData[Index>>2] = data32;
 801af26:	9905      	ldr	r1, [sp, #20]
 801af28:	f840 1022 	str.w	r1, [r0, r2, lsl #2]
      for(Index=0;Index<(Lenght-8);Index+=4) {
 801af2c:	42a3      	cmp	r3, r4
 801af2e:	d3f6      	bcc.n	801af1e <InitMetaDataManager+0x37e>
      Address +=Lenght-8;
 801af30:	44b8      	add	r8, r7
      puint8_RW_MetaData +=Lenght-8;
 801af32:	44be      	add	lr, r7
      data32 = *(__IO uint32_t*) Address;
 801af34:	f8d8 3000 	ldr.w	r3, [r8]
 801af38:	9305      	str	r3, [sp, #20]
    while(data32!=MDM_DATA_TYPE_END) {
 801af3a:	9b05      	ldr	r3, [sp, #20]
 801af3c:	2bff      	cmp	r3, #255	; 0xff
 801af3e:	d1de      	bne.n	801aefe <InitMetaDataManager+0x35e>
    *((uint32_t *) puint8_RW_MetaData)     = MDM_DATA_TYPE_END;
 801af40:	f8ce 3000 	str.w	r3, [lr]
    *(((uint32_t *) puint8_RW_MetaData)+4) = 0; /* No Payload */
 801af44:	2300      	movs	r3, #0
 801af46:	f8ce 3010 	str.w	r3, [lr, #16]
    MDM_PRINTF("Meta Data Manager read from Flash\r\n");
 801af4a:	4b7d      	ldr	r3, [pc, #500]	; (801b140 <InitMetaDataManager+0x5a0>)
 801af4c:	9303      	str	r3, [sp, #12]
 801af4e:	781b      	ldrb	r3, [r3, #0]
 801af50:	f8c5 e000 	str.w	lr, [r5]
 801af54:	4667      	mov	r7, ip
 801af56:	2b00      	cmp	r3, #0
 801af58:	f43f ae3a 	beq.w	801abd0 <InitMetaDataManager+0x30>
 801af5c:	4879      	ldr	r0, [pc, #484]	; (801b144 <InitMetaDataManager+0x5a4>)
 801af5e:	f00d f8f9 	bl	8028154 <puts>
 801af62:	e635      	b.n	801abd0 <InitMetaDataManager+0x30>
        MDM_PRINTF("Error Unknow Meta Data Type\r\n");
 801af64:	4878      	ldr	r0, [pc, #480]	; (801b148 <InitMetaDataManager+0x5a8>)
 801af66:	f00d f8f5 	bl	8028154 <puts>
}
 801af6a:	b007      	add	sp, #28
 801af6c:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 801af70:	b004      	add	sp, #16
 801af72:	4770      	bx	lr
        if(((((uint32_t) puint8_RW_MetaData)+8/* for the MDM_DATA_TYPE_END */) -
 801af74:	682c      	ldr	r4, [r5, #0]
             ((uint32_t)uint64_MetaDataVector) +
 801af76:	4b75      	ldr	r3, [pc, #468]	; (801b14c <InitMetaDataManager+0x5ac>)
 801af78:	1ae3      	subs	r3, r4, r3
             (NumberOfKnownLic-NumberofFoundedLic)*(sizeof(MDM_PayLoadLic_t) + 8 /* MetaDataHeader */))>(MDM_MAX_DATASIZE_64<<3)) {
 801af7a:	1b91      	subs	r1, r2, r6
             ((uint32_t)uint64_MetaDataVector) +
 801af7c:	3308      	adds	r3, #8
             (NumberOfKnownLic-NumberofFoundedLic)*(sizeof(MDM_PayLoadLic_t) + 8 /* MetaDataHeader */))>(MDM_MAX_DATASIZE_64<<3)) {
 801af7e:	20a4      	movs	r0, #164	; 0xa4
             ((uint32_t)uint64_MetaDataVector) +
 801af80:	fb00 3301 	mla	r3, r0, r1, r3
        if(((((uint32_t) puint8_RW_MetaData)+8/* for the MDM_DATA_TYPE_END */) -
 801af84:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
        NecessityToSaveMetaDataManager = 1;
 801af88:	f04f 0101 	mov.w	r1, #1
 801af8c:	f8cb 1000 	str.w	r1, [fp]
        if(((((uint32_t) puint8_RW_MetaData)+8/* for the MDM_DATA_TYPE_END */) -
 801af90:	d854      	bhi.n	801b03c <InitMetaDataManager+0x49c>
        for(Index=0;Index<NumberOfKnownLic; Index++) {
 801af92:	2a00      	cmp	r2, #0
 801af94:	d036      	beq.n	801b004 <InitMetaDataManager+0x464>
 801af96:	3709      	adds	r7, #9
 801af98:	f04f 0800 	mov.w	r8, #0
            pMetaDataHeader->Lenght = sizeof(MDM_PayLoadLic_t) + 8 /* For Meta Data Header */;
 801af9c:	46b2      	mov	sl, r6
 801af9e:	f8cd 9000 	str.w	r9, [sp]
 801afa2:	e005      	b.n	801afb0 <InitMetaDataManager+0x410>
        for(Index=0;Index<NumberOfKnownLic; Index++) {
 801afa4:	f8db 3004 	ldr.w	r3, [fp, #4]
 801afa8:	4543      	cmp	r3, r8
 801afaa:	f107 072d 	add.w	r7, r7, #45	; 0x2d
 801afae:	d926      	bls.n	801affe <InitMetaDataManager+0x45e>
          if(MDM_LicTable[known_OsxLic[Index].LicEnum].Address==0) {
 801afb0:	f817 2c09 	ldrb.w	r2, [r7, #-9]
 801afb4:	eb05 1342 	add.w	r3, r5, r2, lsl #5
        for(Index=0;Index<NumberOfKnownLic; Index++) {
 801afb8:	f108 0801 	add.w	r8, r8, #1
          if(MDM_LicTable[known_OsxLic[Index].LicEnum].Address==0) {
 801afbc:	6a1b      	ldr	r3, [r3, #32]
 801afbe:	2b00      	cmp	r3, #0
 801afc0:	d1f0      	bne.n	801afa4 <InitMetaDataManager+0x404>
            pMetaDataHeader->Type = MDM_DATA_TYPE_LIC;
 801afc2:	6023      	str	r3, [r4, #0]
            PayLoad->osxLicenseInitialized = 0;
 801afc4:	60e3      	str	r3, [r4, #12]
            sprintf((char *)PayLoad->osxLibVersion,known_OsxLic[Index].osxLibVersion);
 801afc6:	f104 0910 	add.w	r9, r4, #16
            pMetaDataHeader->Lenght = sizeof(MDM_PayLoadLic_t) + 8 /* For Meta Data Header */;
 801afca:	23a4      	movs	r3, #164	; 0xa4
            PayLoad->LicEnum = known_OsxLic[Index].LicEnum;
 801afcc:	60a2      	str	r2, [r4, #8]
            pMetaDataHeader->Lenght = sizeof(MDM_PayLoadLic_t) + 8 /* For Meta Data Header */;
 801afce:	6063      	str	r3, [r4, #4]
            sprintf((char *)PayLoad->osxLibVersion,known_OsxLic[Index].osxLibVersion);
 801afd0:	4639      	mov	r1, r7
 801afd2:	4648      	mov	r0, r9
 801afd4:	f00d f8d6 	bl	8028184 <siprintf>
            MDM_PRINTF("Adding=%s%s Version=%s\r\n",MDM_LicTable[known_OsxLic[Index].LicEnum].LicType,MDM_LicTable[known_OsxLic[Index].LicEnum].LicName,PayLoad->osxLibVersion);
 801afd8:	9b03      	ldr	r3, [sp, #12]
 801afda:	781a      	ldrb	r2, [r3, #0]
            PayLoad = (MDM_PayLoadLic_t *) pMetaDataHeader->puint8_PayLoad;
 801afdc:	f104 0608 	add.w	r6, r4, #8
            MDM_PRINTF("Adding=%s%s Version=%s\r\n",MDM_LicTable[known_OsxLic[Index].LicEnum].LicType,MDM_LicTable[known_OsxLic[Index].LicEnum].LicName,PayLoad->osxLibVersion);
 801afe0:	b9aa      	cbnz	r2, 801b00e <InitMetaDataManager+0x46e>
            puint8_RW_MetaData +=pMetaDataHeader->Lenght;
 801afe2:	e9d4 2301 	ldrd	r2, r3, [r4, #4]
            MDM_LicTable[PayLoad->LicEnum].Address = (uint32_t)PayLoad;
 801afe6:	eb05 1343 	add.w	r3, r5, r3, lsl #5
            puint8_RW_MetaData +=pMetaDataHeader->Lenght;
 801afea:	682c      	ldr	r4, [r5, #0]
            MDM_LicTable[PayLoad->LicEnum].Address = (uint32_t)PayLoad;
 801afec:	621e      	str	r6, [r3, #32]
        for(Index=0;Index<NumberOfKnownLic; Index++) {
 801afee:	f8db 3004 	ldr.w	r3, [fp, #4]
            puint8_RW_MetaData +=pMetaDataHeader->Lenght;
 801aff2:	4414      	add	r4, r2
        for(Index=0;Index<NumberOfKnownLic; Index++) {
 801aff4:	4543      	cmp	r3, r8
            puint8_RW_MetaData +=pMetaDataHeader->Lenght;
 801aff6:	602c      	str	r4, [r5, #0]
        for(Index=0;Index<NumberOfKnownLic; Index++) {
 801aff8:	f107 072d 	add.w	r7, r7, #45	; 0x2d
 801affc:	d8d8      	bhi.n	801afb0 <InitMetaDataManager+0x410>
 801affe:	f8dd 9000 	ldr.w	r9, [sp]
 801b002:	4656      	mov	r6, sl
        *((uint32_t *) (puint8_RW_MetaData+4)) = 0; /* No Payload */
 801b004:	21ff      	movs	r1, #255	; 0xff
 801b006:	2300      	movs	r3, #0
 801b008:	e9c4 1300 	strd	r1, r3, [r4]
 801b00c:	e62f      	b.n	801ac6e <InitMetaDataManager+0xce>
            MDM_PRINTF("Adding=%s%s Version=%s\r\n",MDM_LicTable[known_OsxLic[Index].LicEnum].LicType,MDM_LicTable[known_OsxLic[Index].LicEnum].LicName,PayLoad->osxLibVersion);
 801b00e:	f817 1c09 	ldrb.w	r1, [r7, #-9]
 801b012:	484f      	ldr	r0, [pc, #316]	; (801b150 <InitMetaDataManager+0x5b0>)
 801b014:	0149      	lsls	r1, r1, #5
 801b016:	1d0a      	adds	r2, r1, #4
 801b018:	3110      	adds	r1, #16
 801b01a:	4402      	add	r2, r0
 801b01c:	4401      	add	r1, r0
 801b01e:	464b      	mov	r3, r9
 801b020:	484c      	ldr	r0, [pc, #304]	; (801b154 <InitMetaDataManager+0x5b4>)
 801b022:	f00c fffb 	bl	802801c <iprintf>
 801b026:	e7dc      	b.n	801afe2 <InitMetaDataManager+0x442>
      MDM_PRINTF("Warning: The Meta Data Manager in FLASH is not Compatible\r\n\tIt will be ERASED\r\n");
 801b028:	4b45      	ldr	r3, [pc, #276]	; (801b140 <InitMetaDataManager+0x5a0>)
 801b02a:	9303      	str	r3, [sp, #12]
 801b02c:	781b      	ldrb	r3, [r3, #0]
 801b02e:	2b00      	cmp	r3, #0
 801b030:	f43f adcc 	beq.w	801abcc <InitMetaDataManager+0x2c>
 801b034:	4848      	ldr	r0, [pc, #288]	; (801b158 <InitMetaDataManager+0x5b8>)
 801b036:	f00d f88d 	bl	8028154 <puts>
 801b03a:	e5c7      	b.n	801abcc <InitMetaDataManager+0x2c>
          MDM_PRINTF("Meta Data Manager has not enough free space.. It will be reseted\r\n");
 801b03c:	9b03      	ldr	r3, [sp, #12]
 801b03e:	781b      	ldrb	r3, [r3, #0]
 801b040:	bb0b      	cbnz	r3, 801b086 <InitMetaDataManager+0x4e6>
          puint8_RW_MetaData = ((uint8_t *) uint64_MetaDataVector)+8;
 801b042:	4b3e      	ldr	r3, [pc, #248]	; (801b13c <InitMetaDataManager+0x59c>)
 801b044:	602b      	str	r3, [r5, #0]
          for(Index=1;Index<OSX_LICENSE_NUM;Index++) {
 801b046:	4b42      	ldr	r3, [pc, #264]	; (801b150 <InitMetaDataManager+0x5b0>)
            MDM_LicTable[Index].Address =0;
 801b048:	2000      	movs	r0, #0
 801b04a:	f503 7190 	add.w	r1, r3, #288	; 0x120
 801b04e:	63d8      	str	r0, [r3, #60]	; 0x3c
          for(Index=1;Index<OSX_LICENSE_NUM;Index++) {
 801b050:	3320      	adds	r3, #32
 801b052:	4299      	cmp	r1, r3
 801b054:	d1fb      	bne.n	801b04e <InitMetaDataManager+0x4ae>
 801b056:	4c39      	ldr	r4, [pc, #228]	; (801b13c <InitMetaDataManager+0x59c>)
          NumberofFoundedLic = 0;
 801b058:	2600      	movs	r6, #0
 801b05a:	e79a      	b.n	801af92 <InitMetaDataManager+0x3f2>
              MDM_PRINTF("Warning: The Meta Data Manager Contains for %s Generic Meta Data a size=%ld different from what we need =%ld\r\n\tIt will be ERASED\r\n",
 801b05c:	483f      	ldr	r0, [pc, #252]	; (801b15c <InitMetaDataManager+0x5bc>)
 801b05e:	f10c 0104 	add.w	r1, ip, #4
 801b062:	4401      	add	r1, r0
 801b064:	483e      	ldr	r0, [pc, #248]	; (801b160 <InitMetaDataManager+0x5c0>)
 801b066:	f00c ffd9 	bl	802801c <iprintf>
 801b06a:	e68c      	b.n	801ad86 <InitMetaDataManager+0x1e6>
    MDM_knownGMD_t *known_GMD=NULL;
 801b06c:	9c02      	ldr	r4, [sp, #8]
 801b06e:	e5dd      	b.n	801ac2c <InitMetaDataManager+0x8c>
        for(Index =0; known_GMD[Index].GMDType!=GMD_END ;Index++) {
 801b070:	463c      	mov	r4, r7
    MDM_knownOsxLicense_t *known_OsxLic=NULL;
 801b072:	461f      	mov	r7, r3
 801b074:	e5da      	b.n	801ac2c <InitMetaDataManager+0x8c>
 801b076:	9e00      	ldr	r6, [sp, #0]
        *((uint32_t *) (puint8_RW_MetaData+4)) = 0; /* No Payload */
 801b078:	22ff      	movs	r2, #255	; 0xff
 801b07a:	2300      	movs	r3, #0
 801b07c:	e9c7 2300 	strd	r2, r3, [r7]
 801b080:	e5f5      	b.n	801ac6e <InitMetaDataManager+0xce>
  while(KnownMetaDataTable!=NULL) {
 801b082:	46ba      	mov	sl, r7
 801b084:	e5fc      	b.n	801ac80 <InitMetaDataManager+0xe0>
          MDM_PRINTF("Meta Data Manager has not enough free space.. It will be reseted\r\n");
 801b086:	4837      	ldr	r0, [pc, #220]	; (801b164 <InitMetaDataManager+0x5c4>)
 801b088:	f00d f864 	bl	8028154 <puts>
        for(Index=0;Index<NumberOfKnownLic; Index++) {
 801b08c:	f8db 2004 	ldr.w	r2, [fp, #4]
 801b090:	e7d7      	b.n	801b042 <InitMetaDataManager+0x4a2>
  uint32_t Success = UserFunctionForErasingFlash();
 801b092:	f004 fbcd 	bl	801f830 <UserFunctionForErasingFlash>
    MDM_PRINTF("Meta Data Manager erased in FLASH\r\n");
 801b096:	9b03      	ldr	r3, [sp, #12]
 801b098:	781b      	ldrb	r3, [r3, #0]
  if(Success) {
 801b09a:	2800      	cmp	r0, #0
 801b09c:	f43f adf7 	beq.w	801ac8e <InitMetaDataManager+0xee>
    MDM_PRINTF("Meta Data Manager erased in FLASH\r\n");
 801b0a0:	2b00      	cmp	r3, #0
 801b0a2:	d13d      	bne.n	801b120 <InitMetaDataManager+0x580>
  uint32_t Success = UserFunctionForSavingFlash((void *)uint64_MetaDataVector,(void *)(puint8_RW_MetaData +8));
 801b0a4:	6829      	ldr	r1, [r5, #0]
 801b0a6:	4829      	ldr	r0, [pc, #164]	; (801b14c <InitMetaDataManager+0x5ac>)
 801b0a8:	3108      	adds	r1, #8
 801b0aa:	f004 fc0b 	bl	801f8c4 <UserFunctionForSavingFlash>
  if(Success) {
 801b0ae:	2800      	cmp	r0, #0
 801b0b0:	d031      	beq.n	801b116 <InitMetaDataManager+0x576>
    MDM_PRINTF("Meta Data Manager Saved in FLASH\r\n");
 801b0b2:	9b03      	ldr	r3, [sp, #12]
 801b0b4:	781b      	ldrb	r3, [r3, #0]
 801b0b6:	bb5b      	cbnz	r3, 801b110 <InitMetaDataManager+0x570>
  NecessityToSaveMetaDataManager=0;
 801b0b8:	6023      	str	r3, [r4, #0]
  MDM_PRINTF("Meta Data Manager version=%ld.%ld.%ld\r\n",
 801b0ba:	e5f2      	b.n	801aca2 <InitMetaDataManager+0x102>
    *((uint32_t *) puint8_RW_MetaData)     = MDM_DATA_TYPE_END;
 801b0bc:	608b      	str	r3, [r1, #8]
    *(((uint32_t *) puint8_RW_MetaData)+4) = 0; /* No Payload */
 801b0be:	2300      	movs	r3, #0
 801b0c0:	618b      	str	r3, [r1, #24]
    MDM_PRINTF("Meta Data Manager read from Flash\r\n");
 801b0c2:	4b1f      	ldr	r3, [pc, #124]	; (801b140 <InitMetaDataManager+0x5a0>)
 801b0c4:	9303      	str	r3, [sp, #12]
 801b0c6:	781b      	ldrb	r3, [r3, #0]
 801b0c8:	2b00      	cmp	r3, #0
 801b0ca:	f43f ad7f 	beq.w	801abcc <InitMetaDataManager+0x2c>
 801b0ce:	481d      	ldr	r0, [pc, #116]	; (801b144 <InitMetaDataManager+0x5a4>)
 801b0d0:	f00d f840 	bl	8028154 <puts>
 801b0d4:	e57a      	b.n	801abcc <InitMetaDataManager+0x2c>
        if(((((uint32_t) puint8_RW_MetaData)+8/* for the MDM_DATA_TYPE_END */) -
 801b0d6:	682f      	ldr	r7, [r5, #0]
             ((uint32_t)uint64_MetaDataVector) +
 801b0d8:	4b1c      	ldr	r3, [pc, #112]	; (801b14c <InitMetaDataManager+0x5ac>)
 801b0da:	1afb      	subs	r3, r7, r3
 801b0dc:	3308      	adds	r3, #8
        if(((((uint32_t) puint8_RW_MetaData)+8/* for the MDM_DATA_TYPE_END */) -
 801b0de:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
 801b0e2:	d9c9      	bls.n	801b078 <InitMetaDataManager+0x4d8>
          MDM_PRINTF("Meta Data Manager has not enough free space.. It will be reseted\r\n");
 801b0e4:	9b03      	ldr	r3, [sp, #12]
 801b0e6:	781b      	ldrb	r3, [r3, #0]
 801b0e8:	b9f3      	cbnz	r3, 801b128 <InitMetaDataManager+0x588>
          puint8_RW_MetaData = ((uint8_t *) uint64_MetaDataVector)+8;
 801b0ea:	4b14      	ldr	r3, [pc, #80]	; (801b13c <InitMetaDataManager+0x59c>)
 801b0ec:	602b      	str	r3, [r5, #0]
          for(Index=1;Index<GMD_NUM;Index++) {
 801b0ee:	4b1b      	ldr	r3, [pc, #108]	; (801b15c <InitMetaDataManager+0x5bc>)
            MDM_GMDTable[Index].Address =0;
 801b0f0:	2100      	movs	r1, #0
 801b0f2:	f503 72b6 	add.w	r2, r3, #364	; 0x16c
 801b0f6:	6359      	str	r1, [r3, #52]	; 0x34
          for(Index=1;Index<GMD_NUM;Index++) {
 801b0f8:	331c      	adds	r3, #28
 801b0fa:	429a      	cmp	r2, r3
 801b0fc:	d1fb      	bne.n	801b0f6 <InitMetaDataManager+0x556>
        for(Index=0;Index<NumberOfKnownGMD; Index++) {
 801b0fe:	b1c8      	cbz	r0, 801b134 <InitMetaDataManager+0x594>
 801b100:	4f0e      	ldr	r7, [pc, #56]	; (801b13c <InitMetaDataManager+0x59c>)
          NumberofFoundedGMD = 0;
 801b102:	f04f 0900 	mov.w	r9, #0
 801b106:	e674      	b.n	801adf2 <InitMetaDataManager+0x252>
  MDM_PRINTF("\tGeneric Meta Data found:\r\n");
 801b108:	4817      	ldr	r0, [pc, #92]	; (801b168 <InitMetaDataManager+0x5c8>)
 801b10a:	f00d f823 	bl	8028154 <puts>
 801b10e:	e5d2      	b.n	801acb6 <InitMetaDataManager+0x116>
    MDM_PRINTF("Meta Data Manager Saved in FLASH\r\n");
 801b110:	4816      	ldr	r0, [pc, #88]	; (801b16c <InitMetaDataManager+0x5cc>)
 801b112:	f00d f81f 	bl	8028154 <puts>
  MDM_PRINTF("Meta Data Manager version=%ld.%ld.%ld\r\n",
 801b116:	9b03      	ldr	r3, [sp, #12]
  NecessityToSaveMetaDataManager=0;
 801b118:	2200      	movs	r2, #0
  MDM_PRINTF("Meta Data Manager version=%ld.%ld.%ld\r\n",
 801b11a:	781b      	ldrb	r3, [r3, #0]
  NecessityToSaveMetaDataManager=0;
 801b11c:	6022      	str	r2, [r4, #0]
}
 801b11e:	e5b6      	b.n	801ac8e <InitMetaDataManager+0xee>
    MDM_PRINTF("Meta Data Manager erased in FLASH\r\n");
 801b120:	4813      	ldr	r0, [pc, #76]	; (801b170 <InitMetaDataManager+0x5d0>)
 801b122:	f00d f817 	bl	8028154 <puts>
 801b126:	e7bd      	b.n	801b0a4 <InitMetaDataManager+0x504>
          MDM_PRINTF("Meta Data Manager has not enough free space.. It will be reseted\r\n");
 801b128:	480e      	ldr	r0, [pc, #56]	; (801b164 <InitMetaDataManager+0x5c4>)
 801b12a:	f00d f813 	bl	8028154 <puts>
        for(Index=0;Index<NumberOfKnownGMD; Index++) {
 801b12e:	f8db 0008 	ldr.w	r0, [fp, #8]
 801b132:	e7da      	b.n	801b0ea <InitMetaDataManager+0x54a>
 801b134:	4f01      	ldr	r7, [pc, #4]	; (801b13c <InitMetaDataManager+0x59c>)
          NumberofFoundedGMD = 0;
 801b136:	4681      	mov	r9, r0
 801b138:	e79e      	b.n	801b078 <InitMetaDataManager+0x4d8>
 801b13a:	bf00      	nop
 801b13c:	20008138 	.word	0x20008138
 801b140:	20000d84 	.word	0x20000d84
 801b144:	08041898 	.word	0x08041898
 801b148:	080418e4 	.word	0x080418e4
 801b14c:	20008130 	.word	0x20008130
 801b150:	20000150 	.word	0x20000150
 801b154:	080419cc 	.word	0x080419cc
 801b158:	08041848 	.word	0x08041848
 801b15c:	20000290 	.word	0x20000290
 801b160:	08041904 	.word	0x08041904
 801b164:	08041988 	.word	0x08041988
 801b168:	08041a78 	.word	0x08041a78
 801b16c:	08041a2c 	.word	0x08041a2c
 801b170:	08041a08 	.word	0x08041a08
 801b174:	080ff008 	.word	0x080ff008

0801b178 <EraseMetaDataManager>:
uint32_t EraseMetaDataManager(void) {
 801b178:	b510      	push	{r4, lr}
  uint32_t Success = UserFunctionForErasingFlash();
 801b17a:	f004 fb59 	bl	801f830 <UserFunctionForErasingFlash>
  if(Success) {
 801b17e:	4604      	mov	r4, r0
 801b180:	b110      	cbz	r0, 801b188 <EraseMetaDataManager+0x10>
    MDM_PRINTF("Meta Data Manager erased in FLASH\r\n");
 801b182:	4b05      	ldr	r3, [pc, #20]	; (801b198 <EraseMetaDataManager+0x20>)
 801b184:	781b      	ldrb	r3, [r3, #0]
 801b186:	b90b      	cbnz	r3, 801b18c <EraseMetaDataManager+0x14>
}
 801b188:	4620      	mov	r0, r4
 801b18a:	bd10      	pop	{r4, pc}
    MDM_PRINTF("Meta Data Manager erased in FLASH\r\n");
 801b18c:	4803      	ldr	r0, [pc, #12]	; (801b19c <EraseMetaDataManager+0x24>)
 801b18e:	f00c ffe1 	bl	8028154 <puts>
}
 801b192:	4620      	mov	r0, r4
 801b194:	bd10      	pop	{r4, pc}
 801b196:	bf00      	nop
 801b198:	20000d84 	.word	0x20000d84
 801b19c:	08041a08 	.word	0x08041a08

0801b1a0 <SaveMetaDataManager>:
{
 801b1a0:	b508      	push	{r3, lr}
  uint32_t Success = UserFunctionForSavingFlash((void *)uint64_MetaDataVector,(void *)(puint8_RW_MetaData +8));
 801b1a2:	4b0a      	ldr	r3, [pc, #40]	; (801b1cc <SaveMetaDataManager+0x2c>)
 801b1a4:	480a      	ldr	r0, [pc, #40]	; (801b1d0 <SaveMetaDataManager+0x30>)
 801b1a6:	6819      	ldr	r1, [r3, #0]
 801b1a8:	3108      	adds	r1, #8
 801b1aa:	f004 fb8b 	bl	801f8c4 <UserFunctionForSavingFlash>
  if(Success) {
 801b1ae:	b110      	cbz	r0, 801b1b6 <SaveMetaDataManager+0x16>
    MDM_PRINTF("Meta Data Manager Saved in FLASH\r\n");
 801b1b0:	4b08      	ldr	r3, [pc, #32]	; (801b1d4 <SaveMetaDataManager+0x34>)
 801b1b2:	781b      	ldrb	r3, [r3, #0]
 801b1b4:	b91b      	cbnz	r3, 801b1be <SaveMetaDataManager+0x1e>
  NecessityToSaveMetaDataManager=0;
 801b1b6:	4b08      	ldr	r3, [pc, #32]	; (801b1d8 <SaveMetaDataManager+0x38>)
 801b1b8:	2200      	movs	r2, #0
 801b1ba:	601a      	str	r2, [r3, #0]
}
 801b1bc:	bd08      	pop	{r3, pc}
    MDM_PRINTF("Meta Data Manager Saved in FLASH\r\n");
 801b1be:	4807      	ldr	r0, [pc, #28]	; (801b1dc <SaveMetaDataManager+0x3c>)
 801b1c0:	f00c ffc8 	bl	8028154 <puts>
  NecessityToSaveMetaDataManager=0;
 801b1c4:	4b04      	ldr	r3, [pc, #16]	; (801b1d8 <SaveMetaDataManager+0x38>)
 801b1c6:	2200      	movs	r2, #0
 801b1c8:	601a      	str	r2, [r3, #0]
}
 801b1ca:	bd08      	pop	{r3, pc}
 801b1cc:	2000014c 	.word	0x2000014c
 801b1d0:	20008130 	.word	0x20008130
 801b1d4:	20000d84 	.word	0x20000d84
 801b1d8:	200080e8 	.word	0x200080e8
 801b1dc:	08041a2c 	.word	0x08041a2c

0801b1e0 <MDM_SaveGMD>:
 * @param MDM_GenericMetaDataType_t GMDType Generic Meta Data type that we want to save
 * @param void *GMD Pointer where find the Generic Meta Data
 * @retval uin32_t Success/NotSuccess (1/0)
 */
uint32_t MDM_SaveGMD(MDM_GenericMetaDataType_t GMDType,void *GMD)
{
 801b1e0:	b570      	push	{r4, r5, r6, lr}
  uint32_t RetValue=1;
  if(MDM_GMDTable[GMDType].Address!=0) {
 801b1e2:	4d14      	ldr	r5, [pc, #80]	; (801b234 <MDM_SaveGMD+0x54>)
 801b1e4:	ebc0 03c0 	rsb	r3, r0, r0, lsl #3
 801b1e8:	009e      	lsls	r6, r3, #2
 801b1ea:	eb05 0383 	add.w	r3, r5, r3, lsl #2
 801b1ee:	f8d3 415c 	ldr.w	r4, [r3, #348]	; 0x15c
 801b1f2:	b954      	cbnz	r4, 801b20a <MDM_SaveGMD+0x2a>
    MDM_PayLoadGMD_t *MDMPayLoad = (MDM_PayLoadGMD_t *)MDM_GMDTable[GMDType].Address;
    memcpy((void *)MDMPayLoad->puint8_GMD,GMD,MDMPayLoad->GMDSize);
    NecessityToSaveMetaDataManager=1;
    MDM_PRINTF("Updating the Generic Meta Data type=%s\r\n",MDM_GMDTable[GMDType].GMDName);
  } else {
    MDM_PRINTF("ERROR before saving one Generic Meta Datait's necessary Initializes the MDM with the same type=%d\r\n",GMDType);
 801b1f4:	4b10      	ldr	r3, [pc, #64]	; (801b238 <MDM_SaveGMD+0x58>)
 801b1f6:	781b      	ldrb	r3, [r3, #0]
 801b1f8:	b90b      	cbnz	r3, 801b1fe <MDM_SaveGMD+0x1e>
    RetValue=0;
  }
  return RetValue;
}
 801b1fa:	4620      	mov	r0, r4
 801b1fc:	bd70      	pop	{r4, r5, r6, pc}
    MDM_PRINTF("ERROR before saving one Generic Meta Datait's necessary Initializes the MDM with the same type=%d\r\n",GMDType);
 801b1fe:	4601      	mov	r1, r0
 801b200:	480e      	ldr	r0, [pc, #56]	; (801b23c <MDM_SaveGMD+0x5c>)
 801b202:	f00c ff0b 	bl	802801c <iprintf>
}
 801b206:	4620      	mov	r0, r4
 801b208:	bd70      	pop	{r4, r5, r6, pc}
    memcpy((void *)MDMPayLoad->puint8_GMD,GMD,MDMPayLoad->GMDSize);
 801b20a:	6862      	ldr	r2, [r4, #4]
 801b20c:	f104 0008 	add.w	r0, r4, #8
 801b210:	f00c f98a 	bl	8027528 <memcpy>
    MDM_PRINTF("Updating the Generic Meta Data type=%s\r\n",MDM_GMDTable[GMDType].GMDName);
 801b214:	4b08      	ldr	r3, [pc, #32]	; (801b238 <MDM_SaveGMD+0x58>)
    NecessityToSaveMetaDataManager=1;
 801b216:	4a0a      	ldr	r2, [pc, #40]	; (801b240 <MDM_SaveGMD+0x60>)
    MDM_PRINTF("Updating the Generic Meta Data type=%s\r\n",MDM_GMDTable[GMDType].GMDName);
 801b218:	781b      	ldrb	r3, [r3, #0]
    NecessityToSaveMetaDataManager=1;
 801b21a:	2401      	movs	r4, #1
 801b21c:	6014      	str	r4, [r2, #0]
    MDM_PRINTF("Updating the Generic Meta Data type=%s\r\n",MDM_GMDTable[GMDType].GMDName);
 801b21e:	2b00      	cmp	r3, #0
 801b220:	d0eb      	beq.n	801b1fa <MDM_SaveGMD+0x1a>
 801b222:	19a9      	adds	r1, r5, r6
 801b224:	f501 71a4 	add.w	r1, r1, #328	; 0x148
 801b228:	4806      	ldr	r0, [pc, #24]	; (801b244 <MDM_SaveGMD+0x64>)
 801b22a:	f00c fef7 	bl	802801c <iprintf>
}
 801b22e:	4620      	mov	r0, r4
 801b230:	bd70      	pop	{r4, r5, r6, pc}
 801b232:	bf00      	nop
 801b234:	2000014c 	.word	0x2000014c
 801b238:	20000d84 	.word	0x20000d84
 801b23c:	08041afc 	.word	0x08041afc
 801b240:	200080e8 	.word	0x200080e8
 801b244:	08041ad0 	.word	0x08041ad0

0801b248 <MDM_ReCallGMD>:
 * @retval uin32_t Success/NotSuccess (1/0)
 */
uint32_t MDM_ReCallGMD(MDM_GenericMetaDataType_t GMDType,void *GMD)
{
  uint32_t RetValue=1;
  if(MDM_GMDTable[GMDType].Address!=0) {
 801b248:	4a0e      	ldr	r2, [pc, #56]	; (801b284 <MDM_ReCallGMD+0x3c>)
{
 801b24a:	4603      	mov	r3, r0
  if(MDM_GMDTable[GMDType].Address!=0) {
 801b24c:	ebc0 00c0 	rsb	r0, r0, r0, lsl #3
 801b250:	eb02 0280 	add.w	r2, r2, r0, lsl #2
{
 801b254:	b510      	push	{r4, lr}
  if(MDM_GMDTable[GMDType].Address!=0) {
 801b256:	f8d2 415c 	ldr.w	r4, [r2, #348]	; 0x15c
 801b25a:	b954      	cbnz	r4, 801b272 <MDM_ReCallGMD+0x2a>
    MDM_PayLoadGMD_t *MDMPayLoad = (MDM_PayLoadGMD_t *)MDM_GMDTable[GMDType].Address;
    memcpy(GMD,(void *)MDMPayLoad->puint8_GMD,MDMPayLoad->GMDSize);
  } else {
    MDM_PRINTF("ERROR there is not a Generic Meta Data type=%d inside the MDM\r\n",GMDType);
 801b25c:	4a0a      	ldr	r2, [pc, #40]	; (801b288 <MDM_ReCallGMD+0x40>)
 801b25e:	7812      	ldrb	r2, [r2, #0]
 801b260:	b90a      	cbnz	r2, 801b266 <MDM_ReCallGMD+0x1e>
    RetValue=0;
  }
  return RetValue;
}
 801b262:	4620      	mov	r0, r4
 801b264:	bd10      	pop	{r4, pc}
    MDM_PRINTF("ERROR there is not a Generic Meta Data type=%d inside the MDM\r\n",GMDType);
 801b266:	4619      	mov	r1, r3
 801b268:	4808      	ldr	r0, [pc, #32]	; (801b28c <MDM_ReCallGMD+0x44>)
 801b26a:	f00c fed7 	bl	802801c <iprintf>
}
 801b26e:	4620      	mov	r0, r4
 801b270:	bd10      	pop	{r4, pc}
    memcpy(GMD,(void *)MDMPayLoad->puint8_GMD,MDMPayLoad->GMDSize);
 801b272:	6862      	ldr	r2, [r4, #4]
 801b274:	4608      	mov	r0, r1
 801b276:	f104 0108 	add.w	r1, r4, #8
  uint32_t RetValue=1;
 801b27a:	2401      	movs	r4, #1
    memcpy(GMD,(void *)MDMPayLoad->puint8_GMD,MDMPayLoad->GMDSize);
 801b27c:	f00c f954 	bl	8027528 <memcpy>
}
 801b280:	4620      	mov	r0, r4
 801b282:	bd10      	pop	{r4, pc}
 801b284:	2000014c 	.word	0x2000014c
 801b288:	20000d84 	.word	0x20000d84
 801b28c:	08041b60 	.word	0x08041b60

0801b290 <SpectrogramColumn>:
 * @param      *pInSignal  points to the in-place input signal frame of length FFTLen.
 * @param      *pOutCol    points to  output Spectrogram column.
 * @return     None
 */
void SpectrogramColumn(SpectrogramTypeDef *S, float32_t *pInSignal, float32_t *pOutCol)
{
 801b290:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  uint32_t frame_len = S->FrameLen;
 801b294:	f8d0 9010 	ldr.w	r9, [r0, #16]
  uint32_t n_fft = S->FFTLen;
 801b298:	6947      	ldr	r7, [r0, #20]
  float32_t *scratch_buffer = S->pScratch;
 801b29a:	f8d0 8018 	ldr.w	r8, [r0, #24]
{
 801b29e:	460d      	mov	r5, r1
 801b2a0:	ed2d 8b02 	vpush	{d8}
  float32_t first_energy;
  float32_t last_energy;

  /* In-place window application (on signal length, not entire n_fft) */
  /* @note: OK to typecast because hannWin content is not modified */
  arm_mult_f32(pInSignal, S->pWindow, pInSignal, frame_len);
 801b2a4:	6881      	ldr	r1, [r0, #8]
{
 801b2a6:	4606      	mov	r6, r0
 801b2a8:	4614      	mov	r4, r2
  arm_mult_f32(pInSignal, S->pWindow, pInSignal, frame_len);
 801b2aa:	464b      	mov	r3, r9
 801b2ac:	462a      	mov	r2, r5
 801b2ae:	4628      	mov	r0, r5
 801b2b0:	f00b fb9a 	bl	80269e8 <arm_mult_f32>

  /* Zero pad if signal frame length is shorter than n_fft */
  memset(&pInSignal[frame_len], 0, n_fft - frame_len);
 801b2b4:	eba7 0209 	sub.w	r2, r7, r9
 801b2b8:	eb05 0089 	add.w	r0, r5, r9, lsl #2
 801b2bc:	2100      	movs	r1, #0
 801b2be:	f00c f95b 	bl	8027578 <memset>

  /* FFT */
  arm_rfft_fast_f32(S->pRfft, pInSignal, scratch_buffer, 0);
 801b2c2:	4629      	mov	r1, r5
 801b2c4:	2300      	movs	r3, #0
 801b2c6:	6830      	ldr	r0, [r6, #0]
 801b2c8:	4642      	mov	r2, r8
 801b2ca:	f00a fec5 	bl	8026058 <arm_rfft_fast_f32>

  /* Power spectrum */
  first_energy = scratch_buffer[0] * scratch_buffer[0];
 801b2ce:	ed98 7a00 	vldr	s14, [r8]
  last_energy = scratch_buffer[1] * scratch_buffer[1];
 801b2d2:	edd8 7a01 	vldr	s15, [r8, #4]
  first_energy = scratch_buffer[0] * scratch_buffer[0];
 801b2d6:	ee27 7a07 	vmul.f32	s14, s14, s14
  pOutCol[0] = first_energy;
 801b2da:	4625      	mov	r5, r4
  arm_cmplx_mag_squared_f32(&scratch_buffer[2], &pOutCol[1], (n_fft / 2) - 1);
 801b2dc:	087f      	lsrs	r7, r7, #1
  pOutCol[0] = first_energy;
 801b2de:	eca5 7a01 	vstmia	r5!, {s14}
  last_energy = scratch_buffer[1] * scratch_buffer[1];
 801b2e2:	ee27 8aa7 	vmul.f32	s16, s15, s15
  arm_cmplx_mag_squared_f32(&scratch_buffer[2], &pOutCol[1], (n_fft / 2) - 1);
 801b2e6:	1e7a      	subs	r2, r7, #1
 801b2e8:	4629      	mov	r1, r5
 801b2ea:	f108 0008 	add.w	r0, r8, #8
 801b2ee:	f00b fb23 	bl	8026938 <arm_cmplx_mag_squared_f32>
  pOutCol[n_fft / 2] = last_energy;
 801b2f2:	00b9      	lsls	r1, r7, #2
 801b2f4:	eb04 0787 	add.w	r7, r4, r7, lsl #2
 801b2f8:	ed87 8a00 	vstr	s16, [r7]

  /* Magnitude spectrum */
  if (S->Type == SPECTRUM_TYPE_MAGNITUDE)
 801b2fc:	7933      	ldrb	r3, [r6, #4]
 801b2fe:	b99b      	cbnz	r3, 801b328 <SpectrogramColumn+0x98>
   */
  CMSIS_INLINE __STATIC_INLINE arm_status arm_sqrt_f32(
  float32_t in,
  float32_t * pOut)
  {
    if (in >= 0.0f)
 801b300:	2600      	movs	r6, #0
 801b302:	440d      	add	r5, r1
  {
    for (uint32_t i = 0; i < (n_fft / 2) + 1; i++)
    {
      arm_sqrt_f32(pOutCol[i], &pOutCol[i]);
 801b304:	ecb4 0a01 	vldmia	r4!, {s0}
 801b308:	eeb5 0ac0 	vcmpe.f32	s0, #0.0
 801b30c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801b310:	db0e      	blt.n	801b330 <SpectrogramColumn+0xa0>
 801b312:	eeb5 0a40 	vcmp.f32	s0, #0.0
 801b316:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801b31a:	d40c      	bmi.n	801b336 <SpectrogramColumn+0xa6>
#if   (__FPU_USED == 1) && defined ( __CC_ARM   )
      *pOut = __sqrtf(in);
#elif (__FPU_USED == 1) && (defined(__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050))
      *pOut = __builtin_sqrtf(in);
#elif (__FPU_USED == 1) && defined(__GNUC__)
      *pOut = __builtin_sqrtf(in);
 801b31c:	eef1 7ac0 	vsqrt.f32	s15, s0
 801b320:	ed44 7a01 	vstr	s15, [r4, #-4]
    for (uint32_t i = 0; i < (n_fft / 2) + 1; i++)
 801b324:	42ac      	cmp	r4, r5
 801b326:	d1ed      	bne.n	801b304 <SpectrogramColumn+0x74>
    }
  }
}
 801b328:	ecbd 8b02 	vpop	{d8}
 801b32c:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}

      return (ARM_MATH_SUCCESS);
    }
    else
    {
      *pOut = 0.0f;
 801b330:	f844 6c04 	str.w	r6, [r4, #-4]
      return (ARM_MATH_ARGUMENT_ERROR);
 801b334:	e7f6      	b.n	801b324 <SpectrogramColumn+0x94>
      *pOut = __builtin_sqrtf(in);
 801b336:	f00f ffd5 	bl	802b2e4 <sqrtf>
 801b33a:	eef0 7a40 	vmov.f32	s15, s0
 801b33e:	e7ef      	b.n	801b320 <SpectrogramColumn+0x90>

0801b340 <MelSpectrogramColumn>:
 * @param      *pInSignal  points to input signal frame of length FFTLen.
 * @param      *pOutCol    points to  output Mel Spectrogram column.
 * @return     None
 */
void MelSpectrogramColumn(MelSpectrogramTypeDef *S, float32_t *pInSignal, float32_t *pOutCol)
{
 801b340:	b570      	push	{r4, r5, r6, lr}
 801b342:	4604      	mov	r4, r0
  float32_t *tmp_buffer = S->SpectrogramConf->pScratch;
 801b344:	6800      	ldr	r0, [r0, #0]
 801b346:	6986      	ldr	r6, [r0, #24]
{
 801b348:	4615      	mov	r5, r2

  /* Power Spectrogram */
  SpectrogramColumn(S->SpectrogramConf, pInSignal, tmp_buffer);
 801b34a:	4632      	mov	r2, r6
 801b34c:	f7ff ffa0 	bl	801b290 <SpectrogramColumn>

  /* Mel Filter Banks Application */
  MelFilterbank(S->MelFilter, tmp_buffer, pOutCol);
 801b350:	6860      	ldr	r0, [r4, #4]
 801b352:	462a      	mov	r2, r5
 801b354:	4631      	mov	r1, r6
}
 801b356:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
  MelFilterbank(S->MelFilter, tmp_buffer, pOutCol);
 801b35a:	f000 b801 	b.w	801b360 <MelFilterbank>
 801b35e:	bf00      	nop

0801b360 <MelFilterbank>:
  uint16_t start_idx;
  uint16_t stop_idx;
  uint32_t *pStart_idxs = M->pStartIndices;
  uint32_t *pStop_idxs = M->pStopIndices;
  float32_t *pCoefs = M->pCoefficients;
  uint32_t n_mels = M->NumMels;
 801b360:	6903      	ldr	r3, [r0, #16]
{
 801b362:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
  uint32_t *pStop_idxs = M->pStopIndices;
 801b366:	e9d0 5600 	ldrd	r5, r6, [r0]
  float32_t *pCoefs = M->pCoefficients;
 801b36a:	6884      	ldr	r4, [r0, #8]
  float32_t sum;

  for (uint32_t i = 0; i < n_mels; i++)
 801b36c:	b35b      	cbz	r3, 801b3c6 <MelFilterbank+0x66>
 801b36e:	eb05 0383 	add.w	r3, r5, r3, lsl #2
 801b372:	f1a5 0e04 	sub.w	lr, r5, #4
 801b376:	3e04      	subs	r6, #4
 801b378:	4615      	mov	r5, r2
 801b37a:	1f1f      	subs	r7, r3, #4
 801b37c:	f101 0804 	add.w	r8, r1, #4
  {
    start_idx = pStart_idxs[i];
    stop_idx = pStop_idxs[i];
    sum = 0.0f;
    for (uint32_t j = start_idx; j <= stop_idx; j++)
 801b380:	f85e 3f04 	ldr.w	r3, [lr, #4]!
 801b384:	f856 0f04 	ldr.w	r0, [r6, #4]!
    sum = 0.0f;
 801b388:	ed9f 7a10 	vldr	s14, [pc, #64]	; 801b3cc <MelFilterbank+0x6c>
 801b38c:	fa1f f983 	uxth.w	r9, r3
    for (uint32_t j = start_idx; j <= stop_idx; j++)
 801b390:	b280      	uxth	r0, r0
 801b392:	4581      	cmp	r9, r0
 801b394:	d813      	bhi.n	801b3be <MelFilterbank+0x5e>
 801b396:	eb01 0389 	add.w	r3, r1, r9, lsl #2
 801b39a:	eb08 0c80 	add.w	ip, r8, r0, lsl #2
 801b39e:	4622      	mov	r2, r4
    {
      sum += pSpectrCol[j] * (*pCoefs++);
 801b3a0:	ecf3 7a01 	vldmia	r3!, {s15}
 801b3a4:	ecf2 6a01 	vldmia	r2!, {s13}
 801b3a8:	ee67 7aa6 	vmul.f32	s15, s15, s13
    for (uint32_t j = start_idx; j <= stop_idx; j++)
 801b3ac:	459c      	cmp	ip, r3
      sum += pSpectrCol[j] * (*pCoefs++);
 801b3ae:	ee37 7a27 	vadd.f32	s14, s14, s15
    for (uint32_t j = start_idx; j <= stop_idx; j++)
 801b3b2:	d1f5      	bne.n	801b3a0 <MelFilterbank+0x40>
      sum += pSpectrCol[j] * (*pCoefs++);
 801b3b4:	3001      	adds	r0, #1
 801b3b6:	eba0 0009 	sub.w	r0, r0, r9
 801b3ba:	eb04 0480 	add.w	r4, r4, r0, lsl #2
  for (uint32_t i = 0; i < n_mels; i++)
 801b3be:	45be      	cmp	lr, r7
    }
    pMelCol[i] = sum;
 801b3c0:	eca5 7a01 	vstmia	r5!, {s14}
  for (uint32_t i = 0; i < n_mels; i++)
 801b3c4:	d1dc      	bne.n	801b380 <MelFilterbank+0x20>
  }
}
 801b3c6:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 801b3ca:	bf00      	nop
 801b3cc:	00000000 	.word	0x00000000

0801b3d0 <list_init_head>:
 * Function Definitions 
******************************************************************************/
void list_init_head (tListNode * listHead)
{
  listHead->next = listHead;
  listHead->prev = listHead;	
 801b3d0:	e9c0 0000 	strd	r0, r0, [r0]
}
 801b3d4:	4770      	bx	lr
 801b3d6:	bf00      	nop

0801b3d8 <list_is_empty>:
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 801b3d8:	f3ef 8210 	mrs	r2, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 801b3dc:	b672      	cpsid	i
  
  uint32_t uwPRIMASK_Bit;
  uwPRIMASK_Bit = __get_PRIMASK();  /**< backup PRIMASK bit */
  __disable_irq();                  /**< Disable all interrupts by setting PRIMASK bit on Cortex*/
   
  if(listHead->next == listHead)
 801b3de:	6803      	ldr	r3, [r0, #0]
  {
    return_value = 1;
 801b3e0:	1a18      	subs	r0, r3, r0
 801b3e2:	fab0 f080 	clz	r0, r0
 801b3e6:	0940      	lsrs	r0, r0, #5
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 801b3e8:	f382 8810 	msr	PRIMASK, r2
  }
  
  __set_PRIMASK(uwPRIMASK_Bit);     /**< Restore PRIMASK bit*/
  
  return return_value;
}
 801b3ec:	4770      	bx	lr
 801b3ee:	bf00      	nop

0801b3f0 <list_insert_head>:
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 801b3f0:	f3ef 8310 	mrs	r3, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 801b3f4:	b672      	cpsid	i
{
  uint32_t uwPRIMASK_Bit;
  uwPRIMASK_Bit = __get_PRIMASK();  /**< backup PRIMASK bit */
  __disable_irq();                  /**< Disable all interrupts by setting PRIMASK bit on Cortex*/
  
  node->next = listHead->next;
 801b3f6:	6802      	ldr	r2, [r0, #0]
  node->prev = listHead;
 801b3f8:	e9c1 2000 	strd	r2, r0, [r1]
  listHead->next = node;
 801b3fc:	6001      	str	r1, [r0, #0]
  (node->next)->prev = node;
 801b3fe:	680a      	ldr	r2, [r1, #0]
 801b400:	6051      	str	r1, [r2, #4]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 801b402:	f383 8810 	msr	PRIMASK, r3
  
  __set_PRIMASK(uwPRIMASK_Bit);     /**< Restore PRIMASK bit*/
}
 801b406:	4770      	bx	lr

0801b408 <list_insert_tail>:
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 801b408:	f3ef 8310 	mrs	r3, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 801b40c:	b672      	cpsid	i
  uint32_t uwPRIMASK_Bit;
  uwPRIMASK_Bit = __get_PRIMASK();  /**< backup PRIMASK bit */
  __disable_irq();                  /**< Disable all interrupts by setting PRIMASK bit on Cortex*/
  
  node->next = listHead;
  node->prev = listHead->prev;
 801b40e:	6842      	ldr	r2, [r0, #4]
  node->next = listHead;
 801b410:	e9c1 0200 	strd	r0, r2, [r1]
  listHead->prev = node;
 801b414:	6041      	str	r1, [r0, #4]
  (node->prev)->next = node;
 801b416:	684a      	ldr	r2, [r1, #4]
 801b418:	6011      	str	r1, [r2, #0]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 801b41a:	f383 8810 	msr	PRIMASK, r3
  
  __set_PRIMASK(uwPRIMASK_Bit);     /**< Restore PRIMASK bit*/
}
 801b41e:	4770      	bx	lr

0801b420 <list_remove_head>:
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 801b420:	f3ef 8c10 	mrs	ip, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 801b424:	b672      	cpsid	i
{
  uint32_t uwPRIMASK_Bit;
  uwPRIMASK_Bit = __get_PRIMASK();  /**< backup PRIMASK bit */
  __disable_irq();                  /**< Disable all interrupts by setting PRIMASK bit on Cortex*/
  
  *node = listHead->next;
 801b426:	6803      	ldr	r3, [r0, #0]
 801b428:	600b      	str	r3, [r1, #0]
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 801b42a:	f3ef 8010 	mrs	r0, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 801b42e:	b672      	cpsid	i
  (node->prev)->next = node->next;
 801b430:	e9d3 3200 	ldrd	r3, r2, [r3]
 801b434:	6013      	str	r3, [r2, #0]
  (node->next)->prev = node->prev;
 801b436:	605a      	str	r2, [r3, #4]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 801b438:	f380 8810 	msr	PRIMASK, r0
  list_remove_node (listHead->next);
  (*node)->next = NULL;
 801b43c:	680a      	ldr	r2, [r1, #0]
 801b43e:	2300      	movs	r3, #0
 801b440:	6013      	str	r3, [r2, #0]
  (*node)->prev = NULL;
 801b442:	680a      	ldr	r2, [r1, #0]
 801b444:	6053      	str	r3, [r2, #4]
 801b446:	f38c 8810 	msr	PRIMASK, ip
  
  __set_PRIMASK(uwPRIMASK_Bit);     /**< Restore PRIMASK bit*/
}
 801b44a:	4770      	bx	lr

0801b44c <list_remove_tail>:
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 801b44c:	f3ef 8c10 	mrs	ip, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 801b450:	b672      	cpsid	i
{
  uint32_t uwPRIMASK_Bit;
  uwPRIMASK_Bit = __get_PRIMASK();  /**< backup PRIMASK bit */
  __disable_irq();                  /**< Disable all interrupts by setting PRIMASK bit on Cortex*/
  
  *node = listHead->prev;
 801b452:	6843      	ldr	r3, [r0, #4]
 801b454:	600b      	str	r3, [r1, #0]
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 801b456:	f3ef 8010 	mrs	r0, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 801b45a:	b672      	cpsid	i
  (node->prev)->next = node->next;
 801b45c:	e9d3 3200 	ldrd	r3, r2, [r3]
 801b460:	6013      	str	r3, [r2, #0]
  (node->next)->prev = node->prev;
 801b462:	605a      	str	r2, [r3, #4]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 801b464:	f380 8810 	msr	PRIMASK, r0
  list_remove_node (listHead->prev);
  (*node)->next = NULL;
 801b468:	680a      	ldr	r2, [r1, #0]
 801b46a:	2300      	movs	r3, #0
 801b46c:	6013      	str	r3, [r2, #0]
  (*node)->prev = NULL;
 801b46e:	680a      	ldr	r2, [r1, #0]
 801b470:	6053      	str	r3, [r2, #4]
 801b472:	f38c 8810 	msr	PRIMASK, ip
  
  __set_PRIMASK(uwPRIMASK_Bit);     /**< Restore PRIMASK bit*/
}
 801b476:	4770      	bx	lr

0801b478 <list_get_size>:
  
  __set_PRIMASK(uwPRIMASK_Bit);     /**< Restore PRIMASK bit*/
}

int list_get_size (tListNode * listHead)
{
 801b478:	4602      	mov	r2, r0
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 801b47a:	f3ef 8110 	mrs	r1, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 801b47e:	b672      	cpsid	i

  uint32_t uwPRIMASK_Bit;
  uwPRIMASK_Bit = __get_PRIMASK();  /**< backup PRIMASK bit */
  __disable_irq();                  /**< Disable all interrupts by setting PRIMASK bit on Cortex*/

  temp = listHead->next;
 801b480:	6803      	ldr	r3, [r0, #0]
  while (temp != listHead)
 801b482:	429a      	cmp	r2, r3
  int size = 0;
 801b484:	f04f 0000 	mov.w	r0, #0
  while (temp != listHead)
 801b488:	d004      	beq.n	801b494 <list_get_size+0x1c>
  {
    size++;
    temp = temp->next;		
 801b48a:	681b      	ldr	r3, [r3, #0]
  while (temp != listHead)
 801b48c:	429a      	cmp	r2, r3
    size++;
 801b48e:	f100 0001 	add.w	r0, r0, #1
  while (temp != listHead)
 801b492:	d1fa      	bne.n	801b48a <list_get_size+0x12>
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 801b494:	f381 8810 	msr	PRIMASK, r1
  }
  
  __set_PRIMASK(uwPRIMASK_Bit);     /**< Restore PRIMASK bit*/
  
  return (size);
}
 801b498:	4770      	bx	lr
 801b49a:	bf00      	nop

0801b49c <aci_gap_init_IDB05A1>:

#define MIN(a,b)            ((a) < (b) )? (a) : (b)
#define MAX(a,b)            ((a) > (b) )? (a) : (b)

tBleStatus aci_gap_init_IDB05A1(uint8_t role, uint8_t privacy_enabled, uint8_t device_name_char_len, uint16_t* service_handle, uint16_t* dev_name_char_handle, uint16_t* appearance_char_handle)
{
 801b49c:	b530      	push	{r4, r5, lr}
 801b49e:	b08b      	sub	sp, #44	; 0x2c
 
  cp.role = role;
  cp.privacy_enabled = privacy_enabled;
  cp.device_name_char_len = device_name_char_len;
    
  BLUENRG_memset(&resp, 0, sizeof(resp));
 801b4a0:	ad02      	add	r5, sp, #8
 801b4a2:	2400      	movs	r4, #0
  BLUENRG_memset(&rq, 0, sizeof(rq));
  rq.ogf = OGF_VENDOR_CMD;
  rq.ocf = OCF_GAP_INIT;
  rq.cparam = &cp;
  rq.clen = sizeof(cp);
  rq.rparam = &resp;
 801b4a4:	9508      	str	r5, [sp, #32]
  cp.role = role;
 801b4a6:	f88d 0004 	strb.w	r0, [sp, #4]
  cp.device_name_char_len = device_name_char_len;
 801b4aa:	f88d 2006 	strb.w	r2, [sp, #6]
  rq.cparam = &cp;
 801b4ae:	a801      	add	r0, sp, #4
  rq.clen = sizeof(cp);
 801b4b0:	2203      	movs	r2, #3
{
 801b4b2:	461d      	mov	r5, r3
  rq.ogf = OGF_VENDOR_CMD;
 801b4b4:	4b15      	ldr	r3, [pc, #84]	; (801b50c <aci_gap_init_IDB05A1+0x70>)
  cp.privacy_enabled = privacy_enabled;
 801b4b6:	f88d 1005 	strb.w	r1, [sp, #5]
  rq.clen = sizeof(cp);
 801b4ba:	e9cd 0206 	strd	r0, r2, [sp, #24]
  rq.ogf = OGF_VENDOR_CMD;
 801b4be:	9304      	str	r3, [sp, #16]
  rq.rlen = GAP_INIT_RP_SIZE;
  
  if (hci_send_req(&rq, FALSE) < 0)
 801b4c0:	4621      	mov	r1, r4
  rq.rlen = GAP_INIT_RP_SIZE;
 801b4c2:	2307      	movs	r3, #7
  if (hci_send_req(&rq, FALSE) < 0)
 801b4c4:	a804      	add	r0, sp, #16
  BLUENRG_memset(&resp, 0, sizeof(resp));
 801b4c6:	9402      	str	r4, [sp, #8]
  BLUENRG_memset(&rq, 0, sizeof(rq));
 801b4c8:	9405      	str	r4, [sp, #20]
  BLUENRG_memset(&resp, 0, sizeof(resp));
 801b4ca:	f8cd 400b 	str.w	r4, [sp, #11]
  rq.rlen = GAP_INIT_RP_SIZE;
 801b4ce:	9309      	str	r3, [sp, #36]	; 0x24
  if (hci_send_req(&rq, FALSE) < 0)
 801b4d0:	f000 fb20 	bl	801bb14 <hci_send_req>
 801b4d4:	42a0      	cmp	r0, r4
 801b4d6:	db15      	blt.n	801b504 <aci_gap_init_IDB05A1+0x68>
    return BLE_STATUS_TIMEOUT;
  
  if (resp.status) {
 801b4d8:	f89d 0008 	ldrb.w	r0, [sp, #8]
 801b4dc:	b980      	cbnz	r0, 801b500 <aci_gap_init_IDB05A1+0x64>
    return resp.status;
  }
  
  *service_handle = btohs(resp.service_handle);
 801b4de:	9b02      	ldr	r3, [sp, #8]
  *dev_name_char_handle = btohs(resp.dev_name_char_handle);
 801b4e0:	f89d 200b 	ldrb.w	r2, [sp, #11]
 801b4e4:	f89d 400c 	ldrb.w	r4, [sp, #12]
  *service_handle = btohs(resp.service_handle);
 801b4e8:	f3c3 210f 	ubfx	r1, r3, #8, #16
  *appearance_char_handle = btohs(resp.appearance_char_handle);
 801b4ec:	9b03      	ldr	r3, [sp, #12]
  *service_handle = btohs(resp.service_handle);
 801b4ee:	8029      	strh	r1, [r5, #0]
  *dev_name_char_handle = btohs(resp.dev_name_char_handle);
 801b4f0:	990e      	ldr	r1, [sp, #56]	; 0x38
 801b4f2:	ea42 2204 	orr.w	r2, r2, r4, lsl #8
 801b4f6:	800a      	strh	r2, [r1, #0]
  *appearance_char_handle = btohs(resp.appearance_char_handle);
 801b4f8:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
 801b4fa:	f3c3 230f 	ubfx	r3, r3, #8, #16
 801b4fe:	8013      	strh	r3, [r2, #0]
  
  return 0;
}
 801b500:	b00b      	add	sp, #44	; 0x2c
 801b502:	bd30      	pop	{r4, r5, pc}
    return BLE_STATUS_TIMEOUT;
 801b504:	20ff      	movs	r0, #255	; 0xff
}
 801b506:	b00b      	add	sp, #44	; 0x2c
 801b508:	bd30      	pop	{r4, r5, pc}
 801b50a:	bf00      	nop
 801b50c:	008a003f 	.word	0x008a003f

0801b510 <aci_gap_set_discoverable>:

tBleStatus aci_gap_set_discoverable(uint8_t AdvType, uint16_t AdvIntervMin, uint16_t AdvIntervMax,
                             uint8_t OwnAddrType, uint8_t AdvFilterPolicy, uint8_t LocalNameLen,
                             const char *LocalName, uint8_t ServiceUUIDLen, uint8_t* ServiceUUIDList,
                             uint16_t SlaveConnIntervMin, uint16_t SlaveConnIntervMax)
{
 801b510:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 801b514:	b092      	sub	sp, #72	; 0x48
 801b516:	f89d 5064 	ldrb.w	r5, [sp, #100]	; 0x64
 801b51a:	f89d 406c 	ldrb.w	r4, [sp, #108]	; 0x6c
 801b51e:	f89d e060 	ldrb.w	lr, [sp, #96]	; 0x60
 801b522:	f8bd 7074 	ldrh.w	r7, [sp, #116]	; 0x74
 801b526:	f8bd 6078 	ldrh.w	r6, [sp, #120]	; 0x78
  struct hci_request rq;
  uint8_t status;    
  uint8_t buffer[40];
  uint8_t indx = 0;
  
  if ((LocalNameLen+ServiceUUIDLen+14) > sizeof(buffer))
 801b52a:	eb05 0c04 	add.w	ip, r5, r4
 801b52e:	f1bc 0f1a 	cmp.w	ip, #26
 801b532:	dc47      	bgt.n	801b5c4 <aci_gap_set_discoverable+0xb4>
    return BLE_STATUS_INVALID_PARAMS;

  buffer[indx] = AdvType;
 801b534:	f88d 0020 	strb.w	r0, [sp, #32]
  indx++;
  
  AdvIntervMin = htobs(AdvIntervMin);
  BLUENRG_memcpy(buffer + indx, &AdvIntervMin, 2);
 801b538:	f8ad 1021 	strh.w	r1, [sp, #33]	; 0x21
  indx +=  2;
    
  AdvIntervMax = htobs(AdvIntervMax);
  BLUENRG_memcpy(buffer + indx, &AdvIntervMax, 2);
 801b53c:	f8ad 2023 	strh.w	r2, [sp, #35]	; 0x23
  indx++;
    
  buffer[indx] = LocalNameLen;
  indx++;
    
  BLUENRG_memcpy(buffer + indx, LocalName, LocalNameLen);
 801b540:	991a      	ldr	r1, [sp, #104]	; 0x68
  buffer[indx] = AdvFilterPolicy;
 801b542:	f88d e026 	strb.w	lr, [sp, #38]	; 0x26
  BLUENRG_memcpy(buffer + indx, LocalName, LocalNameLen);
 801b546:	462a      	mov	r2, r5
 801b548:	a80a      	add	r0, sp, #40	; 0x28
  buffer[indx] = OwnAddrType;
 801b54a:	f88d 3025 	strb.w	r3, [sp, #37]	; 0x25
  buffer[indx] = LocalNameLen;
 801b54e:	f88d 5027 	strb.w	r5, [sp, #39]	; 0x27
  BLUENRG_memcpy(buffer + indx, LocalName, LocalNameLen);
 801b552:	f00b ffe9 	bl	8027528 <memcpy>
  indx +=  LocalNameLen;
 801b556:	f105 0308 	add.w	r3, r5, #8
  
  buffer[indx] = ServiceUUIDLen;
 801b55a:	aa12      	add	r2, sp, #72	; 0x48
 801b55c:	fa52 f383 	uxtab	r3, r2, r3
  indx++;
 801b560:	3509      	adds	r5, #9
 801b562:	b2ed      	uxtb	r5, r5
  buffer[indx] = ServiceUUIDLen;
 801b564:	f803 4c28 	strb.w	r4, [r3, #-40]

  BLUENRG_memcpy(buffer + indx, ServiceUUIDList, ServiceUUIDLen);
 801b568:	4622      	mov	r2, r4
  BLUENRG_memcpy(buffer + indx, LocalName, LocalNameLen);
 801b56a:	f10d 0820 	add.w	r8, sp, #32
  indx +=  ServiceUUIDLen;  
 801b56e:	442c      	add	r4, r5
 801b570:	b2e4      	uxtb	r4, r4
  BLUENRG_memcpy(buffer + indx, ServiceUUIDList, ServiceUUIDLen);
 801b572:	991c      	ldr	r1, [sp, #112]	; 0x70
 801b574:	eb08 0005 	add.w	r0, r8, r5
 801b578:	f00b ffd6 	bl	8027528 <memcpy>

  SlaveConnIntervMin = htobs(SlaveConnIntervMin);
  BLUENRG_memcpy(buffer + indx, &SlaveConnIntervMin, 2);
 801b57c:	f104 0348 	add.w	r3, r4, #72	; 0x48
 801b580:	eb0d 0203 	add.w	r2, sp, r3
  indx +=  2;
  
  SlaveConnIntervMax = htobs(SlaveConnIntervMax);
  BLUENRG_memcpy(buffer + indx, &SlaveConnIntervMax, 2);
 801b584:	a912      	add	r1, sp, #72	; 0x48
  indx +=  2;    
 801b586:	1d23      	adds	r3, r4, #4
  indx +=  2;
 801b588:	3402      	adds	r4, #2
  BLUENRG_memcpy(buffer + indx, &SlaveConnIntervMax, 2);
 801b58a:	fa51 f484 	uxtab	r4, r1, r4

  BLUENRG_memset(&rq, 0, sizeof(rq));
  rq.ogf = OGF_VENDOR_CMD;
 801b58e:	4811      	ldr	r0, [pc, #68]	; (801b5d4 <aci_gap_set_discoverable+0xc4>)
  BLUENRG_memcpy(buffer + indx, &SlaveConnIntervMin, 2);
 801b590:	f822 7c28 	strh.w	r7, [r2, #-40]
  BLUENRG_memset(&rq, 0, sizeof(rq));
 801b594:	2100      	movs	r1, #0
  rq.ogf = OGF_VENDOR_CMD;
 801b596:	e9cd 0102 	strd	r0, r1, [sp, #8]
  rq.ocf = OCF_GAP_SET_DISCOVERABLE;
  rq.cparam = (void *)buffer;
  rq.clen = indx;
 801b59a:	b2db      	uxtb	r3, r3
  BLUENRG_memcpy(buffer + indx, &SlaveConnIntervMax, 2);
 801b59c:	f824 6c28 	strh.w	r6, [r4, #-40]
  rq.rparam = &status;
  rq.rlen = 1;
 801b5a0:	2201      	movs	r2, #1
  rq.rparam = &status;
 801b5a2:	f10d 0407 	add.w	r4, sp, #7

  if (hci_send_req(&rq, FALSE) < 0)
 801b5a6:	a802      	add	r0, sp, #8
  rq.rlen = 1;
 801b5a8:	e9cd 4206 	strd	r4, r2, [sp, #24]
  rq.cparam = (void *)buffer;
 801b5ac:	f8cd 8010 	str.w	r8, [sp, #16]
  rq.clen = indx;
 801b5b0:	9305      	str	r3, [sp, #20]
  if (hci_send_req(&rq, FALSE) < 0)
 801b5b2:	f000 faaf 	bl	801bb14 <hci_send_req>
 801b5b6:	2800      	cmp	r0, #0
 801b5b8:	db08      	blt.n	801b5cc <aci_gap_set_discoverable+0xbc>
    return BLE_STATUS_TIMEOUT;

  if (status) {
 801b5ba:	f89d 0007 	ldrb.w	r0, [sp, #7]
    return status;
  }

  return 0;
}
 801b5be:	b012      	add	sp, #72	; 0x48
 801b5c0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    return BLE_STATUS_INVALID_PARAMS;
 801b5c4:	2042      	movs	r0, #66	; 0x42
}
 801b5c6:	b012      	add	sp, #72	; 0x48
 801b5c8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    return BLE_STATUS_TIMEOUT;
 801b5cc:	20ff      	movs	r0, #255	; 0xff
}
 801b5ce:	b012      	add	sp, #72	; 0x48
 801b5d0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 801b5d4:	0083003f 	.word	0x0083003f

0801b5d8 <aci_gap_set_auth_requirement>:
                                        uint8_t min_encryption_key_size,
                                        uint8_t max_encryption_key_size,
                                        uint8_t use_fixed_pin,
                                        uint32_t fixed_pin,
                                        uint8_t bonding_mode)
{
 801b5d8:	b530      	push	{r4, r5, lr}
 801b5da:	b08f      	sub	sp, #60	; 0x3c

  BLUENRG_memset(&rq, 0, sizeof(rq));
  rq.ogf = OGF_VENDOR_CMD;
  rq.ocf = OCF_GAP_SET_AUTH_REQUIREMENT;
  rq.cparam = &cp;
  rq.clen = sizeof(cp);
 801b5dc:	251a      	movs	r5, #26
  cp.min_encryption_key_size = min_encryption_key_size;
 801b5de:	f88d 302e 	strb.w	r3, [sp, #46]	; 0x2e
  rq.cparam = &cp;
 801b5e2:	ab07      	add	r3, sp, #28
 801b5e4:	9303      	str	r3, [sp, #12]
  rq.rparam = &status;
  rq.rlen = 1;
 801b5e6:	2301      	movs	r3, #1
 801b5e8:	9306      	str	r3, [sp, #24]
{
 801b5ea:	f89d 304c 	ldrb.w	r3, [sp, #76]	; 0x4c
  cp.mitm_mode = mitm_mode;
 801b5ee:	f88d 001c 	strb.w	r0, [sp, #28]
  cp.use_fixed_pin = use_fixed_pin;
 801b5f2:	f88d 3030 	strb.w	r3, [sp, #48]	; 0x30
  BLUENRG_memcpy(cp.oob_data, oob_data, 16);
 801b5f6:	6810      	ldr	r0, [r2, #0]
{
 801b5f8:	9b14      	ldr	r3, [sp, #80]	; 0x50
 801b5fa:	f89d 4048 	ldrb.w	r4, [sp, #72]	; 0x48
  BLUENRG_memcpy(cp.oob_data, oob_data, 16);
 801b5fe:	f8cd 001e 	str.w	r0, [sp, #30]
  cp.fixed_pin = htobl(fixed_pin);
 801b602:	f8cd 3031 	str.w	r3, [sp, #49]	; 0x31
  rq.ogf = OGF_VENDOR_CMD;
 801b606:	4812      	ldr	r0, [pc, #72]	; (801b650 <aci_gap_set_auth_requirement+0x78>)
{
 801b608:	f89d 3054 	ldrb.w	r3, [sp, #84]	; 0x54
  cp.max_encryption_key_size = max_encryption_key_size;
 801b60c:	f88d 402f 	strb.w	r4, [sp, #47]	; 0x2f
  rq.ogf = OGF_VENDOR_CMD;
 801b610:	9001      	str	r0, [sp, #4]
  BLUENRG_memset(&rq, 0, sizeof(rq));
 801b612:	2400      	movs	r4, #0
  rq.rparam = &status;
 801b614:	f10d 0003 	add.w	r0, sp, #3
  cp.bonding_mode = bonding_mode;
 801b618:	f88d 3035 	strb.w	r3, [sp, #53]	; 0x35
  BLUENRG_memcpy(cp.oob_data, oob_data, 16);
 801b61c:	6853      	ldr	r3, [r2, #4]
  cp.oob_enable = oob_enable;
 801b61e:	f88d 101d 	strb.w	r1, [sp, #29]
  rq.rparam = &status;
 801b622:	e9cd 5004 	strd	r5, r0, [sp, #16]
  BLUENRG_memset(&rq, 0, sizeof(rq));
 801b626:	9402      	str	r4, [sp, #8]

  if (hci_send_req(&rq, FALSE) < 0)
 801b628:	4621      	mov	r1, r4
  BLUENRG_memcpy(cp.oob_data, oob_data, 16);
 801b62a:	f8cd 3022 	str.w	r3, [sp, #34]	; 0x22
 801b62e:	6894      	ldr	r4, [r2, #8]
 801b630:	68d3      	ldr	r3, [r2, #12]
 801b632:	f8cd 4026 	str.w	r4, [sp, #38]	; 0x26
  if (hci_send_req(&rq, FALSE) < 0)
 801b636:	a801      	add	r0, sp, #4
  BLUENRG_memcpy(cp.oob_data, oob_data, 16);
 801b638:	f8cd 302a 	str.w	r3, [sp, #42]	; 0x2a
  if (hci_send_req(&rq, FALSE) < 0)
 801b63c:	f000 fa6a 	bl	801bb14 <hci_send_req>
 801b640:	2800      	cmp	r0, #0
    return BLE_STATUS_TIMEOUT;

  if (status) {
 801b642:	bfac      	ite	ge
 801b644:	f89d 0003 	ldrbge.w	r0, [sp, #3]
    return BLE_STATUS_TIMEOUT;
 801b648:	20ff      	movlt	r0, #255	; 0xff
    return status;
  }
    
  return 0;
}
 801b64a:	b00f      	add	sp, #60	; 0x3c
 801b64c:	bd30      	pop	{r4, r5, pc}
 801b64e:	bf00      	nop
 801b650:	0086003f 	.word	0x0086003f

0801b654 <aci_gap_update_adv_data>:
  struct hci_request rq;
  uint8_t status;
  uint8_t buffer[32];
  uint8_t indx = 0;
    
  if (AdvLen > (sizeof(buffer)-1))
 801b654:	281f      	cmp	r0, #31
 801b656:	d820      	bhi.n	801b69a <aci_gap_update_adv_data+0x46>
{
 801b658:	b510      	push	{r4, lr}
 801b65a:	b090      	sub	sp, #64	; 0x40
 801b65c:	4604      	mov	r4, r0
    return BLE_STATUS_INVALID_PARAMS;

  buffer[indx] = AdvLen;
  indx++;
    
  BLUENRG_memcpy(buffer + indx, AdvData, AdvLen);
 801b65e:	4602      	mov	r2, r0
 801b660:	f10d 0021 	add.w	r0, sp, #33	; 0x21
  buffer[indx] = AdvLen;
 801b664:	f88d 4020 	strb.w	r4, [sp, #32]
  BLUENRG_memcpy(buffer + indx, AdvData, AdvLen);
 801b668:	f00b ff5e 	bl	8027528 <memcpy>
  indx +=  AdvLen;
 801b66c:	3401      	adds	r4, #1
    
  BLUENRG_memset(&rq, 0, sizeof(rq));
  rq.ogf = OGF_VENDOR_CMD;
 801b66e:	4b0d      	ldr	r3, [pc, #52]	; (801b6a4 <aci_gap_update_adv_data+0x50>)
 801b670:	9302      	str	r3, [sp, #8]
  BLUENRG_memset(&rq, 0, sizeof(rq));
 801b672:	2100      	movs	r1, #0
  BLUENRG_memcpy(buffer + indx, AdvData, AdvLen);
 801b674:	a808      	add	r0, sp, #32
  rq.ocf = OCF_GAP_UPDATE_ADV_DATA;
  rq.cparam = (void *)buffer;
 801b676:	e9cd 1003 	strd	r1, r0, [sp, #12]
  rq.clen = indx;
  rq.rparam = &status;
 801b67a:	f10d 0207 	add.w	r2, sp, #7
  rq.rlen = 1;
 801b67e:	2301      	movs	r3, #1
  rq.clen = indx;
 801b680:	b2e4      	uxtb	r4, r4
    
  if (hci_send_req(&rq, FALSE) < 0)
 801b682:	a802      	add	r0, sp, #8
  rq.rlen = 1;
 801b684:	e9cd 2306 	strd	r2, r3, [sp, #24]
  rq.clen = indx;
 801b688:	9405      	str	r4, [sp, #20]
  if (hci_send_req(&rq, FALSE) < 0)
 801b68a:	f000 fa43 	bl	801bb14 <hci_send_req>
 801b68e:	2800      	cmp	r0, #0
 801b690:	db05      	blt.n	801b69e <aci_gap_update_adv_data+0x4a>
    return BLE_STATUS_TIMEOUT;
    
  return status;
 801b692:	f89d 0007 	ldrb.w	r0, [sp, #7]
}
 801b696:	b010      	add	sp, #64	; 0x40
 801b698:	bd10      	pop	{r4, pc}
    return BLE_STATUS_INVALID_PARAMS;
 801b69a:	2042      	movs	r0, #66	; 0x42
}
 801b69c:	4770      	bx	lr
    return BLE_STATUS_TIMEOUT;
 801b69e:	20ff      	movs	r0, #255	; 0xff
}
 801b6a0:	b010      	add	sp, #64	; 0x40
 801b6a2:	bd10      	pop	{r4, pc}
 801b6a4:	008e003f 	.word	0x008e003f

0801b6a8 <aci_gatt_init>:
#define MIN(a,b)            ((a) < (b) )? (a) : (b)
#define MAX(a,b)            ((a) > (b) )? (a) : (b)


tBleStatus aci_gatt_init(void)
{
 801b6a8:	b500      	push	{lr}
  struct hci_request rq;
  uint8_t status;

  BLUENRG_memset(&rq, 0, sizeof(rq));
  rq.ogf = OGF_VENDOR_CMD;
 801b6aa:	480b      	ldr	r0, [pc, #44]	; (801b6d8 <aci_gatt_init+0x30>)
{
 801b6ac:	b089      	sub	sp, #36	; 0x24
  BLUENRG_memset(&rq, 0, sizeof(rq));
 801b6ae:	2100      	movs	r1, #0
  rq.ogf = OGF_VENDOR_CMD;
 801b6b0:	e9cd 0102 	strd	r0, r1, [sp, #8]
  rq.ocf = OCF_GATT_INIT;
  rq.rparam = &status;
 801b6b4:	f10d 0207 	add.w	r2, sp, #7
  rq.rlen = 1;
 801b6b8:	2301      	movs	r3, #1

  if (hci_send_req(&rq, FALSE) < 0)
 801b6ba:	a802      	add	r0, sp, #8
  BLUENRG_memset(&rq, 0, sizeof(rq));
 801b6bc:	e9cd 1104 	strd	r1, r1, [sp, #16]
  rq.rparam = &status;
 801b6c0:	9206      	str	r2, [sp, #24]
  rq.rlen = 1;
 801b6c2:	9307      	str	r3, [sp, #28]
  if (hci_send_req(&rq, FALSE) < 0)
 801b6c4:	f000 fa26 	bl	801bb14 <hci_send_req>
 801b6c8:	2800      	cmp	r0, #0
    return BLE_STATUS_TIMEOUT;

  return status;
 801b6ca:	bfac      	ite	ge
 801b6cc:	f89d 0007 	ldrbge.w	r0, [sp, #7]
    return BLE_STATUS_TIMEOUT;
 801b6d0:	20ff      	movlt	r0, #255	; 0xff
}
 801b6d2:	b009      	add	sp, #36	; 0x24
 801b6d4:	f85d fb04 	ldr.w	pc, [sp], #4
 801b6d8:	0101003f 	.word	0x0101003f

0801b6dc <aci_gatt_add_serv>:

tBleStatus aci_gatt_add_serv(uint8_t service_uuid_type, const uint8_t* service_uuid, uint8_t service_type, uint8_t max_attr_records, uint16_t *serviceHandle)
{
 801b6dc:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 801b6e0:	b08c      	sub	sp, #48	; 0x30
  uint8_t indx = 0;
    
  buffer[indx] = service_uuid_type;
  indx++;
    
  if(service_uuid_type == UUID_TYPE_16){
 801b6e2:	2801      	cmp	r0, #1
{
 801b6e4:	4617      	mov	r7, r2
  if(service_uuid_type == UUID_TYPE_16){
 801b6e6:	bf0b      	itete	eq
 801b6e8:	2603      	moveq	r6, #3
 801b6ea:	2611      	movne	r6, #17
    uuid_len = 2;
  }
  else {
    uuid_len = 16;
  }        
  BLUENRG_memcpy(buffer + indx, service_uuid, uuid_len);
 801b6ec:	2202      	moveq	r2, #2
 801b6ee:	2210      	movne	r2, #16
  buffer[indx] = service_uuid_type;
 801b6f0:	f88d 0004 	strb.w	r0, [sp, #4]
  BLUENRG_memcpy(buffer + indx, service_uuid, uuid_len);
 801b6f4:	f10d 0005 	add.w	r0, sp, #5
  if(service_uuid_type == UUID_TYPE_16){
 801b6f8:	bf0b      	itete	eq
 801b6fa:	2404      	moveq	r4, #4
 801b6fc:	2412      	movne	r4, #18
 801b6fe:	f04f 0805 	moveq.w	r8, #5
 801b702:	f04f 0813 	movne.w	r8, #19
{
 801b706:	461d      	mov	r5, r3
  BLUENRG_memcpy(buffer + indx, service_uuid, uuid_len);
 801b708:	f00b ff0e 	bl	8027528 <memcpy>
  indx +=  uuid_len;
    
  buffer[indx] = service_type;
 801b70c:	f106 0330 	add.w	r3, r6, #48	; 0x30
 801b710:	eb0d 0603 	add.w	r6, sp, r3
  indx++;
    
  buffer[indx] = max_attr_records;
 801b714:	f104 0330 	add.w	r3, r4, #48	; 0x30
 801b718:	eb0d 0403 	add.w	r4, sp, r3
  rq.ogf = OGF_VENDOR_CMD;
  rq.ocf = OCF_GATT_ADD_SERV;
  rq.cparam = (void *)buffer;
  rq.clen = indx;
  rq.rparam = &resp;
  rq.rlen = GATT_ADD_SERV_RP_SIZE;
 801b71c:	2303      	movs	r3, #3
 801b71e:	930b      	str	r3, [sp, #44]	; 0x2c
  rq.ogf = OGF_VENDOR_CMD;
 801b720:	4b12      	ldr	r3, [pc, #72]	; (801b76c <aci_gatt_add_serv+0x90>)
  buffer[indx] = service_type;
 801b722:	f806 7c2c 	strb.w	r7, [r6, #-44]
  BLUENRG_memset(&resp, 0, sizeof(resp));
 801b726:	2100      	movs	r1, #0
  rq.ogf = OGF_VENDOR_CMD;
 801b728:	9306      	str	r3, [sp, #24]
  buffer[indx] = max_attr_records;
 801b72a:	f804 5c2c 	strb.w	r5, [r4, #-44]
  BLUENRG_memcpy(buffer + indx, service_uuid, uuid_len);
 801b72e:	ab01      	add	r3, sp, #4

  if (hci_send_req(&rq, FALSE) < 0)
 801b730:	a806      	add	r0, sp, #24
  rq.clen = indx;
 801b732:	f8cd 8024 	str.w	r8, [sp, #36]	; 0x24
  BLUENRG_memset(&resp, 0, sizeof(resp));
 801b736:	f8ad 1000 	strh.w	r1, [sp]
  BLUENRG_memset(&rq, 0, sizeof(rq));
 801b73a:	9107      	str	r1, [sp, #28]
  rq.rparam = &resp;
 801b73c:	f8cd d028 	str.w	sp, [sp, #40]	; 0x28
  BLUENRG_memset(&resp, 0, sizeof(resp));
 801b740:	f88d 1002 	strb.w	r1, [sp, #2]
  rq.cparam = (void *)buffer;
 801b744:	9308      	str	r3, [sp, #32]
  if (hci_send_req(&rq, FALSE) < 0)
 801b746:	f000 f9e5 	bl	801bb14 <hci_send_req>
 801b74a:	2800      	cmp	r0, #0
 801b74c:	db0a      	blt.n	801b764 <aci_gatt_add_serv+0x88>
    return BLE_STATUS_TIMEOUT;

  if (resp.status) {
 801b74e:	f89d 0000 	ldrb.w	r0, [sp]
 801b752:	b920      	cbnz	r0, 801b75e <aci_gatt_add_serv+0x82>
    return resp.status;
  }
    
  *serviceHandle = btohs(resp.handle);
 801b754:	9b00      	ldr	r3, [sp, #0]
 801b756:	9a12      	ldr	r2, [sp, #72]	; 0x48
 801b758:	f3c3 230f 	ubfx	r3, r3, #8, #16
 801b75c:	8013      	strh	r3, [r2, #0]

  return 0;
}
 801b75e:	b00c      	add	sp, #48	; 0x30
 801b760:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    return BLE_STATUS_TIMEOUT;
 801b764:	20ff      	movs	r0, #255	; 0xff
}
 801b766:	b00c      	add	sp, #48	; 0x30
 801b768:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 801b76c:	0102003f 	.word	0x0102003f

0801b770 <aci_gatt_add_char>:
			     uint8_t secPermissions,
			     uint8_t gattEvtMask,
			     uint8_t encryKeySize,
			     uint8_t isVariable,
			     uint16_t* charHandle)                     
{
 801b770:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 801b774:	b095      	sub	sp, #84	; 0x54
  indx += 2;
    
  buffer[indx] = charUuidType;
  indx++;
    
  if(charUuidType == UUID_TYPE_16){
 801b776:	2901      	cmp	r1, #1
  buffer[indx] = charUuidType;
 801b778:	f88d 1036 	strb.w	r1, [sp, #54]	; 0x36
  if(charUuidType == UUID_TYPE_16){
 801b77c:	bf0c      	ite	eq
 801b77e:	210a      	moveq	r1, #10
 801b780:	2118      	movne	r1, #24
 801b782:	9102      	str	r1, [sp, #8]
{
 801b784:	4698      	mov	r8, r3
    uuid_len = 2;
  }
  else {
    uuid_len = 16;
  }        
  BLUENRG_memcpy(buffer + indx, charUuid, uuid_len);
 801b786:	4611      	mov	r1, r2
{
 801b788:	f89d 3080 	ldrb.w	r3, [sp, #128]	; 0x80
  BLUENRG_memcpy(buffer + indx, &serviceHandle, 2);
 801b78c:	f8ad 0034 	strh.w	r0, [sp, #52]	; 0x34
  if(charUuidType == UUID_TYPE_16){
 801b790:	bf0b      	itete	eq
 801b792:	220b      	moveq	r2, #11
 801b794:	2219      	movne	r2, #25
 801b796:	2409      	moveq	r4, #9
 801b798:	2417      	movne	r4, #23
 801b79a:	bf0c      	ite	eq
 801b79c:	2705      	moveq	r7, #5
 801b79e:	2713      	movne	r7, #19
 801b7a0:	9203      	str	r2, [sp, #12]
{
 801b7a2:	9305      	str	r3, [sp, #20]
  BLUENRG_memcpy(buffer + indx, charUuid, uuid_len);
 801b7a4:	bf0c      	ite	eq
 801b7a6:	2202      	moveq	r2, #2
 801b7a8:	2210      	movne	r2, #16
{
 801b7aa:	f89d 3084 	ldrb.w	r3, [sp, #132]	; 0x84
  if(charUuidType == UUID_TYPE_16){
 801b7ae:	9401      	str	r4, [sp, #4]
  BLUENRG_memcpy(buffer + indx, charUuid, uuid_len);
 801b7b0:	f10d 0037 	add.w	r0, sp, #55	; 0x37
  if(charUuidType == UUID_TYPE_16){
 801b7b4:	bf0b      	itete	eq
 801b7b6:	2408      	moveq	r4, #8
 801b7b8:	2416      	movne	r4, #22
 801b7ba:	2507      	moveq	r5, #7
 801b7bc:	2515      	movne	r5, #21
 801b7be:	bf0c      	ite	eq
 801b7c0:	2606      	moveq	r6, #6
 801b7c2:	2614      	movne	r6, #20
{
 801b7c4:	f89d b078 	ldrb.w	fp, [sp, #120]	; 0x78
 801b7c8:	f89d a07c 	ldrb.w	sl, [sp, #124]	; 0x7c
 801b7cc:	f89d 9088 	ldrb.w	r9, [sp, #136]	; 0x88
 801b7d0:	9304      	str	r3, [sp, #16]
  BLUENRG_memcpy(buffer + indx, charUuid, uuid_len);
 801b7d2:	f00b fea9 	bl	8027528 <memcpy>
  indx +=  uuid_len;
    
  buffer[indx] = charValueLen;
 801b7d6:	f107 0350 	add.w	r3, r7, #80	; 0x50
 801b7da:	eb0d 0703 	add.w	r7, sp, r3
  indx++;
    
  buffer[indx] = charProperties;
 801b7de:	f106 0350 	add.w	r3, r6, #80	; 0x50
 801b7e2:	eb0d 0603 	add.w	r6, sp, r3
  indx++;
    
  buffer[indx] = secPermissions;
 801b7e6:	f105 0350 	add.w	r3, r5, #80	; 0x50
 801b7ea:	eb0d 0503 	add.w	r5, sp, r3
  indx++;
    
  buffer[indx] = gattEvtMask;
 801b7ee:	f104 0350 	add.w	r3, r4, #80	; 0x50
 801b7f2:	eb0d 0403 	add.w	r4, sp, r3
 801b7f6:	9b05      	ldr	r3, [sp, #20]
  buffer[indx] = charValueLen;
 801b7f8:	f807 8c1c 	strb.w	r8, [r7, #-28]
  buffer[indx] = charProperties;
 801b7fc:	f806 bc1c 	strb.w	fp, [r6, #-28]
  buffer[indx] = secPermissions;
 801b800:	f805 ac1c 	strb.w	sl, [r5, #-28]
  buffer[indx] = gattEvtMask;
 801b804:	f804 3c1c 	strb.w	r3, [r4, #-28]
  indx++;
    
  buffer[indx] = encryKeySize;
 801b808:	9c01      	ldr	r4, [sp, #4]

  BLUENRG_memset(&rq, 0, sizeof(rq));
  rq.ogf = OGF_VENDOR_CMD;
  rq.ocf = OCF_GATT_ADD_CHAR;
  rq.cparam = (void *)buffer;
  rq.clen = indx;
 801b80a:	9a03      	ldr	r2, [sp, #12]
 801b80c:	920a      	str	r2, [sp, #40]	; 0x28
  buffer[indx] = encryKeySize;
 801b80e:	f104 0350 	add.w	r3, r4, #80	; 0x50
 801b812:	eb0d 0203 	add.w	r2, sp, r3
  buffer[indx] = isVariable;
 801b816:	9b02      	ldr	r3, [sp, #8]
  buffer[indx] = encryKeySize;
 801b818:	9804      	ldr	r0, [sp, #16]
 801b81a:	f802 0c1c 	strb.w	r0, [r2, #-28]
  buffer[indx] = isVariable;
 801b81e:	3350      	adds	r3, #80	; 0x50
  rq.ogf = OGF_VENDOR_CMD;
 801b820:	4a12      	ldr	r2, [pc, #72]	; (801b86c <aci_gatt_add_char+0xfc>)
  buffer[indx] = isVariable;
 801b822:	446b      	add	r3, sp
  BLUENRG_memset(&resp, 0, sizeof(resp));
 801b824:	2100      	movs	r1, #0
  rq.ogf = OGF_VENDOR_CMD;
 801b826:	e9cd 2107 	strd	r2, r1, [sp, #28]
  buffer[indx] = isVariable;
 801b82a:	f803 9c1c 	strb.w	r9, [r3, #-28]
  rq.rparam = &resp;
 801b82e:	aa06      	add	r2, sp, #24
  rq.rlen = GATT_ADD_CHAR_RP_SIZE;
 801b830:	2303      	movs	r3, #3
 801b832:	e9cd 230b 	strd	r2, r3, [sp, #44]	; 0x2c

  if (hci_send_req(&rq, FALSE) < 0)
 801b836:	a807      	add	r0, sp, #28
  BLUENRG_memcpy(buffer + indx, charUuid, uuid_len);
 801b838:	ab0d      	add	r3, sp, #52	; 0x34
  BLUENRG_memset(&resp, 0, sizeof(resp));
 801b83a:	f8ad 1018 	strh.w	r1, [sp, #24]
 801b83e:	f88d 101a 	strb.w	r1, [sp, #26]
  rq.cparam = (void *)buffer;
 801b842:	9309      	str	r3, [sp, #36]	; 0x24
  if (hci_send_req(&rq, FALSE) < 0)
 801b844:	f000 f966 	bl	801bb14 <hci_send_req>
 801b848:	2800      	cmp	r0, #0
 801b84a:	db0a      	blt.n	801b862 <aci_gatt_add_char+0xf2>
    return BLE_STATUS_TIMEOUT;

  if (resp.status) {
 801b84c:	f89d 0018 	ldrb.w	r0, [sp, #24]
 801b850:	b920      	cbnz	r0, 801b85c <aci_gatt_add_char+0xec>
    return resp.status;
  }
    
  *charHandle = btohs(resp.handle);
 801b852:	9b06      	ldr	r3, [sp, #24]
 801b854:	9a23      	ldr	r2, [sp, #140]	; 0x8c
 801b856:	f3c3 230f 	ubfx	r3, r3, #8, #16
 801b85a:	8013      	strh	r3, [r2, #0]

  return 0;
}
 801b85c:	b015      	add	sp, #84	; 0x54
 801b85e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    return BLE_STATUS_TIMEOUT;
 801b862:	20ff      	movs	r0, #255	; 0xff
}
 801b864:	b015      	add	sp, #84	; 0x54
 801b866:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 801b86a:	bf00      	nop
 801b86c:	0104003f 	.word	0x0104003f

0801b870 <aci_gatt_update_char_value>:
tBleStatus aci_gatt_update_char_value(uint16_t servHandle, 
				      uint16_t charHandle,
				      uint8_t charValOffset,
				      uint8_t charValueLen,   
                                      const void *charValue)
{
 801b870:	b510      	push	{r4, lr}
  struct hci_request rq;
  uint8_t status;
  uint8_t buffer[HCI_MAX_PAYLOAD_SIZE];
  uint8_t indx = 0;
    
  if ((charValueLen+6) > HCI_MAX_PAYLOAD_SIZE)
 801b872:	2b7a      	cmp	r3, #122	; 0x7a
{
 801b874:	b0a8      	sub	sp, #160	; 0xa0
 801b876:	461c      	mov	r4, r3
  if ((charValueLen+6) > HCI_MAX_PAYLOAD_SIZE)
 801b878:	d825      	bhi.n	801b8c6 <aci_gatt_update_char_value+0x56>
    return BLE_STATUS_INVALID_PARAMS;

  servHandle = htobs(servHandle);
  BLUENRG_memcpy(buffer + indx, &servHandle, 2);
 801b87a:	4613      	mov	r3, r2
 801b87c:	f8ad 0020 	strh.w	r0, [sp, #32]
  indx++;
    
  buffer[indx] = charValueLen;
  indx++;
        
  BLUENRG_memcpy(buffer + indx, charValue, charValueLen);
 801b880:	4622      	mov	r2, r4
  BLUENRG_memcpy(buffer + indx, &charHandle, 2);
 801b882:	f8ad 1022 	strh.w	r1, [sp, #34]	; 0x22
  BLUENRG_memcpy(buffer + indx, charValue, charValueLen);
 801b886:	f10d 0026 	add.w	r0, sp, #38	; 0x26
 801b88a:	992a      	ldr	r1, [sp, #168]	; 0xa8
  buffer[indx] = charValOffset;
 801b88c:	f88d 3024 	strb.w	r3, [sp, #36]	; 0x24
  buffer[indx] = charValueLen;
 801b890:	f88d 4025 	strb.w	r4, [sp, #37]	; 0x25
  BLUENRG_memcpy(buffer + indx, charValue, charValueLen);
 801b894:	f00b fe48 	bl	8027528 <memcpy>
  indx +=  charValueLen;
 801b898:	3406      	adds	r4, #6

  BLUENRG_memset(&rq, 0, sizeof(rq));
  rq.ogf = OGF_VENDOR_CMD;
 801b89a:	4b0e      	ldr	r3, [pc, #56]	; (801b8d4 <aci_gatt_update_char_value+0x64>)
  BLUENRG_memset(&rq, 0, sizeof(rq));
 801b89c:	2100      	movs	r1, #0
  BLUENRG_memcpy(buffer + indx, charValue, charValueLen);
 801b89e:	a808      	add	r0, sp, #32
  rq.ocf = OCF_GATT_UPD_CHAR_VAL;
  rq.cparam = (void *)buffer;
  rq.clen = indx;
 801b8a0:	b2e4      	uxtb	r4, r4
  rq.ogf = OGF_VENDOR_CMD;
 801b8a2:	e9cd 3102 	strd	r3, r1, [sp, #8]
  rq.clen = indx;
 801b8a6:	e9cd 0404 	strd	r0, r4, [sp, #16]
  rq.rparam = &status;
 801b8aa:	f10d 0207 	add.w	r2, sp, #7
  rq.rlen = 1;
 801b8ae:	2301      	movs	r3, #1

  if (hci_send_req(&rq, FALSE) < 0)
 801b8b0:	a802      	add	r0, sp, #8
  rq.rlen = 1;
 801b8b2:	e9cd 2306 	strd	r2, r3, [sp, #24]
  if (hci_send_req(&rq, FALSE) < 0)
 801b8b6:	f000 f92d 	bl	801bb14 <hci_send_req>
 801b8ba:	2800      	cmp	r0, #0
 801b8bc:	db06      	blt.n	801b8cc <aci_gatt_update_char_value+0x5c>
    return BLE_STATUS_TIMEOUT;

  if (status) {
 801b8be:	f89d 0007 	ldrb.w	r0, [sp, #7]
    return status;
  }

  return 0;
}
 801b8c2:	b028      	add	sp, #160	; 0xa0
 801b8c4:	bd10      	pop	{r4, pc}
    return BLE_STATUS_INVALID_PARAMS;
 801b8c6:	2042      	movs	r0, #66	; 0x42
}
 801b8c8:	b028      	add	sp, #160	; 0xa0
 801b8ca:	bd10      	pop	{r4, pc}
    return BLE_STATUS_TIMEOUT;
 801b8cc:	20ff      	movs	r0, #255	; 0xff
}
 801b8ce:	b028      	add	sp, #160	; 0xa0
 801b8d0:	bd10      	pop	{r4, pc}
 801b8d2:	bf00      	nop
 801b8d4:	0106003f 	.word	0x0106003f

0801b8d8 <aci_gatt_allow_read>:

  return 0;
}

tBleStatus aci_gatt_allow_read(uint16_t conn_handle)
{
 801b8d8:	b530      	push	{r4, r5, lr}
    uint8_t status;
    
    cp.conn_handle = htobs(conn_handle);

    BLUENRG_memset(&rq, 0, sizeof(rq));
    rq.ogf = OGF_VENDOR_CMD;
 801b8da:	4b0d      	ldr	r3, [pc, #52]	; (801b910 <aci_gatt_allow_read+0x38>)
{
 801b8dc:	b089      	sub	sp, #36	; 0x24
    BLUENRG_memset(&rq, 0, sizeof(rq));
 801b8de:	2100      	movs	r1, #0
    rq.ogf = OGF_VENDOR_CMD;
 801b8e0:	e9cd 3102 	strd	r3, r1, [sp, #8]
    cp.conn_handle = htobs(conn_handle);
 801b8e4:	f8ad 0004 	strh.w	r0, [sp, #4]
    rq.ocf = OCF_GATT_ALLOW_READ;
    rq.cparam = &cp;
    rq.clen = GATT_ALLOW_READ_CP_SIZE;
    rq.rparam = &status;
 801b8e8:	f10d 0203 	add.w	r2, sp, #3
    rq.rlen = 1;
 801b8ec:	2301      	movs	r3, #1
    rq.cparam = &cp;
 801b8ee:	ad01      	add	r5, sp, #4
    rq.clen = GATT_ALLOW_READ_CP_SIZE;
 801b8f0:	2402      	movs	r4, #2

    if (hci_send_req(&rq, FALSE) < 0)
 801b8f2:	a802      	add	r0, sp, #8
    rq.clen = GATT_ALLOW_READ_CP_SIZE;
 801b8f4:	e9cd 5404 	strd	r5, r4, [sp, #16]
    rq.rlen = 1;
 801b8f8:	e9cd 2306 	strd	r2, r3, [sp, #24]
    if (hci_send_req(&rq, FALSE) < 0)
 801b8fc:	f000 f90a 	bl	801bb14 <hci_send_req>
 801b900:	2800      	cmp	r0, #0
      return BLE_STATUS_TIMEOUT;

    return status;
 801b902:	bfac      	ite	ge
 801b904:	f89d 0003 	ldrbge.w	r0, [sp, #3]
      return BLE_STATUS_TIMEOUT;
 801b908:	20ff      	movlt	r0, #255	; 0xff
}
 801b90a:	b009      	add	sp, #36	; 0x24
 801b90c:	bd30      	pop	{r4, r5, pc}
 801b90e:	bf00      	nop
 801b910:	0127003f 	.word	0x0127003f

0801b914 <aci_hal_read_config_data>:

  return status;
}

tBleStatus aci_hal_read_config_data(uint8_t offset, uint16_t data_len, uint8_t *data_len_out_p, uint8_t *data)
{
 801b914:	b5f0      	push	{r4, r5, r6, r7, lr}
 801b916:	b0a9      	sub	sp, #164	; 0xa4
 801b918:	461e      	mov	r6, r3
  hal_read_config_data_rp rp;
  
  cp.offset = offset;
  
  BLUENRG_memset(&rq, 0, sizeof(rq));
  rq.ogf = OGF_VENDOR_CMD;
 801b91a:	4b16      	ldr	r3, [pc, #88]	; (801b974 <aci_hal_read_config_data+0x60>)
 801b91c:	9302      	str	r3, [sp, #8]
  rq.ocf = OCF_HAL_READ_CONFIG_DATA;
  rq.cparam = &cp;
 801b91e:	ab01      	add	r3, sp, #4
 801b920:	9304      	str	r3, [sp, #16]
  rq.clen = sizeof(cp);
 801b922:	2301      	movs	r3, #1
  BLUENRG_memset(&rq, 0, sizeof(rq));
 801b924:	2700      	movs	r7, #0
  rq.clen = sizeof(cp);
 801b926:	9305      	str	r3, [sp, #20]
  rq.rparam = &rp;
 801b928:	ab08      	add	r3, sp, #32
  cp.offset = offset;
 801b92a:	f88d 0004 	strb.w	r0, [sp, #4]
  rq.rparam = &rp;
 801b92e:	9306      	str	r3, [sp, #24]
{
 801b930:	460c      	mov	r4, r1
  rq.rlen = sizeof(rp);
 801b932:	2380      	movs	r3, #128	; 0x80
  
  if (hci_send_req(&rq, FALSE) < 0)
 801b934:	4639      	mov	r1, r7
 801b936:	a802      	add	r0, sp, #8
{
 801b938:	4615      	mov	r5, r2
  BLUENRG_memset(&rq, 0, sizeof(rq));
 801b93a:	9703      	str	r7, [sp, #12]
  rq.rlen = sizeof(rp);
 801b93c:	9307      	str	r3, [sp, #28]
  if (hci_send_req(&rq, FALSE) < 0)
 801b93e:	f000 f8e9 	bl	801bb14 <hci_send_req>
 801b942:	42b8      	cmp	r0, r7
 801b944:	db11      	blt.n	801b96a <aci_hal_read_config_data+0x56>
    return BLE_STATUS_TIMEOUT;
  
  if(rp.status)
 801b946:	f89d 7020 	ldrb.w	r7, [sp, #32]
 801b94a:	b95f      	cbnz	r7, 801b964 <aci_hal_read_config_data+0x50>
    return rp.status;
  
  *data_len_out_p = rq.rlen-1;
 801b94c:	9b07      	ldr	r3, [sp, #28]
 801b94e:	3b01      	subs	r3, #1
 801b950:	b2da      	uxtb	r2, r3
  
  BLUENRG_memcpy(data, rp.data, MIN(data_len, *data_len_out_p));
 801b952:	42a2      	cmp	r2, r4
  *data_len_out_p = rq.rlen-1;
 801b954:	702a      	strb	r2, [r5, #0]
  BLUENRG_memcpy(data, rp.data, MIN(data_len, *data_len_out_p));
 801b956:	4630      	mov	r0, r6
 801b958:	bf28      	it	cs
 801b95a:	4622      	movcs	r2, r4
 801b95c:	f10d 0121 	add.w	r1, sp, #33	; 0x21
 801b960:	f00b fde2 	bl	8027528 <memcpy>
  
  return 0;
}
 801b964:	4638      	mov	r0, r7
 801b966:	b029      	add	sp, #164	; 0xa4
 801b968:	bdf0      	pop	{r4, r5, r6, r7, pc}
    return BLE_STATUS_TIMEOUT;
 801b96a:	27ff      	movs	r7, #255	; 0xff
}
 801b96c:	4638      	mov	r0, r7
 801b96e:	b029      	add	sp, #164	; 0xa4
 801b970:	bdf0      	pop	{r4, r5, r6, r7, pc}
 801b972:	bf00      	nop
 801b974:	000d003f 	.word	0x000d003f

0801b978 <aci_hal_set_tx_power_level>:

tBleStatus aci_hal_set_tx_power_level(uint8_t en_high_power, uint8_t pa_level)
{
 801b978:	b570      	push	{r4, r5, r6, lr}
 801b97a:	b088      	sub	sp, #32
  uint8_t status;
    
  cp.en_high_power = en_high_power;
  cp.pa_level = pa_level;

  BLUENRG_memset(&rq, 0, sizeof(rq));
 801b97c:	2300      	movs	r3, #0
  cp.en_high_power = en_high_power;
 801b97e:	f88d 0004 	strb.w	r0, [sp, #4]
  cp.pa_level = pa_level;
 801b982:	f88d 1005 	strb.w	r1, [sp, #5]
  rq.ogf = OGF_VENDOR_CMD;
  rq.ocf = OCF_HAL_SET_TX_POWER_LEVEL;
  rq.cparam = &cp;
  rq.clen = HAL_SET_TX_POWER_LEVEL_CP_SIZE;
  rq.rparam = &status;
 801b986:	f10d 0203 	add.w	r2, sp, #3
  BLUENRG_memset(&rq, 0, sizeof(rq));
 801b98a:	9303      	str	r3, [sp, #12]
  rq.rlen = 1;

  if (hci_send_req(&rq, FALSE) < 0)
 801b98c:	4619      	mov	r1, r3
  rq.ogf = OGF_VENDOR_CMD;
 801b98e:	4e09      	ldr	r6, [pc, #36]	; (801b9b4 <aci_hal_set_tx_power_level+0x3c>)
 801b990:	9602      	str	r6, [sp, #8]
  rq.rlen = 1;
 801b992:	2301      	movs	r3, #1
  rq.cparam = &cp;
 801b994:	ad01      	add	r5, sp, #4
  rq.clen = HAL_SET_TX_POWER_LEVEL_CP_SIZE;
 801b996:	2402      	movs	r4, #2
  if (hci_send_req(&rq, FALSE) < 0)
 801b998:	a802      	add	r0, sp, #8
  rq.rparam = &status;
 801b99a:	e9cd 4205 	strd	r4, r2, [sp, #20]
  rq.cparam = &cp;
 801b99e:	9504      	str	r5, [sp, #16]
  rq.rlen = 1;
 801b9a0:	9307      	str	r3, [sp, #28]
  if (hci_send_req(&rq, FALSE) < 0)
 801b9a2:	f000 f8b7 	bl	801bb14 <hci_send_req>
 801b9a6:	2800      	cmp	r0, #0
    return BLE_STATUS_TIMEOUT;

  return status;
 801b9a8:	bfac      	ite	ge
 801b9aa:	f89d 0003 	ldrbge.w	r0, [sp, #3]
    return BLE_STATUS_TIMEOUT;
 801b9ae:	20ff      	movlt	r0, #255	; 0xff
}
 801b9b0:	b008      	add	sp, #32
 801b9b2:	bd70      	pop	{r4, r5, r6, pc}
 801b9b4:	000f003f 	.word	0x000f003f

0801b9b8 <aci_l2cap_connection_parameter_update_request>:
#define MAX(a,b)            ((a) > (b) )? (a) : (b)

tBleStatus aci_l2cap_connection_parameter_update_request(uint16_t conn_handle, uint16_t interval_min,
							 uint16_t interval_max, uint16_t slave_latency,
							 uint16_t timeout_multiplier)
{
 801b9b8:	b510      	push	{r4, lr}
 801b9ba:	b08a      	sub	sp, #40	; 0x28
  cp.timeout_multiplier = htobs(timeout_multiplier);

  BLUENRG_memset(&rq, 0, sizeof(rq));
  rq.ogf = OGF_VENDOR_CMD;
  rq.ocf = OCF_L2CAP_CONN_PARAM_UPDATE_REQ;
  rq.cparam = &cp;
 801b9bc:	ac01      	add	r4, sp, #4
  cp.conn_handle = htobs(conn_handle);
 801b9be:	f8ad 0004 	strh.w	r0, [sp, #4]
  cp.interval_min = htobs(interval_min);
 801b9c2:	f8ad 1006 	strh.w	r1, [sp, #6]
  rq.ogf = OGF_VENDOR_CMD;
 801b9c6:	480f      	ldr	r0, [pc, #60]	; (801ba04 <aci_l2cap_connection_parameter_update_request+0x4c>)
{
 801b9c8:	f8bd c030 	ldrh.w	ip, [sp, #48]	; 0x30
  rq.cparam = &cp;
 801b9cc:	9406      	str	r4, [sp, #24]
  rq.clen = L2CAP_CONN_PARAM_UPDATE_REQ_CP_SIZE;
 801b9ce:	210a      	movs	r1, #10
  rq.ogf = OGF_VENDOR_CMD;
 801b9d0:	9004      	str	r0, [sp, #16]
  cp.interval_max = htobs(interval_max);
 801b9d2:	f8ad 2008 	strh.w	r2, [sp, #8]
  cp.slave_latency = htobs(slave_latency);
 801b9d6:	f8ad 300a 	strh.w	r3, [sp, #10]
  rq.event = EVT_CMD_STATUS;
  rq.rparam = &status;
 801b9da:	f10d 0203 	add.w	r2, sp, #3
  rq.clen = L2CAP_CONN_PARAM_UPDATE_REQ_CP_SIZE;
 801b9de:	9107      	str	r1, [sp, #28]
  rq.rlen = 1;
 801b9e0:	2301      	movs	r3, #1
  rq.event = EVT_CMD_STATUS;
 801b9e2:	240f      	movs	r4, #15

  if (hci_send_req(&rq, FALSE) < 0)
 801b9e4:	2100      	movs	r1, #0
 801b9e6:	a804      	add	r0, sp, #16
  rq.rlen = 1;
 801b9e8:	e9cd 2308 	strd	r2, r3, [sp, #32]
  cp.timeout_multiplier = htobs(timeout_multiplier);
 801b9ec:	f8ad c00c 	strh.w	ip, [sp, #12]
  rq.event = EVT_CMD_STATUS;
 801b9f0:	9405      	str	r4, [sp, #20]
  if (hci_send_req(&rq, FALSE) < 0)
 801b9f2:	f000 f88f 	bl	801bb14 <hci_send_req>
 801b9f6:	2800      	cmp	r0, #0
    return BLE_STATUS_TIMEOUT;
  
  return status;  
 801b9f8:	bfac      	ite	ge
 801b9fa:	f89d 0003 	ldrbge.w	r0, [sp, #3]
    return BLE_STATUS_TIMEOUT;
 801b9fe:	20ff      	movlt	r0, #255	; 0xff
}
 801ba00:	b00a      	add	sp, #40	; 0x28
 801ba02:	bd10      	pop	{r4, pc}
 801ba04:	0181003f 	.word	0x0181003f

0801ba08 <hci_reset>:

#define MIN(a,b)            ((a) < (b) )? (a) : (b)
#define MAX(a,b)            ((a) > (b) )? (a) : (b)

int hci_reset(void)
{
 801ba08:	b500      	push	{lr}
  struct hci_request rq;
  uint8_t status;
  
  BLUENRG_memset(&rq, 0, sizeof(rq));
 801ba0a:	2100      	movs	r1, #0
{
 801ba0c:	b089      	sub	sp, #36	; 0x24
  rq.ogf = OGF_HOST_CTL;
 801ba0e:	f04f 1003 	mov.w	r0, #196611	; 0x30003
 801ba12:	e9cd 0102 	strd	r0, r1, [sp, #8]
  rq.ocf = OCF_RESET;
  rq.rparam = &status;
 801ba16:	f10d 0207 	add.w	r2, sp, #7
  rq.rlen = 1;
 801ba1a:	2301      	movs	r3, #1
  
  if (hci_send_req(&rq, FALSE) < 0)
 801ba1c:	a802      	add	r0, sp, #8
  BLUENRG_memset(&rq, 0, sizeof(rq));
 801ba1e:	e9cd 1104 	strd	r1, r1, [sp, #16]
  rq.rparam = &status;
 801ba22:	9206      	str	r2, [sp, #24]
  rq.rlen = 1;
 801ba24:	9307      	str	r3, [sp, #28]
  if (hci_send_req(&rq, FALSE) < 0)
 801ba26:	f000 f875 	bl	801bb14 <hci_send_req>
 801ba2a:	2800      	cmp	r0, #0
    return BLE_STATUS_TIMEOUT;
  
  return status;  
 801ba2c:	bfac      	ite	ge
 801ba2e:	f89d 0007 	ldrbge.w	r0, [sp, #7]
    return BLE_STATUS_TIMEOUT;
 801ba32:	20ff      	movlt	r0, #255	; 0xff
}
 801ba34:	b009      	add	sp, #36	; 0x24
 801ba36:	f85d fb04 	ldr.w	pc, [sp], #4
 801ba3a:	bf00      	nop

0801ba3c <hci_le_set_scan_resp_data>:
  
  return 0;
}

int hci_le_set_scan_resp_data(uint8_t length, const uint8_t data[])
{
 801ba3c:	b5f0      	push	{r4, r5, r6, r7, lr}
 801ba3e:	b091      	sub	sp, #68	; 0x44
  struct hci_request rq;
  le_set_scan_response_data_cp scan_resp_cp;
  uint8_t status;
  
  BLUENRG_memset(&scan_resp_cp, 0, sizeof(scan_resp_cp));
 801ba40:	af08      	add	r7, sp, #32
 801ba42:	2620      	movs	r6, #32
{
 801ba44:	4604      	mov	r4, r0
 801ba46:	460d      	mov	r5, r1
  BLUENRG_memset(&scan_resp_cp, 0, sizeof(scan_resp_cp));
 801ba48:	4632      	mov	r2, r6
 801ba4a:	2100      	movs	r1, #0
 801ba4c:	4638      	mov	r0, r7
 801ba4e:	f00b fd93 	bl	8027578 <memset>
  scan_resp_cp.length = length;
  BLUENRG_memcpy(scan_resp_cp.data, data, MIN(31,length));
 801ba52:	2c1f      	cmp	r4, #31
 801ba54:	4622      	mov	r2, r4
 801ba56:	4629      	mov	r1, r5
 801ba58:	bf28      	it	cs
 801ba5a:	221f      	movcs	r2, #31
 801ba5c:	f10d 0021 	add.w	r0, sp, #33	; 0x21
  scan_resp_cp.length = length;
 801ba60:	f88d 4020 	strb.w	r4, [sp, #32]
  BLUENRG_memcpy(scan_resp_cp.data, data, MIN(31,length));
 801ba64:	f00b fd60 	bl	8027528 <memcpy>
  
  BLUENRG_memset(&rq, 0, sizeof(rq));
  rq.ogf = OGF_LE_CTL;
 801ba68:	4b0a      	ldr	r3, [pc, #40]	; (801ba94 <hci_le_set_scan_resp_data+0x58>)
  rq.ocf = OCF_LE_SET_SCAN_RESPONSE_DATA;
  rq.cparam = &scan_resp_cp;
 801ba6a:	9704      	str	r7, [sp, #16]
  BLUENRG_memset(&rq, 0, sizeof(rq));
 801ba6c:	2100      	movs	r1, #0
  rq.ogf = OGF_LE_CTL;
 801ba6e:	e9cd 3102 	strd	r3, r1, [sp, #8]
  rq.clen = LE_SET_SCAN_RESPONSE_DATA_CP_SIZE;
  rq.rparam = &status;
 801ba72:	f10d 0207 	add.w	r2, sp, #7
  rq.rlen = 1;
 801ba76:	2301      	movs	r3, #1
  
  if (hci_send_req(&rq, FALSE) < 0)
 801ba78:	a802      	add	r0, sp, #8
  rq.rparam = &status;
 801ba7a:	e9cd 6205 	strd	r6, r2, [sp, #20]
  rq.rlen = 1;
 801ba7e:	9307      	str	r3, [sp, #28]
  if (hci_send_req(&rq, FALSE) < 0)
 801ba80:	f000 f848 	bl	801bb14 <hci_send_req>
 801ba84:	2800      	cmp	r0, #0
    return BLE_STATUS_TIMEOUT;
  
  return status;
 801ba86:	bfac      	ite	ge
 801ba88:	f89d 0007 	ldrbge.w	r0, [sp, #7]
    return BLE_STATUS_TIMEOUT;
 801ba8c:	20ff      	movlt	r0, #255	; 0xff
}
 801ba8e:	b011      	add	sp, #68	; 0x44
 801ba90:	bdf0      	pop	{r4, r5, r6, r7, pc}
 801ba92:	bf00      	nop
 801ba94:	00090008 	.word	0x00090008

0801ba98 <hci_init>:
}

/********************** HCI Transport layer functions *****************************/

void hci_init(void(* UserEvtRx)(void* pData), void* pConf)
{
 801ba98:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  uint8_t index;
  
  if(UserEvtRx != NULL)
  {
    hciContext.UserEvtRx = UserEvtRx;
 801ba9c:	4f11      	ldr	r7, [pc, #68]	; (801bae4 <hci_init+0x4c>)
  if(UserEvtRx != NULL)
 801ba9e:	b100      	cbz	r0, 801baa2 <hci_init+0xa>
    hciContext.UserEvtRx = UserEvtRx;
 801baa0:	61f8      	str	r0, [r7, #28]
  }
  
  /* Initialize TL BLE layer */
  hci_tl_lowlevel_init();
 801baa2:	f005 fcef 	bl	8021484 <hci_tl_lowlevel_init>
  
  /* Initialize list heads of ready and free hci data packet queues */
  list_init_head(&hciReadPktPool);
 801baa6:	4810      	ldr	r0, [pc, #64]	; (801bae8 <hci_init+0x50>)
 801baa8:	f7ff fc92 	bl	801b3d0 <list_init_head>
  list_init_head(&hciReadPktRxQueue);
 801baac:	480f      	ldr	r0, [pc, #60]	; (801baec <hci_init+0x54>)
 801baae:	f100 0408 	add.w	r4, r0, #8
 801bab2:	f7ff fc8d 	bl	801b3d0 <list_init_head>
  
  /* Initialize the queue of free hci data packets */
  for (index = 0; index < HCI_READ_PACKET_NUM_MAX; index++)
 801bab6:	f504 762f 	add.w	r6, r4, #700	; 0x2bc
  {
    list_insert_tail(&hciReadPktPool, (tListNode *)&hciReadPacketBuffer[index]);
 801baba:	f1a4 0510 	sub.w	r5, r4, #16
 801babe:	4621      	mov	r1, r4
 801bac0:	4628      	mov	r0, r5
  for (index = 0; index < HCI_READ_PACKET_NUM_MAX; index++)
 801bac2:	348c      	adds	r4, #140	; 0x8c
    list_insert_tail(&hciReadPktPool, (tListNode *)&hciReadPacketBuffer[index]);
 801bac4:	f7ff fca0 	bl	801b408 <list_insert_tail>
  for (index = 0; index < HCI_READ_PACKET_NUM_MAX; index++)
 801bac8:	42a6      	cmp	r6, r4
 801baca:	d1f8      	bne.n	801babe <hci_init+0x26>
  } 
  
  /* Initialize low level driver */
  if (hciContext.io.Init)  hciContext.io.Init(NULL);
 801bacc:	683b      	ldr	r3, [r7, #0]
 801bace:	b10b      	cbz	r3, 801bad4 <hci_init+0x3c>
 801bad0:	2000      	movs	r0, #0
 801bad2:	4798      	blx	r3
  if (hciContext.io.Reset) hciContext.io.Reset();
 801bad4:	68bb      	ldr	r3, [r7, #8]
 801bad6:	b113      	cbz	r3, 801bade <hci_init+0x46>
}
 801bad8:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
  if (hciContext.io.Reset) hciContext.io.Reset();
 801badc:	4718      	bx	r3
}
 801bade:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 801bae2:	bf00      	nop
 801bae4:	20009130 	.word	0x20009130
 801bae8:	20009150 	.word	0x20009150
 801baec:	20009158 	.word	0x20009158

0801baf0 <hci_register_io_bus>:

void hci_register_io_bus(tHciIO* fops)
{
 801baf0:	b410      	push	{r4}
  /* Register bus function */
  hciContext.io.Init    = fops->Init; 
  hciContext.io.Receive = fops->Receive;  
  hciContext.io.Send    = fops->Send;
 801baf2:	e9d0 2403 	ldrd	r2, r4, [r0, #12]
  hciContext.io.Init    = fops->Init; 
 801baf6:	4b06      	ldr	r3, [pc, #24]	; (801bb10 <hci_register_io_bus+0x20>)
 801baf8:	6801      	ldr	r1, [r0, #0]
 801bafa:	6019      	str	r1, [r3, #0]
  hciContext.io.Receive = fops->Receive;  
 801bafc:	60da      	str	r2, [r3, #12]
  hciContext.io.GetTick = fops->GetTick;
 801bafe:	6981      	ldr	r1, [r0, #24]
  hciContext.io.Reset   = fops->Reset;    
 801bb00:	6882      	ldr	r2, [r0, #8]
  hciContext.io.Send    = fops->Send;
 801bb02:	611c      	str	r4, [r3, #16]
  hciContext.io.GetTick = fops->GetTick;
 801bb04:	6199      	str	r1, [r3, #24]
}
 801bb06:	f85d 4b04 	ldr.w	r4, [sp], #4
  hciContext.io.Reset   = fops->Reset;    
 801bb0a:	609a      	str	r2, [r3, #8]
}
 801bb0c:	4770      	bx	lr
 801bb0e:	bf00      	nop
 801bb10:	20009130 	.word	0x20009130

0801bb14 <hci_send_req>:

int hci_send_req(struct hci_request* r, BOOL async)
{
 801bb14:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 801bb18:	f8df 91a8 	ldr.w	r9, [pc, #424]	; 801bcc4 <hci_send_req+0x1b0>
  uint8_t *ptr;
  uint16_t opcode = htobs(cmd_opcode_pack(r->ogf, r->ocf));
 801bb1c:	8847      	ldrh	r7, [r0, #2]
{
 801bb1e:	b0a4      	sub	sp, #144	; 0x90
 801bb20:	4606      	mov	r6, r0
  hci_event_pckt *event_pckt;
  hci_uart_pckt *hci_hdr;

  tHciDataPacket * hciReadPacket = NULL;
 801bb22:	2300      	movs	r3, #0
  tListNode hciTempQueue;
  
  list_init_head(&hciTempQueue);
 801bb24:	a802      	add	r0, sp, #8
  uint16_t opcode = htobs(cmd_opcode_pack(r->ogf, r->ocf));
 801bb26:	f8b6 a000 	ldrh.w	sl, [r6]
  tHciDataPacket * hciReadPacket = NULL;
 801bb2a:	9301      	str	r3, [sp, #4]
{
 801bb2c:	4688      	mov	r8, r1
  while(list_get_size(&hciReadPktPool) < HCI_READ_PACKET_NUM_MAX/2){
 801bb2e:	f109 0420 	add.w	r4, r9, #32
  list_init_head(&hciTempQueue);
 801bb32:	f7ff fc4d 	bl	801b3d0 <list_init_head>
    list_remove_head(&hciReadPktRxQueue, (tListNode **)&pckt);    
 801bb36:	f109 0528 	add.w	r5, r9, #40	; 0x28
  while(list_get_size(&hciReadPktPool) < HCI_READ_PACKET_NUM_MAX/2){
 801bb3a:	e005      	b.n	801bb48 <hci_send_req+0x34>
    list_remove_head(&hciReadPktRxQueue, (tListNode **)&pckt);    
 801bb3c:	f7ff fc70 	bl	801b420 <list_remove_head>
    list_insert_tail(&hciReadPktPool, (tListNode *)pckt);
 801bb40:	9904      	ldr	r1, [sp, #16]
 801bb42:	4620      	mov	r0, r4
 801bb44:	f7ff fc60 	bl	801b408 <list_insert_tail>
  while(list_get_size(&hciReadPktPool) < HCI_READ_PACKET_NUM_MAX/2){
 801bb48:	4620      	mov	r0, r4
 801bb4a:	f7ff fc95 	bl	801b478 <list_get_size>
 801bb4e:	4603      	mov	r3, r0
 801bb50:	2b01      	cmp	r3, #1
    list_remove_head(&hciReadPktRxQueue, (tListNode **)&pckt);    
 801bb52:	a904      	add	r1, sp, #16
 801bb54:	4628      	mov	r0, r5
  while(list_get_size(&hciReadPktPool) < HCI_READ_PACKET_NUM_MAX/2){
 801bb56:	ddf1      	ble.n	801bb3c <hci_send_req+0x28>
  hc.opcode = htobs(cmd_opcode_pack(ogf, ocf));
 801bb58:	8873      	ldrh	r3, [r6, #2]
 801bb5a:	8832      	ldrh	r2, [r6, #0]

  free_event_list();
  
  send_cmd(r->ogf, r->ocf, r->clen, r->cparam);
 801bb5c:	7b34      	ldrb	r4, [r6, #12]
  BLUENRG_memcpy(payload + HCI_HDR_SIZE + HCI_COMMAND_HDR_SIZE, param, plen);
 801bb5e:	68b1      	ldr	r1, [r6, #8]
  BLUENRG_memcpy(payload + 1, &hc, sizeof(hc));
 801bb60:	f88d 4013 	strb.w	r4, [sp, #19]
  hc.opcode = htobs(cmd_opcode_pack(ogf, ocf));
 801bb64:	f3c3 0309 	ubfx	r3, r3, #0, #10
 801bb68:	ea43 2382 	orr.w	r3, r3, r2, lsl #10
  BLUENRG_memcpy(payload + 1, &hc, sizeof(hc));
 801bb6c:	f8ad 3011 	strh.w	r3, [sp, #17]
  BLUENRG_memcpy(payload + HCI_HDR_SIZE + HCI_COMMAND_HDR_SIZE, param, plen);
 801bb70:	4622      	mov	r2, r4
  payload[0] = HCI_COMMAND_PKT;
 801bb72:	2301      	movs	r3, #1
  BLUENRG_memcpy(payload + HCI_HDR_SIZE + HCI_COMMAND_HDR_SIZE, param, plen);
 801bb74:	a805      	add	r0, sp, #20
  payload[0] = HCI_COMMAND_PKT;
 801bb76:	f88d 3010 	strb.w	r3, [sp, #16]
  BLUENRG_memcpy(payload + HCI_HDR_SIZE + HCI_COMMAND_HDR_SIZE, param, plen);
 801bb7a:	f00b fcd5 	bl	8027528 <memcpy>
  if (hciContext.io.Send)
 801bb7e:	f8d9 3010 	ldr.w	r3, [r9, #16]
 801bb82:	b113      	cbz	r3, 801bb8a <hci_send_req+0x76>
    hciContext.io.Send (payload, HCI_HDR_SIZE + HCI_COMMAND_HDR_SIZE + plen);
 801bb84:	1d21      	adds	r1, r4, #4
 801bb86:	a804      	add	r0, sp, #16
 801bb88:	4798      	blx	r3
  
  if (async)
 801bb8a:	f1b8 0f00 	cmp.w	r8, #0
 801bb8e:	f040 8087 	bne.w	801bca0 <hci_send_req+0x18c>
      if ((HAL_GetTick() - tickstart) > HCI_DEFAULT_TIMEOUT_MS)
      {
        goto failed;
      }
      
      if (!list_is_empty(&hciReadPktRxQueue)) 
 801bb92:	4d4a      	ldr	r5, [pc, #296]	; (801bcbc <hci_send_req+0x1a8>)
  uint16_t opcode = htobs(cmd_opcode_pack(r->ogf, r->ocf));
 801bb94:	f3c7 0709 	ubfx	r7, r7, #0, #10
 801bb98:	ea47 278a 	orr.w	r7, r7, sl, lsl #10
 801bb9c:	b2bf      	uxth	r7, r7
    
    /* If there are no more packets to be processed, be sure there is at list one
       packet in the pool to process the expected event.
       If no free packets are available, discard the processed event and insert it
       into the pool. */
    if (list_is_empty(&hciReadPktPool) && list_is_empty(&hciReadPktRxQueue)) {
 801bb9e:	f1a5 0808 	sub.w	r8, r5, #8
    uint32_t tickstart = HAL_GetTick();
 801bba2:	f7f3 fe49 	bl	800f838 <HAL_GetTick>
 801bba6:	4604      	mov	r4, r0
 801bba8:	e002      	b.n	801bbb0 <hci_send_req+0x9c>
      if (!list_is_empty(&hciReadPktRxQueue)) 
 801bbaa:	f7ff fc15 	bl	801b3d8 <list_is_empty>
 801bbae:	b1f0      	cbz	r0, 801bbee <hci_send_req+0xda>
      if ((HAL_GetTick() - tickstart) > HCI_DEFAULT_TIMEOUT_MS)
 801bbb0:	f7f3 fe42 	bl	800f838 <HAL_GetTick>
 801bbb4:	1b03      	subs	r3, r0, r4
 801bbb6:	f5b3 7f7a 	cmp.w	r3, #1000	; 0x3e8
      if (!list_is_empty(&hciReadPktRxQueue)) 
 801bbba:	4628      	mov	r0, r5
      if ((HAL_GetTick() - tickstart) > HCI_DEFAULT_TIMEOUT_MS)
 801bbbc:	d9f5      	bls.n	801bbaa <hci_send_req+0x96>
      hciReadPacket=NULL;
    }
  }
  
failed: 
  if (hciReadPacket!=NULL) {
 801bbbe:	9901      	ldr	r1, [sp, #4]
 801bbc0:	2900      	cmp	r1, #0
 801bbc2:	d142      	bne.n	801bc4a <hci_send_req+0x136>
    list_insert_head(dest_list, tmp_node);
 801bbc4:	4c3d      	ldr	r4, [pc, #244]	; (801bcbc <hci_send_req+0x1a8>)
 801bbc6:	e005      	b.n	801bbd4 <hci_send_req+0xc0>
    list_remove_tail(src_list, &tmp_node);
 801bbc8:	f7ff fc40 	bl	801b44c <list_remove_tail>
    list_insert_head(dest_list, tmp_node);
 801bbcc:	9904      	ldr	r1, [sp, #16]
 801bbce:	4620      	mov	r0, r4
 801bbd0:	f7ff fc0e 	bl	801b3f0 <list_insert_head>
  while (!list_is_empty(src_list))
 801bbd4:	a802      	add	r0, sp, #8
 801bbd6:	f7ff fbff 	bl	801b3d8 <list_is_empty>
 801bbda:	4603      	mov	r3, r0
    list_remove_tail(src_list, &tmp_node);
 801bbdc:	a904      	add	r1, sp, #16
 801bbde:	a802      	add	r0, sp, #8
  while (!list_is_empty(src_list))
 801bbe0:	2b00      	cmp	r3, #0
 801bbe2:	d0f1      	beq.n	801bbc8 <hci_send_req+0xb4>
    list_insert_head(&hciReadPktPool, (tListNode *)hciReadPacket);
  }
  move_list(&hciReadPktRxQueue, &hciTempQueue);  
  return -1;
 801bbe4:	f04f 30ff 	mov.w	r0, #4294967295
done:
  /* Insert the packet back into the pool.*/
  list_insert_head(&hciReadPktPool, (tListNode *)hciReadPacket); 
  move_list(&hciReadPktRxQueue, &hciTempQueue);
  return 0;
}
 801bbe8:	b024      	add	sp, #144	; 0x90
 801bbea:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    list_remove_head(&hciReadPktRxQueue, (tListNode **)&hciReadPacket);    
 801bbee:	a901      	add	r1, sp, #4
 801bbf0:	4628      	mov	r0, r5
 801bbf2:	f7ff fc15 	bl	801b420 <list_remove_head>
    hci_hdr = (void *)hciReadPacket->dataBuff;
 801bbf6:	9901      	ldr	r1, [sp, #4]
    if (hci_hdr->type == HCI_EVENT_PKT)
 801bbf8:	7a0b      	ldrb	r3, [r1, #8]
 801bbfa:	2b04      	cmp	r3, #4
 801bbfc:	d112      	bne.n	801bc24 <hci_send_req+0x110>
      switch (event_pckt->evt) 
 801bbfe:	7a4b      	ldrb	r3, [r1, #9]
      len = hciReadPacket->data_len - (1 + HCI_EVENT_HDR_SIZE);
 801bc00:	f891 2088 	ldrb.w	r2, [r1, #136]	; 0x88
      switch (event_pckt->evt) 
 801bc04:	2b10      	cmp	r3, #16
 801bc06:	d020      	beq.n	801bc4a <hci_send_req+0x136>
 801bc08:	d823      	bhi.n	801bc52 <hci_send_req+0x13e>
 801bc0a:	2b0e      	cmp	r3, #14
 801bc0c:	d01a      	beq.n	801bc44 <hci_send_req+0x130>
 801bc0e:	2b0f      	cmp	r3, #15
 801bc10:	d108      	bne.n	801bc24 <hci_send_req+0x110>
        if (cs->opcode != opcode)
 801bc12:	f8b1 300d 	ldrh.w	r3, [r1, #13]
 801bc16:	42bb      	cmp	r3, r7
 801bc18:	d117      	bne.n	801bc4a <hci_send_req+0x136>
        if (r->event != EVT_CMD_STATUS) {
 801bc1a:	6873      	ldr	r3, [r6, #4]
 801bc1c:	2b0f      	cmp	r3, #15
 801bc1e:	d04a      	beq.n	801bcb6 <hci_send_req+0x1a2>
          if (cs->status) {
 801bc20:	7acb      	ldrb	r3, [r1, #11]
 801bc22:	b993      	cbnz	r3, 801bc4a <hci_send_req+0x136>
    if (list_is_empty(&hciReadPktPool) && list_is_empty(&hciReadPktRxQueue)) {
 801bc24:	4640      	mov	r0, r8
 801bc26:	f7ff fbd7 	bl	801b3d8 <list_is_empty>
 801bc2a:	b120      	cbz	r0, 801bc36 <hci_send_req+0x122>
 801bc2c:	4628      	mov	r0, r5
 801bc2e:	f7ff fbd3 	bl	801b3d8 <list_is_empty>
 801bc32:	2800      	cmp	r0, #0
 801bc34:	d138      	bne.n	801bca8 <hci_send_req+0x194>
    list_insert_tail(&hciTempQueue, (tListNode *)hciReadPacket);
 801bc36:	9901      	ldr	r1, [sp, #4]
 801bc38:	a802      	add	r0, sp, #8
 801bc3a:	f7ff fbe5 	bl	801b408 <list_insert_tail>
      hciReadPacket=NULL;
 801bc3e:	2300      	movs	r3, #0
 801bc40:	9301      	str	r3, [sp, #4]
 801bc42:	e7ae      	b.n	801bba2 <hci_send_req+0x8e>
        if (cc->opcode != opcode)
 801bc44:	898b      	ldrh	r3, [r1, #12]
 801bc46:	42bb      	cmp	r3, r7
 801bc48:	d00c      	beq.n	801bc64 <hci_send_req+0x150>
    list_insert_head(&hciReadPktPool, (tListNode *)hciReadPacket);
 801bc4a:	481d      	ldr	r0, [pc, #116]	; (801bcc0 <hci_send_req+0x1ac>)
 801bc4c:	f7ff fbd0 	bl	801b3f0 <list_insert_head>
 801bc50:	e7b8      	b.n	801bbc4 <hci_send_req+0xb0>
      switch (event_pckt->evt) 
 801bc52:	2b3e      	cmp	r3, #62	; 0x3e
 801bc54:	d1e6      	bne.n	801bc24 <hci_send_req+0x110>
        if (me->subevent != r->event)
 801bc56:	7ac8      	ldrb	r0, [r1, #11]
 801bc58:	6873      	ldr	r3, [r6, #4]
 801bc5a:	4298      	cmp	r0, r3
 801bc5c:	d1e2      	bne.n	801bc24 <hci_send_req+0x110>
        len -= 1;
 801bc5e:	3a04      	subs	r2, #4
        BLUENRG_memcpy(r->rparam, me->data, r->rlen);
 801bc60:	310c      	adds	r1, #12
 801bc62:	e001      	b.n	801bc68 <hci_send_req+0x154>
        len -= EVT_CMD_COMPLETE_SIZE;
 801bc64:	3a06      	subs	r2, #6
        BLUENRG_memcpy(r->rparam, ptr, r->rlen);
 801bc66:	310e      	adds	r1, #14
        r->rlen = MIN(len, r->rlen);
 801bc68:	6973      	ldr	r3, [r6, #20]
        BLUENRG_memcpy(r->rparam, me->data, r->rlen);
 801bc6a:	6930      	ldr	r0, [r6, #16]
    list_insert_head(dest_list, tmp_node);
 801bc6c:	4c13      	ldr	r4, [pc, #76]	; (801bcbc <hci_send_req+0x1a8>)
        r->rlen = MIN(len, r->rlen);
 801bc6e:	429a      	cmp	r2, r3
 801bc70:	bf28      	it	cs
 801bc72:	461a      	movcs	r2, r3
 801bc74:	6172      	str	r2, [r6, #20]
        BLUENRG_memcpy(r->rparam, me->data, r->rlen);
 801bc76:	f00b fc57 	bl	8027528 <memcpy>
  list_insert_head(&hciReadPktPool, (tListNode *)hciReadPacket); 
 801bc7a:	9901      	ldr	r1, [sp, #4]
 801bc7c:	4810      	ldr	r0, [pc, #64]	; (801bcc0 <hci_send_req+0x1ac>)
 801bc7e:	f7ff fbb7 	bl	801b3f0 <list_insert_head>
static void move_list(tListNode * dest_list, tListNode * src_list)
 801bc82:	e005      	b.n	801bc90 <hci_send_req+0x17c>
    list_remove_tail(src_list, &tmp_node);
 801bc84:	f7ff fbe2 	bl	801b44c <list_remove_tail>
    list_insert_head(dest_list, tmp_node);
 801bc88:	9904      	ldr	r1, [sp, #16]
 801bc8a:	4620      	mov	r0, r4
 801bc8c:	f7ff fbb0 	bl	801b3f0 <list_insert_head>
  while (!list_is_empty(src_list))
 801bc90:	a802      	add	r0, sp, #8
 801bc92:	f7ff fba1 	bl	801b3d8 <list_is_empty>
 801bc96:	4603      	mov	r3, r0
    list_remove_tail(src_list, &tmp_node);
 801bc98:	a904      	add	r1, sp, #16
 801bc9a:	a802      	add	r0, sp, #8
  while (!list_is_empty(src_list))
 801bc9c:	2b00      	cmp	r3, #0
 801bc9e:	d0f1      	beq.n	801bc84 <hci_send_req+0x170>
    return 0;
 801bca0:	2000      	movs	r0, #0
}
 801bca2:	b024      	add	sp, #144	; 0x90
 801bca4:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
      list_insert_tail(&hciReadPktPool, (tListNode *)hciReadPacket);
 801bca8:	9901      	ldr	r1, [sp, #4]
 801bcaa:	4640      	mov	r0, r8
 801bcac:	f7ff fbac 	bl	801b408 <list_insert_tail>
      hciReadPacket=NULL;
 801bcb0:	2300      	movs	r3, #0
 801bcb2:	9301      	str	r3, [sp, #4]
 801bcb4:	e775      	b.n	801bba2 <hci_send_req+0x8e>
      len = hciReadPacket->data_len - (1 + HCI_EVENT_HDR_SIZE);
 801bcb6:	3a03      	subs	r2, #3
        BLUENRG_memcpy(r->rparam, ptr, r->rlen);
 801bcb8:	310b      	adds	r1, #11
 801bcba:	e7d5      	b.n	801bc68 <hci_send_req+0x154>
 801bcbc:	20009158 	.word	0x20009158
 801bcc0:	20009150 	.word	0x20009150
 801bcc4:	20009130 	.word	0x20009130

0801bcc8 <hci_user_evt_proc>:

void hci_user_evt_proc(void)
{
 801bcc8:	b570      	push	{r4, r5, r6, lr}
 801bcca:	4d0f      	ldr	r5, [pc, #60]	; (801bd08 <hci_user_evt_proc+0x40>)
 801bccc:	b082      	sub	sp, #8
  tHciDataPacket * hciReadPacket = NULL;
 801bcce:	2300      	movs	r3, #0
 801bcd0:	9301      	str	r3, [sp, #4]
     
  /* process any pending events read */
  while (list_is_empty(&hciReadPktRxQueue) == FALSE)
 801bcd2:	f105 0428 	add.w	r4, r5, #40	; 0x28
    list_remove_head (&hciReadPktRxQueue, (tListNode **)&hciReadPacket);
    if (hciContext.UserEvtRx != NULL)
    {
      hciContext.UserEvtRx(hciReadPacket->dataBuff);
    }
    list_insert_tail(&hciReadPktPool, (tListNode *)hciReadPacket);
 801bcd6:	f105 0620 	add.w	r6, r5, #32
  while (list_is_empty(&hciReadPktRxQueue) == FALSE)
 801bcda:	e00a      	b.n	801bcf2 <hci_user_evt_proc+0x2a>
    list_remove_head (&hciReadPktRxQueue, (tListNode **)&hciReadPacket);
 801bcdc:	f7ff fba0 	bl	801b420 <list_remove_head>
    if (hciContext.UserEvtRx != NULL)
 801bce0:	69eb      	ldr	r3, [r5, #28]
 801bce2:	b113      	cbz	r3, 801bcea <hci_user_evt_proc+0x22>
      hciContext.UserEvtRx(hciReadPacket->dataBuff);
 801bce4:	9801      	ldr	r0, [sp, #4]
 801bce6:	3008      	adds	r0, #8
 801bce8:	4798      	blx	r3
    list_insert_tail(&hciReadPktPool, (tListNode *)hciReadPacket);
 801bcea:	9901      	ldr	r1, [sp, #4]
 801bcec:	4630      	mov	r0, r6
 801bcee:	f7ff fb8b 	bl	801b408 <list_insert_tail>
  while (list_is_empty(&hciReadPktRxQueue) == FALSE)
 801bcf2:	4620      	mov	r0, r4
 801bcf4:	f7ff fb70 	bl	801b3d8 <list_is_empty>
 801bcf8:	4603      	mov	r3, r0
    list_remove_head (&hciReadPktRxQueue, (tListNode **)&hciReadPacket);
 801bcfa:	a901      	add	r1, sp, #4
 801bcfc:	4620      	mov	r0, r4
  while (list_is_empty(&hciReadPktRxQueue) == FALSE)
 801bcfe:	2b00      	cmp	r3, #0
 801bd00:	d0ec      	beq.n	801bcdc <hci_user_evt_proc+0x14>
  }
}
 801bd02:	b002      	add	sp, #8
 801bd04:	bd70      	pop	{r4, r5, r6, pc}
 801bd06:	bf00      	nop
 801bd08:	20009130 	.word	0x20009130

0801bd0c <hci_notify_asynch_evt>:

int32_t hci_notify_asynch_evt(void* pdata)
{
 801bd0c:	b570      	push	{r4, r5, r6, lr}
  tHciDataPacket * hciReadPacket = NULL;
  uint8_t data_len;
  
  int32_t ret = 0;
  
  if (list_is_empty (&hciReadPktPool) == FALSE)
 801bd0e:	4e1c      	ldr	r6, [pc, #112]	; (801bd80 <hci_notify_asynch_evt+0x74>)
{
 801bd10:	b082      	sub	sp, #8
  tHciDataPacket * hciReadPacket = NULL;
 801bd12:	2300      	movs	r3, #0
  if (list_is_empty (&hciReadPktPool) == FALSE)
 801bd14:	f106 0020 	add.w	r0, r6, #32
  tHciDataPacket * hciReadPacket = NULL;
 801bd18:	9301      	str	r3, [sp, #4]
  if (list_is_empty (&hciReadPktPool) == FALSE)
 801bd1a:	f7ff fb5d 	bl	801b3d8 <list_is_empty>
 801bd1e:	b110      	cbz	r0, 801bd26 <hci_notify_asynch_evt+0x1a>
      }
    }
  }
  else 
  {
    ret = 1;
 801bd20:	2001      	movs	r0, #1
  }
  return ret;

}
 801bd22:	b002      	add	sp, #8
 801bd24:	bd70      	pop	{r4, r5, r6, pc}
    list_remove_head (&hciReadPktPool, (tListNode **)&hciReadPacket);
 801bd26:	4605      	mov	r5, r0
 801bd28:	a901      	add	r1, sp, #4
 801bd2a:	f106 0020 	add.w	r0, r6, #32
 801bd2e:	f7ff fb77 	bl	801b420 <list_remove_head>
    if (hciContext.io.Receive)
 801bd32:	68f3      	ldr	r3, [r6, #12]
 801bd34:	b313      	cbz	r3, 801bd7c <hci_notify_asynch_evt+0x70>
      data_len = hciContext.io.Receive(hciReadPacket->dataBuff, HCI_READ_PACKET_SIZE);
 801bd36:	9801      	ldr	r0, [sp, #4]
 801bd38:	2180      	movs	r1, #128	; 0x80
 801bd3a:	3008      	adds	r0, #8
 801bd3c:	4798      	blx	r3
      if (data_len > 0)
 801bd3e:	f010 04ff 	ands.w	r4, r0, #255	; 0xff
        hciReadPacket->data_len = data_len;
 801bd42:	9901      	ldr	r1, [sp, #4]
      if (data_len > 0)
 801bd44:	d00e      	beq.n	801bd64 <hci_notify_asynch_evt+0x58>
  if (hci_pckt[HCI_PCK_TYPE_OFFSET] != HCI_EVENT_PKT)
 801bd46:	7a0b      	ldrb	r3, [r1, #8]
        hciReadPacket->data_len = data_len;
 801bd48:	f881 4088 	strb.w	r4, [r1, #136]	; 0x88
  if (hci_pckt[HCI_PCK_TYPE_OFFSET] != HCI_EVENT_PKT)
 801bd4c:	2b04      	cmp	r3, #4
 801bd4e:	d10f      	bne.n	801bd70 <hci_notify_asynch_evt+0x64>
  if (hci_pckt[EVENT_PARAMETER_TOT_LEN_OFFSET] != hciReadPacket->data_len - (1+HCI_EVENT_HDR_SIZE))
 801bd50:	7a8b      	ldrb	r3, [r1, #10]
 801bd52:	3c03      	subs	r4, #3
 801bd54:	42a3      	cmp	r3, r4
 801bd56:	d10b      	bne.n	801bd70 <hci_notify_asynch_evt+0x64>
          list_insert_tail(&hciReadPktRxQueue, (tListNode *)hciReadPacket);
 801bd58:	f106 0028 	add.w	r0, r6, #40	; 0x28
 801bd5c:	f7ff fb54 	bl	801b408 <list_insert_tail>
  int32_t ret = 0;
 801bd60:	4628      	mov	r0, r5
 801bd62:	e7de      	b.n	801bd22 <hci_notify_asynch_evt+0x16>
        list_insert_head(&hciReadPktPool, (tListNode *)hciReadPacket);
 801bd64:	f106 0020 	add.w	r0, r6, #32
 801bd68:	f7ff fb42 	bl	801b3f0 <list_insert_head>
  int32_t ret = 0;
 801bd6c:	4620      	mov	r0, r4
 801bd6e:	e7d8      	b.n	801bd22 <hci_notify_asynch_evt+0x16>
          list_insert_head(&hciReadPktPool, (tListNode *)hciReadPacket);          
 801bd70:	4804      	ldr	r0, [pc, #16]	; (801bd84 <hci_notify_asynch_evt+0x78>)
 801bd72:	f7ff fb3d 	bl	801b3f0 <list_insert_head>
  int32_t ret = 0;
 801bd76:	2000      	movs	r0, #0
}
 801bd78:	b002      	add	sp, #8
 801bd7a:	bd70      	pop	{r4, r5, r6, pc}
  int32_t ret = 0;
 801bd7c:	4618      	mov	r0, r3
  return ret;
 801bd7e:	e7d0      	b.n	801bd22 <hci_notify_asynch_evt+0x16>
 801bd80:	20009130 	.word	0x20009130
 801bd84:	20009150 	.word	0x20009150

0801bd88 <USBD_MSC_GetHSCfgDesc>:
* @param  length : pointer data length
* @retval pointer to descriptor buffer
*/
uint8_t  *USBD_MSC_GetHSCfgDesc (uint16_t *length)
{
  *length = sizeof (USBD_MSC_CfgHSDesc);
 801bd88:	2320      	movs	r3, #32
 801bd8a:	8003      	strh	r3, [r0, #0]
  return USBD_MSC_CfgHSDesc;
}
 801bd8c:	4800      	ldr	r0, [pc, #0]	; (801bd90 <USBD_MSC_GetHSCfgDesc+0x8>)
 801bd8e:	4770      	bx	lr
 801bd90:	20000448 	.word	0x20000448

0801bd94 <USBD_MSC_GetFSCfgDesc>:
* @param  length : pointer data length
* @retval pointer to descriptor buffer
*/
uint8_t  *USBD_MSC_GetFSCfgDesc (uint16_t *length)
{
  *length = sizeof (USBD_MSC_CfgFSDesc);
 801bd94:	2320      	movs	r3, #32
 801bd96:	8003      	strh	r3, [r0, #0]
  return USBD_MSC_CfgFSDesc;
}
 801bd98:	4800      	ldr	r0, [pc, #0]	; (801bd9c <USBD_MSC_GetFSCfgDesc+0x8>)
 801bd9a:	4770      	bx	lr
 801bd9c:	20000468 	.word	0x20000468

0801bda0 <USBD_MSC_GetOtherSpeedCfgDesc>:
* @param  length : pointer data length
* @retval pointer to descriptor buffer
*/
uint8_t  *USBD_MSC_GetOtherSpeedCfgDesc (uint16_t *length)
{
  *length = sizeof (USBD_MSC_OtherSpeedCfgDesc);
 801bda0:	2320      	movs	r3, #32
 801bda2:	8003      	strh	r3, [r0, #0]
  return USBD_MSC_OtherSpeedCfgDesc;
}
 801bda4:	4800      	ldr	r0, [pc, #0]	; (801bda8 <USBD_MSC_GetOtherSpeedCfgDesc+0x8>)
 801bda6:	4770      	bx	lr
 801bda8:	20000488 	.word	0x20000488

0801bdac <USBD_MSC_GetDeviceQualifierDescriptor>:
* @param  length : pointer data length
* @retval pointer to descriptor buffer
*/
uint8_t  *USBD_MSC_GetDeviceQualifierDescriptor (uint16_t *length)
{
  *length = sizeof (USBD_MSC_DeviceQualifierDesc);
 801bdac:	230a      	movs	r3, #10
 801bdae:	8003      	strh	r3, [r0, #0]
  return USBD_MSC_DeviceQualifierDesc;
}
 801bdb0:	4800      	ldr	r0, [pc, #0]	; (801bdb4 <USBD_MSC_GetDeviceQualifierDescriptor+0x8>)
 801bdb2:	4770      	bx	lr
 801bdb4:	200004a8 	.word	0x200004a8

0801bdb8 <USBD_MSC_Init>:
{
 801bdb8:	b538      	push	{r3, r4, r5, lr}
  if(pdev->dev_speed == USBD_SPEED_HIGH)
 801bdba:	7c03      	ldrb	r3, [r0, #16]
{
 801bdbc:	4604      	mov	r4, r0
  if(pdev->dev_speed == USBD_SPEED_HIGH)
 801bdbe:	b9e3      	cbnz	r3, 801bdfa <USBD_MSC_Init+0x42>
    USBD_LL_OpenEP(pdev, MSC_EPOUT_ADDR, USBD_EP_TYPE_BULK, MSC_MAX_HS_PACKET);
 801bdc0:	f44f 7300 	mov.w	r3, #512	; 0x200
 801bdc4:	2202      	movs	r2, #2
 801bdc6:	2101      	movs	r1, #1
    pdev->ep_out[MSC_EPOUT_ADDR & 0xFU].is_used = 1U;
 801bdc8:	2501      	movs	r5, #1
    USBD_LL_OpenEP(pdev, MSC_EPOUT_ADDR, USBD_EP_TYPE_BULK, MSC_MAX_HS_PACKET);
 801bdca:	f008 ff89 	bl	8024ce0 <USBD_LL_OpenEP>
    pdev->ep_out[MSC_EPOUT_ADDR & 0xFU].is_used = 1U;
 801bdce:	f8c4 5158 	str.w	r5, [r4, #344]	; 0x158
    USBD_LL_OpenEP(pdev, MSC_EPIN_ADDR, USBD_EP_TYPE_BULK, MSC_MAX_HS_PACKET);
 801bdd2:	f44f 7300 	mov.w	r3, #512	; 0x200
    USBD_LL_OpenEP(pdev, MSC_EPIN_ADDR, USBD_EP_TYPE_BULK, MSC_MAX_FS_PACKET);
 801bdd6:	2202      	movs	r2, #2
 801bdd8:	2181      	movs	r1, #129	; 0x81
 801bdda:	4620      	mov	r0, r4
 801bddc:	f008 ff80 	bl	8024ce0 <USBD_LL_OpenEP>
    pdev->ep_in[MSC_EPIN_ADDR & 0xFU].is_used = 1U;
 801bde0:	62e5      	str	r5, [r4, #44]	; 0x2c
  pdev->pClassData = USBD_malloc(sizeof (USBD_MSC_BOT_HandleTypeDef));
 801bde2:	f241 006c 	movw	r0, #4204	; 0x106c
 801bde6:	f00b fb7f 	bl	80274e8 <malloc>
 801bdea:	f8c4 0290 	str.w	r0, [r4, #656]	; 0x290
  if(pdev->pClassData == NULL)
 801bdee:	b170      	cbz	r0, 801be0e <USBD_MSC_Init+0x56>
  MSC_BOT_Init(pdev);
 801bdf0:	4620      	mov	r0, r4
 801bdf2:	f000 f917 	bl	801c024 <MSC_BOT_Init>
  return USBD_OK;
 801bdf6:	2000      	movs	r0, #0
}
 801bdf8:	bd38      	pop	{r3, r4, r5, pc}
    USBD_LL_OpenEP(pdev, MSC_EPOUT_ADDR, USBD_EP_TYPE_BULK, MSC_MAX_FS_PACKET);
 801bdfa:	2340      	movs	r3, #64	; 0x40
 801bdfc:	2202      	movs	r2, #2
 801bdfe:	2101      	movs	r1, #1
    pdev->ep_out[MSC_EPOUT_ADDR & 0xFU].is_used = 1U;
 801be00:	2501      	movs	r5, #1
    USBD_LL_OpenEP(pdev, MSC_EPOUT_ADDR, USBD_EP_TYPE_BULK, MSC_MAX_FS_PACKET);
 801be02:	f008 ff6d 	bl	8024ce0 <USBD_LL_OpenEP>
    pdev->ep_out[MSC_EPOUT_ADDR & 0xFU].is_used = 1U;
 801be06:	f8c4 5158 	str.w	r5, [r4, #344]	; 0x158
    USBD_LL_OpenEP(pdev, MSC_EPIN_ADDR, USBD_EP_TYPE_BULK, MSC_MAX_FS_PACKET);
 801be0a:	2340      	movs	r3, #64	; 0x40
 801be0c:	e7e3      	b.n	801bdd6 <USBD_MSC_Init+0x1e>
    return USBD_FAIL;
 801be0e:	2002      	movs	r0, #2
}
 801be10:	bd38      	pop	{r3, r4, r5, pc}
 801be12:	bf00      	nop

0801be14 <USBD_MSC_DeInit>:
{
 801be14:	b538      	push	{r3, r4, r5, lr}
 801be16:	4604      	mov	r4, r0
  USBD_LL_CloseEP(pdev, MSC_EPOUT_ADDR);
 801be18:	2101      	movs	r1, #1
  pdev->ep_out[MSC_EPOUT_ADDR & 0xFU].is_used = 0U;
 801be1a:	2500      	movs	r5, #0
  USBD_LL_CloseEP(pdev, MSC_EPOUT_ADDR);
 801be1c:	f008 ff6a 	bl	8024cf4 <USBD_LL_CloseEP>
  USBD_LL_CloseEP(pdev, MSC_EPIN_ADDR);
 801be20:	2181      	movs	r1, #129	; 0x81
  pdev->ep_out[MSC_EPOUT_ADDR & 0xFU].is_used = 0U;
 801be22:	f8c4 5158 	str.w	r5, [r4, #344]	; 0x158
  USBD_LL_CloseEP(pdev, MSC_EPIN_ADDR);
 801be26:	4620      	mov	r0, r4
 801be28:	f008 ff64 	bl	8024cf4 <USBD_LL_CloseEP>
  MSC_BOT_DeInit(pdev);
 801be2c:	4620      	mov	r0, r4
  pdev->ep_in[MSC_EPIN_ADDR & 0xFU].is_used = 0U;
 801be2e:	62e5      	str	r5, [r4, #44]	; 0x2c
  MSC_BOT_DeInit(pdev);
 801be30:	f000 f926 	bl	801c080 <MSC_BOT_DeInit>
  if(pdev->pClassData != NULL)
 801be34:	f8d4 0290 	ldr.w	r0, [r4, #656]	; 0x290
 801be38:	b118      	cbz	r0, 801be42 <USBD_MSC_DeInit+0x2e>
    USBD_free(pdev->pClassData);
 801be3a:	f00b fb5d 	bl	80274f8 <free>
    pdev->pClassData  = NULL;
 801be3e:	f8c4 5290 	str.w	r5, [r4, #656]	; 0x290
}
 801be42:	2000      	movs	r0, #0
 801be44:	bd38      	pop	{r3, r4, r5, pc}
 801be46:	bf00      	nop

0801be48 <USBD_MSC_Setup>:
{
 801be48:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  switch (req->bmRequest & USB_REQ_TYPE_MASK)
 801be4c:	780b      	ldrb	r3, [r1, #0]
  USBD_MSC_BOT_HandleTypeDef *hmsc = (USBD_MSC_BOT_HandleTypeDef*) pdev->pClassData;
 801be4e:	f8d0 7290 	ldr.w	r7, [r0, #656]	; 0x290
{
 801be52:	b082      	sub	sp, #8
  uint16_t status_info = 0U;
 801be54:	2200      	movs	r2, #0
  switch (req->bmRequest & USB_REQ_TYPE_MASK)
 801be56:	f013 0660 	ands.w	r6, r3, #96	; 0x60
{
 801be5a:	460c      	mov	r4, r1
 801be5c:	4605      	mov	r5, r0
  uint16_t status_info = 0U;
 801be5e:	f8ad 2006 	strh.w	r2, [sp, #6]
  switch (req->bmRequest & USB_REQ_TYPE_MASK)
 801be62:	d01f      	beq.n	801bea4 <USBD_MSC_Setup+0x5c>
 801be64:	2e20      	cmp	r6, #32
 801be66:	d114      	bne.n	801be92 <USBD_MSC_Setup+0x4a>
    switch (req->bRequest)
 801be68:	784a      	ldrb	r2, [r1, #1]
 801be6a:	2afe      	cmp	r2, #254	; 0xfe
 801be6c:	d00a      	beq.n	801be84 <USBD_MSC_Setup+0x3c>
 801be6e:	2aff      	cmp	r2, #255	; 0xff
 801be70:	d10f      	bne.n	801be92 <USBD_MSC_Setup+0x4a>
      if((req->wValue  == 0U) && (req->wLength == 0U) &&
 801be72:	884a      	ldrh	r2, [r1, #2]
 801be74:	b96a      	cbnz	r2, 801be92 <USBD_MSC_Setup+0x4a>
 801be76:	88ce      	ldrh	r6, [r1, #6]
 801be78:	b95e      	cbnz	r6, 801be92 <USBD_MSC_Setup+0x4a>
 801be7a:	061b      	lsls	r3, r3, #24
 801be7c:	d409      	bmi.n	801be92 <USBD_MSC_Setup+0x4a>
        MSC_BOT_Reset(pdev);
 801be7e:	f000 f8f1 	bl	801c064 <MSC_BOT_Reset>
 801be82:	e00b      	b.n	801be9c <USBD_MSC_Setup+0x54>
      if((req->wValue  == 0U) && (req->wLength == 1U) &&
 801be84:	884e      	ldrh	r6, [r1, #2]
 801be86:	b926      	cbnz	r6, 801be92 <USBD_MSC_Setup+0x4a>
 801be88:	f8b1 8006 	ldrh.w	r8, [r1, #6]
 801be8c:	f1b8 0f01 	cmp.w	r8, #1
 801be90:	d06a      	beq.n	801bf68 <USBD_MSC_Setup+0x120>
      USBD_CtlError(pdev , req);
 801be92:	4621      	mov	r1, r4
 801be94:	4628      	mov	r0, r5
 801be96:	f001 fa05 	bl	801d2a4 <USBD_CtlError>
      ret = USBD_FAIL;
 801be9a:	2602      	movs	r6, #2
}
 801be9c:	4630      	mov	r0, r6
 801be9e:	b002      	add	sp, #8
 801bea0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    switch (req->bRequest)
 801bea4:	f891 8001 	ldrb.w	r8, [r1, #1]
 801bea8:	f1b8 0f0b 	cmp.w	r8, #11
 801beac:	d8f1      	bhi.n	801be92 <USBD_MSC_Setup+0x4a>
 801beae:	a301      	add	r3, pc, #4	; (adr r3, 801beb4 <USBD_MSC_Setup+0x6c>)
 801beb0:	f853 f028 	ldr.w	pc, [r3, r8, lsl #2]
 801beb4:	0801bef3 	.word	0x0801bef3
 801beb8:	0801bf1b 	.word	0x0801bf1b
 801bebc:	0801be93 	.word	0x0801be93
 801bec0:	0801be93 	.word	0x0801be93
 801bec4:	0801be93 	.word	0x0801be93
 801bec8:	0801be93 	.word	0x0801be93
 801becc:	0801be93 	.word	0x0801be93
 801bed0:	0801be93 	.word	0x0801be93
 801bed4:	0801be93 	.word	0x0801be93
 801bed8:	0801be93 	.word	0x0801be93
 801bedc:	0801bf09 	.word	0x0801bf09
 801bee0:	0801bee5 	.word	0x0801bee5
      if (pdev->dev_state == USBD_STATE_CONFIGURED)
 801bee4:	f890 3274 	ldrb.w	r3, [r0, #628]	; 0x274
 801bee8:	2b03      	cmp	r3, #3
 801beea:	d1d2      	bne.n	801be92 <USBD_MSC_Setup+0x4a>
        hmsc->interface = (uint8_t)(req->wValue);
 801beec:	788b      	ldrb	r3, [r1, #2]
 801beee:	607b      	str	r3, [r7, #4]
 801bef0:	e7d4      	b.n	801be9c <USBD_MSC_Setup+0x54>
      if (pdev->dev_state == USBD_STATE_CONFIGURED)
 801bef2:	f890 3274 	ldrb.w	r3, [r0, #628]	; 0x274
 801bef6:	2b03      	cmp	r3, #3
 801bef8:	d1cb      	bne.n	801be92 <USBD_MSC_Setup+0x4a>
        USBD_CtlSendData (pdev, (uint8_t *)(void *)&status_info, 2U);
 801befa:	2202      	movs	r2, #2
 801befc:	f10d 0106 	add.w	r1, sp, #6
 801bf00:	f001 fa06 	bl	801d310 <USBD_CtlSendData>
  uint8_t ret = USBD_OK;
 801bf04:	4646      	mov	r6, r8
 801bf06:	e7c9      	b.n	801be9c <USBD_MSC_Setup+0x54>
      if (pdev->dev_state == USBD_STATE_CONFIGURED)
 801bf08:	f890 3274 	ldrb.w	r3, [r0, #628]	; 0x274
 801bf0c:	2b03      	cmp	r3, #3
 801bf0e:	d1c0      	bne.n	801be92 <USBD_MSC_Setup+0x4a>
        USBD_CtlSendData (pdev, (uint8_t *)(void *)&hmsc->interface, 1U);
 801bf10:	2201      	movs	r2, #1
 801bf12:	1d39      	adds	r1, r7, #4
 801bf14:	f001 f9fc 	bl	801d310 <USBD_CtlSendData>
 801bf18:	e7c0      	b.n	801be9c <USBD_MSC_Setup+0x54>
      USBD_LL_FlushEP(pdev, (uint8_t)req->wIndex);
 801bf1a:	7909      	ldrb	r1, [r1, #4]
 801bf1c:	f008 fef2 	bl	8024d04 <USBD_LL_FlushEP>
      USBD_LL_CloseEP (pdev , (uint8_t)req->wIndex);
 801bf20:	7921      	ldrb	r1, [r4, #4]
 801bf22:	4628      	mov	r0, r5
 801bf24:	f008 fee6 	bl	8024cf4 <USBD_LL_CloseEP>
      if((((uint8_t)req->wIndex) & 0x80U) == 0x80U)
 801bf28:	88a3      	ldrh	r3, [r4, #4]
 801bf2a:	f994 2004 	ldrsb.w	r2, [r4, #4]
        pdev->ep_in[(uint8_t)req->wIndex & 0xFU].is_used = 0U;
 801bf2e:	f003 030f 	and.w	r3, r3, #15
 801bf32:	eb03 0383 	add.w	r3, r3, r3, lsl #2
      if((((uint8_t)req->wIndex) & 0x80U) == 0x80U)
 801bf36:	2a00      	cmp	r2, #0
        pdev->ep_in[(uint8_t)req->wIndex & 0xFU].is_used = 0U;
 801bf38:	eb05 0383 	add.w	r3, r5, r3, lsl #2
 801bf3c:	f04f 0200 	mov.w	r2, #0
      if((((uint8_t)req->wIndex) & 0x80U) == 0x80U)
 801bf40:	db1f      	blt.n	801bf82 <USBD_MSC_Setup+0x13a>
        pdev->ep_out[(uint8_t)req->wIndex & 0xFU].is_used = 0U;
 801bf42:	f8c3 2144 	str.w	r2, [r3, #324]	; 0x144
        if(pdev->dev_speed == USBD_SPEED_HIGH)
 801bf46:	7c2b      	ldrb	r3, [r5, #16]
 801bf48:	bb43      	cbnz	r3, 801bf9c <USBD_MSC_Setup+0x154>
          USBD_LL_OpenEP(pdev, MSC_EPOUT_ADDR, USBD_EP_TYPE_BULK,
 801bf4a:	f44f 7300 	mov.w	r3, #512	; 0x200
 801bf4e:	2202      	movs	r2, #2
 801bf50:	2101      	movs	r1, #1
 801bf52:	4628      	mov	r0, r5
 801bf54:	f008 fec4 	bl	8024ce0 <USBD_LL_OpenEP>
        pdev->ep_out[MSC_EPOUT_ADDR & 0xFU].is_used = 1U;
 801bf58:	2301      	movs	r3, #1
 801bf5a:	f8c5 3158 	str.w	r3, [r5, #344]	; 0x158
      MSC_BOT_CplClrFeature(pdev, (uint8_t)req->wIndex);
 801bf5e:	7921      	ldrb	r1, [r4, #4]
 801bf60:	4628      	mov	r0, r5
 801bf62:	f000 f9a1 	bl	801c2a8 <MSC_BOT_CplClrFeature>
      break;
 801bf66:	e799      	b.n	801be9c <USBD_MSC_Setup+0x54>
      if((req->wValue  == 0U) && (req->wLength == 1U) &&
 801bf68:	061a      	lsls	r2, r3, #24
 801bf6a:	d592      	bpl.n	801be92 <USBD_MSC_Setup+0x4a>
        hmsc->max_lun = (uint32_t)((USBD_StorageTypeDef *)pdev->pUserData)->GetMaxLun();
 801bf6c:	f8d0 3294 	ldr.w	r3, [r0, #660]	; 0x294
 801bf70:	699b      	ldr	r3, [r3, #24]
 801bf72:	4798      	blx	r3
        USBD_CtlSendData (pdev, (uint8_t *)(void *)&hmsc->max_lun, 1U);
 801bf74:	4642      	mov	r2, r8
        hmsc->max_lun = (uint32_t)((USBD_StorageTypeDef *)pdev->pUserData)->GetMaxLun();
 801bf76:	6038      	str	r0, [r7, #0]
        USBD_CtlSendData (pdev, (uint8_t *)(void *)&hmsc->max_lun, 1U);
 801bf78:	4639      	mov	r1, r7
 801bf7a:	4628      	mov	r0, r5
 801bf7c:	f001 f9c8 	bl	801d310 <USBD_CtlSendData>
 801bf80:	e78c      	b.n	801be9c <USBD_MSC_Setup+0x54>
        pdev->ep_in[(uint8_t)req->wIndex & 0xFU].is_used = 0U;
 801bf82:	619a      	str	r2, [r3, #24]
        if(pdev->dev_speed == USBD_SPEED_HIGH)
 801bf84:	7c2b      	ldrb	r3, [r5, #16]
 801bf86:	b983      	cbnz	r3, 801bfaa <USBD_MSC_Setup+0x162>
          USBD_LL_OpenEP(pdev, MSC_EPIN_ADDR, USBD_EP_TYPE_BULK,
 801bf88:	f44f 7300 	mov.w	r3, #512	; 0x200
 801bf8c:	2202      	movs	r2, #2
 801bf8e:	2181      	movs	r1, #129	; 0x81
 801bf90:	4628      	mov	r0, r5
 801bf92:	f008 fea5 	bl	8024ce0 <USBD_LL_OpenEP>
        pdev->ep_in[MSC_EPIN_ADDR & 0xFU].is_used = 1U;
 801bf96:	2301      	movs	r3, #1
 801bf98:	62eb      	str	r3, [r5, #44]	; 0x2c
 801bf9a:	e7e0      	b.n	801bf5e <USBD_MSC_Setup+0x116>
          USBD_LL_OpenEP(pdev, MSC_EPOUT_ADDR, USBD_EP_TYPE_BULK,
 801bf9c:	2340      	movs	r3, #64	; 0x40
 801bf9e:	2202      	movs	r2, #2
 801bfa0:	2101      	movs	r1, #1
 801bfa2:	4628      	mov	r0, r5
 801bfa4:	f008 fe9c 	bl	8024ce0 <USBD_LL_OpenEP>
 801bfa8:	e7d6      	b.n	801bf58 <USBD_MSC_Setup+0x110>
          USBD_LL_OpenEP(pdev, MSC_EPIN_ADDR, USBD_EP_TYPE_BULK,
 801bfaa:	2340      	movs	r3, #64	; 0x40
 801bfac:	2202      	movs	r2, #2
 801bfae:	2181      	movs	r1, #129	; 0x81
 801bfb0:	4628      	mov	r0, r5
 801bfb2:	f008 fe95 	bl	8024ce0 <USBD_LL_OpenEP>
 801bfb6:	e7ee      	b.n	801bf96 <USBD_MSC_Setup+0x14e>

0801bfb8 <USBD_MSC_DataIn>:
{
 801bfb8:	b508      	push	{r3, lr}
  MSC_BOT_DataIn(pdev , epnum);
 801bfba:	f000 f867 	bl	801c08c <MSC_BOT_DataIn>
}
 801bfbe:	2000      	movs	r0, #0
 801bfc0:	bd08      	pop	{r3, pc}
 801bfc2:	bf00      	nop

0801bfc4 <USBD_MSC_DataOut>:
{
 801bfc4:	b508      	push	{r3, lr}
  MSC_BOT_DataOut(pdev , epnum);
 801bfc6:	f000 f8a3 	bl	801c110 <MSC_BOT_DataOut>
}
 801bfca:	2000      	movs	r0, #0
 801bfcc:	bd08      	pop	{r3, pc}
 801bfce:	bf00      	nop

0801bfd0 <USBD_MSC_RegisterStorage>:
* @retval status
*/
uint8_t  USBD_MSC_RegisterStorage  (USBD_HandleTypeDef   *pdev,
                                    USBD_StorageTypeDef *fops)
{
  if(fops != NULL)
 801bfd0:	b109      	cbz	r1, 801bfd6 <USBD_MSC_RegisterStorage+0x6>
  {
    pdev->pUserData = fops;
 801bfd2:	f8c0 1294 	str.w	r1, [r0, #660]	; 0x294
  }
  return USBD_OK;
}
 801bfd6:	2000      	movs	r0, #0
 801bfd8:	4770      	bx	lr
 801bfda:	bf00      	nop

0801bfdc <MSC_BOT_Abort>:
* @param  pdev: device instance
* @retval status
*/

static void  MSC_BOT_Abort (USBD_HandleTypeDef  *pdev)
{
 801bfdc:	b570      	push	{r4, r5, r6, lr}
  USBD_MSC_BOT_HandleTypeDef  *hmsc = (USBD_MSC_BOT_HandleTypeDef*)pdev->pClassData;
 801bfde:	f8d0 5290 	ldr.w	r5, [r0, #656]	; 0x290

  if ((hmsc->cbw.bmFlags == 0U) &&
 801bfe2:	f505 5380 	add.w	r3, r5, #4096	; 0x1000
{
 801bfe6:	4604      	mov	r4, r0
  if ((hmsc->cbw.bmFlags == 0U) &&
 801bfe8:	7e1a      	ldrb	r2, [r3, #24]
 801bfea:	b90a      	cbnz	r2, 801bff0 <MSC_BOT_Abort+0x14>
 801bfec:	695b      	ldr	r3, [r3, #20]
 801bfee:	b93b      	cbnz	r3, 801c000 <MSC_BOT_Abort+0x24>
      (hmsc->bot_status == USBD_BOT_STATUS_NORMAL))
  {
    USBD_LL_StallEP(pdev, MSC_EPOUT_ADDR );
  }

  USBD_LL_StallEP(pdev, MSC_EPIN_ADDR);
 801bff0:	2181      	movs	r1, #129	; 0x81
 801bff2:	4620      	mov	r0, r4
 801bff4:	f008 fe8e 	bl	8024d14 <USBD_LL_StallEP>

  if(hmsc->bot_status == USBD_BOT_STATUS_ERROR)
 801bff8:	7a6b      	ldrb	r3, [r5, #9]
 801bffa:	2b02      	cmp	r3, #2
 801bffc:	d007      	beq.n	801c00e <MSC_BOT_Abort+0x32>
  {
    USBD_LL_PrepareReceive (pdev, MSC_EPOUT_ADDR, (uint8_t *)(void *)&hmsc->cbw,
                            USBD_BOT_CBW_LENGTH);
  }
}
 801bffe:	bd70      	pop	{r4, r5, r6, pc}
      (hmsc->cbw.dDataLength != 0U) &&
 801c000:	7a6b      	ldrb	r3, [r5, #9]
 801c002:	2b00      	cmp	r3, #0
 801c004:	d1f4      	bne.n	801bff0 <MSC_BOT_Abort+0x14>
    USBD_LL_StallEP(pdev, MSC_EPOUT_ADDR );
 801c006:	2101      	movs	r1, #1
 801c008:	f008 fe84 	bl	8024d14 <USBD_LL_StallEP>
 801c00c:	e7f0      	b.n	801bff0 <MSC_BOT_Abort+0x14>
    USBD_LL_PrepareReceive (pdev, MSC_EPOUT_ADDR, (uint8_t *)(void *)&hmsc->cbw,
 801c00e:	f505 5280 	add.w	r2, r5, #4096	; 0x1000
 801c012:	4620      	mov	r0, r4
 801c014:	231f      	movs	r3, #31
}
 801c016:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    USBD_LL_PrepareReceive (pdev, MSC_EPOUT_ADDR, (uint8_t *)(void *)&hmsc->cbw,
 801c01a:	320c      	adds	r2, #12
 801c01c:	2101      	movs	r1, #1
 801c01e:	f008 bead 	b.w	8024d7c <USBD_LL_PrepareReceive>
 801c022:	bf00      	nop

0801c024 <MSC_BOT_Init>:
{
 801c024:	b570      	push	{r4, r5, r6, lr}
 801c026:	4604      	mov	r4, r0
  hmsc->bot_state = USBD_BOT_IDLE;
 801c028:	2000      	movs	r0, #0
  USBD_MSC_BOT_HandleTypeDef  *hmsc = (USBD_MSC_BOT_HandleTypeDef*)pdev->pClassData;
 801c02a:	f8d4 5290 	ldr.w	r5, [r4, #656]	; 0x290
  hmsc->scsi_sense_head = 0U;
 801c02e:	f505 5380 	add.w	r3, r5, #4096	; 0x1000
  hmsc->bot_state = USBD_BOT_IDLE;
 801c032:	8128      	strh	r0, [r5, #8]
  hmsc->scsi_sense_head = 0U;
 801c034:	f8a3 005c 	strh.w	r0, [r3, #92]	; 0x5c
  ((USBD_StorageTypeDef *)pdev->pUserData)->Init(0U);
 801c038:	f8d4 3294 	ldr.w	r3, [r4, #660]	; 0x294
 801c03c:	681b      	ldr	r3, [r3, #0]
 801c03e:	4798      	blx	r3
  USBD_LL_FlushEP(pdev, MSC_EPOUT_ADDR);
 801c040:	2101      	movs	r1, #1
 801c042:	4620      	mov	r0, r4
 801c044:	f008 fe5e 	bl	8024d04 <USBD_LL_FlushEP>
  USBD_LL_FlushEP(pdev, MSC_EPIN_ADDR);
 801c048:	2181      	movs	r1, #129	; 0x81
 801c04a:	4620      	mov	r0, r4
 801c04c:	f008 fe5a 	bl	8024d04 <USBD_LL_FlushEP>
  USBD_LL_PrepareReceive (pdev, MSC_EPOUT_ADDR, (uint8_t *)(void *)&hmsc->cbw,
 801c050:	f505 5280 	add.w	r2, r5, #4096	; 0x1000
 801c054:	4620      	mov	r0, r4
 801c056:	231f      	movs	r3, #31
}
 801c058:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
  USBD_LL_PrepareReceive (pdev, MSC_EPOUT_ADDR, (uint8_t *)(void *)&hmsc->cbw,
 801c05c:	320c      	adds	r2, #12
 801c05e:	2101      	movs	r1, #1
 801c060:	f008 be8c 	b.w	8024d7c <USBD_LL_PrepareReceive>

0801c064 <MSC_BOT_Reset>:
  USBD_MSC_BOT_HandleTypeDef  *hmsc = (USBD_MSC_BOT_HandleTypeDef*)pdev->pClassData;
 801c064:	f8d0 1290 	ldr.w	r1, [r0, #656]	; 0x290
  hmsc->bot_state  = USBD_BOT_IDLE;
 801c068:	f44f 7c80 	mov.w	ip, #256	; 0x100
  USBD_LL_PrepareReceive (pdev, MSC_EPOUT_ADDR, (uint8_t *)(void *)&hmsc->cbw,
 801c06c:	f501 5280 	add.w	r2, r1, #4096	; 0x1000
  hmsc->bot_state  = USBD_BOT_IDLE;
 801c070:	f8a1 c008 	strh.w	ip, [r1, #8]
  USBD_LL_PrepareReceive (pdev, MSC_EPOUT_ADDR, (uint8_t *)(void *)&hmsc->cbw,
 801c074:	231f      	movs	r3, #31
 801c076:	320c      	adds	r2, #12
 801c078:	2101      	movs	r1, #1
 801c07a:	f008 be7f 	b.w	8024d7c <USBD_LL_PrepareReceive>
 801c07e:	bf00      	nop

0801c080 <MSC_BOT_DeInit>:
  hmsc->bot_state  = USBD_BOT_IDLE;
 801c080:	f8d0 3290 	ldr.w	r3, [r0, #656]	; 0x290
 801c084:	2200      	movs	r2, #0
 801c086:	721a      	strb	r2, [r3, #8]
}
 801c088:	4770      	bx	lr
 801c08a:	bf00      	nop

0801c08c <MSC_BOT_DataIn>:
{
 801c08c:	b570      	push	{r4, r5, r6, lr}
  USBD_MSC_BOT_HandleTypeDef  *hmsc = (USBD_MSC_BOT_HandleTypeDef*)pdev->pClassData;
 801c08e:	f8d0 4290 	ldr.w	r4, [r0, #656]	; 0x290
  switch (hmsc->bot_state)
 801c092:	7a23      	ldrb	r3, [r4, #8]
 801c094:	2b02      	cmp	r3, #2
{
 801c096:	4605      	mov	r5, r0
  switch (hmsc->bot_state)
 801c098:	d01b      	beq.n	801c0d2 <MSC_BOT_DataIn+0x46>
 801c09a:	3b03      	subs	r3, #3
 801c09c:	2b01      	cmp	r3, #1
 801c09e:	d821      	bhi.n	801c0e4 <MSC_BOT_DataIn+0x58>
  hmsc->csw.dSignature = USBD_BOT_CSW_SIGNATURE;
 801c0a0:	f504 5380 	add.w	r3, r4, #4096	; 0x1000
 801c0a4:	4a19      	ldr	r2, [pc, #100]	; (801c10c <MSC_BOT_DataIn+0x80>)
 801c0a6:	62da      	str	r2, [r3, #44]	; 0x2c
  hmsc->csw.bStatus = CSW_Status;
 801c0a8:	2200      	movs	r2, #0
 801c0aa:	f883 2038 	strb.w	r2, [r3, #56]	; 0x38
  hmsc->bot_state = USBD_BOT_IDLE;
 801c0ae:	7222      	strb	r2, [r4, #8]
  USBD_LL_Transmit (pdev, MSC_EPIN_ADDR, (uint8_t *)(void *)&hmsc->csw,
 801c0b0:	f504 5281 	add.w	r2, r4, #4128	; 0x1020
 801c0b4:	230d      	movs	r3, #13
 801c0b6:	320c      	adds	r2, #12
 801c0b8:	2181      	movs	r1, #129	; 0x81
 801c0ba:	f008 fe57 	bl	8024d6c <USBD_LL_Transmit>
  USBD_LL_PrepareReceive (pdev, MSC_EPOUT_ADDR, (uint8_t *)(void *)&hmsc->cbw,
 801c0be:	f504 5280 	add.w	r2, r4, #4096	; 0x1000
 801c0c2:	4628      	mov	r0, r5
 801c0c4:	231f      	movs	r3, #31
}
 801c0c6:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
  USBD_LL_PrepareReceive (pdev, MSC_EPOUT_ADDR, (uint8_t *)(void *)&hmsc->cbw,
 801c0ca:	320c      	adds	r2, #12
 801c0cc:	2101      	movs	r1, #1
 801c0ce:	f008 be55 	b.w	8024d7c <USBD_LL_PrepareReceive>
    if(SCSI_ProcessCmd(pdev,
 801c0d2:	f504 5380 	add.w	r3, r4, #4096	; 0x1000
 801c0d6:	461a      	mov	r2, r3
 801c0d8:	7e59      	ldrb	r1, [r3, #25]
 801c0da:	321b      	adds	r2, #27
 801c0dc:	f000 f912 	bl	801c304 <SCSI_ProcessCmd>
 801c0e0:	2800      	cmp	r0, #0
 801c0e2:	db00      	blt.n	801c0e6 <MSC_BOT_DataIn+0x5a>
}
 801c0e4:	bd70      	pop	{r4, r5, r6, pc}
  USBD_MSC_BOT_HandleTypeDef  *hmsc = (USBD_MSC_BOT_HandleTypeDef*)pdev->pClassData;
 801c0e6:	f8d5 4290 	ldr.w	r4, [r5, #656]	; 0x290
  hmsc->csw.dSignature = USBD_BOT_CSW_SIGNATURE;
 801c0ea:	4a08      	ldr	r2, [pc, #32]	; (801c10c <MSC_BOT_DataIn+0x80>)
 801c0ec:	f504 5380 	add.w	r3, r4, #4096	; 0x1000
  hmsc->csw.bStatus = CSW_Status;
 801c0f0:	2601      	movs	r6, #1
  hmsc->csw.dSignature = USBD_BOT_CSW_SIGNATURE;
 801c0f2:	62da      	str	r2, [r3, #44]	; 0x2c
  hmsc->bot_state = USBD_BOT_IDLE;
 801c0f4:	2200      	movs	r2, #0
  hmsc->csw.bStatus = CSW_Status;
 801c0f6:	f883 6038 	strb.w	r6, [r3, #56]	; 0x38
  hmsc->bot_state = USBD_BOT_IDLE;
 801c0fa:	7222      	strb	r2, [r4, #8]
  USBD_LL_Transmit (pdev, MSC_EPIN_ADDR, (uint8_t *)(void *)&hmsc->csw,
 801c0fc:	f504 5281 	add.w	r2, r4, #4128	; 0x1020
 801c100:	230d      	movs	r3, #13
 801c102:	320c      	adds	r2, #12
 801c104:	2181      	movs	r1, #129	; 0x81
 801c106:	4628      	mov	r0, r5
 801c108:	e7d7      	b.n	801c0ba <MSC_BOT_DataIn+0x2e>
 801c10a:	bf00      	nop
 801c10c:	53425355 	.word	0x53425355

0801c110 <MSC_BOT_DataOut>:
{
 801c110:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  USBD_MSC_BOT_HandleTypeDef  *hmsc = (USBD_MSC_BOT_HandleTypeDef*)pdev->pClassData;
 801c114:	f8d0 5290 	ldr.w	r5, [r0, #656]	; 0x290
  switch (hmsc->bot_state)
 801c118:	7a2f      	ldrb	r7, [r5, #8]
{
 801c11a:	4604      	mov	r4, r0
  switch (hmsc->bot_state)
 801c11c:	b167      	cbz	r7, 801c138 <MSC_BOT_DataOut+0x28>
 801c11e:	2f01      	cmp	r7, #1
 801c120:	d108      	bne.n	801c134 <MSC_BOT_DataOut+0x24>
    if(SCSI_ProcessCmd(pdev,
 801c122:	f505 5380 	add.w	r3, r5, #4096	; 0x1000
 801c126:	461a      	mov	r2, r3
 801c128:	7e59      	ldrb	r1, [r3, #25]
 801c12a:	321b      	adds	r2, #27
 801c12c:	f000 f8ea 	bl	801c304 <SCSI_ProcessCmd>
 801c130:	2800      	cmp	r0, #0
 801c132:	db20      	blt.n	801c176 <MSC_BOT_DataOut+0x66>
}
 801c134:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  hmsc->csw.dTag = hmsc->cbw.dTag;
 801c138:	f505 5680 	add.w	r6, r5, #4096	; 0x1000
  if ((USBD_LL_GetRxDataSize (pdev ,MSC_EPOUT_ADDR) != USBD_BOT_CBW_LENGTH) ||
 801c13c:	2101      	movs	r1, #1
  hmsc->csw.dTag = hmsc->cbw.dTag;
 801c13e:	6933      	ldr	r3, [r6, #16]
 801c140:	6333      	str	r3, [r6, #48]	; 0x30
  hmsc->csw.dDataResidue = hmsc->cbw.dDataLength;
 801c142:	6973      	ldr	r3, [r6, #20]
 801c144:	6373      	str	r3, [r6, #52]	; 0x34
  if ((USBD_LL_GetRxDataSize (pdev ,MSC_EPOUT_ADDR) != USBD_BOT_CBW_LENGTH) ||
 801c146:	f008 fe21 	bl	8024d8c <USBD_LL_GetRxDataSize>
 801c14a:	281f      	cmp	r0, #31
 801c14c:	4680      	mov	r8, r0
 801c14e:	d110      	bne.n	801c172 <MSC_BOT_DataOut+0x62>
 801c150:	4b43      	ldr	r3, [pc, #268]	; (801c260 <MSC_BOT_DataOut+0x150>)
 801c152:	68f2      	ldr	r2, [r6, #12]
        (hmsc->cbw.bLUN > 1U) ||
 801c154:	7e71      	ldrb	r1, [r6, #25]
  if ((USBD_LL_GetRxDataSize (pdev ,MSC_EPOUT_ADDR) != USBD_BOT_CBW_LENGTH) ||
 801c156:	429a      	cmp	r2, r3
 801c158:	d029      	beq.n	801c1ae <MSC_BOT_DataOut+0x9e>
    SCSI_SenseCode(pdev, hmsc->cbw.bLUN, ILLEGAL_REQUEST, INVALID_CDB);
 801c15a:	4620      	mov	r0, r4
 801c15c:	2320      	movs	r3, #32
 801c15e:	2205      	movs	r2, #5
 801c160:	f000 fca8 	bl	801cab4 <SCSI_SenseCode>
    hmsc->bot_status = USBD_BOT_STATUS_ERROR;
 801c164:	2302      	movs	r3, #2
 801c166:	726b      	strb	r3, [r5, #9]
    MSC_BOT_Abort(pdev);
 801c168:	4620      	mov	r0, r4
}
 801c16a:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    MSC_BOT_Abort(pdev);
 801c16e:	f7ff bf35 	b.w	801bfdc <MSC_BOT_Abort>
        (hmsc->cbw.bLUN > 1U) ||
 801c172:	7e71      	ldrb	r1, [r6, #25]
 801c174:	e7f1      	b.n	801c15a <MSC_BOT_DataOut+0x4a>
  USBD_MSC_BOT_HandleTypeDef  *hmsc = (USBD_MSC_BOT_HandleTypeDef*)pdev->pClassData;
 801c176:	f8d4 5290 	ldr.w	r5, [r4, #656]	; 0x290
  hmsc->csw.dSignature = USBD_BOT_CSW_SIGNATURE;
 801c17a:	4a3a      	ldr	r2, [pc, #232]	; (801c264 <MSC_BOT_DataOut+0x154>)
 801c17c:	f505 5380 	add.w	r3, r5, #4096	; 0x1000
  USBD_LL_Transmit (pdev, MSC_EPIN_ADDR, (uint8_t *)(void *)&hmsc->csw,
 801c180:	2181      	movs	r1, #129	; 0x81
  hmsc->csw.dSignature = USBD_BOT_CSW_SIGNATURE;
 801c182:	62da      	str	r2, [r3, #44]	; 0x2c
  hmsc->bot_state = USBD_BOT_IDLE;
 801c184:	2200      	movs	r2, #0
  hmsc->csw.bStatus = CSW_Status;
 801c186:	f883 7038 	strb.w	r7, [r3, #56]	; 0x38
  hmsc->bot_state = USBD_BOT_IDLE;
 801c18a:	722a      	strb	r2, [r5, #8]
  USBD_LL_Transmit (pdev, MSC_EPIN_ADDR, (uint8_t *)(void *)&hmsc->csw,
 801c18c:	f505 5281 	add.w	r2, r5, #4128	; 0x1020
 801c190:	230d      	movs	r3, #13
 801c192:	320c      	adds	r2, #12
 801c194:	4620      	mov	r0, r4
 801c196:	f008 fde9 	bl	8024d6c <USBD_LL_Transmit>
  USBD_LL_PrepareReceive (pdev, MSC_EPOUT_ADDR, (uint8_t *)(void *)&hmsc->cbw,
 801c19a:	f505 5280 	add.w	r2, r5, #4096	; 0x1000
 801c19e:	231f      	movs	r3, #31
 801c1a0:	4620      	mov	r0, r4
 801c1a2:	320c      	adds	r2, #12
}
 801c1a4:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
  USBD_LL_PrepareReceive (pdev, MSC_EPOUT_ADDR, (uint8_t *)(void *)&hmsc->cbw,
 801c1a8:	2101      	movs	r1, #1
 801c1aa:	f008 bde7 	b.w	8024d7c <USBD_LL_PrepareReceive>
      (hmsc->cbw.dSignature != USBD_BOT_CBW_SIGNATURE) ||
 801c1ae:	2901      	cmp	r1, #1
 801c1b0:	d8d3      	bhi.n	801c15a <MSC_BOT_DataOut+0x4a>
        (hmsc->cbw.bLUN > 1U) ||
 801c1b2:	7eb3      	ldrb	r3, [r6, #26]
 801c1b4:	3b01      	subs	r3, #1
 801c1b6:	2b0f      	cmp	r3, #15
 801c1b8:	d8cf      	bhi.n	801c15a <MSC_BOT_DataOut+0x4a>
    if(SCSI_ProcessCmd(pdev, hmsc->cbw.bLUN, &hmsc->cbw.CB[0]) < 0)
 801c1ba:	f505 5280 	add.w	r2, r5, #4096	; 0x1000
 801c1be:	321b      	adds	r2, #27
 801c1c0:	4620      	mov	r0, r4
 801c1c2:	f000 f89f 	bl	801c304 <SCSI_ProcessCmd>
 801c1c6:	2800      	cmp	r0, #0
      if(hmsc->bot_state == USBD_BOT_NO_DATA)
 801c1c8:	7a2b      	ldrb	r3, [r5, #8]
    if(SCSI_ProcessCmd(pdev, hmsc->cbw.bLUN, &hmsc->cbw.CB[0]) < 0)
 801c1ca:	db1d      	blt.n	801c208 <MSC_BOT_DataOut+0xf8>
    else if ((hmsc->bot_state != USBD_BOT_DATA_IN) &&
 801c1cc:	3b01      	subs	r3, #1
 801c1ce:	2b02      	cmp	r3, #2
 801c1d0:	d9b0      	bls.n	801c134 <MSC_BOT_DataOut+0x24>
      if (hmsc->bot_data_length > 0U)
 801c1d2:	896b      	ldrh	r3, [r5, #10]
 801c1d4:	b1fb      	cbz	r3, 801c216 <MSC_BOT_DataOut+0x106>
  USBD_MSC_BOT_HandleTypeDef  *hmsc = (USBD_MSC_BOT_HandleTypeDef*)pdev->pClassData;
 801c1d6:	f8d4 6290 	ldr.w	r6, [r4, #656]	; 0x290
  uint16_t length = (uint16_t)MIN(hmsc->cbw.dDataLength, len);
 801c1da:	f506 5180 	add.w	r1, r6, #4096	; 0x1000
 801c1de:	461f      	mov	r7, r3
 801c1e0:	6948      	ldr	r0, [r1, #20]
 801c1e2:	4298      	cmp	r0, r3
 801c1e4:	bf38      	it	cc
 801c1e6:	b283      	uxthcc	r3, r0
  USBD_LL_Transmit(pdev, MSC_EPIN_ADDR, pbuf, length);
 801c1e8:	4620      	mov	r0, r4
  hmsc->csw.dDataResidue -= len;
 801c1ea:	6b4c      	ldr	r4, [r1, #52]	; 0x34
 801c1ec:	1be4      	subs	r4, r4, r7
 801c1ee:	634c      	str	r4, [r1, #52]	; 0x34
  hmsc->csw.bStatus = USBD_CSW_CMD_PASSED;
 801c1f0:	2400      	movs	r4, #0
 801c1f2:	f881 4038 	strb.w	r4, [r1, #56]	; 0x38
  hmsc->bot_state = USBD_BOT_SEND_DATA;
 801c1f6:	2104      	movs	r1, #4
 801c1f8:	7231      	strb	r1, [r6, #8]
        MSC_BOT_SendData(pdev, hmsc->bot_data, hmsc->bot_data_length);
 801c1fa:	f105 020c 	add.w	r2, r5, #12
  USBD_LL_Transmit(pdev, MSC_EPIN_ADDR, pbuf, length);
 801c1fe:	2181      	movs	r1, #129	; 0x81
}
 801c200:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
  USBD_LL_Transmit(pdev, MSC_EPIN_ADDR, pbuf, length);
 801c204:	f008 bdb2 	b.w	8024d6c <USBD_LL_Transmit>
      if(hmsc->bot_state == USBD_BOT_NO_DATA)
 801c208:	2b05      	cmp	r3, #5
 801c20a:	d019      	beq.n	801c240 <MSC_BOT_DataOut+0x130>
        MSC_BOT_Abort(pdev);
 801c20c:	4620      	mov	r0, r4
}
 801c20e:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
        MSC_BOT_Abort(pdev);
 801c212:	f7ff bee3 	b.w	801bfdc <MSC_BOT_Abort>
  USBD_MSC_BOT_HandleTypeDef  *hmsc = (USBD_MSC_BOT_HandleTypeDef*)pdev->pClassData;
 801c216:	f8d4 5290 	ldr.w	r5, [r4, #656]	; 0x290
  hmsc->csw.dSignature = USBD_BOT_CSW_SIGNATURE;
 801c21a:	4912      	ldr	r1, [pc, #72]	; (801c264 <MSC_BOT_DataOut+0x154>)
 801c21c:	f505 5280 	add.w	r2, r5, #4096	; 0x1000
  hmsc->csw.bStatus = CSW_Status;
 801c220:	f882 3038 	strb.w	r3, [r2, #56]	; 0x38
  hmsc->csw.dSignature = USBD_BOT_CSW_SIGNATURE;
 801c224:	62d1      	str	r1, [r2, #44]	; 0x2c
  USBD_LL_Transmit (pdev, MSC_EPIN_ADDR, (uint8_t *)(void *)&hmsc->csw,
 801c226:	f505 5281 	add.w	r2, r5, #4128	; 0x1020
  hmsc->bot_state = USBD_BOT_IDLE;
 801c22a:	722b      	strb	r3, [r5, #8]
  USBD_LL_Transmit (pdev, MSC_EPIN_ADDR, (uint8_t *)(void *)&hmsc->csw,
 801c22c:	320c      	adds	r2, #12
 801c22e:	230d      	movs	r3, #13
 801c230:	2181      	movs	r1, #129	; 0x81
 801c232:	4620      	mov	r0, r4
 801c234:	f008 fd9a 	bl	8024d6c <USBD_LL_Transmit>
  USBD_LL_PrepareReceive (pdev, MSC_EPOUT_ADDR, (uint8_t *)(void *)&hmsc->cbw,
 801c238:	4643      	mov	r3, r8
 801c23a:	f505 5280 	add.w	r2, r5, #4096	; 0x1000
 801c23e:	e7af      	b.n	801c1a0 <MSC_BOT_DataOut+0x90>
  USBD_MSC_BOT_HandleTypeDef  *hmsc = (USBD_MSC_BOT_HandleTypeDef*)pdev->pClassData;
 801c240:	f8d4 5290 	ldr.w	r5, [r4, #656]	; 0x290
  hmsc->csw.dSignature = USBD_BOT_CSW_SIGNATURE;
 801c244:	4a07      	ldr	r2, [pc, #28]	; (801c264 <MSC_BOT_DataOut+0x154>)
 801c246:	f505 5380 	add.w	r3, r5, #4096	; 0x1000
  hmsc->csw.bStatus = CSW_Status;
 801c24a:	2601      	movs	r6, #1
  hmsc->csw.dSignature = USBD_BOT_CSW_SIGNATURE;
 801c24c:	62da      	str	r2, [r3, #44]	; 0x2c
  USBD_LL_Transmit (pdev, MSC_EPIN_ADDR, (uint8_t *)(void *)&hmsc->csw,
 801c24e:	f505 5281 	add.w	r2, r5, #4128	; 0x1020
  hmsc->csw.bStatus = CSW_Status;
 801c252:	f883 6038 	strb.w	r6, [r3, #56]	; 0x38
  USBD_LL_Transmit (pdev, MSC_EPIN_ADDR, (uint8_t *)(void *)&hmsc->csw,
 801c256:	320c      	adds	r2, #12
  hmsc->bot_state = USBD_BOT_IDLE;
 801c258:	722f      	strb	r7, [r5, #8]
  USBD_LL_Transmit (pdev, MSC_EPIN_ADDR, (uint8_t *)(void *)&hmsc->csw,
 801c25a:	230d      	movs	r3, #13
 801c25c:	e7e8      	b.n	801c230 <MSC_BOT_DataOut+0x120>
 801c25e:	bf00      	nop
 801c260:	43425355 	.word	0x43425355
 801c264:	53425355 	.word	0x53425355

0801c268 <MSC_BOT_SendCSW>:
{
 801c268:	b570      	push	{r4, r5, r6, lr}
  USBD_MSC_BOT_HandleTypeDef  *hmsc = (USBD_MSC_BOT_HandleTypeDef*)pdev->pClassData;
 801c26a:	f8d0 5290 	ldr.w	r5, [r0, #656]	; 0x290
  hmsc->csw.dSignature = USBD_BOT_CSW_SIGNATURE;
 801c26e:	f505 5380 	add.w	r3, r5, #4096	; 0x1000
  hmsc->bot_state = USBD_BOT_IDLE;
 801c272:	2200      	movs	r2, #0
  hmsc->csw.bStatus = CSW_Status;
 801c274:	f883 1038 	strb.w	r1, [r3, #56]	; 0x38
  hmsc->csw.dSignature = USBD_BOT_CSW_SIGNATURE;
 801c278:	490a      	ldr	r1, [pc, #40]	; (801c2a4 <MSC_BOT_SendCSW+0x3c>)
 801c27a:	62d9      	str	r1, [r3, #44]	; 0x2c
  hmsc->bot_state = USBD_BOT_IDLE;
 801c27c:	722a      	strb	r2, [r5, #8]
  USBD_LL_Transmit (pdev, MSC_EPIN_ADDR, (uint8_t *)(void *)&hmsc->csw,
 801c27e:	f505 5281 	add.w	r2, r5, #4128	; 0x1020
 801c282:	230d      	movs	r3, #13
 801c284:	320c      	adds	r2, #12
 801c286:	2181      	movs	r1, #129	; 0x81
{
 801c288:	4604      	mov	r4, r0
  USBD_LL_Transmit (pdev, MSC_EPIN_ADDR, (uint8_t *)(void *)&hmsc->csw,
 801c28a:	f008 fd6f 	bl	8024d6c <USBD_LL_Transmit>
  USBD_LL_PrepareReceive (pdev, MSC_EPOUT_ADDR, (uint8_t *)(void *)&hmsc->cbw,
 801c28e:	f505 5280 	add.w	r2, r5, #4096	; 0x1000
 801c292:	4620      	mov	r0, r4
 801c294:	231f      	movs	r3, #31
}
 801c296:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
  USBD_LL_PrepareReceive (pdev, MSC_EPOUT_ADDR, (uint8_t *)(void *)&hmsc->cbw,
 801c29a:	320c      	adds	r2, #12
 801c29c:	2101      	movs	r1, #1
 801c29e:	f008 bd6d 	b.w	8024d7c <USBD_LL_PrepareReceive>
 801c2a2:	bf00      	nop
 801c2a4:	53425355 	.word	0x53425355

0801c2a8 <MSC_BOT_CplClrFeature>:
* @param  epnum: endpoint index
* @retval None
*/

void  MSC_BOT_CplClrFeature (USBD_HandleTypeDef  *pdev, uint8_t epnum)
{
 801c2a8:	b570      	push	{r4, r5, r6, lr}
  USBD_MSC_BOT_HandleTypeDef  *hmsc = (USBD_MSC_BOT_HandleTypeDef*)pdev->pClassData;
 801c2aa:	f8d0 5290 	ldr.w	r5, [r0, #656]	; 0x290

  if(hmsc->bot_status == USBD_BOT_STATUS_ERROR)/* Bad CBW Signature */
 801c2ae:	7a6b      	ldrb	r3, [r5, #9]
 801c2b0:	2b02      	cmp	r3, #2
 801c2b2:	d01e      	beq.n	801c2f2 <MSC_BOT_CplClrFeature+0x4a>
  {
    USBD_LL_StallEP(pdev, MSC_EPIN_ADDR);
    hmsc->bot_status = USBD_BOT_STATUS_NORMAL;
  }
  else if(((epnum & 0x80U) == 0x80U) && (hmsc->bot_status != USBD_BOT_STATUS_RECOVERY))
 801c2b4:	060a      	lsls	r2, r1, #24
 801c2b6:	d521      	bpl.n	801c2fc <MSC_BOT_CplClrFeature+0x54>
 801c2b8:	2b01      	cmp	r3, #1
 801c2ba:	d01f      	beq.n	801c2fc <MSC_BOT_CplClrFeature+0x54>
  hmsc->csw.dSignature = USBD_BOT_CSW_SIGNATURE;
 801c2bc:	f505 5380 	add.w	r3, r5, #4096	; 0x1000
  hmsc->csw.bStatus = CSW_Status;
 801c2c0:	2601      	movs	r6, #1
  hmsc->csw.dSignature = USBD_BOT_CSW_SIGNATURE;
 801c2c2:	4a0f      	ldr	r2, [pc, #60]	; (801c300 <MSC_BOT_CplClrFeature+0x58>)
 801c2c4:	62da      	str	r2, [r3, #44]	; 0x2c
  hmsc->csw.bStatus = CSW_Status;
 801c2c6:	f883 6038 	strb.w	r6, [r3, #56]	; 0x38
  USBD_LL_Transmit (pdev, MSC_EPIN_ADDR, (uint8_t *)(void *)&hmsc->csw,
 801c2ca:	f505 5281 	add.w	r2, r5, #4128	; 0x1020
  hmsc->bot_state = USBD_BOT_IDLE;
 801c2ce:	2300      	movs	r3, #0
 801c2d0:	722b      	strb	r3, [r5, #8]
  USBD_LL_Transmit (pdev, MSC_EPIN_ADDR, (uint8_t *)(void *)&hmsc->csw,
 801c2d2:	320c      	adds	r2, #12
 801c2d4:	230d      	movs	r3, #13
 801c2d6:	2181      	movs	r1, #129	; 0x81
 801c2d8:	4604      	mov	r4, r0
 801c2da:	f008 fd47 	bl	8024d6c <USBD_LL_Transmit>
  USBD_LL_PrepareReceive (pdev, MSC_EPOUT_ADDR, (uint8_t *)(void *)&hmsc->cbw,
 801c2de:	f505 5280 	add.w	r2, r5, #4096	; 0x1000
 801c2e2:	4631      	mov	r1, r6
 801c2e4:	4620      	mov	r0, r4
 801c2e6:	231f      	movs	r3, #31
  }
  else
  {
    return;
  }
}
 801c2e8:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
  USBD_LL_PrepareReceive (pdev, MSC_EPOUT_ADDR, (uint8_t *)(void *)&hmsc->cbw,
 801c2ec:	320c      	adds	r2, #12
 801c2ee:	f008 bd45 	b.w	8024d7c <USBD_LL_PrepareReceive>
    USBD_LL_StallEP(pdev, MSC_EPIN_ADDR);
 801c2f2:	2181      	movs	r1, #129	; 0x81
 801c2f4:	f008 fd0e 	bl	8024d14 <USBD_LL_StallEP>
    hmsc->bot_status = USBD_BOT_STATUS_NORMAL;
 801c2f8:	2300      	movs	r3, #0
 801c2fa:	726b      	strb	r3, [r5, #9]
}
 801c2fc:	bd70      	pop	{r4, r5, r6, pc}
 801c2fe:	bf00      	nop
 801c300:	53425355 	.word	0x53425355

0801c304 <SCSI_ProcessCmd>:
* @param  lun: Logical unit number
* @param  params: Command parameters
* @retval status
*/
int8_t SCSI_ProcessCmd(USBD_HandleTypeDef *pdev, uint8_t lun, uint8_t *cmd)
{
 801c304:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  switch (cmd[0])
 801c308:	7813      	ldrb	r3, [r2, #0]
{
 801c30a:	b083      	sub	sp, #12
 801c30c:	4693      	mov	fp, r2
 801c30e:	4604      	mov	r4, r0
 801c310:	460e      	mov	r6, r1
  switch (cmd[0])
 801c312:	2b5a      	cmp	r3, #90	; 0x5a
 801c314:	d85c      	bhi.n	801c3d0 <SCSI_ProcessCmd+0xcc>
 801c316:	e8df f013 	tbh	[pc, r3, lsl #1]
 801c31a:	00db      	.short	0x00db
 801c31c:	005b005b 	.word	0x005b005b
 801c320:	005b0083 	.word	0x005b0083
 801c324:	005b005b 	.word	0x005b005b
 801c328:	005b005b 	.word	0x005b005b
 801c32c:	005b005b 	.word	0x005b005b
 801c330:	005b005b 	.word	0x005b005b
 801c334:	005b005b 	.word	0x005b005b
 801c338:	005b005b 	.word	0x005b005b
 801c33c:	00b8005b 	.word	0x00b8005b
 801c340:	005b005b 	.word	0x005b005b
 801c344:	005b005b 	.word	0x005b005b
 801c348:	005b005b 	.word	0x005b005b
 801c34c:	01be005b 	.word	0x01be005b
 801c350:	005b007a 	.word	0x005b007a
 801c354:	007a005b 	.word	0x007a005b
 801c358:	005b005b 	.word	0x005b005b
 801c35c:	005b005b 	.word	0x005b005b
 801c360:	005b01c8 	.word	0x005b01c8
 801c364:	005b01ed 	.word	0x005b01ed
 801c368:	014f005b 	.word	0x014f005b
 801c36c:	00f0005b 	.word	0x00f0005b
 801c370:	005b005b 	.word	0x005b005b
 801c374:	005b005b 	.word	0x005b005b
 801c378:	005b013b 	.word	0x005b013b
 801c37c:	005b005b 	.word	0x005b005b
 801c380:	005b005b 	.word	0x005b005b
 801c384:	005b005b 	.word	0x005b005b
 801c388:	005b005b 	.word	0x005b005b
 801c38c:	005b005b 	.word	0x005b005b
 801c390:	005b005b 	.word	0x005b005b
 801c394:	005b005b 	.word	0x005b005b
 801c398:	005b005b 	.word	0x005b005b
 801c39c:	005b005b 	.word	0x005b005b
 801c3a0:	005b005b 	.word	0x005b005b
 801c3a4:	005b005b 	.word	0x005b005b
 801c3a8:	005b005b 	.word	0x005b005b
 801c3ac:	005b005b 	.word	0x005b005b
 801c3b0:	005b005b 	.word	0x005b005b
 801c3b4:	005b005b 	.word	0x005b005b
 801c3b8:	005b005b 	.word	0x005b005b
 801c3bc:	005b005b 	.word	0x005b005b
 801c3c0:	005b005b 	.word	0x005b005b
 801c3c4:	005b005b 	.word	0x005b005b
 801c3c8:	005b005b 	.word	0x005b005b
 801c3cc:	020e005b 	.word	0x020e005b
* @retval none

*/
void SCSI_SenseCode(USBD_HandleTypeDef  *pdev, uint8_t lun, uint8_t sKey, uint8_t ASC)
{
  USBD_MSC_BOT_HandleTypeDef  *hmsc = (USBD_MSC_BOT_HandleTypeDef*)pdev->pClassData;
 801c3d0:	f8d0 3290 	ldr.w	r3, [r0, #656]	; 0x290

  hmsc->scsi_sense[hmsc->scsi_sense_tail].Skey  = sKey;
 801c3d4:	f503 5180 	add.w	r1, r3, #4096	; 0x1000
 801c3d8:	2005      	movs	r0, #5
 801c3da:	f891 205d 	ldrb.w	r2, [r1, #93]	; 0x5d
 801c3de:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
 801c3e2:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
  hmsc->scsi_sense[hmsc->scsi_sense_tail].w.ASC = ASC << 8;
  hmsc->scsi_sense_tail++;
 801c3e6:	3201      	adds	r2, #1
 801c3e8:	b2d2      	uxtb	r2, r2
  hmsc->scsi_sense[hmsc->scsi_sense_tail].Skey  = sKey;
 801c3ea:	f883 003c 	strb.w	r0, [r3, #60]	; 0x3c
  if (hmsc->scsi_sense_tail == SENSE_LIST_DEEPTH)
 801c3ee:	2a04      	cmp	r2, #4
  hmsc->scsi_sense[hmsc->scsi_sense_tail].w.ASC = ASC << 8;
 801c3f0:	f04f 0000 	mov.w	r0, #0
 801c3f4:	f883 0040 	strb.w	r0, [r3, #64]	; 0x40
    return -1;
 801c3f8:	f04f 35ff 	mov.w	r5, #4294967295
  hmsc->scsi_sense_tail++;
 801c3fc:	bf14      	ite	ne
 801c3fe:	f881 205d 	strbne.w	r2, [r1, #93]	; 0x5d
  {
    hmsc->scsi_sense_tail = 0U;
 801c402:	f881 005d 	strbeq.w	r0, [r1, #93]	; 0x5d
}
 801c406:	4628      	mov	r0, r5
 801c408:	b003      	add	sp, #12
 801c40a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
* @retval status
*/
static int8_t SCSI_StartStopUnit(USBD_HandleTypeDef  *pdev, uint8_t lun, uint8_t *params)
{
  USBD_MSC_BOT_HandleTypeDef  *hmsc = (USBD_MSC_BOT_HandleTypeDef*) pdev->pClassData;
  hmsc->bot_data_length = 0U;
 801c40e:	f8d0 3290 	ldr.w	r3, [r0, #656]	; 0x290
 801c412:	2000      	movs	r0, #0
  return 0;
 801c414:	4605      	mov	r5, r0
  hmsc->bot_data_length = 0U;
 801c416:	8158      	strh	r0, [r3, #10]
}
 801c418:	4628      	mov	r0, r5
 801c41a:	b003      	add	sp, #12
 801c41c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    SCSI_RequestSense (pdev, lun, cmd);
 801c420:	f8d0 3290 	ldr.w	r3, [r0, #656]	; 0x290
  hmsc->bot_data[0]	= 0x70U;
 801c424:	2170      	movs	r1, #112	; 0x70
    hmsc->bot_data[i] = 0U;
 801c426:	2000      	movs	r0, #0
 801c428:	60d8      	str	r0, [r3, #12]
  if((hmsc->scsi_sense_head != hmsc->scsi_sense_tail)) {
 801c42a:	f503 5580 	add.w	r5, r3, #4096	; 0x1000
  hmsc->bot_data[0]	= 0x70U;
 801c42e:	7319      	strb	r1, [r3, #12]
  hmsc->bot_data[7]	= REQUEST_SENSE_DATA_LEN - 6U;
 801c430:	210c      	movs	r1, #12
    hmsc->bot_data[i] = 0U;
 801c432:	6118      	str	r0, [r3, #16]
 801c434:	6158      	str	r0, [r3, #20]
 801c436:	6198      	str	r0, [r3, #24]
 801c438:	8398      	strh	r0, [r3, #28]
  hmsc->bot_data[7]	= REQUEST_SENSE_DATA_LEN - 6U;
 801c43a:	74d9      	strb	r1, [r3, #19]
  if((hmsc->scsi_sense_head != hmsc->scsi_sense_tail)) {
 801c43c:	f895 105c 	ldrb.w	r1, [r5, #92]	; 0x5c
 801c440:	f895 405d 	ldrb.w	r4, [r5, #93]	; 0x5d
 801c444:	428c      	cmp	r4, r1
 801c446:	d014      	beq.n	801c472 <SCSI_ProcessCmd+0x16e>
    hmsc->bot_data[2]     = hmsc->scsi_sense[hmsc->scsi_sense_head].Skey;
 801c448:	eb03 04c1 	add.w	r4, r3, r1, lsl #3
 801c44c:	f504 5480 	add.w	r4, r4, #4096	; 0x1000
    hmsc->scsi_sense_head++;
 801c450:	3101      	adds	r1, #1
    hmsc->bot_data[2]     = hmsc->scsi_sense[hmsc->scsi_sense_head].Skey;
 801c452:	f894 603c 	ldrb.w	r6, [r4, #60]	; 0x3c
 801c456:	739e      	strb	r6, [r3, #14]
    hmsc->bot_data[12]    = hmsc->scsi_sense[hmsc->scsi_sense_head].w.b.ASCQ;
 801c458:	f894 6041 	ldrb.w	r6, [r4, #65]	; 0x41
 801c45c:	761e      	strb	r6, [r3, #24]
    hmsc->scsi_sense_head++;
 801c45e:	b2c9      	uxtb	r1, r1
    hmsc->bot_data[13]    = hmsc->scsi_sense[hmsc->scsi_sense_head].w.b.ASC;
 801c460:	f894 4040 	ldrb.w	r4, [r4, #64]	; 0x40
 801c464:	765c      	strb	r4, [r3, #25]
    if (hmsc->scsi_sense_head == SENSE_LIST_DEEPTH)
 801c466:	2904      	cmp	r1, #4
    hmsc->scsi_sense_head++;
 801c468:	bf14      	ite	ne
 801c46a:	f885 105c 	strbne.w	r1, [r5, #92]	; 0x5c
      hmsc->scsi_sense_head = 0U;
 801c46e:	f885 005c 	strbeq.w	r0, [r5, #92]	; 0x5c
  hmsc->bot_data_length = REQUEST_SENSE_DATA_LEN;
 801c472:	2112      	movs	r1, #18
 801c474:	8159      	strh	r1, [r3, #10]
  if (params[4] <= REQUEST_SENSE_DATA_LEN)
 801c476:	f89b 2004 	ldrb.w	r2, [fp, #4]
 801c47a:	428a      	cmp	r2, r1
    hmsc->bot_data_length = params[4];
 801c47c:	bf98      	it	ls
 801c47e:	815a      	strhls	r2, [r3, #10]
  return 0;
 801c480:	2500      	movs	r5, #0
}
 801c482:	4628      	mov	r0, r5
 801c484:	b003      	add	sp, #12
 801c486:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  if (params[1] & 0x01U)/*Evpd is set*/
 801c48a:	f89b 3001 	ldrb.w	r3, [fp, #1]
  USBD_MSC_BOT_HandleTypeDef  *hmsc = (USBD_MSC_BOT_HandleTypeDef*)pdev->pClassData;
 801c48e:	f8d0 0290 	ldr.w	r0, [r0, #656]	; 0x290
  if (params[1] & 0x01U)/*Evpd is set*/
 801c492:	07db      	lsls	r3, r3, #31
 801c494:	f100 8151 	bmi.w	801c73a <SCSI_ProcessCmd+0x436>
    pPage = (uint8_t *)(void *)&((USBD_StorageTypeDef *)pdev->pUserData)->pInquiry[lun * STANDARD_INQUIRY_DATA_LEN];
 801c498:	f8d4 3294 	ldr.w	r3, [r4, #660]	; 0x294
 801c49c:	69dc      	ldr	r4, [r3, #28]
 801c49e:	f89b 3004 	ldrb.w	r3, [fp, #4]
 801c4a2:	eb01 06c1 	add.w	r6, r1, r1, lsl #3
 801c4a6:	eb04 0686 	add.w	r6, r4, r6, lsl #2
    len = (uint16_t)pPage[4] + 5U;
 801c4aa:	7932      	ldrb	r2, [r6, #4]
 801c4ac:	3205      	adds	r2, #5
    if (params[4] <= len)
 801c4ae:	4293      	cmp	r3, r2
 801c4b0:	bf28      	it	cs
 801c4b2:	4613      	movcs	r3, r2
    hmsc->bot_data_length = len;
 801c4b4:	8143      	strh	r3, [r0, #10]
    while (len)
 801c4b6:	2b00      	cmp	r3, #0
 801c4b8:	d0e2      	beq.n	801c480 <SCSI_ProcessCmd+0x17c>
 801c4ba:	f103 020b 	add.w	r2, r3, #11
 801c4be:	4402      	add	r2, r0
 801c4c0:	4433      	add	r3, r6
      hmsc->bot_data[len] = pPage[len];
 801c4c2:	f813 1d01 	ldrb.w	r1, [r3, #-1]!
 801c4c6:	f802 1901 	strb.w	r1, [r2], #-1
    while (len)
 801c4ca:	429e      	cmp	r6, r3
 801c4cc:	d1f9      	bne.n	801c4c2 <SCSI_ProcessCmd+0x1be>
 801c4ce:	e7d7      	b.n	801c480 <SCSI_ProcessCmd+0x17c>
  USBD_MSC_BOT_HandleTypeDef  *hmsc = (USBD_MSC_BOT_HandleTypeDef*)pdev->pClassData;
 801c4d0:	f8d0 7290 	ldr.w	r7, [r0, #656]	; 0x290
  if (hmsc->cbw.dDataLength != 0U)
 801c4d4:	f507 5380 	add.w	r3, r7, #4096	; 0x1000
 801c4d8:	f8d3 8014 	ldr.w	r8, [r3, #20]
 801c4dc:	f1b8 0f00 	cmp.w	r8, #0
 801c4e0:	f040 826c 	bne.w	801c9bc <SCSI_ProcessCmd+0x6b8>
  if(((USBD_StorageTypeDef *)pdev->pUserData)->IsReady(lun) != 0)
 801c4e4:	f8d0 3294 	ldr.w	r3, [r0, #660]	; 0x294
 801c4e8:	4608      	mov	r0, r1
 801c4ea:	689b      	ldr	r3, [r3, #8]
 801c4ec:	4798      	blx	r3
 801c4ee:	4605      	mov	r5, r0
 801c4f0:	2800      	cmp	r0, #0
 801c4f2:	f040 8245 	bne.w	801c980 <SCSI_ProcessCmd+0x67c>
  hmsc->bot_data_length = 0U;
 801c4f6:	8178      	strh	r0, [r7, #10]
  return 0;
 801c4f8:	e785      	b.n	801c406 <SCSI_ProcessCmd+0x102>
* @retval status
*/

static int8_t SCSI_Write10 (USBD_HandleTypeDef  *pdev, uint8_t lun , uint8_t *params)
{
  USBD_MSC_BOT_HandleTypeDef  *hmsc = (USBD_MSC_BOT_HandleTypeDef*) pdev->pClassData;
 801c4fa:	f8d0 7290 	ldr.w	r7, [r0, #656]	; 0x290
  uint32_t len;

  if (hmsc->bot_state == USBD_BOT_IDLE) /* Idle */
 801c4fe:	7a3d      	ldrb	r5, [r7, #8]
  {
    /* case 8 : Hi <> Do */
    if ((hmsc->cbw.bmFlags & 0x80U) == 0x80U)
 801c500:	f507 5880 	add.w	r8, r7, #4096	; 0x1000
  if (hmsc->bot_state == USBD_BOT_IDLE) /* Idle */
 801c504:	2d00      	cmp	r5, #0
 801c506:	f040 813d 	bne.w	801c784 <SCSI_ProcessCmd+0x480>
    if ((hmsc->cbw.bmFlags & 0x80U) == 0x80U)
 801c50a:	f998 3018 	ldrsb.w	r3, [r8, #24]
 801c50e:	2b00      	cmp	r3, #0
 801c510:	f2c0 8291 	blt.w	801ca36 <SCSI_ProcessCmd+0x732>
      SCSI_SenseCode(pdev, hmsc->cbw.bLUN, ILLEGAL_REQUEST, INVALID_CDB);
      return -1;
    }

    /* Check whether Media is ready */
    if(((USBD_StorageTypeDef *)pdev->pUserData)->IsReady(lun) != 0)
 801c514:	f8d0 3294 	ldr.w	r3, [r0, #660]	; 0x294
 801c518:	4608      	mov	r0, r1
 801c51a:	689b      	ldr	r3, [r3, #8]
 801c51c:	4798      	blx	r3
 801c51e:	4681      	mov	r9, r0
 801c520:	2800      	cmp	r0, #0
 801c522:	f040 8265 	bne.w	801c9f0 <SCSI_ProcessCmd+0x6ec>
      SCSI_SenseCode(pdev, lun, NOT_READY, MEDIUM_NOT_PRESENT);
      return -1;
    }

    /* Check If media is write-protected */
    if(((USBD_StorageTypeDef *)pdev->pUserData)->IsWriteProtected(lun) != 0)
 801c526:	f8d4 3294 	ldr.w	r3, [r4, #660]	; 0x294
 801c52a:	4630      	mov	r0, r6
 801c52c:	68db      	ldr	r3, [r3, #12]
 801c52e:	4798      	blx	r3
 801c530:	4605      	mov	r5, r0
 801c532:	2800      	cmp	r0, #0
 801c534:	f040 81cf 	bne.w	801c8d6 <SCSI_ProcessCmd+0x5d2>
    {
      SCSI_SenseCode(pdev, lun, NOT_READY, WRITE_PROTECTED);
      return -1;
    }

    hmsc->scsi_blk_addr = ((uint32_t)params[2] << 24) |
 801c538:	f8db 0002 	ldr.w	r0, [fp, #2]
 801c53c:	f8d4 6290 	ldr.w	r6, [r4, #656]	; 0x290
 801c540:	ba00      	rev	r0, r0
 801c542:	f8c8 0064 	str.w	r0, [r8, #100]	; 0x64
                          ((uint32_t)params[3] << 16) |
                          ((uint32_t)params[4] << 8) |
                           (uint32_t)params[5];

    hmsc->scsi_blk_len = ((uint32_t)params[7] << 8) |
 801c546:	f8bb 3007 	ldrh.w	r3, [fp, #7]
static int8_t SCSI_CheckAddressRange (USBD_HandleTypeDef *pdev, uint8_t lun,
                                      uint32_t blk_offset, uint32_t blk_nbr)
{
  USBD_MSC_BOT_HandleTypeDef  *hmsc = (USBD_MSC_BOT_HandleTypeDef*) pdev->pClassData;

  if ((blk_offset + blk_nbr) > hmsc->scsi_blk_nbr)
 801c54a:	f506 5180 	add.w	r1, r6, #4096	; 0x1000
 801c54e:	ba5b      	rev16	r3, r3
 801c550:	b29b      	uxth	r3, r3
 801c552:	6e0a      	ldr	r2, [r1, #96]	; 0x60
    hmsc->scsi_blk_len = ((uint32_t)params[7] << 8) |
 801c554:	f8c8 3068 	str.w	r3, [r8, #104]	; 0x68
  if ((blk_offset + blk_nbr) > hmsc->scsi_blk_nbr)
 801c558:	4418      	add	r0, r3
 801c55a:	4290      	cmp	r0, r2
 801c55c:	f200 8259 	bhi.w	801ca12 <SCSI_ProcessCmd+0x70e>
    len = hmsc->scsi_blk_len * hmsc->scsi_blk_size;
 801c560:	f8b8 205e 	ldrh.w	r2, [r8, #94]	; 0x5e
 801c564:	fb02 f303 	mul.w	r3, r2, r3
    if (hmsc->cbw.dDataLength != len)
 801c568:	f8d8 2014 	ldr.w	r2, [r8, #20]
 801c56c:	4293      	cmp	r3, r2
 801c56e:	f040 8148 	bne.w	801c802 <SCSI_ProcessCmd+0x4fe>
    len = MIN(len, MSC_MEDIA_PACKET);
 801c572:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
    hmsc->bot_state = USBD_BOT_DATA_OUT;
 801c576:	f04f 0101 	mov.w	r1, #1
    len = MIN(len, MSC_MEDIA_PACKET);
 801c57a:	bf28      	it	cs
 801c57c:	f44f 5380 	movcs.w	r3, #4096	; 0x1000
    hmsc->bot_state = USBD_BOT_DATA_OUT;
 801c580:	7239      	strb	r1, [r7, #8]
    USBD_LL_PrepareReceive (pdev, MSC_EPOUT_ADDR, hmsc->bot_data, len);
 801c582:	b29b      	uxth	r3, r3
 801c584:	f107 020c 	add.w	r2, r7, #12
 801c588:	4620      	mov	r0, r4
 801c58a:	f008 fbf7 	bl	8024d7c <USBD_LL_PrepareReceive>
  return 0;
 801c58e:	e73a      	b.n	801c406 <SCSI_ProcessCmd+0x102>
  if ((params[1]& 0x02U) == 0x02U)
 801c590:	f89b 5001 	ldrb.w	r5, [fp, #1]
 801c594:	f8d0 1290 	ldr.w	r1, [r0, #656]	; 0x290
 801c598:	f015 0002 	ands.w	r0, r5, #2
 801c59c:	f040 815a 	bne.w	801c854 <SCSI_ProcessCmd+0x550>
  if(SCSI_CheckAddressRange(pdev, lun, hmsc->scsi_blk_addr,
 801c5a0:	f501 5380 	add.w	r3, r1, #4096	; 0x1000
  if ((blk_offset + blk_nbr) > hmsc->scsi_blk_nbr)
 801c5a4:	e9d3 2419 	ldrd	r2, r4, [r3, #100]	; 0x64
 801c5a8:	4422      	add	r2, r4
 801c5aa:	6e1c      	ldr	r4, [r3, #96]	; 0x60
 801c5ac:	42a2      	cmp	r2, r4
 801c5ae:	f200 81c0 	bhi.w	801c932 <SCSI_ProcessCmd+0x62e>
  hmsc->bot_data_length = 0U;
 801c5b2:	8148      	strh	r0, [r1, #10]
  return 0;
 801c5b4:	4605      	mov	r5, r0
  return 0;
 801c5b6:	e726      	b.n	801c406 <SCSI_ProcessCmd+0x102>
  USBD_MSC_BOT_HandleTypeDef  *hmsc = (USBD_MSC_BOT_HandleTypeDef*) pdev->pClassData;
 801c5b8:	f8d0 8290 	ldr.w	r8, [r0, #656]	; 0x290
  if(hmsc->bot_state == USBD_BOT_IDLE)  /* Idle */
 801c5bc:	f898 7008 	ldrb.w	r7, [r8, #8]
 801c5c0:	2f00      	cmp	r7, #0
 801c5c2:	f040 80db 	bne.w	801c77c <SCSI_ProcessCmd+0x478>
    if ((hmsc->cbw.bmFlags & 0x80U) != 0x80U)
 801c5c6:	f508 5a80 	add.w	sl, r8, #4096	; 0x1000
 801c5ca:	f99a 3018 	ldrsb.w	r3, [sl, #24]
 801c5ce:	2b00      	cmp	r3, #0
 801c5d0:	f280 81c3 	bge.w	801c95a <SCSI_ProcessCmd+0x656>
    if(((USBD_StorageTypeDef *)pdev->pUserData)->IsReady(lun) != 0)
 801c5d4:	f8d0 3294 	ldr.w	r3, [r0, #660]	; 0x294
 801c5d8:	4608      	mov	r0, r1
 801c5da:	689b      	ldr	r3, [r3, #8]
 801c5dc:	4798      	blx	r3
 801c5de:	4605      	mov	r5, r0
 801c5e0:	2800      	cmp	r0, #0
 801c5e2:	f040 80b4 	bne.w	801c74e <SCSI_ProcessCmd+0x44a>
    hmsc->scsi_blk_addr = ((uint32_t)params[2] << 24) |
 801c5e6:	f8db 1002 	ldr.w	r1, [fp, #2]
 801c5ea:	f8d4 9290 	ldr.w	r9, [r4, #656]	; 0x290
 801c5ee:	ba09      	rev	r1, r1
 801c5f0:	f8ca 1064 	str.w	r1, [sl, #100]	; 0x64
    hmsc->scsi_blk_len =  ((uint32_t)params[7] <<  8) | (uint32_t)params[8];
 801c5f4:	f8bb 3007 	ldrh.w	r3, [fp, #7]
  if ((blk_offset + blk_nbr) > hmsc->scsi_blk_nbr)
 801c5f8:	f509 5780 	add.w	r7, r9, #4096	; 0x1000
 801c5fc:	ba5b      	rev16	r3, r3
 801c5fe:	b29b      	uxth	r3, r3
 801c600:	6e3a      	ldr	r2, [r7, #96]	; 0x60
    hmsc->scsi_blk_len =  ((uint32_t)params[7] <<  8) | (uint32_t)params[8];
 801c602:	f8ca 3068 	str.w	r3, [sl, #104]	; 0x68
  if ((blk_offset + blk_nbr) > hmsc->scsi_blk_nbr)
 801c606:	4419      	add	r1, r3
 801c608:	4291      	cmp	r1, r2
 801c60a:	f200 8150 	bhi.w	801c8ae <SCSI_ProcessCmd+0x5aa>
    hmsc->bot_state = USBD_BOT_DATA_IN;
 801c60e:	2202      	movs	r2, #2
 801c610:	f888 2008 	strb.w	r2, [r8, #8]
    if (hmsc->cbw.dDataLength != (hmsc->scsi_blk_len * hmsc->scsi_blk_size))
 801c614:	f8ba 205e 	ldrh.w	r2, [sl, #94]	; 0x5e
 801c618:	fb02 f303 	mul.w	r3, r2, r3
 801c61c:	f8da 2014 	ldr.w	r2, [sl, #20]
 801c620:	429a      	cmp	r2, r3
 801c622:	f040 8144 	bne.w	801c8ae <SCSI_ProcessCmd+0x5aa>
* @retval status
*/
static int8_t SCSI_ProcessRead (USBD_HandleTypeDef  *pdev, uint8_t lun)
{
  USBD_MSC_BOT_HandleTypeDef *hmsc = (USBD_MSC_BOT_HandleTypeDef*)pdev->pClassData;
  uint32_t len = hmsc->scsi_blk_len * hmsc->scsi_blk_size;
 801c626:	f8b7 305e 	ldrh.w	r3, [r7, #94]	; 0x5e

  len = MIN(len, MSC_MEDIA_PACKET);

  if( ((USBD_StorageTypeDef *)pdev->pUserData)->Read(lun,
 801c62a:	f8d4 2294 	ldr.w	r2, [r4, #660]	; 0x294
 801c62e:	4630      	mov	r0, r6
  uint32_t len = hmsc->scsi_blk_len * hmsc->scsi_blk_size;
 801c630:	6ebe      	ldr	r6, [r7, #104]	; 0x68
  if( ((USBD_StorageTypeDef *)pdev->pUserData)->Read(lun,
 801c632:	f8d2 a010 	ldr.w	sl, [r2, #16]
  uint32_t len = hmsc->scsi_blk_len * hmsc->scsi_blk_size;
 801c636:	fb03 f606 	mul.w	r6, r3, r6
  len = MIN(len, MSC_MEDIA_PACKET);
 801c63a:	f5b6 5f80 	cmp.w	r6, #4096	; 0x1000
  hmsc->bot_data_length = MSC_MEDIA_PACKET;
 801c63e:	f44f 5280 	mov.w	r2, #4096	; 0x1000
                              hmsc->bot_data,
 801c642:	f109 050c 	add.w	r5, r9, #12
  len = MIN(len, MSC_MEDIA_PACKET);
 801c646:	bf28      	it	cs
 801c648:	f44f 5680 	movcs.w	r6, #4096	; 0x1000
  hmsc->bot_data_length = MSC_MEDIA_PACKET;
 801c64c:	f8a8 200a 	strh.w	r2, [r8, #10]
  if( ((USBD_StorageTypeDef *)pdev->pUserData)->Read(lun,
 801c650:	4629      	mov	r1, r5
 801c652:	6e7a      	ldr	r2, [r7, #100]	; 0x64
                              hmsc->scsi_blk_addr,
                              (len / hmsc->scsi_blk_size)) < 0)
 801c654:	fbb6 f3f3 	udiv	r3, r6, r3
  if( ((USBD_StorageTypeDef *)pdev->pUserData)->Read(lun,
 801c658:	b29b      	uxth	r3, r3
 801c65a:	47d0      	blx	sl
 801c65c:	2800      	cmp	r0, #0
 801c65e:	f2c0 8152 	blt.w	801c906 <SCSI_ProcessCmd+0x602>
  {
    SCSI_SenseCode(pdev, lun, HARDWARE_ERROR, UNRECOVERED_READ_ERROR);
    return -1;
  }

  USBD_LL_Transmit (pdev, MSC_EPIN_ADDR, hmsc->bot_data, len);
 801c662:	462a      	mov	r2, r5
 801c664:	b2b3      	uxth	r3, r6
 801c666:	4620      	mov	r0, r4
 801c668:	2181      	movs	r1, #129	; 0x81
 801c66a:	f008 fb7f 	bl	8024d6c <USBD_LL_Transmit>

  hmsc->scsi_blk_addr += (len / hmsc->scsi_blk_size);
  hmsc->scsi_blk_len -= (len / hmsc->scsi_blk_size);
 801c66e:	e9d7 3519 	ldrd	r3, r5, [r7, #100]	; 0x64
  hmsc->scsi_blk_addr += (len / hmsc->scsi_blk_size);
 801c672:	f8b7 005e 	ldrh.w	r0, [r7, #94]	; 0x5e
 801c676:	fbb6 f0f0 	udiv	r0, r6, r0
 801c67a:	4403      	add	r3, r0
  hmsc->scsi_blk_len -= (len / hmsc->scsi_blk_size);
 801c67c:	1a2d      	subs	r5, r5, r0
 801c67e:	e9c7 3519 	strd	r3, r5, [r7, #100]	; 0x64

  /* case 6 : Hi = Di */
  hmsc->csw.dDataResidue -= len;
 801c682:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801c684:	1b9b      	subs	r3, r3, r6
 801c686:	637b      	str	r3, [r7, #52]	; 0x34

  if (hmsc->scsi_blk_len == 0U)
 801c688:	2d00      	cmp	r5, #0
 801c68a:	f47f aef9 	bne.w	801c480 <SCSI_ProcessCmd+0x17c>
  {
    hmsc->bot_state = USBD_BOT_LAST_DATA_IN;
 801c68e:	2303      	movs	r3, #3
 801c690:	f889 3008 	strb.w	r3, [r9, #8]
 801c694:	e6b7      	b.n	801c406 <SCSI_ProcessCmd+0x102>
    hmsc->bot_data[len] = MSC_Mode_Sense6_data[len];
 801c696:	4ad3      	ldr	r2, [pc, #844]	; (801c9e4 <SCSI_ProcessCmd+0x6e0>)
  USBD_MSC_BOT_HandleTypeDef  *hmsc = (USBD_MSC_BOT_HandleTypeDef*)pdev->pClassData;
 801c698:	f8d4 3290 	ldr.w	r3, [r4, #656]	; 0x290
    hmsc->bot_data[len] = MSC_Mode_Sense10_data[len];
 801c69c:	6811      	ldr	r1, [r2, #0]
 801c69e:	6852      	ldr	r2, [r2, #4]
 801c6a0:	60d9      	str	r1, [r3, #12]
  hmsc->bot_data_length = len;
 801c6a2:	2008      	movs	r0, #8
 801c6a4:	8158      	strh	r0, [r3, #10]
    hmsc->bot_data[len] = MSC_Mode_Sense10_data[len];
 801c6a6:	611a      	str	r2, [r3, #16]
 801c6a8:	e6ea      	b.n	801c480 <SCSI_ProcessCmd+0x17c>
  USBD_MSC_BOT_HandleTypeDef  *hmsc = (USBD_MSC_BOT_HandleTypeDef*)pdev->pClassData;
 801c6aa:	f8d0 5290 	ldr.w	r5, [r0, #656]	; 0x290
    hmsc->bot_data[i] = 0U;
 801c6ae:	2700      	movs	r7, #0
 801c6b0:	60ef      	str	r7, [r5, #12]
 801c6b2:	612f      	str	r7, [r5, #16]
 801c6b4:	616f      	str	r7, [r5, #20]
  if(((USBD_StorageTypeDef *)pdev->pUserData)->GetCapacity(lun, &blk_nbr, &blk_size) != 0U)
 801c6b6:	f8d0 3294 	ldr.w	r3, [r0, #660]	; 0x294
 801c6ba:	f10d 0202 	add.w	r2, sp, #2
 801c6be:	4608      	mov	r0, r1
 801c6c0:	685b      	ldr	r3, [r3, #4]
 801c6c2:	a901      	add	r1, sp, #4
 801c6c4:	4798      	blx	r3
 801c6c6:	2800      	cmp	r0, #0
 801c6c8:	f040 80da 	bne.w	801c880 <SCSI_ProcessCmd+0x57c>
    hmsc->bot_data[4] = (uint8_t)((blk_nbr - 1U) >> 24);
 801c6cc:	9b01      	ldr	r3, [sp, #4]
 801c6ce:	f8bd 2002 	ldrh.w	r2, [sp, #2]
 801c6d2:	3b01      	subs	r3, #1
    hmsc->bot_data[3] = 0x08U;
 801c6d4:	2008      	movs	r0, #8
    hmsc->bot_data[4] = (uint8_t)((blk_nbr - 1U) >> 24);
 801c6d6:	0e19      	lsrs	r1, r3, #24
    hmsc->bot_data[3] = 0x08U;
 801c6d8:	73e8      	strb	r0, [r5, #15]
    hmsc->bot_data[4] = (uint8_t)((blk_nbr - 1U) >> 24);
 801c6da:	7429      	strb	r1, [r5, #16]
    hmsc->bot_data[5] = (uint8_t)((blk_nbr - 1U) >> 16);
 801c6dc:	0c18      	lsrs	r0, r3, #16
    hmsc->bot_data[6] = (uint8_t)((blk_nbr - 1U) >>  8);
 801c6de:	0a19      	lsrs	r1, r3, #8
 801c6e0:	ba52      	rev16	r2, r2
    hmsc->bot_data[5] = (uint8_t)((blk_nbr - 1U) >> 16);
 801c6e2:	7468      	strb	r0, [r5, #17]
    hmsc->bot_data[6] = (uint8_t)((blk_nbr - 1U) >>  8);
 801c6e4:	74a9      	strb	r1, [r5, #18]
    hmsc->bot_data[8] = 0x02U;
 801c6e6:	2002      	movs	r0, #2
    hmsc->bot_data_length = 12U;
 801c6e8:	210c      	movs	r1, #12
    hmsc->bot_data[7] = (uint8_t)(blk_nbr - 1U);
 801c6ea:	74eb      	strb	r3, [r5, #19]
    hmsc->bot_data[8] = 0x02U;
 801c6ec:	82a8      	strh	r0, [r5, #20]
    hmsc->bot_data[10] = (uint8_t)(blk_size >>  8);
 801c6ee:	82ea      	strh	r2, [r5, #22]
    hmsc->bot_data_length = 12U;
 801c6f0:	8169      	strh	r1, [r5, #10]
    return 0;
 801c6f2:	e6c5      	b.n	801c480 <SCSI_ProcessCmd+0x17c>
  if(((USBD_StorageTypeDef *)pdev->pUserData)->GetCapacity(lun, &hmsc->scsi_blk_nbr, &hmsc->scsi_blk_size) != 0)
 801c6f4:	e9d0 73a4 	ldrd	r7, r3, [r0, #656]	; 0x290
 801c6f8:	f507 5282 	add.w	r2, r7, #4160	; 0x1040
 801c6fc:	4608      	mov	r0, r1
 801c6fe:	685b      	ldr	r3, [r3, #4]
 801c700:	321e      	adds	r2, #30
 801c702:	f507 5183 	add.w	r1, r7, #4192	; 0x1060
 801c706:	4798      	blx	r3
 801c708:	4605      	mov	r5, r0
 801c70a:	2800      	cmp	r0, #0
 801c70c:	f040 808b 	bne.w	801c826 <SCSI_ProcessCmd+0x522>
    hmsc->bot_data[0] = (uint8_t)((hmsc->scsi_blk_nbr - 1U) >> 24);
 801c710:	f507 5280 	add.w	r2, r7, #4096	; 0x1000
 801c714:	6e13      	ldr	r3, [r2, #96]	; 0x60
 801c716:	3b01      	subs	r3, #1
 801c718:	0e19      	lsrs	r1, r3, #24
 801c71a:	7339      	strb	r1, [r7, #12]
    hmsc->bot_data[1] = (uint8_t)((hmsc->scsi_blk_nbr - 1U) >> 16);
 801c71c:	0c19      	lsrs	r1, r3, #16
 801c71e:	7379      	strb	r1, [r7, #13]
    hmsc->bot_data[2] = (uint8_t)((hmsc->scsi_blk_nbr - 1U) >>  8);
 801c720:	0a19      	lsrs	r1, r3, #8
 801c722:	73b9      	strb	r1, [r7, #14]
    hmsc->bot_data[3] = (uint8_t)(hmsc->scsi_blk_nbr - 1U);
 801c724:	73fb      	strb	r3, [r7, #15]
    hmsc->bot_data[4] = (uint8_t)(hmsc->scsi_blk_size >>  24);
 801c726:	f8b2 305e 	ldrh.w	r3, [r2, #94]	; 0x5e
 801c72a:	8238      	strh	r0, [r7, #16]
    hmsc->bot_data_length = 8U;
 801c72c:	2208      	movs	r2, #8
 801c72e:	ba5b      	rev16	r3, r3
    hmsc->bot_data[6] = (uint8_t)(hmsc->scsi_blk_size >>  8);
 801c730:	827b      	strh	r3, [r7, #18]
    hmsc->bot_data_length = 8U;
 801c732:	817a      	strh	r2, [r7, #10]
    return 0;
 801c734:	e667      	b.n	801c406 <SCSI_ProcessCmd+0x102>
    hmsc->bot_data[len] = MSC_Mode_Sense10_data[len];
 801c736:	4aac      	ldr	r2, [pc, #688]	; (801c9e8 <SCSI_ProcessCmd+0x6e4>)
 801c738:	e7ae      	b.n	801c698 <SCSI_ProcessCmd+0x394>
      hmsc->bot_data[len] = MSC_Page00_Inquiry_Data[len];
 801c73a:	4bac      	ldr	r3, [pc, #688]	; (801c9ec <SCSI_ProcessCmd+0x6e8>)
    hmsc->bot_data_length = len;
 801c73c:	2107      	movs	r1, #7
      hmsc->bot_data[len] = MSC_Page00_Inquiry_Data[len];
 801c73e:	681a      	ldr	r2, [r3, #0]
 801c740:	889c      	ldrh	r4, [r3, #4]
 801c742:	799b      	ldrb	r3, [r3, #6]
 801c744:	8204      	strh	r4, [r0, #16]
    hmsc->bot_data_length = len;
 801c746:	8141      	strh	r1, [r0, #10]
      hmsc->bot_data[len] = MSC_Page00_Inquiry_Data[len];
 801c748:	60c2      	str	r2, [r0, #12]
 801c74a:	7483      	strb	r3, [r0, #18]
 801c74c:	e698      	b.n	801c480 <SCSI_ProcessCmd+0x17c>
  USBD_MSC_BOT_HandleTypeDef  *hmsc = (USBD_MSC_BOT_HandleTypeDef*)pdev->pClassData;
 801c74e:	f8d4 2290 	ldr.w	r2, [r4, #656]	; 0x290
  hmsc->scsi_sense[hmsc->scsi_sense_tail].Skey  = sKey;
 801c752:	f502 5180 	add.w	r1, r2, #4096	; 0x1000
 801c756:	2002      	movs	r0, #2
 801c758:	f891 305d 	ldrb.w	r3, [r1, #93]	; 0x5d
 801c75c:	eb02 02c3 	add.w	r2, r2, r3, lsl #3
  hmsc->scsi_sense_tail++;
 801c760:	3301      	adds	r3, #1
  hmsc->scsi_sense[hmsc->scsi_sense_tail].Skey  = sKey;
 801c762:	f502 5280 	add.w	r2, r2, #4096	; 0x1000
  hmsc->scsi_sense_tail++;
 801c766:	b2db      	uxtb	r3, r3
  if (hmsc->scsi_sense_tail == SENSE_LIST_DEEPTH)
 801c768:	2b04      	cmp	r3, #4
  hmsc->scsi_sense[hmsc->scsi_sense_tail].w.ASC = ASC << 8;
 801c76a:	f882 7040 	strb.w	r7, [r2, #64]	; 0x40
  hmsc->scsi_sense[hmsc->scsi_sense_tail].Skey  = sKey;
 801c76e:	f882 003c 	strb.w	r0, [r2, #60]	; 0x3c
  if (hmsc->scsi_sense_tail == SENSE_LIST_DEEPTH)
 801c772:	f000 8176 	beq.w	801ca62 <SCSI_ProcessCmd+0x75e>
  hmsc->scsi_sense_tail++;
 801c776:	f881 305d 	strb.w	r3, [r1, #93]	; 0x5d
 801c77a:	e681      	b.n	801c480 <SCSI_ProcessCmd+0x17c>
 801c77c:	46c1      	mov	r9, r8
 801c77e:	f508 5780 	add.w	r7, r8, #4096	; 0x1000
 801c782:	e750      	b.n	801c626 <SCSI_ProcessCmd+0x322>
*/

static int8_t SCSI_ProcessWrite (USBD_HandleTypeDef  *pdev, uint8_t lun)
{
  USBD_MSC_BOT_HandleTypeDef *hmsc = (USBD_MSC_BOT_HandleTypeDef*) pdev->pClassData;
  uint32_t len = hmsc->scsi_blk_len * hmsc->scsi_blk_size;
 801c784:	f8b8 305e 	ldrh.w	r3, [r8, #94]	; 0x5e
 801c788:	f8d8 2068 	ldr.w	r2, [r8, #104]	; 0x68
 801c78c:	fb02 f503 	mul.w	r5, r2, r3

  len = MIN(len, MSC_MEDIA_PACKET);

  if(((USBD_StorageTypeDef *)pdev->pUserData)->Write(lun, hmsc->bot_data,
 801c790:	f8d4 2294 	ldr.w	r2, [r4, #660]	; 0x294
  len = MIN(len, MSC_MEDIA_PACKET);
 801c794:	f5b5 5f80 	cmp.w	r5, #4096	; 0x1000
  if(((USBD_StorageTypeDef *)pdev->pUserData)->Write(lun, hmsc->bot_data,
 801c798:	f107 070c 	add.w	r7, r7, #12
  len = MIN(len, MSC_MEDIA_PACKET);
 801c79c:	bf28      	it	cs
 801c79e:	f44f 5580 	movcs.w	r5, #4096	; 0x1000
  if(((USBD_StorageTypeDef *)pdev->pUserData)->Write(lun, hmsc->bot_data,
 801c7a2:	6956      	ldr	r6, [r2, #20]
                             hmsc->scsi_blk_addr,
                             (len / hmsc->scsi_blk_size)) < 0)
 801c7a4:	fbb5 f3f3 	udiv	r3, r5, r3
  if(((USBD_StorageTypeDef *)pdev->pUserData)->Write(lun, hmsc->bot_data,
 801c7a8:	4608      	mov	r0, r1
 801c7aa:	f8d8 2064 	ldr.w	r2, [r8, #100]	; 0x64
 801c7ae:	b29b      	uxth	r3, r3
 801c7b0:	4639      	mov	r1, r7
 801c7b2:	47b0      	blx	r6
 801c7b4:	2800      	cmp	r0, #0
 801c7b6:	f2c0 8163 	blt.w	801ca80 <SCSI_ProcessCmd+0x77c>

    return -1;
  }

  hmsc->scsi_blk_addr += (len / hmsc->scsi_blk_size);
  hmsc->scsi_blk_len -= (len / hmsc->scsi_blk_size);
 801c7ba:	e9d8 1319 	ldrd	r1, r3, [r8, #100]	; 0x64

  /* case 12 : Ho = Do */
  hmsc->csw.dDataResidue -= len;
 801c7be:	f8d8 0034 	ldr.w	r0, [r8, #52]	; 0x34
  hmsc->scsi_blk_addr += (len / hmsc->scsi_blk_size);
 801c7c2:	f8b8 205e 	ldrh.w	r2, [r8, #94]	; 0x5e
  hmsc->csw.dDataResidue -= len;
 801c7c6:	1b40      	subs	r0, r0, r5
  hmsc->scsi_blk_addr += (len / hmsc->scsi_blk_size);
 801c7c8:	fbb5 f5f2 	udiv	r5, r5, r2
 801c7cc:	4429      	add	r1, r5
  hmsc->scsi_blk_len -= (len / hmsc->scsi_blk_size);
 801c7ce:	1b5d      	subs	r5, r3, r5
 801c7d0:	e9c8 1519 	strd	r1, r5, [r8, #100]	; 0x64
  hmsc->csw.dDataResidue -= len;
 801c7d4:	f8c8 0034 	str.w	r0, [r8, #52]	; 0x34

  if (hmsc->scsi_blk_len == 0U)
 801c7d8:	b925      	cbnz	r5, 801c7e4 <SCSI_ProcessCmd+0x4e0>
  {
    MSC_BOT_SendCSW (pdev, USBD_CSW_CMD_PASSED);
 801c7da:	4629      	mov	r1, r5
 801c7dc:	4620      	mov	r0, r4
 801c7de:	f7ff fd43 	bl	801c268 <MSC_BOT_SendCSW>
 801c7e2:	e610      	b.n	801c406 <SCSI_ProcessCmd+0x102>
  }
  else
  {
    len = MIN((hmsc->scsi_blk_len * hmsc->scsi_blk_size), MSC_MEDIA_PACKET);
 801c7e4:	fb02 f505 	mul.w	r5, r2, r5
 801c7e8:	f5b5 5f80 	cmp.w	r5, #4096	; 0x1000
 801c7ec:	bf28      	it	cs
 801c7ee:	f44f 5580 	movcs.w	r5, #4096	; 0x1000
    /* Prepare EP to Receive next packet */
    USBD_LL_PrepareReceive (pdev, MSC_EPOUT_ADDR, hmsc->bot_data, len);
 801c7f2:	b2ab      	uxth	r3, r5
 801c7f4:	463a      	mov	r2, r7
 801c7f6:	2101      	movs	r1, #1
 801c7f8:	4620      	mov	r0, r4
 801c7fa:	f008 fabf 	bl	8024d7c <USBD_LL_PrepareReceive>
  return 0;
 801c7fe:	2500      	movs	r5, #0
 801c800:	e601      	b.n	801c406 <SCSI_ProcessCmd+0x102>
  hmsc->scsi_sense[hmsc->scsi_sense_tail].Skey  = sKey;
 801c802:	f891 205d 	ldrb.w	r2, [r1, #93]	; 0x5d
 801c806:	eb06 03c2 	add.w	r3, r6, r2, lsl #3
 801c80a:	2005      	movs	r0, #5
 801c80c:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
  hmsc->scsi_sense_tail++;
 801c810:	3201      	adds	r2, #1
 801c812:	b2d2      	uxtb	r2, r2
  if (hmsc->scsi_sense_tail == SENSE_LIST_DEEPTH)
 801c814:	2a04      	cmp	r2, #4
  hmsc->scsi_sense[hmsc->scsi_sense_tail].Skey  = sKey;
 801c816:	f883 003c 	strb.w	r0, [r3, #60]	; 0x3c
  hmsc->scsi_sense[hmsc->scsi_sense_tail].w.ASC = ASC << 8;
 801c81a:	f883 5040 	strb.w	r5, [r3, #64]	; 0x40
  if (hmsc->scsi_sense_tail == SENSE_LIST_DEEPTH)
 801c81e:	d016      	beq.n	801c84e <SCSI_ProcessCmd+0x54a>
  hmsc->scsi_sense_tail++;
 801c820:	f881 205d 	strb.w	r2, [r1, #93]	; 0x5d
 801c824:	e62c      	b.n	801c480 <SCSI_ProcessCmd+0x17c>
  USBD_MSC_BOT_HandleTypeDef  *hmsc = (USBD_MSC_BOT_HandleTypeDef*)pdev->pClassData;
 801c826:	f8d4 2290 	ldr.w	r2, [r4, #656]	; 0x290
  hmsc->scsi_sense[hmsc->scsi_sense_tail].Skey  = sKey;
 801c82a:	f502 5180 	add.w	r1, r2, #4096	; 0x1000
 801c82e:	2002      	movs	r0, #2
 801c830:	f891 305d 	ldrb.w	r3, [r1, #93]	; 0x5d
 801c834:	eb02 02c3 	add.w	r2, r2, r3, lsl #3
  hmsc->scsi_sense_tail++;
 801c838:	3301      	adds	r3, #1
  hmsc->scsi_sense[hmsc->scsi_sense_tail].Skey  = sKey;
 801c83a:	f502 5280 	add.w	r2, r2, #4096	; 0x1000
  hmsc->scsi_sense_tail++;
 801c83e:	b2db      	uxtb	r3, r3
  hmsc->scsi_sense[hmsc->scsi_sense_tail].w.ASC = ASC << 8;
 801c840:	2500      	movs	r5, #0
  if (hmsc->scsi_sense_tail == SENSE_LIST_DEEPTH)
 801c842:	2b04      	cmp	r3, #4
  hmsc->scsi_sense[hmsc->scsi_sense_tail].Skey  = sKey;
 801c844:	f882 003c 	strb.w	r0, [r2, #60]	; 0x3c
  hmsc->scsi_sense[hmsc->scsi_sense_tail].w.ASC = ASC << 8;
 801c848:	f882 5040 	strb.w	r5, [r2, #64]	; 0x40
  if (hmsc->scsi_sense_tail == SENSE_LIST_DEEPTH)
 801c84c:	d193      	bne.n	801c776 <SCSI_ProcessCmd+0x472>
    hmsc->scsi_sense_tail = 0U;
 801c84e:	f881 505d 	strb.w	r5, [r1, #93]	; 0x5d
 801c852:	e5d8      	b.n	801c406 <SCSI_ProcessCmd+0x102>
  hmsc->scsi_sense[hmsc->scsi_sense_tail].Skey  = sKey;
 801c854:	f501 5080 	add.w	r0, r1, #4096	; 0x1000
 801c858:	2405      	movs	r4, #5
 801c85a:	f890 205d 	ldrb.w	r2, [r0, #93]	; 0x5d
 801c85e:	eb01 03c2 	add.w	r3, r1, r2, lsl #3
  hmsc->scsi_sense_tail++;
 801c862:	3201      	adds	r2, #1
  hmsc->scsi_sense[hmsc->scsi_sense_tail].Skey  = sKey;
 801c864:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
  hmsc->scsi_sense_tail++;
 801c868:	b2d2      	uxtb	r2, r2
  hmsc->scsi_sense[hmsc->scsi_sense_tail].w.ASC = ASC << 8;
 801c86a:	2500      	movs	r5, #0
  if (hmsc->scsi_sense_tail == SENSE_LIST_DEEPTH)
 801c86c:	2a04      	cmp	r2, #4
  hmsc->scsi_sense[hmsc->scsi_sense_tail].Skey  = sKey;
 801c86e:	f883 403c 	strb.w	r4, [r3, #60]	; 0x3c
  hmsc->scsi_sense[hmsc->scsi_sense_tail].w.ASC = ASC << 8;
 801c872:	f883 5040 	strb.w	r5, [r3, #64]	; 0x40
  if (hmsc->scsi_sense_tail == SENSE_LIST_DEEPTH)
 801c876:	f000 80c9 	beq.w	801ca0c <SCSI_ProcessCmd+0x708>
  hmsc->scsi_sense_tail++;
 801c87a:	f880 205d 	strb.w	r2, [r0, #93]	; 0x5d
 801c87e:	e5ff      	b.n	801c480 <SCSI_ProcessCmd+0x17c>
  USBD_MSC_BOT_HandleTypeDef  *hmsc = (USBD_MSC_BOT_HandleTypeDef*)pdev->pClassData;
 801c880:	f8d4 2290 	ldr.w	r2, [r4, #656]	; 0x290
  hmsc->scsi_sense[hmsc->scsi_sense_tail].Skey  = sKey;
 801c884:	f502 5180 	add.w	r1, r2, #4096	; 0x1000
 801c888:	2002      	movs	r0, #2
 801c88a:	f891 305d 	ldrb.w	r3, [r1, #93]	; 0x5d
 801c88e:	eb02 02c3 	add.w	r2, r2, r3, lsl #3
  hmsc->scsi_sense_tail++;
 801c892:	3301      	adds	r3, #1
  hmsc->scsi_sense[hmsc->scsi_sense_tail].Skey  = sKey;
 801c894:	f502 5280 	add.w	r2, r2, #4096	; 0x1000
  hmsc->scsi_sense_tail++;
 801c898:	b2db      	uxtb	r3, r3
  if (hmsc->scsi_sense_tail == SENSE_LIST_DEEPTH)
 801c89a:	2b04      	cmp	r3, #4
  hmsc->scsi_sense[hmsc->scsi_sense_tail].w.ASC = ASC << 8;
 801c89c:	f882 7040 	strb.w	r7, [r2, #64]	; 0x40
  hmsc->scsi_sense[hmsc->scsi_sense_tail].Skey  = sKey;
 801c8a0:	f882 003c 	strb.w	r0, [r2, #60]	; 0x3c
  if (hmsc->scsi_sense_tail == SENSE_LIST_DEEPTH)
 801c8a4:	f47f af67 	bne.w	801c776 <SCSI_ProcessCmd+0x472>
    hmsc->scsi_sense_tail = 0U;
 801c8a8:	f881 705d 	strb.w	r7, [r1, #93]	; 0x5d
 801c8ac:	e5e8      	b.n	801c480 <SCSI_ProcessCmd+0x17c>
  hmsc->scsi_sense[hmsc->scsi_sense_tail].Skey  = sKey;
 801c8ae:	f897 205d 	ldrb.w	r2, [r7, #93]	; 0x5d
 801c8b2:	4613      	mov	r3, r2
  hmsc->scsi_sense_tail++;
 801c8b4:	3301      	adds	r3, #1
 801c8b6:	eb09 02c2 	add.w	r2, r9, r2, lsl #3
  hmsc->scsi_sense[hmsc->scsi_sense_tail].Skey  = sKey;
 801c8ba:	f502 5280 	add.w	r2, r2, #4096	; 0x1000
  hmsc->scsi_sense_tail++;
 801c8be:	b2db      	uxtb	r3, r3
  hmsc->scsi_sense[hmsc->scsi_sense_tail].Skey  = sKey;
 801c8c0:	2105      	movs	r1, #5
  if (hmsc->scsi_sense_tail == SENSE_LIST_DEEPTH)
 801c8c2:	2b04      	cmp	r3, #4
  hmsc->scsi_sense[hmsc->scsi_sense_tail].Skey  = sKey;
 801c8c4:	f882 103c 	strb.w	r1, [r2, #60]	; 0x3c
  hmsc->scsi_sense[hmsc->scsi_sense_tail].w.ASC = ASC << 8;
 801c8c8:	f882 5040 	strb.w	r5, [r2, #64]	; 0x40
  if (hmsc->scsi_sense_tail == SENSE_LIST_DEEPTH)
 801c8cc:	f000 80c6 	beq.w	801ca5c <SCSI_ProcessCmd+0x758>
  hmsc->scsi_sense_tail++;
 801c8d0:	f887 305d 	strb.w	r3, [r7, #93]	; 0x5d
 801c8d4:	e5d4      	b.n	801c480 <SCSI_ProcessCmd+0x17c>
  USBD_MSC_BOT_HandleTypeDef  *hmsc = (USBD_MSC_BOT_HandleTypeDef*)pdev->pClassData;
 801c8d6:	f8d4 2290 	ldr.w	r2, [r4, #656]	; 0x290
  hmsc->scsi_sense[hmsc->scsi_sense_tail].Skey  = sKey;
 801c8da:	f502 5180 	add.w	r1, r2, #4096	; 0x1000
 801c8de:	2002      	movs	r0, #2
 801c8e0:	f891 305d 	ldrb.w	r3, [r1, #93]	; 0x5d
 801c8e4:	eb02 02c3 	add.w	r2, r2, r3, lsl #3
  hmsc->scsi_sense_tail++;
 801c8e8:	3301      	adds	r3, #1
  hmsc->scsi_sense[hmsc->scsi_sense_tail].Skey  = sKey;
 801c8ea:	f502 5280 	add.w	r2, r2, #4096	; 0x1000
  hmsc->scsi_sense_tail++;
 801c8ee:	b2db      	uxtb	r3, r3
  if (hmsc->scsi_sense_tail == SENSE_LIST_DEEPTH)
 801c8f0:	2b04      	cmp	r3, #4
  hmsc->scsi_sense[hmsc->scsi_sense_tail].w.ASC = ASC << 8;
 801c8f2:	f882 9040 	strb.w	r9, [r2, #64]	; 0x40
  hmsc->scsi_sense[hmsc->scsi_sense_tail].Skey  = sKey;
 801c8f6:	f882 003c 	strb.w	r0, [r2, #60]	; 0x3c
  if (hmsc->scsi_sense_tail == SENSE_LIST_DEEPTH)
 801c8fa:	f47f af3c 	bne.w	801c776 <SCSI_ProcessCmd+0x472>
    hmsc->scsi_sense_tail = 0U;
 801c8fe:	f881 905d 	strb.w	r9, [r1, #93]	; 0x5d
  return 0;
 801c902:	464d      	mov	r5, r9
 801c904:	e57f      	b.n	801c406 <SCSI_ProcessCmd+0x102>
  USBD_MSC_BOT_HandleTypeDef  *hmsc = (USBD_MSC_BOT_HandleTypeDef*)pdev->pClassData;
 801c906:	f8d4 2290 	ldr.w	r2, [r4, #656]	; 0x290
  hmsc->scsi_sense[hmsc->scsi_sense_tail].Skey  = sKey;
 801c90a:	f502 5180 	add.w	r1, r2, #4096	; 0x1000
 801c90e:	2004      	movs	r0, #4
 801c910:	f891 305d 	ldrb.w	r3, [r1, #93]	; 0x5d
 801c914:	eb02 02c3 	add.w	r2, r2, r3, lsl #3
  hmsc->scsi_sense_tail++;
 801c918:	3301      	adds	r3, #1
  hmsc->scsi_sense[hmsc->scsi_sense_tail].Skey  = sKey;
 801c91a:	f502 5280 	add.w	r2, r2, #4096	; 0x1000
  hmsc->scsi_sense_tail++;
 801c91e:	b2db      	uxtb	r3, r3
  hmsc->scsi_sense[hmsc->scsi_sense_tail].w.ASC = ASC << 8;
 801c920:	2500      	movs	r5, #0
  if (hmsc->scsi_sense_tail == SENSE_LIST_DEEPTH)
 801c922:	4283      	cmp	r3, r0
  hmsc->scsi_sense[hmsc->scsi_sense_tail].Skey  = sKey;
 801c924:	f882 003c 	strb.w	r0, [r2, #60]	; 0x3c
  hmsc->scsi_sense[hmsc->scsi_sense_tail].w.ASC = ASC << 8;
 801c928:	f882 5040 	strb.w	r5, [r2, #64]	; 0x40
  if (hmsc->scsi_sense_tail == SENSE_LIST_DEEPTH)
 801c92c:	f47f af23 	bne.w	801c776 <SCSI_ProcessCmd+0x472>
 801c930:	e78d      	b.n	801c84e <SCSI_ProcessCmd+0x54a>
  hmsc->scsi_sense[hmsc->scsi_sense_tail].Skey  = sKey;
 801c932:	f893 205d 	ldrb.w	r2, [r3, #93]	; 0x5d
 801c936:	4614      	mov	r4, r2
 801c938:	eb01 02c2 	add.w	r2, r1, r2, lsl #3
  hmsc->scsi_sense_tail++;
 801c93c:	1c61      	adds	r1, r4, #1
  hmsc->scsi_sense[hmsc->scsi_sense_tail].Skey  = sKey;
 801c93e:	f502 5280 	add.w	r2, r2, #4096	; 0x1000
  hmsc->scsi_sense_tail++;
 801c942:	b2c9      	uxtb	r1, r1
  hmsc->scsi_sense[hmsc->scsi_sense_tail].Skey  = sKey;
 801c944:	2405      	movs	r4, #5
  if (hmsc->scsi_sense_tail == SENSE_LIST_DEEPTH)
 801c946:	2904      	cmp	r1, #4
  hmsc->scsi_sense[hmsc->scsi_sense_tail].Skey  = sKey;
 801c948:	f882 403c 	strb.w	r4, [r2, #60]	; 0x3c
  hmsc->scsi_sense[hmsc->scsi_sense_tail].w.ASC = ASC << 8;
 801c94c:	f882 0040 	strb.w	r0, [r2, #64]	; 0x40
  if (hmsc->scsi_sense_tail == SENSE_LIST_DEEPTH)
 801c950:	f000 808b 	beq.w	801ca6a <SCSI_ProcessCmd+0x766>
  hmsc->scsi_sense_tail++;
 801c954:	f883 105d 	strb.w	r1, [r3, #93]	; 0x5d
 801c958:	e592      	b.n	801c480 <SCSI_ProcessCmd+0x17c>
  hmsc->scsi_sense[hmsc->scsi_sense_tail].Skey  = sKey;
 801c95a:	f89a 205d 	ldrb.w	r2, [sl, #93]	; 0x5d
 801c95e:	4613      	mov	r3, r2
  hmsc->scsi_sense_tail++;
 801c960:	3301      	adds	r3, #1
 801c962:	eb08 02c2 	add.w	r2, r8, r2, lsl #3
  hmsc->scsi_sense[hmsc->scsi_sense_tail].Skey  = sKey;
 801c966:	f502 5280 	add.w	r2, r2, #4096	; 0x1000
  hmsc->scsi_sense_tail++;
 801c96a:	b2db      	uxtb	r3, r3
  hmsc->scsi_sense[hmsc->scsi_sense_tail].Skey  = sKey;
 801c96c:	2105      	movs	r1, #5
  if (hmsc->scsi_sense_tail == SENSE_LIST_DEEPTH)
 801c96e:	2b04      	cmp	r3, #4
  hmsc->scsi_sense[hmsc->scsi_sense_tail].Skey  = sKey;
 801c970:	f882 103c 	strb.w	r1, [r2, #60]	; 0x3c
  hmsc->scsi_sense[hmsc->scsi_sense_tail].w.ASC = ASC << 8;
 801c974:	f882 7040 	strb.w	r7, [r2, #64]	; 0x40
  if (hmsc->scsi_sense_tail == SENSE_LIST_DEEPTH)
 801c978:	d07b      	beq.n	801ca72 <SCSI_ProcessCmd+0x76e>
  hmsc->scsi_sense_tail++;
 801c97a:	f88a 305d 	strb.w	r3, [sl, #93]	; 0x5d
 801c97e:	e57f      	b.n	801c480 <SCSI_ProcessCmd+0x17c>
  USBD_MSC_BOT_HandleTypeDef  *hmsc = (USBD_MSC_BOT_HandleTypeDef*)pdev->pClassData;
 801c980:	f8d4 3290 	ldr.w	r3, [r4, #656]	; 0x290
  hmsc->scsi_sense[hmsc->scsi_sense_tail].Skey  = sKey;
 801c984:	f503 5180 	add.w	r1, r3, #4096	; 0x1000
  return 0;
 801c988:	2500      	movs	r5, #0
 801c98a:	f891 005d 	ldrb.w	r0, [r1, #93]	; 0x5d
  hmsc->scsi_sense[hmsc->scsi_sense_tail].Skey  = sKey;
 801c98e:	f891 205d 	ldrb.w	r2, [r1, #93]	; 0x5d
 801c992:	eb03 03c0 	add.w	r3, r3, r0, lsl #3
 801c996:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
  hmsc->scsi_sense_tail++;
 801c99a:	3201      	adds	r2, #1
 801c99c:	b2d2      	uxtb	r2, r2
  hmsc->scsi_sense[hmsc->scsi_sense_tail].Skey  = sKey;
 801c99e:	2002      	movs	r0, #2
  hmsc->scsi_sense[hmsc->scsi_sense_tail].w.ASC = ASC << 8;
 801c9a0:	f883 8040 	strb.w	r8, [r3, #64]	; 0x40
  hmsc->scsi_sense[hmsc->scsi_sense_tail].Skey  = sKey;
 801c9a4:	f883 003c 	strb.w	r0, [r3, #60]	; 0x3c
  if (hmsc->scsi_sense_tail == SENSE_LIST_DEEPTH)
 801c9a8:	2a04      	cmp	r2, #4
    hmsc->bot_state = USBD_BOT_NO_DATA;
 801c9aa:	f04f 0305 	mov.w	r3, #5
  hmsc->scsi_sense_tail++;
 801c9ae:	bf14      	ite	ne
 801c9b0:	f881 205d 	strbne.w	r2, [r1, #93]	; 0x5d
    hmsc->scsi_sense_tail = 0U;
 801c9b4:	f881 805d 	strbeq.w	r8, [r1, #93]	; 0x5d
    hmsc->bot_state = USBD_BOT_NO_DATA;
 801c9b8:	723b      	strb	r3, [r7, #8]
    return -1;
 801c9ba:	e524      	b.n	801c406 <SCSI_ProcessCmd+0x102>
  hmsc->scsi_sense[hmsc->scsi_sense_tail].Skey  = sKey;
 801c9bc:	f893 105d 	ldrb.w	r1, [r3, #93]	; 0x5d
 801c9c0:	460a      	mov	r2, r1
  hmsc->scsi_sense_tail++;
 801c9c2:	3201      	adds	r2, #1
 801c9c4:	eb07 01c1 	add.w	r1, r7, r1, lsl #3
  hmsc->scsi_sense[hmsc->scsi_sense_tail].Skey  = sKey;
 801c9c8:	f501 5180 	add.w	r1, r1, #4096	; 0x1000
  hmsc->scsi_sense_tail++;
 801c9cc:	b2d2      	uxtb	r2, r2
  hmsc->scsi_sense[hmsc->scsi_sense_tail].Skey  = sKey;
 801c9ce:	2005      	movs	r0, #5
  hmsc->scsi_sense[hmsc->scsi_sense_tail].w.ASC = ASC << 8;
 801c9d0:	2500      	movs	r5, #0
  if (hmsc->scsi_sense_tail == SENSE_LIST_DEEPTH)
 801c9d2:	2a04      	cmp	r2, #4
  hmsc->scsi_sense[hmsc->scsi_sense_tail].Skey  = sKey;
 801c9d4:	f881 003c 	strb.w	r0, [r1, #60]	; 0x3c
  hmsc->scsi_sense[hmsc->scsi_sense_tail].w.ASC = ASC << 8;
 801c9d8:	f881 5040 	strb.w	r5, [r1, #64]	; 0x40
  if (hmsc->scsi_sense_tail == SENSE_LIST_DEEPTH)
 801c9dc:	d04d      	beq.n	801ca7a <SCSI_ProcessCmd+0x776>
  hmsc->scsi_sense_tail++;
 801c9de:	f883 205d 	strb.w	r2, [r3, #93]	; 0x5d
 801c9e2:	e54d      	b.n	801c480 <SCSI_ProcessCmd+0x17c>
 801c9e4:	08035b4c 	.word	0x08035b4c
 801c9e8:	08035b44 	.word	0x08035b44
 801c9ec:	08035b54 	.word	0x08035b54
  USBD_MSC_BOT_HandleTypeDef  *hmsc = (USBD_MSC_BOT_HandleTypeDef*)pdev->pClassData;
 801c9f0:	f8d4 3290 	ldr.w	r3, [r4, #656]	; 0x290
  hmsc->scsi_sense[hmsc->scsi_sense_tail].Skey  = sKey;
 801c9f4:	f503 5180 	add.w	r1, r3, #4096	; 0x1000
 801c9f8:	f891 005d 	ldrb.w	r0, [r1, #93]	; 0x5d
 801c9fc:	4602      	mov	r2, r0
 801c9fe:	eb03 03c0 	add.w	r3, r3, r0, lsl #3
 801ca02:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
  hmsc->scsi_sense_tail++;
 801ca06:	3201      	adds	r2, #1
  hmsc->scsi_sense[hmsc->scsi_sense_tail].Skey  = sKey;
 801ca08:	2002      	movs	r0, #2
 801ca0a:	e702      	b.n	801c812 <SCSI_ProcessCmd+0x50e>
    hmsc->scsi_sense_tail = 0U;
 801ca0c:	f880 505d 	strb.w	r5, [r0, #93]	; 0x5d
 801ca10:	e4f9      	b.n	801c406 <SCSI_ProcessCmd+0x102>
  hmsc->scsi_sense[hmsc->scsi_sense_tail].Skey  = sKey;
 801ca12:	f891 205d 	ldrb.w	r2, [r1, #93]	; 0x5d
 801ca16:	4613      	mov	r3, r2
  hmsc->scsi_sense_tail++;
 801ca18:	3301      	adds	r3, #1
 801ca1a:	eb06 02c2 	add.w	r2, r6, r2, lsl #3
  hmsc->scsi_sense[hmsc->scsi_sense_tail].Skey  = sKey;
 801ca1e:	f502 5280 	add.w	r2, r2, #4096	; 0x1000
  hmsc->scsi_sense_tail++;
 801ca22:	b2db      	uxtb	r3, r3
  hmsc->scsi_sense[hmsc->scsi_sense_tail].Skey  = sKey;
 801ca24:	2005      	movs	r0, #5
  if (hmsc->scsi_sense_tail == SENSE_LIST_DEEPTH)
 801ca26:	2b04      	cmp	r3, #4
  hmsc->scsi_sense[hmsc->scsi_sense_tail].Skey  = sKey;
 801ca28:	f882 003c 	strb.w	r0, [r2, #60]	; 0x3c
  hmsc->scsi_sense[hmsc->scsi_sense_tail].w.ASC = ASC << 8;
 801ca2c:	f882 5040 	strb.w	r5, [r2, #64]	; 0x40
  if (hmsc->scsi_sense_tail == SENSE_LIST_DEEPTH)
 801ca30:	f47f aea1 	bne.w	801c776 <SCSI_ProcessCmd+0x472>
 801ca34:	e70b      	b.n	801c84e <SCSI_ProcessCmd+0x54a>
  hmsc->scsi_sense[hmsc->scsi_sense_tail].Skey  = sKey;
 801ca36:	f898 205d 	ldrb.w	r2, [r8, #93]	; 0x5d
 801ca3a:	4613      	mov	r3, r2
  hmsc->scsi_sense_tail++;
 801ca3c:	3301      	adds	r3, #1
 801ca3e:	eb07 02c2 	add.w	r2, r7, r2, lsl #3
  hmsc->scsi_sense[hmsc->scsi_sense_tail].Skey  = sKey;
 801ca42:	f502 5280 	add.w	r2, r2, #4096	; 0x1000
  hmsc->scsi_sense_tail++;
 801ca46:	b2db      	uxtb	r3, r3
  hmsc->scsi_sense[hmsc->scsi_sense_tail].Skey  = sKey;
 801ca48:	2105      	movs	r1, #5
  if (hmsc->scsi_sense_tail == SENSE_LIST_DEEPTH)
 801ca4a:	2b04      	cmp	r3, #4
  hmsc->scsi_sense[hmsc->scsi_sense_tail].Skey  = sKey;
 801ca4c:	f882 103c 	strb.w	r1, [r2, #60]	; 0x3c
  hmsc->scsi_sense[hmsc->scsi_sense_tail].w.ASC = ASC << 8;
 801ca50:	f882 5040 	strb.w	r5, [r2, #64]	; 0x40
  if (hmsc->scsi_sense_tail == SENSE_LIST_DEEPTH)
 801ca54:	d02b      	beq.n	801caae <SCSI_ProcessCmd+0x7aa>
  hmsc->scsi_sense_tail++;
 801ca56:	f888 305d 	strb.w	r3, [r8, #93]	; 0x5d
 801ca5a:	e511      	b.n	801c480 <SCSI_ProcessCmd+0x17c>
    hmsc->scsi_sense_tail = 0U;
 801ca5c:	f887 505d 	strb.w	r5, [r7, #93]	; 0x5d
 801ca60:	e4d1      	b.n	801c406 <SCSI_ProcessCmd+0x102>
 801ca62:	f881 705d 	strb.w	r7, [r1, #93]	; 0x5d
  return 0;
 801ca66:	463d      	mov	r5, r7
 801ca68:	e4cd      	b.n	801c406 <SCSI_ProcessCmd+0x102>
    hmsc->scsi_sense_tail = 0U;
 801ca6a:	f883 005d 	strb.w	r0, [r3, #93]	; 0x5d
  return 0;
 801ca6e:	4605      	mov	r5, r0
 801ca70:	e4c9      	b.n	801c406 <SCSI_ProcessCmd+0x102>
    hmsc->scsi_sense_tail = 0U;
 801ca72:	f88a 705d 	strb.w	r7, [sl, #93]	; 0x5d
  return 0;
 801ca76:	463d      	mov	r5, r7
 801ca78:	e4c5      	b.n	801c406 <SCSI_ProcessCmd+0x102>
    hmsc->scsi_sense_tail = 0U;
 801ca7a:	f883 505d 	strb.w	r5, [r3, #93]	; 0x5d
 801ca7e:	e4c2      	b.n	801c406 <SCSI_ProcessCmd+0x102>
  USBD_MSC_BOT_HandleTypeDef  *hmsc = (USBD_MSC_BOT_HandleTypeDef*)pdev->pClassData;
 801ca80:	f8d4 3290 	ldr.w	r3, [r4, #656]	; 0x290
  hmsc->scsi_sense[hmsc->scsi_sense_tail].Skey  = sKey;
 801ca84:	f503 5180 	add.w	r1, r3, #4096	; 0x1000
 801ca88:	2004      	movs	r0, #4
 801ca8a:	f891 405d 	ldrb.w	r4, [r1, #93]	; 0x5d
 801ca8e:	4622      	mov	r2, r4
 801ca90:	eb03 03c4 	add.w	r3, r3, r4, lsl #3
  hmsc->scsi_sense_tail++;
 801ca94:	3201      	adds	r2, #1
  hmsc->scsi_sense[hmsc->scsi_sense_tail].Skey  = sKey;
 801ca96:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
  hmsc->scsi_sense_tail++;
 801ca9a:	b2d2      	uxtb	r2, r2
  hmsc->scsi_sense[hmsc->scsi_sense_tail].w.ASC = ASC << 8;
 801ca9c:	2500      	movs	r5, #0
  if (hmsc->scsi_sense_tail == SENSE_LIST_DEEPTH)
 801ca9e:	4282      	cmp	r2, r0
  hmsc->scsi_sense[hmsc->scsi_sense_tail].Skey  = sKey;
 801caa0:	f883 003c 	strb.w	r0, [r3, #60]	; 0x3c
  hmsc->scsi_sense[hmsc->scsi_sense_tail].w.ASC = ASC << 8;
 801caa4:	f883 5040 	strb.w	r5, [r3, #64]	; 0x40
  if (hmsc->scsi_sense_tail == SENSE_LIST_DEEPTH)
 801caa8:	f47f aeba 	bne.w	801c820 <SCSI_ProcessCmd+0x51c>
 801caac:	e6cf      	b.n	801c84e <SCSI_ProcessCmd+0x54a>
    hmsc->scsi_sense_tail = 0U;
 801caae:	f888 505d 	strb.w	r5, [r8, #93]	; 0x5d
 801cab2:	e4a8      	b.n	801c406 <SCSI_ProcessCmd+0x102>

0801cab4 <SCSI_SenseCode>:
  USBD_MSC_BOT_HandleTypeDef  *hmsc = (USBD_MSC_BOT_HandleTypeDef*)pdev->pClassData;
 801cab4:	f8d0 3290 	ldr.w	r3, [r0, #656]	; 0x290
  hmsc->scsi_sense[hmsc->scsi_sense_tail].Skey  = sKey;
 801cab8:	f503 5080 	add.w	r0, r3, #4096	; 0x1000
 801cabc:	f890 105d 	ldrb.w	r1, [r0, #93]	; 0x5d
 801cac0:	eb03 03c1 	add.w	r3, r3, r1, lsl #3
 801cac4:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
  hmsc->scsi_sense_tail++;
 801cac8:	3101      	adds	r1, #1
 801caca:	b2c9      	uxtb	r1, r1
  hmsc->scsi_sense[hmsc->scsi_sense_tail].Skey  = sKey;
 801cacc:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c
  if (hmsc->scsi_sense_tail == SENSE_LIST_DEEPTH)
 801cad0:	2904      	cmp	r1, #4
  hmsc->scsi_sense[hmsc->scsi_sense_tail].w.ASC = ASC << 8;
 801cad2:	f04f 0200 	mov.w	r2, #0
 801cad6:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
  hmsc->scsi_sense_tail++;
 801cada:	bf14      	ite	ne
 801cadc:	f880 105d 	strbne.w	r1, [r0, #93]	; 0x5d
    hmsc->scsi_sense_tail = 0U;
 801cae0:	f880 205d 	strbeq.w	r2, [r0, #93]	; 0x5d
}
 801cae4:	4770      	bx	lr
 801cae6:	bf00      	nop

0801cae8 <USBD_Init>:
* @retval None
*/
USBD_StatusTypeDef USBD_Init(USBD_HandleTypeDef *pdev, USBD_DescriptorsTypeDef *pdesc, uint8_t id)
{
  /* Check whether the USB Host handle is valid */
  if(pdev == NULL)
 801cae8:	b188      	cbz	r0, 801cb0e <USBD_Init+0x26>
{
 801caea:	b508      	push	{r3, lr}
#endif
    return USBD_FAIL;
  }

  /* Unlink previous class*/
  if(pdev->pClass != NULL)
 801caec:	f8d0 328c 	ldr.w	r3, [r0, #652]	; 0x28c
 801caf0:	b113      	cbz	r3, 801caf8 <USBD_Init+0x10>
  {
    pdev->pClass = NULL;
 801caf2:	2300      	movs	r3, #0
 801caf4:	f8c0 328c 	str.w	r3, [r0, #652]	; 0x28c
  }

  /* Assign USBD Descriptors */
  if(pdesc != NULL)
 801caf8:	b109      	cbz	r1, 801cafe <USBD_Init+0x16>
  {
    pdev->pDesc = pdesc;
 801cafa:	f8c0 1288 	str.w	r1, [r0, #648]	; 0x288
  }

  /* Set Device initial State */
  pdev->dev_state  = USBD_STATE_DEFAULT;
 801cafe:	2301      	movs	r3, #1
 801cb00:	f880 3274 	strb.w	r3, [r0, #628]	; 0x274
  pdev->id = id;
 801cb04:	7002      	strb	r2, [r0, #0]
  /* Initialize low level driver */
  USBD_LL_Init(pdev);
 801cb06:	f008 f897 	bl	8024c38 <USBD_LL_Init>

  return USBD_OK;
 801cb0a:	2000      	movs	r0, #0
}
 801cb0c:	bd08      	pop	{r3, pc}
    return USBD_FAIL;
 801cb0e:	2002      	movs	r0, #2
}
 801cb10:	4770      	bx	lr
 801cb12:	bf00      	nop

0801cb14 <USBD_DeInit>:
*         Re-Initialize th device library
* @param  pdev: device instance
* @retval status: status
*/
USBD_StatusTypeDef USBD_DeInit(USBD_HandleTypeDef *pdev)
{
 801cb14:	b510      	push	{r4, lr}
  /* Set Default State */
  pdev->dev_state  = USBD_STATE_DEFAULT;
 801cb16:	2201      	movs	r2, #1

  /* Free Class Resources */
  pdev->pClass->DeInit(pdev, (uint8_t)pdev->dev_config);
 801cb18:	f8d0 328c 	ldr.w	r3, [r0, #652]	; 0x28c
  pdev->dev_state  = USBD_STATE_DEFAULT;
 801cb1c:	f880 2274 	strb.w	r2, [r0, #628]	; 0x274
  pdev->pClass->DeInit(pdev, (uint8_t)pdev->dev_config);
 801cb20:	7901      	ldrb	r1, [r0, #4]
 801cb22:	685b      	ldr	r3, [r3, #4]
{
 801cb24:	4604      	mov	r4, r0
  pdev->pClass->DeInit(pdev, (uint8_t)pdev->dev_config);
 801cb26:	4798      	blx	r3

    /* Stop the low level driver  */
  USBD_LL_Stop(pdev);
 801cb28:	4620      	mov	r0, r4
 801cb2a:	f008 f8d1 	bl	8024cd0 <USBD_LL_Stop>

  /* Initialize low level driver */
  USBD_LL_DeInit(pdev);
 801cb2e:	4620      	mov	r0, r4
 801cb30:	f008 f8be 	bl	8024cb0 <USBD_LL_DeInit>

  return USBD_OK;
}
 801cb34:	2000      	movs	r0, #0
 801cb36:	bd10      	pop	{r4, pc}

0801cb38 <USBD_RegisterClass>:
  * @retval USBD Status
  */
USBD_StatusTypeDef  USBD_RegisterClass(USBD_HandleTypeDef *pdev, USBD_ClassTypeDef *pclass)
{
  USBD_StatusTypeDef   status = USBD_OK;
  if(pclass != 0)
 801cb38:	b119      	cbz	r1, 801cb42 <USBD_RegisterClass+0xa>
  {
    /* link the class to the USB Device handle */
    pdev->pClass = pclass;
 801cb3a:	f8c0 128c 	str.w	r1, [r0, #652]	; 0x28c
    status = USBD_OK;
 801cb3e:	2000      	movs	r0, #0
 801cb40:	4770      	bx	lr
  else
  {
#if (USBD_DEBUG_LEVEL > 1U)
    USBD_ErrLog("Invalid Class handle");
#endif
    status = USBD_FAIL;
 801cb42:	2002      	movs	r0, #2
  }

  return status;
}
 801cb44:	4770      	bx	lr
 801cb46:	bf00      	nop

0801cb48 <USBD_Start>:
  *         Start the USB Device Core.
  * @param  pdev: Device Handle
  * @retval USBD Status
  */
USBD_StatusTypeDef  USBD_Start  (USBD_HandleTypeDef *pdev)
{
 801cb48:	b508      	push	{r3, lr}

  /* Start the low level driver  */
  USBD_LL_Start(pdev);
 801cb4a:	f008 f8b9 	bl	8024cc0 <USBD_LL_Start>

  return USBD_OK;
}
 801cb4e:	2000      	movs	r0, #0
 801cb50:	bd08      	pop	{r3, pc}
 801cb52:	bf00      	nop

0801cb54 <USBD_Stop>:
  *         Stop the USB Device Core.
  * @param  pdev: Device Handle
  * @retval USBD Status
  */
USBD_StatusTypeDef  USBD_Stop   (USBD_HandleTypeDef *pdev)
{
 801cb54:	b510      	push	{r4, lr}
  /* Free Class Resources */
  pdev->pClass->DeInit(pdev, (uint8_t)pdev->dev_config);
 801cb56:	f8d0 328c 	ldr.w	r3, [r0, #652]	; 0x28c
 801cb5a:	7901      	ldrb	r1, [r0, #4]
 801cb5c:	685b      	ldr	r3, [r3, #4]
{
 801cb5e:	4604      	mov	r4, r0
  pdev->pClass->DeInit(pdev, (uint8_t)pdev->dev_config);
 801cb60:	4798      	blx	r3

  /* Stop the low level driver  */
  USBD_LL_Stop(pdev);
 801cb62:	4620      	mov	r0, r4
 801cb64:	f008 f8b4 	bl	8024cd0 <USBD_LL_Stop>

  return USBD_OK;
}
 801cb68:	2000      	movs	r0, #0
 801cb6a:	bd10      	pop	{r4, pc}

0801cb6c <USBD_SetClassConfig>:
* @param  cfgidx: configuration index
* @retval status
*/

USBD_StatusTypeDef USBD_SetClassConfig(USBD_HandleTypeDef  *pdev, uint8_t cfgidx)
{
 801cb6c:	b508      	push	{r3, lr}
  USBD_StatusTypeDef   ret = USBD_FAIL;

  if(pdev->pClass != NULL)
 801cb6e:	f8d0 328c 	ldr.w	r3, [r0, #652]	; 0x28c
 801cb72:	b11b      	cbz	r3, 801cb7c <USBD_SetClassConfig+0x10>
  {
    /* Set configuration  and Start the Class*/
    if(pdev->pClass->Init(pdev, cfgidx) == 0U)
 801cb74:	681b      	ldr	r3, [r3, #0]
 801cb76:	4798      	blx	r3
 801cb78:	b900      	cbnz	r0, 801cb7c <USBD_SetClassConfig+0x10>
      ret = USBD_OK;
    }
  }

  return ret;
}
 801cb7a:	bd08      	pop	{r3, pc}
  USBD_StatusTypeDef   ret = USBD_FAIL;
 801cb7c:	2002      	movs	r0, #2
}
 801cb7e:	bd08      	pop	{r3, pc}

0801cb80 <USBD_ClrClassConfig>:
* @param  pdev: device instance
* @param  cfgidx: configuration index
* @retval status: USBD_StatusTypeDef
*/
USBD_StatusTypeDef USBD_ClrClassConfig(USBD_HandleTypeDef  *pdev, uint8_t cfgidx)
{
 801cb80:	b508      	push	{r3, lr}
  /* Clear configuration  and De-initialize the Class process*/
  pdev->pClass->DeInit(pdev, cfgidx);
 801cb82:	f8d0 328c 	ldr.w	r3, [r0, #652]	; 0x28c
 801cb86:	685b      	ldr	r3, [r3, #4]
 801cb88:	4798      	blx	r3
  return USBD_OK;
}
 801cb8a:	2000      	movs	r0, #0
 801cb8c:	bd08      	pop	{r3, pc}
 801cb8e:	bf00      	nop

0801cb90 <USBD_LL_SetupStage>:
*         Handle the setup stage
* @param  pdev: device instance
* @retval status
*/
USBD_StatusTypeDef USBD_LL_SetupStage(USBD_HandleTypeDef *pdev, uint8_t *psetup)
{
 801cb90:	b538      	push	{r3, r4, r5, lr}
 801cb92:	4604      	mov	r4, r0
  USBD_ParseSetupRequest(&pdev->request, psetup);
 801cb94:	f500 7520 	add.w	r5, r0, #640	; 0x280
 801cb98:	4628      	mov	r0, r5
 801cb9a:	f000 fb6f 	bl	801d27c <USBD_ParseSetupRequest>

  pdev->ep0_state = USBD_EP0_SETUP;

  pdev->ep0_data_len = pdev->request.wLength;

  switch (pdev->request.bmRequest & 0x1FU)
 801cb9e:	f894 1280 	ldrb.w	r1, [r4, #640]	; 0x280
  pdev->ep0_data_len = pdev->request.wLength;
 801cba2:	f8b4 2286 	ldrh.w	r2, [r4, #646]	; 0x286
 801cba6:	f8c4 2270 	str.w	r2, [r4, #624]	; 0x270
  pdev->ep0_state = USBD_EP0_SETUP;
 801cbaa:	2301      	movs	r3, #1
 801cbac:	f8c4 326c 	str.w	r3, [r4, #620]	; 0x26c
  switch (pdev->request.bmRequest & 0x1FU)
 801cbb0:	f001 031f 	and.w	r3, r1, #31
 801cbb4:	2b01      	cmp	r3, #1
 801cbb6:	d009      	beq.n	801cbcc <USBD_LL_SetupStage+0x3c>
 801cbb8:	2b02      	cmp	r3, #2
 801cbba:	d013      	beq.n	801cbe4 <USBD_LL_SetupStage+0x54>
 801cbbc:	b163      	cbz	r3, 801cbd8 <USBD_LL_SetupStage+0x48>
  case USB_REQ_RECIPIENT_ENDPOINT:
    USBD_StdEPReq(pdev, &pdev->request);
    break;

  default:
    USBD_LL_StallEP(pdev, (pdev->request.bmRequest & 0x80U));
 801cbbe:	f001 0180 	and.w	r1, r1, #128	; 0x80
 801cbc2:	4620      	mov	r0, r4
 801cbc4:	f008 f8a6 	bl	8024d14 <USBD_LL_StallEP>
    break;
  }

  return USBD_OK;
}
 801cbc8:	2000      	movs	r0, #0
 801cbca:	bd38      	pop	{r3, r4, r5, pc}
    USBD_StdItfReq(pdev, &pdev->request);
 801cbcc:	4629      	mov	r1, r5
 801cbce:	4620      	mov	r0, r4
 801cbd0:	f000 fa84 	bl	801d0dc <USBD_StdItfReq>
}
 801cbd4:	2000      	movs	r0, #0
 801cbd6:	bd38      	pop	{r3, r4, r5, pc}
    USBD_StdDevReq (pdev, &pdev->request);
 801cbd8:	4629      	mov	r1, r5
 801cbda:	4620      	mov	r0, r4
 801cbdc:	f000 f906 	bl	801cdec <USBD_StdDevReq>
}
 801cbe0:	2000      	movs	r0, #0
 801cbe2:	bd38      	pop	{r3, r4, r5, pc}
    USBD_StdEPReq(pdev, &pdev->request);
 801cbe4:	4629      	mov	r1, r5
 801cbe6:	4620      	mov	r0, r4
 801cbe8:	f000 faac 	bl	801d144 <USBD_StdEPReq>
}
 801cbec:	2000      	movs	r0, #0
 801cbee:	bd38      	pop	{r3, r4, r5, pc}

0801cbf0 <USBD_LL_DataOutStage>:
* @param  epnum: endpoint index
* @retval status
*/
USBD_StatusTypeDef USBD_LL_DataOutStage(USBD_HandleTypeDef *pdev,
                                        uint8_t epnum, uint8_t *pdata)
{
 801cbf0:	b538      	push	{r3, r4, r5, lr}
 801cbf2:	4605      	mov	r5, r0
  USBD_EndpointTypeDef    *pep;

  if(epnum == 0U)
 801cbf4:	b969      	cbnz	r1, 801cc12 <USBD_LL_DataOutStage+0x22>
 801cbf6:	4613      	mov	r3, r2
  {
    pep = &pdev->ep_out[0];

    if ( pdev->ep0_state == USBD_EP0_DATA_OUT)
 801cbf8:	f8d0 226c 	ldr.w	r2, [r0, #620]	; 0x26c
 801cbfc:	2a03      	cmp	r2, #3
 801cbfe:	d015      	beq.n	801cc2c <USBD_LL_DataOutStage+0x3c>
        USBD_CtlSendStatus(pdev);
      }
    }
    else
    {
      if (pdev->ep0_state == USBD_EP0_STATUS_OUT)
 801cc00:	2a05      	cmp	r2, #5
 801cc02:	460c      	mov	r4, r1
 801cc04:	d10e      	bne.n	801cc24 <USBD_LL_DataOutStage+0x34>
      {
        /*
         * STATUS PHASE completed, update ep0_state to idle
         */
        pdev->ep0_state = USBD_EP0_IDLE;
 801cc06:	f8c5 126c 	str.w	r1, [r5, #620]	; 0x26c
        USBD_LL_StallEP(pdev, 0U);
 801cc0a:	f008 f883 	bl	8024d14 <USBD_LL_StallEP>
  {
    /* should never be in this condition */
    return USBD_FAIL;
  }

  return USBD_OK;
 801cc0e:	4620      	mov	r0, r4
}
 801cc10:	bd38      	pop	{r3, r4, r5, pc}
  else if((pdev->pClass->DataOut != NULL) &&
 801cc12:	f8d0 328c 	ldr.w	r3, [r0, #652]	; 0x28c
 801cc16:	699b      	ldr	r3, [r3, #24]
 801cc18:	b133      	cbz	r3, 801cc28 <USBD_LL_DataOutStage+0x38>
 801cc1a:	f890 2274 	ldrb.w	r2, [r0, #628]	; 0x274
 801cc1e:	2a03      	cmp	r2, #3
 801cc20:	d102      	bne.n	801cc28 <USBD_LL_DataOutStage+0x38>
    pdev->pClass->DataOut(pdev, epnum);
 801cc22:	4798      	blx	r3
  return USBD_OK;
 801cc24:	2000      	movs	r0, #0
}
 801cc26:	bd38      	pop	{r3, r4, r5, pc}
    return USBD_FAIL;
 801cc28:	2002      	movs	r0, #2
}
 801cc2a:	bd38      	pop	{r3, r4, r5, pc}
      if(pep->rem_length > pep->maxpacket)
 801cc2c:	e9d0 1253 	ldrd	r1, r2, [r0, #332]	; 0x14c
 801cc30:	4291      	cmp	r1, r2
 801cc32:	d90c      	bls.n	801cc4e <USBD_LL_DataOutStage+0x5e>
        pep->rem_length -=  pep->maxpacket;
 801cc34:	1a89      	subs	r1, r1, r2
        USBD_CtlContinueRx (pdev,
 801cc36:	428a      	cmp	r2, r1
 801cc38:	bf88      	it	hi
 801cc3a:	b28a      	uxthhi	r2, r1
        pep->rem_length -=  pep->maxpacket;
 801cc3c:	f8c0 114c 	str.w	r1, [r0, #332]	; 0x14c
        USBD_CtlContinueRx (pdev,
 801cc40:	bf98      	it	ls
 801cc42:	b292      	uxthls	r2, r2
 801cc44:	4619      	mov	r1, r3
 801cc46:	f000 fb79 	bl	801d33c <USBD_CtlContinueRx>
  return USBD_OK;
 801cc4a:	2000      	movs	r0, #0
}
 801cc4c:	bd38      	pop	{r3, r4, r5, pc}
        if((pdev->pClass->EP0_RxReady != NULL)&&
 801cc4e:	f8d0 328c 	ldr.w	r3, [r0, #652]	; 0x28c
 801cc52:	691b      	ldr	r3, [r3, #16]
 801cc54:	b11b      	cbz	r3, 801cc5e <USBD_LL_DataOutStage+0x6e>
 801cc56:	f890 2274 	ldrb.w	r2, [r0, #628]	; 0x274
 801cc5a:	2a03      	cmp	r2, #3
 801cc5c:	d004      	beq.n	801cc68 <USBD_LL_DataOutStage+0x78>
        USBD_CtlSendStatus(pdev);
 801cc5e:	4628      	mov	r0, r5
 801cc60:	f000 fb74 	bl	801d34c <USBD_CtlSendStatus>
  return USBD_OK;
 801cc64:	2000      	movs	r0, #0
}
 801cc66:	bd38      	pop	{r3, r4, r5, pc}
          pdev->pClass->EP0_RxReady(pdev);
 801cc68:	4798      	blx	r3
 801cc6a:	e7f8      	b.n	801cc5e <USBD_LL_DataOutStage+0x6e>

0801cc6c <USBD_LL_DataInStage>:
* @param  epnum: endpoint index
* @retval status
*/
USBD_StatusTypeDef USBD_LL_DataInStage(USBD_HandleTypeDef *pdev, uint8_t epnum,
                                       uint8_t *pdata)
{
 801cc6c:	b570      	push	{r4, r5, r6, lr}
 801cc6e:	4604      	mov	r4, r0
  USBD_EndpointTypeDef *pep;

  if(epnum == 0U)
 801cc70:	b989      	cbnz	r1, 801cc96 <USBD_LL_DataInStage+0x2a>
 801cc72:	4613      	mov	r3, r2
  {
    pep = &pdev->ep_in[0];

    if ( pdev->ep0_state == USBD_EP0_DATA_IN)
 801cc74:	f8d0 226c 	ldr.w	r2, [r0, #620]	; 0x26c
 801cc78:	2a02      	cmp	r2, #2
 801cc7a:	d01c      	beq.n	801ccb6 <USBD_LL_DataInStage+0x4a>
        }
      }
    }
    else
    {
      if ((pdev->ep0_state == USBD_EP0_STATUS_IN) ||
 801cc7c:	f032 0304 	bics.w	r3, r2, #4
 801cc80:	d102      	bne.n	801cc88 <USBD_LL_DataInStage+0x1c>
          (pdev->ep0_state == USBD_EP0_IDLE))
      {
        USBD_LL_StallEP(pdev, 0x80U);
 801cc82:	2180      	movs	r1, #128	; 0x80
 801cc84:	f008 f846 	bl	8024d14 <USBD_LL_StallEP>
      }
    }

    if (pdev->dev_test_mode == 1U)
 801cc88:	f894 3278 	ldrb.w	r3, [r4, #632]	; 0x278
 801cc8c:	2b01      	cmp	r3, #1
    {
      USBD_RunTestMode(pdev);
      pdev->dev_test_mode = 0U;
 801cc8e:	f04f 0000 	mov.w	r0, #0
    if (pdev->dev_test_mode == 1U)
 801cc92:	d00d      	beq.n	801ccb0 <USBD_LL_DataInStage+0x44>
    /* should never be in this condition */
    return USBD_FAIL;
  }

  return USBD_OK;
}
 801cc94:	bd70      	pop	{r4, r5, r6, pc}
  else if((pdev->pClass->DataIn != NULL) &&
 801cc96:	f8d0 328c 	ldr.w	r3, [r0, #652]	; 0x28c
 801cc9a:	695b      	ldr	r3, [r3, #20]
 801cc9c:	b133      	cbz	r3, 801ccac <USBD_LL_DataInStage+0x40>
 801cc9e:	f890 2274 	ldrb.w	r2, [r0, #628]	; 0x274
 801cca2:	2a03      	cmp	r2, #3
 801cca4:	d102      	bne.n	801ccac <USBD_LL_DataInStage+0x40>
    pdev->pClass->DataIn(pdev, epnum);
 801cca6:	4798      	blx	r3
  return USBD_OK;
 801cca8:	2000      	movs	r0, #0
}
 801ccaa:	bd70      	pop	{r4, r5, r6, pc}
    return USBD_FAIL;
 801ccac:	2002      	movs	r0, #2
}
 801ccae:	bd70      	pop	{r4, r5, r6, pc}
      pdev->dev_test_mode = 0U;
 801ccb0:	f884 0278 	strb.w	r0, [r4, #632]	; 0x278
}
 801ccb4:	bd70      	pop	{r4, r5, r6, pc}
      if(pep->rem_length > pep->maxpacket)
 801ccb6:	e9d0 6208 	ldrd	r6, r2, [r0, #32]
 801ccba:	4296      	cmp	r6, r2
 801ccbc:	d827      	bhi.n	801cd0e <USBD_LL_DataInStage+0xa2>
        if((pep->total_length % pep->maxpacket == 0U) &&
 801ccbe:	69c3      	ldr	r3, [r0, #28]
 801ccc0:	fbb3 f5f2 	udiv	r5, r3, r2
 801ccc4:	fb02 3515 	mls	r5, r2, r5, r3
 801ccc8:	b95d      	cbnz	r5, 801cce2 <USBD_LL_DataInStage+0x76>
 801ccca:	429a      	cmp	r2, r3
 801cccc:	d809      	bhi.n	801cce2 <USBD_LL_DataInStage+0x76>
           (pep->total_length >= pep->maxpacket) &&
 801ccce:	f8d0 2270 	ldr.w	r2, [r0, #624]	; 0x270
 801ccd2:	4293      	cmp	r3, r2
 801ccd4:	d205      	bcs.n	801cce2 <USBD_LL_DataInStage+0x76>
          USBD_CtlContinueSendData(pdev, NULL, 0U);
 801ccd6:	462a      	mov	r2, r5
 801ccd8:	f000 fb28 	bl	801d32c <USBD_CtlContinueSendData>
          pdev->ep0_data_len = 0U;
 801ccdc:	f8c4 5270 	str.w	r5, [r4, #624]	; 0x270
 801cce0:	e01c      	b.n	801cd1c <USBD_LL_DataInStage+0xb0>
          if((pdev->pClass->EP0_TxSent != NULL)&&
 801cce2:	f8d4 328c 	ldr.w	r3, [r4, #652]	; 0x28c
 801cce6:	68db      	ldr	r3, [r3, #12]
 801cce8:	b11b      	cbz	r3, 801ccf2 <USBD_LL_DataInStage+0x86>
 801ccea:	f894 2274 	ldrb.w	r2, [r4, #628]	; 0x274
 801ccee:	2a03      	cmp	r2, #3
 801ccf0:	d01b      	beq.n	801cd2a <USBD_LL_DataInStage+0xbe>
          USBD_LL_StallEP(pdev, 0x80U);
 801ccf2:	2180      	movs	r1, #128	; 0x80
 801ccf4:	4620      	mov	r0, r4
 801ccf6:	f008 f80d 	bl	8024d14 <USBD_LL_StallEP>
          USBD_CtlReceiveStatus(pdev);
 801ccfa:	4620      	mov	r0, r4
 801ccfc:	f000 fb32 	bl	801d364 <USBD_CtlReceiveStatus>
    if (pdev->dev_test_mode == 1U)
 801cd00:	f894 3278 	ldrb.w	r3, [r4, #632]	; 0x278
 801cd04:	2b01      	cmp	r3, #1
      pdev->dev_test_mode = 0U;
 801cd06:	f04f 0000 	mov.w	r0, #0
    if (pdev->dev_test_mode == 1U)
 801cd0a:	d1c3      	bne.n	801cc94 <USBD_LL_DataInStage+0x28>
 801cd0c:	e7d0      	b.n	801ccb0 <USBD_LL_DataInStage+0x44>
        pep->rem_length -= pep->maxpacket;
 801cd0e:	1ab2      	subs	r2, r6, r2
 801cd10:	460d      	mov	r5, r1
 801cd12:	6202      	str	r2, [r0, #32]
        USBD_CtlContinueSendData (pdev, pdata, (uint16_t)pep->rem_length);
 801cd14:	4619      	mov	r1, r3
 801cd16:	b292      	uxth	r2, r2
 801cd18:	f000 fb08 	bl	801d32c <USBD_CtlContinueSendData>
          USBD_LL_PrepareReceive (pdev, 0U, NULL, 0U);
 801cd1c:	462b      	mov	r3, r5
 801cd1e:	462a      	mov	r2, r5
 801cd20:	4629      	mov	r1, r5
 801cd22:	4620      	mov	r0, r4
 801cd24:	f008 f82a 	bl	8024d7c <USBD_LL_PrepareReceive>
 801cd28:	e7ae      	b.n	801cc88 <USBD_LL_DataInStage+0x1c>
            pdev->pClass->EP0_TxSent(pdev);
 801cd2a:	4620      	mov	r0, r4
 801cd2c:	4798      	blx	r3
 801cd2e:	e7e0      	b.n	801ccf2 <USBD_LL_DataInStage+0x86>

0801cd30 <USBD_LL_Reset>:
* @param  pdev: device instance
* @retval status
*/

USBD_StatusTypeDef USBD_LL_Reset(USBD_HandleTypeDef  *pdev)
{
 801cd30:	b570      	push	{r4, r5, r6, lr}
  /* Open EP0 OUT */
  USBD_LL_OpenEP(pdev, 0x00U, USBD_EP_TYPE_CTRL, USB_MAX_EP0_SIZE);
 801cd32:	2200      	movs	r2, #0
{
 801cd34:	4604      	mov	r4, r0
  USBD_LL_OpenEP(pdev, 0x00U, USBD_EP_TYPE_CTRL, USB_MAX_EP0_SIZE);
 801cd36:	4611      	mov	r1, r2
  pdev->ep_out[0x00U & 0xFU].is_used = 1U;
 801cd38:	2501      	movs	r5, #1

  pdev->ep_out[0].maxpacket = USB_MAX_EP0_SIZE;
 801cd3a:	2640      	movs	r6, #64	; 0x40
  USBD_LL_OpenEP(pdev, 0x00U, USBD_EP_TYPE_CTRL, USB_MAX_EP0_SIZE);
 801cd3c:	2340      	movs	r3, #64	; 0x40
 801cd3e:	f007 ffcf 	bl	8024ce0 <USBD_LL_OpenEP>

  /* Open EP0 IN */
  USBD_LL_OpenEP(pdev, 0x80U, USBD_EP_TYPE_CTRL, USB_MAX_EP0_SIZE);
 801cd42:	4633      	mov	r3, r6
 801cd44:	2180      	movs	r1, #128	; 0x80
  pdev->ep_out[0x00U & 0xFU].is_used = 1U;
 801cd46:	f8c4 5144 	str.w	r5, [r4, #324]	; 0x144
  pdev->ep_out[0].maxpacket = USB_MAX_EP0_SIZE;
 801cd4a:	f8c4 6150 	str.w	r6, [r4, #336]	; 0x150
  USBD_LL_OpenEP(pdev, 0x80U, USBD_EP_TYPE_CTRL, USB_MAX_EP0_SIZE);
 801cd4e:	2200      	movs	r2, #0
 801cd50:	4620      	mov	r0, r4
 801cd52:	f007 ffc5 	bl	8024ce0 <USBD_LL_OpenEP>
  pdev->dev_state = USBD_STATE_DEFAULT;
  pdev->ep0_state = USBD_EP0_IDLE;
  pdev->dev_config= 0U;
  pdev->dev_remote_wakeup = 0U;

  if (pdev->pClassData)
 801cd56:	f8d4 3290 	ldr.w	r3, [r4, #656]	; 0x290
  pdev->ep_in[0x80U & 0xFU].is_used = 1U;
 801cd5a:	61a5      	str	r5, [r4, #24]
  pdev->ep0_state = USBD_EP0_IDLE;
 801cd5c:	2100      	movs	r1, #0
  pdev->ep_in[0].maxpacket = USB_MAX_EP0_SIZE;
 801cd5e:	6266      	str	r6, [r4, #36]	; 0x24
  pdev->dev_state = USBD_STATE_DEFAULT;
 801cd60:	f884 5274 	strb.w	r5, [r4, #628]	; 0x274
  pdev->ep0_state = USBD_EP0_IDLE;
 801cd64:	f8c4 126c 	str.w	r1, [r4, #620]	; 0x26c
  pdev->dev_config= 0U;
 801cd68:	6061      	str	r1, [r4, #4]
  pdev->dev_remote_wakeup = 0U;
 801cd6a:	f8c4 127c 	str.w	r1, [r4, #636]	; 0x27c
  if (pdev->pClassData)
 801cd6e:	b123      	cbz	r3, 801cd7a <USBD_LL_Reset+0x4a>
  {
    pdev->pClass->DeInit(pdev, (uint8_t)pdev->dev_config);
 801cd70:	f8d4 328c 	ldr.w	r3, [r4, #652]	; 0x28c
 801cd74:	4620      	mov	r0, r4
 801cd76:	685b      	ldr	r3, [r3, #4]
 801cd78:	4798      	blx	r3
  }

  return USBD_OK;
}
 801cd7a:	2000      	movs	r0, #0
 801cd7c:	bd70      	pop	{r4, r5, r6, pc}
 801cd7e:	bf00      	nop

0801cd80 <USBD_LL_SetSpeed>:
* @param  pdev: device instance
* @retval status
*/
USBD_StatusTypeDef USBD_LL_SetSpeed(USBD_HandleTypeDef  *pdev, USBD_SpeedTypeDef speed)
{
  pdev->dev_speed = speed;
 801cd80:	7401      	strb	r1, [r0, #16]
  return USBD_OK;
}
 801cd82:	2000      	movs	r0, #0
 801cd84:	4770      	bx	lr
 801cd86:	bf00      	nop

0801cd88 <USBD_LL_Suspend>:
* @retval status
*/

USBD_StatusTypeDef USBD_LL_Suspend(USBD_HandleTypeDef  *pdev)
{
  pdev->dev_old_state =  pdev->dev_state;
 801cd88:	f890 2274 	ldrb.w	r2, [r0, #628]	; 0x274
 801cd8c:	f880 2275 	strb.w	r2, [r0, #629]	; 0x275
  pdev->dev_state  = USBD_STATE_SUSPENDED;
 801cd90:	2304      	movs	r3, #4
 801cd92:	f880 3274 	strb.w	r3, [r0, #628]	; 0x274
  return USBD_OK;
}
 801cd96:	2000      	movs	r0, #0
 801cd98:	4770      	bx	lr
 801cd9a:	bf00      	nop

0801cd9c <USBD_LL_Resume>:
* @param  pdev: device instance
* @retval status
*/

USBD_StatusTypeDef USBD_LL_Resume(USBD_HandleTypeDef  *pdev)
{
 801cd9c:	4603      	mov	r3, r0
  pdev->dev_state = pdev->dev_old_state;
  return USBD_OK;
}
 801cd9e:	2000      	movs	r0, #0
  pdev->dev_state = pdev->dev_old_state;
 801cda0:	f893 2275 	ldrb.w	r2, [r3, #629]	; 0x275
 801cda4:	f883 2274 	strb.w	r2, [r3, #628]	; 0x274
}
 801cda8:	4770      	bx	lr
 801cdaa:	bf00      	nop

0801cdac <USBD_LL_SOF>:
* @retval status
*/

USBD_StatusTypeDef USBD_LL_SOF(USBD_HandleTypeDef  *pdev)
{
  if(pdev->dev_state == USBD_STATE_CONFIGURED)
 801cdac:	f890 2274 	ldrb.w	r2, [r0, #628]	; 0x274
 801cdb0:	2a03      	cmp	r2, #3
 801cdb2:	d001      	beq.n	801cdb8 <USBD_LL_SOF+0xc>
    {
      pdev->pClass->SOF(pdev);
    }
  }
  return USBD_OK;
}
 801cdb4:	2000      	movs	r0, #0
 801cdb6:	4770      	bx	lr
{
 801cdb8:	b508      	push	{r3, lr}
    if(pdev->pClass->SOF != NULL)
 801cdba:	f8d0 328c 	ldr.w	r3, [r0, #652]	; 0x28c
 801cdbe:	69db      	ldr	r3, [r3, #28]
 801cdc0:	b103      	cbz	r3, 801cdc4 <USBD_LL_SOF+0x18>
      pdev->pClass->SOF(pdev);
 801cdc2:	4798      	blx	r3
}
 801cdc4:	2000      	movs	r0, #0
 801cdc6:	bd08      	pop	{r3, pc}

0801cdc8 <USBD_LL_IsoINIncomplete>:
  /* Prevent unused arguments compilation warning */
  UNUSED(pdev);
  UNUSED(epnum);

  return USBD_OK;
}
 801cdc8:	2000      	movs	r0, #0
 801cdca:	4770      	bx	lr

0801cdcc <USBD_LL_IsoOUTIncomplete>:
 801cdcc:	2000      	movs	r0, #0
 801cdce:	4770      	bx	lr

0801cdd0 <USBD_LL_DevConnected>:
 801cdd0:	2000      	movs	r0, #0
 801cdd2:	4770      	bx	lr

0801cdd4 <USBD_LL_DevDisconnected>:
*         Handle device disconnection event
* @param  pdev: device instance
* @retval status
*/
USBD_StatusTypeDef USBD_LL_DevDisconnected(USBD_HandleTypeDef  *pdev)
{
 801cdd4:	b508      	push	{r3, lr}
  /* Free Class Resources */
  pdev->dev_state = USBD_STATE_DEFAULT;
  pdev->pClass->DeInit(pdev, (uint8_t)pdev->dev_config);
 801cdd6:	f8d0 228c 	ldr.w	r2, [r0, #652]	; 0x28c
  pdev->dev_state = USBD_STATE_DEFAULT;
 801cdda:	2101      	movs	r1, #1
 801cddc:	f880 1274 	strb.w	r1, [r0, #628]	; 0x274
  pdev->pClass->DeInit(pdev, (uint8_t)pdev->dev_config);
 801cde0:	6852      	ldr	r2, [r2, #4]
 801cde2:	7901      	ldrb	r1, [r0, #4]
 801cde4:	4790      	blx	r2

  return USBD_OK;
}
 801cde6:	2000      	movs	r0, #0
 801cde8:	bd08      	pop	{r3, pc}
 801cdea:	bf00      	nop

0801cdec <USBD_StdDevReq>:
* @param  pdev: device instance
* @param  req: usb request
* @retval status
*/
USBD_StatusTypeDef  USBD_StdDevReq (USBD_HandleTypeDef *pdev , USBD_SetupReqTypedef  *req)
{
 801cdec:	b530      	push	{r4, r5, lr}
 801cdee:	780b      	ldrb	r3, [r1, #0]
 801cdf0:	f003 0360 	and.w	r3, r3, #96	; 0x60
  USBD_StatusTypeDef ret = USBD_OK;

  switch (req->bmRequest & USB_REQ_TYPE_MASK)
 801cdf4:	2b20      	cmp	r3, #32
{
 801cdf6:	b083      	sub	sp, #12
 801cdf8:	460d      	mov	r5, r1
 801cdfa:	4604      	mov	r4, r0
  switch (req->bmRequest & USB_REQ_TYPE_MASK)
 801cdfc:	d00d      	beq.n	801ce1a <USBD_StdDevReq+0x2e>
 801cdfe:	2b40      	cmp	r3, #64	; 0x40
 801ce00:	d00b      	beq.n	801ce1a <USBD_StdDevReq+0x2e>
 801ce02:	b19b      	cbz	r3, 801ce2c <USBD_StdDevReq+0x40>
*/

void USBD_CtlError( USBD_HandleTypeDef *pdev ,
                            USBD_SetupReqTypedef *req)
{
  USBD_LL_StallEP(pdev , 0x80U);
 801ce04:	2180      	movs	r1, #128	; 0x80
 801ce06:	4620      	mov	r0, r4
 801ce08:	f007 ff84 	bl	8024d14 <USBD_LL_StallEP>
  USBD_LL_StallEP(pdev , 0U);
 801ce0c:	2100      	movs	r1, #0
 801ce0e:	4620      	mov	r0, r4
 801ce10:	f007 ff80 	bl	8024d14 <USBD_LL_StallEP>
}
 801ce14:	2000      	movs	r0, #0
 801ce16:	b003      	add	sp, #12
 801ce18:	bd30      	pop	{r4, r5, pc}
    pdev->pClass->Setup(pdev, req);
 801ce1a:	f8d4 328c 	ldr.w	r3, [r4, #652]	; 0x28c
 801ce1e:	4629      	mov	r1, r5
 801ce20:	689b      	ldr	r3, [r3, #8]
 801ce22:	4620      	mov	r0, r4
 801ce24:	4798      	blx	r3
}
 801ce26:	2000      	movs	r0, #0
 801ce28:	b003      	add	sp, #12
 801ce2a:	bd30      	pop	{r4, r5, pc}
    switch (req->bRequest)
 801ce2c:	784b      	ldrb	r3, [r1, #1]
 801ce2e:	2b09      	cmp	r3, #9
 801ce30:	d8e8      	bhi.n	801ce04 <USBD_StdDevReq+0x18>
 801ce32:	a201      	add	r2, pc, #4	; (adr r2, 801ce38 <USBD_StdDevReq+0x4c>)
 801ce34:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 801ce38:	0801ce93 	.word	0x0801ce93
 801ce3c:	0801cebb 	.word	0x0801cebb
 801ce40:	0801ce05 	.word	0x0801ce05
 801ce44:	0801ced9 	.word	0x0801ced9
 801ce48:	0801ce05 	.word	0x0801ce05
 801ce4c:	0801cee1 	.word	0x0801cee1
 801ce50:	0801cf19 	.word	0x0801cf19
 801ce54:	0801ce05 	.word	0x0801ce05
 801ce58:	0801cf49 	.word	0x0801cf49
 801ce5c:	0801ce61 	.word	0x0801ce61
  cfgidx = (uint8_t)(req->wValue);
 801ce60:	7889      	ldrb	r1, [r1, #2]
 801ce62:	4d9d      	ldr	r5, [pc, #628]	; (801d0d8 <USBD_StdDevReq+0x2ec>)
  if (cfgidx > USBD_MAX_NUM_CONFIGURATION)
 801ce64:	2901      	cmp	r1, #1
  cfgidx = (uint8_t)(req->wValue);
 801ce66:	7029      	strb	r1, [r5, #0]
  if (cfgidx > USBD_MAX_NUM_CONFIGURATION)
 801ce68:	d8cc      	bhi.n	801ce04 <USBD_StdDevReq+0x18>
    switch (pdev->dev_state)
 801ce6a:	f890 3274 	ldrb.w	r3, [r0, #628]	; 0x274
 801ce6e:	2b02      	cmp	r3, #2
 801ce70:	f000 810d 	beq.w	801d08e <USBD_StdDevReq+0x2a2>
 801ce74:	2b03      	cmp	r3, #3
 801ce76:	f000 80f9 	beq.w	801d06c <USBD_StdDevReq+0x280>
  USBD_LL_StallEP(pdev , 0x80U);
 801ce7a:	2180      	movs	r1, #128	; 0x80
 801ce7c:	f007 ff4a 	bl	8024d14 <USBD_LL_StallEP>
  USBD_LL_StallEP(pdev , 0U);
 801ce80:	2100      	movs	r1, #0
 801ce82:	4620      	mov	r0, r4
 801ce84:	f007 ff46 	bl	8024d14 <USBD_LL_StallEP>
      USBD_ClrClassConfig(pdev, cfgidx);
 801ce88:	7829      	ldrb	r1, [r5, #0]
 801ce8a:	4620      	mov	r0, r4
 801ce8c:	f7ff fe78 	bl	801cb80 <USBD_ClrClassConfig>
      break;
 801ce90:	e7c0      	b.n	801ce14 <USBD_StdDevReq+0x28>
  switch (pdev->dev_state)
 801ce92:	f890 3274 	ldrb.w	r3, [r0, #628]	; 0x274
 801ce96:	3b01      	subs	r3, #1
 801ce98:	2b02      	cmp	r3, #2
 801ce9a:	d8b3      	bhi.n	801ce04 <USBD_StdDevReq+0x18>
    if(req->wLength != 0x2U)
 801ce9c:	88ca      	ldrh	r2, [r1, #6]
 801ce9e:	2a02      	cmp	r2, #2
 801cea0:	d1b0      	bne.n	801ce04 <USBD_StdDevReq+0x18>
    if (pdev->dev_remote_wakeup)
 801cea2:	f8d0 327c 	ldr.w	r3, [r0, #636]	; 0x27c
      pdev->dev_config_status |= USB_CONFIG_REMOTE_WAKEUP;
 801cea6:	4601      	mov	r1, r0
 801cea8:	2b00      	cmp	r3, #0
 801ceaa:	bf14      	ite	ne
 801ceac:	4613      	movne	r3, r2
 801ceae:	2300      	moveq	r3, #0
 801ceb0:	f841 3f0c 	str.w	r3, [r1, #12]!
    USBD_CtlSendData (pdev, (uint8_t *)(void *)&pdev->dev_config_status, 2U);
 801ceb4:	f000 fa2c 	bl	801d310 <USBD_CtlSendData>
    break;
 801ceb8:	e7ac      	b.n	801ce14 <USBD_StdDevReq+0x28>
  switch (pdev->dev_state)
 801ceba:	f890 3274 	ldrb.w	r3, [r0, #628]	; 0x274
 801cebe:	3b01      	subs	r3, #1
 801cec0:	2b02      	cmp	r3, #2
 801cec2:	d89f      	bhi.n	801ce04 <USBD_StdDevReq+0x18>
    if (req->wValue == USB_FEATURE_REMOTE_WAKEUP)
 801cec4:	884b      	ldrh	r3, [r1, #2]
 801cec6:	2b01      	cmp	r3, #1
 801cec8:	d1a4      	bne.n	801ce14 <USBD_StdDevReq+0x28>
      pdev->dev_remote_wakeup = 0U;
 801ceca:	2300      	movs	r3, #0
 801cecc:	f8c4 327c 	str.w	r3, [r4, #636]	; 0x27c
      USBD_CtlSendStatus(pdev);
 801ced0:	4620      	mov	r0, r4
 801ced2:	f000 fa3b 	bl	801d34c <USBD_CtlSendStatus>
 801ced6:	e79d      	b.n	801ce14 <USBD_StdDevReq+0x28>
  if (req->wValue == USB_FEATURE_REMOTE_WAKEUP)
 801ced8:	884b      	ldrh	r3, [r1, #2]
 801ceda:	2b01      	cmp	r3, #1
 801cedc:	d19a      	bne.n	801ce14 <USBD_StdDevReq+0x28>
 801cede:	e7f5      	b.n	801cecc <USBD_StdDevReq+0xe0>
  if ((req->wIndex == 0U) && (req->wLength == 0U) && (req->wValue < 128U))
 801cee0:	888b      	ldrh	r3, [r1, #4]
 801cee2:	2b00      	cmp	r3, #0
 801cee4:	d18e      	bne.n	801ce04 <USBD_StdDevReq+0x18>
 801cee6:	88cb      	ldrh	r3, [r1, #6]
 801cee8:	2b00      	cmp	r3, #0
 801ceea:	d18b      	bne.n	801ce04 <USBD_StdDevReq+0x18>
 801ceec:	884d      	ldrh	r5, [r1, #2]
 801ceee:	2d7f      	cmp	r5, #127	; 0x7f
 801cef0:	d888      	bhi.n	801ce04 <USBD_StdDevReq+0x18>
    if (pdev->dev_state == USBD_STATE_CONFIGURED)
 801cef2:	f890 3274 	ldrb.w	r3, [r0, #628]	; 0x274
 801cef6:	2b03      	cmp	r3, #3
 801cef8:	d084      	beq.n	801ce04 <USBD_StdDevReq+0x18>
    dev_addr = (uint8_t)(req->wValue) & 0x7FU;
 801cefa:	b2e9      	uxtb	r1, r5
      pdev->dev_address = dev_addr;
 801cefc:	f880 1276 	strb.w	r1, [r0, #630]	; 0x276
      USBD_LL_SetUSBAddress(pdev, dev_addr);
 801cf00:	f007 ff2c 	bl	8024d5c <USBD_LL_SetUSBAddress>
      USBD_CtlSendStatus(pdev);
 801cf04:	4620      	mov	r0, r4
 801cf06:	f000 fa21 	bl	801d34c <USBD_CtlSendStatus>
      if (dev_addr != 0U)
 801cf0a:	2d00      	cmp	r5, #0
 801cf0c:	f000 80e0 	beq.w	801d0d0 <USBD_StdDevReq+0x2e4>
        pdev->dev_state = USBD_STATE_ADDRESSED;
 801cf10:	2302      	movs	r3, #2
 801cf12:	f884 3274 	strb.w	r3, [r4, #628]	; 0x274
 801cf16:	e77d      	b.n	801ce14 <USBD_StdDevReq+0x28>
  switch (req->wValue >> 8)
 801cf18:	884a      	ldrh	r2, [r1, #2]
 801cf1a:	0a13      	lsrs	r3, r2, #8
 801cf1c:	3b01      	subs	r3, #1
 801cf1e:	2b06      	cmp	r3, #6
 801cf20:	f63f af70 	bhi.w	801ce04 <USBD_StdDevReq+0x18>
 801cf24:	a101      	add	r1, pc, #4	; (adr r1, 801cf2c <USBD_StdDevReq+0x140>)
 801cf26:	f851 f023 	ldr.w	pc, [r1, r3, lsl #2]
 801cf2a:	bf00      	nop
 801cf2c:	0801cfef 	.word	0x0801cfef
 801cf30:	0801cfd7 	.word	0x0801cfd7
 801cf34:	0801cfc5 	.word	0x0801cfc5
 801cf38:	0801ce05 	.word	0x0801ce05
 801cf3c:	0801ce05 	.word	0x0801ce05
 801cf40:	0801cfaf 	.word	0x0801cfaf
 801cf44:	0801cf6f 	.word	0x0801cf6f
  if (req->wLength != 1U)
 801cf48:	88ca      	ldrh	r2, [r1, #6]
 801cf4a:	2a01      	cmp	r2, #1
 801cf4c:	f47f af5a 	bne.w	801ce04 <USBD_StdDevReq+0x18>
    switch (pdev->dev_state)
 801cf50:	f890 3274 	ldrb.w	r3, [r0, #628]	; 0x274
 801cf54:	2b02      	cmp	r3, #2
 801cf56:	f200 8082 	bhi.w	801d05e <USBD_StdDevReq+0x272>
 801cf5a:	2b00      	cmp	r3, #0
 801cf5c:	f43f af52 	beq.w	801ce04 <USBD_StdDevReq+0x18>
      pdev->dev_default_config = 0U;
 801cf60:	4601      	mov	r1, r0
 801cf62:	2300      	movs	r3, #0
 801cf64:	f841 3f08 	str.w	r3, [r1, #8]!
      USBD_CtlSendData (pdev, (uint8_t *)(void *)&pdev->dev_default_config, 1U);
 801cf68:	f000 f9d2 	bl	801d310 <USBD_CtlSendData>
      break;
 801cf6c:	e752      	b.n	801ce14 <USBD_StdDevReq+0x28>
    if(pdev->dev_speed == USBD_SPEED_HIGH  )
 801cf6e:	7c03      	ldrb	r3, [r0, #16]
 801cf70:	2b00      	cmp	r3, #0
 801cf72:	f47f af47 	bne.w	801ce04 <USBD_StdDevReq+0x18>
      pbuf   = (uint8_t *)pdev->pClass->GetOtherSpeedConfigDescriptor(&len);
 801cf76:	f8d0 328c 	ldr.w	r3, [r0, #652]	; 0x28c
 801cf7a:	f10d 0006 	add.w	r0, sp, #6
 801cf7e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 801cf80:	4798      	blx	r3
      pbuf[1] = USB_DESC_TYPE_OTHER_SPEED_CONFIGURATION;
 801cf82:	2307      	movs	r3, #7
 801cf84:	7043      	strb	r3, [r0, #1]
  if((len != 0U) && (req->wLength != 0U))
 801cf86:	f8bd 2006 	ldrh.w	r2, [sp, #6]
 801cf8a:	b15a      	cbz	r2, 801cfa4 <USBD_StdDevReq+0x1b8>
 801cf8c:	88eb      	ldrh	r3, [r5, #6]
 801cf8e:	2b00      	cmp	r3, #0
 801cf90:	d09e      	beq.n	801ced0 <USBD_StdDevReq+0xe4>
    len = MIN(len, req->wLength);
 801cf92:	429a      	cmp	r2, r3
 801cf94:	bf28      	it	cs
 801cf96:	461a      	movcs	r2, r3
    USBD_CtlSendData (pdev, pbuf, len);
 801cf98:	4601      	mov	r1, r0
 801cf9a:	4620      	mov	r0, r4
    len = MIN(len, req->wLength);
 801cf9c:	f8ad 2006 	strh.w	r2, [sp, #6]
    USBD_CtlSendData (pdev, pbuf, len);
 801cfa0:	f000 f9b6 	bl	801d310 <USBD_CtlSendData>
  if(req->wLength == 0U)
 801cfa4:	88eb      	ldrh	r3, [r5, #6]
 801cfa6:	2b00      	cmp	r3, #0
 801cfa8:	f47f af34 	bne.w	801ce14 <USBD_StdDevReq+0x28>
 801cfac:	e790      	b.n	801ced0 <USBD_StdDevReq+0xe4>
    if(pdev->dev_speed == USBD_SPEED_HIGH)
 801cfae:	7c03      	ldrb	r3, [r0, #16]
 801cfb0:	2b00      	cmp	r3, #0
 801cfb2:	f47f af27 	bne.w	801ce04 <USBD_StdDevReq+0x18>
      pbuf = (uint8_t *)pdev->pClass->GetDeviceQualifierDescriptor(&len);
 801cfb6:	f8d0 328c 	ldr.w	r3, [r0, #652]	; 0x28c
 801cfba:	f10d 0006 	add.w	r0, sp, #6
 801cfbe:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 801cfc0:	4798      	blx	r3
      break;
 801cfc2:	e7e0      	b.n	801cf86 <USBD_StdDevReq+0x19a>
    switch ((uint8_t)(req->wValue))
 801cfc4:	b2d2      	uxtb	r2, r2
 801cfc6:	2a05      	cmp	r2, #5
 801cfc8:	f63f af1c 	bhi.w	801ce04 <USBD_StdDevReq+0x18>
 801cfcc:	e8df f002 	tbb	[pc, r2]
 801cfd0:	272f373f 	.word	0x272f373f
 801cfd4:	171f      	.short	0x171f
    if(pdev->dev_speed == USBD_SPEED_HIGH )
 801cfd6:	7c03      	ldrb	r3, [r0, #16]
 801cfd8:	2b00      	cmp	r3, #0
 801cfda:	d166      	bne.n	801d0aa <USBD_StdDevReq+0x2be>
      pbuf   = (uint8_t *)pdev->pClass->GetHSConfigDescriptor(&len);
 801cfdc:	f8d0 328c 	ldr.w	r3, [r0, #652]	; 0x28c
 801cfe0:	f10d 0006 	add.w	r0, sp, #6
 801cfe4:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 801cfe6:	4798      	blx	r3
      pbuf[1] = USB_DESC_TYPE_CONFIGURATION;
 801cfe8:	2302      	movs	r3, #2
 801cfea:	7043      	strb	r3, [r0, #1]
 801cfec:	e7cb      	b.n	801cf86 <USBD_StdDevReq+0x19a>
    pbuf = pdev->pDesc->GetDeviceDescriptor(pdev->dev_speed, &len);
 801cfee:	f8d0 3288 	ldr.w	r3, [r0, #648]	; 0x288
 801cff2:	7c00      	ldrb	r0, [r0, #16]
 801cff4:	681b      	ldr	r3, [r3, #0]
 801cff6:	f10d 0106 	add.w	r1, sp, #6
 801cffa:	4798      	blx	r3
    break;
 801cffc:	e7c3      	b.n	801cf86 <USBD_StdDevReq+0x19a>
      pbuf = pdev->pDesc->GetInterfaceStrDescriptor(pdev->dev_speed, &len);
 801cffe:	f8d0 3288 	ldr.w	r3, [r0, #648]	; 0x288
 801d002:	7c00      	ldrb	r0, [r0, #16]
 801d004:	699b      	ldr	r3, [r3, #24]
 801d006:	f10d 0106 	add.w	r1, sp, #6
 801d00a:	4798      	blx	r3
      break;
 801d00c:	e7bb      	b.n	801cf86 <USBD_StdDevReq+0x19a>
      pbuf = pdev->pDesc->GetConfigurationStrDescriptor(pdev->dev_speed, &len);
 801d00e:	f8d0 3288 	ldr.w	r3, [r0, #648]	; 0x288
 801d012:	7c00      	ldrb	r0, [r0, #16]
 801d014:	695b      	ldr	r3, [r3, #20]
 801d016:	f10d 0106 	add.w	r1, sp, #6
 801d01a:	4798      	blx	r3
      break;
 801d01c:	e7b3      	b.n	801cf86 <USBD_StdDevReq+0x19a>
      pbuf = pdev->pDesc->GetSerialStrDescriptor(pdev->dev_speed, &len);
 801d01e:	f8d0 3288 	ldr.w	r3, [r0, #648]	; 0x288
 801d022:	7c00      	ldrb	r0, [r0, #16]
 801d024:	691b      	ldr	r3, [r3, #16]
 801d026:	f10d 0106 	add.w	r1, sp, #6
 801d02a:	4798      	blx	r3
      break;
 801d02c:	e7ab      	b.n	801cf86 <USBD_StdDevReq+0x19a>
      pbuf = pdev->pDesc->GetProductStrDescriptor(pdev->dev_speed, &len);
 801d02e:	f8d0 3288 	ldr.w	r3, [r0, #648]	; 0x288
 801d032:	7c00      	ldrb	r0, [r0, #16]
 801d034:	68db      	ldr	r3, [r3, #12]
 801d036:	f10d 0106 	add.w	r1, sp, #6
 801d03a:	4798      	blx	r3
      break;
 801d03c:	e7a3      	b.n	801cf86 <USBD_StdDevReq+0x19a>
      pbuf = pdev->pDesc->GetManufacturerStrDescriptor(pdev->dev_speed, &len);
 801d03e:	f8d0 3288 	ldr.w	r3, [r0, #648]	; 0x288
 801d042:	7c00      	ldrb	r0, [r0, #16]
 801d044:	689b      	ldr	r3, [r3, #8]
 801d046:	f10d 0106 	add.w	r1, sp, #6
 801d04a:	4798      	blx	r3
      break;
 801d04c:	e79b      	b.n	801cf86 <USBD_StdDevReq+0x19a>
     pbuf = pdev->pDesc->GetLangIDStrDescriptor(pdev->dev_speed, &len);
 801d04e:	f8d0 3288 	ldr.w	r3, [r0, #648]	; 0x288
 801d052:	7c00      	ldrb	r0, [r0, #16]
 801d054:	685b      	ldr	r3, [r3, #4]
 801d056:	f10d 0106 	add.w	r1, sp, #6
 801d05a:	4798      	blx	r3
      break;
 801d05c:	e793      	b.n	801cf86 <USBD_StdDevReq+0x19a>
    switch (pdev->dev_state)
 801d05e:	2b03      	cmp	r3, #3
 801d060:	f47f aed0 	bne.w	801ce04 <USBD_StdDevReq+0x18>
      USBD_CtlSendData (pdev, (uint8_t *)(void *)&pdev->dev_config, 1U);
 801d064:	1d01      	adds	r1, r0, #4
 801d066:	f000 f953 	bl	801d310 <USBD_CtlSendData>
      break;
 801d06a:	e6d3      	b.n	801ce14 <USBD_StdDevReq+0x28>
      if (cfgidx == 0U)
 801d06c:	b331      	cbz	r1, 801d0bc <USBD_StdDevReq+0x2d0>
      else if (cfgidx != pdev->dev_config)
 801d06e:	6841      	ldr	r1, [r0, #4]
 801d070:	2901      	cmp	r1, #1
 801d072:	f43f af2d 	beq.w	801ced0 <USBD_StdDevReq+0xe4>
        USBD_ClrClassConfig(pdev, (uint8_t)pdev->dev_config);
 801d076:	b2c9      	uxtb	r1, r1
 801d078:	f7ff fd82 	bl	801cb80 <USBD_ClrClassConfig>
        pdev->dev_config = cfgidx;
 801d07c:	7829      	ldrb	r1, [r5, #0]
 801d07e:	6061      	str	r1, [r4, #4]
        if(USBD_SetClassConfig(pdev, cfgidx) == USBD_FAIL)
 801d080:	4620      	mov	r0, r4
 801d082:	f7ff fd73 	bl	801cb6c <USBD_SetClassConfig>
 801d086:	2802      	cmp	r0, #2
 801d088:	f47f af22 	bne.w	801ced0 <USBD_StdDevReq+0xe4>
 801d08c:	e6ba      	b.n	801ce04 <USBD_StdDevReq+0x18>
      if (cfgidx)
 801d08e:	2900      	cmp	r1, #0
 801d090:	f43f af1e 	beq.w	801ced0 <USBD_StdDevReq+0xe4>
        pdev->dev_config = cfgidx;
 801d094:	2101      	movs	r1, #1
        pdev->dev_state = USBD_STATE_CONFIGURED;
 801d096:	2303      	movs	r3, #3
        pdev->dev_config = cfgidx;
 801d098:	6041      	str	r1, [r0, #4]
        pdev->dev_state = USBD_STATE_CONFIGURED;
 801d09a:	f880 3274 	strb.w	r3, [r0, #628]	; 0x274
        if(USBD_SetClassConfig(pdev, cfgidx) == USBD_FAIL)
 801d09e:	f7ff fd65 	bl	801cb6c <USBD_SetClassConfig>
 801d0a2:	2802      	cmp	r0, #2
 801d0a4:	f47f af14 	bne.w	801ced0 <USBD_StdDevReq+0xe4>
 801d0a8:	e6ac      	b.n	801ce04 <USBD_StdDevReq+0x18>
      pbuf   = (uint8_t *)pdev->pClass->GetFSConfigDescriptor(&len);
 801d0aa:	f8d0 328c 	ldr.w	r3, [r0, #652]	; 0x28c
 801d0ae:	f10d 0006 	add.w	r0, sp, #6
 801d0b2:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 801d0b4:	4798      	blx	r3
      pbuf[1] = USB_DESC_TYPE_CONFIGURATION;
 801d0b6:	2302      	movs	r3, #2
 801d0b8:	7043      	strb	r3, [r0, #1]
 801d0ba:	e764      	b.n	801cf86 <USBD_StdDevReq+0x19a>
        pdev->dev_state = USBD_STATE_ADDRESSED;
 801d0bc:	2302      	movs	r3, #2
 801d0be:	f880 3274 	strb.w	r3, [r0, #628]	; 0x274
        pdev->dev_config = cfgidx;
 801d0c2:	6041      	str	r1, [r0, #4]
        USBD_ClrClassConfig(pdev, cfgidx);
 801d0c4:	f7ff fd5c 	bl	801cb80 <USBD_ClrClassConfig>
        USBD_CtlSendStatus(pdev);
 801d0c8:	4620      	mov	r0, r4
 801d0ca:	f000 f93f 	bl	801d34c <USBD_CtlSendStatus>
 801d0ce:	e6a1      	b.n	801ce14 <USBD_StdDevReq+0x28>
        pdev->dev_state = USBD_STATE_DEFAULT;
 801d0d0:	2301      	movs	r3, #1
 801d0d2:	f884 3274 	strb.w	r3, [r4, #628]	; 0x274
 801d0d6:	e69d      	b.n	801ce14 <USBD_StdDevReq+0x28>
 801d0d8:	2000941c 	.word	0x2000941c

0801d0dc <USBD_StdItfReq>:
{
 801d0dc:	b538      	push	{r3, r4, r5, lr}
  switch (req->bmRequest & USB_REQ_TYPE_MASK)
 801d0de:	780b      	ldrb	r3, [r1, #0]
 801d0e0:	f003 0260 	and.w	r2, r3, #96	; 0x60
 801d0e4:	2a40      	cmp	r2, #64	; 0x40
{
 801d0e6:	460d      	mov	r5, r1
 801d0e8:	4604      	mov	r4, r0
  switch (req->bmRequest & USB_REQ_TYPE_MASK)
 801d0ea:	d00a      	beq.n	801d102 <USBD_StdItfReq+0x26>
 801d0ec:	065b      	lsls	r3, r3, #25
 801d0ee:	d508      	bpl.n	801d102 <USBD_StdItfReq+0x26>
  USBD_LL_StallEP(pdev , 0x80U);
 801d0f0:	2180      	movs	r1, #128	; 0x80
 801d0f2:	f007 fe0f 	bl	8024d14 <USBD_LL_StallEP>
  USBD_LL_StallEP(pdev , 0U);
 801d0f6:	2100      	movs	r1, #0
 801d0f8:	4620      	mov	r0, r4
 801d0fa:	f007 fe0b 	bl	8024d14 <USBD_LL_StallEP>
}
 801d0fe:	2000      	movs	r0, #0
 801d100:	bd38      	pop	{r3, r4, r5, pc}
    switch (pdev->dev_state)
 801d102:	f894 3274 	ldrb.w	r3, [r4, #628]	; 0x274
 801d106:	3b01      	subs	r3, #1
 801d108:	2b02      	cmp	r3, #2
 801d10a:	d811      	bhi.n	801d130 <USBD_StdItfReq+0x54>
      if (LOBYTE(req->wIndex) <= USBD_MAX_NUM_INTERFACES)
 801d10c:	792b      	ldrb	r3, [r5, #4]
 801d10e:	2b03      	cmp	r3, #3
 801d110:	d80e      	bhi.n	801d130 <USBD_StdItfReq+0x54>
        ret = (USBD_StatusTypeDef)pdev->pClass->Setup (pdev, req);
 801d112:	f8d4 328c 	ldr.w	r3, [r4, #652]	; 0x28c
 801d116:	4629      	mov	r1, r5
 801d118:	689b      	ldr	r3, [r3, #8]
 801d11a:	4620      	mov	r0, r4
 801d11c:	4798      	blx	r3
        if ((req->wLength == 0U) && (ret == USBD_OK))
 801d11e:	88eb      	ldrh	r3, [r5, #6]
 801d120:	2b00      	cmp	r3, #0
 801d122:	d1ec      	bne.n	801d0fe <USBD_StdItfReq+0x22>
 801d124:	2800      	cmp	r0, #0
 801d126:	d1ea      	bne.n	801d0fe <USBD_StdItfReq+0x22>
          USBD_CtlSendStatus(pdev);
 801d128:	4620      	mov	r0, r4
 801d12a:	f000 f90f 	bl	801d34c <USBD_CtlSendStatus>
 801d12e:	e7e6      	b.n	801d0fe <USBD_StdItfReq+0x22>
  USBD_LL_StallEP(pdev , 0x80U);
 801d130:	2180      	movs	r1, #128	; 0x80
 801d132:	4620      	mov	r0, r4
 801d134:	f007 fdee 	bl	8024d14 <USBD_LL_StallEP>
  USBD_LL_StallEP(pdev , 0U);
 801d138:	2100      	movs	r1, #0
 801d13a:	4620      	mov	r0, r4
 801d13c:	f007 fdea 	bl	8024d14 <USBD_LL_StallEP>
}
 801d140:	2000      	movs	r0, #0
 801d142:	bd38      	pop	{r3, r4, r5, pc}

0801d144 <USBD_StdEPReq>:
{
 801d144:	b538      	push	{r3, r4, r5, lr}
 801d146:	780b      	ldrb	r3, [r1, #0]
 801d148:	f003 0360 	and.w	r3, r3, #96	; 0x60
  switch (req->bmRequest & USB_REQ_TYPE_MASK)
 801d14c:	2b20      	cmp	r3, #32
{
 801d14e:	4604      	mov	r4, r0
  switch (req->bmRequest & USB_REQ_TYPE_MASK)
 801d150:	d00c      	beq.n	801d16c <USBD_StdEPReq+0x28>
 801d152:	2b40      	cmp	r3, #64	; 0x40
 801d154:	d00a      	beq.n	801d16c <USBD_StdEPReq+0x28>
 801d156:	b183      	cbz	r3, 801d17a <USBD_StdEPReq+0x36>
  USBD_LL_StallEP(pdev , 0x80U);
 801d158:	2180      	movs	r1, #128	; 0x80
 801d15a:	4620      	mov	r0, r4
 801d15c:	f007 fdda 	bl	8024d14 <USBD_LL_StallEP>
  USBD_LL_StallEP(pdev , 0U);
 801d160:	2100      	movs	r1, #0
 801d162:	4620      	mov	r0, r4
 801d164:	f007 fdd6 	bl	8024d14 <USBD_LL_StallEP>
}
 801d168:	2000      	movs	r0, #0
 801d16a:	bd38      	pop	{r3, r4, r5, pc}
    pdev->pClass->Setup (pdev, req);
 801d16c:	f8d4 328c 	ldr.w	r3, [r4, #652]	; 0x28c
 801d170:	4620      	mov	r0, r4
 801d172:	689b      	ldr	r3, [r3, #8]
 801d174:	4798      	blx	r3
}
 801d176:	2000      	movs	r0, #0
 801d178:	bd38      	pop	{r3, r4, r5, pc}
    switch (req->bRequest)
 801d17a:	784b      	ldrb	r3, [r1, #1]
  ep_addr  = LOBYTE(req->wIndex);
 801d17c:	888a      	ldrh	r2, [r1, #4]
 801d17e:	2b01      	cmp	r3, #1
 801d180:	fa5f fc82 	uxtb.w	ip, r2
    switch (req->bRequest)
 801d184:	d03d      	beq.n	801d202 <USBD_StdEPReq+0xbe>
 801d186:	2b03      	cmp	r3, #3
 801d188:	d029      	beq.n	801d1de <USBD_StdEPReq+0x9a>
 801d18a:	2b00      	cmp	r3, #0
 801d18c:	d1e4      	bne.n	801d158 <USBD_StdEPReq+0x14>
      switch (pdev->dev_state)
 801d18e:	f890 3274 	ldrb.w	r3, [r0, #628]	; 0x274
 801d192:	2b02      	cmp	r3, #2
 801d194:	d050      	beq.n	801d238 <USBD_StdEPReq+0xf4>
 801d196:	2b03      	cmp	r3, #3
 801d198:	d1de      	bne.n	801d158 <USBD_StdEPReq+0x14>
          if (pdev->ep_in[ep_addr & 0xFU].is_used == 0U)
 801d19a:	f00c 030f 	and.w	r3, ip, #15
 801d19e:	eb03 0383 	add.w	r3, r3, r3, lsl #2
        if((ep_addr & 0x80U) == 0x80U)
 801d1a2:	0612      	lsls	r2, r2, #24
          if (pdev->ep_in[ep_addr & 0xFU].is_used == 0U)
 801d1a4:	eb00 0383 	add.w	r3, r0, r3, lsl #2
        if((ep_addr & 0x80U) == 0x80U)
 801d1a8:	d455      	bmi.n	801d256 <USBD_StdEPReq+0x112>
          if (pdev->ep_out[ep_addr & 0xFU].is_used == 0U)
 801d1aa:	f8d3 3144 	ldr.w	r3, [r3, #324]	; 0x144
 801d1ae:	2b00      	cmp	r3, #0
 801d1b0:	d0d2      	beq.n	801d158 <USBD_StdEPReq+0x14>
        pep = ((ep_addr & 0x80U) == 0x80U) ? &pdev->ep_in[ep_addr & 0x7FU]:\
 801d1b2:	f00c 037f 	and.w	r3, ip, #127	; 0x7f
 801d1b6:	2514      	movs	r5, #20
 801d1b8:	fb05 0503 	mla	r5, r5, r3, r0
 801d1bc:	f505 75a0 	add.w	r5, r5, #320	; 0x140
          if ((ep_addr == 0x00U) || (ep_addr == 0x80U))
 801d1c0:	b133      	cbz	r3, 801d1d0 <USBD_StdEPReq+0x8c>
          else if(USBD_LL_IsStallEP(pdev, ep_addr))
 801d1c2:	4661      	mov	r1, ip
 801d1c4:	4620      	mov	r0, r4
 801d1c6:	f007 fdb5 	bl	8024d34 <USBD_LL_IsStallEP>
 801d1ca:	2800      	cmp	r0, #0
 801d1cc:	d04f      	beq.n	801d26e <USBD_StdEPReq+0x12a>
            pep->status = 0x0001U;
 801d1ce:	2301      	movs	r3, #1
 801d1d0:	602b      	str	r3, [r5, #0]
          USBD_CtlSendData (pdev, (uint8_t *)(void *)&pep->status, 2U);
 801d1d2:	2202      	movs	r2, #2
 801d1d4:	4629      	mov	r1, r5
 801d1d6:	4620      	mov	r0, r4
 801d1d8:	f000 f89a 	bl	801d310 <USBD_CtlSendData>
          break;
 801d1dc:	e7c4      	b.n	801d168 <USBD_StdEPReq+0x24>
      switch (pdev->dev_state)
 801d1de:	f890 3274 	ldrb.w	r3, [r0, #628]	; 0x274
 801d1e2:	2b02      	cmp	r3, #2
 801d1e4:	d01d      	beq.n	801d222 <USBD_StdEPReq+0xde>
 801d1e6:	2b03      	cmp	r3, #3
 801d1e8:	d1b6      	bne.n	801d158 <USBD_StdEPReq+0x14>
        if (req->wValue == USB_FEATURE_EP_HALT)
 801d1ea:	884b      	ldrh	r3, [r1, #2]
 801d1ec:	b92b      	cbnz	r3, 801d1fa <USBD_StdEPReq+0xb6>
          if ((ep_addr != 0x00U) && (ep_addr != 0x80U) && (req->wLength == 0x00U))
 801d1ee:	f01c 0f7f 	tst.w	ip, #127	; 0x7f
 801d1f2:	d002      	beq.n	801d1fa <USBD_StdEPReq+0xb6>
 801d1f4:	88cb      	ldrh	r3, [r1, #6]
 801d1f6:	2b00      	cmp	r3, #0
 801d1f8:	d03b      	beq.n	801d272 <USBD_StdEPReq+0x12e>
        USBD_CtlSendStatus(pdev);
 801d1fa:	4620      	mov	r0, r4
 801d1fc:	f000 f8a6 	bl	801d34c <USBD_CtlSendStatus>
        break;
 801d200:	e7b2      	b.n	801d168 <USBD_StdEPReq+0x24>
      switch (pdev->dev_state)
 801d202:	f890 3274 	ldrb.w	r3, [r0, #628]	; 0x274
 801d206:	2b02      	cmp	r3, #2
 801d208:	d00b      	beq.n	801d222 <USBD_StdEPReq+0xde>
 801d20a:	2b03      	cmp	r3, #3
 801d20c:	d1a4      	bne.n	801d158 <USBD_StdEPReq+0x14>
        if (req->wValue == USB_FEATURE_EP_HALT)
 801d20e:	884b      	ldrh	r3, [r1, #2]
 801d210:	2b00      	cmp	r3, #0
 801d212:	d1a9      	bne.n	801d168 <USBD_StdEPReq+0x24>
          if ((ep_addr & 0x7FU) != 0x00U)
 801d214:	f01c 0f7f 	tst.w	ip, #127	; 0x7f
 801d218:	d0ef      	beq.n	801d1fa <USBD_StdEPReq+0xb6>
            USBD_LL_ClearStallEP(pdev, ep_addr);
 801d21a:	4661      	mov	r1, ip
 801d21c:	f007 fd82 	bl	8024d24 <USBD_LL_ClearStallEP>
 801d220:	e7eb      	b.n	801d1fa <USBD_StdEPReq+0xb6>
        if ((ep_addr != 0x00U) && (ep_addr != 0x80U))
 801d222:	f01c 0f7f 	tst.w	ip, #127	; 0x7f
 801d226:	d097      	beq.n	801d158 <USBD_StdEPReq+0x14>
          USBD_LL_StallEP(pdev, ep_addr);
 801d228:	4661      	mov	r1, ip
 801d22a:	f007 fd73 	bl	8024d14 <USBD_LL_StallEP>
          USBD_LL_StallEP(pdev, 0x80U);
 801d22e:	2180      	movs	r1, #128	; 0x80
 801d230:	4620      	mov	r0, r4
 801d232:	f007 fd6f 	bl	8024d14 <USBD_LL_StallEP>
 801d236:	e797      	b.n	801d168 <USBD_StdEPReq+0x24>
        if ((ep_addr != 0x00U) && (ep_addr != 0x80U))
 801d238:	f01c 0f7f 	tst.w	ip, #127	; 0x7f
 801d23c:	d18c      	bne.n	801d158 <USBD_StdEPReq+0x14>
        pep = ((ep_addr & 0x80U) == 0x80U) ? &pdev->ep_in[ep_addr & 0x7FU]:\
 801d23e:	0611      	lsls	r1, r2, #24
 801d240:	bf4c      	ite	mi
 801d242:	f100 0114 	addmi.w	r1, r0, #20
 801d246:	f500 71a0 	addpl.w	r1, r0, #320	; 0x140
          pep->status = 0x0000U;
 801d24a:	2300      	movs	r3, #0
 801d24c:	600b      	str	r3, [r1, #0]
          USBD_CtlSendData (pdev, (uint8_t *)(void *)&pep->status, 2U);
 801d24e:	2202      	movs	r2, #2
 801d250:	f000 f85e 	bl	801d310 <USBD_CtlSendData>
          break;
 801d254:	e788      	b.n	801d168 <USBD_StdEPReq+0x24>
          if (pdev->ep_in[ep_addr & 0xFU].is_used == 0U)
 801d256:	699b      	ldr	r3, [r3, #24]
 801d258:	2b00      	cmp	r3, #0
 801d25a:	f43f af7d 	beq.w	801d158 <USBD_StdEPReq+0x14>
        pep = ((ep_addr & 0x80U) == 0x80U) ? &pdev->ep_in[ep_addr & 0x7FU]:\
 801d25e:	f00c 037f 	and.w	r3, ip, #127	; 0x7f
 801d262:	1c5d      	adds	r5, r3, #1
 801d264:	eb05 0585 	add.w	r5, r5, r5, lsl #2
 801d268:	eb00 0585 	add.w	r5, r0, r5, lsl #2
 801d26c:	e7a8      	b.n	801d1c0 <USBD_StdEPReq+0x7c>
            pep->status = 0x0000U;
 801d26e:	6028      	str	r0, [r5, #0]
 801d270:	e7af      	b.n	801d1d2 <USBD_StdEPReq+0x8e>
            USBD_LL_StallEP(pdev, ep_addr);
 801d272:	4661      	mov	r1, ip
 801d274:	f007 fd4e 	bl	8024d14 <USBD_LL_StallEP>
 801d278:	e7bf      	b.n	801d1fa <USBD_StdEPReq+0xb6>
 801d27a:	bf00      	nop

0801d27c <USBD_ParseSetupRequest>:
  req->bmRequest     = *(uint8_t *)  (pdata);
 801d27c:	780b      	ldrb	r3, [r1, #0]
 801d27e:	7003      	strb	r3, [r0, #0]
  req->bRequest      = *(uint8_t *)  (pdata +  1);
 801d280:	784b      	ldrb	r3, [r1, #1]
 801d282:	7043      	strb	r3, [r0, #1]
  req->wValue        = SWAPBYTE      (pdata +  2);
 801d284:	78ca      	ldrb	r2, [r1, #3]
 801d286:	788b      	ldrb	r3, [r1, #2]
 801d288:	eb03 2302 	add.w	r3, r3, r2, lsl #8
 801d28c:	8043      	strh	r3, [r0, #2]
  req->wIndex        = SWAPBYTE      (pdata +  4);
 801d28e:	794a      	ldrb	r2, [r1, #5]
 801d290:	790b      	ldrb	r3, [r1, #4]
 801d292:	eb03 2302 	add.w	r3, r3, r2, lsl #8
 801d296:	8083      	strh	r3, [r0, #4]
  req->wLength       = SWAPBYTE      (pdata +  6);
 801d298:	79ca      	ldrb	r2, [r1, #7]
 801d29a:	798b      	ldrb	r3, [r1, #6]
 801d29c:	eb03 2302 	add.w	r3, r3, r2, lsl #8
 801d2a0:	80c3      	strh	r3, [r0, #6]
}
 801d2a2:	4770      	bx	lr

0801d2a4 <USBD_CtlError>:
{
 801d2a4:	b510      	push	{r4, lr}
  USBD_LL_StallEP(pdev , 0x80U);
 801d2a6:	2180      	movs	r1, #128	; 0x80
{
 801d2a8:	4604      	mov	r4, r0
  USBD_LL_StallEP(pdev , 0x80U);
 801d2aa:	f007 fd33 	bl	8024d14 <USBD_LL_StallEP>
  USBD_LL_StallEP(pdev , 0U);
 801d2ae:	4620      	mov	r0, r4
 801d2b0:	2100      	movs	r1, #0
}
 801d2b2:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  USBD_LL_StallEP(pdev , 0U);
 801d2b6:	f007 bd2d 	b.w	8024d14 <USBD_LL_StallEP>
 801d2ba:	bf00      	nop

0801d2bc <USBD_GetString>:
  */
void USBD_GetString(uint8_t *desc, uint8_t *unicode, uint16_t *len)
{
  uint8_t idx = 0U;

  if (desc != NULL)
 801d2bc:	b318      	cbz	r0, 801d306 <USBD_GetString+0x4a>
  */
static uint8_t USBD_GetLen(uint8_t *buf)
{
    uint8_t  len = 0U;

    while (*buf != '\0')
 801d2be:	7803      	ldrb	r3, [r0, #0]
{
 801d2c0:	b430      	push	{r4, r5}
    while (*buf != '\0')
 801d2c2:	b30b      	cbz	r3, 801d308 <USBD_GetString+0x4c>
 801d2c4:	4604      	mov	r4, r0
 801d2c6:	f1c0 0c01 	rsb	ip, r0, #1
    {
        len++;
 801d2ca:	eb04 030c 	add.w	r3, r4, ip
    while (*buf != '\0')
 801d2ce:	f814 5f01 	ldrb.w	r5, [r4, #1]!
 801d2d2:	b2db      	uxtb	r3, r3
 801d2d4:	2d00      	cmp	r5, #0
 801d2d6:	d1f8      	bne.n	801d2ca <USBD_GetString+0xe>
    *len = (uint16_t)USBD_GetLen(desc) * 2U + 2U;
 801d2d8:	3301      	adds	r3, #1
 801d2da:	005b      	lsls	r3, r3, #1
 801d2dc:	b2dc      	uxtb	r4, r3
 801d2de:	8013      	strh	r3, [r2, #0]
    unicode[idx++] = USB_DESC_TYPE_STRING;
 801d2e0:	2303      	movs	r3, #3
    unicode[idx++] = *(uint8_t *)(void *)len;
 801d2e2:	700c      	strb	r4, [r1, #0]
    unicode[idx++] = USB_DESC_TYPE_STRING;
 801d2e4:	704b      	strb	r3, [r1, #1]
    while (*desc != '\0')
 801d2e6:	7804      	ldrb	r4, [r0, #0]
 801d2e8:	b15c      	cbz	r4, 801d302 <USBD_GetString+0x46>
    unicode[idx++] = USB_DESC_TYPE_STRING;
 801d2ea:	2302      	movs	r3, #2
      unicode[idx++] =  0U;
 801d2ec:	2500      	movs	r5, #0
      unicode[idx++] = *desc++;
 801d2ee:	1c5a      	adds	r2, r3, #1
 801d2f0:	b2d2      	uxtb	r2, r2
 801d2f2:	54cc      	strb	r4, [r1, r3]
      unicode[idx++] =  0U;
 801d2f4:	548d      	strb	r5, [r1, r2]
    while (*desc != '\0')
 801d2f6:	f810 4f01 	ldrb.w	r4, [r0, #1]!
      unicode[idx++] =  0U;
 801d2fa:	3302      	adds	r3, #2
 801d2fc:	b2db      	uxtb	r3, r3
    while (*desc != '\0')
 801d2fe:	2c00      	cmp	r4, #0
 801d300:	d1f5      	bne.n	801d2ee <USBD_GetString+0x32>
}
 801d302:	bc30      	pop	{r4, r5}
 801d304:	4770      	bx	lr
 801d306:	4770      	bx	lr
    while (*buf != '\0')
 801d308:	2402      	movs	r4, #2
 801d30a:	4623      	mov	r3, r4
 801d30c:	e7e7      	b.n	801d2de <USBD_GetString+0x22>
 801d30e:	bf00      	nop

0801d310 <USBD_CtlSendData>:
* @param  len: length of data to be sent
* @retval status
*/
USBD_StatusTypeDef USBD_CtlSendData (USBD_HandleTypeDef *pdev, uint8_t *pbuf,
                                     uint16_t len)
{
 801d310:	b508      	push	{r3, lr}
 801d312:	4613      	mov	r3, r2
 801d314:	460a      	mov	r2, r1
  /* Set EP0 State */
  pdev->ep0_state = USBD_EP0_DATA_IN;
 801d316:	2102      	movs	r1, #2
  pdev->ep_in[0].total_length = len;
  pdev->ep_in[0].rem_length   = len;
 801d318:	e9c0 3307 	strd	r3, r3, [r0, #28]
  pdev->ep0_state = USBD_EP0_DATA_IN;
 801d31c:	f8c0 126c 	str.w	r1, [r0, #620]	; 0x26c

 /* Start the transfer */
  USBD_LL_Transmit (pdev, 0x00U, pbuf, len);
 801d320:	2100      	movs	r1, #0
 801d322:	f007 fd23 	bl	8024d6c <USBD_LL_Transmit>

  return USBD_OK;
}
 801d326:	2000      	movs	r0, #0
 801d328:	bd08      	pop	{r3, pc}
 801d32a:	bf00      	nop

0801d32c <USBD_CtlContinueSendData>:
* @param  len: length of data to be sent
* @retval status
*/
USBD_StatusTypeDef USBD_CtlContinueSendData (USBD_HandleTypeDef *pdev,
                                             uint8_t *pbuf, uint16_t len)
{
 801d32c:	b508      	push	{r3, lr}
 801d32e:	4613      	mov	r3, r2
 /* Start the next transfer */
  USBD_LL_Transmit (pdev, 0x00U, pbuf, len);
 801d330:	460a      	mov	r2, r1
 801d332:	2100      	movs	r1, #0
 801d334:	f007 fd1a 	bl	8024d6c <USBD_LL_Transmit>

  return USBD_OK;
}
 801d338:	2000      	movs	r0, #0
 801d33a:	bd08      	pop	{r3, pc}

0801d33c <USBD_CtlContinueRx>:
* @param  len: length of data to be received
* @retval status
*/
USBD_StatusTypeDef USBD_CtlContinueRx (USBD_HandleTypeDef *pdev, uint8_t *pbuf,
                                       uint16_t len)
{
 801d33c:	b508      	push	{r3, lr}
 801d33e:	4613      	mov	r3, r2
  USBD_LL_PrepareReceive(pdev, 0U, pbuf, len);
 801d340:	460a      	mov	r2, r1
 801d342:	2100      	movs	r1, #0
 801d344:	f007 fd1a 	bl	8024d7c <USBD_LL_PrepareReceive>

  return USBD_OK;
}
 801d348:	2000      	movs	r0, #0
 801d34a:	bd08      	pop	{r3, pc}

0801d34c <USBD_CtlSendStatus>:
*         send zero lzngth packet on the ctl pipe
* @param  pdev: device instance
* @retval status
*/
USBD_StatusTypeDef USBD_CtlSendStatus (USBD_HandleTypeDef *pdev)
{
 801d34c:	b508      	push	{r3, lr}
  /* Set EP0 State */
  pdev->ep0_state = USBD_EP0_STATUS_IN;
 801d34e:	2204      	movs	r2, #4

  /* Start the transfer */
  USBD_LL_Transmit(pdev, 0x00U, NULL, 0U);
 801d350:	2300      	movs	r3, #0
  pdev->ep0_state = USBD_EP0_STATUS_IN;
 801d352:	f8c0 226c 	str.w	r2, [r0, #620]	; 0x26c
  USBD_LL_Transmit(pdev, 0x00U, NULL, 0U);
 801d356:	4619      	mov	r1, r3
 801d358:	461a      	mov	r2, r3
 801d35a:	f007 fd07 	bl	8024d6c <USBD_LL_Transmit>

  return USBD_OK;
}
 801d35e:	2000      	movs	r0, #0
 801d360:	bd08      	pop	{r3, pc}
 801d362:	bf00      	nop

0801d364 <USBD_CtlReceiveStatus>:
*         receive zero lzngth packet on the ctl pipe
* @param  pdev: device instance
* @retval status
*/
USBD_StatusTypeDef USBD_CtlReceiveStatus (USBD_HandleTypeDef *pdev)
{
 801d364:	b508      	push	{r3, lr}
  /* Set EP0 State */
  pdev->ep0_state = USBD_EP0_STATUS_OUT;
 801d366:	2205      	movs	r2, #5

 /* Start the transfer */
  USBD_LL_PrepareReceive (pdev, 0U, NULL, 0U);
 801d368:	2300      	movs	r3, #0
  pdev->ep0_state = USBD_EP0_STATUS_OUT;
 801d36a:	f8c0 226c 	str.w	r2, [r0, #620]	; 0x26c
  USBD_LL_PrepareReceive (pdev, 0U, NULL, 0U);
 801d36e:	4619      	mov	r1, r3
 801d370:	461a      	mov	r2, r3
 801d372:	f007 fd03 	bl	8024d7c <USBD_LL_PrepareReceive>

  return USBD_OK;
}
 801d376:	2000      	movs	r0, #0
 801d378:	bd08      	pop	{r3, pc}
 801d37a:	bf00      	nop

0801d37c <Reset_Handler>:

    .section	.text.Reset_Handler
	.weak	Reset_Handler
	.type	Reset_Handler, %function
Reset_Handler:
  ldr   sp, =_estack    /* Atollic update: set stack pointer */
 801d37c:	f8df d034 	ldr.w	sp, [pc, #52]	; 801d3b4 <LoopForever+0x2>

/* Copy the data segment initializers from flash to SRAM */
  movs	r1, #0
 801d380:	2100      	movs	r1, #0
  b	LoopCopyDataInit
 801d382:	e003      	b.n	801d38c <LoopCopyDataInit>

0801d384 <CopyDataInit>:

CopyDataInit:
	ldr	r3, =_sidata
 801d384:	4b0c      	ldr	r3, [pc, #48]	; (801d3b8 <LoopForever+0x6>)
	ldr	r3, [r3, r1]
 801d386:	585b      	ldr	r3, [r3, r1]
	str	r3, [r0, r1]
 801d388:	5043      	str	r3, [r0, r1]
	adds	r1, r1, #4
 801d38a:	3104      	adds	r1, #4

0801d38c <LoopCopyDataInit>:

LoopCopyDataInit:
	ldr	r0, =_sdata
 801d38c:	480b      	ldr	r0, [pc, #44]	; (801d3bc <LoopForever+0xa>)
	ldr	r3, =_edata
 801d38e:	4b0c      	ldr	r3, [pc, #48]	; (801d3c0 <LoopForever+0xe>)
	adds	r2, r0, r1
 801d390:	1842      	adds	r2, r0, r1
	cmp	r2, r3
 801d392:	429a      	cmp	r2, r3
	bcc	CopyDataInit
 801d394:	d3f6      	bcc.n	801d384 <CopyDataInit>
	ldr	r2, =_sbss
 801d396:	4a0b      	ldr	r2, [pc, #44]	; (801d3c4 <LoopForever+0x12>)
	b	LoopFillZerobss
 801d398:	e002      	b.n	801d3a0 <LoopFillZerobss>

0801d39a <FillZerobss>:
/* Zero fill the bss segment. */
FillZerobss:
	movs	r3, #0
 801d39a:	2300      	movs	r3, #0
	str	r3, [r2], #4
 801d39c:	f842 3b04 	str.w	r3, [r2], #4

0801d3a0 <LoopFillZerobss>:

LoopFillZerobss:
	ldr	r3, = _ebss
 801d3a0:	4b09      	ldr	r3, [pc, #36]	; (801d3c8 <LoopForever+0x16>)
	cmp	r2, r3
 801d3a2:	429a      	cmp	r2, r3
	bcc	FillZerobss
 801d3a4:	d3f9      	bcc.n	801d39a <FillZerobss>

/* Call the clock system intitialization function.*/
    bl  SystemInit
 801d3a6:	f7f2 f9dd 	bl	800f764 <SystemInit>
/* Call static constructors */
    bl __libc_init_array
 801d3aa:	f00a f875 	bl	8027498 <__libc_init_array>
/* Call the application's entry point.*/
	bl	main
 801d3ae:	f005 f911 	bl	80225d4 <main>

0801d3b2 <LoopForever>:

LoopForever:
    b LoopForever
 801d3b2:	e7fe      	b.n	801d3b2 <LoopForever>
  ldr   sp, =_estack    /* Atollic update: set stack pointer */
 801d3b4:	20018000 	.word	0x20018000
	ldr	r3, =_sidata
 801d3b8:	080581e0 	.word	0x080581e0
	ldr	r0, =_sdata
 801d3bc:	20000000 	.word	0x20000000
	ldr	r3, =_edata
 801d3c0:	200021f0 	.word	0x200021f0
	ldr	r2, =_sbss
 801d3c4:	200021f0 	.word	0x200021f0
	ldr	r3, = _ebss
 801d3c8:	20014fd0 	.word	0x20014fd0

0801d3cc <ADC1_2_IRQHandler>:
 * @retval : None
*/
    .section	.text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
	b	Infinite_Loop
 801d3cc:	e7fe      	b.n	801d3cc <ADC1_2_IRQHandler>
	...

0801d3d0 <_sbrk>:
{
	extern char end /*asm("end")*/;
	static char *heap_end;
	char *prev_heap_end,*min_stack_ptr;

	if (heap_end == 0)
 801d3d0:	490d      	ldr	r1, [pc, #52]	; (801d408 <_sbrk+0x38>)
{
 801d3d2:	b508      	push	{r3, lr}
 801d3d4:	4603      	mov	r3, r0
	if (heap_end == 0)
 801d3d6:	6808      	ldr	r0, [r1, #0]
 801d3d8:	b158      	cbz	r0, 801d3f2 <_sbrk+0x22>

	prev_heap_end = heap_end;

#ifdef FreeRTOS
	/* Use the NVIC offset register to locate the main stack pointer. */
	min_stack_ptr = (char*)(*(unsigned int *)*(unsigned int *)0xE000ED08);
 801d3da:	f04f 22e0 	mov.w	r2, #3758153728	; 0xe000e000
	/* Locate the STACK bottom address */
	min_stack_ptr -= MAX_STACK_SIZE;

	if (heap_end + incr > min_stack_ptr)
 801d3de:	4403      	add	r3, r0
	min_stack_ptr = (char*)(*(unsigned int *)*(unsigned int *)0xE000ED08);
 801d3e0:	f8d2 2d08 	ldr.w	r2, [r2, #3336]	; 0xd08
 801d3e4:	6812      	ldr	r2, [r2, #0]
	min_stack_ptr -= MAX_STACK_SIZE;
 801d3e6:	f5a2 7200 	sub.w	r2, r2, #512	; 0x200
	if (heap_end + incr > min_stack_ptr)
 801d3ea:	4293      	cmp	r3, r2
 801d3ec:	d804      	bhi.n	801d3f8 <_sbrk+0x28>
//		abort();
		errno = ENOMEM;
		return (caddr_t) -1;
	}

	heap_end += incr;
 801d3ee:	600b      	str	r3, [r1, #0]

	return (caddr_t) prev_heap_end;
}
 801d3f0:	bd08      	pop	{r3, pc}
		heap_end = &end;
 801d3f2:	4806      	ldr	r0, [pc, #24]	; (801d40c <_sbrk+0x3c>)
 801d3f4:	6008      	str	r0, [r1, #0]
 801d3f6:	e7f0      	b.n	801d3da <_sbrk+0xa>
		errno = ENOMEM;
 801d3f8:	f009 fe7e 	bl	80270f8 <__errno>
 801d3fc:	230c      	movs	r3, #12
 801d3fe:	6003      	str	r3, [r0, #0]
		return (caddr_t) -1;
 801d400:	f04f 30ff 	mov.w	r0, #4294967295
}
 801d404:	bd08      	pop	{r3, pc}
 801d406:	bf00      	nop
 801d408:	20009420 	.word	0x20009420
 801d40c:	20014fd0 	.word	0x20014fd0

0801d410 <_getpid>:
}

int _getpid(void)
{
	return 1;
}
 801d410:	2001      	movs	r0, #1
 801d412:	4770      	bx	lr

0801d414 <_kill>:

int _kill(int pid, int sig)
{
 801d414:	b508      	push	{r3, lr}
	errno = EINVAL;
 801d416:	f009 fe6f 	bl	80270f8 <__errno>
 801d41a:	2316      	movs	r3, #22
 801d41c:	6003      	str	r3, [r0, #0]
	return -1;
}
 801d41e:	f04f 30ff 	mov.w	r0, #4294967295
 801d422:	bd08      	pop	{r3, pc}

0801d424 <_exit>:

void _exit (int status)
{
 801d424:	b508      	push	{r3, lr}
	errno = EINVAL;
 801d426:	f009 fe67 	bl	80270f8 <__errno>
 801d42a:	2316      	movs	r3, #22
 801d42c:	6003      	str	r3, [r0, #0]
	_kill(status, -1);
	while (1) {}
 801d42e:	e7fe      	b.n	801d42e <_exit+0xa>

0801d430 <_write>:
}

int _write(int file, char *ptr, int len)
{
 801d430:	b570      	push	{r4, r5, r6, lr}
	int DataIdx;

		for (DataIdx = 0; DataIdx < len; DataIdx++)
 801d432:	1e16      	subs	r6, r2, #0
 801d434:	dd07      	ble.n	801d446 <_write+0x16>
 801d436:	460c      	mov	r4, r1
 801d438:	198d      	adds	r5, r1, r6
		{
		   __io_putchar( *ptr++ );
 801d43a:	f814 0b01 	ldrb.w	r0, [r4], #1
 801d43e:	f003 feb7 	bl	80211b0 <__io_putchar>
		for (DataIdx = 0; DataIdx < len; DataIdx++)
 801d442:	42a5      	cmp	r5, r4
 801d444:	d1f9      	bne.n	801d43a <_write+0xa>
		}
	return len;
}
 801d446:	4630      	mov	r0, r6
 801d448:	bd70      	pop	{r4, r5, r6, pc}
 801d44a:	bf00      	nop

0801d44c <_close>:

int _close(int file)
{
	return -1;
}
 801d44c:	f04f 30ff 	mov.w	r0, #4294967295
 801d450:	4770      	bx	lr
 801d452:	bf00      	nop

0801d454 <_fstat>:

int _fstat(int file, struct stat *st)
{
	st->st_mode = S_IFCHR;
 801d454:	f44f 5300 	mov.w	r3, #8192	; 0x2000
 801d458:	604b      	str	r3, [r1, #4]
	return 0;
}
 801d45a:	2000      	movs	r0, #0
 801d45c:	4770      	bx	lr
 801d45e:	bf00      	nop

0801d460 <_isatty>:

int _isatty(int file)
{
	return 1;
}
 801d460:	2001      	movs	r0, #1
 801d462:	4770      	bx	lr

0801d464 <_lseek>:

int _lseek(int file, int ptr, int dir)
{
	return 0;
}
 801d464:	2000      	movs	r0, #0
 801d466:	4770      	bx	lr

0801d468 <_read>:

int _read(int file, char *ptr, int len)
{
 801d468:	b510      	push	{r4, lr}
 801d46a:	460c      	mov	r4, r1
	/* scanf calls _read() with len=1024, so eat one character at time */
	*ptr = __io_getchar();
 801d46c:	f003 fec8 	bl	8021200 <__io_getchar>
 801d470:	7020      	strb	r0, [r4, #0]
	return 1;
}
 801d472:	2001      	movs	r0, #1
 801d474:	bd10      	pop	{r4, pc}
 801d476:	bf00      	nop

0801d478 <ai_asc_get_info>:
/**  PUBLIC APIs SECTION  *****************************************************/

AI_API_ENTRY
ai_bool ai_asc_get_info(
  ai_handle network, ai_network_report* report)
{
 801d478:	b530      	push	{r4, r5, lr}
 801d47a:	460d      	mov	r5, r1
 801d47c:	b09f      	sub	sp, #124	; 0x7c
 801d47e:	4604      	mov	r4, r0
  ai_network* net_ctx = AI_NETWORK_ACQUIRE_CTX(network);
 801d480:	f7e6 ff7f 	bl	8004382 <ai_platform_context_acquire>

  if ( report && net_ctx )
 801d484:	2d00      	cmp	r5, #0
 801d486:	d038      	beq.n	801d4fa <ai_asc_get_info+0x82>
 801d488:	b398      	cbz	r0, 801d4f2 <ai_asc_get_info+0x7a>
  {
    ai_network_report r = {
 801d48a:	2264      	movs	r2, #100	; 0x64
 801d48c:	2100      	movs	r1, #0
 801d48e:	a805      	add	r0, sp, #20
 801d490:	f00a f872 	bl	8027578 <memset>
 801d494:	491b      	ldr	r1, [pc, #108]	; (801d504 <ai_asc_get_info+0x8c>)
 801d496:	4b1c      	ldr	r3, [pc, #112]	; (801d508 <ai_asc_get_info+0x90>)
 801d498:	4a1c      	ldr	r2, [pc, #112]	; (801d50c <ai_asc_get_info+0x94>)
 801d49a:	e9cd 1301 	strd	r1, r3, [sp, #4]
 801d49e:	4b1c      	ldr	r3, [pc, #112]	; (801d510 <ai_asc_get_info+0x98>)
 801d4a0:	e9cd 2303 	strd	r2, r3, [sp, #12]
      .model_signature   = AI_ASC_MODEL_SIGNATURE,
      .model_datetime    = AI_TOOLS_DATE_TIME,
      
      .compile_datetime  = AI_TOOLS_COMPILE_TIME,
      
      .runtime_revision  = ai_platform_runtime_get_revision(),
 801d4a4:	f7e6 ff07 	bl	80042b6 <ai_platform_runtime_get_revision>
    ai_network_report r = {
 801d4a8:	9005      	str	r0, [sp, #20]
      .runtime_version   = ai_platform_runtime_get_version(),
 801d4aa:	f7e6 ff1c 	bl	80042e6 <ai_platform_runtime_get_version>
    ai_network_report r = {
 801d4ae:	4b19      	ldr	r3, [pc, #100]	; (801d514 <ai_asc_get_info+0x9c>)
 801d4b0:	f44f 7282 	mov.w	r2, #260	; 0x104
 801d4b4:	e9cd 0306 	strd	r0, r3, [sp, #24]
 801d4b8:	f240 3301 	movw	r3, #769	; 0x301
 801d4bc:	f8ad 2020 	strh.w	r2, [sp, #32]
 801d4c0:	f8ad 3024 	strh.w	r3, [sp, #36]	; 0x24
      .tool_version      = {AI_TOOLS_VERSION_MAJOR, AI_TOOLS_VERSION_MINOR,
                            AI_TOOLS_VERSION_MICRO, 0x0},
      .tool_api_version  = {AI_TOOLS_API_VERSION_MAJOR, AI_TOOLS_API_VERSION_MINOR,
                            AI_TOOLS_API_VERSION_MICRO, 0x0},

      .api_version            = ai_platform_api_get_version(),
 801d4c4:	f7e6 ff29 	bl	800431a <ai_platform_api_get_version>
 801d4c8:	900a      	str	r0, [sp, #40]	; 0x28
      .interface_api_version  = ai_platform_interface_api_get_version(),
 801d4ca:	f7e6 ff40 	bl	800434e <ai_platform_interface_api_get_version>
    ai_network_report r = {
 801d4ce:	4b12      	ldr	r3, [pc, #72]	; (801d518 <ai_asc_get_info+0xa0>)
      .interface_api_version  = ai_platform_interface_api_get_version(),
 801d4d0:	4602      	mov	r2, r0
      .params            = AI_STRUCT_INIT,
      .n_nodes           = 0,
      .signature         = 0x0,
    };

    if ( !ai_platform_api_get_network_report(network, &r) ) return false;
 801d4d2:	a901      	add	r1, sp, #4
 801d4d4:	4620      	mov	r0, r4
    ai_network_report r = {
 801d4d6:	e9cd 230b 	strd	r2, r3, [sp, #44]	; 0x2c
    if ( !ai_platform_api_get_network_report(network, &r) ) return false;
 801d4da:	f7e6 ffa0 	bl	800441e <ai_platform_api_get_network_report>
 801d4de:	4604      	mov	r4, r0
 801d4e0:	b140      	cbz	r0, 801d4f4 <ai_asc_get_info+0x7c>

    *report = r;
 801d4e2:	2274      	movs	r2, #116	; 0x74
 801d4e4:	a901      	add	r1, sp, #4
 801d4e6:	4628      	mov	r0, r5
 801d4e8:	f00a f81e 	bl	8027528 <memcpy>
    return true;
  }

  return false;
}
 801d4ec:	4620      	mov	r0, r4
 801d4ee:	b01f      	add	sp, #124	; 0x7c
 801d4f0:	bd30      	pop	{r4, r5, pc}
  return false;
 801d4f2:	4604      	mov	r4, r0
}
 801d4f4:	4620      	mov	r0, r4
 801d4f6:	b01f      	add	sp, #124	; 0x7c
 801d4f8:	bd30      	pop	{r4, r5, pc}
  return false;
 801d4fa:	462c      	mov	r4, r5
}
 801d4fc:	4620      	mov	r0, r4
 801d4fe:	b01f      	add	sp, #124	; 0x7c
 801d500:	bd30      	pop	{r4, r5, pc}
 801d502:	bf00      	nop
 801d504:	08041ba0 	.word	0x08041ba0
 801d508:	08041ba4 	.word	0x08041ba4
 801d50c:	08041bc8 	.word	0x08041bc8
 801d510:	08041be4 	.word	0x08041be4
 801d514:	08041bfc 	.word	0x08041bfc
 801d518:	0007e4f1 	.word	0x0007e4f1

0801d51c <ai_asc_get_error>:

AI_API_ENTRY
ai_error ai_asc_get_error(ai_handle network)
{
  return ai_platform_network_get_error(network);
 801d51c:	f7e6 bf53 	b.w	80043c6 <ai_platform_network_get_error>

0801d520 <ai_asc_create>:
}

AI_API_ENTRY
ai_error ai_asc_create(
  ai_handle* network, const ai_buffer* network_config)
{
 801d520:	b510      	push	{r4, lr}
  return ai_platform_network_create(
 801d522:	2303      	movs	r3, #3
{
 801d524:	b082      	sub	sp, #8
  return ai_platform_network_create(
 801d526:	2400      	movs	r4, #0
 801d528:	e9cd 3400 	strd	r3, r4, [sp]
 801d52c:	4a02      	ldr	r2, [pc, #8]	; (801d538 <ai_asc_create+0x18>)
 801d52e:	2301      	movs	r3, #1
 801d530:	f7e7 f834 	bl	800459c <ai_platform_network_create>
    network, network_config, 
    &AI_NET_OBJ_INSTANCE,
    AI_TOOLS_API_VERSION_MAJOR, AI_TOOLS_API_VERSION_MINOR, AI_TOOLS_API_VERSION_MICRO);
}
 801d534:	b002      	add	sp, #8
 801d536:	bd10      	pop	{r4, pc}
 801d538:	200004ec 	.word	0x200004ec

0801d53c <ai_asc_destroy>:

AI_API_ENTRY
ai_handle ai_asc_destroy(ai_handle network)
{
  return ai_platform_network_destroy(network);
 801d53c:	f7e7 b873 	b.w	8004626 <ai_platform_network_destroy>

0801d540 <ai_asc_init>:
}

AI_API_ENTRY
ai_bool ai_asc_init(
  ai_handle network, const ai_network_params* params)
{
 801d540:	b538      	push	{r3, r4, r5, lr}
 801d542:	460c      	mov	r4, r1
  ai_network* net_ctx = ai_platform_network_init(network, params);
 801d544:	f7e7 f892 	bl	800466c <ai_platform_network_init>
  if ( !net_ctx ) return false;
 801d548:	2800      	cmp	r0, #0
 801d54a:	d06e      	beq.n	801d62a <ai_asc_init+0xea>
    dense_2_bias_array.format |= AI_FMT_FLAG_CONST;
 801d54c:	4b37      	ldr	r3, [pc, #220]	; (801d62c <ai_asc_init+0xec>)
 801d54e:	6922      	ldr	r2, [r4, #16]
 801d550:	6d98      	ldr	r0, [r3, #88]	; 0x58
    dense_2_weights_array.format |= AI_FMT_FLAG_CONST;
 801d552:	6e9d      	ldr	r5, [r3, #104]	; 0x68
    conv2d_1_weights_array.data = AI_PTR(weights + 0);
 801d554:	f8c3 20d0 	str.w	r2, [r3, #208]	; 0xd0
    dense_2_bias_array.format |= AI_FMT_FLAG_CONST;
 801d558:	f040 4080 	orr.w	r0, r0, #1073741824	; 0x40000000
 801d55c:	6598      	str	r0, [r3, #88]	; 0x58
    dense_1_weights_array.format |= AI_FMT_FLAG_CONST;
 801d55e:	f8d3 0088 	ldr.w	r0, [r3, #136]	; 0x88
    dense_2_bias_array.data = AI_PTR(weights + 30800);
 801d562:	f502 41f0 	add.w	r1, r2, #30720	; 0x7800
 801d566:	3150      	adds	r1, #80	; 0x50
    dense_1_weights_array.format |= AI_FMT_FLAG_CONST;
 801d568:	f040 4080 	orr.w	r0, r0, #1073741824	; 0x40000000
    dense_2_bias_array.data_start = AI_PTR(weights + 30800);
 801d56c:	e9c3 1118 	strd	r1, r1, [r3, #96]	; 0x60
    dense_1_weights_array.format |= AI_FMT_FLAG_CONST;
 801d570:	f8c3 0088 	str.w	r0, [r3, #136]	; 0x88
    dense_2_weights_array.data = AI_PTR(weights + 30692);
 801d574:	f502 41ef 	add.w	r1, r2, #30592	; 0x7780
    dense_1_weights_array.data = AI_PTR(weights + 9920);
 801d578:	f502 501b 	add.w	r0, r2, #9920	; 0x26c0
    dense_1_weights_array.data_start = AI_PTR(weights + 9920);
 801d57c:	e9c3 0024 	strd	r0, r0, [r3, #144]	; 0x90
    dense_2_weights_array.data = AI_PTR(weights + 30692);
 801d580:	3164      	adds	r1, #100	; 0x64
    conv2d_2_weights_array.format |= AI_FMT_FLAG_CONST;
 801d582:	f8d3 00a8 	ldr.w	r0, [r3, #168]	; 0xa8
    dense_2_weights_array.data_start = AI_PTR(weights + 30692);
 801d586:	e9c3 111c 	strd	r1, r1, [r3, #112]	; 0x70
    conv2d_2_bias_array.format |= AI_FMT_FLAG_CONST;
 801d58a:	f8d3 1098 	ldr.w	r1, [r3, #152]	; 0x98
    dense_2_weights_array.format |= AI_FMT_FLAG_CONST;
 801d58e:	f045 4580 	orr.w	r5, r5, #1073741824	; 0x40000000
    conv2d_2_weights_array.format |= AI_FMT_FLAG_CONST;
 801d592:	f040 4080 	orr.w	r0, r0, #1073741824	; 0x40000000
    dense_2_weights_array.format |= AI_FMT_FLAG_CONST;
 801d596:	669d      	str	r5, [r3, #104]	; 0x68
    conv2d_2_bias_array.format |= AI_FMT_FLAG_CONST;
 801d598:	f041 4180 	orr.w	r1, r1, #1073741824	; 0x40000000
    dense_1_bias_array.format |= AI_FMT_FLAG_CONST;
 801d59c:	6f9d      	ldr	r5, [r3, #120]	; 0x78
    conv2d_2_weights_array.format |= AI_FMT_FLAG_CONST;
 801d59e:	f8c3 00a8 	str.w	r0, [r3, #168]	; 0xa8
    conv2d_1_bias_array.format |= AI_FMT_FLAG_CONST;
 801d5a2:	f8d3 00b8 	ldr.w	r0, [r3, #184]	; 0xb8
    conv2d_2_bias_array.format |= AI_FMT_FLAG_CONST;
 801d5a6:	f8c3 1098 	str.w	r1, [r3, #152]	; 0x98
    conv2d_1_weights_array.format |= AI_FMT_FLAG_CONST;
 801d5aa:	f8d3 10c8 	ldr.w	r1, [r3, #200]	; 0xc8
    dense_1_bias_array.format |= AI_FMT_FLAG_CONST;
 801d5ae:	f045 4580 	orr.w	r5, r5, #1073741824	; 0x40000000
    conv2d_1_bias_array.format |= AI_FMT_FLAG_CONST;
 801d5b2:	f040 4080 	orr.w	r0, r0, #1073741824	; 0x40000000
    dense_1_bias_array.format |= AI_FMT_FLAG_CONST;
 801d5b6:	679d      	str	r5, [r3, #120]	; 0x78
    conv2d_1_bias_array.format |= AI_FMT_FLAG_CONST;
 801d5b8:	f8c3 00b8 	str.w	r0, [r3, #184]	; 0xb8
    conv2d_2_bias_array.data = AI_PTR(weights + 9856);
 801d5bc:	f502 551a 	add.w	r5, r2, #9856	; 0x2680
    conv2d_1_weights_array.format |= AI_FMT_FLAG_CONST;
 801d5c0:	f041 4180 	orr.w	r1, r1, #1073741824	; 0x40000000
    dense_1_bias_array.data = AI_PTR(weights + 30656);
 801d5c4:	f502 40ef 	add.w	r0, r2, #30592	; 0x7780
    conv2d_2_bias_array.data_start = AI_PTR(weights + 9856);
 801d5c8:	e9c3 5528 	strd	r5, r5, [r3, #160]	; 0xa0
    conv2d_1_weights_array.format |= AI_FMT_FLAG_CONST;
 801d5cc:	f8c3 10c8 	str.w	r1, [r3, #200]	; 0xc8
    conv2d_2_weights_array.data = AI_PTR(weights + 640);
 801d5d0:	f502 7520 	add.w	r5, r2, #640	; 0x280
    conv2d_1_bias_array.data = AI_PTR(weights + 576);
 801d5d4:	f502 7110 	add.w	r1, r2, #576	; 0x240
    dense_1_bias_array.data = AI_PTR(weights + 30656);
 801d5d8:	3040      	adds	r0, #64	; 0x40
    conv2d_1_bias_array.data_start = AI_PTR(weights + 576);
 801d5da:	e9c3 1130 	strd	r1, r1, [r3, #192]	; 0xc0
    dense_1_bias_array.data_start = AI_PTR(weights + 30656);
 801d5de:	e9c3 0020 	strd	r0, r0, [r3, #128]	; 0x80
    conv2d_2_weights_array.data_start = AI_PTR(weights + 640);
 801d5e2:	e9c3 552c 	strd	r5, r5, [r3, #176]	; 0xb0
    conv2d_1_weights_array.data_start = AI_PTR(weights + 0);
 801d5e6:	f8c3 20d4 	str.w	r2, [r3, #212]	; 0xd4
  ai_ptr activations = AI_PTR(AI_PTR_ALIGN(activation_buffer->data, 4));
 801d5ea:	6aa2      	ldr	r2, [r4, #40]	; 0x28
 801d5ec:	3203      	adds	r2, #3
 801d5ee:	f022 0203 	bic.w	r2, r2, #3
    input_0_output_array.data = AI_PTR(NULL);
 801d5f2:	2100      	movs	r1, #0
    conv2d_1_output_array.data = AI_PTR(activations + 3968);
 801d5f4:	f502 6478 	add.w	r4, r2, #3968	; 0xf80
    conv2d_2_output_array.data = AI_PTR(activations + 1664);
 801d5f8:	f502 60d0 	add.w	r0, r2, #1664	; 0x680
    conv2d_2_scratch0_array.data_start = AI_PTR(activations + 0);
 801d5fc:	e9c3 2238 	strd	r2, r2, [r3, #224]	; 0xe0
    conv2d_1_scratch0_array.data_start = AI_PTR(activations + 0);
 801d600:	e9c3 223c 	strd	r2, r2, [r3, #240]	; 0xf0
    conv2d_1_output_array.data_start = AI_PTR(activations + 3968);
 801d604:	e9c3 4444 	strd	r4, r4, [r3, #272]	; 0x110
    dense_1_output_array.data_start = AI_PTR(activations + 0);
 801d608:	e9c3 224c 	strd	r2, r2, [r3, #304]	; 0x130
    dense_1_nl_output_array.data_start = AI_PTR(activations + 0);
 801d60c:	e9c3 2250 	strd	r2, r2, [r3, #320]	; 0x140
    dense_2_nl_output_array.data_start = AI_PTR(NULL);
 801d610:	e9c3 1158 	strd	r1, r1, [r3, #352]	; 0x160
    conv2d_2_output_array.data_start = AI_PTR(activations + 1664);
 801d614:	e9c3 0048 	strd	r0, r0, [r3, #288]	; 0x120
    dense_2_output_array.data = AI_PTR(activations + 36);
 801d618:	f102 0024 	add.w	r0, r2, #36	; 0x24
    dense_2_output_array.data_start = AI_PTR(activations + 36);
 801d61c:	e9c3 0054 	strd	r0, r0, [r3, #336]	; 0x150
    input_0_output_array.data = AI_PTR(NULL);
 801d620:	f8c3 1100 	str.w	r1, [r3, #256]	; 0x100
    input_0_output_array.data_start = AI_PTR(NULL);
 801d624:	f8c3 1104 	str.w	r1, [r3, #260]	; 0x104

  ai_bool ok = true;
  ok &= asc_configure_weights(net_ctx, &params->params);
  ok &= asc_configure_activations(net_ctx, &params->activations);

  return ok;
 801d628:	2001      	movs	r0, #1
}
 801d62a:	bd38      	pop	{r3, r4, r5, pc}
 801d62c:	200004ec 	.word	0x200004ec

0801d630 <ai_asc_run>:

AI_API_ENTRY
ai_i32 ai_asc_run(
  ai_handle network, const ai_buffer* input, ai_buffer* output)
{
  return ai_platform_network_process(network, input, output);
 801d630:	f7e7 b878 	b.w	8004724 <ai_platform_network_process>

0801d634 <ai_asc_forward>:
}

AI_API_ENTRY
ai_i32 ai_asc_forward(ai_handle network, const ai_buffer* input)
{
  return ai_platform_network_process(network, input, NULL);
 801d634:	2200      	movs	r2, #0
 801d636:	f7e7 b875 	b.w	8004724 <ai_platform_network_process>
 801d63a:	bf00      	nop

0801d63c <ai_asc_data_weights_get>:
		    0x60, 0xb5, 0xd6, 0x3d, 0x2a, 0xe8, 0xdd, 0xbc, 0x32, 0xb5,
		    0xd5, 0xbc, 0x91, 0xee, 0xbf, 0x3d, 0xdf, 0x1c, 0xc1, 0xbd
  };

  return AI_HANDLE_PTR(s_asc_weights);
}
 801d63c:	4800      	ldr	r0, [pc, #0]	; (801d640 <ai_asc_data_weights_get+0x4>)
 801d63e:	4770      	bx	lr
 801d640:	08035b8c 	.word	0x08035b8c

0801d644 <ASC_PostProc>:
 * @brief      ASC postprocessing
 * @param[in]  pNNOut  The CNN result
 * @retval     Classification result
 */
ASC_OutputTypeDef ASC_PostProc(float32_t *pNNOut)
{
 801d644:	b538      	push	{r3, r4, r5, lr}
  float32_t max_out;
  uint32_t classification_result;

  /* ASC NN Output FIFO buffers left shift */
  memmove(ascNNOutBuffer0, ascNNOutBuffer0 + 1, sizeof(float32_t) * (PP_FLT_LENGTH - 1));
 801d646:	4d4e      	ldr	r5, [pc, #312]	; (801d780 <ASC_PostProc+0x13c>)
{
 801d648:	4604      	mov	r4, r0
  memmove(ascNNOutBuffer0, ascNNOutBuffer0 + 1, sizeof(float32_t) * (PP_FLT_LENGTH - 1));
 801d64a:	2218      	movs	r2, #24
 801d64c:	1d29      	adds	r1, r5, #4
 801d64e:	4628      	mov	r0, r5
 801d650:	f009 ff78 	bl	8027544 <memmove>
  memmove(ascNNOutBuffer1, ascNNOutBuffer1 + 1, sizeof(float32_t) * (PP_FLT_LENGTH - 1));
 801d654:	2218      	movs	r2, #24
 801d656:	f105 0120 	add.w	r1, r5, #32
 801d65a:	f105 001c 	add.w	r0, r5, #28
 801d65e:	f009 ff71 	bl	8027544 <memmove>
  memmove(ascNNOutBuffer2, ascNNOutBuffer2 + 1, sizeof(float32_t) * (PP_FLT_LENGTH - 1));
 801d662:	2218      	movs	r2, #24
 801d664:	f105 013c 	add.w	r1, r5, #60	; 0x3c
 801d668:	f105 0038 	add.w	r0, r5, #56	; 0x38
 801d66c:	f009 ff6a 	bl	8027544 <memmove>
  ascNNOutBuffer0[PP_FLT_LENGTH - 1] = pNNOut[0];
 801d670:	6823      	ldr	r3, [r4, #0]
 801d672:	61ab      	str	r3, [r5, #24]
  ascNNOutBuffer1[PP_FLT_LENGTH - 1] = pNNOut[1];
 801d674:	6863      	ldr	r3, [r4, #4]
  ascNNOutBuffer2[PP_FLT_LENGTH - 1] = pNNOut[2];

  /* Reset of network out to be filled with the average of the ASC out Buffer */
  pNNOut[0] = 0.0f;
 801d676:	ed9f 6a43 	vldr	s12, [pc, #268]	; 801d784 <ASC_PostProc+0x140>
  ascNNOutBuffer1[PP_FLT_LENGTH - 1] = pNNOut[1];
 801d67a:	636b      	str	r3, [r5, #52]	; 0x34
  ascNNOutBuffer2[PP_FLT_LENGTH - 1] = pNNOut[2];
 801d67c:	68a1      	ldr	r1, [r4, #8]
 801d67e:	6529      	str	r1, [r5, #80]	; 0x50
  pNNOut[0] = 0.0f;
 801d680:	f105 021c 	add.w	r2, r5, #28
  pNNOut[1] = 0.0f;
  pNNOut[2] = 0.0f;
 801d684:	eef0 7a46 	vmov.f32	s15, s12
 801d688:	462b      	mov	r3, r5
 801d68a:	eeb0 7a46 	vmov.f32	s14, s12
 801d68e:	eef0 6a46 	vmov.f32	s13, s12
 801d692:	f105 0138 	add.w	r1, r5, #56	; 0x38
  pNNOut[0] = 0.0f;
 801d696:	ed84 6a00 	vstr	s12, [r4]
  pNNOut[1] = 0.0f;
 801d69a:	ed84 6a01 	vstr	s12, [r4, #4]
  pNNOut[2] = 0.0f;
 801d69e:	ed84 6a02 	vstr	s12, [r4, #8]

  /* Averaging ASC NN Outputs over a Buffer of Filter Length inferences */
  for (uint32_t i = 0; i < PP_FLT_LENGTH; i++)
 801d6a2:	4610      	mov	r0, r2
  {
    pNNOut[0] += ascNNOutBuffer0[i];
 801d6a4:	ecb3 6a01 	vldmia	r3!, {s12}
 801d6a8:	ee76 6a86 	vadd.f32	s13, s13, s12
  for (uint32_t i = 0; i < PP_FLT_LENGTH; i++)
 801d6ac:	4283      	cmp	r3, r0
    pNNOut[0] += ascNNOutBuffer0[i];
 801d6ae:	edc4 6a00 	vstr	s13, [r4]
    pNNOut[1] += ascNNOutBuffer1[i];
 801d6b2:	ecb2 6a01 	vldmia	r2!, {s12}
 801d6b6:	ee37 7a06 	vadd.f32	s14, s14, s12
 801d6ba:	ed84 7a01 	vstr	s14, [r4, #4]
    pNNOut[2] += ascNNOutBuffer2[i];
 801d6be:	ecb1 6a01 	vldmia	r1!, {s12}
 801d6c2:	ee77 7a86 	vadd.f32	s15, s15, s12
 801d6c6:	edc4 7a02 	vstr	s15, [r4, #8]
  for (uint32_t i = 0; i < PP_FLT_LENGTH; i++)
 801d6ca:	d1eb      	bne.n	801d6a4 <ASC_PostProc+0x60>
  }
  pNNOut[0] /= (float32_t) PP_FLT_LENGTH;
 801d6cc:	eef1 5a0c 	vmov.f32	s11, #28	; 0x40e00000  7.0
 801d6d0:	ee86 6aa5 	vdiv.f32	s12, s13, s11
      max_out = pNNOut[i];
      classification_result = i;
    }
  }

  if(W2ST_CHECK_CONNECTION(W2ST_CONNECT_STD_TERM)) {
 801d6d4:	4b2c      	ldr	r3, [pc, #176]	; (801d788 <ASC_PostProc+0x144>)
 801d6d6:	681b      	ldr	r3, [r3, #0]
  pNNOut[1] /= (float32_t) PP_FLT_LENGTH;
 801d6d8:	eec7 6a25 	vdiv.f32	s13, s14, s11
  pNNOut[2] /= (float32_t) PP_FLT_LENGTH;
 801d6dc:	ee87 7aa5 	vdiv.f32	s14, s15, s11
    if (pNNOut[i] > max_out)
 801d6e0:	eeb4 6ae6 	vcmpe.f32	s12, s13
 801d6e4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801d6e8:	bf4c      	ite	mi
 801d6ea:	eef0 7a66 	vmovmi.f32	s15, s13
  max_out = pNNOut[0];
 801d6ee:	eef0 7a46 	vmovpl.f32	s15, s12
    if (pNNOut[i] > max_out)
 801d6f2:	eeb4 7ae7 	vcmpe.f32	s14, s15
  pNNOut[0] /= (float32_t) PP_FLT_LENGTH;
 801d6f6:	ed84 6a00 	vstr	s12, [r4]
  pNNOut[1] /= (float32_t) PP_FLT_LENGTH;
 801d6fa:	edc4 6a01 	vstr	s13, [r4, #4]
  pNNOut[2] /= (float32_t) PP_FLT_LENGTH;
 801d6fe:	ed84 7a02 	vstr	s14, [r4, #8]
  for (uint32_t i = 1; i < 3; i++)
 801d702:	bf4c      	ite	mi
 801d704:	2401      	movmi	r4, #1
  classification_result = 0;
 801d706:	2400      	movpl	r4, #0
    if (pNNOut[i] > max_out)
 801d708:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    Term_Update(BufferToWrite,BytesToWrite);
  } else {
    SENSING1_PRINTF("ASC=   %ld%% %ld%% %ld%%\r\n", (int32_t) (pNNOut[0] * 100), (int32_t)(pNNOut[1] * 100), (int32_t)(pNNOut[2] * 100));
  }

  return (ASC_OutputTypeDef) classification_result;
 801d70c:	bfd2      	itee	le
 801d70e:	b2e4      	uxtble	r4, r4
    if (pNNOut[i] > max_out)
 801d710:	eef0 7a47 	vmovgt.f32	s15, s14
 801d714:	2402      	movgt	r4, #2
  if(W2ST_CHECK_CONNECTION(W2ST_CONNECT_STD_TERM)) {
 801d716:	069b      	lsls	r3, r3, #26
 801d718:	d41d      	bmi.n	801d756 <ASC_PostProc+0x112>
    SENSING1_PRINTF("ASC=   %ld%% %ld%% %ld%%\r\n", (int32_t) (pNNOut[0] * 100), (int32_t)(pNNOut[1] * 100), (int32_t)(pNNOut[2] * 100));
 801d71a:	4b1c      	ldr	r3, [pc, #112]	; (801d78c <ASC_PostProc+0x148>)
 801d71c:	781b      	ldrb	r3, [r3, #0]
 801d71e:	b90b      	cbnz	r3, 801d724 <ASC_PostProc+0xe0>
}
 801d720:	4620      	mov	r0, r4
 801d722:	bd38      	pop	{r3, r4, r5, pc}
    SENSING1_PRINTF("ASC=   %ld%% %ld%% %ld%%\r\n", (int32_t) (pNNOut[0] * 100), (int32_t)(pNNOut[1] * 100), (int32_t)(pNNOut[2] * 100));
 801d724:	eddf 7a1a 	vldr	s15, [pc, #104]	; 801d790 <ASC_PostProc+0x14c>
 801d728:	481a      	ldr	r0, [pc, #104]	; (801d794 <ASC_PostProc+0x150>)
 801d72a:	ee27 7a27 	vmul.f32	s14, s14, s15
 801d72e:	ee66 6aa7 	vmul.f32	s13, s13, s15
 801d732:	ee26 6a27 	vmul.f32	s12, s12, s15
 801d736:	eefd 7ac7 	vcvt.s32.f32	s15, s14
 801d73a:	ee17 3a90 	vmov	r3, s15
 801d73e:	eefd 7ae6 	vcvt.s32.f32	s15, s13
 801d742:	ee17 2a90 	vmov	r2, s15
 801d746:	eefd 7ac6 	vcvt.s32.f32	s15, s12
 801d74a:	ee17 1a90 	vmov	r1, s15
 801d74e:	f00a fc65 	bl	802801c <iprintf>
}
 801d752:	4620      	mov	r0, r4
 801d754:	bd38      	pop	{r3, r4, r5, pc}
    BytesToWrite = sprintf((char *)BufferToWrite,"NNconfidence = %ld%%\n", (int32_t)(max_out * 100));
 801d756:	ed9f 7a0e 	vldr	s14, [pc, #56]	; 801d790 <ASC_PostProc+0x14c>
 801d75a:	490f      	ldr	r1, [pc, #60]	; (801d798 <ASC_PostProc+0x154>)
 801d75c:	480f      	ldr	r0, [pc, #60]	; (801d79c <ASC_PostProc+0x158>)
 801d75e:	ee67 7a87 	vmul.f32	s15, s15, s14
 801d762:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 801d766:	ee17 2a90 	vmov	r2, s15
 801d76a:	f00a fd0b 	bl	8028184 <siprintf>
 801d76e:	4a0c      	ldr	r2, [pc, #48]	; (801d7a0 <ASC_PostProc+0x15c>)
 801d770:	4603      	mov	r3, r0
    Term_Update(BufferToWrite,BytesToWrite);
 801d772:	b2c1      	uxtb	r1, r0
 801d774:	4809      	ldr	r0, [pc, #36]	; (801d79c <ASC_PostProc+0x158>)
    BytesToWrite = sprintf((char *)BufferToWrite,"NNconfidence = %ld%%\n", (int32_t)(max_out * 100));
 801d776:	6013      	str	r3, [r2, #0]
    Term_Update(BufferToWrite,BytesToWrite);
 801d778:	f005 fc9a 	bl	80230b0 <Term_Update>
}
 801d77c:	4620      	mov	r0, r4
 801d77e:	bd38      	pop	{r3, r4, r5, pc}
 801d780:	200094dc 	.word	0x200094dc
 801d784:	00000000 	.word	0x00000000
 801d788:	2001457c 	.word	0x2001457c
 801d78c:	20000d84 	.word	0x20000d84
 801d790:	42c80000 	.word	0x42c80000
 801d794:	08041c20 	.word	0x08041c20
 801d798:	08041c08 	.word	0x08041c08
 801d79c:	200133dc 	.word	0x200133dc
 801d7a0:	200134dc 	.word	0x200134dc

0801d7a4 <ASC_Init>:
  * @brief  Create and Init ASC Convolutional Neural Network
  *
  * @retval ASC Status
  */
ASC_StatusTypeDef ASC_Init(void)
{
 801d7a4:	b570      	push	{r4, r5, r6, lr}
 * @retval none
 */
static void Preprocessing_Init(void)
{
  /* Init RFFT */
  arm_rfft_fast_init_f32(&S_Rfft, 1024);
 801d7a6:	4c1c      	ldr	r4, [pc, #112]	; (801d818 <ASC_Init+0x74>)
  ClassificationCode = ASC_UNDEFINED;
 801d7a8:	4b1c      	ldr	r3, [pc, #112]	; (801d81c <ASC_Init+0x78>)

  /* Init Spectrogram */
  S_Spectr.pRfft    = &S_Rfft;
  S_Spectr.Type     = SPECTRUM_TYPE_POWER;
  S_Spectr.pWindow  = (float32_t *) hannWin_1024;
 801d7aa:	4e1d      	ldr	r6, [pc, #116]	; (801d820 <ASC_Init+0x7c>)
  S_Spectr.SampRate = 16000;
  S_Spectr.FrameLen = 1024;
  S_Spectr.FFTLen   = 1024;
  S_Spectr.pScratch = aWorkingBuffer1;
 801d7ac:	4d1d      	ldr	r5, [pc, #116]	; (801d824 <ASC_Init+0x80>)
{
 801d7ae:	b082      	sub	sp, #8
  ClassificationCode = ASC_UNDEFINED;
 801d7b0:	22ff      	movs	r2, #255	; 0xff
  arm_rfft_fast_init_f32(&S_Rfft, 1024);
 801d7b2:	f44f 6180 	mov.w	r1, #1024	; 0x400
 801d7b6:	4620      	mov	r0, r4
  ClassificationCode = ASC_UNDEFINED;
 801d7b8:	701a      	strb	r2, [r3, #0]
  arm_rfft_fast_init_f32(&S_Rfft, 1024);
 801d7ba:	f008 fbcb 	bl	8025f54 <arm_rfft_fast_init_f32>
  __HAL_RCC_CRC_CLK_ENABLE();
 801d7be:	4b1a      	ldr	r3, [pc, #104]	; (801d828 <ASC_Init+0x84>)
 801d7c0:	6c9a      	ldr	r2, [r3, #72]	; 0x48
 801d7c2:	f442 5280 	orr.w	r2, r2, #4096	; 0x1000
 801d7c6:	649a      	str	r2, [r3, #72]	; 0x48
 801d7c8:	6c9b      	ldr	r3, [r3, #72]	; 0x48
  S_Spectr.pRfft    = &S_Rfft;
 801d7ca:	61a4      	str	r4, [r4, #24]
  __HAL_RCC_CRC_CLK_ENABLE();
 801d7cc:	f403 5380 	and.w	r3, r3, #4096	; 0x1000
 801d7d0:	9301      	str	r3, [sp, #4]
 801d7d2:	9b01      	ldr	r3, [sp, #4]
  S_Spectr.SampRate = 16000;
 801d7d4:	f44f 537a 	mov.w	r3, #16000	; 0x3e80
  S_Spectr.pWindow  = (float32_t *) hannWin_1024;
 801d7d8:	e9c4 6308 	strd	r6, r3, [r4, #32]

  /* Init Mel filter */
  S_MelFilter.pStartIndices = (uint32_t *) melFiltersStartIndices_1024_30;
 801d7dc:	4b13      	ldr	r3, [pc, #76]	; (801d82c <ASC_Init+0x88>)
  S_Spectr.Type     = SPECTRUM_TYPE_POWER;
 801d7de:	2201      	movs	r2, #1
  S_MelFilter.pStartIndices = (uint32_t *) melFiltersStartIndices_1024_30;
 801d7e0:	e9c4 530c 	strd	r5, r3, [r4, #48]	; 0x30
  S_Spectr.Type     = SPECTRUM_TYPE_POWER;
 801d7e4:	7722      	strb	r2, [r4, #28]
  S_MelFilter.pStopIndices  = (uint32_t *) melFiltersStopIndices_1024_30;
  S_MelFilter.pCoefficients = (float32_t *) melFilterLut_1024_30;
 801d7e6:	4b12      	ldr	r3, [pc, #72]	; (801d830 <ASC_Init+0x8c>)
  S_MelFilter.pStopIndices  = (uint32_t *) melFiltersStopIndices_1024_30;
 801d7e8:	4a12      	ldr	r2, [pc, #72]	; (801d834 <ASC_Init+0x90>)
  S_Spectr.FrameLen = 1024;
 801d7ea:	f44f 6080 	mov.w	r0, #1024	; 0x400
  S_MelFilter.pCoefficients = (float32_t *) melFilterLut_1024_30;
 801d7ee:	e9c4 230e 	strd	r2, r3, [r4, #56]	; 0x38
  S_Spectr.FFTLen   = 1024;
 801d7f2:	e9c4 000a 	strd	r0, r0, [r4, #40]	; 0x28
  S_MelFilter.NumMels       = 30;

  /* Init MelSpectrogram */
  S_MelSpectr.SpectrogramConf = &S_Spectr;
 801d7f6:	f104 0218 	add.w	r2, r4, #24
  S_MelSpectr.MelFilter       = &S_MelFilter;
 801d7fa:	f104 0334 	add.w	r3, r4, #52	; 0x34
  if (aiInit(AI_ASC_MODEL_NAME,AI_ASC_MODEL_CTX))
 801d7fe:	2103      	movs	r1, #3
  S_MelFilter.NumMels       = 30;
 801d800:	251e      	movs	r5, #30
  if (aiInit(AI_ASC_MODEL_NAME,AI_ASC_MODEL_CTX))
 801d802:	480d      	ldr	r0, [pc, #52]	; (801d838 <ASC_Init+0x94>)
  S_MelFilter.NumMels       = 30;
 801d804:	6465      	str	r5, [r4, #68]	; 0x44
  S_MelSpectr.MelFilter       = &S_MelFilter;
 801d806:	e9c4 2319 	strd	r2, r3, [r4, #100]	; 0x64
  if (aiInit(AI_ASC_MODEL_NAME,AI_ASC_MODEL_CTX))
 801d80a:	f002 fc09 	bl	8020020 <aiInit>
}
 801d80e:	3800      	subs	r0, #0
 801d810:	bf18      	it	ne
 801d812:	2001      	movne	r0, #1
 801d814:	b002      	add	sp, #8
 801d816:	bd70      	pop	{r4, r5, r6, pc}
 801d818:	20009530 	.word	0x20009530
 801d81c:	20000d5c 	.word	0x20000d5c
 801d820:	08034b44 	.word	0x08034b44
 801d824:	2000a518 	.word	0x2000a518
 801d828:	40021000 	.word	0x40021000
 801d82c:	08030acc 	.word	0x08030acc
 801d830:	0802fb34 	.word	0x0802fb34
 801d834:	08030a54 	.word	0x08030a54
 801d838:	08041ba0 	.word	0x08041ba0

0801d83c <ASC_DeInit>:
{
 801d83c:	b508      	push	{r3, lr}
  if (aiDeInit(AI_ASC_MODEL_NAME,AI_ASC_MODEL_CTX))
 801d83e:	4806      	ldr	r0, [pc, #24]	; (801d858 <ASC_DeInit+0x1c>)
 801d840:	2103      	movs	r1, #3
 801d842:	f002 fdf3 	bl	802042c <aiDeInit>
 801d846:	b928      	cbnz	r0, 801d854 <ASC_DeInit+0x18>
  __HAL_RCC_CRC_CLK_DISABLE();
 801d848:	4a04      	ldr	r2, [pc, #16]	; (801d85c <ASC_DeInit+0x20>)
 801d84a:	6c93      	ldr	r3, [r2, #72]	; 0x48
 801d84c:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
 801d850:	6493      	str	r3, [r2, #72]	; 0x48
}
 801d852:	bd08      	pop	{r3, pc}
    return ASC_ERROR ;
 801d854:	2001      	movs	r0, #1
}
 801d856:	bd08      	pop	{r3, pc}
 801d858:	08041ba0 	.word	0x08041ba0
 801d85c:	40021000 	.word	0x40021000

0801d860 <ASC_GetClassificationCode>:
  return ClassificationCode;
 801d860:	4b01      	ldr	r3, [pc, #4]	; (801d868 <ASC_GetClassificationCode+0x8>)
}
 801d862:	7818      	ldrb	r0, [r3, #0]
 801d864:	4770      	bx	lr
 801d866:	bf00      	nop
 801d868:	20000d5c 	.word	0x20000d5c

0801d86c <ASC_NN_Run>:
{
 801d86c:	b570      	push	{r4, r5, r6, lr}
 801d86e:	4c16      	ldr	r4, [pc, #88]	; (801d8c8 <ASC_NN_Run+0x5c>)
 801d870:	4d16      	ldr	r5, [pc, #88]	; (801d8cc <ASC_NN_Run+0x60>)
 801d872:	f5ad 7d72 	sub.w	sp, sp, #968	; 0x3c8
 801d876:	4602      	mov	r2, r0
 801d878:	460e      	mov	r6, r1
 801d87a:	4684      	mov	ip, r0
 801d87c:	f504 6e70 	add.w	lr, r4, #3840	; 0xf00
    pSpectrogram[i] = (pSpectrogram[i] - featureScalerMean[i]) / featureScalerStd[i];
 801d880:	ecb4 7a01 	vldmia	r4!, {s14}
 801d884:	eddc 7a00 	vldr	s15, [ip]
 801d888:	ecf5 6a01 	vldmia	r5!, {s13}
 801d88c:	ee77 7ac7 	vsub.f32	s15, s15, s14
  for (uint32_t i = 0; i < SPECTROGRAM_ROWS * SPECTROGRAM_COLS; i++)
 801d890:	4574      	cmp	r4, lr
    pSpectrogram[i] = (pSpectrogram[i] - featureScalerMean[i]) / featureScalerStd[i];
 801d892:	ee87 7aa6 	vdiv.f32	s14, s15, s13
 801d896:	ecac 7a01 	vstmia	ip!, {s14}
  for (uint32_t i = 0; i < SPECTROGRAM_ROWS * SPECTROGRAM_COLS; i++)
 801d89a:	d1f1      	bne.n	801d880 <ASC_NN_Run+0x14>
  aiConvertInputFloat_2_Int8(AI_ASC_MODEL_NAME, AI_ASC_MODEL_CTX,pSpectrogram, AscNnInput);
 801d89c:	ab02      	add	r3, sp, #8
 801d89e:	2103      	movs	r1, #3
 801d8a0:	480b      	ldr	r0, [pc, #44]	; (801d8d0 <ASC_NN_Run+0x64>)
 801d8a2:	f002 fa25 	bl	801fcf0 <aiConvertInputFloat_2_Int8>
  aiRun(AI_ASC_MODEL_NAME, AI_ASC_MODEL_CTX, AscNnInput,AscNnOutput);
 801d8a6:	ab01      	add	r3, sp, #4
 801d8a8:	aa02      	add	r2, sp, #8
 801d8aa:	2103      	movs	r1, #3
 801d8ac:	4808      	ldr	r0, [pc, #32]	; (801d8d0 <ASC_NN_Run+0x64>)
 801d8ae:	f002 fb3f 	bl	801ff30 <aiRun>
  aiConvertOutputInt8_2_Float(AI_ASC_MODEL_NAME, AI_ASC_MODEL_CTX,AscNnOutput, pNetworkOut);
 801d8b2:	4633      	mov	r3, r6
 801d8b4:	aa01      	add	r2, sp, #4
 801d8b6:	2103      	movs	r1, #3
 801d8b8:	4805      	ldr	r0, [pc, #20]	; (801d8d0 <ASC_NN_Run+0x64>)
 801d8ba:	f002 fab5 	bl	801fe28 <aiConvertOutputInt8_2_Float>
}
 801d8be:	2000      	movs	r0, #0
 801d8c0:	f50d 7d72 	add.w	sp, sp, #968	; 0x3c8
 801d8c4:	bd70      	pop	{r4, r5, r6, pc}
 801d8c6:	bf00      	nop
 801d8c8:	0803892c 	.word	0x0803892c
 801d8cc:	08037a2c 	.word	0x08037a2c
 801d8d0:	08041ba0 	.word	0x08041ba0

0801d8d4 <ASC_Run>:
{
 801d8d4:	b570      	push	{r4, r5, r6, lr}
 801d8d6:	ed2d 8b02 	vpush	{d8}
   MelSpectrogramColumn(&S_MelSpectr, pBuffer, aColBuffer);
 801d8da:	4e36      	ldr	r6, [pc, #216]	; (801d9b4 <ASC_Run+0xe0>)
{
 801d8dc:	b084      	sub	sp, #16
  ai_float dense_2_out[AI_ASC_OUT_1_SIZE] = {0.0, 0.0, 0.0};
 801d8de:	2300      	movs	r3, #0
{
 801d8e0:	4601      	mov	r1, r0
   MelSpectrogramColumn(&S_MelSpectr, pBuffer, aColBuffer);
 801d8e2:	f106 026c 	add.w	r2, r6, #108	; 0x6c
 801d8e6:	f106 0064 	add.w	r0, r6, #100	; 0x64
  ai_float dense_2_out[AI_ASC_OUT_1_SIZE] = {0.0, 0.0, 0.0};
 801d8ea:	9301      	str	r3, [sp, #4]
 801d8ec:	9302      	str	r3, [sp, #8]
 801d8ee:	9303      	str	r3, [sp, #12]
   MelSpectrogramColumn(&S_MelSpectr, pBuffer, aColBuffer);
 801d8f0:	f7fd fd26 	bl	801b340 <MelSpectrogramColumn>
    aSpectrogram[i * SPECTROGRAM_COLS + SpectrColIndex] = aColBuffer[i];
 801d8f4:	f8d6 50e4 	ldr.w	r5, [r6, #228]	; 0xe4
 801d8f8:	f106 04e8 	add.w	r4, r6, #232	; 0xe8
 801d8fc:	f106 036c 	add.w	r3, r6, #108	; 0x6c
 801d900:	eb04 0285 	add.w	r2, r4, r5, lsl #2
 801d904:	f106 00e4 	add.w	r0, r6, #228	; 0xe4
 801d908:	f853 1b04 	ldr.w	r1, [r3], #4
 801d90c:	f842 1b80 	str.w	r1, [r2], #128
  for (uint32_t i = 0; i < NMELS; i++) {
 801d910:	4283      	cmp	r3, r0
 801d912:	d1f9      	bne.n	801d908 <ASC_Run+0x34>
  if (SpectrColIndex == SPECTROGRAM_COLS)
 801d914:	2d1f      	cmp	r5, #31
  SpectrColIndex++;
 801d916:	f105 0301 	add.w	r3, r5, #1
  if (SpectrColIndex == SPECTROGRAM_COLS)
 801d91a:	d006      	beq.n	801d92a <ASC_Run+0x56>
    return ASC_UNDEFINED;
 801d91c:	20ff      	movs	r0, #255	; 0xff
  SpectrColIndex++;
 801d91e:	f8c6 30e4 	str.w	r3, [r6, #228]	; 0xe4
}
 801d922:	b004      	add	sp, #16
 801d924:	ecbd 8b02 	vpop	{d8}
 801d928:	bd70      	pop	{r4, r5, r6, pc}
    SpectrColIndex = 0;
 801d92a:	4d23      	ldr	r5, [pc, #140]	; (801d9b8 <ASC_Run+0xe4>)
 * @param      pSpectrogram  Mel-scaled power spectrogram
 * @retval     none
 */
static void PowerTodB(float32_t *pSpectrogram)
{
  float32_t max_mel_energy = 0.0f;
 801d92c:	eddf 7a23 	vldr	s15, [pc, #140]	; 801d9bc <ASC_Run+0xe8>
    SpectrColIndex = 0;
 801d930:	2300      	movs	r3, #0
 801d932:	f8c6 30e4 	str.w	r3, [r6, #228]	; 0xe4
  uint32_t i;

  /* Find MelEnergy Scaling factor */
  for (i = 0; i < NMELS * SPECTROGRAM_COLS; i++) {
 801d936:	f505 6670 	add.w	r6, r5, #3840	; 0xf00
    SpectrColIndex = 0;
 801d93a:	462b      	mov	r3, r5
    max_mel_energy = (max_mel_energy > pSpectrogram[i]) ? max_mel_energy : pSpectrogram[i];
 801d93c:	ecb3 7a01 	vldmia	r3!, {s14}
 801d940:	eeb4 7ae7 	vcmpe.f32	s14, s15
 801d944:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801d948:	bf58      	it	pl
 801d94a:	eef0 7a47 	vmovpl.f32	s15, s14
  for (i = 0; i < NMELS * SPECTROGRAM_COLS; i++) {
 801d94e:	42b3      	cmp	r3, r6
 801d950:	d1f4      	bne.n	801d93c <ASC_Run+0x68>
 801d952:	4623      	mov	r3, r4
  }

  /* Scale Mel Energies */
  for (i = 0; i < NMELS * SPECTROGRAM_COLS; i++) {
    pSpectrogram[i] /= max_mel_energy;
 801d954:	edd3 6a00 	vldr	s13, [r3]
 801d958:	ee86 7aa7 	vdiv.f32	s14, s13, s15
 801d95c:	eca3 7a01 	vstmia	r3!, {s14}
  for (i = 0; i < NMELS * SPECTROGRAM_COLS; i++) {
 801d960:	42b3      	cmp	r3, r6
 801d962:	d1f7      	bne.n	801d954 <ASC_Run+0x80>
  }

  /* Convert power spectrogram to decibel */
  for (i = 0; i < NMELS * SPECTROGRAM_COLS; i++) {
    pSpectrogram[i] = 10.0f * log10f(pSpectrogram[i]);
 801d964:	eeb2 8a04 	vmov.f32	s16, #36	; 0x41200000  10.0
 801d968:	ed94 0a00 	vldr	s0, [r4]
 801d96c:	f00d fc0a 	bl	802b184 <log10f>
 801d970:	ee20 0a08 	vmul.f32	s0, s0, s16
 801d974:	eca4 0a01 	vstmia	r4!, {s0}
  for (i = 0; i < NMELS * SPECTROGRAM_COLS; i++) {
 801d978:	42b4      	cmp	r4, r6
 801d97a:	d1f5      	bne.n	801d968 <ASC_Run+0x94>
  }

  /* Threshold output to -80.0 dB */
  for (i = 0; i < NMELS * SPECTROGRAM_COLS; i++) {
    pSpectrogram[i] = (pSpectrogram[i] < -80.0f) ? (-80.0f) : (pSpectrogram[i]);
 801d97c:	ed9f 7a10 	vldr	s14, [pc, #64]	; 801d9c0 <ASC_Run+0xec>
 801d980:	ecf5 7a01 	vldmia	r5!, {s15}
 801d984:	eef4 7a47 	vcmp.f32	s15, s14
 801d988:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801d98c:	bf48      	it	mi
 801d98e:	eef0 7a47 	vmovmi.f32	s15, s14
  for (i = 0; i < NMELS * SPECTROGRAM_COLS; i++) {
 801d992:	42b5      	cmp	r5, r6
    pSpectrogram[i] = (pSpectrogram[i] < -80.0f) ? (-80.0f) : (pSpectrogram[i]);
 801d994:	ed45 7a01 	vstr	s15, [r5, #-4]
  for (i = 0; i < NMELS * SPECTROGRAM_COLS; i++) {
 801d998:	d1f2      	bne.n	801d980 <ASC_Run+0xac>
    ASC_NN_Run(aSpectrogram, dense_2_out);
 801d99a:	a901      	add	r1, sp, #4
 801d99c:	4806      	ldr	r0, [pc, #24]	; (801d9b8 <ASC_Run+0xe4>)
 801d99e:	f7ff ff65 	bl	801d86c <ASC_NN_Run>
    ClassificationCode = ASC_PostProc(dense_2_out);
 801d9a2:	a801      	add	r0, sp, #4
 801d9a4:	f7ff fe4e 	bl	801d644 <ASC_PostProc>
 801d9a8:	4b06      	ldr	r3, [pc, #24]	; (801d9c4 <ASC_Run+0xf0>)
 801d9aa:	7018      	strb	r0, [r3, #0]
}
 801d9ac:	b004      	add	sp, #16
 801d9ae:	ecbd 8b02 	vpop	{d8}
 801d9b2:	bd70      	pop	{r4, r5, r6, pc}
 801d9b4:	20009530 	.word	0x20009530
 801d9b8:	20009618 	.word	0x20009618
 801d9bc:	00000000 	.word	0x00000000
 801d9c0:	c2a00000 	.word	0xc2a00000
 801d9c4:	20000d5c 	.word	0x20000d5c

0801d9c8 <error>:
 * @brief DataLog Manager error handler
 * @param None
 * @retval None
 */
static void error(void)
{
 801d9c8:	b508      	push	{r3, lr}
  LedInitTargetPlatform();
 801d9ca:	f001 fee3 	bl	801f794 <LedInitTargetPlatform>
  while (1)
  {
    LedOnTargetPlatform();
 801d9ce:	f001 fed9 	bl	801f784 <LedOnTargetPlatform>
    HAL_Delay(500);
 801d9d2:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
 801d9d6:	f004 fff1 	bl	80229bc <HAL_Delay>
    LedOffTargetPlatform();
 801d9da:	f001 fed7 	bl	801f78c <LedOffTargetPlatform>
    HAL_Delay(100);
 801d9de:	2064      	movs	r0, #100	; 0x64
 801d9e0:	f004 ffec 	bl	80229bc <HAL_Delay>
  while (1)
 801d9e4:	e7f3      	b.n	801d9ce <error+0x6>
 801d9e6:	bf00      	nop

0801d9e8 <SD_CardLoggingMemsData>:
{
 801d9e8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  CounterEnviromental++;
 801d9ec:	4d9f      	ldr	r5, [pc, #636]	; (801dc6c <SD_CardLoggingMemsData+0x284>)
 801d9ee:	682b      	ldr	r3, [r5, #0]
{
 801d9f0:	b0c6      	sub	sp, #280	; 0x118
  CounterEnviromental++;
 801d9f2:	3301      	adds	r3, #1
 801d9f4:	602b      	str	r3, [r5, #0]
  RTC_GetCurrentDateTime();
 801d9f6:	f004 ffcd 	bl	8022994 <RTC_GetCurrentDateTime>
                         CurrentTime.Minutes,
 801d9fa:	4a9d      	ldr	r2, [pc, #628]	; (801dc70 <SD_CardLoggingMemsData+0x288>)
                         999- (CurrentTime.SubSeconds*1000)/(CurrentTime.SecondFraction));
 801d9fc:	6853      	ldr	r3, [r2, #4]
 801d9fe:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
 801da02:	fb01 f303 	mul.w	r3, r1, r3
 801da06:	6891      	ldr	r1, [r2, #8]
 801da08:	fbb3 f3f1 	udiv	r3, r3, r1
  CharPos = sprintf(myBuffer, "%02d:%02d:%02d.%03ld,",
 801da0c:	7891      	ldrb	r1, [r2, #2]
 801da0e:	f5c3 7379 	rsb	r3, r3, #996	; 0x3e4
 801da12:	3303      	adds	r3, #3
 801da14:	e9cd 1300 	strd	r1, r3, [sp]
 801da18:	a806      	add	r0, sp, #24
 801da1a:	7853      	ldrb	r3, [r2, #1]
 801da1c:	4995      	ldr	r1, [pc, #596]	; (801dc74 <SD_CardLoggingMemsData+0x28c>)
 801da1e:	7812      	ldrb	r2, [r2, #0]
 801da20:	f00a fbb0 	bl	8028184 <siprintf>
  if(SD_Card_FeaturesMask & FEATURE_MASK_ACC) {
 801da24:	686b      	ldr	r3, [r5, #4]
 801da26:	f413 0600 	ands.w	r6, r3, #8388608	; 0x800000
  CharPos = sprintf(myBuffer, "%02d:%02d:%02d.%03ld,",
 801da2a:	4604      	mov	r4, r0
  if(SD_Card_FeaturesMask & FEATURE_MASK_ACC) {
 801da2c:	f040 8103 	bne.w	801dc36 <SD_CardLoggingMemsData+0x24e>
  if(SD_Card_FeaturesMask & FEATURE_MASK_GRYO) {
 801da30:	0258      	lsls	r0, r3, #9
 801da32:	f100 80f1 	bmi.w	801dc18 <SD_CardLoggingMemsData+0x230>
  if(SD_Card_FeaturesMask & FEATURE_MASK_MAG) {
 801da36:	0299      	lsls	r1, r3, #10
 801da38:	f100 80de 	bmi.w	801dbf8 <SD_CardLoggingMemsData+0x210>
  if(CounterEnviromental==RoundCounterEnvironmental) {
 801da3c:	4a8e      	ldr	r2, [pc, #568]	; (801dc78 <SD_CardLoggingMemsData+0x290>)
 801da3e:	6829      	ldr	r1, [r5, #0]
 801da40:	6812      	ldr	r2, [r2, #0]
 801da42:	4291      	cmp	r1, r2
 801da44:	d04f      	beq.n	801dae6 <SD_CardLoggingMemsData+0xfe>
    if(SD_Card_FeaturesMask & FEATURE_MASK_PRESS) {
 801da46:	02df      	lsls	r7, r3, #11
 801da48:	d441      	bmi.n	801dace <SD_CardLoggingMemsData+0xe6>
    if(SD_Card_FeaturesMask & FEATURE_MASK_TEMP1) {
 801da4a:	0358      	lsls	r0, r3, #13
 801da4c:	d433      	bmi.n	801dab6 <SD_CardLoggingMemsData+0xce>
    if(SD_Card_FeaturesMask & FEATURE_MASK_TEMP2) {
 801da4e:	03d9      	lsls	r1, r3, #15
 801da50:	d425      	bmi.n	801da9e <SD_CardLoggingMemsData+0xb6>
    if(SD_Card_FeaturesMask & FEATURE_MASK_HUM) {
 801da52:	031a      	lsls	r2, r3, #12
 801da54:	d41b      	bmi.n	801da8e <SD_CardLoggingMemsData+0xa6>
  if((SD_LogMems_Enabled!=0) & (NeedToSaveSomething==1)){
 801da56:	68ab      	ldr	r3, [r5, #8]
 801da58:	b103      	cbz	r3, 801da5c <SD_CardLoggingMemsData+0x74>
 801da5a:	b916      	cbnz	r6, 801da62 <SD_CardLoggingMemsData+0x7a>
}
 801da5c:	b046      	add	sp, #280	; 0x118
 801da5e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    CharPos += sprintf(myBuffer+CharPos,"%c",'\n');
 801da62:	ab06      	add	r3, sp, #24
 801da64:	4985      	ldr	r1, [pc, #532]	; (801dc7c <SD_CardLoggingMemsData+0x294>)
 801da66:	220a      	movs	r2, #10
 801da68:	1918      	adds	r0, r3, r4
 801da6a:	f00a fb8b 	bl	8028184 <siprintf>
    if(f_write(&MyFileMems, (const void*)myBuffer, CharPos, (void *)&byteswritten) != FR_OK) {
 801da6e:	4884      	ldr	r0, [pc, #528]	; (801dc80 <SD_CardLoggingMemsData+0x298>)
 801da70:	ab03      	add	r3, sp, #12
 801da72:	1c62      	adds	r2, r4, #1
 801da74:	a906      	add	r1, sp, #24
 801da76:	f7f9 fea9 	bl	80177cc <f_write>
 801da7a:	2800      	cmp	r0, #0
 801da7c:	d0ee      	beq.n	801da5c <SD_CardLoggingMemsData+0x74>
      if(W2ST_CHECK_CONNECTION(W2ST_CONNECT_SD_CARD_LOGGING)) {
 801da7e:	4b81      	ldr	r3, [pc, #516]	; (801dc84 <SD_CardLoggingMemsData+0x29c>)
 801da80:	681b      	ldr	r3, [r3, #0]
 801da82:	055b      	lsls	r3, r3, #21
 801da84:	d5ea      	bpl.n	801da5c <SD_CardLoggingMemsData+0x74>
        SDLog_Update(SD_CARD_LOGGING_IO_ERROR);
 801da86:	2003      	movs	r0, #3
 801da88:	f005 ffe4 	bl	8023a54 <SDLog_Update>
}
 801da8c:	e7e6      	b.n	801da5c <SD_CardLoggingMemsData+0x74>
        CharPos += sprintf(myBuffer+CharPos,"%c",',');
 801da8e:	ab06      	add	r3, sp, #24
 801da90:	1918      	adds	r0, r3, r4
 801da92:	497a      	ldr	r1, [pc, #488]	; (801dc7c <SD_CardLoggingMemsData+0x294>)
 801da94:	222c      	movs	r2, #44	; 0x2c
 801da96:	3401      	adds	r4, #1
 801da98:	f00a fb74 	bl	8028184 <siprintf>
 801da9c:	e7db      	b.n	801da56 <SD_CardLoggingMemsData+0x6e>
      CharPos += sprintf(myBuffer+CharPos,"%c",',');
 801da9e:	ab06      	add	r3, sp, #24
 801daa0:	1918      	adds	r0, r3, r4
 801daa2:	222c      	movs	r2, #44	; 0x2c
 801daa4:	4975      	ldr	r1, [pc, #468]	; (801dc7c <SD_CardLoggingMemsData+0x294>)
 801daa6:	f00a fb6d 	bl	8028184 <siprintf>
    if(SD_Card_FeaturesMask & FEATURE_MASK_HUM) {
 801daaa:	686b      	ldr	r3, [r5, #4]
 801daac:	031a      	lsls	r2, r3, #12
      CharPos += sprintf(myBuffer+CharPos,"%c",',');
 801daae:	f104 0401 	add.w	r4, r4, #1
    if(SD_Card_FeaturesMask & FEATURE_MASK_HUM) {
 801dab2:	d5d0      	bpl.n	801da56 <SD_CardLoggingMemsData+0x6e>
 801dab4:	e7eb      	b.n	801da8e <SD_CardLoggingMemsData+0xa6>
      CharPos += sprintf(myBuffer+CharPos,"%c",',');
 801dab6:	ab06      	add	r3, sp, #24
 801dab8:	1918      	adds	r0, r3, r4
 801daba:	4970      	ldr	r1, [pc, #448]	; (801dc7c <SD_CardLoggingMemsData+0x294>)
 801dabc:	222c      	movs	r2, #44	; 0x2c
 801dabe:	f00a fb61 	bl	8028184 <siprintf>
    if(SD_Card_FeaturesMask & FEATURE_MASK_TEMP2) {
 801dac2:	686b      	ldr	r3, [r5, #4]
 801dac4:	03d9      	lsls	r1, r3, #15
      CharPos += sprintf(myBuffer+CharPos,"%c",',');
 801dac6:	f104 0401 	add.w	r4, r4, #1
    if(SD_Card_FeaturesMask & FEATURE_MASK_TEMP2) {
 801daca:	d5c2      	bpl.n	801da52 <SD_CardLoggingMemsData+0x6a>
 801dacc:	e7e7      	b.n	801da9e <SD_CardLoggingMemsData+0xb6>
      CharPos += sprintf(myBuffer+CharPos,"%c",',');
 801dace:	ab06      	add	r3, sp, #24
 801dad0:	1918      	adds	r0, r3, r4
 801dad2:	496a      	ldr	r1, [pc, #424]	; (801dc7c <SD_CardLoggingMemsData+0x294>)
 801dad4:	222c      	movs	r2, #44	; 0x2c
 801dad6:	f00a fb55 	bl	8028184 <siprintf>
    if(SD_Card_FeaturesMask & FEATURE_MASK_TEMP1) {
 801dada:	686b      	ldr	r3, [r5, #4]
 801dadc:	0358      	lsls	r0, r3, #13
      CharPos += sprintf(myBuffer+CharPos,"%c",',');
 801dade:	f104 0401 	add.w	r4, r4, #1
    if(SD_Card_FeaturesMask & FEATURE_MASK_TEMP1) {
 801dae2:	d5b4      	bpl.n	801da4e <SD_CardLoggingMemsData+0x66>
 801dae4:	e7e7      	b.n	801dab6 <SD_CardLoggingMemsData+0xce>
    CounterEnviromental=0;
 801dae6:	2200      	movs	r2, #0
 801dae8:	602a      	str	r2, [r5, #0]
    if(SD_Card_FeaturesMask & FEATURE_MASK_PRESS) {
 801daea:	02da      	lsls	r2, r3, #11
 801daec:	d520      	bpl.n	801db30 <SD_CardLoggingMemsData+0x148>
      if(TargetBoardFeatures.HandlePressSensor != SENSING1_SNS_NOT_VALID) {
 801daee:	4f66      	ldr	r7, [pc, #408]	; (801dc88 <SD_CardLoggingMemsData+0x2a0>)
 801daf0:	6938      	ldr	r0, [r7, #16]
 801daf2:	f242 720f 	movw	r2, #9999	; 0x270f
 801daf6:	4290      	cmp	r0, r2
 801daf8:	d019      	beq.n	801db2e <SD_CardLoggingMemsData+0x146>
        status= ENV_SENSOR_GetValue( TargetBoardFeatures.HandlePressSensor, ENV_PRESSURE, &Pressure );
 801dafa:	ae03      	add	r6, sp, #12
 801dafc:	4632      	mov	r2, r6
 801dafe:	2102      	movs	r1, #2
 801db00:	f7ee fdd6 	bl	800c6b0 <BSP_ENV_SENSOR_GetValue>
        if((SD_Card_FeaturesMask & FEATURE_MASK_TEMP2)==0) {
 801db04:	686b      	ldr	r3, [r5, #4]
 801db06:	03db      	lsls	r3, r3, #15
        status= ENV_SENSOR_GetValue( TargetBoardFeatures.HandlePressSensor, ENV_PRESSURE, &Pressure );
 801db08:	4680      	mov	r8, r0
        if((SD_Card_FeaturesMask & FEATURE_MASK_TEMP2)==0) {
 801db0a:	f140 80fe 	bpl.w	801dd0a <SD_CardLoggingMemsData+0x322>
        if ( status == BSP_ERROR_NONE ) {
 801db0e:	f1b8 0f00 	cmp.w	r8, #0
 801db12:	f040 80d7 	bne.w	801dcc4 <SD_CardLoggingMemsData+0x2dc>
          CharPos += sprintf(myBuffer+CharPos,",%.2f",Pressure);
 801db16:	6830      	ldr	r0, [r6, #0]
 801db18:	f7ec fe6e 	bl	800a7f8 <__aeabi_f2d>
 801db1c:	460b      	mov	r3, r1
 801db1e:	a906      	add	r1, sp, #24
 801db20:	4602      	mov	r2, r0
 801db22:	1908      	adds	r0, r1, r4
 801db24:	4959      	ldr	r1, [pc, #356]	; (801dc8c <SD_CardLoggingMemsData+0x2a4>)
 801db26:	f00a fb2d 	bl	8028184 <siprintf>
    if(SD_Card_FeaturesMask & FEATURE_MASK_TEMP1) {
 801db2a:	686b      	ldr	r3, [r5, #4]
          CharPos += sprintf(myBuffer+CharPos,",%.2f",Pressure);
 801db2c:	4404      	add	r4, r0
      NeedToSaveSomething=1;
 801db2e:	2601      	movs	r6, #1
    if(SD_Card_FeaturesMask & FEATURE_MASK_TEMP1) {
 801db30:	0358      	lsls	r0, r3, #13
 801db32:	d520      	bpl.n	801db76 <SD_CardLoggingMemsData+0x18e>
      if(TargetBoardFeatures.HandleTempSensors[0] != SENSING1_SNS_NOT_VALID) {
 801db34:	4f54      	ldr	r7, [pc, #336]	; (801dc88 <SD_CardLoggingMemsData+0x2a0>)
 801db36:	68b8      	ldr	r0, [r7, #8]
 801db38:	f242 720f 	movw	r2, #9999	; 0x270f
 801db3c:	4290      	cmp	r0, r2
 801db3e:	d019      	beq.n	801db74 <SD_CardLoggingMemsData+0x18c>
        status= ENV_SENSOR_GetValue( TargetBoardFeatures.HandleTempSensors[0], ENV_TEMPERATURE, &Temperature);
 801db40:	ae03      	add	r6, sp, #12
 801db42:	2101      	movs	r1, #1
 801db44:	4632      	mov	r2, r6
 801db46:	f7ee fdb3 	bl	800c6b0 <BSP_ENV_SENSOR_GetValue>
        if((SD_Card_FeaturesMask & FEATURE_MASK_HUM)==0) {
 801db4a:	686b      	ldr	r3, [r5, #4]
 801db4c:	0319      	lsls	r1, r3, #12
        status= ENV_SENSOR_GetValue( TargetBoardFeatures.HandleTempSensors[0], ENV_TEMPERATURE, &Temperature);
 801db4e:	4680      	mov	r8, r0
        if((SD_Card_FeaturesMask & FEATURE_MASK_HUM)==0) {
 801db50:	f140 80e2 	bpl.w	801dd18 <SD_CardLoggingMemsData+0x330>
        if ( status == BSP_ERROR_NONE ) {
 801db54:	f1b8 0f00 	cmp.w	r8, #0
 801db58:	f040 80bd 	bne.w	801dcd6 <SD_CardLoggingMemsData+0x2ee>
          CharPos += sprintf(myBuffer+CharPos,",%.2f",Temperature);
 801db5c:	6830      	ldr	r0, [r6, #0]
 801db5e:	f7ec fe4b 	bl	800a7f8 <__aeabi_f2d>
 801db62:	460b      	mov	r3, r1
 801db64:	a906      	add	r1, sp, #24
 801db66:	4602      	mov	r2, r0
 801db68:	1908      	adds	r0, r1, r4
 801db6a:	4948      	ldr	r1, [pc, #288]	; (801dc8c <SD_CardLoggingMemsData+0x2a4>)
 801db6c:	f00a fb0a 	bl	8028184 <siprintf>
    if(SD_Card_FeaturesMask & FEATURE_MASK_TEMP2) {
 801db70:	686b      	ldr	r3, [r5, #4]
          CharPos += sprintf(myBuffer+CharPos,",%.2f",Temperature);
 801db72:	4404      	add	r4, r0
      NeedToSaveSomething=1;
 801db74:	2601      	movs	r6, #1
    if(SD_Card_FeaturesMask & FEATURE_MASK_TEMP2) {
 801db76:	03da      	lsls	r2, r3, #15
 801db78:	d51d      	bpl.n	801dbb6 <SD_CardLoggingMemsData+0x1ce>
      if(TargetBoardFeatures.HandleTempSensors[1] != SENSING1_SNS_NOT_VALID) {
 801db7a:	4e43      	ldr	r6, [pc, #268]	; (801dc88 <SD_CardLoggingMemsData+0x2a0>)
 801db7c:	68f0      	ldr	r0, [r6, #12]
 801db7e:	f242 720f 	movw	r2, #9999	; 0x270f
 801db82:	4290      	cmp	r0, r2
 801db84:	d016      	beq.n	801dbb4 <SD_CardLoggingMemsData+0x1cc>
        status= ENV_SENSOR_GetValue( TargetBoardFeatures.HandleTempSensors[1], ENV_TEMPERATURE, &Temperature);
 801db86:	aa03      	add	r2, sp, #12
 801db88:	2101      	movs	r1, #1
 801db8a:	f7ee fd91 	bl	800c6b0 <BSP_ENV_SENSOR_GetValue>
 801db8e:	4607      	mov	r7, r0
        ENV_SENSOR_Set_One_Shot(TargetBoardFeatures.HandleTempSensors[1]);
 801db90:	68f0      	ldr	r0, [r6, #12]
 801db92:	f006 ff2b 	bl	80249ec <BSP_ENV_SENSOR_Set_One_Shot>
        if ( status == BSP_ERROR_NONE ) {
 801db96:	2f00      	cmp	r7, #0
 801db98:	f040 80a6 	bne.w	801dce8 <SD_CardLoggingMemsData+0x300>
          CharPos += sprintf(myBuffer+CharPos,",%.2f",Temperature);
 801db9c:	9803      	ldr	r0, [sp, #12]
 801db9e:	f7ec fe2b 	bl	800a7f8 <__aeabi_f2d>
 801dba2:	460b      	mov	r3, r1
 801dba4:	a906      	add	r1, sp, #24
 801dba6:	4602      	mov	r2, r0
 801dba8:	1908      	adds	r0, r1, r4
 801dbaa:	4938      	ldr	r1, [pc, #224]	; (801dc8c <SD_CardLoggingMemsData+0x2a4>)
 801dbac:	f00a faea 	bl	8028184 <siprintf>
    if(SD_Card_FeaturesMask & FEATURE_MASK_HUM) {
 801dbb0:	686b      	ldr	r3, [r5, #4]
          CharPos += sprintf(myBuffer+CharPos,",%.2f",Temperature);
 801dbb2:	4404      	add	r4, r0
      NeedToSaveSomething=1;
 801dbb4:	2601      	movs	r6, #1
    if(SD_Card_FeaturesMask & FEATURE_MASK_HUM) {
 801dbb6:	031b      	lsls	r3, r3, #12
 801dbb8:	f57f af4d 	bpl.w	801da56 <SD_CardLoggingMemsData+0x6e>
      if(TargetBoardFeatures.HandleHumSensor != SENSING1_SNS_NOT_VALID) {
 801dbbc:	4e32      	ldr	r6, [pc, #200]	; (801dc88 <SD_CardLoggingMemsData+0x2a0>)
 801dbbe:	6970      	ldr	r0, [r6, #20]
 801dbc0:	f242 730f 	movw	r3, #9999	; 0x270f
 801dbc4:	4298      	cmp	r0, r3
 801dbc6:	d015      	beq.n	801dbf4 <SD_CardLoggingMemsData+0x20c>
        status= ENV_SENSOR_GetValue( TargetBoardFeatures.HandleHumSensor, ENV_HUMIDITY, &Humidity );
 801dbc8:	aa03      	add	r2, sp, #12
 801dbca:	2104      	movs	r1, #4
 801dbcc:	f7ee fd70 	bl	800c6b0 <BSP_ENV_SENSOR_GetValue>
 801dbd0:	4607      	mov	r7, r0
        ENV_SENSOR_Set_One_Shot(TargetBoardFeatures.HandleHumSensor);
 801dbd2:	6970      	ldr	r0, [r6, #20]
 801dbd4:	f006 ff0a 	bl	80249ec <BSP_ENV_SENSOR_Set_One_Shot>
        if ( status == BSP_ERROR_NONE ) {
 801dbd8:	2f00      	cmp	r7, #0
 801dbda:	f040 808e 	bne.w	801dcfa <SD_CardLoggingMemsData+0x312>
          CharPos += sprintf(myBuffer+CharPos,",%.2f",Humidity);
 801dbde:	9803      	ldr	r0, [sp, #12]
 801dbe0:	f7ec fe0a 	bl	800a7f8 <__aeabi_f2d>
 801dbe4:	460b      	mov	r3, r1
 801dbe6:	a906      	add	r1, sp, #24
 801dbe8:	4602      	mov	r2, r0
 801dbea:	1908      	adds	r0, r1, r4
 801dbec:	4927      	ldr	r1, [pc, #156]	; (801dc8c <SD_CardLoggingMemsData+0x2a4>)
 801dbee:	f00a fac9 	bl	8028184 <siprintf>
 801dbf2:	4404      	add	r4, r0
 801dbf4:	2601      	movs	r6, #1
 801dbf6:	e72e      	b.n	801da56 <SD_CardLoggingMemsData+0x6e>
    status= MOTION_SENSOR_GetAxes( TargetBoardFeatures.HandleMagSensor, MOTION_MAGNETO, &Magnetometer );
 801dbf8:	4b23      	ldr	r3, [pc, #140]	; (801dc88 <SD_CardLoggingMemsData+0x2a0>)
 801dbfa:	aa03      	add	r2, sp, #12
 801dbfc:	6a18      	ldr	r0, [r3, #32]
 801dbfe:	2104      	movs	r1, #4
 801dc00:	f7ee fe88 	bl	800c914 <BSP_MOTION_SENSOR_GetAxes>
    if ( status == BSP_ERROR_NONE ) {
 801dc04:	2800      	cmp	r0, #0
 801dc06:	d047      	beq.n	801dc98 <SD_CardLoggingMemsData+0x2b0>
      CharPos += sprintf(myBuffer+CharPos,"%s",",,,");
 801dc08:	4b21      	ldr	r3, [pc, #132]	; (801dc90 <SD_CardLoggingMemsData+0x2a8>)
 801dc0a:	6818      	ldr	r0, [r3, #0]
 801dc0c:	ab06      	add	r3, sp, #24
 801dc0e:	5118      	str	r0, [r3, r4]
 801dc10:	3403      	adds	r4, #3
    if(SD_Card_FeaturesMask & FEATURE_MASK_PRESS) {
 801dc12:	686b      	ldr	r3, [r5, #4]
    NeedToSaveSomething=1;
 801dc14:	2601      	movs	r6, #1
 801dc16:	e711      	b.n	801da3c <SD_CardLoggingMemsData+0x54>
    status= MOTION_SENSOR_GetAxes( TargetBoardFeatures.HandleGyroSensor, MOTION_GYRO, &AngularVelocity );
 801dc18:	4b1b      	ldr	r3, [pc, #108]	; (801dc88 <SD_CardLoggingMemsData+0x2a0>)
 801dc1a:	aa03      	add	r2, sp, #12
 801dc1c:	69d8      	ldr	r0, [r3, #28]
 801dc1e:	2101      	movs	r1, #1
 801dc20:	f7ee fe78 	bl	800c914 <BSP_MOTION_SENSOR_GetAxes>
    if (status == BSP_ERROR_NONE) {
 801dc24:	b1b8      	cbz	r0, 801dc56 <SD_CardLoggingMemsData+0x26e>
      CharPos += sprintf(myBuffer+CharPos,"%s",",,,");
 801dc26:	4b1a      	ldr	r3, [pc, #104]	; (801dc90 <SD_CardLoggingMemsData+0x2a8>)
 801dc28:	6818      	ldr	r0, [r3, #0]
 801dc2a:	ab06      	add	r3, sp, #24
 801dc2c:	5118      	str	r0, [r3, r4]
 801dc2e:	3403      	adds	r4, #3
  if(SD_Card_FeaturesMask & FEATURE_MASK_MAG) {
 801dc30:	686b      	ldr	r3, [r5, #4]
    NeedToSaveSomething=1;
 801dc32:	2601      	movs	r6, #1
 801dc34:	e6ff      	b.n	801da36 <SD_CardLoggingMemsData+0x4e>
    status= MOTION_SENSOR_GetAxes(TargetBoardFeatures.HandleAccSensor, MOTION_ACCELERO, &Acceleration);
 801dc36:	4b14      	ldr	r3, [pc, #80]	; (801dc88 <SD_CardLoggingMemsData+0x2a0>)
 801dc38:	aa03      	add	r2, sp, #12
 801dc3a:	6998      	ldr	r0, [r3, #24]
 801dc3c:	2102      	movs	r1, #2
 801dc3e:	f7ee fe69 	bl	800c914 <BSP_MOTION_SENSOR_GetAxes>
    if (status == BSP_ERROR_NONE) {
 801dc42:	2800      	cmp	r0, #0
 801dc44:	d033      	beq.n	801dcae <SD_CardLoggingMemsData+0x2c6>
      CharPos += sprintf(myBuffer+CharPos,"%s",",,,");
 801dc46:	4b12      	ldr	r3, [pc, #72]	; (801dc90 <SD_CardLoggingMemsData+0x2a8>)
 801dc48:	6818      	ldr	r0, [r3, #0]
 801dc4a:	ab06      	add	r3, sp, #24
 801dc4c:	5118      	str	r0, [r3, r4]
 801dc4e:	3403      	adds	r4, #3
  if(SD_Card_FeaturesMask & FEATURE_MASK_GRYO) {
 801dc50:	686b      	ldr	r3, [r5, #4]
    NeedToSaveSomething=1;
 801dc52:	2601      	movs	r6, #1
 801dc54:	e6ec      	b.n	801da30 <SD_CardLoggingMemsData+0x48>
      CharPos += sprintf(myBuffer+CharPos,",%ld,%ld,%ld",
 801dc56:	9b05      	ldr	r3, [sp, #20]
 801dc58:	9300      	str	r3, [sp, #0]
 801dc5a:	a906      	add	r1, sp, #24
 801dc5c:	1908      	adds	r0, r1, r4
 801dc5e:	e9dd 2303 	ldrd	r2, r3, [sp, #12]
 801dc62:	490c      	ldr	r1, [pc, #48]	; (801dc94 <SD_CardLoggingMemsData+0x2ac>)
 801dc64:	f00a fa8e 	bl	8028184 <siprintf>
 801dc68:	4404      	add	r4, r0
 801dc6a:	e7e1      	b.n	801dc30 <SD_CardLoggingMemsData+0x248>
 801dc6c:	2000b518 	.word	0x2000b518
 801dc70:	200134f0 	.word	0x200134f0
 801dc74:	08041c3c 	.word	0x08041c3c
 801dc78:	20000d60 	.word	0x20000d60
 801dc7c:	08041c70 	.word	0x08041c70
 801dc80:	2000f658 	.word	0x2000f658
 801dc84:	2001457c 	.word	0x2001457c
 801dc88:	200106a4 	.word	0x200106a4
 801dc8c:	08041c68 	.word	0x08041c68
 801dc90:	08041c64 	.word	0x08041c64
 801dc94:	08041c54 	.word	0x08041c54
      CharPos += sprintf(myBuffer+CharPos,",%ld,%ld,%ld",
 801dc98:	9b05      	ldr	r3, [sp, #20]
 801dc9a:	9300      	str	r3, [sp, #0]
 801dc9c:	a906      	add	r1, sp, #24
 801dc9e:	1908      	adds	r0, r1, r4
 801dca0:	e9dd 2303 	ldrd	r2, r3, [sp, #12]
 801dca4:	4920      	ldr	r1, [pc, #128]	; (801dd28 <SD_CardLoggingMemsData+0x340>)
 801dca6:	f00a fa6d 	bl	8028184 <siprintf>
 801dcaa:	4404      	add	r4, r0
 801dcac:	e7b1      	b.n	801dc12 <SD_CardLoggingMemsData+0x22a>
      CharPos += sprintf(myBuffer+CharPos,",%ld,%ld,%ld",
 801dcae:	9b05      	ldr	r3, [sp, #20]
 801dcb0:	9300      	str	r3, [sp, #0]
 801dcb2:	a906      	add	r1, sp, #24
 801dcb4:	1908      	adds	r0, r1, r4
 801dcb6:	e9dd 2303 	ldrd	r2, r3, [sp, #12]
 801dcba:	491b      	ldr	r1, [pc, #108]	; (801dd28 <SD_CardLoggingMemsData+0x340>)
 801dcbc:	f00a fa62 	bl	8028184 <siprintf>
 801dcc0:	4404      	add	r4, r0
 801dcc2:	e7c5      	b.n	801dc50 <SD_CardLoggingMemsData+0x268>
          CharPos += sprintf(myBuffer+CharPos,"%c",',');
 801dcc4:	ab06      	add	r3, sp, #24
 801dcc6:	1918      	adds	r0, r3, r4
 801dcc8:	4918      	ldr	r1, [pc, #96]	; (801dd2c <SD_CardLoggingMemsData+0x344>)
 801dcca:	222c      	movs	r2, #44	; 0x2c
 801dccc:	f00a fa5a 	bl	8028184 <siprintf>
 801dcd0:	3401      	adds	r4, #1
    if(SD_Card_FeaturesMask & FEATURE_MASK_TEMP1) {
 801dcd2:	686b      	ldr	r3, [r5, #4]
 801dcd4:	e72b      	b.n	801db2e <SD_CardLoggingMemsData+0x146>
          CharPos += sprintf(myBuffer+CharPos,"%c",',');
 801dcd6:	ab06      	add	r3, sp, #24
 801dcd8:	1918      	adds	r0, r3, r4
 801dcda:	4914      	ldr	r1, [pc, #80]	; (801dd2c <SD_CardLoggingMemsData+0x344>)
 801dcdc:	222c      	movs	r2, #44	; 0x2c
 801dcde:	f00a fa51 	bl	8028184 <siprintf>
 801dce2:	3401      	adds	r4, #1
    if(SD_Card_FeaturesMask & FEATURE_MASK_TEMP2) {
 801dce4:	686b      	ldr	r3, [r5, #4]
 801dce6:	e745      	b.n	801db74 <SD_CardLoggingMemsData+0x18c>
          CharPos += sprintf(myBuffer+CharPos,"%c",',');
 801dce8:	ab06      	add	r3, sp, #24
 801dcea:	1918      	adds	r0, r3, r4
 801dcec:	490f      	ldr	r1, [pc, #60]	; (801dd2c <SD_CardLoggingMemsData+0x344>)
 801dcee:	222c      	movs	r2, #44	; 0x2c
 801dcf0:	f00a fa48 	bl	8028184 <siprintf>
 801dcf4:	3401      	adds	r4, #1
    if(SD_Card_FeaturesMask & FEATURE_MASK_HUM) {
 801dcf6:	686b      	ldr	r3, [r5, #4]
 801dcf8:	e75c      	b.n	801dbb4 <SD_CardLoggingMemsData+0x1cc>
          CharPos += sprintf(myBuffer+CharPos,"%c",',');
 801dcfa:	ab06      	add	r3, sp, #24
 801dcfc:	1918      	adds	r0, r3, r4
 801dcfe:	490b      	ldr	r1, [pc, #44]	; (801dd2c <SD_CardLoggingMemsData+0x344>)
 801dd00:	222c      	movs	r2, #44	; 0x2c
 801dd02:	f00a fa3f 	bl	8028184 <siprintf>
 801dd06:	3401      	adds	r4, #1
 801dd08:	e774      	b.n	801dbf4 <SD_CardLoggingMemsData+0x20c>
          ENV_SENSOR_Set_One_Shot(TargetBoardFeatures.HandlePressSensor);
 801dd0a:	6938      	ldr	r0, [r7, #16]
 801dd0c:	f006 fe6e 	bl	80249ec <BSP_ENV_SENSOR_Set_One_Shot>
        if ( status == BSP_ERROR_NONE ) {
 801dd10:	f1b8 0f00 	cmp.w	r8, #0
 801dd14:	d1d6      	bne.n	801dcc4 <SD_CardLoggingMemsData+0x2dc>
 801dd16:	e6fe      	b.n	801db16 <SD_CardLoggingMemsData+0x12e>
          ENV_SENSOR_Set_One_Shot(TargetBoardFeatures.HandleTempSensors[0]);
 801dd18:	68b8      	ldr	r0, [r7, #8]
 801dd1a:	f006 fe67 	bl	80249ec <BSP_ENV_SENSOR_Set_One_Shot>
        if ( status == BSP_ERROR_NONE ) {
 801dd1e:	f1b8 0f00 	cmp.w	r8, #0
 801dd22:	d1d8      	bne.n	801dcd6 <SD_CardLoggingMemsData+0x2ee>
 801dd24:	e71a      	b.n	801db5c <SD_CardLoggingMemsData+0x174>
 801dd26:	bf00      	nop
 801dd28:	08041c54 	.word	0x08041c54
 801dd2c:	08041c70 	.word	0x08041c70

0801dd30 <DATALOG_SD_LogMems_Enable.constprop.0>:
static uint8_t DATALOG_SD_LogMems_Enable(uint32_t SomethingAlreadyRecording, uint32_t OnlyForAnnotation)
 801dd30:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 801dd34:	ed2d 8b02 	vpush	{d8}
 801dd38:	f5ad 7d19 	sub.w	sp, sp, #612	; 0x264
 801dd3c:	4680      	mov	r8, r0
  RTC_GetCurrentDateTime();
 801dd3e:	f004 fe29 	bl	8022994 <RTC_GetCurrentDateTime>
                       CurrentDate.Date,
 801dd42:	4993      	ldr	r1, [pc, #588]	; (801df90 <DATALOG_SD_LogMems_Enable.constprop.0+0x260>)
    sprintf(FileName, "%s-Ann_%02d_%s_%02d_%02dh_%02dm_%02ds.csv",
 801dd44:	4893      	ldr	r0, [pc, #588]	; (801df94 <DATALOG_SD_LogMems_Enable.constprop.0+0x264>)
                       MonthName[CurrentDate.Month-1],
 801dd46:	784b      	ldrb	r3, [r1, #1]
                       CurrentTime.Seconds);
 801dd48:	4a93      	ldr	r2, [pc, #588]	; (801df98 <DATALOG_SD_LogMems_Enable.constprop.0+0x268>)
    sprintf(FileName, "%s-Ann_%02d_%s_%02d_%02dh_%02dm_%02ds.csv",
 801dd4a:	4c94      	ldr	r4, [pc, #592]	; (801df9c <DATALOG_SD_LogMems_Enable.constprop.0+0x26c>)
 801dd4c:	3b01      	subs	r3, #1
 801dd4e:	ae08      	add	r6, sp, #32
 801dd50:	f850 3023 	ldr.w	r3, [r0, r3, lsl #2]
 801dd54:	9300      	str	r3, [sp, #0]
 801dd56:	788b      	ldrb	r3, [r1, #2]
 801dd58:	78c9      	ldrb	r1, [r1, #3]
 801dd5a:	9101      	str	r1, [sp, #4]
 801dd5c:	7891      	ldrb	r1, [r2, #2]
 801dd5e:	9104      	str	r1, [sp, #16]
 801dd60:	7851      	ldrb	r1, [r2, #1]
 801dd62:	7812      	ldrb	r2, [r2, #0]
 801dd64:	e9cd 2102 	strd	r2, r1, [sp, #8]
  if(OnlyForAnnotation) {
 801dd68:	f1b8 0f00 	cmp.w	r8, #0
 801dd6c:	d05a      	beq.n	801de24 <DATALOG_SD_LogMems_Enable.constprop.0+0xf4>
    sprintf(FileName, "%s-Ann_%02d_%s_%02d_%02dh_%02dm_%02ds.csv",
 801dd6e:	498c      	ldr	r1, [pc, #560]	; (801dfa0 <DATALOG_SD_LogMems_Enable.constprop.0+0x270>)
 801dd70:	f104 020c 	add.w	r2, r4, #12
 801dd74:	4630      	mov	r0, r6
 801dd76:	f00a fa05 	bl	8028184 <siprintf>
  while(SD_LogMems_Enabled==0) {
 801dd7a:	68a3      	ldr	r3, [r4, #8]
 801dd7c:	bb03      	cbnz	r3, 801ddc0 <DATALOG_SD_LogMems_Enable.constprop.0+0x90>
    if(f_open(&MyFileMems, (char const*)MemsDataFileName, FA_CREATE_ALWAYS | FA_WRITE) != FR_OK) {
 801dd7e:	4f89      	ldr	r7, [pc, #548]	; (801dfa4 <DATALOG_SD_LogMems_Enable.constprop.0+0x274>)
    if(W2ST_CHECK_CONNECTION(W2ST_CONNECT_STD_TERM)) {
 801dd80:	f8df 9230 	ldr.w	r9, [pc, #560]	; 801dfb4 <DATALOG_SD_LogMems_Enable.constprop.0+0x284>
      BytesToWrite =sprintf((char *)BufferToWrite, "FileName=%s\n",MemsDataFileName);
 801dd84:	f8df a258 	ldr.w	sl, [pc, #600]	; 801dfe0 <DATALOG_SD_LogMems_Enable.constprop.0+0x2b0>
static uint8_t DATALOG_SD_LogMems_Enable(uint32_t SomethingAlreadyRecording, uint32_t OnlyForAnnotation)
 801dd88:	2500      	movs	r5, #0
 801dd8a:	e006      	b.n	801dd9a <DATALOG_SD_LogMems_Enable.constprop.0+0x6a>
      if(SDCardFileCount > MAX_TRIALS_OPENS_SD) {
 801dd8c:	2d0a      	cmp	r5, #10
 801dd8e:	f200 80c3 	bhi.w	801df18 <DATALOG_SD_LogMems_Enable.constprop.0+0x1e8>
      osDelay(100);
 801dd92:	f7fa fd97 	bl	80188c4 <osDelay>
  while(SD_LogMems_Enabled==0) {
 801dd96:	68a3      	ldr	r3, [r4, #8]
 801dd98:	b97b      	cbnz	r3, 801ddba <DATALOG_SD_LogMems_Enable.constprop.0+0x8a>
    if(f_open(&MyFileMems, (char const*)MemsDataFileName, FA_CREATE_ALWAYS | FA_WRITE) != FR_OK) {
 801dd9a:	220a      	movs	r2, #10
 801dd9c:	4631      	mov	r1, r6
 801dd9e:	4638      	mov	r0, r7
 801dda0:	f7f9 faa6 	bl	80172f0 <f_open>
    SD_LogMems_Enabled=1;
 801dda4:	2201      	movs	r2, #1
    if(f_open(&MyFileMems, (char const*)MemsDataFileName, FA_CREATE_ALWAYS | FA_WRITE) != FR_OK) {
 801dda6:	4603      	mov	r3, r0
    SDCardFileCount++;
 801dda8:	4415      	add	r5, r2
      osDelay(100);
 801ddaa:	2064      	movs	r0, #100	; 0x64
    if(f_open(&MyFileMems, (char const*)MemsDataFileName, FA_CREATE_ALWAYS | FA_WRITE) != FR_OK) {
 801ddac:	2b00      	cmp	r3, #0
 801ddae:	d1ed      	bne.n	801dd8c <DATALOG_SD_LogMems_Enable.constprop.0+0x5c>
    if(W2ST_CHECK_CONNECTION(W2ST_CONNECT_STD_TERM)) {
 801ddb0:	f8d9 3000 	ldr.w	r3, [r9]
    SD_LogMems_Enabled=1;
 801ddb4:	60a2      	str	r2, [r4, #8]
    if(W2ST_CHECK_CONNECTION(W2ST_CONNECT_STD_TERM)) {
 801ddb6:	069b      	lsls	r3, r3, #26
 801ddb8:	d427      	bmi.n	801de0a <DATALOG_SD_LogMems_Enable.constprop.0+0xda>
  if(OnlyForAnnotation) {
 801ddba:	f1b8 0f00 	cmp.w	r8, #0
 801ddbe:	d03a      	beq.n	801de36 <DATALOG_SD_LogMems_Enable.constprop.0+0x106>
    uint8_t pHeader[]= "hh:mm:ss.ms, Annotation\n";
 801ddc0:	4d79      	ldr	r5, [pc, #484]	; (801dfa8 <DATALOG_SD_LogMems_Enable.constprop.0+0x278>)
    CharPos = sprintf(Introduction,"Sensors' Acquisition [Hz] setup: Mic@%d Volume=%ld\n",AUDIO_SAMPLING_FREQUENCY,TargetBoardFeatures.AudioVolume);
 801ddc2:	4e7a      	ldr	r6, [pc, #488]	; (801dfac <DATALOG_SD_LogMems_Enable.constprop.0+0x27c>)
    uint8_t pHeader[]= "hh:mm:ss.ms, Annotation\n";
 801ddc4:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 801ddc6:	ac18      	add	r4, sp, #96	; 0x60
 801ddc8:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 801ddca:	e895 0007 	ldmia.w	r5, {r0, r1, r2}
 801ddce:	c403      	stmia	r4!, {r0, r1}
    CharPos = sprintf(Introduction,"Sensors' Acquisition [Hz] setup: Mic@%d Volume=%ld\n",AUDIO_SAMPLING_FREQUENCY,TargetBoardFeatures.AudioVolume);
 801ddd0:	6bb3      	ldr	r3, [r6, #56]	; 0x38
 801ddd2:	4977      	ldr	r1, [pc, #476]	; (801dfb0 <DATALOG_SD_LogMems_Enable.constprop.0+0x280>)
    uint8_t pHeader[]= "hh:mm:ss.ms, Annotation\n";
 801ddd4:	7022      	strb	r2, [r4, #0]
    CharPos = sprintf(Introduction,"Sensors' Acquisition [Hz] setup: Mic@%d Volume=%ld\n",AUDIO_SAMPLING_FREQUENCY,TargetBoardFeatures.AudioVolume);
 801ddd6:	a858      	add	r0, sp, #352	; 0x160
 801ddd8:	f44f 527a 	mov.w	r2, #16000	; 0x3e80
 801dddc:	f00a f9d2 	bl	8028184 <siprintf>
    if(f_write(&MyFileMems, (const void*)Introduction, CharPos, (void *)&byteswritten) != FR_OK) {
 801dde0:	ab07      	add	r3, sp, #28
    CharPos = sprintf(Introduction,"Sensors' Acquisition [Hz] setup: Mic@%d Volume=%ld\n",AUDIO_SAMPLING_FREQUENCY,TargetBoardFeatures.AudioVolume);
 801dde2:	4602      	mov	r2, r0
    if(f_write(&MyFileMems, (const void*)Introduction, CharPos, (void *)&byteswritten) != FR_OK) {
 801dde4:	a958      	add	r1, sp, #352	; 0x160
 801dde6:	486f      	ldr	r0, [pc, #444]	; (801dfa4 <DATALOG_SD_LogMems_Enable.constprop.0+0x274>)
 801dde8:	f7f9 fcf0 	bl	80177cc <f_write>
 801ddec:	2800      	cmp	r0, #0
 801ddee:	f000 809b 	beq.w	801df28 <DATALOG_SD_LogMems_Enable.constprop.0+0x1f8>
      if(W2ST_CHECK_CONNECTION(W2ST_CONNECT_SD_CARD_LOGGING)) {
 801ddf2:	4b70      	ldr	r3, [pc, #448]	; (801dfb4 <DATALOG_SD_LogMems_Enable.constprop.0+0x284>)
 801ddf4:	681b      	ldr	r3, [r3, #0]
 801ddf6:	055b      	lsls	r3, r3, #21
 801ddf8:	f100 809f 	bmi.w	801df3a <DATALOG_SD_LogMems_Enable.constprop.0+0x20a>
      return 0;
 801ddfc:	2000      	movs	r0, #0
}
 801ddfe:	f50d 7d19 	add.w	sp, sp, #612	; 0x264
 801de02:	ecbd 8b02 	vpop	{d8}
 801de06:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
      BytesToWrite =sprintf((char *)BufferToWrite, "FileName=%s\n",MemsDataFileName);
 801de0a:	4651      	mov	r1, sl
 801de0c:	4632      	mov	r2, r6
 801de0e:	486a      	ldr	r0, [pc, #424]	; (801dfb8 <DATALOG_SD_LogMems_Enable.constprop.0+0x288>)
 801de10:	f00a f9b8 	bl	8028184 <siprintf>
 801de14:	4a69      	ldr	r2, [pc, #420]	; (801dfbc <DATALOG_SD_LogMems_Enable.constprop.0+0x28c>)
 801de16:	4603      	mov	r3, r0
      Term_Update(BufferToWrite,BytesToWrite);
 801de18:	b2d9      	uxtb	r1, r3
 801de1a:	4867      	ldr	r0, [pc, #412]	; (801dfb8 <DATALOG_SD_LogMems_Enable.constprop.0+0x288>)
      BytesToWrite =sprintf((char *)BufferToWrite, "FileName=%s\n",MemsDataFileName);
 801de1c:	6013      	str	r3, [r2, #0]
      Term_Update(BufferToWrite,BytesToWrite);
 801de1e:	f005 f947 	bl	80230b0 <Term_Update>
 801de22:	e7b8      	b.n	801dd96 <DATALOG_SD_LogMems_Enable.constprop.0+0x66>
    sprintf(FileName, "%s-MemsAnn_%02d_%s_%02d_%02dh_%02dm_%02ds.csv",
 801de24:	4966      	ldr	r1, [pc, #408]	; (801dfc0 <DATALOG_SD_LogMems_Enable.constprop.0+0x290>)
 801de26:	f104 020c 	add.w	r2, r4, #12
 801de2a:	4630      	mov	r0, r6
 801de2c:	f00a f9aa 	bl	8028184 <siprintf>
  while(SD_LogMems_Enabled==0) {
 801de30:	68a3      	ldr	r3, [r4, #8]
 801de32:	2b00      	cmp	r3, #0
 801de34:	d0a3      	beq.n	801dd7e <DATALOG_SD_LogMems_Enable.constprop.0+0x4e>
    int32_t IneHz = SampleRateIneFeatures/10;
 801de36:	4b63      	ldr	r3, [pc, #396]	; (801dfc4 <DATALOG_SD_LogMems_Enable.constprop.0+0x294>)
 801de38:	4f63      	ldr	r7, [pc, #396]	; (801dfc8 <DATALOG_SD_LogMems_Enable.constprop.0+0x298>)
 801de3a:	f8b3 9004 	ldrh.w	r9, [r3, #4]
    int32_t EnvHz = RoundedEnvironmentalFreq/10;
 801de3e:	689a      	ldr	r2, [r3, #8]
    CharPosHeader = sprintf(Header,"%s","hh:mm:ss.ms, Annotation ");
 801de40:	f8df b1a0 	ldr.w	fp, [pc, #416]	; 801dfe4 <DATALOG_SD_LogMems_Enable.constprop.0+0x2b4>
    CharPosIntro = sprintf(Introduction,"%s","Sensors' Acquisition [Hz]: ");
 801de44:	f8df e1a0 	ldr.w	lr, [pc, #416]	; 801dfe8 <DATALOG_SD_LogMems_Enable.constprop.0+0x2b8>
    if(SD_Card_FeaturesMask&FEATURE_MASK_BLUEVOICE) {
 801de48:	6865      	ldr	r5, [r4, #4]
    int32_t IneHz = SampleRateIneFeatures/10;
 801de4a:	fba7 3109 	umull	r3, r1, r7, r9
    int32_t EnvHz = RoundedEnvironmentalFreq/10;
 801de4e:	fba7 3702 	umull	r3, r7, r7, r2
    int32_t IneHz = SampleRateIneFeatures/10;
 801de52:	08cb      	lsrs	r3, r1, #3
    int32_t IneSubHz = SampleRateIneFeatures%10;
 801de54:	eb03 0383 	add.w	r3, r3, r3, lsl #2
    int32_t EnvHz = RoundedEnvironmentalFreq/10;
 801de58:	08ff      	lsrs	r7, r7, #3
    int32_t IneSubHz = SampleRateIneFeatures%10;
 801de5a:	eba9 0943 	sub.w	r9, r9, r3, lsl #1
    int32_t EnvSubHz = RoundedEnvironmentalFreq%10;
 801de5e:	eb07 0a87 	add.w	sl, r7, r7, lsl #2
    int32_t IneHz = SampleRateIneFeatures/10;
 801de62:	08cb      	lsrs	r3, r1, #3
 801de64:	ee08 3a10 	vmov	s16, r3
    int32_t EnvSubHz = RoundedEnvironmentalFreq%10;
 801de68:	eba2 0a4a 	sub.w	sl, r2, sl, lsl #1
    CharPosHeader = sprintf(Header,"%s","hh:mm:ss.ms, Annotation ");
 801de6c:	e8bb 000f 	ldmia.w	fp!, {r0, r1, r2, r3}
 801de70:	f10d 0860 	add.w	r8, sp, #96	; 0x60
 801de74:	46c4      	mov	ip, r8
 801de76:	e8ac 000f 	stmia.w	ip!, {r0, r1, r2, r3}
 801de7a:	e89b 0007 	ldmia.w	fp, {r0, r1, r2}
 801de7e:	e8ac 0003 	stmia.w	ip!, {r0, r1}
 801de82:	f88c 2000 	strb.w	r2, [ip]
    CharPosIntro = sprintf(Introduction,"%s","Sensors' Acquisition [Hz]: ");
 801de86:	e8be 000f 	ldmia.w	lr!, {r0, r1, r2, r3}
 801de8a:	ae58      	add	r6, sp, #352	; 0x160
 801de8c:	c60f      	stmia	r6!, {r0, r1, r2, r3}
 801de8e:	e89e 0007 	ldmia.w	lr, {r0, r1, r2}
 801de92:	e886 0007 	stmia.w	r6, {r0, r1, r2}
    if(SD_Card_FeaturesMask&FEATURE_MASK_BLUEVOICE) {
 801de96:	012e      	lsls	r6, r5, #4
    int32_t IneSubHz = SampleRateIneFeatures%10;
 801de98:	fa1f f989 	uxth.w	r9, r9
    if(SD_Card_FeaturesMask&FEATURE_MASK_BLUEVOICE) {
 801de9c:	f100 813b 	bmi.w	801e116 <DATALOG_SD_LogMems_Enable.constprop.0+0x3e6>
    CharPosIntro = sprintf(Introduction,"%s","Sensors' Acquisition [Hz]: ");
 801dea0:	261b      	movs	r6, #27
    if(SD_Card_FeaturesMask&FEATURE_MASK_ACC) {
 801dea2:	0228      	lsls	r0, r5, #8
 801dea4:	f100 80a2 	bmi.w	801dfec <DATALOG_SD_LogMems_Enable.constprop.0+0x2bc>
    if(SD_Card_FeaturesMask&FEATURE_MASK_GRYO) {
 801dea8:	0269      	lsls	r1, r5, #9
    CharPosHeader = sprintf(Header,"%s","hh:mm:ss.ms, Annotation ");
 801deaa:	f04f 0b18 	mov.w	fp, #24
    if(SD_Card_FeaturesMask&FEATURE_MASK_GRYO) {
 801deae:	f100 80b8 	bmi.w	801e022 <DATALOG_SD_LogMems_Enable.constprop.0+0x2f2>
    if(SD_Card_FeaturesMask&FEATURE_MASK_MAG) {
 801deb2:	02aa      	lsls	r2, r5, #10
 801deb4:	f100 80de 	bmi.w	801e074 <DATALOG_SD_LogMems_Enable.constprop.0+0x344>
    if(SD_Card_FeaturesMask&FEATURE_MASK_PRESS) {
 801deb8:	02eb      	lsls	r3, r5, #11
 801deba:	f100 8100 	bmi.w	801e0be <DATALOG_SD_LogMems_Enable.constprop.0+0x38e>
    if(SD_Card_FeaturesMask&FEATURE_MASK_TEMP1) {
 801debe:	0368      	lsls	r0, r5, #13
 801dec0:	f100 8114 	bmi.w	801e0ec <DATALOG_SD_LogMems_Enable.constprop.0+0x3bc>
    if(SD_Card_FeaturesMask&FEATURE_MASK_TEMP2) {
 801dec4:	03e9      	lsls	r1, r5, #15
 801dec6:	d44e      	bmi.n	801df66 <DATALOG_SD_LogMems_Enable.constprop.0+0x236>
    if(SD_Card_FeaturesMask&FEATURE_MASK_HUM) {
 801dec8:	032a      	lsls	r2, r5, #12
 801deca:	d43a      	bmi.n	801df42 <DATALOG_SD_LogMems_Enable.constprop.0+0x212>
    CharPosIntro += sprintf(Introduction+CharPosIntro,"%c",'\n');
 801decc:	ab58      	add	r3, sp, #352	; 0x160
 801dece:	1998      	adds	r0, r3, r6
 801ded0:	493e      	ldr	r1, [pc, #248]	; (801dfcc <DATALOG_SD_LogMems_Enable.constprop.0+0x29c>)
 801ded2:	220a      	movs	r2, #10
 801ded4:	f00a f956 	bl	8028184 <siprintf>
    CharPosHeader += sprintf(Header+CharPosHeader,"%c",'\n');
 801ded8:	493c      	ldr	r1, [pc, #240]	; (801dfcc <DATALOG_SD_LogMems_Enable.constprop.0+0x29c>)
 801deda:	220a      	movs	r2, #10
 801dedc:	eb08 000b 	add.w	r0, r8, fp
 801dee0:	f00a f950 	bl	8028184 <siprintf>
    if(f_write(&MyFileMems, (const void*)Introduction, CharPosIntro, (void *)&byteswritten) != FR_OK) {
 801dee4:	482f      	ldr	r0, [pc, #188]	; (801dfa4 <DATALOG_SD_LogMems_Enable.constprop.0+0x274>)
 801dee6:	1c72      	adds	r2, r6, #1
 801dee8:	a958      	add	r1, sp, #352	; 0x160
 801deea:	ab07      	add	r3, sp, #28
 801deec:	f7f9 fc6e 	bl	80177cc <f_write>
 801def0:	2800      	cmp	r0, #0
 801def2:	f47f af7e 	bne.w	801ddf2 <DATALOG_SD_LogMems_Enable.constprop.0+0xc2>
    if(f_write(&MyFileMems, (const void*)Header, CharPosHeader, (void *)&byteswritten) != FR_OK) {
 801def6:	482b      	ldr	r0, [pc, #172]	; (801dfa4 <DATALOG_SD_LogMems_Enable.constprop.0+0x274>)
 801def8:	ab07      	add	r3, sp, #28
 801defa:	f10b 0201 	add.w	r2, fp, #1
 801defe:	4641      	mov	r1, r8
 801df00:	f7f9 fc64 	bl	80177cc <f_write>
 801df04:	2800      	cmp	r0, #0
 801df06:	f47f af74 	bne.w	801ddf2 <DATALOG_SD_LogMems_Enable.constprop.0+0xc2>
  return 1;
 801df0a:	2001      	movs	r0, #1
}
 801df0c:	f50d 7d19 	add.w	sp, sp, #612	; 0x264
 801df10:	ecbd 8b02 	vpop	{d8}
 801df14:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        SD_LogMems_Enabled= 0;
 801df18:	2000      	movs	r0, #0
 801df1a:	60a0      	str	r0, [r4, #8]
}
 801df1c:	f50d 7d19 	add.w	sp, sp, #612	; 0x264
 801df20:	ecbd 8b02 	vpop	{d8}
 801df24:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    if(f_write(&MyFileMems, (const void*)pHeader, sizeof(pHeader), (void *)&byteswritten) != FR_OK) {
 801df28:	481e      	ldr	r0, [pc, #120]	; (801dfa4 <DATALOG_SD_LogMems_Enable.constprop.0+0x274>)
 801df2a:	ab07      	add	r3, sp, #28
 801df2c:	2219      	movs	r2, #25
 801df2e:	a918      	add	r1, sp, #96	; 0x60
 801df30:	f7f9 fc4c 	bl	80177cc <f_write>
 801df34:	2800      	cmp	r0, #0
 801df36:	d0e8      	beq.n	801df0a <DATALOG_SD_LogMems_Enable.constprop.0+0x1da>
 801df38:	e75b      	b.n	801ddf2 <DATALOG_SD_LogMems_Enable.constprop.0+0xc2>
        SDLog_Update(SD_CARD_LOGGING_IO_ERROR);
 801df3a:	2003      	movs	r0, #3
 801df3c:	f005 fd8a 	bl	8023a54 <SDLog_Update>
 801df40:	e75c      	b.n	801ddfc <DATALOG_SD_LogMems_Enable.constprop.0+0xcc>
      CharPosIntro += sprintf(Introduction+CharPosIntro,"H@%ld.%ld ",EnvHz,EnvSubHz);
 801df42:	a858      	add	r0, sp, #352	; 0x160
 801df44:	4922      	ldr	r1, [pc, #136]	; (801dfd0 <DATALOG_SD_LogMems_Enable.constprop.0+0x2a0>)
 801df46:	4653      	mov	r3, sl
 801df48:	463a      	mov	r2, r7
 801df4a:	4430      	add	r0, r6
 801df4c:	f00a f91a 	bl	8028184 <siprintf>
      CharPosHeader += sprintf(Header+CharPosHeader,"%s",", H [%]");
 801df50:	4b20      	ldr	r3, [pc, #128]	; (801dfd4 <DATALOG_SD_LogMems_Enable.constprop.0+0x2a4>)
      CharPosIntro += sprintf(Introduction+CharPosIntro,"H@%ld.%ld ",EnvHz,EnvSubHz);
 801df52:	4406      	add	r6, r0
      CharPosHeader += sprintf(Header+CharPosHeader,"%s",", H [%]");
 801df54:	cb03      	ldmia	r3!, {r0, r1}
 801df56:	eb08 020b 	add.w	r2, r8, fp
 801df5a:	f848 000b 	str.w	r0, [r8, fp]
 801df5e:	6051      	str	r1, [r2, #4]
 801df60:	f10b 0b07 	add.w	fp, fp, #7
 801df64:	e7b2      	b.n	801decc <DATALOG_SD_LogMems_Enable.constprop.0+0x19c>
      CharPosIntro += sprintf(Introduction+CharPosIntro,"T2@%ld.%ld ",EnvHz,EnvSubHz);
 801df66:	ab58      	add	r3, sp, #352	; 0x160
 801df68:	1998      	adds	r0, r3, r6
 801df6a:	491b      	ldr	r1, [pc, #108]	; (801dfd8 <DATALOG_SD_LogMems_Enable.constprop.0+0x2a8>)
 801df6c:	4653      	mov	r3, sl
 801df6e:	463a      	mov	r2, r7
 801df70:	f00a f908 	bl	8028184 <siprintf>
      CharPosHeader += sprintf(Header+CharPosHeader,"%s",", T2 ['C]");
 801df74:	4b19      	ldr	r3, [pc, #100]	; (801dfdc <DATALOG_SD_LogMems_Enable.constprop.0+0x2ac>)
    if(SD_Card_FeaturesMask&FEATURE_MASK_HUM) {
 801df76:	6865      	ldr	r5, [r4, #4]
      CharPosIntro += sprintf(Introduction+CharPosIntro,"T2@%ld.%ld ",EnvHz,EnvSubHz);
 801df78:	4406      	add	r6, r0
      CharPosHeader += sprintf(Header+CharPosHeader,"%s",", T2 ['C]");
 801df7a:	cb03      	ldmia	r3!, {r0, r1}
 801df7c:	eb08 020b 	add.w	r2, r8, fp
 801df80:	881b      	ldrh	r3, [r3, #0]
 801df82:	f848 000b 	str.w	r0, [r8, fp]
 801df86:	6051      	str	r1, [r2, #4]
 801df88:	8113      	strh	r3, [r2, #8]
 801df8a:	f10b 0b09 	add.w	fp, fp, #9
 801df8e:	e79b      	b.n	801dec8 <DATALOG_SD_LogMems_Enable.constprop.0+0x198>
 801df90:	20013528 	.word	0x20013528
 801df94:	0803982c 	.word	0x0803982c
 801df98:	200134f0 	.word	0x200134f0
 801df9c:	2000b518 	.word	0x2000b518
 801dfa0:	08041c74 	.word	0x08041c74
 801dfa4:	2000f658 	.word	0x2000f658
 801dfa8:	08041e40 	.word	0x08041e40
 801dfac:	200106a4 	.word	0x200106a4
 801dfb0:	08041ca0 	.word	0x08041ca0
 801dfb4:	2001457c 	.word	0x2001457c
 801dfb8:	200133dc 	.word	0x200133dc
 801dfbc:	200134dc 	.word	0x200134dc
 801dfc0:	08041cd4 	.word	0x08041cd4
 801dfc4:	20000d60 	.word	0x20000d60
 801dfc8:	cccccccd 	.word	0xcccccccd
 801dfcc:	08041c70 	.word	0x08041c70
 801dfd0:	08041e2c 	.word	0x08041e2c
 801dfd4:	08041e38 	.word	0x08041e38
 801dfd8:	08041e14 	.word	0x08041e14
 801dfdc:	08041e20 	.word	0x08041e20
 801dfe0:	08041d04 	.word	0x08041d04
 801dfe4:	08041d14 	.word	0x08041d14
 801dfe8:	08041d30 	.word	0x08041d30
      CharPosIntro += sprintf(Introduction+CharPosIntro,"Acc@%ld.%ld ",IneHz,IneSubHz);
 801dfec:	a858      	add	r0, sp, #352	; 0x160
 801dfee:	4950      	ldr	r1, [pc, #320]	; (801e130 <DATALOG_SD_LogMems_Enable.constprop.0+0x400>)
 801dff0:	ee18 2a10 	vmov	r2, s16
 801dff4:	464b      	mov	r3, r9
 801dff6:	4430      	add	r0, r6
 801dff8:	f00a f8c4 	bl	8028184 <siprintf>
      CharPosHeader += sprintf(Header+CharPosHeader,"%s",", AccX [mg], AccY, AccZ");
 801dffc:	f8df e154 	ldr.w	lr, [pc, #340]	; 801e154 <DATALOG_SD_LogMems_Enable.constprop.0+0x424>
    if(SD_Card_FeaturesMask&FEATURE_MASK_GRYO) {
 801e000:	6865      	ldr	r5, [r4, #4]
      CharPosIntro += sprintf(Introduction+CharPosIntro,"Acc@%ld.%ld ",IneHz,IneSubHz);
 801e002:	4406      	add	r6, r0
      CharPosHeader += sprintf(Header+CharPosHeader,"%s",", AccX [mg], AccY, AccZ");
 801e004:	e8be 000f 	ldmia.w	lr!, {r0, r1, r2, r3}
 801e008:	f10d 0c78 	add.w	ip, sp, #120	; 0x78
 801e00c:	e8ac 000f 	stmia.w	ip!, {r0, r1, r2, r3}
 801e010:	e89e 0003 	ldmia.w	lr, {r0, r1}
 801e014:	e88c 0003 	stmia.w	ip, {r0, r1}
    if(SD_Card_FeaturesMask&FEATURE_MASK_GRYO) {
 801e018:	0269      	lsls	r1, r5, #9
      CharPosHeader += sprintf(Header+CharPosHeader,"%s",", AccX [mg], AccY, AccZ");
 801e01a:	f04f 0b2f 	mov.w	fp, #47	; 0x2f
    if(SD_Card_FeaturesMask&FEATURE_MASK_GRYO) {
 801e01e:	f57f af48 	bpl.w	801deb2 <DATALOG_SD_LogMems_Enable.constprop.0+0x182>
      CharPosIntro += sprintf(Introduction+CharPosIntro,"Gyro@%ld.%ld ",IneHz,IneSubHz);
 801e022:	a858      	add	r0, sp, #352	; 0x160
 801e024:	4943      	ldr	r1, [pc, #268]	; (801e134 <DATALOG_SD_LogMems_Enable.constprop.0+0x404>)
 801e026:	ee18 2a10 	vmov	r2, s16
 801e02a:	464b      	mov	r3, r9
 801e02c:	4430      	add	r0, r6
 801e02e:	f00a f8a9 	bl	8028184 <siprintf>
      CharPosHeader += sprintf(Header+CharPosHeader,"%s",", GyroX [mdps], GyroY, GyroZ");
 801e032:	f8df c124 	ldr.w	ip, [pc, #292]	; 801e158 <DATALOG_SD_LogMems_Enable.constprop.0+0x428>
    if(SD_Card_FeaturesMask&FEATURE_MASK_MAG) {
 801e036:	6865      	ldr	r5, [r4, #4]
      CharPosIntro += sprintf(Introduction+CharPosIntro,"Gyro@%ld.%ld ",IneHz,IneSubHz);
 801e038:	4406      	add	r6, r0
      CharPosHeader += sprintf(Header+CharPosHeader,"%s",", GyroX [mdps], GyroY, GyroZ");
 801e03a:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 801e03e:	eb08 0e0b 	add.w	lr, r8, fp
 801e042:	f848 000b 	str.w	r0, [r8, fp]
 801e046:	f8ce 1004 	str.w	r1, [lr, #4]
 801e04a:	f8ce 2008 	str.w	r2, [lr, #8]
 801e04e:	e8bc 0007 	ldmia.w	ip!, {r0, r1, r2}
 801e052:	f8ce 300c 	str.w	r3, [lr, #12]
 801e056:	f8ce 2018 	str.w	r2, [lr, #24]
 801e05a:	f89c 3000 	ldrb.w	r3, [ip]
 801e05e:	f8ce 0010 	str.w	r0, [lr, #16]
    if(SD_Card_FeaturesMask&FEATURE_MASK_MAG) {
 801e062:	02aa      	lsls	r2, r5, #10
      CharPosHeader += sprintf(Header+CharPosHeader,"%s",", GyroX [mdps], GyroY, GyroZ");
 801e064:	f10b 0b1c 	add.w	fp, fp, #28
 801e068:	f8ce 1014 	str.w	r1, [lr, #20]
 801e06c:	f88e 301c 	strb.w	r3, [lr, #28]
    if(SD_Card_FeaturesMask&FEATURE_MASK_MAG) {
 801e070:	f57f af22 	bpl.w	801deb8 <DATALOG_SD_LogMems_Enable.constprop.0+0x188>
      CharPosIntro += sprintf(Introduction+CharPosIntro,"Mag@%ld.%ld ",IneHz,IneSubHz);
 801e074:	a858      	add	r0, sp, #352	; 0x160
 801e076:	ee18 2a10 	vmov	r2, s16
 801e07a:	492f      	ldr	r1, [pc, #188]	; (801e138 <DATALOG_SD_LogMems_Enable.constprop.0+0x408>)
 801e07c:	464b      	mov	r3, r9
 801e07e:	4430      	add	r0, r6
 801e080:	f00a f880 	bl	8028184 <siprintf>
      CharPosHeader += sprintf(Header+CharPosHeader,"%s",", MagX [mgauss], MagY, MagZ");
 801e084:	f8df c0d4 	ldr.w	ip, [pc, #212]	; 801e15c <DATALOG_SD_LogMems_Enable.constprop.0+0x42c>
    if(SD_Card_FeaturesMask&FEATURE_MASK_PRESS) {
 801e088:	6865      	ldr	r5, [r4, #4]
      CharPosIntro += sprintf(Introduction+CharPosIntro,"Mag@%ld.%ld ",IneHz,IneSubHz);
 801e08a:	4406      	add	r6, r0
      CharPosHeader += sprintf(Header+CharPosHeader,"%s",", MagX [mgauss], MagY, MagZ");
 801e08c:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 801e090:	eb08 0e0b 	add.w	lr, r8, fp
 801e094:	f848 000b 	str.w	r0, [r8, fp]
 801e098:	f8ce 1004 	str.w	r1, [lr, #4]
 801e09c:	f8ce 2008 	str.w	r2, [lr, #8]
 801e0a0:	e8bc 0007 	ldmia.w	ip!, {r0, r1, r2}
 801e0a4:	f8ce 300c 	str.w	r3, [lr, #12]
    if(SD_Card_FeaturesMask&FEATURE_MASK_PRESS) {
 801e0a8:	02eb      	lsls	r3, r5, #11
      CharPosHeader += sprintf(Header+CharPosHeader,"%s",", MagX [mgauss], MagY, MagZ");
 801e0aa:	f10b 0b1b 	add.w	fp, fp, #27
 801e0ae:	f8ce 0010 	str.w	r0, [lr, #16]
 801e0b2:	f8ce 1014 	str.w	r1, [lr, #20]
 801e0b6:	f8ce 2018 	str.w	r2, [lr, #24]
    if(SD_Card_FeaturesMask&FEATURE_MASK_PRESS) {
 801e0ba:	f57f af00 	bpl.w	801debe <DATALOG_SD_LogMems_Enable.constprop.0+0x18e>
      CharPosIntro += sprintf(Introduction+CharPosIntro,"P@%ld.%ld ",EnvHz,EnvSubHz);
 801e0be:	ab58      	add	r3, sp, #352	; 0x160
 801e0c0:	1998      	adds	r0, r3, r6
 801e0c2:	491e      	ldr	r1, [pc, #120]	; (801e13c <DATALOG_SD_LogMems_Enable.constprop.0+0x40c>)
 801e0c4:	4653      	mov	r3, sl
 801e0c6:	463a      	mov	r2, r7
 801e0c8:	f00a f85c 	bl	8028184 <siprintf>
      CharPosHeader += sprintf(Header+CharPosHeader,"%s",", P [mB]");
 801e0cc:	4b1c      	ldr	r3, [pc, #112]	; (801e140 <DATALOG_SD_LogMems_Enable.constprop.0+0x410>)
    if(SD_Card_FeaturesMask&FEATURE_MASK_TEMP1) {
 801e0ce:	6865      	ldr	r5, [r4, #4]
      CharPosIntro += sprintf(Introduction+CharPosIntro,"P@%ld.%ld ",EnvHz,EnvSubHz);
 801e0d0:	4406      	add	r6, r0
      CharPosHeader += sprintf(Header+CharPosHeader,"%s",", P [mB]");
 801e0d2:	cb03      	ldmia	r3!, {r0, r1}
 801e0d4:	eb08 020b 	add.w	r2, r8, fp
 801e0d8:	f848 000b 	str.w	r0, [r8, fp]
 801e0dc:	781b      	ldrb	r3, [r3, #0]
 801e0de:	6051      	str	r1, [r2, #4]
    if(SD_Card_FeaturesMask&FEATURE_MASK_TEMP1) {
 801e0e0:	0368      	lsls	r0, r5, #13
      CharPosHeader += sprintf(Header+CharPosHeader,"%s",", P [mB]");
 801e0e2:	7213      	strb	r3, [r2, #8]
 801e0e4:	f10b 0b08 	add.w	fp, fp, #8
    if(SD_Card_FeaturesMask&FEATURE_MASK_TEMP1) {
 801e0e8:	f57f aeec 	bpl.w	801dec4 <DATALOG_SD_LogMems_Enable.constprop.0+0x194>
      CharPosIntro += sprintf(Introduction+CharPosIntro,"T1@%ld.%ld ",EnvHz,EnvSubHz);
 801e0ec:	ab58      	add	r3, sp, #352	; 0x160
 801e0ee:	1998      	adds	r0, r3, r6
 801e0f0:	4914      	ldr	r1, [pc, #80]	; (801e144 <DATALOG_SD_LogMems_Enable.constprop.0+0x414>)
 801e0f2:	4653      	mov	r3, sl
 801e0f4:	463a      	mov	r2, r7
 801e0f6:	f00a f845 	bl	8028184 <siprintf>
      CharPosHeader += sprintf(Header+CharPosHeader,"%s",", T1 ['C]");
 801e0fa:	4b13      	ldr	r3, [pc, #76]	; (801e148 <DATALOG_SD_LogMems_Enable.constprop.0+0x418>)
    if(SD_Card_FeaturesMask&FEATURE_MASK_TEMP2) {
 801e0fc:	6865      	ldr	r5, [r4, #4]
      CharPosIntro += sprintf(Introduction+CharPosIntro,"T1@%ld.%ld ",EnvHz,EnvSubHz);
 801e0fe:	4406      	add	r6, r0
      CharPosHeader += sprintf(Header+CharPosHeader,"%s",", T1 ['C]");
 801e100:	cb03      	ldmia	r3!, {r0, r1}
 801e102:	eb08 020b 	add.w	r2, r8, fp
 801e106:	881b      	ldrh	r3, [r3, #0]
 801e108:	f848 000b 	str.w	r0, [r8, fp]
 801e10c:	6051      	str	r1, [r2, #4]
 801e10e:	8113      	strh	r3, [r2, #8]
 801e110:	f10b 0b09 	add.w	fp, fp, #9
 801e114:	e6d6      	b.n	801dec4 <DATALOG_SD_LogMems_Enable.constprop.0+0x194>
      CharPosIntro += sprintf(Introduction+CharPosIntro,"Mic@%d Volume=%ld ",AUDIO_SAMPLING_FREQUENCY,TargetBoardFeatures.AudioVolume);
 801e116:	4b0d      	ldr	r3, [pc, #52]	; (801e14c <DATALOG_SD_LogMems_Enable.constprop.0+0x41c>)
 801e118:	490d      	ldr	r1, [pc, #52]	; (801e150 <DATALOG_SD_LogMems_Enable.constprop.0+0x420>)
 801e11a:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 801e11c:	f44f 527a 	mov.w	r2, #16000	; 0x3e80
 801e120:	f20d 107b 	addw	r0, sp, #379	; 0x17b
 801e124:	f00a f82e 	bl	8028184 <siprintf>
    if(SD_Card_FeaturesMask&FEATURE_MASK_ACC) {
 801e128:	6865      	ldr	r5, [r4, #4]
      CharPosIntro += sprintf(Introduction+CharPosIntro,"Mic@%d Volume=%ld ",AUDIO_SAMPLING_FREQUENCY,TargetBoardFeatures.AudioVolume);
 801e12a:	f100 061b 	add.w	r6, r0, #27
 801e12e:	e6b8      	b.n	801dea2 <DATALOG_SD_LogMems_Enable.constprop.0+0x172>
 801e130:	08041d60 	.word	0x08041d60
 801e134:	08041d88 	.word	0x08041d88
 801e138:	08041db8 	.word	0x08041db8
 801e13c:	08041de4 	.word	0x08041de4
 801e140:	08041df0 	.word	0x08041df0
 801e144:	08041dfc 	.word	0x08041dfc
 801e148:	08041e08 	.word	0x08041e08
 801e14c:	200106a4 	.word	0x200106a4
 801e150:	08041d4c 	.word	0x08041d4c
 801e154:	08041d70 	.word	0x08041d70
 801e158:	08041d98 	.word	0x08041d98
 801e15c:	08041dc8 	.word	0x08041dc8

0801e160 <DATALOG_SD_LogAudio_Disable>:
{
 801e160:	b570      	push	{r4, r5, r6, lr}
  if(SD_LogAudio_Enabled) {
 801e162:	4d19      	ldr	r5, [pc, #100]	; (801e1c8 <DATALOG_SD_LogAudio_Disable+0x68>)
 801e164:	69ab      	ldr	r3, [r5, #24]
{
 801e166:	b082      	sub	sp, #8
 801e168:	4604      	mov	r4, r0
  if(SD_LogAudio_Enabled) {
 801e16a:	b913      	cbnz	r3, 801e172 <DATALOG_SD_LogAudio_Disable+0x12>
  if(SomethingAlreadyRecording==0 ) {
 801e16c:	b334      	cbz	r4, 801e1bc <DATALOG_SD_LogAudio_Disable+0x5c>
}
 801e16e:	b002      	add	sp, #8
 801e170:	bd70      	pop	{r4, r5, r6, pc}
    len = f_size(&MyFileAudio);
 801e172:	4e16      	ldr	r6, [pc, #88]	; (801e1cc <DATALOG_SD_LogAudio_Disable+0x6c>)
 801e174:	68f3      	ldr	r3, [r6, #12]
  pAudioHeader[4] = (uint8_t)(len);
 801e176:	622b      	str	r3, [r5, #32]
    osDelay(100);
 801e178:	2064      	movs	r0, #100	; 0x64
  len -=44;
 801e17a:	3b2c      	subs	r3, #44	; 0x2c
  pAudioHeader[40] = (uint8_t)(len); 
 801e17c:	646b      	str	r3, [r5, #68]	; 0x44
    osDelay(100);
 801e17e:	f7fa fba1 	bl	80188c4 <osDelay>
    f_lseek(&MyFileAudio, 0);
 801e182:	2100      	movs	r1, #0
 801e184:	4630      	mov	r0, r6
 801e186:	f7f9 fcc3 	bl	8017b10 <f_lseek>
    if(f_write(&MyFileAudio, (uint8_t*)pAudioHeader,  sizeof(pAudioHeader), (void*)&byteswritten) != FR_OK) {
 801e18a:	ab01      	add	r3, sp, #4
 801e18c:	222c      	movs	r2, #44	; 0x2c
 801e18e:	4630      	mov	r0, r6
 801e190:	f105 011c 	add.w	r1, r5, #28
 801e194:	f7f9 fb1a 	bl	80177cc <f_write>
 801e198:	b130      	cbz	r0, 801e1a8 <DATALOG_SD_LogAudio_Disable+0x48>
      if(W2ST_CHECK_CONNECTION(W2ST_CONNECT_SD_CARD_LOGGING)) {
 801e19a:	4b0d      	ldr	r3, [pc, #52]	; (801e1d0 <DATALOG_SD_LogAudio_Disable+0x70>)
 801e19c:	681b      	ldr	r3, [r3, #0]
 801e19e:	055b      	lsls	r3, r3, #21
 801e1a0:	d502      	bpl.n	801e1a8 <DATALOG_SD_LogAudio_Disable+0x48>
        SDLog_Update(SD_CARD_LOGGING_IO_ERROR);
 801e1a2:	2003      	movs	r0, #3
 801e1a4:	f005 fc56 	bl	8023a54 <SDLog_Update>
    osDelay(100);
 801e1a8:	2064      	movs	r0, #100	; 0x64
 801e1aa:	f7fa fb8b 	bl	80188c4 <osDelay>
    f_close(&MyFileAudio);
 801e1ae:	4807      	ldr	r0, [pc, #28]	; (801e1cc <DATALOG_SD_LogAudio_Disable+0x6c>)
 801e1b0:	f7f9 fc82 	bl	8017ab8 <f_close>
    SD_LogAudio_Enabled=0;
 801e1b4:	2300      	movs	r3, #0
 801e1b6:	61ab      	str	r3, [r5, #24]
  if(SomethingAlreadyRecording==0 ) {
 801e1b8:	2c00      	cmp	r4, #0
 801e1ba:	d1d8      	bne.n	801e16e <DATALOG_SD_LogAudio_Disable+0xe>
    NoSDFlag =0;
 801e1bc:	64ac      	str	r4, [r5, #72]	; 0x48
    LedOffTargetPlatform();
 801e1be:	f001 fae5 	bl	801f78c <LedOffTargetPlatform>
}
 801e1c2:	b002      	add	sp, #8
 801e1c4:	bd70      	pop	{r4, r5, r6, pc}
 801e1c6:	bf00      	nop
 801e1c8:	2000b518 	.word	0x2000b518
 801e1cc:	2000e628 	.word	0x2000e628
 801e1d0:	2001457c 	.word	0x2001457c

0801e1d4 <AudioProcess_SD_Recording>:
{
 801e1d4:	b570      	push	{r4, r5, r6, lr}
  memcpy(Audio_OUT_Buff + OutBuffIndex, pInBuff, len * sizeof(uint16_t));
 801e1d6:	4d14      	ldr	r5, [pc, #80]	; (801e228 <AudioProcess_SD_Recording+0x54>)
 801e1d8:	f8b5 404c 	ldrh.w	r4, [r5, #76]	; 0x4c
 801e1dc:	6d2b      	ldr	r3, [r5, #80]	; 0x50
{
 801e1de:	460e      	mov	r6, r1
  memcpy(Audio_OUT_Buff + OutBuffIndex, pInBuff, len * sizeof(uint16_t));
 801e1e0:	0072      	lsls	r2, r6, #1
{
 801e1e2:	4601      	mov	r1, r0
  memcpy(Audio_OUT_Buff + OutBuffIndex, pInBuff, len * sizeof(uint16_t));
 801e1e4:	eb03 0044 	add.w	r0, r3, r4, lsl #1
 801e1e8:	f009 f99e 	bl	8027528 <memcpy>
  NbAudioSamplesCounter += len;
 801e1ec:	6d69      	ldr	r1, [r5, #84]	; 0x54
  OutBuffIndex += len;
 801e1ee:	19a3      	adds	r3, r4, r6
  OutBuffIndex &=AUDIO_BUFF_LEN_MASK;
 801e1f0:	f3c3 030a 	ubfx	r3, r3, #0, #11
  NbAudioSamplesCounter += len;
 801e1f4:	440e      	add	r6, r1
  if(OutBuffIndex == (AUDIO_BUFF_LEN / 2)) {
 801e1f6:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
  NbAudioSamplesCounter += len;
 801e1fa:	656e      	str	r6, [r5, #84]	; 0x54
  OutBuffIndex &=AUDIO_BUFF_LEN_MASK;
 801e1fc:	f8a5 304c 	strh.w	r3, [r5, #76]	; 0x4c
  if(OutBuffIndex == (AUDIO_BUFF_LEN / 2)) {
 801e200:	d00e      	beq.n	801e220 <AudioProcess_SD_Recording+0x4c>
  } else if (OutBuffIndex == 0) {
 801e202:	b963      	cbnz	r3, 801e21e <AudioProcess_SD_Recording+0x4a>
    if(semRun) {
 801e204:	4b09      	ldr	r3, [pc, #36]	; (801e22c <AudioProcess_SD_Recording+0x58>)
    index_buff= AUDIO_BUFF_LEN / 2;
 801e206:	f44f 6280 	mov.w	r2, #1024	; 0x400
    if(semRun) {
 801e20a:	6818      	ldr	r0, [r3, #0]
    index_buff= AUDIO_BUFF_LEN / 2;
 801e20c:	65aa      	str	r2, [r5, #88]	; 0x58
    writeAudio_flag=1;
 801e20e:	2301      	movs	r3, #1
 801e210:	f885 305c 	strb.w	r3, [r5, #92]	; 0x5c
    if(semRun) {
 801e214:	b118      	cbz	r0, 801e21e <AudioProcess_SD_Recording+0x4a>
}
 801e216:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
      osSemaphoreRelease(semRun);
 801e21a:	f7fa bc21 	b.w	8018a60 <osSemaphoreRelease>
}
 801e21e:	bd70      	pop	{r4, r5, r6, pc}
    if(semRun) {
 801e220:	4b02      	ldr	r3, [pc, #8]	; (801e22c <AudioProcess_SD_Recording+0x58>)
    index_buff=0;
 801e222:	2200      	movs	r2, #0
 801e224:	e7f1      	b.n	801e20a <AudioProcess_SD_Recording+0x36>
 801e226:	bf00      	nop
 801e228:	2000b518 	.word	0x2000b518
 801e22c:	20012a9c 	.word	0x20012a9c

0801e230 <SD_CardLoggingMemsStop>:
{
 801e230:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  if(IsSdMemsRecording) {
 801e232:	4c40      	ldr	r4, [pc, #256]	; (801e334 <SD_CardLoggingMemsStop+0x104>)
 801e234:	6e23      	ldr	r3, [r4, #96]	; 0x60
 801e236:	bb03      	cbnz	r3, 801e27a <SD_CardLoggingMemsStop+0x4a>
    if(W2ST_CHECK_CONNECTION(W2ST_CONNECT_STD_ERR)){
 801e238:	4b3f      	ldr	r3, [pc, #252]	; (801e338 <SD_CardLoggingMemsStop+0x108>)
 801e23a:	681b      	ldr	r3, [r3, #0]
 801e23c:	065b      	lsls	r3, r3, #25
 801e23e:	d405      	bmi.n	801e24c <SD_CardLoggingMemsStop+0x1c>
  PowerCtrlUnLock();
 801e240:	f000 ffea 	bl	801f218 <PowerCtrlUnLock>
}
 801e244:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
  LedInitTargetPlatform();
 801e248:	f001 baa4 	b.w	801f794 <LedInitTargetPlatform>
      BytesToWrite =sprintf((char *)BufferToWrite,"5 None Data Log MEMS\n");
 801e24c:	4c3b      	ldr	r4, [pc, #236]	; (801e33c <SD_CardLoggingMemsStop+0x10c>)
 801e24e:	4d3c      	ldr	r5, [pc, #240]	; (801e340 <SD_CardLoggingMemsStop+0x110>)
 801e250:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 801e252:	6028      	str	r0, [r5, #0]
 801e254:	6820      	ldr	r0, [r4, #0]
 801e256:	6128      	str	r0, [r5, #16]
 801e258:	483a      	ldr	r0, [pc, #232]	; (801e344 <SD_CardLoggingMemsStop+0x114>)
 801e25a:	88a4      	ldrh	r4, [r4, #4]
 801e25c:	6069      	str	r1, [r5, #4]
 801e25e:	2115      	movs	r1, #21
 801e260:	6001      	str	r1, [r0, #0]
 801e262:	60aa      	str	r2, [r5, #8]
 801e264:	60eb      	str	r3, [r5, #12]
 801e266:	82ac      	strh	r4, [r5, #20]
      Stderr_Update(BufferToWrite,BytesToWrite);
 801e268:	4628      	mov	r0, r5
 801e26a:	f004 fef1 	bl	8023050 <Stderr_Update>
  PowerCtrlUnLock();
 801e26e:	f000 ffd3 	bl	801f218 <PowerCtrlUnLock>
}
 801e272:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
  LedInitTargetPlatform();
 801e276:	f001 ba8d 	b.w	801f794 <LedInitTargetPlatform>
    stopProc(SD_CARD_LOGGING);
 801e27a:	2011      	movs	r0, #17
 801e27c:	f003 fcec 	bl	8021c58 <stopProc>
  if(SD_LogMems_Enabled) {
 801e280:	68a3      	ldr	r3, [r4, #8]
    IsSdMemsRecording= 0;
 801e282:	2500      	movs	r5, #0
 801e284:	6625      	str	r5, [r4, #96]	; 0x60
  if(SD_LogMems_Enabled) {
 801e286:	bb6b      	cbnz	r3, 801e2e4 <SD_CardLoggingMemsStop+0xb4>
    if(W2ST_CHECK_CONNECTION(W2ST_CONNECT_STD_TERM)) {
 801e288:	4b2b      	ldr	r3, [pc, #172]	; (801e338 <SD_CardLoggingMemsStop+0x108>)
 801e28a:	681b      	ldr	r3, [r3, #0]
 801e28c:	069d      	lsls	r5, r3, #26
 801e28e:	d417      	bmi.n	801e2c0 <SD_CardLoggingMemsStop+0x90>
      (SD_Card_FeaturesMask & FEATURE_MASK_GRYO) ||
 801e290:	6863      	ldr	r3, [r4, #4]
    if((SD_Card_FeaturesMask & FEATURE_MASK_ACC)  ||
 801e292:	f413 0f60 	tst.w	r3, #14680064	; 0xe00000
 801e296:	d008      	beq.n	801e2aa <SD_CardLoggingMemsStop+0x7a>
      if(SD_Card_FeaturesMask & FEATURE_MASK_ACC) {
 801e298:	0218      	lsls	r0, r3, #8
 801e29a:	d43d      	bmi.n	801e318 <SD_CardLoggingMemsStop+0xe8>
      if(SD_Card_FeaturesMask & FEATURE_MASK_GRYO) {
 801e29c:	0259      	lsls	r1, r3, #9
 801e29e:	d432      	bmi.n	801e306 <SD_CardLoggingMemsStop+0xd6>
      if(SD_Card_FeaturesMask & FEATURE_MASK_MAG) {
 801e2a0:	029a      	lsls	r2, r3, #10
 801e2a2:	d428      	bmi.n	801e2f6 <SD_CardLoggingMemsStop+0xc6>
      DisableMotionSensors();
 801e2a4:	f001 f83c 	bl	801f320 <DisableMotionSensors>
        (SD_Card_FeaturesMask & FEATURE_MASK_TEMP1) ||
 801e2a8:	6863      	ldr	r3, [r4, #4]
    if( (SD_Card_FeaturesMask & FEATURE_MASK_PRESS) ||
 801e2aa:	f413 1fe8 	tst.w	r3, #1900544	; 0x1d0000
 801e2ae:	d0c7      	beq.n	801e240 <SD_CardLoggingMemsStop+0x10>
      DisableEnvSensors ();
 801e2b0:	f001 f8c8 	bl	801f444 <DisableEnvSensors>
  PowerCtrlUnLock();
 801e2b4:	f000 ffb0 	bl	801f218 <PowerCtrlUnLock>
}
 801e2b8:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
  LedInitTargetPlatform();
 801e2bc:	f001 ba6a 	b.w	801f794 <LedInitTargetPlatform>
      BytesToWrite =sprintf((char *)BufferToWrite,"Stop Data Log MEMS Rec\n");
 801e2c0:	4b20      	ldr	r3, [pc, #128]	; (801e344 <SD_CardLoggingMemsStop+0x114>)
 801e2c2:	4d21      	ldr	r5, [pc, #132]	; (801e348 <SD_CardLoggingMemsStop+0x118>)
 801e2c4:	4e1e      	ldr	r6, [pc, #120]	; (801e340 <SD_CardLoggingMemsStop+0x110>)
 801e2c6:	2717      	movs	r7, #23
 801e2c8:	601f      	str	r7, [r3, #0]
 801e2ca:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 801e2cc:	6030      	str	r0, [r6, #0]
 801e2ce:	6071      	str	r1, [r6, #4]
 801e2d0:	cd03      	ldmia	r5!, {r0, r1}
 801e2d2:	60b2      	str	r2, [r6, #8]
 801e2d4:	6130      	str	r0, [r6, #16]
 801e2d6:	6171      	str	r1, [r6, #20]
 801e2d8:	60f3      	str	r3, [r6, #12]
      Term_Update(BufferToWrite,BytesToWrite);
 801e2da:	4630      	mov	r0, r6
 801e2dc:	4639      	mov	r1, r7
 801e2de:	f004 fee7 	bl	80230b0 <Term_Update>
 801e2e2:	e7d5      	b.n	801e290 <SD_CardLoggingMemsStop+0x60>
    closeFileMems(IsSdAudioRecording);
 801e2e4:	6e66      	ldr	r6, [r4, #100]	; 0x64
    f_close(&MyFileMems);
 801e2e6:	4819      	ldr	r0, [pc, #100]	; (801e34c <SD_CardLoggingMemsStop+0x11c>)
 801e2e8:	f7f9 fbe6 	bl	8017ab8 <f_close>
    SD_LogMems_Enabled =0;
 801e2ec:	60a5      	str	r5, [r4, #8]
  if(SomethingAlreadyRecording==0) {
 801e2ee:	b1e6      	cbz	r6, 801e32a <SD_CardLoggingMemsStop+0xfa>
    SD_LogMems_Enabled=0;
 801e2f0:	2300      	movs	r3, #0
 801e2f2:	60a3      	str	r3, [r4, #8]
 801e2f4:	e7c8      	b.n	801e288 <SD_CardLoggingMemsStop+0x58>
        MOTION_SENSOR_SetOutputDataRate(TargetBoardFeatures.HandleMagSensor, MOTION_MAGNETO,TargetBoardFeatures.DefaultMagODR);
 801e2f6:	4b16      	ldr	r3, [pc, #88]	; (801e350 <SD_CardLoggingMemsStop+0x120>)
 801e2f8:	2104      	movs	r1, #4
 801e2fa:	ed93 0a0b 	vldr	s0, [r3, #44]	; 0x2c
 801e2fe:	6a18      	ldr	r0, [r3, #32]
 801e300:	f7ee fbe0 	bl	800cac4 <BSP_MOTION_SENSOR_SetOutputDataRate>
 801e304:	e7ce      	b.n	801e2a4 <SD_CardLoggingMemsStop+0x74>
        MOTION_SENSOR_SetOutputDataRate(TargetBoardFeatures.HandleGyroSensor, MOTION_GYRO,TargetBoardFeatures.DefaultGyroODR);
 801e306:	4b12      	ldr	r3, [pc, #72]	; (801e350 <SD_CardLoggingMemsStop+0x120>)
 801e308:	2101      	movs	r1, #1
 801e30a:	ed93 0a0a 	vldr	s0, [r3, #40]	; 0x28
 801e30e:	69d8      	ldr	r0, [r3, #28]
 801e310:	f7ee fbd8 	bl	800cac4 <BSP_MOTION_SENSOR_SetOutputDataRate>
      if(SD_Card_FeaturesMask & FEATURE_MASK_MAG) {
 801e314:	6863      	ldr	r3, [r4, #4]
 801e316:	e7c3      	b.n	801e2a0 <SD_CardLoggingMemsStop+0x70>
        MOTION_SENSOR_SetOutputDataRate(TargetBoardFeatures.HandleAccSensor, MOTION_ACCELERO,TargetBoardFeatures.DefaultAccODR);
 801e318:	4b0d      	ldr	r3, [pc, #52]	; (801e350 <SD_CardLoggingMemsStop+0x120>)
 801e31a:	2102      	movs	r1, #2
 801e31c:	ed93 0a09 	vldr	s0, [r3, #36]	; 0x24
 801e320:	6998      	ldr	r0, [r3, #24]
 801e322:	f7ee fbcf 	bl	800cac4 <BSP_MOTION_SENSOR_SetOutputDataRate>
      if(SD_Card_FeaturesMask & FEATURE_MASK_GRYO) {
 801e326:	6863      	ldr	r3, [r4, #4]
 801e328:	e7b8      	b.n	801e29c <SD_CardLoggingMemsStop+0x6c>
    NoSDFlag =0;
 801e32a:	64a6      	str	r6, [r4, #72]	; 0x48
    LedOffTargetPlatform();
 801e32c:	f001 fa2e 	bl	801f78c <LedOffTargetPlatform>
 801e330:	e7de      	b.n	801e2f0 <SD_CardLoggingMemsStop+0xc0>
 801e332:	bf00      	nop
 801e334:	2000b518 	.word	0x2000b518
 801e338:	2001457c 	.word	0x2001457c
 801e33c:	08041e74 	.word	0x08041e74
 801e340:	200133dc 	.word	0x200133dc
 801e344:	200134dc 	.word	0x200134dc
 801e348:	08041e5c 	.word	0x08041e5c
 801e34c:	2000f658 	.word	0x2000f658
 801e350:	200106a4 	.word	0x200106a4

0801e354 <SD_CardLoggingAudioStop>:
{
 801e354:	b570      	push	{r4, r5, r6, lr}
  if(IsSdAudioRecording) {
 801e356:	4c29      	ldr	r4, [pc, #164]	; (801e3fc <SD_CardLoggingAudioStop+0xa8>)
 801e358:	6e63      	ldr	r3, [r4, #100]	; 0x64
 801e35a:	bb13      	cbnz	r3, 801e3a2 <SD_CardLoggingAudioStop+0x4e>
    if(W2ST_CHECK_CONNECTION(W2ST_CONNECT_STD_ERR)){
 801e35c:	4b28      	ldr	r3, [pc, #160]	; (801e400 <SD_CardLoggingAudioStop+0xac>)
 801e35e:	681b      	ldr	r3, [r3, #0]
 801e360:	065b      	lsls	r3, r3, #25
 801e362:	d405      	bmi.n	801e370 <SD_CardLoggingAudioStop+0x1c>
  PowerCtrlUnLock();
 801e364:	f000 ff58 	bl	801f218 <PowerCtrlUnLock>
}
 801e368:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
  LedInitTargetPlatform();
 801e36c:	f001 ba12 	b.w	801f794 <LedInitTargetPlatform>
      BytesToWrite =sprintf((char *)BufferToWrite,"6 None Data Log Audio\n");
 801e370:	4c24      	ldr	r4, [pc, #144]	; (801e404 <SD_CardLoggingAudioStop+0xb0>)
 801e372:	4d25      	ldr	r5, [pc, #148]	; (801e408 <SD_CardLoggingAudioStop+0xb4>)
 801e374:	4e25      	ldr	r6, [pc, #148]	; (801e40c <SD_CardLoggingAudioStop+0xb8>)
 801e376:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 801e378:	6069      	str	r1, [r5, #4]
 801e37a:	88a1      	ldrh	r1, [r4, #4]
 801e37c:	6028      	str	r0, [r5, #0]
 801e37e:	82a9      	strh	r1, [r5, #20]
 801e380:	6820      	ldr	r0, [r4, #0]
 801e382:	79a1      	ldrb	r1, [r4, #6]
 801e384:	6128      	str	r0, [r5, #16]
 801e386:	60aa      	str	r2, [r5, #8]
 801e388:	60eb      	str	r3, [r5, #12]
 801e38a:	75a9      	strb	r1, [r5, #22]
      Stderr_Update(BufferToWrite,BytesToWrite);
 801e38c:	4628      	mov	r0, r5
      BytesToWrite =sprintf((char *)BufferToWrite,"6 None Data Log Audio\n");
 801e38e:	2116      	movs	r1, #22
 801e390:	6031      	str	r1, [r6, #0]
      Stderr_Update(BufferToWrite,BytesToWrite);
 801e392:	f004 fe5d 	bl	8023050 <Stderr_Update>
  PowerCtrlUnLock();
 801e396:	f000 ff3f 	bl	801f218 <PowerCtrlUnLock>
}
 801e39a:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
  LedInitTargetPlatform();
 801e39e:	f001 b9f9 	b.w	801f794 <LedInitTargetPlatform>
    DeInitMics();
 801e3a2:	f001 f8d1 	bl	801f548 <DeInitMics>
  if(SD_LogAudio_Enabled) {
 801e3a6:	69a3      	ldr	r3, [r4, #24]
    writeAudio_flag=0;
 801e3a8:	2500      	movs	r5, #0
 801e3aa:	f884 505c 	strb.w	r5, [r4, #92]	; 0x5c
    IsSdAudioRecording= 0;
 801e3ae:	6665      	str	r5, [r4, #100]	; 0x64
  if(SD_LogAudio_Enabled) {
 801e3b0:	b9fb      	cbnz	r3, 801e3f2 <SD_CardLoggingAudioStop+0x9e>
  vPortFree((void*)Audio_OUT_Buff);
 801e3b2:	6d20      	ldr	r0, [r4, #80]	; 0x50
 801e3b4:	f7fa fd76 	bl	8018ea4 <vPortFree>
    if(W2ST_CHECK_CONNECTION(W2ST_CONNECT_STD_TERM)) {
 801e3b8:	4b11      	ldr	r3, [pc, #68]	; (801e400 <SD_CardLoggingAudioStop+0xac>)
 801e3ba:	681b      	ldr	r3, [r3, #0]
 801e3bc:	069a      	lsls	r2, r3, #26
 801e3be:	d5d1      	bpl.n	801e364 <SD_CardLoggingAudioStop+0x10>
      BytesToWrite =sprintf((char *)BufferToWrite,"Stop Data Log Audio Rec\n");
 801e3c0:	4c13      	ldr	r4, [pc, #76]	; (801e410 <SD_CardLoggingAudioStop+0xbc>)
 801e3c2:	4d11      	ldr	r5, [pc, #68]	; (801e408 <SD_CardLoggingAudioStop+0xb4>)
 801e3c4:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 801e3c6:	6069      	str	r1, [r5, #4]
 801e3c8:	4910      	ldr	r1, [pc, #64]	; (801e40c <SD_CardLoggingAudioStop+0xb8>)
 801e3ca:	6028      	str	r0, [r5, #0]
 801e3cc:	2618      	movs	r6, #24
 801e3ce:	600e      	str	r6, [r1, #0]
 801e3d0:	cc03      	ldmia	r4!, {r0, r1}
 801e3d2:	60eb      	str	r3, [r5, #12]
 801e3d4:	7823      	ldrb	r3, [r4, #0]
 801e3d6:	60aa      	str	r2, [r5, #8]
 801e3d8:	6128      	str	r0, [r5, #16]
 801e3da:	6169      	str	r1, [r5, #20]
 801e3dc:	762b      	strb	r3, [r5, #24]
      Term_Update(BufferToWrite,BytesToWrite);
 801e3de:	4631      	mov	r1, r6
 801e3e0:	4628      	mov	r0, r5
 801e3e2:	f004 fe65 	bl	80230b0 <Term_Update>
  PowerCtrlUnLock();
 801e3e6:	f000 ff17 	bl	801f218 <PowerCtrlUnLock>
}
 801e3ea:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
  LedInitTargetPlatform();
 801e3ee:	f001 b9d1 	b.w	801f794 <LedInitTargetPlatform>
    DATALOG_SD_LogAudio_Disable(SomethingAlreadyRecording);
 801e3f2:	6e20      	ldr	r0, [r4, #96]	; 0x60
 801e3f4:	f7ff feb4 	bl	801e160 <DATALOG_SD_LogAudio_Disable>
    SD_LogAudio_Enabled=0;
 801e3f8:	61a5      	str	r5, [r4, #24]
 801e3fa:	e7da      	b.n	801e3b2 <SD_CardLoggingAudioStop+0x5e>
 801e3fc:	2000b518 	.word	0x2000b518
 801e400:	2001457c 	.word	0x2001457c
 801e404:	08041ea8 	.word	0x08041ea8
 801e408:	200133dc 	.word	0x200133dc
 801e40c:	200134dc 	.word	0x200134dc
 801e410:	08041e8c 	.word	0x08041e8c

0801e414 <volumeInit>:
{
 801e414:	b510      	push	{r4, lr}
  SENSING1_PRINTF("Creating FAT Volume...\r\n");
 801e416:	4c22      	ldr	r4, [pc, #136]	; (801e4a0 <volumeInit+0x8c>)
 801e418:	7823      	ldrb	r3, [r4, #0]
{
 801e41a:	b084      	sub	sp, #16
  SENSING1_PRINTF("Creating FAT Volume...\r\n");
 801e41c:	b9a3      	cbnz	r3, 801e448 <volumeInit+0x34>
  res = f_mkfs(SDPath, FM_ANY, 0, workBuffer, sizeof(workBuffer));
 801e41e:	f44f 5280 	mov.w	r2, #4096	; 0x1000
 801e422:	4b20      	ldr	r3, [pc, #128]	; (801e4a4 <volumeInit+0x90>)
 801e424:	9200      	str	r2, [sp, #0]
 801e426:	2107      	movs	r1, #7
 801e428:	481f      	ldr	r0, [pc, #124]	; (801e4a8 <volumeInit+0x94>)
 801e42a:	2200      	movs	r2, #0
 801e42c:	f7f9 fe02 	bl	8018034 <f_mkfs>
    SENSING1_PRINTF("mkfs error: %d.\r\n", res);
 801e430:	7823      	ldrb	r3, [r4, #0]
  if (res != FR_OK)
 801e432:	4601      	mov	r1, r0
 801e434:	bb28      	cbnz	r0, 801e482 <volumeInit+0x6e>
  SENSING1_PRINTF("Creating STM32.TXT\r\n");
 801e436:	b9e3      	cbnz	r3, 801e472 <volumeInit+0x5e>
  if (f_open(&MyFileDummy, "STM32.TXT", FA_CREATE_ALWAYS | FA_WRITE) == FR_OK)
 801e438:	491c      	ldr	r1, [pc, #112]	; (801e4ac <volumeInit+0x98>)
 801e43a:	481d      	ldr	r0, [pc, #116]	; (801e4b0 <volumeInit+0x9c>)
 801e43c:	220a      	movs	r2, #10
 801e43e:	f7f8 ff57 	bl	80172f0 <f_open>
 801e442:	b128      	cbz	r0, 801e450 <volumeInit+0x3c>
}
 801e444:	b004      	add	sp, #16
 801e446:	bd10      	pop	{r4, pc}
  SENSING1_PRINTF("Creating FAT Volume...\r\n");
 801e448:	481a      	ldr	r0, [pc, #104]	; (801e4b4 <volumeInit+0xa0>)
 801e44a:	f009 fe83 	bl	8028154 <puts>
 801e44e:	e7e6      	b.n	801e41e <volumeInit+0xa>
    res = f_write(&MyFileDummy, wtext, sizeof(wtext) - 1, (void *)&byteswritten);
 801e450:	4919      	ldr	r1, [pc, #100]	; (801e4b8 <volumeInit+0xa4>)
 801e452:	4817      	ldr	r0, [pc, #92]	; (801e4b0 <volumeInit+0x9c>)
 801e454:	ab03      	add	r3, sp, #12
 801e456:	2213      	movs	r2, #19
 801e458:	f7f9 f9b8 	bl	80177cc <f_write>
    if (res != FR_OK || (byteswritten != (sizeof(wtext) - 1)))
 801e45c:	b9a0      	cbnz	r0, 801e488 <volumeInit+0x74>
 801e45e:	9b03      	ldr	r3, [sp, #12]
 801e460:	2b13      	cmp	r3, #19
 801e462:	d111      	bne.n	801e488 <volumeInit+0x74>
    SENSING1_PRINTF("Closing file\r\n");
 801e464:	7823      	ldrb	r3, [r4, #0]
 801e466:	b943      	cbnz	r3, 801e47a <volumeInit+0x66>
    f_close(&MyFileDummy);
 801e468:	4811      	ldr	r0, [pc, #68]	; (801e4b0 <volumeInit+0x9c>)
 801e46a:	f7f9 fb25 	bl	8017ab8 <f_close>
}
 801e46e:	b004      	add	sp, #16
 801e470:	bd10      	pop	{r4, pc}
  SENSING1_PRINTF("Creating STM32.TXT\r\n");
 801e472:	4812      	ldr	r0, [pc, #72]	; (801e4bc <volumeInit+0xa8>)
 801e474:	f009 fe6e 	bl	8028154 <puts>
 801e478:	e7de      	b.n	801e438 <volumeInit+0x24>
    SENSING1_PRINTF("Closing file\r\n");
 801e47a:	4811      	ldr	r0, [pc, #68]	; (801e4c0 <volumeInit+0xac>)
 801e47c:	f009 fe6a 	bl	8028154 <puts>
 801e480:	e7f2      	b.n	801e468 <volumeInit+0x54>
    SENSING1_PRINTF("mkfs error: %d.\r\n", res);
 801e482:	b94b      	cbnz	r3, 801e498 <volumeInit+0x84>
    error();
 801e484:	f7ff faa0 	bl	801d9c8 <error>
      SENSING1_PRINTF("Error writing to file: %d.\r\n", res);
 801e488:	7823      	ldrb	r3, [r4, #0]
 801e48a:	2b00      	cmp	r3, #0
 801e48c:	d0fa      	beq.n	801e484 <volumeInit+0x70>
 801e48e:	4601      	mov	r1, r0
 801e490:	480c      	ldr	r0, [pc, #48]	; (801e4c4 <volumeInit+0xb0>)
 801e492:	f009 fdc3 	bl	802801c <iprintf>
 801e496:	e7f5      	b.n	801e484 <volumeInit+0x70>
    SENSING1_PRINTF("mkfs error: %d.\r\n", res);
 801e498:	480b      	ldr	r0, [pc, #44]	; (801e4c8 <volumeInit+0xb4>)
 801e49a:	f009 fdbf 	bl	802801c <iprintf>
 801e49e:	e7f1      	b.n	801e484 <volumeInit+0x70>
 801e4a0:	20000d84 	.word	0x20000d84
 801e4a4:	2000b5c4 	.word	0x2000b5c4
 801e4a8:	2000b580 	.word	0x2000b580
 801e4ac:	08041f00 	.word	0x08041f00
 801e4b0:	2000d5f8 	.word	0x2000d5f8
 801e4b4:	08041ec0 	.word	0x08041ec0
 801e4b8:	0803985c 	.word	0x0803985c
 801e4bc:	08041eec 	.word	0x08041eec
 801e4c0:	08041f2c 	.word	0x08041f2c
 801e4c4:	08041f0c 	.word	0x08041f0c
 801e4c8:	08041ed8 	.word	0x08041ed8

0801e4cc <DATALOG_SD_Init>:
{
 801e4cc:	b510      	push	{r4, lr}
  if (FATFS_LinkDriver(DiskIO_Driver, SDPath) != 0)
 801e4ce:	4c2f      	ldr	r4, [pc, #188]	; (801e58c <DATALOG_SD_Init+0xc0>)
 801e4d0:	492f      	ldr	r1, [pc, #188]	; (801e590 <DATALOG_SD_Init+0xc4>)
 801e4d2:	68e0      	ldr	r0, [r4, #12]
{
 801e4d4:	b082      	sub	sp, #8
  if (FATFS_LinkDriver(DiskIO_Driver, SDPath) != 0)
 801e4d6:	f7fa f91f 	bl	8018718 <FATFS_LinkDriver>
 801e4da:	2800      	cmp	r0, #0
 801e4dc:	d153      	bne.n	801e586 <DATALOG_SD_Init+0xba>
  if (f_mount(&SDFatFs, (TCHAR const *)SDPath, 0) != FR_OK)
 801e4de:	4602      	mov	r2, r0
 801e4e0:	492b      	ldr	r1, [pc, #172]	; (801e590 <DATALOG_SD_Init+0xc4>)
 801e4e2:	482c      	ldr	r0, [pc, #176]	; (801e594 <DATALOG_SD_Init+0xc8>)
 801e4e4:	f7f8 fecc 	bl	8017280 <f_mount>
 801e4e8:	2800      	cmp	r0, #0
 801e4ea:	d14c      	bne.n	801e586 <DATALOG_SD_Init+0xba>
  if (DiskIO_Driver->disk_initialize(0) != RES_OK)
 801e4ec:	68e3      	ldr	r3, [r4, #12]
 801e4ee:	681b      	ldr	r3, [r3, #0]
 801e4f0:	4798      	blx	r3
 801e4f2:	2800      	cmp	r0, #0
 801e4f4:	d141      	bne.n	801e57a <DATALOG_SD_Init+0xae>
  SENSING1_PRINTF("Attempting to read STM32.TXT...\r\n");
 801e4f6:	4c28      	ldr	r4, [pc, #160]	; (801e598 <DATALOG_SD_Init+0xcc>)
 801e4f8:	7823      	ldrb	r3, [r4, #0]
 801e4fa:	2b00      	cmp	r3, #0
 801e4fc:	d132      	bne.n	801e564 <DATALOG_SD_Init+0x98>
  res = f_open(&MyFileDummy, "STM32.TXT", FA_READ);
 801e4fe:	4927      	ldr	r1, [pc, #156]	; (801e59c <DATALOG_SD_Init+0xd0>)
 801e500:	4827      	ldr	r0, [pc, #156]	; (801e5a0 <DATALOG_SD_Init+0xd4>)
 801e502:	2201      	movs	r2, #1
 801e504:	f7f8 fef4 	bl	80172f0 <f_open>
  if (res != FR_OK)
 801e508:	b188      	cbz	r0, 801e52e <DATALOG_SD_Init+0x62>
    SENSING1_PRINTF("Could not open STM32.TXT\r\n");
 801e50a:	7823      	ldrb	r3, [r4, #0]
 801e50c:	b92b      	cbnz	r3, 801e51a <DATALOG_SD_Init+0x4e>
    volumeInit();
 801e50e:	f7ff ff81 	bl	801e414 <volumeInit>
  SENSING1_PRINTF("FatFs volume ready\r\n");
 801e512:	7823      	ldrb	r3, [r4, #0]
 801e514:	b92b      	cbnz	r3, 801e522 <DATALOG_SD_Init+0x56>
}
 801e516:	b002      	add	sp, #8
 801e518:	bd10      	pop	{r4, pc}
    SENSING1_PRINTF("Could not open STM32.TXT\r\n");
 801e51a:	4822      	ldr	r0, [pc, #136]	; (801e5a4 <DATALOG_SD_Init+0xd8>)
 801e51c:	f009 fe1a 	bl	8028154 <puts>
 801e520:	e7f5      	b.n	801e50e <DATALOG_SD_Init+0x42>
  SENSING1_PRINTF("FatFs volume ready\r\n");
 801e522:	4821      	ldr	r0, [pc, #132]	; (801e5a8 <DATALOG_SD_Init+0xdc>)
}
 801e524:	b002      	add	sp, #8
 801e526:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  SENSING1_PRINTF("FatFs volume ready\r\n");
 801e52a:	f009 be13 	b.w	8028154 <puts>
    memset(rtext, 0, sizeof(rtext));
 801e52e:	4601      	mov	r1, r0
 801e530:	2240      	movs	r2, #64	; 0x40
 801e532:	481e      	ldr	r0, [pc, #120]	; (801e5ac <DATALOG_SD_Init+0xe0>)
 801e534:	f009 f820 	bl	8027578 <memset>
    res = f_read(&MyFileDummy, rtext, sizeof(rtext), (void *)&bytesread);
 801e538:	491c      	ldr	r1, [pc, #112]	; (801e5ac <DATALOG_SD_Init+0xe0>)
 801e53a:	4819      	ldr	r0, [pc, #100]	; (801e5a0 <DATALOG_SD_Init+0xd4>)
 801e53c:	ab01      	add	r3, sp, #4
 801e53e:	2240      	movs	r2, #64	; 0x40
 801e540:	f7f9 f856 	bl	80175f0 <f_read>
    if (res == FR_OK)
 801e544:	b950      	cbnz	r0, 801e55c <DATALOG_SD_Init+0x90>
      if (strcmp(wtext, (char const *)rtext) == 0)
 801e546:	4919      	ldr	r1, [pc, #100]	; (801e5ac <DATALOG_SD_Init+0xe0>)
 801e548:	4819      	ldr	r0, [pc, #100]	; (801e5b0 <DATALOG_SD_Init+0xe4>)
 801e54a:	f7eb ff88 	bl	800a45e <strcmp>
 801e54e:	b918      	cbnz	r0, 801e558 <DATALOG_SD_Init+0x8c>
    f_close(&MyFileDummy);
 801e550:	4813      	ldr	r0, [pc, #76]	; (801e5a0 <DATALOG_SD_Init+0xd4>)
 801e552:	f7f9 fab1 	bl	8017ab8 <f_close>
  return res;
 801e556:	e7dc      	b.n	801e512 <DATALOG_SD_Init+0x46>
        SENSING1_PRINTF("File content error\r\n");
 801e558:	7823      	ldrb	r3, [r4, #0]
 801e55a:	b93b      	cbnz	r3, 801e56c <DATALOG_SD_Init+0xa0>
    f_close(&MyFileDummy);
 801e55c:	4810      	ldr	r0, [pc, #64]	; (801e5a0 <DATALOG_SD_Init+0xd4>)
 801e55e:	f7f9 faab 	bl	8017ab8 <f_close>
 801e562:	e7d4      	b.n	801e50e <DATALOG_SD_Init+0x42>
  SENSING1_PRINTF("Attempting to read STM32.TXT...\r\n");
 801e564:	4813      	ldr	r0, [pc, #76]	; (801e5b4 <DATALOG_SD_Init+0xe8>)
 801e566:	f009 fdf5 	bl	8028154 <puts>
 801e56a:	e7c8      	b.n	801e4fe <DATALOG_SD_Init+0x32>
        SENSING1_PRINTF("File content error\r\n");
 801e56c:	4812      	ldr	r0, [pc, #72]	; (801e5b8 <DATALOG_SD_Init+0xec>)
 801e56e:	f009 fdf1 	bl	8028154 <puts>
    f_close(&MyFileDummy);
 801e572:	480b      	ldr	r0, [pc, #44]	; (801e5a0 <DATALOG_SD_Init+0xd4>)
 801e574:	f7f9 faa0 	bl	8017ab8 <f_close>
  return res;
 801e578:	e7c9      	b.n	801e50e <DATALOG_SD_Init+0x42>
    SENSING1_PRINTF("QSPI disk_initialize error\r\n");
 801e57a:	4b07      	ldr	r3, [pc, #28]	; (801e598 <DATALOG_SD_Init+0xcc>)
 801e57c:	781b      	ldrb	r3, [r3, #0]
 801e57e:	b113      	cbz	r3, 801e586 <DATALOG_SD_Init+0xba>
 801e580:	480e      	ldr	r0, [pc, #56]	; (801e5bc <DATALOG_SD_Init+0xf0>)
 801e582:	f009 fde7 	bl	8028154 <puts>
    error();
 801e586:	f7ff fa1f 	bl	801d9c8 <error>
 801e58a:	bf00      	nop
 801e58c:	20000d60 	.word	0x20000d60
 801e590:	2000b580 	.word	0x2000b580
 801e594:	2000c5c4 	.word	0x2000c5c4
 801e598:	20000d84 	.word	0x20000d84
 801e59c:	08041f00 	.word	0x08041f00
 801e5a0:	2000d5f8 	.word	0x2000d5f8
 801e5a4:	08041f7c 	.word	0x08041f7c
 801e5a8:	08041fac 	.word	0x08041fac
 801e5ac:	2000b584 	.word	0x2000b584
 801e5b0:	0803985c 	.word	0x0803985c
 801e5b4:	08041f58 	.word	0x08041f58
 801e5b8:	08041f98 	.word	0x08041f98
 801e5bc:	08041f3c 	.word	0x08041f3c

0801e5c0 <SD_CardLoggingMemsStart>:
{
 801e5c0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  if(!IsSdMemsRecording) {
 801e5c4:	4c98      	ldr	r4, [pc, #608]	; (801e828 <SD_CardLoggingMemsStart+0x268>)
 801e5c6:	6e25      	ldr	r5, [r4, #96]	; 0x60
 801e5c8:	b325      	cbz	r5, 801e614 <SD_CardLoggingMemsStart+0x54>
    if(W2ST_CHECK_CONNECTION(W2ST_CONNECT_STD_ERR)){
 801e5ca:	4b98      	ldr	r3, [pc, #608]	; (801e82c <SD_CardLoggingMemsStart+0x26c>)
 801e5cc:	681b      	ldr	r3, [r3, #0]
 801e5ce:	065b      	lsls	r3, r3, #25
 801e5d0:	d401      	bmi.n	801e5d6 <SD_CardLoggingMemsStart+0x16>
}
 801e5d2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      BytesToWrite =sprintf((char *)BufferToWrite,"2 Data Log MEMS is already started\n");
 801e5d6:	4d96      	ldr	r5, [pc, #600]	; (801e830 <SD_CardLoggingMemsStart+0x270>)
 801e5d8:	4c96      	ldr	r4, [pc, #600]	; (801e834 <SD_CardLoggingMemsStart+0x274>)
 801e5da:	f105 0620 	add.w	r6, r5, #32
 801e5de:	46ac      	mov	ip, r5
 801e5e0:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 801e5e4:	45b4      	cmp	ip, r6
 801e5e6:	f104 0410 	add.w	r4, r4, #16
 801e5ea:	f105 0510 	add.w	r5, r5, #16
 801e5ee:	f844 0c10 	str.w	r0, [r4, #-16]
 801e5f2:	f844 1c0c 	str.w	r1, [r4, #-12]
 801e5f6:	f844 2c08 	str.w	r2, [r4, #-8]
 801e5fa:	f844 3c04 	str.w	r3, [r4, #-4]
 801e5fe:	d1ee      	bne.n	801e5de <SD_CardLoggingMemsStart+0x1e>
 801e600:	6828      	ldr	r0, [r5, #0]
 801e602:	6020      	str	r0, [r4, #0]
 801e604:	4b8c      	ldr	r3, [pc, #560]	; (801e838 <SD_CardLoggingMemsStart+0x278>)
      Stderr_Update(BufferToWrite,BytesToWrite);
 801e606:	488b      	ldr	r0, [pc, #556]	; (801e834 <SD_CardLoggingMemsStart+0x274>)
      BytesToWrite =sprintf((char *)BufferToWrite,"2 Data Log MEMS is already started\n");
 801e608:	2123      	movs	r1, #35	; 0x23
}
 801e60a:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
      BytesToWrite =sprintf((char *)BufferToWrite,"2 Data Log MEMS is already started\n");
 801e60e:	6019      	str	r1, [r3, #0]
      Stderr_Update(BufferToWrite,BytesToWrite);
 801e610:	f004 bd1e 	b.w	8023050 <Stderr_Update>
 801e614:	4606      	mov	r6, r0
    LedOffTargetPlatform();
 801e616:	f001 f8b9 	bl	801f78c <LedOffTargetPlatform>
  if(DATALOG_SD_LogMems_Enable(SomethingAlreadyRecording,OnlyForAnnotation)) {
 801e61a:	4630      	mov	r0, r6
    openFileMems(IsSdAudioRecording,OnlyForAnnotation);
 801e61c:	f8d4 8064 	ldr.w	r8, [r4, #100]	; 0x64
  if(DATALOG_SD_LogMems_Enable(SomethingAlreadyRecording,OnlyForAnnotation)) {
 801e620:	f7ff fb86 	bl	801dd30 <DATALOG_SD_LogMems_Enable.constprop.0>
 801e624:	4607      	mov	r7, r0
 801e626:	2800      	cmp	r0, #0
 801e628:	d03a      	beq.n	801e6a0 <SD_CardLoggingMemsStart+0xe0>
    SD_LogMems_Enabled=1;
 801e62a:	2301      	movs	r3, #1
 801e62c:	60a3      	str	r3, [r4, #8]
    NoSDFlag =0;
 801e62e:	64a5      	str	r5, [r4, #72]	; 0x48
     osDelay(100);
 801e630:	2064      	movs	r0, #100	; 0x64
 801e632:	f7fa f947 	bl	80188c4 <osDelay>
    if(SD_LogMems_Enabled) {
 801e636:	68a3      	ldr	r3, [r4, #8]
 801e638:	b1cb      	cbz	r3, 801e66e <SD_CardLoggingMemsStart+0xae>
      IsSdMemsRecording= 1;
 801e63a:	2301      	movs	r3, #1
 801e63c:	6623      	str	r3, [r4, #96]	; 0x60
      if(OnlyForAnnotation==0) {
 801e63e:	2e00      	cmp	r6, #0
 801e640:	d1c7      	bne.n	801e5d2 <SD_CardLoggingMemsStart+0x12>
        startProc(SD_CARD_LOGGING,RoundedInertialWakeUpTimer);
 801e642:	4f7e      	ldr	r7, [pc, #504]	; (801e83c <SD_CardLoggingMemsStart+0x27c>)
 801e644:	2011      	movs	r0, #17
 801e646:	6939      	ldr	r1, [r7, #16]
 801e648:	f003 f944 	bl	80218d4 <startProc>
        if(W2ST_CHECK_CONNECTION(W2ST_CONNECT_STD_TERM)) {
 801e64c:	4b77      	ldr	r3, [pc, #476]	; (801e82c <SD_CardLoggingMemsStart+0x26c>)
 801e64e:	681b      	ldr	r3, [r3, #0]
 801e650:	069e      	lsls	r6, r3, #26
 801e652:	d469      	bmi.n	801e728 <SD_CardLoggingMemsStart+0x168>
        PowerCtrlLock();
 801e654:	f000 fdd8 	bl	801f208 <PowerCtrlLock>
            (SD_Card_FeaturesMask & FEATURE_MASK_GRYO) ||
 801e658:	6863      	ldr	r3, [r4, #4]
        if( (SD_Card_FeaturesMask & FEATURE_MASK_ACC)  ||
 801e65a:	f413 0f60 	tst.w	r3, #14680064	; 0xe00000
 801e65e:	d13f      	bne.n	801e6e0 <SD_CardLoggingMemsStart+0x120>
        if( (SD_Card_FeaturesMask & FEATURE_MASK_PRESS) ||
 801e660:	f413 1fe8 	tst.w	r3, #1900544	; 0x1d0000
 801e664:	d0b5      	beq.n	801e5d2 <SD_CardLoggingMemsStart+0x12>
}
 801e666:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
            EnableEnvSensors ();
 801e66a:	f000 be9d 	b.w	801f3a8 <EnableEnvSensors>
      if(W2ST_CHECK_CONNECTION(W2ST_CONNECT_STD_ERR)){
 801e66e:	4b6f      	ldr	r3, [pc, #444]	; (801e82c <SD_CardLoggingMemsStart+0x26c>)
 801e670:	681b      	ldr	r3, [r3, #0]
 801e672:	065a      	lsls	r2, r3, #25
 801e674:	d5ad      	bpl.n	801e5d2 <SD_CardLoggingMemsStart+0x12>
        BytesToWrite =sprintf((char *)BufferToWrite,"1 SD Card not present\n");
 801e676:	4c72      	ldr	r4, [pc, #456]	; (801e840 <SD_CardLoggingMemsStart+0x280>)
 801e678:	4d6e      	ldr	r5, [pc, #440]	; (801e834 <SD_CardLoggingMemsStart+0x274>)
 801e67a:	4e6f      	ldr	r6, [pc, #444]	; (801e838 <SD_CardLoggingMemsStart+0x278>)
 801e67c:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 801e67e:	6069      	str	r1, [r5, #4]
 801e680:	88a1      	ldrh	r1, [r4, #4]
 801e682:	6028      	str	r0, [r5, #0]
 801e684:	82a9      	strh	r1, [r5, #20]
 801e686:	6820      	ldr	r0, [r4, #0]
 801e688:	79a1      	ldrb	r1, [r4, #6]
 801e68a:	6128      	str	r0, [r5, #16]
 801e68c:	75a9      	strb	r1, [r5, #22]
 801e68e:	60aa      	str	r2, [r5, #8]
 801e690:	60eb      	str	r3, [r5, #12]
 801e692:	2116      	movs	r1, #22
        Stderr_Update(BufferToWrite,BytesToWrite);
 801e694:	4628      	mov	r0, r5
        BytesToWrite =sprintf((char *)BufferToWrite,"1 SD Card not present\n");
 801e696:	6031      	str	r1, [r6, #0]
}
 801e698:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
        Stderr_Update(BufferToWrite,BytesToWrite);
 801e69c:	f004 bcd8 	b.w	8023050 <Stderr_Update>
  if(SD_LogMems_Enabled) {
 801e6a0:	68a3      	ldr	r3, [r4, #8]
 801e6a2:	b9ab      	cbnz	r3, 801e6d0 <SD_CardLoggingMemsStart+0x110>
  if(SomethingAlreadyRecording==0) {
 801e6a4:	f1b8 0f00 	cmp.w	r8, #0
 801e6a8:	d1c2      	bne.n	801e630 <SD_CardLoggingMemsStart+0x70>
    NoSDFlag =0;
 801e6aa:	f8c4 8048 	str.w	r8, [r4, #72]	; 0x48
    LedOffTargetPlatform();
 801e6ae:	f001 f86d 	bl	801f78c <LedOffTargetPlatform>
    if((SomethingAlreadyRecording==0) & (NoSDFlag==0)){
 801e6b2:	6ca3      	ldr	r3, [r4, #72]	; 0x48
 801e6b4:	2b00      	cmp	r3, #0
 801e6b6:	d1bb      	bne.n	801e630 <SD_CardLoggingMemsStart+0x70>
      if(W2ST_CHECK_CONNECTION(W2ST_CONNECT_SD_CARD_LOGGING)) {
 801e6b8:	4b5c      	ldr	r3, [pc, #368]	; (801e82c <SD_CardLoggingMemsStart+0x26c>)
 801e6ba:	681b      	ldr	r3, [r3, #0]
 801e6bc:	055f      	lsls	r7, r3, #21
 801e6be:	d449      	bmi.n	801e754 <SD_CardLoggingMemsStart+0x194>
      NoSDFlag = 1;
 801e6c0:	2301      	movs	r3, #1
  FATFS_UnLinkDriver(SDPath);
 801e6c2:	4860      	ldr	r0, [pc, #384]	; (801e844 <SD_CardLoggingMemsStart+0x284>)
      NoSDFlag = 1;
 801e6c4:	64a3      	str	r3, [r4, #72]	; 0x48
  FATFS_UnLinkDriver(SDPath);
 801e6c6:	f7fa f84b 	bl	8018760 <FATFS_UnLinkDriver>
      DATALOG_SD_Init();
 801e6ca:	f7ff feff 	bl	801e4cc <DATALOG_SD_Init>
 801e6ce:	e7af      	b.n	801e630 <SD_CardLoggingMemsStart+0x70>
    f_close(&MyFileMems);
 801e6d0:	485d      	ldr	r0, [pc, #372]	; (801e848 <SD_CardLoggingMemsStart+0x288>)
 801e6d2:	f7f9 f9f1 	bl	8017ab8 <f_close>
    SD_LogMems_Enabled =0;
 801e6d6:	60a7      	str	r7, [r4, #8]
  if(SomethingAlreadyRecording==0) {
 801e6d8:	f1b8 0f00 	cmp.w	r8, #0
 801e6dc:	d1a8      	bne.n	801e630 <SD_CardLoggingMemsStart+0x70>
 801e6de:	e7e4      	b.n	801e6aa <SD_CardLoggingMemsStart+0xea>
          EnableMotionSensors ();
 801e6e0:	f000 fdda 	bl	801f298 <EnableMotionSensors>
          if(SD_Card_FeaturesMask & FEATURE_MASK_ACC) {
 801e6e4:	6863      	ldr	r3, [r4, #4]
 801e6e6:	021d      	lsls	r5, r3, #8
 801e6e8:	d452      	bmi.n	801e790 <SD_CardLoggingMemsStart+0x1d0>
          if(SD_Card_FeaturesMask & FEATURE_MASK_GRYO) {
 801e6ea:	0258      	lsls	r0, r3, #9
 801e6ec:	d436      	bmi.n	801e75c <SD_CardLoggingMemsStart+0x19c>
          if(SD_Card_FeaturesMask & FEATURE_MASK_MAG) {
 801e6ee:	0299      	lsls	r1, r3, #10
 801e6f0:	d5b6      	bpl.n	801e660 <SD_CardLoggingMemsStart+0xa0>
            MOTION_SENSOR_GetOutputDataRate(TargetBoardFeatures.HandleMagSensor, MOTION_MAGNETO,&TargetBoardFeatures.DefaultMagODR);
 801e6f2:	4d56      	ldr	r5, [pc, #344]	; (801e84c <SD_CardLoggingMemsStart+0x28c>)
 801e6f4:	2104      	movs	r1, #4
 801e6f6:	6a28      	ldr	r0, [r5, #32]
 801e6f8:	f105 022c 	add.w	r2, r5, #44	; 0x2c
 801e6fc:	f7ee f9ac 	bl	800ca58 <BSP_MOTION_SENSOR_GetOutputDataRate>
            if(SampleRateIneFeatures <= 130) {
 801e700:	88bb      	ldrh	r3, [r7, #4]
 801e702:	2b82      	cmp	r3, #130	; 0x82
 801e704:	d968      	bls.n	801e7d8 <SD_CardLoggingMemsStart+0x218>
            } else if (SampleRateIneFeatures <= 260) {
 801e706:	f5b3 7f82 	cmp.w	r3, #260	; 0x104
 801e70a:	f240 8085 	bls.w	801e818 <SD_CardLoggingMemsStart+0x258>
            } else if (SampleRateIneFeatures <= 520) {
 801e70e:	f5b3 7f02 	cmp.w	r3, #520	; 0x208
              MOTION_SENSOR_SetOutputDataRate(TargetBoardFeatures.HandleMagSensor, MOTION_MAGNETO,50.0f);
 801e712:	bf94      	ite	ls
 801e714:	ed9f 0a4e 	vldrls	s0, [pc, #312]	; 801e850 <SD_CardLoggingMemsStart+0x290>
              MOTION_SENSOR_SetOutputDataRate(TargetBoardFeatures.HandleMagSensor, MOTION_MAGNETO,100.0f);
 801e718:	ed9f 0a4e 	vldrhi	s0, [pc, #312]	; 801e854 <SD_CardLoggingMemsStart+0x294>
 801e71c:	6a28      	ldr	r0, [r5, #32]
 801e71e:	2104      	movs	r1, #4
 801e720:	f7ee f9d0 	bl	800cac4 <BSP_MOTION_SENSOR_SetOutputDataRate>
            (SD_Card_FeaturesMask & FEATURE_MASK_TEMP1) ||
 801e724:	6863      	ldr	r3, [r4, #4]
 801e726:	e79b      	b.n	801e660 <SD_CardLoggingMemsStart+0xa0>
          BytesToWrite =sprintf((char *)BufferToWrite,"Start Data Log MEMS Rec\n");
 801e728:	4b43      	ldr	r3, [pc, #268]	; (801e838 <SD_CardLoggingMemsStart+0x278>)
 801e72a:	4d4b      	ldr	r5, [pc, #300]	; (801e858 <SD_CardLoggingMemsStart+0x298>)
 801e72c:	4e41      	ldr	r6, [pc, #260]	; (801e834 <SD_CardLoggingMemsStart+0x274>)
 801e72e:	f04f 0c18 	mov.w	ip, #24
 801e732:	f8c3 c000 	str.w	ip, [r3]
 801e736:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 801e738:	6030      	str	r0, [r6, #0]
 801e73a:	6071      	str	r1, [r6, #4]
 801e73c:	cd03      	ldmia	r5!, {r0, r1}
 801e73e:	60f3      	str	r3, [r6, #12]
 801e740:	782b      	ldrb	r3, [r5, #0]
 801e742:	6130      	str	r0, [r6, #16]
 801e744:	6171      	str	r1, [r6, #20]
 801e746:	60b2      	str	r2, [r6, #8]
          Term_Update(BufferToWrite,BytesToWrite);
 801e748:	4661      	mov	r1, ip
          BytesToWrite =sprintf((char *)BufferToWrite,"Start Data Log MEMS Rec\n");
 801e74a:	7633      	strb	r3, [r6, #24]
          Term_Update(BufferToWrite,BytesToWrite);
 801e74c:	4630      	mov	r0, r6
 801e74e:	f004 fcaf 	bl	80230b0 <Term_Update>
 801e752:	e77f      	b.n	801e654 <SD_CardLoggingMemsStart+0x94>
        SDLog_Update(SD_CARD_LOGGING_NO_SD);
 801e754:	2002      	movs	r0, #2
 801e756:	f005 f97d 	bl	8023a54 <SDLog_Update>
 801e75a:	e7b1      	b.n	801e6c0 <SD_CardLoggingMemsStart+0x100>
            MOTION_SENSOR_GetOutputDataRate(TargetBoardFeatures.HandleGyroSensor, MOTION_GYRO,&TargetBoardFeatures.DefaultGyroODR);
 801e75c:	4d3b      	ldr	r5, [pc, #236]	; (801e84c <SD_CardLoggingMemsStart+0x28c>)
 801e75e:	2101      	movs	r1, #1
 801e760:	69e8      	ldr	r0, [r5, #28]
 801e762:	f105 0228 	add.w	r2, r5, #40	; 0x28
 801e766:	f7ee f977 	bl	800ca58 <BSP_MOTION_SENSOR_GetOutputDataRate>
            if(SampleRateIneFeatures <= 130) {
 801e76a:	88bb      	ldrh	r3, [r7, #4]
 801e76c:	2b82      	cmp	r3, #130	; 0x82
 801e76e:	d92b      	bls.n	801e7c8 <SD_CardLoggingMemsStart+0x208>
            } else if (SampleRateIneFeatures <= 260) {
 801e770:	f5b3 7f82 	cmp.w	r3, #260	; 0x104
 801e774:	d948      	bls.n	801e808 <SD_CardLoggingMemsStart+0x248>
            } else if (SampleRateIneFeatures <= 520) {
 801e776:	f5b3 7f02 	cmp.w	r3, #520	; 0x208
              MOTION_SENSOR_SetOutputDataRate(TargetBoardFeatures.HandleGyroSensor, MOTION_GYRO,52.0f);
 801e77a:	bf94      	ite	ls
 801e77c:	ed9f 0a37 	vldrls	s0, [pc, #220]	; 801e85c <SD_CardLoggingMemsStart+0x29c>
              MOTION_SENSOR_SetOutputDataRate(TargetBoardFeatures.HandleGyroSensor, MOTION_GYRO,104.0f);
 801e780:	ed9f 0a37 	vldrhi	s0, [pc, #220]	; 801e860 <SD_CardLoggingMemsStart+0x2a0>
 801e784:	69e8      	ldr	r0, [r5, #28]
 801e786:	2101      	movs	r1, #1
 801e788:	f7ee f99c 	bl	800cac4 <BSP_MOTION_SENSOR_SetOutputDataRate>
          if(SD_Card_FeaturesMask & FEATURE_MASK_MAG) {
 801e78c:	6863      	ldr	r3, [r4, #4]
 801e78e:	e7ae      	b.n	801e6ee <SD_CardLoggingMemsStart+0x12e>
            MOTION_SENSOR_GetOutputDataRate(TargetBoardFeatures.HandleAccSensor, MOTION_ACCELERO,&TargetBoardFeatures.DefaultAccODR);
 801e790:	4d2e      	ldr	r5, [pc, #184]	; (801e84c <SD_CardLoggingMemsStart+0x28c>)
            Set2GAccelerometerFullScale();
 801e792:	f003 fae1 	bl	8021d58 <Set2GAccelerometerFullScale>
            MOTION_SENSOR_GetOutputDataRate(TargetBoardFeatures.HandleAccSensor, MOTION_ACCELERO,&TargetBoardFeatures.DefaultAccODR);
 801e796:	69a8      	ldr	r0, [r5, #24]
 801e798:	f105 0224 	add.w	r2, r5, #36	; 0x24
 801e79c:	2102      	movs	r1, #2
 801e79e:	f7ee f95b 	bl	800ca58 <BSP_MOTION_SENSOR_GetOutputDataRate>
            if(SampleRateIneFeatures <= 130) {
 801e7a2:	88bb      	ldrh	r3, [r7, #4]
 801e7a4:	2b82      	cmp	r3, #130	; 0x82
 801e7a6:	d91f      	bls.n	801e7e8 <SD_CardLoggingMemsStart+0x228>
            } else if (SampleRateIneFeatures <= 260) {
 801e7a8:	f5b3 7f82 	cmp.w	r3, #260	; 0x104
 801e7ac:	d924      	bls.n	801e7f8 <SD_CardLoggingMemsStart+0x238>
            } else if (SampleRateIneFeatures <= 520) {
 801e7ae:	f5b3 7f02 	cmp.w	r3, #520	; 0x208
              MOTION_SENSOR_SetOutputDataRate(TargetBoardFeatures.HandleAccSensor, MOTION_ACCELERO,52.0f);
 801e7b2:	bf94      	ite	ls
 801e7b4:	ed9f 0a29 	vldrls	s0, [pc, #164]	; 801e85c <SD_CardLoggingMemsStart+0x29c>
              MOTION_SENSOR_SetOutputDataRate(TargetBoardFeatures.HandleAccSensor, MOTION_ACCELERO,104.0f);
 801e7b8:	ed9f 0a29 	vldrhi	s0, [pc, #164]	; 801e860 <SD_CardLoggingMemsStart+0x2a0>
 801e7bc:	69a8      	ldr	r0, [r5, #24]
 801e7be:	2102      	movs	r1, #2
 801e7c0:	f7ee f980 	bl	800cac4 <BSP_MOTION_SENSOR_SetOutputDataRate>
          if(SD_Card_FeaturesMask & FEATURE_MASK_GRYO) {
 801e7c4:	6863      	ldr	r3, [r4, #4]
 801e7c6:	e790      	b.n	801e6ea <SD_CardLoggingMemsStart+0x12a>
              MOTION_SENSOR_SetOutputDataRate(TargetBoardFeatures.HandleGyroSensor, MOTION_GYRO,13.0f);
 801e7c8:	69e8      	ldr	r0, [r5, #28]
 801e7ca:	eeb2 0a0a 	vmov.f32	s0, #42	; 0x41500000  13.0
 801e7ce:	2101      	movs	r1, #1
 801e7d0:	f7ee f978 	bl	800cac4 <BSP_MOTION_SENSOR_SetOutputDataRate>
          if(SD_Card_FeaturesMask & FEATURE_MASK_MAG) {
 801e7d4:	6863      	ldr	r3, [r4, #4]
 801e7d6:	e78a      	b.n	801e6ee <SD_CardLoggingMemsStart+0x12e>
              MOTION_SENSOR_SetOutputDataRate(TargetBoardFeatures.HandleMagSensor, MOTION_MAGNETO,10.0f);
 801e7d8:	6a28      	ldr	r0, [r5, #32]
 801e7da:	eeb2 0a04 	vmov.f32	s0, #36	; 0x41200000  10.0
 801e7de:	2104      	movs	r1, #4
 801e7e0:	f7ee f970 	bl	800cac4 <BSP_MOTION_SENSOR_SetOutputDataRate>
            (SD_Card_FeaturesMask & FEATURE_MASK_TEMP1) ||
 801e7e4:	6863      	ldr	r3, [r4, #4]
 801e7e6:	e73b      	b.n	801e660 <SD_CardLoggingMemsStart+0xa0>
              MOTION_SENSOR_SetOutputDataRate(TargetBoardFeatures.HandleAccSensor, MOTION_ACCELERO,13.0f);
 801e7e8:	69a8      	ldr	r0, [r5, #24]
 801e7ea:	eeb2 0a0a 	vmov.f32	s0, #42	; 0x41500000  13.0
 801e7ee:	2102      	movs	r1, #2
 801e7f0:	f7ee f968 	bl	800cac4 <BSP_MOTION_SENSOR_SetOutputDataRate>
          if(SD_Card_FeaturesMask & FEATURE_MASK_GRYO) {
 801e7f4:	6863      	ldr	r3, [r4, #4]
 801e7f6:	e778      	b.n	801e6ea <SD_CardLoggingMemsStart+0x12a>
              MOTION_SENSOR_SetOutputDataRate(TargetBoardFeatures.HandleAccSensor, MOTION_ACCELERO,26.0f);
 801e7f8:	69a8      	ldr	r0, [r5, #24]
 801e7fa:	eeb3 0a0a 	vmov.f32	s0, #58	; 0x41d00000  26.0
 801e7fe:	2102      	movs	r1, #2
 801e800:	f7ee f960 	bl	800cac4 <BSP_MOTION_SENSOR_SetOutputDataRate>
          if(SD_Card_FeaturesMask & FEATURE_MASK_GRYO) {
 801e804:	6863      	ldr	r3, [r4, #4]
 801e806:	e770      	b.n	801e6ea <SD_CardLoggingMemsStart+0x12a>
              MOTION_SENSOR_SetOutputDataRate(TargetBoardFeatures.HandleGyroSensor, MOTION_GYRO,26.0f);
 801e808:	69e8      	ldr	r0, [r5, #28]
 801e80a:	eeb3 0a0a 	vmov.f32	s0, #58	; 0x41d00000  26.0
 801e80e:	2101      	movs	r1, #1
 801e810:	f7ee f958 	bl	800cac4 <BSP_MOTION_SENSOR_SetOutputDataRate>
          if(SD_Card_FeaturesMask & FEATURE_MASK_MAG) {
 801e814:	6863      	ldr	r3, [r4, #4]
 801e816:	e76a      	b.n	801e6ee <SD_CardLoggingMemsStart+0x12e>
              MOTION_SENSOR_SetOutputDataRate(TargetBoardFeatures.HandleMagSensor, MOTION_MAGNETO,20.0f);
 801e818:	6a28      	ldr	r0, [r5, #32]
 801e81a:	eeb3 0a04 	vmov.f32	s0, #52	; 0x41a00000  20.0
 801e81e:	2104      	movs	r1, #4
 801e820:	f7ee f950 	bl	800cac4 <BSP_MOTION_SENSOR_SetOutputDataRate>
            (SD_Card_FeaturesMask & FEATURE_MASK_TEMP1) ||
 801e824:	6863      	ldr	r3, [r4, #4]
 801e826:	e71b      	b.n	801e660 <SD_CardLoggingMemsStart+0xa0>
 801e828:	2000b518 	.word	0x2000b518
 801e82c:	2001457c 	.word	0x2001457c
 801e830:	08041ff4 	.word	0x08041ff4
 801e834:	200133dc 	.word	0x200133dc
 801e838:	200134dc 	.word	0x200134dc
 801e83c:	20000d60 	.word	0x20000d60
 801e840:	08041fdc 	.word	0x08041fdc
 801e844:	2000b580 	.word	0x2000b580
 801e848:	2000f658 	.word	0x2000f658
 801e84c:	200106a4 	.word	0x200106a4
 801e850:	42480000 	.word	0x42480000
 801e854:	42c80000 	.word	0x42c80000
 801e858:	08041fc0 	.word	0x08041fc0
 801e85c:	42500000 	.word	0x42500000
 801e860:	42d00000 	.word	0x42d00000

0801e864 <SdCardMemsRecordingRun>:
{
 801e864:	b510      	push	{r4, lr}
  if(!IsSdMemsRecording) {
 801e866:	4c0b      	ldr	r4, [pc, #44]	; (801e894 <SdCardMemsRecordingRun+0x30>)
 801e868:	6e23      	ldr	r3, [r4, #96]	; 0x60
 801e86a:	b13b      	cbz	r3, 801e87c <SdCardMemsRecordingRun+0x18>
     SD_CardLoggingMemsData();
 801e86c:	f7ff f8bc 	bl	801d9e8 <SD_CardLoggingMemsData>
  LedInitTargetPlatform();
 801e870:	f000 ff90 	bl	801f794 <LedInitTargetPlatform>
}
 801e874:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  LedOffTargetPlatform();
 801e878:	f000 bf88 	b.w	801f78c <LedOffTargetPlatform>
    SD_CardLoggingMemsStart(OnlyForAnnotation);
 801e87c:	f7ff fea0 	bl	801e5c0 <SD_CardLoggingMemsStart>
  if(IsSdMemsRecording) {
 801e880:	6e23      	ldr	r3, [r4, #96]	; 0x60
 801e882:	2b00      	cmp	r3, #0
 801e884:	d1f2      	bne.n	801e86c <SdCardMemsRecordingRun+0x8>
  LedInitTargetPlatform();
 801e886:	f000 ff85 	bl	801f794 <LedInitTargetPlatform>
}
 801e88a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  LedOffTargetPlatform();
 801e88e:	f000 bf7d 	b.w	801f78c <LedOffTargetPlatform>
 801e892:	bf00      	nop
 801e894:	2000b518 	.word	0x2000b518

0801e898 <SD_CardLoggingAudioStart>:
{
 801e898:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  if(!IsSdAudioRecording) {
 801e89c:	4c83      	ldr	r4, [pc, #524]	; (801eaac <SD_CardLoggingAudioStart+0x214>)
 801e89e:	6e65      	ldr	r5, [r4, #100]	; 0x64
{
 801e8a0:	b098      	sub	sp, #96	; 0x60
  if(!IsSdAudioRecording) {
 801e8a2:	b33d      	cbz	r5, 801e8f4 <SD_CardLoggingAudioStart+0x5c>
    if(W2ST_CHECK_CONNECTION(W2ST_CONNECT_STD_ERR)){
 801e8a4:	4b82      	ldr	r3, [pc, #520]	; (801eab0 <SD_CardLoggingAudioStart+0x218>)
 801e8a6:	681b      	ldr	r3, [r3, #0]
 801e8a8:	065b      	lsls	r3, r3, #25
 801e8aa:	d402      	bmi.n	801e8b2 <SD_CardLoggingAudioStart+0x1a>
}
 801e8ac:	b018      	add	sp, #96	; 0x60
 801e8ae:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
      BytesToWrite =sprintf((char *)BufferToWrite,"4 Data Log Audio is already started\n");
 801e8b2:	4e80      	ldr	r6, [pc, #512]	; (801eab4 <SD_CardLoggingAudioStart+0x21c>)
 801e8b4:	4d80      	ldr	r5, [pc, #512]	; (801eab8 <SD_CardLoggingAudioStart+0x220>)
 801e8b6:	f106 0720 	add.w	r7, r6, #32
 801e8ba:	4634      	mov	r4, r6
 801e8bc:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 801e8be:	42bc      	cmp	r4, r7
 801e8c0:	f105 0510 	add.w	r5, r5, #16
 801e8c4:	f106 0610 	add.w	r6, r6, #16
 801e8c8:	f845 0c10 	str.w	r0, [r5, #-16]
 801e8cc:	f845 1c0c 	str.w	r1, [r5, #-12]
 801e8d0:	f845 2c08 	str.w	r2, [r5, #-8]
 801e8d4:	f845 3c04 	str.w	r3, [r5, #-4]
 801e8d8:	d1ef      	bne.n	801e8ba <SD_CardLoggingAudioStart+0x22>
 801e8da:	6830      	ldr	r0, [r6, #0]
 801e8dc:	4b77      	ldr	r3, [pc, #476]	; (801eabc <SD_CardLoggingAudioStart+0x224>)
 801e8de:	6028      	str	r0, [r5, #0]
 801e8e0:	7932      	ldrb	r2, [r6, #4]
      Stderr_Update(BufferToWrite,BytesToWrite);
 801e8e2:	4875      	ldr	r0, [pc, #468]	; (801eab8 <SD_CardLoggingAudioStart+0x220>)
      BytesToWrite =sprintf((char *)BufferToWrite,"4 Data Log Audio is already started\n");
 801e8e4:	712a      	strb	r2, [r5, #4]
 801e8e6:	2124      	movs	r1, #36	; 0x24
 801e8e8:	6019      	str	r1, [r3, #0]
}
 801e8ea:	b018      	add	sp, #96	; 0x60
 801e8ec:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
      Stderr_Update(BufferToWrite,BytesToWrite);
 801e8f0:	f004 bbae 	b.w	8023050 <Stderr_Update>
    LedOffTargetPlatform();
 801e8f4:	f000 ff4a 	bl	801f78c <LedOffTargetPlatform>
  Audio_OUT_Buff  = (uint16_t * )pvPortMalloc(sizeof( uint16_t ) * AUDIO_BUFF_LEN);
 801e8f8:	f44f 5080 	mov.w	r0, #4096	; 0x1000
    openFileAudio(IsSdMemsRecording);
 801e8fc:	f8d4 a060 	ldr.w	sl, [r4, #96]	; 0x60
  Audio_OUT_Buff  = (uint16_t * )pvPortMalloc(sizeof( uint16_t ) * AUDIO_BUFF_LEN);
 801e900:	f7fa fa52 	bl	8018da8 <pvPortMalloc>
 801e904:	6520      	str	r0, [r4, #80]	; 0x50
  if (Audio_OUT_Buff == NULL) {
 801e906:	2800      	cmp	r0, #0
 801e908:	f000 80c7 	beq.w	801ea9a <SD_CardLoggingAudioStart+0x202>
  pAudioHeader[8]  = 'W';
 801e90c:	4a6c      	ldr	r2, [pc, #432]	; (801eac0 <SD_CardLoggingAudioStart+0x228>)
 801e90e:	6262      	str	r2, [r4, #36]	; 0x24
  pAudioHeader[32]  = BlockAlign;
 801e910:	4a6c      	ldr	r2, [pc, #432]	; (801eac4 <SD_CardLoggingAudioStart+0x22c>)
  pAudioHeader[4] = 0x00;
 801e912:	4b6d      	ldr	r3, [pc, #436]	; (801eac8 <SD_CardLoggingAudioStart+0x230>)
  pAudioHeader[0] = 'R';
 801e914:	496d      	ldr	r1, [pc, #436]	; (801eacc <SD_CardLoggingAudioStart+0x234>)
  pAudioHeader[32]  = BlockAlign;
 801e916:	63e2      	str	r2, [r4, #60]	; 0x3c
  pAudioHeader[36]  = 'd';
 801e918:	4a6d      	ldr	r2, [pc, #436]	; (801ead0 <SD_CardLoggingAudioStart+0x238>)
  NbAudioSamplesCounter = 0;
 801e91a:	6565      	str	r5, [r4, #84]	; 0x54
  pAudioHeader[4] = 0x00;
 801e91c:	e9c4 1307 	strd	r1, r3, [r4, #28]
  pAudioHeader[40]  = 0x00;
 801e920:	e9c4 2310 	strd	r2, r3, [r4, #64]	; 0x40
  pAudioHeader[24]  = (uint8_t)((SampleRate & 0xFF));
 801e924:	f04f 1201 	mov.w	r2, #65537	; 0x10001
 801e928:	f44f 537a 	mov.w	r3, #16000	; 0x3e80
 801e92c:	e9c4 230c 	strd	r2, r3, [r4, #48]	; 0x30
  pAudioHeader[12]  = 'f';
 801e930:	4968      	ldr	r1, [pc, #416]	; (801ead4 <SD_CardLoggingAudioStart+0x23c>)
 801e932:	62a1      	str	r1, [r4, #40]	; 0x28
  pAudioHeader[28]  = (uint8_t)(( ByteRate & 0xFF));
 801e934:	f44f 43fa 	mov.w	r3, #32000	; 0x7d00
  pAudioHeader[16]  = 0x10;
 801e938:	2010      	movs	r0, #16
  pAudioHeader[28]  = (uint8_t)(( ByteRate & 0xFF));
 801e93a:	63a3      	str	r3, [r4, #56]	; 0x38
  pAudioHeader[16]  = 0x10;
 801e93c:	62e0      	str	r0, [r4, #44]	; 0x2c
  RTC_GetCurrentDateTime();
 801e93e:	f004 f829 	bl	8022994 <RTC_GetCurrentDateTime>
                     CurrentDate.Date,
 801e942:	4b65      	ldr	r3, [pc, #404]	; (801ead8 <SD_CardLoggingAudioStart+0x240>)
  sprintf(FileName, "%s-Audio_%02d_%s_%02d_%02dh_%02dm_%02ds.wav",
 801e944:	4865      	ldr	r0, [pc, #404]	; (801eadc <SD_CardLoggingAudioStart+0x244>)
                     MonthName[CurrentDate.Month-1],
 801e946:	7859      	ldrb	r1, [r3, #1]
                     CurrentTime.Seconds);
 801e948:	4a65      	ldr	r2, [pc, #404]	; (801eae0 <SD_CardLoggingAudioStart+0x248>)
 801e94a:	4f59      	ldr	r7, [pc, #356]	; (801eab0 <SD_CardLoggingAudioStart+0x218>)
  sprintf(FileName, "%s-Audio_%02d_%s_%02d_%02dh_%02dm_%02ds.wav",
 801e94c:	3901      	subs	r1, #1
 801e94e:	f850 1021 	ldr.w	r1, [r0, r1, lsl #2]
 801e952:	9100      	str	r1, [sp, #0]
 801e954:	7891      	ldrb	r1, [r2, #2]
 801e956:	9104      	str	r1, [sp, #16]
 801e958:	7851      	ldrb	r1, [r2, #1]
 801e95a:	9103      	str	r1, [sp, #12]
 801e95c:	7812      	ldrb	r2, [r2, #0]
 801e95e:	9202      	str	r2, [sp, #8]
 801e960:	78da      	ldrb	r2, [r3, #3]
 801e962:	4960      	ldr	r1, [pc, #384]	; (801eae4 <SD_CardLoggingAudioStart+0x24c>)
 801e964:	789b      	ldrb	r3, [r3, #2]
 801e966:	9201      	str	r2, [sp, #4]
 801e968:	a808      	add	r0, sp, #32
 801e96a:	f104 020c 	add.w	r2, r4, #12
 801e96e:	f009 fc09 	bl	8028184 <siprintf>
  while(SD_LogAudio_Enabled==0) {
 801e972:	69a5      	ldr	r5, [r4, #24]
 801e974:	b9cd      	cbnz	r5, 801e9aa <SD_CardLoggingAudioStart+0x112>
    if(f_open(&MyFileAudio, (char const*)AudioDataFileName, FA_CREATE_ALWAYS | FA_WRITE) != FR_OK) {
 801e976:	4e5c      	ldr	r6, [pc, #368]	; (801eae8 <SD_CardLoggingAudioStart+0x250>)
        BytesToWrite =sprintf((char *)BufferToWrite, "FileName=%s\n",AudioDataFileName);
 801e978:	f8df 9188 	ldr.w	r9, [pc, #392]	; 801eb04 <SD_CardLoggingAudioStart+0x26c>
 801e97c:	f8df 8138 	ldr.w	r8, [pc, #312]	; 801eab8 <SD_CardLoggingAudioStart+0x220>
 801e980:	e006      	b.n	801e990 <SD_CardLoggingAudioStart+0xf8>
      if(SDCardFileCount > MAX_TRIALS_OPENS_SD) {
 801e982:	2d0a      	cmp	r5, #10
 801e984:	d87e      	bhi.n	801ea84 <SD_CardLoggingAudioStart+0x1ec>
      osDelay(100);
 801e986:	2064      	movs	r0, #100	; 0x64
 801e988:	f7f9 ff9c 	bl	80188c4 <osDelay>
  while(SD_LogAudio_Enabled==0) {
 801e98c:	69a3      	ldr	r3, [r4, #24]
 801e98e:	b963      	cbnz	r3, 801e9aa <SD_CardLoggingAudioStart+0x112>
    if(f_open(&MyFileAudio, (char const*)AudioDataFileName, FA_CREATE_ALWAYS | FA_WRITE) != FR_OK) {
 801e990:	220a      	movs	r2, #10
 801e992:	a908      	add	r1, sp, #32
 801e994:	4630      	mov	r0, r6
 801e996:	f7f8 fcab 	bl	80172f0 <f_open>
    SDCardFileCount++;
 801e99a:	3501      	adds	r5, #1
    if(f_open(&MyFileAudio, (char const*)AudioDataFileName, FA_CREATE_ALWAYS | FA_WRITE) != FR_OK) {
 801e99c:	2800      	cmp	r0, #0
 801e99e:	d1f0      	bne.n	801e982 <SD_CardLoggingAudioStart+0xea>
      SD_LogAudio_Enabled =1;
 801e9a0:	2301      	movs	r3, #1
 801e9a2:	61a3      	str	r3, [r4, #24]
      if(W2ST_CHECK_CONNECTION(W2ST_CONNECT_STD_TERM)) {
 801e9a4:	683b      	ldr	r3, [r7, #0]
 801e9a6:	069b      	lsls	r3, r3, #26
 801e9a8:	d440      	bmi.n	801ea2c <SD_CardLoggingAudioStart+0x194>
  if(f_write(&MyFileAudio, (uint8_t*) pAudioHeader, sizeof(pAudioHeader), (void *)&byteswritten) != FR_OK) {
 801e9aa:	4950      	ldr	r1, [pc, #320]	; (801eaec <SD_CardLoggingAudioStart+0x254>)
 801e9ac:	484e      	ldr	r0, [pc, #312]	; (801eae8 <SD_CardLoggingAudioStart+0x250>)
 801e9ae:	ab07      	add	r3, sp, #28
 801e9b0:	222c      	movs	r2, #44	; 0x2c
 801e9b2:	f7f8 ff0b 	bl	80177cc <f_write>
 801e9b6:	b920      	cbnz	r0, 801e9c2 <SD_CardLoggingAudioStart+0x12a>
  if(f_sync(&MyFileAudio) != FR_OK) {
 801e9b8:	484b      	ldr	r0, [pc, #300]	; (801eae8 <SD_CardLoggingAudioStart+0x250>)
 801e9ba:	f7f9 f807 	bl	80179cc <f_sync>
 801e9be:	4605      	mov	r5, r0
 801e9c0:	b1a0      	cbz	r0, 801e9ec <SD_CardLoggingAudioStart+0x154>
    if(W2ST_CHECK_CONNECTION(W2ST_CONNECT_SD_CARD_LOGGING)) {
 801e9c2:	683b      	ldr	r3, [r7, #0]
 801e9c4:	055d      	lsls	r5, r3, #21
 801e9c6:	d460      	bmi.n	801ea8a <SD_CardLoggingAudioStart+0x1f2>
    DATALOG_SD_LogAudio_Disable(SomethingAlreadyRecording);
 801e9c8:	4650      	mov	r0, sl
 801e9ca:	f7ff fbc9 	bl	801e160 <DATALOG_SD_LogAudio_Disable>
    if((SomethingAlreadyRecording==0) & (NoSDFlag==0)){
 801e9ce:	6ca3      	ldr	r3, [r4, #72]	; 0x48
 801e9d0:	ea5a 0303 	orrs.w	r3, sl, r3
 801e9d4:	d10f      	bne.n	801e9f6 <SD_CardLoggingAudioStart+0x15e>
      if(W2ST_CHECK_CONNECTION(W2ST_CONNECT_SD_CARD_LOGGING)) {
 801e9d6:	683b      	ldr	r3, [r7, #0]
 801e9d8:	0558      	lsls	r0, r3, #21
 801e9da:	d45a      	bmi.n	801ea92 <SD_CardLoggingAudioStart+0x1fa>
      NoSDFlag = 1;
 801e9dc:	2301      	movs	r3, #1
  FATFS_UnLinkDriver(SDPath);
 801e9de:	4844      	ldr	r0, [pc, #272]	; (801eaf0 <SD_CardLoggingAudioStart+0x258>)
      NoSDFlag = 1;
 801e9e0:	64a3      	str	r3, [r4, #72]	; 0x48
  FATFS_UnLinkDriver(SDPath);
 801e9e2:	f7f9 febd 	bl	8018760 <FATFS_UnLinkDriver>
      DATALOG_SD_Init();
 801e9e6:	f7ff fd71 	bl	801e4cc <DATALOG_SD_Init>
 801e9ea:	e004      	b.n	801e9f6 <SD_CardLoggingAudioStart+0x15e>
  PowerCtrlLock();
 801e9ec:	f000 fc0c 	bl	801f208 <PowerCtrlLock>
    SD_LogAudio_Enabled=1;
 801e9f0:	2301      	movs	r3, #1
 801e9f2:	61a3      	str	r3, [r4, #24]
    NoSDFlag =0;
 801e9f4:	64a5      	str	r5, [r4, #72]	; 0x48
    osDelay(100);
 801e9f6:	2064      	movs	r0, #100	; 0x64
 801e9f8:	f7f9 ff64 	bl	80188c4 <osDelay>
    if(SD_LogAudio_Enabled) {
 801e9fc:	69a3      	ldr	r3, [r4, #24]
 801e9fe:	bb0b      	cbnz	r3, 801ea44 <SD_CardLoggingAudioStart+0x1ac>
      if(W2ST_CHECK_CONNECTION(W2ST_CONNECT_STD_ERR)){
 801ea00:	683b      	ldr	r3, [r7, #0]
 801ea02:	065a      	lsls	r2, r3, #25
 801ea04:	f57f af52 	bpl.w	801e8ac <SD_CardLoggingAudioStart+0x14>
        BytesToWrite =sprintf((char *)BufferToWrite,"3 SD Card not present\n");
 801ea08:	4c3a      	ldr	r4, [pc, #232]	; (801eaf4 <SD_CardLoggingAudioStart+0x25c>)
 801ea0a:	4d2b      	ldr	r5, [pc, #172]	; (801eab8 <SD_CardLoggingAudioStart+0x220>)
 801ea0c:	4e2b      	ldr	r6, [pc, #172]	; (801eabc <SD_CardLoggingAudioStart+0x224>)
 801ea0e:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 801ea10:	6069      	str	r1, [r5, #4]
 801ea12:	88a1      	ldrh	r1, [r4, #4]
 801ea14:	82a9      	strh	r1, [r5, #20]
 801ea16:	79a1      	ldrb	r1, [r4, #6]
 801ea18:	6028      	str	r0, [r5, #0]
 801ea1a:	75a9      	strb	r1, [r5, #22]
 801ea1c:	6820      	ldr	r0, [r4, #0]
 801ea1e:	6128      	str	r0, [r5, #16]
 801ea20:	2116      	movs	r1, #22
 801ea22:	60aa      	str	r2, [r5, #8]
 801ea24:	60eb      	str	r3, [r5, #12]
        Stderr_Update(BufferToWrite,BytesToWrite);
 801ea26:	4628      	mov	r0, r5
        BytesToWrite =sprintf((char *)BufferToWrite,"3 SD Card not present\n");
 801ea28:	6031      	str	r1, [r6, #0]
        Stderr_Update(BufferToWrite,BytesToWrite);
 801ea2a:	e75e      	b.n	801e8ea <SD_CardLoggingAudioStart+0x52>
        BytesToWrite =sprintf((char *)BufferToWrite, "FileName=%s\n",AudioDataFileName);
 801ea2c:	4649      	mov	r1, r9
 801ea2e:	aa08      	add	r2, sp, #32
 801ea30:	4640      	mov	r0, r8
 801ea32:	f009 fba7 	bl	8028184 <siprintf>
 801ea36:	4b21      	ldr	r3, [pc, #132]	; (801eabc <SD_CardLoggingAudioStart+0x224>)
        Term_Update(BufferToWrite,BytesToWrite);
 801ea38:	b2c1      	uxtb	r1, r0
        BytesToWrite =sprintf((char *)BufferToWrite, "FileName=%s\n",AudioDataFileName);
 801ea3a:	6018      	str	r0, [r3, #0]
        Term_Update(BufferToWrite,BytesToWrite);
 801ea3c:	4640      	mov	r0, r8
 801ea3e:	f004 fb37 	bl	80230b0 <Term_Update>
 801ea42:	e7a3      	b.n	801e98c <SD_CardLoggingAudioStart+0xf4>
      IsSdAudioRecording= 1;
 801ea44:	2301      	movs	r3, #1
      InitMics(AUDIO_SAMPLING_FREQUENCY);
 801ea46:	f44f 507a 	mov.w	r0, #16000	; 0x3e80
      IsSdAudioRecording= 1;
 801ea4a:	6663      	str	r3, [r4, #100]	; 0x64
      InitMics(AUDIO_SAMPLING_FREQUENCY);
 801ea4c:	f000 fd48 	bl	801f4e0 <InitMics>
      if(W2ST_CHECK_CONNECTION(W2ST_CONNECT_STD_TERM)) {
 801ea50:	683b      	ldr	r3, [r7, #0]
 801ea52:	0699      	lsls	r1, r3, #26
 801ea54:	f57f af2a 	bpl.w	801e8ac <SD_CardLoggingAudioStart+0x14>
        BytesToWrite =sprintf((char *)BufferToWrite,"Start Data Log Audio Rec\n");
 801ea58:	4c27      	ldr	r4, [pc, #156]	; (801eaf8 <SD_CardLoggingAudioStart+0x260>)
 801ea5a:	4d17      	ldr	r5, [pc, #92]	; (801eab8 <SD_CardLoggingAudioStart+0x220>)
 801ea5c:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 801ea5e:	6069      	str	r1, [r5, #4]
 801ea60:	4916      	ldr	r1, [pc, #88]	; (801eabc <SD_CardLoggingAudioStart+0x224>)
 801ea62:	6028      	str	r0, [r5, #0]
 801ea64:	2619      	movs	r6, #25
 801ea66:	600e      	str	r6, [r1, #0]
 801ea68:	cc03      	ldmia	r4!, {r0, r1}
 801ea6a:	60eb      	str	r3, [r5, #12]
 801ea6c:	8823      	ldrh	r3, [r4, #0]
 801ea6e:	6128      	str	r0, [r5, #16]
 801ea70:	6169      	str	r1, [r5, #20]
        Term_Update(BufferToWrite,BytesToWrite);
 801ea72:	4628      	mov	r0, r5
 801ea74:	4631      	mov	r1, r6
        BytesToWrite =sprintf((char *)BufferToWrite,"Start Data Log Audio Rec\n");
 801ea76:	60aa      	str	r2, [r5, #8]
 801ea78:	832b      	strh	r3, [r5, #24]
}
 801ea7a:	b018      	add	sp, #96	; 0x60
 801ea7c:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
        Term_Update(BufferToWrite,BytesToWrite);
 801ea80:	f004 bb16 	b.w	80230b0 <Term_Update>
        SD_LogAudio_Enabled= 0;
 801ea84:	2300      	movs	r3, #0
 801ea86:	61a3      	str	r3, [r4, #24]
        return 0;
 801ea88:	e79e      	b.n	801e9c8 <SD_CardLoggingAudioStart+0x130>
      SDLog_Update(SD_CARD_LOGGING_IO_ERROR);
 801ea8a:	2003      	movs	r0, #3
 801ea8c:	f004 ffe2 	bl	8023a54 <SDLog_Update>
 801ea90:	e79a      	b.n	801e9c8 <SD_CardLoggingAudioStart+0x130>
        SDLog_Update(SD_CARD_LOGGING_NO_SD);
 801ea92:	2002      	movs	r0, #2
 801ea94:	f004 ffde 	bl	8023a54 <SDLog_Update>
 801ea98:	e7a0      	b.n	801e9dc <SD_CardLoggingAudioStart+0x144>
    SENSING1_PRINTF("Error: Failed to allocate memory for audio buffer.\r\n");
 801ea9a:	4b18      	ldr	r3, [pc, #96]	; (801eafc <SD_CardLoggingAudioStart+0x264>)
 801ea9c:	781b      	ldrb	r3, [r3, #0]
 801ea9e:	b90b      	cbnz	r3, 801eaa4 <SD_CardLoggingAudioStart+0x20c>
    error();
 801eaa0:	f7fe ff92 	bl	801d9c8 <error>
    SENSING1_PRINTF("Error: Failed to allocate memory for audio buffer.\r\n");
 801eaa4:	4816      	ldr	r0, [pc, #88]	; (801eb00 <SD_CardLoggingAudioStart+0x268>)
 801eaa6:	f009 fb55 	bl	8028154 <puts>
 801eaaa:	e7f9      	b.n	801eaa0 <SD_CardLoggingAudioStart+0x208>
 801eaac:	2000b518 	.word	0x2000b518
 801eab0:	2001457c 	.word	0x2001457c
 801eab4:	080420ac 	.word	0x080420ac
 801eab8:	200133dc 	.word	0x200133dc
 801eabc:	200134dc 	.word	0x200134dc
 801eac0:	45564157 	.word	0x45564157
 801eac4:	00100002 	.word	0x00100002
 801eac8:	001d4c00 	.word	0x001d4c00
 801eacc:	46464952 	.word	0x46464952
 801ead0:	61746164 	.word	0x61746164
 801ead4:	20746d66 	.word	0x20746d66
 801ead8:	20013528 	.word	0x20013528
 801eadc:	0803982c 	.word	0x0803982c
 801eae0:	200134f0 	.word	0x200134f0
 801eae4:	0804204c 	.word	0x0804204c
 801eae8:	2000e628 	.word	0x2000e628
 801eaec:	2000b534 	.word	0x2000b534
 801eaf0:	2000b580 	.word	0x2000b580
 801eaf4:	08042094 	.word	0x08042094
 801eaf8:	08042078 	.word	0x08042078
 801eafc:	20000d84 	.word	0x20000d84
 801eb00:	08042018 	.word	0x08042018
 801eb04:	08041d04 	.word	0x08041d04

0801eb08 <SdCardAudioRecordingRun>:
{
 801eb08:	b530      	push	{r4, r5, lr}
  if(!IsSdAudioRecording) {
 801eb0a:	4c18      	ldr	r4, [pc, #96]	; (801eb6c <SdCardAudioRecordingRun+0x64>)
 801eb0c:	6e63      	ldr	r3, [r4, #100]	; 0x64
{
 801eb0e:	b083      	sub	sp, #12
  if(!IsSdAudioRecording) {
 801eb10:	b15b      	cbz	r3, 801eb2a <SdCardAudioRecordingRun+0x22>
  if (NbAudioSamplesCounter < 3000 * 16) {
 801eb12:	6d62      	ldr	r2, [r4, #84]	; 0x54
 801eb14:	f64b 337f 	movw	r3, #47999	; 0xbb7f
 801eb18:	429a      	cmp	r2, r3
 801eb1a:	d812      	bhi.n	801eb42 <SdCardAudioRecordingRun+0x3a>
  LedInitTargetPlatform();
 801eb1c:	f000 fe3a 	bl	801f794 <LedInitTargetPlatform>
}
 801eb20:	b003      	add	sp, #12
 801eb22:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
  LedOffTargetPlatform();
 801eb26:	f000 be31 	b.w	801f78c <LedOffTargetPlatform>
    SD_CardLoggingAudioStart();
 801eb2a:	f7ff feb5 	bl	801e898 <SD_CardLoggingAudioStart>
  if(IsSdAudioRecording) {
 801eb2e:	6e63      	ldr	r3, [r4, #100]	; 0x64
 801eb30:	2b00      	cmp	r3, #0
 801eb32:	d1ee      	bne.n	801eb12 <SdCardAudioRecordingRun+0xa>
  LedInitTargetPlatform();
 801eb34:	f000 fe2e 	bl	801f794 <LedInitTargetPlatform>
}
 801eb38:	b003      	add	sp, #12
 801eb3a:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
  LedOffTargetPlatform();
 801eb3e:	f000 be25 	b.w	801f78c <LedOffTargetPlatform>
  if(f_write(&MyFileAudio, ((uint8_t *)(Audio_OUT_Buff+index_buff)), AUDIO_BUFF_LEN /* Because we need to write 16bit for sample */, (void *)&byteswritten) != FR_OK) {
 801eb42:	6da5      	ldr	r5, [r4, #88]	; 0x58
 801eb44:	6d21      	ldr	r1, [r4, #80]	; 0x50
 801eb46:	480a      	ldr	r0, [pc, #40]	; (801eb70 <SdCardAudioRecordingRun+0x68>)
 801eb48:	ab01      	add	r3, sp, #4
 801eb4a:	f44f 6200 	mov.w	r2, #2048	; 0x800
 801eb4e:	eb01 0145 	add.w	r1, r1, r5, lsl #1
 801eb52:	f7f8 fe3b 	bl	80177cc <f_write>
 801eb56:	2800      	cmp	r0, #0
 801eb58:	d0e0      	beq.n	801eb1c <SdCardAudioRecordingRun+0x14>
    if(W2ST_CHECK_CONNECTION(W2ST_CONNECT_SD_CARD_LOGGING)) {
 801eb5a:	4b06      	ldr	r3, [pc, #24]	; (801eb74 <SdCardAudioRecordingRun+0x6c>)
 801eb5c:	681b      	ldr	r3, [r3, #0]
 801eb5e:	055b      	lsls	r3, r3, #21
 801eb60:	d5dc      	bpl.n	801eb1c <SdCardAudioRecordingRun+0x14>
      SDLog_Update(SD_CARD_LOGGING_IO_ERROR);
 801eb62:	2003      	movs	r0, #3
 801eb64:	f004 ff76 	bl	8023a54 <SDLog_Update>
 801eb68:	e7d8      	b.n	801eb1c <SdCardAudioRecordingRun+0x14>
 801eb6a:	bf00      	nop
 801eb6c:	2000b518 	.word	0x2000b518
 801eb70:	2000e628 	.word	0x2000e628
 801eb74:	2001457c 	.word	0x2001457c

0801eb78 <DATALOG_SD_DeInit>:
  FATFS_UnLinkDriver(SDPath);
 801eb78:	4801      	ldr	r0, [pc, #4]	; (801eb80 <DATALOG_SD_DeInit+0x8>)
 801eb7a:	f7f9 bdf1 	b.w	8018760 <FATFS_UnLinkDriver>
 801eb7e:	bf00      	nop
 801eb80:	2000b580 	.word	0x2000b580

0801eb84 <SaveDataAnnotation>:
{
 801eb84:	b530      	push	{r4, r5, lr}
  if(SD_LogMems_Enabled) {
 801eb86:	4d3f      	ldr	r5, [pc, #252]	; (801ec84 <SaveDataAnnotation+0x100>)
 801eb88:	68ab      	ldr	r3, [r5, #8]
{
 801eb8a:	b097      	sub	sp, #92	; 0x5c
  if(SD_LogMems_Enabled) {
 801eb8c:	b90b      	cbnz	r3, 801eb92 <SaveDataAnnotation+0xe>
}
 801eb8e:	b017      	add	sp, #92	; 0x5c
 801eb90:	bd30      	pop	{r4, r5, pc}
     RTC_GetCurrentDateTime();
 801eb92:	4604      	mov	r4, r0
 801eb94:	f003 fefe 	bl	8022994 <RTC_GetCurrentDateTime>
                        CurrentTime.Minutes,
 801eb98:	4a3b      	ldr	r2, [pc, #236]	; (801ec88 <SaveDataAnnotation+0x104>)
                        999- (CurrentTime.SubSeconds*1000)/(CurrentTime.SecondFraction),
 801eb9a:	6853      	ldr	r3, [r2, #4]
    size = sprintf(myBuffer, "%02d:%02d:%02d.%03ld,%s",
 801eb9c:	9402      	str	r4, [sp, #8]
                        999- (CurrentTime.SubSeconds*1000)/(CurrentTime.SecondFraction),
 801eb9e:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
 801eba2:	fb01 f303 	mul.w	r3, r1, r3
 801eba6:	6891      	ldr	r1, [r2, #8]
 801eba8:	fbb3 f3f1 	udiv	r3, r3, r1
    size = sprintf(myBuffer, "%02d:%02d:%02d.%03ld,%s",
 801ebac:	7891      	ldrb	r1, [r2, #2]
 801ebae:	f5c3 7379 	rsb	r3, r3, #996	; 0x3e4
 801ebb2:	3303      	adds	r3, #3
 801ebb4:	e9cd 1300 	strd	r1, r3, [sp]
 801ebb8:	a806      	add	r0, sp, #24
 801ebba:	7853      	ldrb	r3, [r2, #1]
 801ebbc:	4933      	ldr	r1, [pc, #204]	; (801ec8c <SaveDataAnnotation+0x108>)
 801ebbe:	7812      	ldrb	r2, [r2, #0]
 801ebc0:	f009 fae0 	bl	8028184 <siprintf>
    if(SD_Card_FeaturesMask!=FEATURE_MASK_BLUEVOICE) {
 801ebc4:	686b      	ldr	r3, [r5, #4]
 801ebc6:	f1b3 6f00 	cmp.w	r3, #134217728	; 0x8000000
    size = sprintf(myBuffer, "%02d:%02d:%02d.%03ld,%s",
 801ebca:	4604      	mov	r4, r0
    if(SD_Card_FeaturesMask!=FEATURE_MASK_BLUEVOICE) {
 801ebcc:	d00d      	beq.n	801ebea <SaveDataAnnotation+0x66>
      if(SD_Card_FeaturesMask&FEATURE_MASK_ACC) {
 801ebce:	021a      	lsls	r2, r3, #8
 801ebd0:	d452      	bmi.n	801ec78 <SaveDataAnnotation+0xf4>
      if(SD_Card_FeaturesMask&FEATURE_MASK_GRYO) {
 801ebd2:	0258      	lsls	r0, r3, #9
 801ebd4:	d449      	bmi.n	801ec6a <SaveDataAnnotation+0xe6>
      if(SD_Card_FeaturesMask&FEATURE_MASK_MAG) {
 801ebd6:	0299      	lsls	r1, r3, #10
 801ebd8:	d440      	bmi.n	801ec5c <SaveDataAnnotation+0xd8>
      if(SD_Card_FeaturesMask&FEATURE_MASK_PRESS) {
 801ebda:	02da      	lsls	r2, r3, #11
 801ebdc:	d435      	bmi.n	801ec4a <SaveDataAnnotation+0xc6>
      if(SD_Card_FeaturesMask&FEATURE_MASK_TEMP1) {
 801ebde:	0358      	lsls	r0, r3, #13
 801ebe0:	d42a      	bmi.n	801ec38 <SaveDataAnnotation+0xb4>
      if(SD_Card_FeaturesMask&FEATURE_MASK_TEMP2) {
 801ebe2:	03d9      	lsls	r1, r3, #15
 801ebe4:	d41f      	bmi.n	801ec26 <SaveDataAnnotation+0xa2>
      if(SD_Card_FeaturesMask&FEATURE_MASK_HUM) {
 801ebe6:	031a      	lsls	r2, r3, #12
 801ebe8:	d415      	bmi.n	801ec16 <SaveDataAnnotation+0x92>
    size += sprintf(myBuffer+size, "%c",'\n');
 801ebea:	ab06      	add	r3, sp, #24
 801ebec:	4928      	ldr	r1, [pc, #160]	; (801ec90 <SaveDataAnnotation+0x10c>)
 801ebee:	220a      	movs	r2, #10
 801ebf0:	1918      	adds	r0, r3, r4
 801ebf2:	f009 fac7 	bl	8028184 <siprintf>
    if(f_write(&MyFileMems, myBuffer, size, (void *)&byteswritten) != FR_OK) {
 801ebf6:	4827      	ldr	r0, [pc, #156]	; (801ec94 <SaveDataAnnotation+0x110>)
 801ebf8:	ab05      	add	r3, sp, #20
 801ebfa:	1c62      	adds	r2, r4, #1
 801ebfc:	a906      	add	r1, sp, #24
 801ebfe:	f7f8 fde5 	bl	80177cc <f_write>
 801ec02:	2800      	cmp	r0, #0
 801ec04:	d0c3      	beq.n	801eb8e <SaveDataAnnotation+0xa>
      if(W2ST_CHECK_CONNECTION(W2ST_CONNECT_SD_CARD_LOGGING)) {
 801ec06:	4b24      	ldr	r3, [pc, #144]	; (801ec98 <SaveDataAnnotation+0x114>)
 801ec08:	681b      	ldr	r3, [r3, #0]
 801ec0a:	055b      	lsls	r3, r3, #21
 801ec0c:	d5bf      	bpl.n	801eb8e <SaveDataAnnotation+0xa>
        SDLog_Update(SD_CARD_LOGGING_IO_ERROR);
 801ec0e:	2003      	movs	r0, #3
 801ec10:	f004 ff20 	bl	8023a54 <SDLog_Update>
}
 801ec14:	e7bb      	b.n	801eb8e <SaveDataAnnotation+0xa>
        size += sprintf(myBuffer+size, "%c",',');
 801ec16:	ab06      	add	r3, sp, #24
 801ec18:	1918      	adds	r0, r3, r4
 801ec1a:	491d      	ldr	r1, [pc, #116]	; (801ec90 <SaveDataAnnotation+0x10c>)
 801ec1c:	222c      	movs	r2, #44	; 0x2c
 801ec1e:	f009 fab1 	bl	8028184 <siprintf>
 801ec22:	3401      	adds	r4, #1
 801ec24:	e7e1      	b.n	801ebea <SaveDataAnnotation+0x66>
        size += sprintf(myBuffer+size, "%c",',');
 801ec26:	ab06      	add	r3, sp, #24
 801ec28:	1918      	adds	r0, r3, r4
 801ec2a:	4919      	ldr	r1, [pc, #100]	; (801ec90 <SaveDataAnnotation+0x10c>)
 801ec2c:	222c      	movs	r2, #44	; 0x2c
 801ec2e:	f009 faa9 	bl	8028184 <siprintf>
 801ec32:	3401      	adds	r4, #1
      if(SD_Card_FeaturesMask&FEATURE_MASK_HUM) {
 801ec34:	686b      	ldr	r3, [r5, #4]
 801ec36:	e7d6      	b.n	801ebe6 <SaveDataAnnotation+0x62>
        size += sprintf(myBuffer+size, "%c",',');
 801ec38:	ab06      	add	r3, sp, #24
 801ec3a:	1918      	adds	r0, r3, r4
 801ec3c:	4914      	ldr	r1, [pc, #80]	; (801ec90 <SaveDataAnnotation+0x10c>)
 801ec3e:	222c      	movs	r2, #44	; 0x2c
 801ec40:	f009 faa0 	bl	8028184 <siprintf>
 801ec44:	3401      	adds	r4, #1
      if(SD_Card_FeaturesMask&FEATURE_MASK_TEMP2) {
 801ec46:	686b      	ldr	r3, [r5, #4]
 801ec48:	e7cb      	b.n	801ebe2 <SaveDataAnnotation+0x5e>
        size += sprintf(myBuffer+size, "%c",',');
 801ec4a:	ab06      	add	r3, sp, #24
 801ec4c:	1918      	adds	r0, r3, r4
 801ec4e:	4910      	ldr	r1, [pc, #64]	; (801ec90 <SaveDataAnnotation+0x10c>)
 801ec50:	222c      	movs	r2, #44	; 0x2c
 801ec52:	f009 fa97 	bl	8028184 <siprintf>
 801ec56:	3401      	adds	r4, #1
      if(SD_Card_FeaturesMask&FEATURE_MASK_TEMP1) {
 801ec58:	686b      	ldr	r3, [r5, #4]
 801ec5a:	e7c0      	b.n	801ebde <SaveDataAnnotation+0x5a>
        size += sprintf(myBuffer+size, "%s",",,,");
 801ec5c:	4a0f      	ldr	r2, [pc, #60]	; (801ec9c <SaveDataAnnotation+0x118>)
      if(SD_Card_FeaturesMask&FEATURE_MASK_PRESS) {
 801ec5e:	686b      	ldr	r3, [r5, #4]
        size += sprintf(myBuffer+size, "%s",",,,");
 801ec60:	6810      	ldr	r0, [r2, #0]
 801ec62:	aa06      	add	r2, sp, #24
 801ec64:	5110      	str	r0, [r2, r4]
 801ec66:	3403      	adds	r4, #3
 801ec68:	e7b7      	b.n	801ebda <SaveDataAnnotation+0x56>
        size += sprintf(myBuffer+size, "%s",",,,");
 801ec6a:	4a0c      	ldr	r2, [pc, #48]	; (801ec9c <SaveDataAnnotation+0x118>)
      if(SD_Card_FeaturesMask&FEATURE_MASK_MAG) {
 801ec6c:	686b      	ldr	r3, [r5, #4]
        size += sprintf(myBuffer+size, "%s",",,,");
 801ec6e:	6810      	ldr	r0, [r2, #0]
 801ec70:	aa06      	add	r2, sp, #24
 801ec72:	5110      	str	r0, [r2, r4]
 801ec74:	3403      	adds	r4, #3
 801ec76:	e7ae      	b.n	801ebd6 <SaveDataAnnotation+0x52>
        size += sprintf(myBuffer+size, "%s",",,,");
 801ec78:	4a08      	ldr	r2, [pc, #32]	; (801ec9c <SaveDataAnnotation+0x118>)
 801ec7a:	6810      	ldr	r0, [r2, #0]
 801ec7c:	aa06      	add	r2, sp, #24
 801ec7e:	5110      	str	r0, [r2, r4]
 801ec80:	3403      	adds	r4, #3
 801ec82:	e7a6      	b.n	801ebd2 <SaveDataAnnotation+0x4e>
 801ec84:	2000b518 	.word	0x2000b518
 801ec88:	200134f0 	.word	0x200134f0
 801ec8c:	080420d4 	.word	0x080420d4
 801ec90:	08041c70 	.word	0x08041c70
 801ec94:	2000f658 	.word	0x2000f658
 801ec98:	2001457c 	.word	0x2001457c
 801ec9c:	08041c64 	.word	0x08041c64

0801eca0 <get_fattime>:
{
 801eca0:	b508      	push	{r3, lr}
    RTC_GetCurrentDateTime();
 801eca2:	f003 fe77 	bl	8022994 <RTC_GetCurrentDateTime>
               | ((DWORD)CurrentDate.Month << 21)
 801eca6:	490b      	ldr	r1, [pc, #44]	; (801ecd4 <get_fattime+0x34>)
               | ((DWORD)CurrentTime.Hours << 11)
 801eca8:	4a0b      	ldr	r2, [pc, #44]	; (801ecd8 <get_fattime+0x38>)
               | ((DWORD)CurrentDate.Date << 16)
 801ecaa:	788b      	ldrb	r3, [r1, #2]
               | ((DWORD)CurrentDate.Month << 21)
 801ecac:	7848      	ldrb	r0, [r1, #1]
               | ((DWORD)CurrentTime.Hours << 11)
 801ecae:	f892 c000 	ldrb.w	ip, [r2]
               | ((DWORD)CurrentDate.Date << 16)
 801ecb2:	041b      	lsls	r3, r3, #16
    fat_time =   ((DWORD)(CurrentDate.Year + 2000 - 1980) << 25)
 801ecb4:	ea43 5340 	orr.w	r3, r3, r0, lsl #21
 801ecb8:	78c8      	ldrb	r0, [r1, #3]
               | ((DWORD)CurrentTime.Minutes << 5)
 801ecba:	7851      	ldrb	r1, [r2, #1]
               | ((DWORD)CurrentTime.Seconds >> 1);
 801ecbc:	7892      	ldrb	r2, [r2, #2]
    fat_time =   ((DWORD)(CurrentDate.Year + 2000 - 1980) << 25)
 801ecbe:	ea43 23cc 	orr.w	r3, r3, ip, lsl #11
 801ecc2:	ea43 1341 	orr.w	r3, r3, r1, lsl #5
 801ecc6:	ea43 0352 	orr.w	r3, r3, r2, lsr #1
 801ecca:	3014      	adds	r0, #20
}
 801eccc:	ea43 6040 	orr.w	r0, r3, r0, lsl #25
 801ecd0:	bd08      	pop	{r3, pc}
 801ecd2:	bf00      	nop
 801ecd4:	20013528 	.word	0x20013528
 801ecd8:	200134f0 	.word	0x200134f0

0801ecdc <prvHelpCommand>:
	return pcReturn;
}
/*-----------------------------------------------------------*/

static BaseType_t prvHelpCommand( char *pcWriteBuffer, size_t xWriteBufferLen, const char *pcCommandString )
{
 801ecdc:	b538      	push	{r3, r4, r5, lr}
static const CLI_Definition_List_Item_t * pxCommand = NULL;
BaseType_t xReturn;

	( void ) pcCommandString;

	if( pxCommand == NULL )
 801ecde:	4d08      	ldr	r5, [pc, #32]	; (801ed00 <prvHelpCommand+0x24>)
 801ece0:	4b08      	ldr	r3, [pc, #32]	; (801ed04 <prvHelpCommand+0x28>)
 801ece2:	682c      	ldr	r4, [r5, #0]
 801ece4:	2c00      	cmp	r4, #0
 801ece6:	bf08      	it	eq
 801ece8:	461c      	moveq	r4, r3
{
 801ecea:	460a      	mov	r2, r1
		pxCommand = &xRegisteredCommands;
	}

	/* Return the next command help string, before moving the pointer on to
	the next command in the list. */
	strncpy( pcWriteBuffer, pxCommand->pxCommandLineDefinition->pcHelpString, xWriteBufferLen );
 801ecec:	6823      	ldr	r3, [r4, #0]
 801ecee:	6859      	ldr	r1, [r3, #4]
 801ecf0:	f009 fabf 	bl	8028272 <strncpy>
	pxCommand = pxCommand->pxNext;
 801ecf4:	6860      	ldr	r0, [r4, #4]
 801ecf6:	6028      	str	r0, [r5, #0]
	{
		xReturn = pdTRUE;
	}

	return xReturn;
}
 801ecf8:	3800      	subs	r0, #0
 801ecfa:	bf18      	it	ne
 801ecfc:	2001      	movne	r0, #1
 801ecfe:	bd38      	pop	{r3, r4, r5, pc}
 801ed00:	20010688 	.word	0x20010688
 801ed04:	20000d74 	.word	0x20000d74

0801ed08 <FreeRTOS_CLIRegisterCommand>:
{
 801ed08:	b538      	push	{r3, r4, r5, lr}
	configASSERT( pxCommandToRegister );
 801ed0a:	b1d8      	cbz	r0, 801ed44 <FreeRTOS_CLIRegisterCommand+0x3c>
	pxNewListItem = ( CLI_Definition_List_Item_t * ) pvPortMalloc( sizeof( CLI_Definition_List_Item_t ) );
 801ed0c:	4604      	mov	r4, r0
 801ed0e:	2008      	movs	r0, #8
 801ed10:	f7fa f84a 	bl	8018da8 <pvPortMalloc>
	configASSERT( pxNewListItem );
 801ed14:	4605      	mov	r5, r0
 801ed16:	b160      	cbz	r0, 801ed32 <FreeRTOS_CLIRegisterCommand+0x2a>
		taskENTER_CRITICAL();
 801ed18:	f7fa f964 	bl	8018fe4 <vPortEnterCritical>
			pxLastCommandInList->pxNext = pxNewListItem;
 801ed1c:	4b0e      	ldr	r3, [pc, #56]	; (801ed58 <FreeRTOS_CLIRegisterCommand+0x50>)
 801ed1e:	689a      	ldr	r2, [r3, #8]
			pxLastCommandInList = pxNewListItem;
 801ed20:	609d      	str	r5, [r3, #8]
			pxNewListItem->pxNext = NULL;
 801ed22:	2100      	movs	r1, #0
 801ed24:	e9c5 4100 	strd	r4, r1, [r5]
			pxLastCommandInList->pxNext = pxNewListItem;
 801ed28:	6055      	str	r5, [r2, #4]
		taskEXIT_CRITICAL();
 801ed2a:	f7fa f97d 	bl	8019028 <vPortExitCritical>
}
 801ed2e:	2001      	movs	r0, #1
 801ed30:	bd38      	pop	{r3, r4, r5, pc}
 801ed32:	f04f 0350 	mov.w	r3, #80	; 0x50
 801ed36:	f383 8811 	msr	BASEPRI, r3
 801ed3a:	f3bf 8f6f 	isb	sy
 801ed3e:	f3bf 8f4f 	dsb	sy
	configASSERT( pxNewListItem );
 801ed42:	e7fe      	b.n	801ed42 <FreeRTOS_CLIRegisterCommand+0x3a>
 801ed44:	f04f 0350 	mov.w	r3, #80	; 0x50
 801ed48:	f383 8811 	msr	BASEPRI, r3
 801ed4c:	f3bf 8f6f 	isb	sy
 801ed50:	f3bf 8f4f 	dsb	sy
	configASSERT( pxCommandToRegister );
 801ed54:	e7fe      	b.n	801ed54 <FreeRTOS_CLIRegisterCommand+0x4c>
 801ed56:	bf00      	nop
 801ed58:	20000d74 	.word	0x20000d74

0801ed5c <FreeRTOS_CLIProcessCommand>:
{
 801ed5c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	if( pxCommand == NULL )
 801ed60:	4f31      	ldr	r7, [pc, #196]	; (801ee28 <FreeRTOS_CLIProcessCommand+0xcc>)
 801ed62:	687b      	ldr	r3, [r7, #4]
{
 801ed64:	b082      	sub	sp, #8
 801ed66:	4682      	mov	sl, r0
 801ed68:	4688      	mov	r8, r1
 801ed6a:	4691      	mov	r9, r2
	if( pxCommand == NULL )
 801ed6c:	b163      	cbz	r3, 801ed88 <FreeRTOS_CLIProcessCommand+0x2c>
		xReturn = pxCommand->pxCommandLineDefinition->pxCommandInterpreter( pcWriteBuffer, xWriteBufferLen, pcCommandInput );
 801ed6e:	681b      	ldr	r3, [r3, #0]
 801ed70:	4652      	mov	r2, sl
 801ed72:	689b      	ldr	r3, [r3, #8]
 801ed74:	4649      	mov	r1, r9
 801ed76:	4640      	mov	r0, r8
 801ed78:	4798      	blx	r3
		if( xReturn == pdFALSE )
 801ed7a:	4605      	mov	r5, r0
 801ed7c:	b900      	cbnz	r0, 801ed80 <FreeRTOS_CLIProcessCommand+0x24>
			pxCommand = NULL;
 801ed7e:	6078      	str	r0, [r7, #4]
}
 801ed80:	4628      	mov	r0, r5
 801ed82:	b002      	add	sp, #8
 801ed84:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		for( pxCommand = &xRegisteredCommands; pxCommand != NULL; pxCommand = pxCommand->pxNext )
 801ed88:	4c28      	ldr	r4, [pc, #160]	; (801ee2c <FreeRTOS_CLIProcessCommand+0xd0>)
 801ed8a:	607c      	str	r4, [r7, #4]
			pcRegisteredCommandString = pxCommand->pxCommandLineDefinition->pcCommand;
 801ed8c:	6826      	ldr	r6, [r4, #0]
 801ed8e:	6831      	ldr	r1, [r6, #0]
			xCommandStringLength = strlen( pcRegisteredCommandString );
 801ed90:	9101      	str	r1, [sp, #4]
 801ed92:	4608      	mov	r0, r1
 801ed94:	f7eb fb6d 	bl	800a472 <strlen>
			if( ( pcCommandInput[ xCommandStringLength ] == ' ' ) || ( pcCommandInput[ xCommandStringLength ] == 0x00 ) )
 801ed98:	f81a 3000 	ldrb.w	r3, [sl, r0]
				if( strncmp( pcCommandInput, pcRegisteredCommandString, xCommandStringLength ) == 0 )
 801ed9c:	9901      	ldr	r1, [sp, #4]
			if( ( pcCommandInput[ xCommandStringLength ] == ' ' ) || ( pcCommandInput[ xCommandStringLength ] == 0x00 ) )
 801ed9e:	f013 0fdf 	tst.w	r3, #223	; 0xdf
				if( strncmp( pcCommandInput, pcRegisteredCommandString, xCommandStringLength ) == 0 )
 801eda2:	4602      	mov	r2, r0
 801eda4:	4650      	mov	r0, sl
			if( ( pcCommandInput[ xCommandStringLength ] == ' ' ) || ( pcCommandInput[ xCommandStringLength ] == 0x00 ) )
 801eda6:	d103      	bne.n	801edb0 <FreeRTOS_CLIProcessCommand+0x54>
				if( strncmp( pcCommandInput, pcRegisteredCommandString, xCommandStringLength ) == 0 )
 801eda8:	f009 fa4f 	bl	802824a <strncmp>
 801edac:	4605      	mov	r5, r0
 801edae:	b168      	cbz	r0, 801edcc <FreeRTOS_CLIProcessCommand+0x70>
		for( pxCommand = &xRegisteredCommands; pxCommand != NULL; pxCommand = pxCommand->pxNext )
 801edb0:	6864      	ldr	r4, [r4, #4]
 801edb2:	607c      	str	r4, [r7, #4]
 801edb4:	2c00      	cmp	r4, #0
 801edb6:	d1e9      	bne.n	801ed8c <FreeRTOS_CLIProcessCommand+0x30>
		strncpy( pcWriteBuffer, "Command not recognised.  Enter 'help' to view a list of available commands.\r\n\r\n", xWriteBufferLen );
 801edb8:	491d      	ldr	r1, [pc, #116]	; (801ee30 <FreeRTOS_CLIProcessCommand+0xd4>)
 801edba:	464a      	mov	r2, r9
 801edbc:	4640      	mov	r0, r8
 801edbe:	f009 fa58 	bl	8028272 <strncpy>
		xReturn = pdFALSE;
 801edc2:	2500      	movs	r5, #0
}
 801edc4:	4628      	mov	r0, r5
 801edc6:	b002      	add	sp, #8
 801edc8:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
					if( pxCommand->pxCommandLineDefinition->cExpectedNumberOfParameters >= 0 )
 801edcc:	f996 400c 	ldrsb.w	r4, [r6, #12]
 801edd0:	2c00      	cmp	r4, #0
 801edd2:	da03      	bge.n	801eddc <FreeRTOS_CLIProcessCommand+0x80>
	if( ( pxCommand != NULL ) && ( xReturn == pdFALSE ) )
 801edd4:	687b      	ldr	r3, [r7, #4]
	else if( pxCommand != NULL )
 801edd6:	2b00      	cmp	r3, #0
 801edd8:	d0ee      	beq.n	801edb8 <FreeRTOS_CLIProcessCommand+0x5c>
 801edda:	e7c8      	b.n	801ed6e <FreeRTOS_CLIProcessCommand+0x12>
{
int8_t cParameters = 0;
BaseType_t xLastCharacterWasSpace = pdFALSE;

	/* Count the number of space delimited words in pcCommandString. */
	while( *pcCommandString != 0x00 )
 801eddc:	f89a 3000 	ldrb.w	r3, [sl]
 801ede0:	b18b      	cbz	r3, 801ee06 <FreeRTOS_CLIProcessCommand+0xaa>
 801ede2:	4652      	mov	r2, sl
BaseType_t xLastCharacterWasSpace = pdFALSE;
 801ede4:	4601      	mov	r1, r0
 801ede6:	e003      	b.n	801edf0 <FreeRTOS_CLIProcessCommand+0x94>
				xLastCharacterWasSpace = pdTRUE;
			}
		}
		else
		{
			xLastCharacterWasSpace = pdFALSE;
 801ede8:	2100      	movs	r1, #0
	while( *pcCommandString != 0x00 )
 801edea:	f812 3f01 	ldrb.w	r3, [r2, #1]!
 801edee:	b13b      	cbz	r3, 801ee00 <FreeRTOS_CLIProcessCommand+0xa4>
		if( ( *pcCommandString ) == ' ' )
 801edf0:	2b20      	cmp	r3, #32
 801edf2:	d1f9      	bne.n	801ede8 <FreeRTOS_CLIProcessCommand+0x8c>
				cParameters++;
 801edf4:	1c43      	adds	r3, r0, #1
			if( xLastCharacterWasSpace != pdTRUE )
 801edf6:	2900      	cmp	r1, #0
 801edf8:	d1f7      	bne.n	801edea <FreeRTOS_CLIProcessCommand+0x8e>
				cParameters++;
 801edfa:	b258      	sxtb	r0, r3
				xLastCharacterWasSpace = pdTRUE;
 801edfc:	2101      	movs	r1, #1
 801edfe:	e7f4      	b.n	801edea <FreeRTOS_CLIProcessCommand+0x8e>
		pcCommandString++;
	}

	/* If the command string ended with spaces, then there will have been too
	many parameters counted. */
	if( xLastCharacterWasSpace == pdTRUE )
 801ee00:	b109      	cbz	r1, 801ee06 <FreeRTOS_CLIProcessCommand+0xaa>
	{
		cParameters--;
 801ee02:	3801      	subs	r0, #1
 801ee04:	b240      	sxtb	r0, r0
						if( prvGetNumberOfParameters( pcCommandInput ) != pxCommand->pxCommandLineDefinition->cExpectedNumberOfParameters )
 801ee06:	4284      	cmp	r4, r0
 801ee08:	d0e4      	beq.n	801edd4 <FreeRTOS_CLIProcessCommand+0x78>
	if( ( pxCommand != NULL ) && ( xReturn == pdFALSE ) )
 801ee0a:	687b      	ldr	r3, [r7, #4]
 801ee0c:	2b00      	cmp	r3, #0
 801ee0e:	d0d3      	beq.n	801edb8 <FreeRTOS_CLIProcessCommand+0x5c>
		strncpy( pcWriteBuffer, "Incorrect command parameter(s).  Enter \"help\" to view a list of available commands.\r\n\r\n", xWriteBufferLen );
 801ee10:	4908      	ldr	r1, [pc, #32]	; (801ee34 <FreeRTOS_CLIProcessCommand+0xd8>)
 801ee12:	464a      	mov	r2, r9
 801ee14:	4640      	mov	r0, r8
 801ee16:	f009 fa2c 	bl	8028272 <strncpy>
		pxCommand = NULL;
 801ee1a:	2300      	movs	r3, #0
}
 801ee1c:	4628      	mov	r0, r5
		pxCommand = NULL;
 801ee1e:	607b      	str	r3, [r7, #4]
}
 801ee20:	b002      	add	sp, #8
 801ee22:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 801ee26:	bf00      	nop
 801ee28:	20010688 	.word	0x20010688
 801ee2c:	20000d74 	.word	0x20000d74
 801ee30:	08042174 	.word	0x08042174
 801ee34:	0804211c 	.word	0x0804211c

0801ee38 <FreeRTOS_CLIGetParameter>:
	*pxParameterStringLength = 0;
 801ee38:	2300      	movs	r3, #0
 801ee3a:	6013      	str	r3, [r2, #0]
UBaseType_t uxParametersFound = 0;
 801ee3c:	469c      	mov	ip, r3
	while( uxParametersFound < uxWantedParameter )
 801ee3e:	458c      	cmp	ip, r1
 801ee40:	d021      	beq.n	801ee86 <FreeRTOS_CLIGetParameter+0x4e>
		while( ( ( *pcCommandString ) != 0x00 ) && ( ( *pcCommandString ) != ' ' ) )
 801ee42:	7803      	ldrb	r3, [r0, #0]
 801ee44:	b91b      	cbnz	r3, 801ee4e <FreeRTOS_CLIGetParameter+0x16>
 801ee46:	e01e      	b.n	801ee86 <FreeRTOS_CLIGetParameter+0x4e>
 801ee48:	f810 3f01 	ldrb.w	r3, [r0, #1]!
 801ee4c:	b1db      	cbz	r3, 801ee86 <FreeRTOS_CLIGetParameter+0x4e>
 801ee4e:	2b20      	cmp	r3, #32
 801ee50:	d1fa      	bne.n	801ee48 <FreeRTOS_CLIGetParameter+0x10>
		while( ( ( *pcCommandString ) != 0x00 ) && ( ( *pcCommandString ) == ' ' ) )
 801ee52:	7803      	ldrb	r3, [r0, #0]
 801ee54:	2b20      	cmp	r3, #32
 801ee56:	d103      	bne.n	801ee60 <FreeRTOS_CLIGetParameter+0x28>
 801ee58:	f810 3f01 	ldrb.w	r3, [r0, #1]!
 801ee5c:	2b20      	cmp	r3, #32
 801ee5e:	d0fb      	beq.n	801ee58 <FreeRTOS_CLIGetParameter+0x20>
		if( *pcCommandString != 0x00 )
 801ee60:	b18b      	cbz	r3, 801ee86 <FreeRTOS_CLIGetParameter+0x4e>
			uxParametersFound++;
 801ee62:	f10c 0c01 	add.w	ip, ip, #1
			if( uxParametersFound == uxWantedParameter )
 801ee66:	4561      	cmp	r1, ip
 801ee68:	d1e9      	bne.n	801ee3e <FreeRTOS_CLIGetParameter+0x6>
				while( ( ( *pcCommandString ) != 0x00 ) && ( ( *pcCommandString ) != ' ' ) )
 801ee6a:	7803      	ldrb	r3, [r0, #0]
 801ee6c:	b15b      	cbz	r3, 801ee86 <FreeRTOS_CLIGetParameter+0x4e>
 801ee6e:	4684      	mov	ip, r0
 801ee70:	2100      	movs	r1, #0
 801ee72:	e004      	b.n	801ee7e <FreeRTOS_CLIGetParameter+0x46>
					( *pxParameterStringLength )++;
 801ee74:	3101      	adds	r1, #1
 801ee76:	6011      	str	r1, [r2, #0]
				while( ( ( *pcCommandString ) != 0x00 ) && ( ( *pcCommandString ) != ' ' ) )
 801ee78:	f81c 3f01 	ldrb.w	r3, [ip, #1]!
 801ee7c:	b12b      	cbz	r3, 801ee8a <FreeRTOS_CLIGetParameter+0x52>
 801ee7e:	2b20      	cmp	r3, #32
 801ee80:	d1f8      	bne.n	801ee74 <FreeRTOS_CLIGetParameter+0x3c>
				if( *pxParameterStringLength == 0 )
 801ee82:	b101      	cbz	r1, 801ee86 <FreeRTOS_CLIGetParameter+0x4e>
 801ee84:	4770      	bx	lr
const char *pcReturn = NULL;
 801ee86:	2000      	movs	r0, #0
}
 801ee88:	4770      	bx	lr
 801ee8a:	4770      	bx	lr

0801ee8c <CheckBootLoaderCompliance>:
 * @brief Function for Testing the BootLoader Compliance
 * @param None
 * @retval int8_t Return value for checking purpose (0/1 == Ok/Error)
 */
int8_t CheckBootLoaderCompliance(void)
{
 801ee8c:	b510      	push	{r4, lr}
  OTA_PRINTF("Testing BootLoaderCompliance:\r\n");
  OTA_PRINTF("\tVersion  %u.%u.%u\r\n",
 801ee8e:	4c1b      	ldr	r4, [pc, #108]	; (801eefc <CheckBootLoaderCompliance+0x70>)
  OTA_PRINTF("Testing BootLoaderCompliance:\r\n");
 801ee90:	481b      	ldr	r0, [pc, #108]	; (801ef00 <CheckBootLoaderCompliance+0x74>)
 801ee92:	f009 f95f 	bl	8028154 <puts>
  OTA_PRINTF("\tVersion  %u.%u.%u\r\n",
 801ee96:	6821      	ldr	r1, [r4, #0]
 801ee98:	481a      	ldr	r0, [pc, #104]	; (801ef04 <CheckBootLoaderCompliance+0x78>)
 801ee9a:	b2cb      	uxtb	r3, r1
 801ee9c:	f3c1 2207 	ubfx	r2, r1, #8, #8
 801eea0:	0c09      	lsrs	r1, r1, #16
 801eea2:	f009 f8bb 	bl	802801c <iprintf>
             (unsigned int)BootLoaderFeatures->Version >> 16,
             (unsigned int)(BootLoaderFeatures->Version >> 8) & 0xFF,
             (unsigned int)BootLoaderFeatures->Version & 0xFF);

  if(BootLoaderFeatures->MagicNum==OTA_MAGIC_NUM) {
 801eea6:	4b18      	ldr	r3, [pc, #96]	; (801ef08 <CheckBootLoaderCompliance+0x7c>)
 801eea8:	6862      	ldr	r2, [r4, #4]
 801eeaa:	429a      	cmp	r2, r3
 801eeac:	d116      	bne.n	801eedc <CheckBootLoaderCompliance+0x50>
    OTA_PRINTF("\tMagicNum    OK\r\n");
 801eeae:	4817      	ldr	r0, [pc, #92]	; (801ef0c <CheckBootLoaderCompliance+0x80>)
 801eeb0:	f009 f950 	bl	8028154 <puts>
  } else {
    OTA_PRINTF("\tMagicNum    KO\r\n");
    return 0;
  }

  OTA_PRINTF("\tMaxSize = %u\r\n", (unsigned int) BootLoaderFeatures->OTAMaxSize);
 801eeb4:	6921      	ldr	r1, [r4, #16]
 801eeb6:	4816      	ldr	r0, [pc, #88]	; (801ef10 <CheckBootLoaderCompliance+0x84>)
 801eeb8:	f009 f8b0 	bl	802801c <iprintf>

  if(BootLoaderFeatures->OTAStartAdd==(OTA_ADDRESS_START-16)) {
 801eebc:	4b15      	ldr	r3, [pc, #84]	; (801ef14 <CheckBootLoaderCompliance+0x88>)
 801eebe:	68a2      	ldr	r2, [r4, #8]
 801eec0:	429a      	cmp	r2, r3
 801eec2:	d110      	bne.n	801eee6 <CheckBootLoaderCompliance+0x5a>
    OTA_PRINTF("\tOTAStartAdd OK\r\n");
 801eec4:	4814      	ldr	r0, [pc, #80]	; (801ef18 <CheckBootLoaderCompliance+0x8c>)
 801eec6:	f009 f945 	bl	8028154 <puts>
  } else {
    OTA_PRINTF("\tOTAStartAdd KO\r\n");
    return 0;
  }

  if(BootLoaderFeatures->OTADoneAdd==OTA_MAGIC_DONE_NUM_POS) {
 801eeca:	4b14      	ldr	r3, [pc, #80]	; (801ef1c <CheckBootLoaderCompliance+0x90>)
 801eecc:	68e2      	ldr	r2, [r4, #12]
 801eece:	429a      	cmp	r2, r3
 801eed0:	d10e      	bne.n	801eef0 <CheckBootLoaderCompliance+0x64>
    OTA_PRINTF("\tOTADoneAdd  OK\r\n");
 801eed2:	4813      	ldr	r0, [pc, #76]	; (801ef20 <CheckBootLoaderCompliance+0x94>)
 801eed4:	f009 f93e 	bl	8028154 <puts>
  } else {
    OTA_PRINTF("\tOTADoneAdd  KO\r\n");
    return 0;
  }

  return 1;
 801eed8:	2001      	movs	r0, #1
}
 801eeda:	bd10      	pop	{r4, pc}
    OTA_PRINTF("\tMagicNum    KO\r\n");
 801eedc:	4811      	ldr	r0, [pc, #68]	; (801ef24 <CheckBootLoaderCompliance+0x98>)
 801eede:	f009 f939 	bl	8028154 <puts>
    return 0;
 801eee2:	2000      	movs	r0, #0
}
 801eee4:	bd10      	pop	{r4, pc}
    OTA_PRINTF("\tOTAStartAdd KO\r\n");
 801eee6:	4810      	ldr	r0, [pc, #64]	; (801ef28 <CheckBootLoaderCompliance+0x9c>)
 801eee8:	f009 f934 	bl	8028154 <puts>
    return 0;
 801eeec:	2000      	movs	r0, #0
}
 801eeee:	bd10      	pop	{r4, pc}
    OTA_PRINTF("\tOTADoneAdd  KO\r\n");
 801eef0:	480e      	ldr	r0, [pc, #56]	; (801ef2c <CheckBootLoaderCompliance+0xa0>)
 801eef2:	f009 f92f 	bl	8028154 <puts>
    return 0;
 801eef6:	2000      	movs	r0, #0
}
 801eef8:	bd10      	pop	{r4, pc}
 801eefa:	bf00      	nop
 801eefc:	08003f00 	.word	0x08003f00
 801ef00:	080421fc 	.word	0x080421fc
 801ef04:	0804221c 	.word	0x0804221c
 801ef08:	deadbeef 	.word	0xdeadbeef
 801ef0c:	08042234 	.word	0x08042234
 801ef10:	08042248 	.word	0x08042248
 801ef14:	08080000 	.word	0x08080000
 801ef18:	0804226c 	.word	0x0804226c
 801ef1c:	08080008 	.word	0x08080008
 801ef20:	08042294 	.word	0x08042294
 801ef24:	08042258 	.word	0x08042258
 801ef28:	08042280 	.word	0x08042280
 801ef2c:	080422a8 	.word	0x080422a8

0801ef30 <UpdateFWBlueMS>:
 * @param int32_t data_length length of the data
 * @param uint8_t WriteMagicNum 1/0 for writing or not the magic number
 * @retval int8_t Return value for checking purpose (1/-1 == Ok/Error)
 */
int8_t UpdateFWBlueMS(uint32_t *SizeOfUpdate, uint8_t *att_data, int32_t data_length, uint8_t WriteMagicNum)
{
 801ef30:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  int8_t ReturnValue=0;
  /* Save the Packed received */

  if(data_length>(*SizeOfUpdate)){
 801ef34:	6804      	ldr	r4, [r0, #0]
 801ef36:	4294      	cmp	r4, r2
{
 801ef38:	b08f      	sub	sp, #60	; 0x3c
 801ef3a:	4682      	mov	sl, r0
 801ef3c:	4690      	mov	r8, r2
  if(data_length>(*SizeOfUpdate)){
 801ef3e:	d20d      	bcs.n	801ef5c <UpdateFWBlueMS+0x2c>
    /* Too many bytes...Something wrong... necessity to send it again... */
    OTA_PRINTF("OTA something wrong data_length=%d RemSizeOfUpdate=%u....\r\nPlease Try again\r\n",
 801ef40:	4622      	mov	r2, r4
 801ef42:	4641      	mov	r1, r8
 801ef44:	4875      	ldr	r0, [pc, #468]	; (801f11c <UpdateFWBlueMS+0x1ec>)
 801ef46:	f009 f869 	bl	802801c <iprintf>
    (int) data_length, (unsigned int)(*SizeOfUpdate));
    ReturnValue = -1;
 801ef4a:	f04f 34ff 	mov.w	r4, #4294967295
    /* Reset for Restarting again */
    *SizeOfUpdate=0;
 801ef4e:	2300      	movs	r3, #0
    /* Lock the Flash to disable the flash control register access (recommended
     to protect the FLASH memory against possible unwanted operation) *********/
    HAL_FLASH_Lock();
  }
  return ReturnValue;
}
 801ef50:	4620      	mov	r0, r4
    *SizeOfUpdate=0;
 801ef52:	f8ca 3000 	str.w	r3, [sl]
}
 801ef56:	b00f      	add	sp, #60	; 0x3c
 801ef58:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 801ef5c:	460f      	mov	r7, r1
 801ef5e:	469b      	mov	fp, r3
    HAL_FLASH_Unlock();
 801ef60:	f7f1 fad0 	bl	8010504 <HAL_FLASH_Unlock>
    for(Counter=0;Counter<data_length;Counter+=8) {
 801ef64:	f1b8 0f00 	cmp.w	r8, #0
 801ef68:	dd23      	ble.n	801efb2 <UpdateFWBlueMS+0x82>
      if(HAL_FLASH_Program(FLASH_TYPEPROGRAM_DOUBLEWORD, WritingAddress,ValueToWrite)==HAL_OK) {
 801ef6a:	463c      	mov	r4, r7
 801ef6c:	4e6c      	ldr	r6, [pc, #432]	; (801f120 <UpdateFWBlueMS+0x1f0>)
 801ef6e:	f108 33ff 	add.w	r3, r8, #4294967295
 801ef72:	f023 0307 	bic.w	r3, r3, #7
 801ef76:	f107 0108 	add.w	r1, r7, #8
 801ef7a:	f104 0901 	add.w	r9, r4, #1
 801ef7e:	6835      	ldr	r5, [r6, #0]
 801ef80:	185f      	adds	r7, r3, r1
      memcpy((uint8_t*) &ValueToWrite,att_data+Counter,data_length-Counter+1);
 801ef82:	44c1      	add	r9, r8
 801ef84:	e005      	b.n	801ef92 <UpdateFWBlueMS+0x62>
       WritingAddress+=8;
 801ef86:	6835      	ldr	r5, [r6, #0]
    for(Counter=0;Counter<data_length;Counter+=8) {
 801ef88:	42a7      	cmp	r7, r4
       WritingAddress+=8;
 801ef8a:	f105 0508 	add.w	r5, r5, #8
 801ef8e:	6035      	str	r5, [r6, #0]
    for(Counter=0;Counter<data_length;Counter+=8) {
 801ef90:	d00f      	beq.n	801efb2 <UpdateFWBlueMS+0x82>
      memcpy((uint8_t*) &ValueToWrite,att_data+Counter,data_length-Counter+1);
 801ef92:	eba9 0204 	sub.w	r2, r9, r4
 801ef96:	4621      	mov	r1, r4
 801ef98:	a802      	add	r0, sp, #8
 801ef9a:	f008 fac5 	bl	8027528 <memcpy>
      if(HAL_FLASH_Program(FLASH_TYPEPROGRAM_DOUBLEWORD, WritingAddress,ValueToWrite)==HAL_OK) {
 801ef9e:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 801efa2:	4629      	mov	r1, r5
 801efa4:	2000      	movs	r0, #0
    for(Counter=0;Counter<data_length;Counter+=8) {
 801efa6:	3408      	adds	r4, #8
      if(HAL_FLASH_Program(FLASH_TYPEPROGRAM_DOUBLEWORD, WritingAddress,ValueToWrite)==HAL_OK) {
 801efa8:	f7f1 fb06 	bl	80105b8 <HAL_FLASH_Program>
 801efac:	2800      	cmp	r0, #0
 801efae:	d0ea      	beq.n	801ef86 <UpdateFWBlueMS+0x56>
        OTA_ERROR_FUNCTION();
 801efb0:	e7fe      	b.n	801efb0 <UpdateFWBlueMS+0x80>
    *SizeOfUpdate -= data_length;
 801efb2:	f8da 4000 	ldr.w	r4, [sl]
 801efb6:	eba4 0408 	sub.w	r4, r4, r8
 801efba:	f8ca 4000 	str.w	r4, [sl]
    if(*SizeOfUpdate==0) {
 801efbe:	bb2c      	cbnz	r4, 801f00c <UpdateFWBlueMS+0xdc>
      OTA_PRINTF("OTA Update saved\r\n");
 801efc0:	4858      	ldr	r0, [pc, #352]	; (801f124 <UpdateFWBlueMS+0x1f4>)
 801efc2:	f009 f8c7 	bl	8028154 <puts>
      if(WriteMagicNum) {
 801efc6:	f1bb 0f00 	cmp.w	fp, #0
 801efca:	d01f      	beq.n	801f00c <UpdateFWBlueMS+0xdc>
        if(ExpecteduwCRCValue) {
 801efcc:	4f56      	ldr	r7, [pc, #344]	; (801f128 <UpdateFWBlueMS+0x1f8>)
 801efce:	683b      	ldr	r3, [r7, #0]
 801efd0:	bb1b      	cbnz	r3, 801f01a <UpdateFWBlueMS+0xea>
          ValueToWrite=(((uint64_t)SizeOfUpdateBlueFW)<<32)| (OTA_MAGIC_NUM);
 801efd2:	4b56      	ldr	r3, [pc, #344]	; (801f12c <UpdateFWBlueMS+0x1fc>)
          WritingAddress = OTA_MAGIC_NUM_POS;
 801efd4:	4e52      	ldr	r6, [pc, #328]	; (801f120 <UpdateFWBlueMS+0x1f0>)
 801efd6:	4d56      	ldr	r5, [pc, #344]	; (801f130 <UpdateFWBlueMS+0x200>)
 801efd8:	6035      	str	r5, [r6, #0]
          if(Value32==NN_OTA_MAGIC_NUM) {
 801efda:	f46f 6286 	mvn.w	r2, #1072	; 0x430
          ValueToWrite=(((uint64_t)SizeOfUpdateBlueFW)<<32)| (OTA_MAGIC_NUM);
 801efde:	9302      	str	r3, [sp, #8]
          if(Value32==NN_OTA_MAGIC_NUM) {
 801efe0:	f103 434d 	add.w	r3, r3, #3439329280	; 0xcd000000
 801efe4:	4413      	add	r3, r2
 801efe6:	692a      	ldr	r2, [r5, #16]
          ValueToWrite=(((uint64_t)SizeOfUpdateBlueFW)<<32)| (OTA_MAGIC_NUM);
 801efe8:	687f      	ldr	r7, [r7, #4]
 801efea:	9703      	str	r7, [sp, #12]
          if(Value32==NN_OTA_MAGIC_NUM) {
 801efec:	429a      	cmp	r2, r3
 801efee:	d045      	beq.n	801f07c <UpdateFWBlueMS+0x14c>
            OTA_PRINTF("Full FoTA\r\n");
 801eff0:	4850      	ldr	r0, [pc, #320]	; (801f134 <UpdateFWBlueMS+0x204>)
 801eff2:	f009 f8af 	bl	8028154 <puts>
            DestinationAddress =BootLoaderFeatures->ProgStartAdd;
 801eff6:	4b50      	ldr	r3, [pc, #320]	; (801f138 <UpdateFWBlueMS+0x208>)
 801eff8:	695d      	ldr	r5, [r3, #20]
            if(HAL_FLASH_Program(FLASH_TYPEPROGRAM_DOUBLEWORD, WritingAddress,ValueToWrite)!=HAL_OK) {
 801effa:	4a4c      	ldr	r2, [pc, #304]	; (801f12c <UpdateFWBlueMS+0x1fc>)
 801effc:	6831      	ldr	r1, [r6, #0]
 801effe:	463b      	mov	r3, r7
 801f000:	2000      	movs	r0, #0
 801f002:	f7f1 fad9 	bl	80105b8 <HAL_FLASH_Program>
 801f006:	2800      	cmp	r0, #0
 801f008:	d02f      	beq.n	801f06a <UpdateFWBlueMS+0x13a>
              OTA_ERROR_FUNCTION();
 801f00a:	e7fe      	b.n	801f00a <UpdateFWBlueMS+0xda>
  int8_t ReturnValue=0;
 801f00c:	2400      	movs	r4, #0
    HAL_FLASH_Lock();
 801f00e:	f7f1 fa8d 	bl	801052c <HAL_FLASH_Lock>
}
 801f012:	4620      	mov	r0, r4
 801f014:	b00f      	add	sp, #60	; 0x3c
 801f016:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
          CrcHandle.Instance = CRC;
 801f01a:	4a48      	ldr	r2, [pc, #288]	; (801f13c <UpdateFWBlueMS+0x20c>)
 801f01c:	9205      	str	r2, [sp, #20]
          CrcHandle.InputDataFormat              = CRC_INPUTDATA_FORMAT_WORDS;
 801f01e:	2303      	movs	r3, #3
          if(HAL_CRC_GetState(&CrcHandle) != HAL_CRC_STATE_RESET) {
 801f020:	a805      	add	r0, sp, #20
          CrcHandle.Init.OutputDataInversionMode = CRC_OUTPUTDATA_INVERSION_DISABLE;
 801f022:	e9cd 440a 	strd	r4, r4, [sp, #40]	; 0x28
          CrcHandle.Init.DefaultPolynomialUse    = DEFAULT_POLYNOMIAL_ENABLE;
 801f026:	f8ad 4018 	strh.w	r4, [sp, #24]
          CrcHandle.InputDataFormat              = CRC_INPUTDATA_FORMAT_WORDS;
 801f02a:	930d      	str	r3, [sp, #52]	; 0x34
          if(HAL_CRC_GetState(&CrcHandle) != HAL_CRC_STATE_RESET) {
 801f02c:	f7f0 fd92 	bl	800fb54 <HAL_CRC_GetState>
 801f030:	2800      	cmp	r0, #0
 801f032:	d157      	bne.n	801f0e4 <UpdateFWBlueMS+0x1b4>
          if (HAL_CRC_Init(&CrcHandle) != HAL_OK) {
 801f034:	a805      	add	r0, sp, #20
 801f036:	f7f0 fd09 	bl	800fa4c <HAL_CRC_Init>
 801f03a:	b100      	cbz	r0, 801f03e <UpdateFWBlueMS+0x10e>
            OTA_ERROR_FUNCTION();
 801f03c:	e7fe      	b.n	801f03c <UpdateFWBlueMS+0x10c>
            OTA_PRINTF("CRC  Initialized\n\r");
 801f03e:	4840      	ldr	r0, [pc, #256]	; (801f140 <UpdateFWBlueMS+0x210>)
 801f040:	f008 ffec 	bl	802801c <iprintf>
          uwCRCValue = HAL_CRC_Calculate(&CrcHandle, (uint32_t *)OTA_ADDRESS_START, SizeOfUpdateBlueFW>>2);
 801f044:	687a      	ldr	r2, [r7, #4]
 801f046:	493f      	ldr	r1, [pc, #252]	; (801f144 <UpdateFWBlueMS+0x214>)
 801f048:	0892      	lsrs	r2, r2, #2
 801f04a:	a805      	add	r0, sp, #20
 801f04c:	f7f0 fd56 	bl	800fafc <HAL_CRC_Calculate>
          if(uwCRCValue==ExpecteduwCRCValue) {
 801f050:	683b      	ldr	r3, [r7, #0]
 801f052:	4283      	cmp	r3, r0
          uwCRCValue = HAL_CRC_Calculate(&CrcHandle, (uint32_t *)OTA_ADDRESS_START, SizeOfUpdateBlueFW>>2);
 801f054:	4605      	mov	r5, r0
          if(uwCRCValue==ExpecteduwCRCValue) {
 801f056:	d057      	beq.n	801f108 <UpdateFWBlueMS+0x1d8>
            OTA_PRINTF("OTA Error CRC-checking\r\n");
 801f058:	483b      	ldr	r0, [pc, #236]	; (801f148 <UpdateFWBlueMS+0x218>)
 801f05a:	f009 f87b 	bl	8028154 <puts>
          if(ExpecteduwCRCValue) {
 801f05e:	683a      	ldr	r2, [r7, #0]
 801f060:	2a00      	cmp	r2, #0
 801f062:	d14c      	bne.n	801f0fe <UpdateFWBlueMS+0x1ce>
          ReturnValue=-1;
 801f064:	f04f 34ff 	mov.w	r4, #4294967295
 801f068:	e7d1      	b.n	801f00e <UpdateFWBlueMS+0xde>
              WritingAddress = OTA_MAGIC_NUM_POS+8;
 801f06a:	4938      	ldr	r1, [pc, #224]	; (801f14c <UpdateFWBlueMS+0x21c>)
 801f06c:	6031      	str	r1, [r6, #0]
              if(HAL_FLASH_Program(FLASH_TYPEPROGRAM_DOUBLEWORD, WritingAddress,ValueToWrite)!=HAL_OK) {
 801f06e:	4622      	mov	r2, r4
 801f070:	462b      	mov	r3, r5
 801f072:	f7f1 faa1 	bl	80105b8 <HAL_FLASH_Program>
 801f076:	2800      	cmp	r0, #0
 801f078:	d04a      	beq.n	801f110 <UpdateFWBlueMS+0x1e0>
                OTA_ERROR_FUNCTION();
 801f07a:	e7fe      	b.n	801f07a <UpdateFWBlueMS+0x14a>
            OTA_PRINTF("Partial FoTA\r\n");
 801f07c:	4834      	ldr	r0, [pc, #208]	; (801f150 <UpdateFWBlueMS+0x220>)
 801f07e:	f009 f869 	bl	8028154 <puts>
            HeaderSize = *(uint32_t *)HeaderAddress;
 801f082:	696c      	ldr	r4, [r5, #20]
            OTA_PRINTF("Header Size  = %u\r\n", (unsigned int) HeaderSize);
 801f084:	4833      	ldr	r0, [pc, #204]	; (801f154 <UpdateFWBlueMS+0x224>)
 801f086:	4621      	mov	r1, r4
 801f088:	f008 ffc8 	bl	802801c <iprintf>
            OTA_PRINTF("Header Ver   = %u\r\n",*(short unsigned int*)HeaderAddress);
 801f08c:	8b29      	ldrh	r1, [r5, #24]
 801f08e:	4832      	ldr	r0, [pc, #200]	; (801f158 <UpdateFWBlueMS+0x228>)
 801f090:	f008 ffc4 	bl	802801c <iprintf>
            OTA_PRINTF("Header Type  = %u\r\n",*(short unsigned int*)HeaderAddress);
 801f094:	8b69      	ldrh	r1, [r5, #26]
 801f096:	4831      	ldr	r0, [pc, #196]	; (801f15c <UpdateFWBlueMS+0x22c>)
 801f098:	f008 ffc0 	bl	802801c <iprintf>
            OTA_PRINTF("Header Sig   = 0x%016llX%016llX\r\n",
 801f09c:	e9d5 1007 	ldrd	r1, r0, [r5, #28]
 801f0a0:	e9d5 2309 	ldrd	r2, r3, [r5, #36]	; 0x24
 801f0a4:	e9cd 1000 	strd	r1, r0, [sp]
 801f0a8:	482d      	ldr	r0, [pc, #180]	; (801f160 <UpdateFWBlueMS+0x230>)
 801f0aa:	f008 ffb7 	bl	802801c <iprintf>
            OTA_PRINTF("Data Weights = %u\r\n",*(unsigned int*)HeaderAddress);
 801f0ae:	6ae9      	ldr	r1, [r5, #44]	; 0x2c
 801f0b0:	482c      	ldr	r0, [pc, #176]	; (801f164 <UpdateFWBlueMS+0x234>)
 801f0b2:	f008 ffb3 	bl	802801c <iprintf>
            ActivationSize = *(uint32_t *)HeaderAddress;
 801f0b6:	f8d5 8030 	ldr.w	r8, [r5, #48]	; 0x30
            OTA_PRINTF("Act Size     = %u\r\n", (unsigned int) ActivationSize);
 801f0ba:	482b      	ldr	r0, [pc, #172]	; (801f168 <UpdateFWBlueMS+0x238>)
 801f0bc:	4641      	mov	r1, r8
 801f0be:	f008 ffad 	bl	802801c <iprintf>
            OTA_PRINTF("Reserved     = %0xX%X%X\r\n",
 801f0c2:	6b69      	ldr	r1, [r5, #52]	; 0x34
 801f0c4:	4829      	ldr	r0, [pc, #164]	; (801f16c <UpdateFWBlueMS+0x23c>)
 801f0c6:	e9d5 230e 	ldrd	r2, r3, [r5, #56]	; 0x38
 801f0ca:	f008 ffa7 	bl	802801c <iprintf>
            DestinationAddress = (uint32_t) aiNetworkRetrieveDataWeightsAddress(ActivationSize,&ModelName);
 801f0ce:	a905      	add	r1, sp, #20
 801f0d0:	4640      	mov	r0, r8
 801f0d2:	f000 fddf 	bl	801fc94 <aiNetworkRetrieveDataWeightsAddress>
            if(DestinationAddress==((uint32_t)NULL)) {
 801f0d6:	b148      	cbz	r0, 801f0ec <UpdateFWBlueMS+0x1bc>
            DestinationAddress = (uint32_t) aiNetworkRetrieveDataWeightsAddress(ActivationSize,&ModelName);
 801f0d8:	4605      	mov	r5, r0
              OTA_PRINTF("Valid Partial FoTA for [%s]\r\n", ModelName);
 801f0da:	9905      	ldr	r1, [sp, #20]
 801f0dc:	4824      	ldr	r0, [pc, #144]	; (801f170 <UpdateFWBlueMS+0x240>)
 801f0de:	f008 ff9d 	bl	802801c <iprintf>
          if(ReturnValue==1) {
 801f0e2:	e78a      	b.n	801effa <UpdateFWBlueMS+0xca>
            HAL_CRC_DeInit(&CrcHandle);
 801f0e4:	a805      	add	r0, sp, #20
 801f0e6:	f7f0 fcef 	bl	800fac8 <HAL_CRC_DeInit>
 801f0ea:	e7a3      	b.n	801f034 <UpdateFWBlueMS+0x104>
              OTA_PRINTF("Error Not A Valid Partial FoTA\r\n");
 801f0ec:	4821      	ldr	r0, [pc, #132]	; (801f174 <UpdateFWBlueMS+0x244>)
 801f0ee:	f009 f831 	bl	8028154 <puts>
              OTA_PRINTF("\rThe Update will be rejected\r\n");
 801f0f2:	4821      	ldr	r0, [pc, #132]	; (801f178 <UpdateFWBlueMS+0x248>)
 801f0f4:	f009 f82e 	bl	8028154 <puts>
              ReturnValue=-1;
 801f0f8:	f04f 34ff 	mov.w	r4, #4294967295
 801f0fc:	e787      	b.n	801f00e <UpdateFWBlueMS+0xde>
            OTA_PRINTF("Wrong CRC! Computed = %X  Expected = %X ... Try again\r\n",
 801f0fe:	4629      	mov	r1, r5
 801f100:	481e      	ldr	r0, [pc, #120]	; (801f17c <UpdateFWBlueMS+0x24c>)
 801f102:	f008 ff8b 	bl	802801c <iprintf>
 801f106:	e7ad      	b.n	801f064 <UpdateFWBlueMS+0x134>
            OTA_PRINTF("OTA CRC-checked\r\n");
 801f108:	481d      	ldr	r0, [pc, #116]	; (801f180 <UpdateFWBlueMS+0x250>)
 801f10a:	f009 f823 	bl	8028154 <puts>
        if(ReturnValue==1) {
 801f10e:	e760      	b.n	801efd2 <UpdateFWBlueMS+0xa2>
									OTA_PRINTF("OTA will be installed at next board reset\r\n");
 801f110:	481c      	ldr	r0, [pc, #112]	; (801f184 <UpdateFWBlueMS+0x254>)
 801f112:	f009 f81f 	bl	8028154 <puts>
 801f116:	2401      	movs	r4, #1
 801f118:	e779      	b.n	801f00e <UpdateFWBlueMS+0xde>
 801f11a:	bf00      	nop
 801f11c:	080422bc 	.word	0x080422bc
 801f120:	20000d80 	.word	0x20000d80
 801f124:	0804230c 	.word	0x0804230c
 801f128:	20010694 	.word	0x20010694
 801f12c:	deadbeef 	.word	0xdeadbeef
 801f130:	08080000 	.word	0x08080000
 801f134:	08042474 	.word	0x08042474
 801f138:	08003f00 	.word	0x08003f00
 801f13c:	40023000 	.word	0x40023000
 801f140:	08042320 	.word	0x08042320
 801f144:	08080010 	.word	0x08080010
 801f148:	08042348 	.word	0x08042348
 801f14c:	08080008 	.word	0x08080008
 801f150:	08042360 	.word	0x08042360
 801f154:	08042370 	.word	0x08042370
 801f158:	08042384 	.word	0x08042384
 801f15c:	08042398 	.word	0x08042398
 801f160:	080423ac 	.word	0x080423ac
 801f164:	080423d0 	.word	0x080423d0
 801f168:	080423e4 	.word	0x080423e4
 801f16c:	080423f8 	.word	0x080423f8
 801f170:	08042454 	.word	0x08042454
 801f174:	08042414 	.word	0x08042414
 801f178:	08042434 	.word	0x08042434
 801f17c:	080424ac 	.word	0x080424ac
 801f180:	08042334 	.word	0x08042334
 801f184:	08042480 	.word	0x08042480

0801f188 <StartUpdateFWBlueMS>:
 * @param uint32_t SizeOfUpdate  size of the firmware image [bytes]
 * @param uint32_t uwCRCValue expected CRC value
 * @retval None
 */
void StartUpdateFWBlueMS(uint32_t SizeOfUpdate, uint32_t uwCRCValue)
{
 801f188:	b570      	push	{r4, r5, r6, lr}
 801f18a:	b086      	sub	sp, #24
 801f18c:	4604      	mov	r4, r0
  FLASH_EraseInitTypeDef EraseInitStruct;
  uint32_t SectorError = 0;
 801f18e:	2600      	movs	r6, #0
  OTA_PRINTF("Start FLASH Erase\r\n");
 801f190:	4814      	ldr	r0, [pc, #80]	; (801f1e4 <StartUpdateFWBlueMS+0x5c>)
  uint32_t SectorError = 0;
 801f192:	9601      	str	r6, [sp, #4]
{
 801f194:	460d      	mov	r5, r1
  OTA_PRINTF("Start FLASH Erase\r\n");
 801f196:	f008 ffdd 	bl	8028154 <puts>

  SizeOfUpdateBlueFW = SizeOfUpdate;
 801f19a:	4b13      	ldr	r3, [pc, #76]	; (801f1e8 <StartUpdateFWBlueMS+0x60>)
  ExpecteduwCRCValue = uwCRCValue;
  WritingAddress = OTA_ADDRESS_START;
 801f19c:	4a13      	ldr	r2, [pc, #76]	; (801f1ec <StartUpdateFWBlueMS+0x64>)

  EraseInitStruct.TypeErase   = FLASH_TYPEERASE_PAGES;
  EraseInitStruct.Banks       = GetBank(OTA_MAGIC_NUM_POS);
 801f19e:	4814      	ldr	r0, [pc, #80]	; (801f1f0 <StartUpdateFWBlueMS+0x68>)
  EraseInitStruct.TypeErase   = FLASH_TYPEERASE_PAGES;
 801f1a0:	9602      	str	r6, [sp, #8]
  ExpecteduwCRCValue = uwCRCValue;
 801f1a2:	e9c3 5400 	strd	r5, r4, [r3]
  WritingAddress = OTA_ADDRESS_START;
 801f1a6:	4b13      	ldr	r3, [pc, #76]	; (801f1f4 <StartUpdateFWBlueMS+0x6c>)
 801f1a8:	6013      	str	r3, [r2, #0]
  EraseInitStruct.Banks       = GetBank(OTA_MAGIC_NUM_POS);
 801f1aa:	f000 fb13 	bl	801f7d4 <GetBank>
 801f1ae:	4603      	mov	r3, r0
  EraseInitStruct.Page        = GetPage(OTA_MAGIC_NUM_POS);
 801f1b0:	480f      	ldr	r0, [pc, #60]	; (801f1f0 <StartUpdateFWBlueMS+0x68>)
  EraseInitStruct.Banks       = GetBank(OTA_MAGIC_NUM_POS);
 801f1b2:	9303      	str	r3, [sp, #12]
  EraseInitStruct.Page        = GetPage(OTA_MAGIC_NUM_POS);
 801f1b4:	f000 faf2 	bl	801f79c <GetPage>
  EraseInitStruct.NbPages     = (SizeOfUpdate+16+FLASH_PAGE_SIZE-1)/FLASH_PAGE_SIZE;
 801f1b8:	f604 030f 	addw	r3, r4, #2063	; 0x80f
 801f1bc:	0adb      	lsrs	r3, r3, #11
 801f1be:	e9cd 0304 	strd	r0, r3, [sp, #16]

  /* Unlock the Flash to enable the flash control register access *************/
  HAL_FLASH_Unlock();
 801f1c2:	f7f1 f99f 	bl	8010504 <HAL_FLASH_Unlock>
  if (__HAL_FLASH_GET_FLAG(FLASH_FLAG_PEMPTY) != 0) {
    __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_PEMPTY);
  }
#endif /* STM32L4R9xx */

  if(HAL_FLASHEx_Erase(&EraseInitStruct, &SectorError) != HAL_OK){
 801f1c6:	a901      	add	r1, sp, #4
 801f1c8:	a802      	add	r0, sp, #8
 801f1ca:	f7f1 faab 	bl	8010724 <HAL_FLASHEx_Erase>
 801f1ce:	b100      	cbz	r0, 801f1d2 <StartUpdateFWBlueMS+0x4a>
    /* Error occurred while sector erase.
      User can add here some code to deal with this error.
      SectorError will contain the faulty sector and then to know the code error on this sector,
      user can call function 'HAL_FLASH_GetError()'
      FLASH_ErrorTypeDef errorcode = HAL_FLASH_GetError(); */
    OTA_ERROR_FUNCTION();
 801f1d0:	e7fe      	b.n	801f1d0 <StartUpdateFWBlueMS+0x48>
  } else {
    OTA_PRINTF("End FLASH Erase %u Pages of 2KB\r\n", (unsigned int) EraseInitStruct.NbPages);
 801f1d2:	9905      	ldr	r1, [sp, #20]
 801f1d4:	4808      	ldr	r0, [pc, #32]	; (801f1f8 <StartUpdateFWBlueMS+0x70>)
 801f1d6:	f008 ff21 	bl	802801c <iprintf>
  }

  /* Lock the Flash to disable the flash control register access (recommended
  to protect the FLASH memory against possible unwanted operation) *********/
  HAL_FLASH_Lock();
 801f1da:	f7f1 f9a7 	bl	801052c <HAL_FLASH_Lock>
}
 801f1de:	b006      	add	sp, #24
 801f1e0:	bd70      	pop	{r4, r5, r6, pc}
 801f1e2:	bf00      	nop
 801f1e4:	080424e4 	.word	0x080424e4
 801f1e8:	20010694 	.word	0x20010694
 801f1ec:	20000d80 	.word	0x20000d80
 801f1f0:	08080000 	.word	0x08080000
 801f1f4:	08080010 	.word	0x08080010
 801f1f8:	080424f8 	.word	0x080424f8

0801f1fc <SetMinPowerMode>:
  return minPowerMode;
}

int SetMinPowerMode(powerState_t powerMode)
{
  minPowerMode = powerMode ;
 801f1fc:	4b01      	ldr	r3, [pc, #4]	; (801f204 <SetMinPowerMode+0x8>)
 801f1fe:	7018      	strb	r0, [r3, #0]
  return 0;
}
 801f200:	2000      	movs	r0, #0
 801f202:	4770      	bx	lr
 801f204:	2001069c 	.word	0x2001069c

0801f208 <PowerCtrlLock>:

int PowerCtrlLock(void)
{
  return ++PowerCtrlLockToken;
 801f208:	4b02      	ldr	r3, [pc, #8]	; (801f214 <PowerCtrlLock+0xc>)
 801f20a:	6858      	ldr	r0, [r3, #4]
 801f20c:	3001      	adds	r0, #1
 801f20e:	6058      	str	r0, [r3, #4]
}
 801f210:	4770      	bx	lr
 801f212:	bf00      	nop
 801f214:	2001069c 	.word	0x2001069c

0801f218 <PowerCtrlUnLock>:
int PowerCtrlUnLock(void)
{
  PowerCtrlLockToken -= (PowerCtrlLockToken) ? 1:0;
 801f218:	4b03      	ldr	r3, [pc, #12]	; (801f228 <PowerCtrlUnLock+0x10>)
 801f21a:	6858      	ldr	r0, [r3, #4]
 801f21c:	2800      	cmp	r0, #0
 801f21e:	bf18      	it	ne
 801f220:	3801      	subne	r0, #1
 801f222:	6058      	str	r0, [r3, #4]
  return PowerCtrlLockToken;
}
 801f224:	4770      	bx	lr
 801f226:	bf00      	nop
 801f228:	2001069c 	.word	0x2001069c

0801f22c <vApplicationIdleHook>:
  return PowerCtrlLockToken;
}

void vApplicationIdleHook( void )
{
   __WFI();
 801f22c:	bf30      	wfi
}
 801f22e:	4770      	bx	lr

0801f230 <initPowerController>:
  minPowerMode = powerMode ;
 801f230:	4b12      	ldr	r3, [pc, #72]	; (801f27c <initPowerController+0x4c>)

int initPowerController(void)
{
 801f232:	b530      	push	{r4, r5, lr}
    SetMinPowerMode (RUN);

  /* Enable Power Clock */
  __HAL_RCC_PWR_CLK_ENABLE();
 801f234:	4d12      	ldr	r5, [pc, #72]	; (801f280 <initPowerController+0x50>)
  minPowerMode = powerMode ;
 801f236:	2400      	movs	r4, #0
 801f238:	701c      	strb	r4, [r3, #0]
  __HAL_RCC_PWR_CLK_ENABLE();
 801f23a:	6dab      	ldr	r3, [r5, #88]	; 0x58
 801f23c:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 801f240:	65ab      	str	r3, [r5, #88]	; 0x58
 801f242:	6dab      	ldr	r3, [r5, #88]	; 0x58
{
 801f244:	b083      	sub	sp, #12
  __HAL_RCC_PWR_CLK_ENABLE();
 801f246:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 801f24a:	9301      	str	r3, [sp, #4]
 801f24c:	9b01      	ldr	r3, [sp, #4]
    HAL_PWR_EnableBkUpAccess();
 801f24e:	f7f2 fe37 	bl	8011ec0 <HAL_PWR_EnableBkUpAccess>

  /* Ensure that MSI is wake-up system clock */
  __HAL_RCC_WAKEUPSTOP_CLK_CONFIG(RCC_STOP_WAKEUPCLOCK_MSI);
 801f252:	68ab      	ldr	r3, [r5, #8]

  /* Configure RTC */
  RtcHandle.Instance = RTC;
 801f254:	480b      	ldr	r0, [pc, #44]	; (801f284 <initPowerController+0x54>)
 801f256:	4a0c      	ldr	r2, [pc, #48]	; (801f288 <initPowerController+0x58>)
  __HAL_RCC_WAKEUPSTOP_CLK_CONFIG(RCC_STOP_WAKEUPCLOCK_MSI);
 801f258:	f423 4300 	bic.w	r3, r3, #32768	; 0x8000
 801f25c:	60ab      	str	r3, [r5, #8]
    - OutPut = Output Disable
    - OutPutPolarity = High Polarity
    - OutPutType = Open Drain */
  RtcHandle.Init.HourFormat     = RTC_HOURFORMAT_24;
  RtcHandle.Init.AsynchPrediv   = RTC_ASYNCH_PREDIV;
  RtcHandle.Init.SynchPrediv    = RTC_SYNCH_PREDIV;
 801f25e:	f647 73ff 	movw	r3, #32767	; 0x7fff
  RtcHandle.Init.HourFormat     = RTC_HOURFORMAT_24;
 801f262:	e9c0 2400 	strd	r2, r4, [r0]
  RtcHandle.Init.SynchPrediv    = RTC_SYNCH_PREDIV;
 801f266:	e9c0 4302 	strd	r4, r3, [r0, #8]
  RtcHandle.Init.OutPut         = RTC_OUTPUT_DISABLE;
  RtcHandle.Init.OutPutPolarity = RTC_OUTPUT_POLARITY_HIGH;
  RtcHandle.Init.OutPutType     = RTC_OUTPUT_TYPE_OPENDRAIN;
 801f26a:	e9c0 4406 	strd	r4, r4, [r0, #24]
  RtcHandle.Init.OutPut         = RTC_OUTPUT_DISABLE;
 801f26e:	6104      	str	r4, [r0, #16]
  if(HAL_RTC_Init(&RtcHandle) != HAL_OK)
 801f270:	f7f4 fd4a 	bl	8013d08 <HAL_RTC_Init>
 801f274:	b908      	cbnz	r0, 801f27a <initPowerController+0x4a>
  {
    /* Initialization Error */
    while(1);
  }
  return 0 ;
}
 801f276:	b003      	add	sp, #12
 801f278:	bd30      	pop	{r4, r5, pc}
    while(1);
 801f27a:	e7fe      	b.n	801f27a <initPowerController+0x4a>
 801f27c:	2001069c 	.word	0x2001069c
 801f280:	40021000 	.word	0x40021000
 801f284:	20013504 	.word	0x20013504
 801f288:	40002800 	.word	0x40002800

0801f28c <vPortSuppressTicksAndSleep>:
  uint32_t tickIn,tickOut;
  uint32_t missedTicks;
  volatile uint32_t DR,TRin,TRout;

#if (SENSING1_USE_PWR_MGNT == 0)
  minPowerMode = IDLE_WFI;
 801f28c:	4b01      	ldr	r3, [pc, #4]	; (801f294 <vPortSuppressTicksAndSleep+0x8>)
 801f28e:	2201      	movs	r2, #1
 801f290:	701a      	strb	r2, [r3, #0]
  HAL_ResumeTick();
  HAL_RTCEx_DeactivateWakeUpTimer(&RtcHandle);
#ifdef DEBUG_PM
  SENSING1_PRINTF( "zz %d ms\r\n",missedTicks );
#endif
}
 801f292:	4770      	bx	lr
 801f294:	2001069c 	.word	0x2001069c

0801f298 <EnableMotionSensors>:
/** @brief enable all the Inertial MEMS1 sensors
 * @param None
 * @retval None
 */
void EnableMotionSensors (void)
{
 801f298:	b510      	push	{r4, lr}
  if(TargetBoardFeatures.HandleAccSensor != SENSING1_SNS_NOT_VALID) {
 801f29a:	4c1c      	ldr	r4, [pc, #112]	; (801f30c <EnableMotionSensors+0x74>)
 801f29c:	69a0      	ldr	r0, [r4, #24]
 801f29e:	f242 730f 	movw	r3, #9999	; 0x270f
 801f2a2:	4298      	cmp	r0, r3
 801f2a4:	d125      	bne.n	801f2f2 <EnableMotionSensors+0x5a>
    if(MOTION_SENSOR_Enable(TargetBoardFeatures.HandleAccSensor, MOTION_ACCELERO)==BSP_ERROR_NONE) {
      SENSING1_PRINTF("Enabled Accelero Sensor\r\n");
    }
  }

  if(TargetBoardFeatures.HandleGyroSensor != SENSING1_SNS_NOT_VALID) {
 801f2a6:	69e0      	ldr	r0, [r4, #28]
 801f2a8:	f242 730f 	movw	r3, #9999	; 0x270f
 801f2ac:	4298      	cmp	r0, r3
 801f2ae:	d113      	bne.n	801f2d8 <EnableMotionSensors+0x40>
    if(MOTION_SENSOR_Enable(TargetBoardFeatures.HandleGyroSensor, MOTION_GYRO)==BSP_ERROR_NONE) {
      SENSING1_PRINTF("Enabled Gyroscope Sensor\r\n");
    }
  }

  if(TargetBoardFeatures.HandleMagSensor != SENSING1_SNS_NOT_VALID) {
 801f2b0:	6a20      	ldr	r0, [r4, #32]
 801f2b2:	f242 730f 	movw	r3, #9999	; 0x270f
 801f2b6:	4298      	cmp	r0, r3
 801f2b8:	d100      	bne.n	801f2bc <EnableMotionSensors+0x24>
    if(MOTION_SENSOR_Enable(TargetBoardFeatures.HandleMagSensor, MOTION_MAGNETO)==BSP_ERROR_NONE) {
      SENSING1_PRINTF("Enabled Magneto Sensor\r\n");
    }
  }
}
 801f2ba:	bd10      	pop	{r4, pc}
    if(MOTION_SENSOR_Enable(TargetBoardFeatures.HandleMagSensor, MOTION_MAGNETO)==BSP_ERROR_NONE) {
 801f2bc:	2104      	movs	r1, #4
 801f2be:	f7ed fac1 	bl	800c844 <BSP_MOTION_SENSOR_Enable>
 801f2c2:	2800      	cmp	r0, #0
 801f2c4:	d1f9      	bne.n	801f2ba <EnableMotionSensors+0x22>
      SENSING1_PRINTF("Enabled Magneto Sensor\r\n");
 801f2c6:	4b12      	ldr	r3, [pc, #72]	; (801f310 <EnableMotionSensors+0x78>)
 801f2c8:	781b      	ldrb	r3, [r3, #0]
 801f2ca:	2b00      	cmp	r3, #0
 801f2cc:	d0f5      	beq.n	801f2ba <EnableMotionSensors+0x22>
}
 801f2ce:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
      SENSING1_PRINTF("Enabled Magneto Sensor\r\n");
 801f2d2:	4810      	ldr	r0, [pc, #64]	; (801f314 <EnableMotionSensors+0x7c>)
 801f2d4:	f008 bf3e 	b.w	8028154 <puts>
    if(MOTION_SENSOR_Enable(TargetBoardFeatures.HandleGyroSensor, MOTION_GYRO)==BSP_ERROR_NONE) {
 801f2d8:	2101      	movs	r1, #1
 801f2da:	f7ed fab3 	bl	800c844 <BSP_MOTION_SENSOR_Enable>
 801f2de:	2800      	cmp	r0, #0
 801f2e0:	d1e6      	bne.n	801f2b0 <EnableMotionSensors+0x18>
      SENSING1_PRINTF("Enabled Gyroscope Sensor\r\n");
 801f2e2:	4b0b      	ldr	r3, [pc, #44]	; (801f310 <EnableMotionSensors+0x78>)
 801f2e4:	781b      	ldrb	r3, [r3, #0]
 801f2e6:	2b00      	cmp	r3, #0
 801f2e8:	d0e2      	beq.n	801f2b0 <EnableMotionSensors+0x18>
 801f2ea:	480b      	ldr	r0, [pc, #44]	; (801f318 <EnableMotionSensors+0x80>)
 801f2ec:	f008 ff32 	bl	8028154 <puts>
 801f2f0:	e7de      	b.n	801f2b0 <EnableMotionSensors+0x18>
    if(MOTION_SENSOR_Enable(TargetBoardFeatures.HandleAccSensor, MOTION_ACCELERO)==BSP_ERROR_NONE) {
 801f2f2:	2102      	movs	r1, #2
 801f2f4:	f7ed faa6 	bl	800c844 <BSP_MOTION_SENSOR_Enable>
 801f2f8:	2800      	cmp	r0, #0
 801f2fa:	d1d4      	bne.n	801f2a6 <EnableMotionSensors+0xe>
      SENSING1_PRINTF("Enabled Accelero Sensor\r\n");
 801f2fc:	4b04      	ldr	r3, [pc, #16]	; (801f310 <EnableMotionSensors+0x78>)
 801f2fe:	781b      	ldrb	r3, [r3, #0]
 801f300:	2b00      	cmp	r3, #0
 801f302:	d0d0      	beq.n	801f2a6 <EnableMotionSensors+0xe>
 801f304:	4805      	ldr	r0, [pc, #20]	; (801f31c <EnableMotionSensors+0x84>)
 801f306:	f008 ff25 	bl	8028154 <puts>
 801f30a:	e7cc      	b.n	801f2a6 <EnableMotionSensors+0xe>
 801f30c:	200106a4 	.word	0x200106a4
 801f310:	20000d84 	.word	0x20000d84
 801f314:	08042554 	.word	0x08042554
 801f318:	08042538 	.word	0x08042538
 801f31c:	0804251c 	.word	0x0804251c

0801f320 <DisableMotionSensors>:
/** @brief disable all the Inertial MEMS1 sensors
 * @param None
 * @retval None
 */
void DisableMotionSensors (void)
{
 801f320:	b510      	push	{r4, lr}
  if(TargetBoardFeatures.HandleAccSensor != SENSING1_SNS_NOT_VALID) {
 801f322:	4c1c      	ldr	r4, [pc, #112]	; (801f394 <DisableMotionSensors+0x74>)
 801f324:	69a0      	ldr	r0, [r4, #24]
 801f326:	f242 730f 	movw	r3, #9999	; 0x270f
 801f32a:	4298      	cmp	r0, r3
 801f32c:	d125      	bne.n	801f37a <DisableMotionSensors+0x5a>
    if(MOTION_SENSOR_Disable(TargetBoardFeatures.HandleAccSensor, MOTION_ACCELERO)==BSP_ERROR_NONE) {
      SENSING1_PRINTF("Disabled Accelero Sensor\r\n");
    }
  }

  if(TargetBoardFeatures.HandleGyroSensor != SENSING1_SNS_NOT_VALID) {
 801f32e:	69e0      	ldr	r0, [r4, #28]
 801f330:	f242 730f 	movw	r3, #9999	; 0x270f
 801f334:	4298      	cmp	r0, r3
 801f336:	d113      	bne.n	801f360 <DisableMotionSensors+0x40>
    if(MOTION_SENSOR_Disable(TargetBoardFeatures.HandleGyroSensor, MOTION_GYRO)==BSP_ERROR_NONE) {
      SENSING1_PRINTF("Disabled Gyroscope Sensor\r\n");
    }
  }

  if(TargetBoardFeatures.HandleMagSensor != SENSING1_SNS_NOT_VALID) {
 801f338:	6a20      	ldr	r0, [r4, #32]
 801f33a:	f242 730f 	movw	r3, #9999	; 0x270f
 801f33e:	4298      	cmp	r0, r3
 801f340:	d100      	bne.n	801f344 <DisableMotionSensors+0x24>
    if(MOTION_SENSOR_Disable(TargetBoardFeatures.HandleMagSensor, MOTION_MAGNETO)==BSP_ERROR_NONE) {
      SENSING1_PRINTF("Disabled Magneto Sensor\r\n");
    }
  }
}
 801f342:	bd10      	pop	{r4, pc}
    if(MOTION_SENSOR_Disable(TargetBoardFeatures.HandleMagSensor, MOTION_MAGNETO)==BSP_ERROR_NONE) {
 801f344:	2104      	movs	r1, #4
 801f346:	f7ed fab1 	bl	800c8ac <BSP_MOTION_SENSOR_Disable>
 801f34a:	2800      	cmp	r0, #0
 801f34c:	d1f9      	bne.n	801f342 <DisableMotionSensors+0x22>
      SENSING1_PRINTF("Disabled Magneto Sensor\r\n");
 801f34e:	4b12      	ldr	r3, [pc, #72]	; (801f398 <DisableMotionSensors+0x78>)
 801f350:	781b      	ldrb	r3, [r3, #0]
 801f352:	2b00      	cmp	r3, #0
 801f354:	d0f5      	beq.n	801f342 <DisableMotionSensors+0x22>
}
 801f356:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
      SENSING1_PRINTF("Disabled Magneto Sensor\r\n");
 801f35a:	4810      	ldr	r0, [pc, #64]	; (801f39c <DisableMotionSensors+0x7c>)
 801f35c:	f008 befa 	b.w	8028154 <puts>
    if(MOTION_SENSOR_Disable(TargetBoardFeatures.HandleGyroSensor, MOTION_GYRO)==BSP_ERROR_NONE) {
 801f360:	2101      	movs	r1, #1
 801f362:	f7ed faa3 	bl	800c8ac <BSP_MOTION_SENSOR_Disable>
 801f366:	2800      	cmp	r0, #0
 801f368:	d1e6      	bne.n	801f338 <DisableMotionSensors+0x18>
      SENSING1_PRINTF("Disabled Gyroscope Sensor\r\n");
 801f36a:	4b0b      	ldr	r3, [pc, #44]	; (801f398 <DisableMotionSensors+0x78>)
 801f36c:	781b      	ldrb	r3, [r3, #0]
 801f36e:	2b00      	cmp	r3, #0
 801f370:	d0e2      	beq.n	801f338 <DisableMotionSensors+0x18>
 801f372:	480b      	ldr	r0, [pc, #44]	; (801f3a0 <DisableMotionSensors+0x80>)
 801f374:	f008 feee 	bl	8028154 <puts>
 801f378:	e7de      	b.n	801f338 <DisableMotionSensors+0x18>
    if(MOTION_SENSOR_Disable(TargetBoardFeatures.HandleAccSensor, MOTION_ACCELERO)==BSP_ERROR_NONE) {
 801f37a:	2102      	movs	r1, #2
 801f37c:	f7ed fa96 	bl	800c8ac <BSP_MOTION_SENSOR_Disable>
 801f380:	2800      	cmp	r0, #0
 801f382:	d1d4      	bne.n	801f32e <DisableMotionSensors+0xe>
      SENSING1_PRINTF("Disabled Accelero Sensor\r\n");
 801f384:	4b04      	ldr	r3, [pc, #16]	; (801f398 <DisableMotionSensors+0x78>)
 801f386:	781b      	ldrb	r3, [r3, #0]
 801f388:	2b00      	cmp	r3, #0
 801f38a:	d0d0      	beq.n	801f32e <DisableMotionSensors+0xe>
 801f38c:	4805      	ldr	r0, [pc, #20]	; (801f3a4 <DisableMotionSensors+0x84>)
 801f38e:	f008 fee1 	bl	8028154 <puts>
 801f392:	e7cc      	b.n	801f32e <DisableMotionSensors+0xe>
 801f394:	200106a4 	.word	0x200106a4
 801f398:	20000d84 	.word	0x20000d84
 801f39c:	080425a4 	.word	0x080425a4
 801f3a0:	08042588 	.word	0x08042588
 801f3a4:	0804256c 	.word	0x0804256c

0801f3a8 <EnableEnvSensors>:
/** @brief enable all the Environmental MEMS1 sensors
 * @param None
 * @retval None
 */
void EnableEnvSensors (void)
{
 801f3a8:	b538      	push	{r3, r4, r5, lr}
  if(TargetBoardFeatures.HandleHumSensor != SENSING1_SNS_NOT_VALID) {
 801f3aa:	4c20      	ldr	r4, [pc, #128]	; (801f42c <EnableEnvSensors+0x84>)
 801f3ac:	6960      	ldr	r0, [r4, #20]
 801f3ae:	f242 730f 	movw	r3, #9999	; 0x270f
 801f3b2:	4298      	cmp	r0, r3
 801f3b4:	d108      	bne.n	801f3c8 <EnableEnvSensors+0x20>
#endif /* ONE_SHOT */
      }
    }
  }

  if(TargetBoardFeatures.HandlePressSensor != SENSING1_SNS_NOT_VALID) {
 801f3b6:	6920      	ldr	r0, [r4, #16]
 801f3b8:	f242 730f 	movw	r3, #9999	; 0x270f
 801f3bc:	4298      	cmp	r0, r3
 801f3be:	d118      	bne.n	801f3f2 <EnableEnvSensors+0x4a>
#endif /* ONE_SHOT */
      }
    }
  }

  TargetBoardFeatures.EnvSensorEnabled= 1;
 801f3c0:	2301      	movs	r3, #1
 801f3c2:	f884 303c 	strb.w	r3, [r4, #60]	; 0x3c
}
 801f3c6:	bd38      	pop	{r3, r4, r5, pc}
    if(ENV_SENSOR_Enable(TargetBoardFeatures.HandleHumSensor, ENV_HUMIDITY)==BSP_ERROR_NONE) {
 801f3c8:	2104      	movs	r1, #4
 801f3ca:	f7ed f909 	bl	800c5e0 <BSP_ENV_SENSOR_Enable>
 801f3ce:	2800      	cmp	r0, #0
 801f3d0:	d1f1      	bne.n	801f3b6 <EnableEnvSensors+0xe>
      SENSING1_PRINTF("Enabled Humidity Sensor (One Shot)\r\n");
 801f3d2:	4d17      	ldr	r5, [pc, #92]	; (801f430 <EnableEnvSensors+0x88>)
 801f3d4:	782b      	ldrb	r3, [r5, #0]
 801f3d6:	bb2b      	cbnz	r3, 801f424 <EnableEnvSensors+0x7c>
      if(ENV_SENSOR_Enable(TargetBoardFeatures.HandleTempSensors[0], ENV_TEMPERATURE)==BSP_ERROR_NONE) {
 801f3d8:	68a0      	ldr	r0, [r4, #8]
 801f3da:	2101      	movs	r1, #1
 801f3dc:	f7ed f900 	bl	800c5e0 <BSP_ENV_SENSOR_Enable>
 801f3e0:	2800      	cmp	r0, #0
 801f3e2:	d1e8      	bne.n	801f3b6 <EnableEnvSensors+0xe>
        SENSING1_PRINTF("Enabled Temperature Sensor1 (One Shot)\r\n");
 801f3e4:	782b      	ldrb	r3, [r5, #0]
 801f3e6:	2b00      	cmp	r3, #0
 801f3e8:	d0e5      	beq.n	801f3b6 <EnableEnvSensors+0xe>
 801f3ea:	4812      	ldr	r0, [pc, #72]	; (801f434 <EnableEnvSensors+0x8c>)
 801f3ec:	f008 feb2 	bl	8028154 <puts>
 801f3f0:	e7e1      	b.n	801f3b6 <EnableEnvSensors+0xe>
    if(ENV_SENSOR_Enable(TargetBoardFeatures.HandlePressSensor, ENV_PRESSURE)==BSP_ERROR_NONE) {
 801f3f2:	2102      	movs	r1, #2
 801f3f4:	f7ed f8f4 	bl	800c5e0 <BSP_ENV_SENSOR_Enable>
 801f3f8:	2800      	cmp	r0, #0
 801f3fa:	d1e1      	bne.n	801f3c0 <EnableEnvSensors+0x18>
      SENSING1_PRINTF("Enabled Pressure Sensor (One Shot)\r\n");
 801f3fc:	4d0c      	ldr	r5, [pc, #48]	; (801f430 <EnableEnvSensors+0x88>)
 801f3fe:	782b      	ldrb	r3, [r5, #0]
 801f400:	b963      	cbnz	r3, 801f41c <EnableEnvSensors+0x74>
      if(ENV_SENSOR_Enable(TargetBoardFeatures.HandleTempSensors[1], ENV_TEMPERATURE)==BSP_ERROR_NONE) {
 801f402:	68e0      	ldr	r0, [r4, #12]
 801f404:	2101      	movs	r1, #1
 801f406:	f7ed f8eb 	bl	800c5e0 <BSP_ENV_SENSOR_Enable>
 801f40a:	2800      	cmp	r0, #0
 801f40c:	d1d8      	bne.n	801f3c0 <EnableEnvSensors+0x18>
        SENSING1_PRINTF("Enabled Temperature Sensor2 (One Shot)\r\n");
 801f40e:	782b      	ldrb	r3, [r5, #0]
 801f410:	2b00      	cmp	r3, #0
 801f412:	d0d5      	beq.n	801f3c0 <EnableEnvSensors+0x18>
 801f414:	4808      	ldr	r0, [pc, #32]	; (801f438 <EnableEnvSensors+0x90>)
 801f416:	f008 fe9d 	bl	8028154 <puts>
 801f41a:	e7d1      	b.n	801f3c0 <EnableEnvSensors+0x18>
      SENSING1_PRINTF("Enabled Pressure Sensor (One Shot)\r\n");
 801f41c:	4807      	ldr	r0, [pc, #28]	; (801f43c <EnableEnvSensors+0x94>)
 801f41e:	f008 fe99 	bl	8028154 <puts>
 801f422:	e7ee      	b.n	801f402 <EnableEnvSensors+0x5a>
      SENSING1_PRINTF("Enabled Humidity Sensor (One Shot)\r\n");
 801f424:	4806      	ldr	r0, [pc, #24]	; (801f440 <EnableEnvSensors+0x98>)
 801f426:	f008 fe95 	bl	8028154 <puts>
 801f42a:	e7d5      	b.n	801f3d8 <EnableEnvSensors+0x30>
 801f42c:	200106a4 	.word	0x200106a4
 801f430:	20000d84 	.word	0x20000d84
 801f434:	080425e4 	.word	0x080425e4
 801f438:	08042630 	.word	0x08042630
 801f43c:	0804260c 	.word	0x0804260c
 801f440:	080425c0 	.word	0x080425c0

0801f444 <DisableEnvSensors>:
/** @brief disable all the Environmental MEMS1 sensors
 * @param None
 * @retval None
 */
void DisableEnvSensors (void)
{
 801f444:	b510      	push	{r4, lr}
  if(TargetBoardFeatures.HandleHumSensor != SENSING1_SNS_NOT_VALID) {
 801f446:	4c20      	ldr	r4, [pc, #128]	; (801f4c8 <DisableEnvSensors+0x84>)
 801f448:	6960      	ldr	r0, [r4, #20]
 801f44a:	f242 730f 	movw	r3, #9999	; 0x270f
 801f44e:	4298      	cmp	r0, r3
 801f450:	d108      	bne.n	801f464 <DisableEnvSensors+0x20>
    if(ENV_SENSOR_Disable(TargetBoardFeatures.HandleTempSensors[0], ENV_TEMPERATURE)==BSP_ERROR_NONE) {
      SENSING1_PRINTF("Disabled Temperature Sensor1\r\n");
    }
  }

  if(TargetBoardFeatures.HandlePressSensor != SENSING1_SNS_NOT_VALID) {
 801f452:	6920      	ldr	r0, [r4, #16]
 801f454:	f242 730f 	movw	r3, #9999	; 0x270f
 801f458:	4298      	cmp	r0, r3
 801f45a:	d118      	bne.n	801f48e <DisableEnvSensors+0x4a>
    if(ENV_SENSOR_Disable(TargetBoardFeatures.HandleTempSensors[1], ENV_TEMPERATURE)==BSP_ERROR_NONE) {
      SENSING1_PRINTF("Disabled Temperature Sensor2\r\n");
    }
  }

  TargetBoardFeatures.EnvSensorEnabled= 0;
 801f45c:	2300      	movs	r3, #0
 801f45e:	f884 303c 	strb.w	r3, [r4, #60]	; 0x3c
}
 801f462:	bd10      	pop	{r4, pc}
    if(ENV_SENSOR_Disable(TargetBoardFeatures.HandleHumSensor, ENV_HUMIDITY)==BSP_ERROR_NONE) {
 801f464:	2104      	movs	r1, #4
 801f466:	f7ed f8ef 	bl	800c648 <BSP_ENV_SENSOR_Disable>
 801f46a:	b910      	cbnz	r0, 801f472 <DisableEnvSensors+0x2e>
      SENSING1_PRINTF("Disabled Humidity Sensor\r\n");
 801f46c:	4b17      	ldr	r3, [pc, #92]	; (801f4cc <DisableEnvSensors+0x88>)
 801f46e:	781b      	ldrb	r3, [r3, #0]
 801f470:	bb33      	cbnz	r3, 801f4c0 <DisableEnvSensors+0x7c>
    if(ENV_SENSOR_Disable(TargetBoardFeatures.HandleTempSensors[0], ENV_TEMPERATURE)==BSP_ERROR_NONE) {
 801f472:	68a0      	ldr	r0, [r4, #8]
 801f474:	2101      	movs	r1, #1
 801f476:	f7ed f8e7 	bl	800c648 <BSP_ENV_SENSOR_Disable>
 801f47a:	2800      	cmp	r0, #0
 801f47c:	d1e9      	bne.n	801f452 <DisableEnvSensors+0xe>
      SENSING1_PRINTF("Disabled Temperature Sensor1\r\n");
 801f47e:	4b13      	ldr	r3, [pc, #76]	; (801f4cc <DisableEnvSensors+0x88>)
 801f480:	781b      	ldrb	r3, [r3, #0]
 801f482:	2b00      	cmp	r3, #0
 801f484:	d0e5      	beq.n	801f452 <DisableEnvSensors+0xe>
 801f486:	4812      	ldr	r0, [pc, #72]	; (801f4d0 <DisableEnvSensors+0x8c>)
 801f488:	f008 fe64 	bl	8028154 <puts>
 801f48c:	e7e1      	b.n	801f452 <DisableEnvSensors+0xe>
    if(ENV_SENSOR_Disable(TargetBoardFeatures.HandlePressSensor, ENV_PRESSURE)==BSP_ERROR_NONE) {
 801f48e:	2102      	movs	r1, #2
 801f490:	f7ed f8da 	bl	800c648 <BSP_ENV_SENSOR_Disable>
 801f494:	b910      	cbnz	r0, 801f49c <DisableEnvSensors+0x58>
      SENSING1_PRINTF("Disabled Pressure Sensor\r\n");
 801f496:	4b0d      	ldr	r3, [pc, #52]	; (801f4cc <DisableEnvSensors+0x88>)
 801f498:	781b      	ldrb	r3, [r3, #0]
 801f49a:	b96b      	cbnz	r3, 801f4b8 <DisableEnvSensors+0x74>
    if(ENV_SENSOR_Disable(TargetBoardFeatures.HandleTempSensors[1], ENV_TEMPERATURE)==BSP_ERROR_NONE) {
 801f49c:	68e0      	ldr	r0, [r4, #12]
 801f49e:	2101      	movs	r1, #1
 801f4a0:	f7ed f8d2 	bl	800c648 <BSP_ENV_SENSOR_Disable>
 801f4a4:	2800      	cmp	r0, #0
 801f4a6:	d1d9      	bne.n	801f45c <DisableEnvSensors+0x18>
      SENSING1_PRINTF("Disabled Temperature Sensor2\r\n");
 801f4a8:	4b08      	ldr	r3, [pc, #32]	; (801f4cc <DisableEnvSensors+0x88>)
 801f4aa:	781b      	ldrb	r3, [r3, #0]
 801f4ac:	2b00      	cmp	r3, #0
 801f4ae:	d0d5      	beq.n	801f45c <DisableEnvSensors+0x18>
 801f4b0:	4808      	ldr	r0, [pc, #32]	; (801f4d4 <DisableEnvSensors+0x90>)
 801f4b2:	f008 fe4f 	bl	8028154 <puts>
 801f4b6:	e7d1      	b.n	801f45c <DisableEnvSensors+0x18>
      SENSING1_PRINTF("Disabled Pressure Sensor\r\n");
 801f4b8:	4807      	ldr	r0, [pc, #28]	; (801f4d8 <DisableEnvSensors+0x94>)
 801f4ba:	f008 fe4b 	bl	8028154 <puts>
 801f4be:	e7ed      	b.n	801f49c <DisableEnvSensors+0x58>
      SENSING1_PRINTF("Disabled Humidity Sensor\r\n");
 801f4c0:	4806      	ldr	r0, [pc, #24]	; (801f4dc <DisableEnvSensors+0x98>)
 801f4c2:	f008 fe47 	bl	8028154 <puts>
 801f4c6:	e7d4      	b.n	801f472 <DisableEnvSensors+0x2e>
 801f4c8:	200106a4 	.word	0x200106a4
 801f4cc:	20000d84 	.word	0x20000d84
 801f4d0:	08042674 	.word	0x08042674
 801f4d4:	080426b0 	.word	0x080426b0
 801f4d8:	08042694 	.word	0x08042694
 801f4dc:	08042658 	.word	0x08042658

0801f4e0 <InitMics>:
/** @brief Initialize all the MEMS's Microphones
 * @param None
 * @retval None
 */
void InitMics(uint32_t AudioFreq)
{
 801f4e0:	b538      	push	{r3, r4, r5, lr}
  MicParams.BitsPerSample = 16;
 801f4e2:	4c14      	ldr	r4, [pc, #80]	; (801f534 <InitMics+0x54>)
  MicParams.ChannelsNbr = AUDIO_CHANNELS;
 801f4e4:	2310      	movs	r3, #16
 801f4e6:	2101      	movs	r1, #1
 801f4e8:	e9c4 3112 	strd	r3, r1, [r4, #72]	; 0x48
  MicParams.SampleRate = AudioFreq;
 801f4ec:	e9c4 3010 	strd	r3, r0, [r4, #64]	; 0x40
  MicParams.Volume = TargetBoardFeatures.AudioVolume;
 801f4f0:	6ba2      	ldr	r2, [r4, #56]	; 0x38
 801f4f2:	6522      	str	r2, [r4, #80]	; 0x50
{
 801f4f4:	4605      	mov	r5, r0
  ret = BSP_AUDIO_IN_Init(AUDIO_INSTANCE, &MicParams);
 801f4f6:	f104 0140 	add.w	r1, r4, #64	; 0x40
 801f4fa:	2000      	movs	r0, #0
 801f4fc:	f7ec f9b2 	bl	800b864 <BSP_AUDIO_IN_Init>
    SENSING1_PRINTF("\nError Audio Init\r\n");
 801f500:	4b0d      	ldr	r3, [pc, #52]	; (801f538 <InitMics+0x58>)
  if(ret != BSP_ERROR_NONE) {
 801f502:	b2c0      	uxtb	r0, r0
    SENSING1_PRINTF("\nError Audio Init\r\n");
 801f504:	781b      	ldrb	r3, [r3, #0]
  if(ret != BSP_ERROR_NONE) {
 801f506:	b108      	cbz	r0, 801f50c <InitMics+0x2c>
    SENSING1_PRINTF("\nError Audio Init\r\n");
 801f508:	b97b      	cbnz	r3, 801f52a <InitMics+0x4a>
    while(1) {
 801f50a:	e7fe      	b.n	801f50a <InitMics+0x2a>
    SENSING1_PRINTF("\nOK Audio Init\t(Audio Freq.= %ld)\r\n", AudioFreq);
 801f50c:	b943      	cbnz	r3, 801f520 <InitMics+0x40>
  TargetBoardFeatures.NumMicSensors=AUDIO_CHANNELS;
 801f50e:	2301      	movs	r3, #1
 801f510:	6363      	str	r3, [r4, #52]	; 0x34
#if defined(USE_STM32L4XX_NUCLEO)
  BSP_AUDIO_IN_Record(AUDIO_INSTANCE, (uint8_t *) PCM_Buffer, 0);
#elif defined(STM32_SENSORTILE)
  BSP_AUDIO_IN_Record(AUDIO_INSTANCE, (uint8_t *) PCM_Buffer, PCM_AUDIO_IN_SAMPLES*2);
#elif defined(USE_STM32L475E_IOT01)
  BSP_AUDIO_IN_Record(AUDIO_INSTANCE, (uint8_t *) PCM_Buffer, PCM_AUDIO_IN_SAMPLES*4);
 801f512:	490a      	ldr	r1, [pc, #40]	; (801f53c <InitMics+0x5c>)
#elif defined(STM32_SENSORTILEBOX)
  BSP_AUDIO_IN_Record(AUDIO_INSTANCE, (uint8_t *) PCM_Buffer, PCM_AUDIO_IN_SAMPLES*2);
#else
  #error "Platform not supported"
#endif /* USE_STM32L4XX_NUCLEO */
}
 801f514:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  BSP_AUDIO_IN_Record(AUDIO_INSTANCE, (uint8_t *) PCM_Buffer, PCM_AUDIO_IN_SAMPLES*4);
 801f518:	2240      	movs	r2, #64	; 0x40
 801f51a:	2000      	movs	r0, #0
 801f51c:	f7ec b8e8 	b.w	800b6f0 <BSP_AUDIO_IN_Record>
    SENSING1_PRINTF("\nOK Audio Init\t(Audio Freq.= %ld)\r\n", AudioFreq);
 801f520:	4629      	mov	r1, r5
 801f522:	4807      	ldr	r0, [pc, #28]	; (801f540 <InitMics+0x60>)
 801f524:	f008 fd7a 	bl	802801c <iprintf>
 801f528:	e7f1      	b.n	801f50e <InitMics+0x2e>
    SENSING1_PRINTF("\nError Audio Init\r\n");
 801f52a:	4806      	ldr	r0, [pc, #24]	; (801f544 <InitMics+0x64>)
 801f52c:	f008 fe12 	bl	8028154 <puts>
 801f530:	e7eb      	b.n	801f50a <InitMics+0x2a>
 801f532:	bf00      	nop
 801f534:	200106a4 	.word	0x200106a4
 801f538:	20000d84 	.word	0x20000d84
 801f53c:	200106f8 	.word	0x200106f8
 801f540:	080426e4 	.word	0x080426e4
 801f544:	080426d0 	.word	0x080426d0

0801f548 <DeInitMics>:
/** @brief DeInitialize all the MEMS's Microphones
 * @param None
 * @retval None
 */
void DeInitMics(void)
{
 801f548:	b508      	push	{r3, lr}
  uint8_t ret = BSP_ERROR_NONE;

  BSP_AUDIO_IN_Stop(AUDIO_INSTANCE);
 801f54a:	2000      	movs	r0, #0
 801f54c:	f7ec f916 	bl	800b77c <BSP_AUDIO_IN_Stop>

  /* The ADC could be used also for Battery Charger */
  ret = BSP_AUDIO_IN_DeInit(AUDIO_INSTANCE);
 801f550:	2000      	movs	r0, #0
 801f552:	f7ec f865 	bl	800b620 <BSP_AUDIO_IN_DeInit>

  if (ret != BSP_ERROR_NONE) {
    SENSING1_PRINTF("Error Audio DeInit\r\n");
 801f556:	4b08      	ldr	r3, [pc, #32]	; (801f578 <DeInitMics+0x30>)
  if (ret != BSP_ERROR_NONE) {
 801f558:	b2c0      	uxtb	r0, r0
    SENSING1_PRINTF("Error Audio DeInit\r\n");
 801f55a:	781b      	ldrb	r3, [r3, #0]
  if (ret != BSP_ERROR_NONE) {
 801f55c:	b108      	cbz	r0, 801f562 <DeInitMics+0x1a>
    SENSING1_PRINTF("Error Audio DeInit\r\n");
 801f55e:	b93b      	cbnz	r3, 801f570 <DeInitMics+0x28>
    while(1);
 801f560:	e7fe      	b.n	801f560 <DeInitMics+0x18>
  } else {
    SENSING1_PRINTF("OK Audio DeInit\r\n");
 801f562:	b903      	cbnz	r3, 801f566 <DeInitMics+0x1e>
  }
}
 801f564:	bd08      	pop	{r3, pc}
 801f566:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    SENSING1_PRINTF("OK Audio DeInit\r\n");
 801f56a:	4804      	ldr	r0, [pc, #16]	; (801f57c <DeInitMics+0x34>)
 801f56c:	f008 bdf2 	b.w	8028154 <puts>
    SENSING1_PRINTF("Error Audio DeInit\r\n");
 801f570:	4803      	ldr	r0, [pc, #12]	; (801f580 <DeInitMics+0x38>)
 801f572:	f008 fdef 	bl	8028154 <puts>
 801f576:	e7f3      	b.n	801f560 <DeInitMics+0x18>
 801f578:	20000d84 	.word	0x20000d84
 801f57c:	0804271c 	.word	0x0804271c
 801f580:	08042708 	.word	0x08042708

0801f584 <InitUSBMSC>:
 * @brief  Initialize USB Mass Storage Device
 * @param  None
 * @retval None
 */
void InitUSBMSC(void)
{
 801f584:	b508      	push	{r3, lr}
  SENSING1_PRINTF("Starting USB Mass Storage Device mode\r\n");
 801f586:	4b0d      	ldr	r3, [pc, #52]	; (801f5bc <InitUSBMSC+0x38>)
 801f588:	781b      	ldrb	r3, [r3, #0]
 801f58a:	b99b      	cbnz	r3, 801f5b4 <InitUSBMSC+0x30>
  HAL_PWREx_EnableVddUSB();
 801f58c:	f7f2 fca8 	bl	8011ee0 <HAL_PWREx_EnableVddUSB>
  USBD_Init(&hUSBDevice, &USBD_Desc, 0);
 801f590:	2200      	movs	r2, #0
 801f592:	490b      	ldr	r1, [pc, #44]	; (801f5c0 <InitUSBMSC+0x3c>)
 801f594:	480b      	ldr	r0, [pc, #44]	; (801f5c4 <InitUSBMSC+0x40>)
 801f596:	f7fd faa7 	bl	801cae8 <USBD_Init>
  USBD_RegisterClass(&hUSBDevice, &USBD_MSC);
 801f59a:	490b      	ldr	r1, [pc, #44]	; (801f5c8 <InitUSBMSC+0x44>)
 801f59c:	4809      	ldr	r0, [pc, #36]	; (801f5c4 <InitUSBMSC+0x40>)
 801f59e:	f7fd facb 	bl	801cb38 <USBD_RegisterClass>
  USBD_MSC_RegisterStorage(&hUSBDevice, &USBD_Storage_Interface_fops_FS);
 801f5a2:	490a      	ldr	r1, [pc, #40]	; (801f5cc <InitUSBMSC+0x48>)
 801f5a4:	4807      	ldr	r0, [pc, #28]	; (801f5c4 <InitUSBMSC+0x40>)
 801f5a6:	f7fc fd13 	bl	801bfd0 <USBD_MSC_RegisterStorage>
  USBD_Start(&hUSBDevice);
}
 801f5aa:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  USBD_Start(&hUSBDevice);
 801f5ae:	4805      	ldr	r0, [pc, #20]	; (801f5c4 <InitUSBMSC+0x40>)
 801f5b0:	f7fd baca 	b.w	801cb48 <USBD_Start>
  SENSING1_PRINTF("Starting USB Mass Storage Device mode\r\n");
 801f5b4:	4806      	ldr	r0, [pc, #24]	; (801f5d0 <InitUSBMSC+0x4c>)
 801f5b6:	f008 fdcd 	bl	8028154 <puts>
 801f5ba:	e7e7      	b.n	801f58c <InitUSBMSC+0x8>
 801f5bc:	20000d84 	.word	0x20000d84
 801f5c0:	20000df0 	.word	0x20000df0
 801f5c4:	20010778 	.word	0x20010778
 801f5c8:	200004b4 	.word	0x200004b4
 801f5cc:	20000e0c 	.word	0x20000e0c
 801f5d0:	08042730 	.word	0x08042730

0801f5d4 <InitTargetPlatform>:
{
 801f5d4:	b530      	push	{r4, r5, lr}
  TargetBoardFeatures.BoardType = BoardType;
 801f5d6:	4c57      	ldr	r4, [pc, #348]	; (801f734 <InitTargetPlatform+0x160>)
{
 801f5d8:	b085      	sub	sp, #20
 801f5da:	4603      	mov	r3, r0
  BSP_PB_Init(BUTTON_USER, BUTTON_MODE_EXTI);
 801f5dc:	2101      	movs	r1, #1
 801f5de:	2000      	movs	r0, #0
  TargetBoardFeatures.BoardType = BoardType;
 801f5e0:	7023      	strb	r3, [r4, #0]
  BSP_PB_Init(BUTTON_USER, BUTTON_MODE_EXTI);
 801f5e2:	f7eb fdf9 	bl	800b1d8 <BSP_PB_Init>
  COM_InitStruct.WordLength = (COM_WordLengthTypeDef) CFG_HW_UART1_WORDLENGTH;
 801f5e6:	2000      	movs	r0, #0
  COM_InitStruct.BaudRate   = CFG_HW_UART1_BAUDRATE;
 801f5e8:	f44f 33e1 	mov.w	r3, #115200	; 0x1c200
  if (BSP_COM_Init(COM1, &COM_InitStruct) != BSP_ERROR_NONE)
 801f5ec:	4669      	mov	r1, sp
  COM_InitStruct.WordLength = (COM_WordLengthTypeDef) CFG_HW_UART1_WORDLENGTH;
 801f5ee:	e9cd 3000 	strd	r3, r0, [sp]
  COM_InitStruct.StopBits   = COM_STOPBITS_1;
 801f5f2:	9002      	str	r0, [sp, #8]
  COM_InitStruct.HwFlowCtl  = COM_HWCONTROL_NONE;
 801f5f4:	f8ad 000c 	strh.w	r0, [sp, #12]
  if (BSP_COM_Init(COM1, &COM_InitStruct) != BSP_ERROR_NONE)
 801f5f8:	f7eb fe80 	bl	800b2fc <BSP_COM_Init>
 801f5fc:	2800      	cmp	r0, #0
 801f5fe:	d161      	bne.n	801f6c4 <InitTargetPlatform+0xf0>
    SENSING1_PRINTF("UART Initialized\r\n");
 801f600:	4d4d      	ldr	r5, [pc, #308]	; (801f738 <InitTargetPlatform+0x164>)
 801f602:	782b      	ldrb	r3, [r5, #0]
 801f604:	2b00      	cmp	r3, #0
 801f606:	d156      	bne.n	801f6b6 <InitTargetPlatform+0xe2>
#if defined(USE_STM32L4XX_NUCLEO)
  BSP_LED_Init(LED2);
#elif defined(STM32_SENSORTILE)
  BSP_LED_Init(LED1);
#elif defined(USE_STM32L475E_IOT01)
  BSP_LED_Init(LED2);
 801f608:	2000      	movs	r0, #0
 801f60a:	f7eb fda7 	bl	800b15c <BSP_LED_Init>
  if (BSP_PB_GetState(BUTTON_USER) == GPIO_PIN_SET)
 801f60e:	2000      	movs	r0, #0
 801f610:	f7eb fe34 	bl	800b27c <BSP_PB_GetState>
 801f614:	2801      	cmp	r0, #1
 801f616:	d052      	beq.n	801f6be <InitTargetPlatform+0xea>
  memset(&TargetBoardFeatures, 0, sizeof(TargetFeatures_t));
 801f618:	2240      	movs	r2, #64	; 0x40
 801f61a:	2100      	movs	r1, #0
 801f61c:	4845      	ldr	r0, [pc, #276]	; (801f734 <InitTargetPlatform+0x160>)
 801f61e:	f007 ffab 	bl	8027578 <memset>
  TargetBoardFeatures.HandleMagSensor  = 1;
 801f622:	2301      	movs	r3, #1
  if (MOTION_SENSOR_Init(TargetBoardFeatures.HandleAccSensor, MOTION_ACCELERO|MOTION_GYRO) == BSP_ERROR_NONE){
 801f624:	2103      	movs	r1, #3
 801f626:	2000      	movs	r0, #0
  TargetBoardFeatures.HandleTempSensors[1] = 1;
 801f628:	e9c4 3303 	strd	r3, r3, [r4, #12]
  TargetBoardFeatures.HandleMagSensor  = 1;
 801f62c:	6223      	str	r3, [r4, #32]
  if (MOTION_SENSOR_Init(TargetBoardFeatures.HandleAccSensor, MOTION_ACCELERO|MOTION_GYRO) == BSP_ERROR_NONE){
 801f62e:	f7ed f875 	bl	800c71c <BSP_MOTION_SENSOR_Init>
    SENSING1_PRINTF("OK Accelero/Gyroscope Sensor\n\r");
 801f632:	782b      	ldrb	r3, [r5, #0]
  if (MOTION_SENSOR_Init(TargetBoardFeatures.HandleAccSensor, MOTION_ACCELERO|MOTION_GYRO) == BSP_ERROR_NONE){
 801f634:	2800      	cmp	r0, #0
 801f636:	d13c      	bne.n	801f6b2 <InitTargetPlatform+0xde>
    SENSING1_PRINTF("OK Accelero/Gyroscope Sensor\n\r");
 801f638:	2b00      	cmp	r3, #0
 801f63a:	d15d      	bne.n	801f6f8 <InitTargetPlatform+0x124>
  Set2GAccelerometerFullScale();
 801f63c:	f002 fb8c 	bl	8021d58 <Set2GAccelerometerFullScale>
  if(MOTION_SENSOR_Init(TargetBoardFeatures.HandleMagSensor, MOTION_MAGNETO)==BSP_ERROR_NONE){
 801f640:	6a20      	ldr	r0, [r4, #32]
 801f642:	2104      	movs	r1, #4
 801f644:	f7ed f86a 	bl	800c71c <BSP_MOTION_SENSOR_Init>
    SENSING1_PRINTF("OK Magneto Sensor\n\r");
 801f648:	782b      	ldrb	r3, [r5, #0]
  if(MOTION_SENSOR_Init(TargetBoardFeatures.HandleMagSensor, MOTION_MAGNETO)==BSP_ERROR_NONE){
 801f64a:	2800      	cmp	r0, #0
 801f64c:	d03e      	beq.n	801f6cc <InitTargetPlatform+0xf8>
    SENSING1_PRINTF("Error Magneto Sensor\n\r");
 801f64e:	2b00      	cmp	r3, #0
 801f650:	d15f      	bne.n	801f712 <InitTargetPlatform+0x13e>
    TargetBoardFeatures.HandleMagSensor = SENSING1_SNS_NOT_VALID;
 801f652:	f242 730f 	movw	r3, #9999	; 0x270f
 801f656:	6223      	str	r3, [r4, #32]
  if(ENV_SENSOR_Init(TargetBoardFeatures.HandleHumSensor, ENV_HUMIDITY|ENV_TEMPERATURE)==BSP_ERROR_NONE){
 801f658:	6960      	ldr	r0, [r4, #20]
 801f65a:	2105      	movs	r1, #5
 801f65c:	f7ec ff26 	bl	800c4ac <BSP_ENV_SENSOR_Init>
    SENSING1_PRINTF("OK Humidity/Temperature1 Sensor\n\r");
 801f660:	782b      	ldrb	r3, [r5, #0]
  if(ENV_SENSOR_Init(TargetBoardFeatures.HandleHumSensor, ENV_HUMIDITY|ENV_TEMPERATURE)==BSP_ERROR_NONE){
 801f662:	2800      	cmp	r0, #0
 801f664:	d13c      	bne.n	801f6e0 <InitTargetPlatform+0x10c>
    SENSING1_PRINTF("OK Humidity/Temperature1 Sensor\n\r");
 801f666:	2b00      	cmp	r3, #0
 801f668:	d15b      	bne.n	801f722 <InitTargetPlatform+0x14e>
    TargetBoardFeatures.NumTempSensors++;
 801f66a:	6863      	ldr	r3, [r4, #4]
 801f66c:	3301      	adds	r3, #1
 801f66e:	6063      	str	r3, [r4, #4]
  if(ENV_SENSOR_Init(TargetBoardFeatures.HandlePressSensor, ENV_PRESSURE|ENV_TEMPERATURE)==BSP_ERROR_NONE){
 801f670:	6920      	ldr	r0, [r4, #16]
 801f672:	2103      	movs	r1, #3
 801f674:	f7ec ff1a 	bl	800c4ac <BSP_ENV_SENSOR_Init>
    SENSING1_PRINTF("OK Pressure/Temperature2 Sensor\n\r");
 801f678:	782b      	ldrb	r3, [r5, #0]
  if(ENV_SENSOR_Init(TargetBoardFeatures.HandlePressSensor, ENV_PRESSURE|ENV_TEMPERATURE)==BSP_ERROR_NONE){
 801f67a:	2800      	cmp	r0, #0
 801f67c:	d136      	bne.n	801f6ec <InitTargetPlatform+0x118>
    SENSING1_PRINTF("OK Pressure/Temperature2 Sensor\n\r");
 801f67e:	2b00      	cmp	r3, #0
 801f680:	d143      	bne.n	801f70a <InitTargetPlatform+0x136>
    TargetBoardFeatures.NumTempSensors++;
 801f682:	6863      	ldr	r3, [r4, #4]
 801f684:	3301      	adds	r3, #1
 801f686:	6063      	str	r3, [r4, #4]
  DisableMotionSensors();
 801f688:	f7ff fe4a 	bl	801f320 <DisableMotionSensors>
  DisableEnvSensors();
 801f68c:	f7ff feda 	bl	801f444 <DisableEnvSensors>
  TargetBoardFeatures.AudioVolume = AUDIO_VOLUME_VALUE;
 801f690:	2320      	movs	r3, #32
 801f692:	63a3      	str	r3, [r4, #56]	; 0x38
  DATALOG_SD_Init();
 801f694:	f7fe ff1a 	bl	801e4cc <DATALOG_SD_Init>
  HAL_Delay(200);
 801f698:	20c8      	movs	r0, #200	; 0xc8
 801f69a:	f003 f98f 	bl	80229bc <HAL_Delay>
  sprintf(DefaultDataFileName,"%s","IoT01");
 801f69e:	4a27      	ldr	r2, [pc, #156]	; (801f73c <InitTargetPlatform+0x168>)
 801f6a0:	4b27      	ldr	r3, [pc, #156]	; (801f740 <InitTargetPlatform+0x16c>)
  SENSING1_PRINTF("\n\r");
 801f6a2:	7829      	ldrb	r1, [r5, #0]
  sprintf(DefaultDataFileName,"%s","IoT01");
 801f6a4:	6810      	ldr	r0, [r2, #0]
 801f6a6:	8892      	ldrh	r2, [r2, #4]
 801f6a8:	6018      	str	r0, [r3, #0]
 801f6aa:	809a      	strh	r2, [r3, #4]
  SENSING1_PRINTF("\n\r");
 801f6ac:	bb41      	cbnz	r1, 801f700 <InitTargetPlatform+0x12c>
}
 801f6ae:	b005      	add	sp, #20
 801f6b0:	bd30      	pop	{r4, r5, pc}
    SENSING1_PRINTF("Error Accelero/Gyroscope Sensor\n\r");
 801f6b2:	b98b      	cbnz	r3, 801f6d8 <InitTargetPlatform+0x104>
    while(1);
 801f6b4:	e7fe      	b.n	801f6b4 <InitTargetPlatform+0xe0>
    SENSING1_PRINTF("UART Initialized\r\n");
 801f6b6:	4823      	ldr	r0, [pc, #140]	; (801f744 <InitTargetPlatform+0x170>)
 801f6b8:	f008 fd4c 	bl	8028154 <puts>
 801f6bc:	e7a4      	b.n	801f608 <InitTargetPlatform+0x34>
    InitUSBMSC();
 801f6be:	f7ff ff61 	bl	801f584 <InitUSBMSC>
    while(1);
 801f6c2:	e7fe      	b.n	801f6c2 <InitTargetPlatform+0xee>
    Error_Handler();
 801f6c4:	f003 f98a 	bl	80229dc <Error_Handler>
 801f6c8:	4d1b      	ldr	r5, [pc, #108]	; (801f738 <InitTargetPlatform+0x164>)
 801f6ca:	e79d      	b.n	801f608 <InitTargetPlatform+0x34>
    SENSING1_PRINTF("OK Magneto Sensor\n\r");
 801f6cc:	2b00      	cmp	r3, #0
 801f6ce:	d0c3      	beq.n	801f658 <InitTargetPlatform+0x84>
 801f6d0:	481d      	ldr	r0, [pc, #116]	; (801f748 <InitTargetPlatform+0x174>)
 801f6d2:	f008 fca3 	bl	802801c <iprintf>
 801f6d6:	e7bf      	b.n	801f658 <InitTargetPlatform+0x84>
    SENSING1_PRINTF("Error Accelero/Gyroscope Sensor\n\r");
 801f6d8:	481c      	ldr	r0, [pc, #112]	; (801f74c <InitTargetPlatform+0x178>)
 801f6da:	f008 fc9f 	bl	802801c <iprintf>
    TargetBoardFeatures.HandleGyroSensor = SENSING1_SNS_NOT_VALID;
 801f6de:	e7e9      	b.n	801f6b4 <InitTargetPlatform+0xe0>
    SENSING1_PRINTF("Error Humidity/Temperature1 Sensor\n\r");
 801f6e0:	bb1b      	cbnz	r3, 801f72a <InitTargetPlatform+0x156>
    TargetBoardFeatures.HandleHumSensor      = SENSING1_SNS_NOT_VALID;
 801f6e2:	f242 730f 	movw	r3, #9999	; 0x270f
 801f6e6:	6163      	str	r3, [r4, #20]
    TargetBoardFeatures.HandleTempSensors[0] = SENSING1_SNS_NOT_VALID;
 801f6e8:	60a3      	str	r3, [r4, #8]
 801f6ea:	e7c1      	b.n	801f670 <InitTargetPlatform+0x9c>
    SENSING1_PRINTF("Error Pressure/Temperature2 Sensor\n\r");
 801f6ec:	b9ab      	cbnz	r3, 801f71a <InitTargetPlatform+0x146>
    TargetBoardFeatures.HandlePressSensor    = SENSING1_SNS_NOT_VALID;
 801f6ee:	f242 730f 	movw	r3, #9999	; 0x270f
    TargetBoardFeatures.HandleTempSensors[1] = SENSING1_SNS_NOT_VALID;
 801f6f2:	e9c4 3303 	strd	r3, r3, [r4, #12]
 801f6f6:	e7c7      	b.n	801f688 <InitTargetPlatform+0xb4>
    SENSING1_PRINTF("OK Accelero/Gyroscope Sensor\n\r");
 801f6f8:	4815      	ldr	r0, [pc, #84]	; (801f750 <InitTargetPlatform+0x17c>)
 801f6fa:	f008 fc8f 	bl	802801c <iprintf>
 801f6fe:	e79d      	b.n	801f63c <InitTargetPlatform+0x68>
  SENSING1_PRINTF("\n\r");
 801f700:	4814      	ldr	r0, [pc, #80]	; (801f754 <InitTargetPlatform+0x180>)
 801f702:	f008 fc8b 	bl	802801c <iprintf>
}
 801f706:	b005      	add	sp, #20
 801f708:	bd30      	pop	{r4, r5, pc}
    SENSING1_PRINTF("OK Pressure/Temperature2 Sensor\n\r");
 801f70a:	4813      	ldr	r0, [pc, #76]	; (801f758 <InitTargetPlatform+0x184>)
 801f70c:	f008 fc86 	bl	802801c <iprintf>
 801f710:	e7b7      	b.n	801f682 <InitTargetPlatform+0xae>
    SENSING1_PRINTF("Error Magneto Sensor\n\r");
 801f712:	4812      	ldr	r0, [pc, #72]	; (801f75c <InitTargetPlatform+0x188>)
 801f714:	f008 fc82 	bl	802801c <iprintf>
 801f718:	e79b      	b.n	801f652 <InitTargetPlatform+0x7e>
    SENSING1_PRINTF("Error Pressure/Temperature2 Sensor\n\r");
 801f71a:	4811      	ldr	r0, [pc, #68]	; (801f760 <InitTargetPlatform+0x18c>)
 801f71c:	f008 fc7e 	bl	802801c <iprintf>
 801f720:	e7e5      	b.n	801f6ee <InitTargetPlatform+0x11a>
    SENSING1_PRINTF("OK Humidity/Temperature1 Sensor\n\r");
 801f722:	4810      	ldr	r0, [pc, #64]	; (801f764 <InitTargetPlatform+0x190>)
 801f724:	f008 fc7a 	bl	802801c <iprintf>
 801f728:	e79f      	b.n	801f66a <InitTargetPlatform+0x96>
    SENSING1_PRINTF("Error Humidity/Temperature1 Sensor\n\r");
 801f72a:	480f      	ldr	r0, [pc, #60]	; (801f768 <InitTargetPlatform+0x194>)
 801f72c:	f008 fc76 	bl	802801c <iprintf>
 801f730:	e7d7      	b.n	801f6e2 <InitTargetPlatform+0x10e>
 801f732:	bf00      	nop
 801f734:	200106a4 	.word	0x200106a4
 801f738:	20000d84 	.word	0x20000d84
 801f73c:	08042874 	.word	0x08042874
 801f740:	2000b524 	.word	0x2000b524
 801f744:	08042758 	.word	0x08042758
 801f748:	080427b0 	.word	0x080427b0
 801f74c:	0804278c 	.word	0x0804278c
 801f750:	0804276c 	.word	0x0804276c
 801f754:	08042330 	.word	0x08042330
 801f758:	08042828 	.word	0x08042828
 801f75c:	080427c4 	.word	0x080427c4
 801f760:	0804284c 	.word	0x0804284c
 801f764:	080427dc 	.word	0x080427dc
 801f768:	08042800 	.word	0x08042800

0801f76c <DeInitUSBMSC>:
{
 801f76c:	b510      	push	{r4, lr}
  USBD_Stop(&hUSBDevice);
 801f76e:	4c04      	ldr	r4, [pc, #16]	; (801f780 <DeInitUSBMSC+0x14>)
 801f770:	4620      	mov	r0, r4
 801f772:	f7fd f9ef 	bl	801cb54 <USBD_Stop>
  USBD_DeInit(&hUSBDevice);
 801f776:	4620      	mov	r0, r4
}
 801f778:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  USBD_DeInit(&hUSBDevice);
 801f77c:	f7fd b9ca 	b.w	801cb14 <USBD_DeInit>
 801f780:	20010778 	.word	0x20010778

0801f784 <LedOnTargetPlatform>:
  BSP_LED_On(LED2);
 801f784:	2000      	movs	r0, #0
 801f786:	f7eb bd0f 	b.w	800b1a8 <BSP_LED_On>
 801f78a:	bf00      	nop

0801f78c <LedOffTargetPlatform>:
  BSP_LED_Off(LED2);
 801f78c:	2000      	movs	r0, #0
 801f78e:	f7eb bd17 	b.w	800b1c0 <BSP_LED_Off>
 801f792:	bf00      	nop

0801f794 <LedInitTargetPlatform>:
  BSP_LED_Init(LED2);
 801f794:	2000      	movs	r0, #0
 801f796:	f7eb bce1 	b.w	800b15c <BSP_LED_Init>
 801f79a:	bf00      	nop

0801f79c <GetPage>:
  */
uint32_t GetPage(uint32_t Addr)
{
  uint32_t page = 0;

  if (Addr < (FLASH_BASE + FLASH_BANK_SIZE)) {
 801f79c:	4b0a      	ldr	r3, [pc, #40]	; (801f7c8 <GetPage+0x2c>)
 801f79e:	f8d3 25e0 	ldr.w	r2, [r3, #1504]	; 0x5e0
 801f7a2:	f64f 73ff 	movw	r3, #65535	; 0xffff
 801f7a6:	b291      	uxth	r1, r2
 801f7a8:	4299      	cmp	r1, r3
 801f7aa:	bf17      	itett	ne
 801f7ac:	4b07      	ldrne	r3, [pc, #28]	; (801f7cc <GetPage+0x30>)
 801f7ae:	4b08      	ldreq	r3, [pc, #32]	; (801f7d0 <GetPage+0x34>)
 801f7b0:	ea03 2342 	andne.w	r3, r3, r2, lsl #9
 801f7b4:	f103 6300 	addne.w	r3, r3, #134217728	; 0x8000000
 801f7b8:	4283      	cmp	r3, r0
    /* Bank 1 */
    page = (Addr - FLASH_BASE) / FLASH_PAGE_SIZE;
 801f7ba:	bf8c      	ite	hi
 801f7bc:	f100 4078 	addhi.w	r0, r0, #4160749568	; 0xf8000000
  } else {
    /* Bank 2 */
    page = (Addr - (FLASH_BASE + FLASH_BANK_SIZE)) / FLASH_PAGE_SIZE;
 801f7c0:	1ac0      	subls	r0, r0, r3
 801f7c2:	0ac0      	lsrs	r0, r0, #11
  }

  return page;
}
 801f7c4:	4770      	bx	lr
 801f7c6:	bf00      	nop
 801f7c8:	1fff7000 	.word	0x1fff7000
 801f7cc:	01fffe00 	.word	0x01fffe00
 801f7d0:	08080000 	.word	0x08080000

0801f7d4 <GetBank>:
  */
uint32_t GetBank(uint32_t Addr)
{
  uint32_t bank = 0;

  if (READ_BIT(SYSCFG->MEMRMP, SYSCFG_MEMRMP_FB_MODE) == 0) {
 801f7d4:	4b12      	ldr	r3, [pc, #72]	; (801f820 <GetBank+0x4c>)
    /* No Bank swap */
    if (Addr < (FLASH_BASE + FLASH_BANK_SIZE)) {
 801f7d6:	4a13      	ldr	r2, [pc, #76]	; (801f824 <GetBank+0x50>)
  if (READ_BIT(SYSCFG->MEMRMP, SYSCFG_MEMRMP_FB_MODE) == 0) {
 801f7d8:	681b      	ldr	r3, [r3, #0]
    if (Addr < (FLASH_BASE + FLASH_BANK_SIZE)) {
 801f7da:	f8d2 25e0 	ldr.w	r2, [r2, #1504]	; 0x5e0
  if (READ_BIT(SYSCFG->MEMRMP, SYSCFG_MEMRMP_FB_MODE) == 0) {
 801f7de:	f413 7f80 	tst.w	r3, #256	; 0x100
    if (Addr < (FLASH_BASE + FLASH_BANK_SIZE)) {
 801f7e2:	b291      	uxth	r1, r2
 801f7e4:	f64f 73ff 	movw	r3, #65535	; 0xffff
  if (READ_BIT(SYSCFG->MEMRMP, SYSCFG_MEMRMP_FB_MODE) == 0) {
 801f7e8:	d10c      	bne.n	801f804 <GetBank+0x30>
    if (Addr < (FLASH_BASE + FLASH_BANK_SIZE)) {
 801f7ea:	4299      	cmp	r1, r3
 801f7ec:	bf17      	itett	ne
 801f7ee:	4b0e      	ldrne	r3, [pc, #56]	; (801f828 <GetBank+0x54>)
 801f7f0:	4b0e      	ldreq	r3, [pc, #56]	; (801f82c <GetBank+0x58>)
 801f7f2:	ea03 2342 	andne.w	r3, r3, r2, lsl #9
 801f7f6:	f103 6300 	addne.w	r3, r3, #134217728	; 0x8000000
  } else {
    /* Bank swap */
    if (Addr < (FLASH_BASE + FLASH_BANK_SIZE)) {
      bank = FLASH_BANK_2;
    } else {
      bank = FLASH_BANK_1;
 801f7fa:	4298      	cmp	r0, r3
 801f7fc:	bf2c      	ite	cs
 801f7fe:	2002      	movcs	r0, #2
 801f800:	2001      	movcc	r0, #1
 801f802:	4770      	bx	lr
    if (Addr < (FLASH_BASE + FLASH_BANK_SIZE)) {
 801f804:	4299      	cmp	r1, r3
 801f806:	bf17      	itett	ne
 801f808:	4b07      	ldrne	r3, [pc, #28]	; (801f828 <GetBank+0x54>)
 801f80a:	4b08      	ldreq	r3, [pc, #32]	; (801f82c <GetBank+0x58>)
 801f80c:	ea03 2342 	andne.w	r3, r3, r2, lsl #9
 801f810:	f103 6300 	addne.w	r3, r3, #134217728	; 0x8000000
      bank = FLASH_BANK_2;
 801f814:	4283      	cmp	r3, r0
 801f816:	bf94      	ite	ls
 801f818:	2001      	movls	r0, #1
 801f81a:	2002      	movhi	r0, #2
    }
  }

  return bank;
}
 801f81c:	4770      	bx	lr
 801f81e:	bf00      	nop
 801f820:	40010000 	.word	0x40010000
 801f824:	1fff7000 	.word	0x1fff7000
 801f828:	01fffe00 	.word	0x01fffe00
 801f82c:	08080000 	.word	0x08080000

0801f830 <UserFunctionForErasingFlash>:
/**
 * @brief User function for Erasing the MDM on Flash
 * @param None
 * @retval uint32_t Success/NotSuccess [1/0]
 */
uint32_t UserFunctionForErasingFlash(void) {
 801f830:	b510      	push	{r4, lr}
  FLASH_EraseInitTypeDef EraseInitStruct;
  uint32_t SectorError = 0;
  uint32_t Success=1;

  EraseInitStruct.TypeErase   = FLASH_TYPEERASE_PAGES;
  EraseInitStruct.Banks       = GetBank(MDM_FLASH_ADD);
 801f832:	4c1f      	ldr	r4, [pc, #124]	; (801f8b0 <UserFunctionForErasingFlash+0x80>)
uint32_t UserFunctionForErasingFlash(void) {
 801f834:	b086      	sub	sp, #24
  uint32_t SectorError = 0;
 801f836:	2300      	movs	r3, #0
  EraseInitStruct.Banks       = GetBank(MDM_FLASH_ADD);
 801f838:	4620      	mov	r0, r4
  EraseInitStruct.TypeErase   = FLASH_TYPEERASE_PAGES;
 801f83a:	e9cd 3301 	strd	r3, r3, [sp, #4]
  EraseInitStruct.Banks       = GetBank(MDM_FLASH_ADD);
 801f83e:	f7ff ffc9 	bl	801f7d4 <GetBank>
  if (Addr < (FLASH_BASE + FLASH_BANK_SIZE)) {
 801f842:	4b1c      	ldr	r3, [pc, #112]	; (801f8b4 <UserFunctionForErasingFlash+0x84>)
  EraseInitStruct.Banks       = GetBank(MDM_FLASH_ADD);
 801f844:	9003      	str	r0, [sp, #12]
  if (Addr < (FLASH_BASE + FLASH_BANK_SIZE)) {
 801f846:	f8d3 25e0 	ldr.w	r2, [r3, #1504]	; 0x5e0
 801f84a:	f64f 73ff 	movw	r3, #65535	; 0xffff
 801f84e:	b291      	uxth	r1, r2
 801f850:	4299      	cmp	r1, r3
 801f852:	d023      	beq.n	801f89c <UserFunctionForErasingFlash+0x6c>
 801f854:	4b18      	ldr	r3, [pc, #96]	; (801f8b8 <UserFunctionForErasingFlash+0x88>)
 801f856:	ea03 2342 	and.w	r3, r3, r2, lsl #9
 801f85a:	f103 6300 	add.w	r3, r3, #134217728	; 0x8000000
 801f85e:	42a3      	cmp	r3, r4
 801f860:	d922      	bls.n	801f8a8 <UserFunctionForErasingFlash+0x78>
    page = (Addr - FLASH_BASE) / FLASH_PAGE_SIZE;
 801f862:	f44f 74ff 	mov.w	r4, #510	; 0x1fe
  EraseInitStruct.Page        = GetPage(MDM_FLASH_ADD);
#ifndef STM32L4R9xx
  EraseInitStruct.NbPages     = 2; /* Each page is 2K */
 801f866:	2302      	movs	r3, #2
 801f868:	e9cd 4304 	strd	r4, r3, [sp, #16]
#else /* STM32L4R9xx */
  EraseInitStruct.NbPages     = 1; /* Each page is 4k */
#endif /* STM32L4R9xx */

  /* Unlock the Flash to enable the flash control register access *************/
  HAL_FLASH_Unlock();
 801f86c:	f7f0 fe4a 	bl	8010504 <HAL_FLASH_Unlock>
  if (__HAL_FLASH_GET_FLAG(FLASH_FLAG_PEMPTY) != 0) {
    __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_PEMPTY);
  }
#endif /* STM32L4R9xx */

  if(HAL_FLASHEx_Erase(&EraseInitStruct, &SectorError) != HAL_OK){
 801f870:	a901      	add	r1, sp, #4
 801f872:	a802      	add	r0, sp, #8
 801f874:	f7f0 ff56 	bl	8010724 <HAL_FLASHEx_Erase>
 801f878:	b150      	cbz	r0, 801f890 <UserFunctionForErasingFlash+0x60>
      User can add here some code to deal with this error.
      SectorError will contain the faulty sector and then to know the code error on this sector,
      user can call function 'HAL_FLASH_GetError()'
      FLASH_ErrorTypeDef errorcode = HAL_FLASH_GetError(); */
    Success=0;
    SENSING1_PRINTF("MetaDataManager Flash sector erase error\r\n");
 801f87a:	4b10      	ldr	r3, [pc, #64]	; (801f8bc <UserFunctionForErasingFlash+0x8c>)
 801f87c:	781b      	ldrb	r3, [r3, #0]
 801f87e:	b97b      	cbnz	r3, 801f8a0 <UserFunctionForErasingFlash+0x70>
    Error_Handler();
 801f880:	f003 f8ac 	bl	80229dc <Error_Handler>
  }

  /* Lock the Flash to disable the flash control register access (recommended
  to protect the FLASH memory against possible unwanted operation) *********/
  HAL_FLASH_Lock();
 801f884:	f7f0 fe52 	bl	801052c <HAL_FLASH_Lock>
    Success=0;
 801f888:	2400      	movs	r4, #0

  return Success;
}
 801f88a:	4620      	mov	r0, r4
 801f88c:	b006      	add	sp, #24
 801f88e:	bd10      	pop	{r4, pc}
  HAL_FLASH_Lock();
 801f890:	f7f0 fe4c 	bl	801052c <HAL_FLASH_Lock>
  uint32_t Success=1;
 801f894:	2401      	movs	r4, #1
}
 801f896:	4620      	mov	r0, r4
 801f898:	b006      	add	sp, #24
 801f89a:	bd10      	pop	{r4, pc}
 801f89c:	24fe      	movs	r4, #254	; 0xfe
    page = (Addr - (FLASH_BASE + FLASH_BANK_SIZE)) / FLASH_PAGE_SIZE;
 801f89e:	e7e2      	b.n	801f866 <UserFunctionForErasingFlash+0x36>
    SENSING1_PRINTF("MetaDataManager Flash sector erase error\r\n");
 801f8a0:	4807      	ldr	r0, [pc, #28]	; (801f8c0 <UserFunctionForErasingFlash+0x90>)
 801f8a2:	f008 fc57 	bl	8028154 <puts>
 801f8a6:	e7eb      	b.n	801f880 <UserFunctionForErasingFlash+0x50>
    page = (Addr - (FLASH_BASE + FLASH_BANK_SIZE)) / FLASH_PAGE_SIZE;
 801f8a8:	1ae4      	subs	r4, r4, r3
 801f8aa:	0ae4      	lsrs	r4, r4, #11
 801f8ac:	e7db      	b.n	801f866 <UserFunctionForErasingFlash+0x36>
 801f8ae:	bf00      	nop
 801f8b0:	080ff000 	.word	0x080ff000
 801f8b4:	1fff7000 	.word	0x1fff7000
 801f8b8:	01fffe00 	.word	0x01fffe00
 801f8bc:	20000d84 	.word	0x20000d84
 801f8c0:	0804287c 	.word	0x0804287c

0801f8c4 <UserFunctionForSavingFlash>:
 * @param void * InitMetaDataVector Pointer to the MDM beginning
 * @param void * EndMetaDataVector Pointer to the MDM end
 * @retval uint32_t Success/NotSuccess [1/0]
 */
uint32_t UserFunctionForSavingFlash(void *InitMetaDataVector,void *EndMetaDataVector)
{
 801f8c4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 801f8c6:	4604      	mov	r4, r0
 801f8c8:	460e      	mov	r6, r1
  /* Store in Flash Memory */
  uint32_t Address = MDM_FLASH_ADD;
  uint64_t *WriteIndex;

  /* Unlock the Flash to enable the flash control register access *************/
  HAL_FLASH_Unlock();
 801f8ca:	f7f0 fe1b 	bl	8010504 <HAL_FLASH_Unlock>
  for(WriteIndex =((uint64_t *) InitMetaDataVector); WriteIndex<((uint64_t *) EndMetaDataVector); WriteIndex++) {
 801f8ce:	42b4      	cmp	r4, r6
 801f8d0:	d218      	bcs.n	801f904 <UserFunctionForSavingFlash+0x40>
  uint32_t Address = MDM_FLASH_ADD;
 801f8d2:	4d0f      	ldr	r5, [pc, #60]	; (801f910 <UserFunctionForSavingFlash+0x4c>)
  uint32_t Success=1;
 801f8d4:	2701      	movs	r7, #1
 801f8d6:	e003      	b.n	801f8e0 <UserFunctionForSavingFlash+0x1c>
  for(WriteIndex =((uint64_t *) InitMetaDataVector); WriteIndex<((uint64_t *) EndMetaDataVector); WriteIndex++) {
 801f8d8:	42a6      	cmp	r6, r4
    if (HAL_FLASH_Program(FLASH_TYPEPROGRAM_DOUBLEWORD, Address,*WriteIndex) == HAL_OK){
      Address = Address + 8;
 801f8da:	f105 0508 	add.w	r5, r5, #8
  for(WriteIndex =((uint64_t *) InitMetaDataVector); WriteIndex<((uint64_t *) EndMetaDataVector); WriteIndex++) {
 801f8de:	d90d      	bls.n	801f8fc <UserFunctionForSavingFlash+0x38>
    if (HAL_FLASH_Program(FLASH_TYPEPROGRAM_DOUBLEWORD, Address,*WriteIndex) == HAL_OK){
 801f8e0:	e8f4 2302 	ldrd	r2, r3, [r4], #8
 801f8e4:	4629      	mov	r1, r5
 801f8e6:	2000      	movs	r0, #0
 801f8e8:	f7f0 fe66 	bl	80105b8 <HAL_FLASH_Program>
 801f8ec:	2800      	cmp	r0, #0
 801f8ee:	d0f3      	beq.n	801f8d8 <UserFunctionForSavingFlash+0x14>
    } else {
      /* Error occurred while writing data in Flash memory.
         User can add here some code to deal with this error
         FLASH_ErrorTypeDef errorcode = HAL_FLASH_GetError(); */
      Error_Handler();
 801f8f0:	f003 f874 	bl	80229dc <Error_Handler>
  for(WriteIndex =((uint64_t *) InitMetaDataVector); WriteIndex<((uint64_t *) EndMetaDataVector); WriteIndex++) {
 801f8f4:	42a6      	cmp	r6, r4
      Success =0;
 801f8f6:	f04f 0700 	mov.w	r7, #0
  for(WriteIndex =((uint64_t *) InitMetaDataVector); WriteIndex<((uint64_t *) EndMetaDataVector); WriteIndex++) {
 801f8fa:	d8f1      	bhi.n	801f8e0 <UserFunctionForSavingFlash+0x1c>
    }
  }

  /* Lock the Flash to disable the flash control register access (recommended
   to protect the FLASH memory against possible unwanted operation) *********/
  HAL_FLASH_Lock();
 801f8fc:	f7f0 fe16 	bl	801052c <HAL_FLASH_Lock>

  return Success;
}
 801f900:	4638      	mov	r0, r7
 801f902:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  uint32_t Success=1;
 801f904:	2701      	movs	r7, #1
  HAL_FLASH_Lock();
 801f906:	f7f0 fe11 	bl	801052c <HAL_FLASH_Lock>
}
 801f90a:	4638      	mov	r0, r7
 801f90c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 801f90e:	bf00      	nop
 801f910:	080ff000 	.word	0x080ff000

0801f914 <aiPrintLayoutBuffer>:
  return Address;
}

__STATIC_INLINE void aiPrintLayoutBuffer(const char *msg, int idx,
        const ai_buffer* buffer)
{
 801f914:	b5f0      	push	{r4, r5, r6, r7, lr}
    uint32_t type_id = AI_BUFFER_FMT_GET_TYPE(buffer->format);
    SENSING1_PRINTF("%s[%d] ",msg, idx);
 801f916:	4e45      	ldr	r6, [pc, #276]	; (801fa2c <aiPrintLayoutBuffer+0x118>)
    uint32_t type_id = AI_BUFFER_FMT_GET_TYPE(buffer->format);
 801f918:	6815      	ldr	r5, [r2, #0]
    SENSING1_PRINTF("%s[%d] ",msg, idx);
 801f91a:	7833      	ldrb	r3, [r6, #0]
{
 801f91c:	b083      	sub	sp, #12
 801f91e:	4614      	mov	r4, r2
    uint32_t type_id = AI_BUFFER_FMT_GET_TYPE(buffer->format);
 801f920:	f3c5 4543 	ubfx	r5, r5, #17, #4
    SENSING1_PRINTF("%s[%d] ",msg, idx);
 801f924:	b91b      	cbnz	r3, 801f92e <aiPrintLayoutBuffer+0x1a>
    if (type_id == AI_BUFFER_FMT_TYPE_Q) {
 801f926:	2d02      	cmp	r5, #2
 801f928:	d027      	beq.n	801f97a <aiPrintLayoutBuffer+0x66>
    else
        SENSING1_PRINTF("NONE");
    SENSING1_PRINTF(" %ld bytes, shape=(%d,%d,%ld)\r\n",
    		AI_BUFFER_BYTE_SIZE(AI_BUFFER_SIZE(buffer), buffer->format),
			buffer->height, buffer->width, buffer->channels);
}
 801f92a:	b003      	add	sp, #12
 801f92c:	bdf0      	pop	{r4, r5, r6, r7, pc}
    SENSING1_PRINTF("%s[%d] ",msg, idx);
 801f92e:	460a      	mov	r2, r1
 801f930:	4601      	mov	r1, r0
 801f932:	483f      	ldr	r0, [pc, #252]	; (801fa30 <aiPrintLayoutBuffer+0x11c>)
 801f934:	f008 fb72 	bl	802801c <iprintf>
    if (type_id == AI_BUFFER_FMT_TYPE_Q) {
 801f938:	2d02      	cmp	r5, #2
        SENSING1_PRINTF(" %s%d,",
 801f93a:	7833      	ldrb	r3, [r6, #0]
    if (type_id == AI_BUFFER_FMT_TYPE_Q) {
 801f93c:	d04a      	beq.n	801f9d4 <aiPrintLayoutBuffer+0xc0>
    else if (type_id == AI_BUFFER_FMT_TYPE_FLOAT)
 801f93e:	2d01      	cmp	r5, #1
 801f940:	d03f      	beq.n	801f9c2 <aiPrintLayoutBuffer+0xae>
        SENSING1_PRINTF("NONE");
 801f942:	2b00      	cmp	r3, #0
 801f944:	d0f1      	beq.n	801f92a <aiPrintLayoutBuffer+0x16>
 801f946:	483b      	ldr	r0, [pc, #236]	; (801fa34 <aiPrintLayoutBuffer+0x120>)
 801f948:	f008 fb68 	bl	802801c <iprintf>
    SENSING1_PRINTF(" %ld bytes, shape=(%d,%d,%ld)\r\n",
 801f94c:	7833      	ldrb	r3, [r6, #0]
 801f94e:	2b00      	cmp	r3, #0
 801f950:	d0eb      	beq.n	801f92a <aiPrintLayoutBuffer+0x16>
 801f952:	8923      	ldrh	r3, [r4, #8]
 801f954:	88e2      	ldrh	r2, [r4, #6]
 801f956:	6821      	ldr	r1, [r4, #0]
 801f958:	68e0      	ldr	r0, [r4, #12]
 801f95a:	9000      	str	r0, [sp, #0]
 801f95c:	fb02 f403 	mul.w	r4, r2, r3
 801f960:	f3c1 11c6 	ubfx	r1, r1, #7, #7
 801f964:	fb04 f101 	mul.w	r1, r4, r1
 801f968:	fb00 f101 	mul.w	r1, r0, r1
 801f96c:	3104      	adds	r1, #4
 801f96e:	08c9      	lsrs	r1, r1, #3
 801f970:	4831      	ldr	r0, [pc, #196]	; (801fa38 <aiPrintLayoutBuffer+0x124>)
 801f972:	f008 fb53 	bl	802801c <iprintf>
}
 801f976:	b003      	add	sp, #12
 801f978:	bdf0      	pop	{r4, r5, r6, r7, pc}
        if (AI_BUFFER_META_INFO_INTQ(buffer->meta_info)) {
 801f97a:	6963      	ldr	r3, [r4, #20]
 801f97c:	2b00      	cmp	r3, #0
 801f97e:	d0d4      	beq.n	801f92a <aiPrintLayoutBuffer+0x16>
 801f980:	681a      	ldr	r2, [r3, #0]
 801f982:	07d2      	lsls	r2, r2, #31
 801f984:	d5d1      	bpl.n	801f92a <aiPrintLayoutBuffer+0x16>
 801f986:	2200      	movs	r2, #0
 801f988:	685d      	ldr	r5, [r3, #4]
 801f98a:	2d00      	cmp	r5, #0
 801f98c:	d036      	beq.n	801f9fc <aiPrintLayoutBuffer+0xe8>
            SENSING1_PRINTF(" scale=%f, zero=%d,",AI_BUFFER_META_INFO_INTQ_GET_SCALE(buffer->meta_info, 0), AI_BUFFER_META_INFO_INTQ_GET_ZEROPOINT(buffer->meta_info, 0));
 801f98e:	2a00      	cmp	r2, #0
 801f990:	d0cb      	beq.n	801f92a <aiPrintLayoutBuffer+0x16>
 801f992:	686f      	ldr	r7, [r5, #4]
 801f994:	2f00      	cmp	r7, #0
 801f996:	d044      	beq.n	801fa22 <aiPrintLayoutBuffer+0x10e>
 801f998:	8869      	ldrh	r1, [r5, #2]
 801f99a:	2900      	cmp	r1, #0
 801f99c:	d03e      	beq.n	801fa1c <aiPrintLayoutBuffer+0x108>
 801f99e:	683b      	ldr	r3, [r7, #0]
 801f9a0:	6818      	ldr	r0, [r3, #0]
 801f9a2:	f7ea ff29 	bl	800a7f8 <__aeabi_f2d>
 801f9a6:	882d      	ldrh	r5, [r5, #0]
 801f9a8:	460b      	mov	r3, r1
 801f9aa:	6879      	ldr	r1, [r7, #4]
 801f9ac:	4602      	mov	r2, r0
 801f9ae:	07a8      	lsls	r0, r5, #30
 801f9b0:	bf4c      	ite	mi
 801f9b2:	7809      	ldrbmi	r1, [r1, #0]
 801f9b4:	f991 1000 	ldrsbpl.w	r1, [r1]
 801f9b8:	9100      	str	r1, [sp, #0]
 801f9ba:	4820      	ldr	r0, [pc, #128]	; (801fa3c <aiPrintLayoutBuffer+0x128>)
 801f9bc:	f008 fb2e 	bl	802801c <iprintf>
 801f9c0:	e7c4      	b.n	801f94c <aiPrintLayoutBuffer+0x38>
        SENSING1_PRINTF(" float%d,",
 801f9c2:	2b00      	cmp	r3, #0
 801f9c4:	d0b1      	beq.n	801f92a <aiPrintLayoutBuffer+0x16>
 801f9c6:	6821      	ldr	r1, [r4, #0]
 801f9c8:	481d      	ldr	r0, [pc, #116]	; (801fa40 <aiPrintLayoutBuffer+0x12c>)
 801f9ca:	f3c1 11c6 	ubfx	r1, r1, #7, #7
 801f9ce:	f008 fb25 	bl	802801c <iprintf>
 801f9d2:	e7bb      	b.n	801f94c <aiPrintLayoutBuffer+0x38>
        SENSING1_PRINTF(" %s%d,",
 801f9d4:	2b00      	cmp	r3, #0
 801f9d6:	d0d0      	beq.n	801f97a <aiPrintLayoutBuffer+0x66>
 801f9d8:	6822      	ldr	r2, [r4, #0]
 801f9da:	4b1a      	ldr	r3, [pc, #104]	; (801fa44 <aiPrintLayoutBuffer+0x130>)
 801f9dc:	491a      	ldr	r1, [pc, #104]	; (801fa48 <aiPrintLayoutBuffer+0x134>)
 801f9de:	481b      	ldr	r0, [pc, #108]	; (801fa4c <aiPrintLayoutBuffer+0x138>)
 801f9e0:	f412 0f00 	tst.w	r2, #8388608	; 0x800000
 801f9e4:	bf08      	it	eq
 801f9e6:	4619      	moveq	r1, r3
 801f9e8:	f3c2 12c6 	ubfx	r2, r2, #7, #7
 801f9ec:	f008 fb16 	bl	802801c <iprintf>
        if (AI_BUFFER_META_INFO_INTQ(buffer->meta_info)) {
 801f9f0:	6963      	ldr	r3, [r4, #20]
            SENSING1_PRINTF(" scale=%f, zero=%d,",AI_BUFFER_META_INFO_INTQ_GET_SCALE(buffer->meta_info, 0), AI_BUFFER_META_INFO_INTQ_GET_ZEROPOINT(buffer->meta_info, 0));
 801f9f2:	7832      	ldrb	r2, [r6, #0]
        if (AI_BUFFER_META_INFO_INTQ(buffer->meta_info)) {
 801f9f4:	b113      	cbz	r3, 801f9fc <aiPrintLayoutBuffer+0xe8>
 801f9f6:	6819      	ldr	r1, [r3, #0]
 801f9f8:	07cd      	lsls	r5, r1, #31
 801f9fa:	d4c5      	bmi.n	801f988 <aiPrintLayoutBuffer+0x74>
    		SENSING1_PRINTF("Q%d.%d,",
 801f9fc:	2a00      	cmp	r2, #0
 801f9fe:	d094      	beq.n	801f92a <aiPrintLayoutBuffer+0x16>
 801fa00:	6823      	ldr	r3, [r4, #0]
 801fa02:	4813      	ldr	r0, [pc, #76]	; (801fa50 <aiPrintLayoutBuffer+0x13c>)
 801fa04:	f003 027f 	and.w	r2, r3, #127	; 0x7f
 801fa08:	3a40      	subs	r2, #64	; 0x40
 801fa0a:	f3c3 11c6 	ubfx	r1, r3, #7, #7
 801fa0e:	f3c3 53c0 	ubfx	r3, r3, #23, #1
 801fa12:	4413      	add	r3, r2
 801fa14:	1ac9      	subs	r1, r1, r3
 801fa16:	f008 fb01 	bl	802801c <iprintf>
 801fa1a:	e797      	b.n	801f94c <aiPrintLayoutBuffer+0x38>
            SENSING1_PRINTF(" scale=%f, zero=%d,",AI_BUFFER_META_INFO_INTQ_GET_SCALE(buffer->meta_info, 0), AI_BUFFER_META_INFO_INTQ_GET_ZEROPOINT(buffer->meta_info, 0));
 801fa1c:	2200      	movs	r2, #0
 801fa1e:	2300      	movs	r3, #0
 801fa20:	e7ca      	b.n	801f9b8 <aiPrintLayoutBuffer+0xa4>
 801fa22:	2200      	movs	r2, #0
 801fa24:	2300      	movs	r3, #0
 801fa26:	4639      	mov	r1, r7
 801fa28:	e7c6      	b.n	801f9b8 <aiPrintLayoutBuffer+0xa4>
 801fa2a:	bf00      	nop
 801fa2c:	20000d84 	.word	0x20000d84
 801fa30:	080428b0 	.word	0x080428b0
 801fa34:	080428e8 	.word	0x080428e8
 801fa38:	080428f0 	.word	0x080428f0
 801fa3c:	080428c0 	.word	0x080428c0
 801fa40:	080428dc 	.word	0x080428dc
 801fa44:	080428ac 	.word	0x080428ac
 801fa48:	080428a8 	.word	0x080428a8
 801fa4c:	080428b8 	.word	0x080428b8
 801fa50:	080428d4 	.word	0x080428d4

0801fa54 <ai_mnetwork_create>:
{
 801fa54:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 801fa58:	b083      	sub	sp, #12
 801fa5a:	4b32      	ldr	r3, [pc, #200]	; (801fb24 <ai_mnetwork_create+0xd0>)
 801fa5c:	9201      	str	r2, [sp, #4]
 801fa5e:	4606      	mov	r6, r0
 801fa60:	4688      	mov	r8, r1
    for (int i=0; i<AI_MNETWORK_NUMBER; i++) {
 801fa62:	2500      	movs	r5, #0
        else if ((!inst) && (gnetworks[i].entry == NULL))
 801fa64:	681c      	ldr	r4, [r3, #0]
    for (int i=0; i<AI_MNETWORK_NUMBER; i++) {
 801fa66:	3338      	adds	r3, #56	; 0x38
        else if ((!inst) && (gnetworks[i].entry == NULL))
 801fa68:	b13c      	cbz	r4, 801fa7a <ai_mnetwork_create+0x26>
    for (int i=0; i<AI_MNETWORK_NUMBER; i++) {
 801fa6a:	3501      	adds	r5, #1
 801fa6c:	2d04      	cmp	r5, #4
 801fa6e:	d1f9      	bne.n	801fa64 <ai_mnetwork_create+0x10>
        return err;
 801fa70:	f241 0031 	movw	r0, #4145	; 0x1031
}
 801fa74:	b003      	add	sp, #12
 801fa76:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    for (int i=0; i<AI_MNETWORK_NUMBER; i++) {
 801fa7a:	f8df b0ac 	ldr.w	fp, [pc, #172]	; 801fb28 <ai_mnetwork_create+0xd4>
 801fa7e:	465f      	mov	r7, fp
    if (name && (strlen(entry->name) == strlen(name)) &&
 801fa80:	b156      	cbz	r6, 801fa98 <ai_mnetwork_create+0x44>
 801fa82:	f8d7 a000 	ldr.w	sl, [r7]
 801fa86:	4650      	mov	r0, sl
 801fa88:	f7ea fcf3 	bl	800a472 <strlen>
 801fa8c:	4681      	mov	r9, r0
 801fa8e:	4630      	mov	r0, r6
 801fa90:	f7ea fcef 	bl	800a472 <strlen>
 801fa94:	4581      	cmp	r9, r0
 801fa96:	d009      	beq.n	801faac <ai_mnetwork_create+0x58>
    for (int i=0; i<AI_MNETWORK_NUMBER; i++) {
 801fa98:	3401      	adds	r4, #1
 801fa9a:	2c04      	cmp	r4, #4
 801fa9c:	f107 0760 	add.w	r7, r7, #96	; 0x60
 801faa0:	d1ee      	bne.n	801fa80 <ai_mnetwork_create+0x2c>
        return err;
 801faa2:	f241 0014 	movw	r0, #4116	; 0x1014
}
 801faa6:	b003      	add	sp, #12
 801faa8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
            (strncmp(entry->name, name, strlen(entry->name)) == 0))
 801faac:	464a      	mov	r2, r9
 801faae:	4631      	mov	r1, r6
 801fab0:	4650      	mov	r0, sl
 801fab2:	f008 fbca 	bl	802824a <strncmp>
    if (name && (strlen(entry->name) == strlen(name)) &&
 801fab6:	2800      	cmp	r0, #0
 801fab8:	d1ee      	bne.n	801fa98 <ai_mnetwork_create+0x44>
    if (network_config == NULL)
 801faba:	9b01      	ldr	r3, [sp, #4]
 801fabc:	b32b      	cbz	r3, 801fb0a <ai_mnetwork_create+0xb6>
        err = found->ai_create(network, network_config);
 801fabe:	eb04 0344 	add.w	r3, r4, r4, lsl #1
 801fac2:	eb0b 1343 	add.w	r3, fp, r3, lsl #5
 801fac6:	9901      	ldr	r1, [sp, #4]
 801fac8:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 801faca:	4640      	mov	r0, r8
 801facc:	4798      	blx	r3
 801face:	0061      	lsls	r1, r4, #1
 801fad0:	b2c2      	uxtb	r2, r0
 801fad2:	f3c0 2317 	ubfx	r3, r0, #8, #24
    if ((err.code == AI_ERROR_CODE_NONE) && (err.type == AI_ERROR_NONE)) {
 801fad6:	ea52 2003 	orrs.w	r0, r2, r3, lsl #8
 801fada:	d10e      	bne.n	801fafa <ai_mnetwork_create+0xa6>
        entry = &networks[i];
 801fadc:	440c      	add	r4, r1
        inst->entry = found;
 801fade:	ebc5 05c5 	rsb	r5, r5, r5, lsl #3
 801fae2:	4910      	ldr	r1, [pc, #64]	; (801fb24 <ai_mnetwork_create+0xd0>)
        entry = &networks[i];
 801fae4:	eb0b 1444 	add.w	r4, fp, r4, lsl #5
        inst->entry = found;
 801fae8:	f841 4035 	str.w	r4, [r1, r5, lsl #3]
 801faec:	eb01 05c5 	add.w	r5, r1, r5, lsl #3
        inst->handle = *network;
 801faf0:	f8d8 1000 	ldr.w	r1, [r8]
 801faf4:	6069      	str	r1, [r5, #4]
        *network = (ai_handle*)inst;
 801faf6:	f8c8 5000 	str.w	r5, [r8]
    return err;
 801fafa:	2000      	movs	r0, #0
 801fafc:	f362 0007 	bfi	r0, r2, #0, #8
 801fb00:	f363 201f 	bfi	r0, r3, #8, #24
}
 801fb04:	b003      	add	sp, #12
 801fb06:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        err = found->ai_create(network, found->config);
 801fb0a:	eb04 0344 	add.w	r3, r4, r4, lsl #1
 801fb0e:	eb0b 1343 	add.w	r3, fp, r3, lsl #5
 801fb12:	4640      	mov	r0, r8
 801fb14:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 801fb16:	6b59      	ldr	r1, [r3, #52]	; 0x34
 801fb18:	4790      	blx	r2
 801fb1a:	0061      	lsls	r1, r4, #1
 801fb1c:	b2c2      	uxtb	r2, r0
 801fb1e:	f3c0 2317 	ubfx	r3, r0, #8, #24
 801fb22:	e7d8      	b.n	801fad6 <ai_mnetwork_create+0x82>
 801fb24:	20010a1c 	.word	0x20010a1c
 801fb28:	08039880 	.word	0x08039880

0801fb2c <ai_mnetwork_destroy>:
{
 801fb2c:	b570      	push	{r4, r5, r6, lr}
 801fb2e:	4e1c      	ldr	r6, [pc, #112]	; (801fba0 <ai_mnetwork_destroy+0x74>)
 801fb30:	4604      	mov	r4, r0
    for (int i=0; i<AI_MNETWORK_NUMBER; i++) {
 801fb32:	4633      	mov	r3, r6
 801fb34:	2200      	movs	r2, #0
 801fb36:	461d      	mov	r5, r3
        if ((inst) && (&gnetworks[i] == inst))
 801fb38:	b144      	cbz	r4, 801fb4c <ai_mnetwork_destroy+0x20>
 801fb3a:	429c      	cmp	r4, r3
 801fb3c:	d00d      	beq.n	801fb5a <ai_mnetwork_destroy+0x2e>
    for (int i=0; i<AI_MNETWORK_NUMBER; i++) {
 801fb3e:	3201      	adds	r2, #1
 801fb40:	2a04      	cmp	r2, #4
 801fb42:	f103 0338 	add.w	r3, r3, #56	; 0x38
 801fb46:	d1f6      	bne.n	801fb36 <ai_mnetwork_destroy+0xa>
}
 801fb48:	4620      	mov	r0, r4
 801fb4a:	bd70      	pop	{r4, r5, r6, pc}
        else if ((!inst) && (gnetworks[i].entry == NULL))
 801fb4c:	6819      	ldr	r1, [r3, #0]
 801fb4e:	2900      	cmp	r1, #0
 801fb50:	d1f5      	bne.n	801fb3e <ai_mnetwork_destroy+0x12>
            return &gnetworks[i];
 801fb52:	ebc2 02c2 	rsb	r2, r2, r2, lsl #3
 801fb56:	eb06 05c2 	add.w	r5, r6, r2, lsl #3
        ai_handle hdl = inn->entry->ai_destroy(inn->handle);
 801fb5a:	e9d5 3000 	ldrd	r3, r0, [r5]
 801fb5e:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 801fb60:	4798      	blx	r3
        if (hdl != inn->handle) {
 801fb62:	686b      	ldr	r3, [r5, #4]
 801fb64:	4283      	cmp	r3, r0
 801fb66:	d0ef      	beq.n	801fb48 <ai_mnetwork_destroy+0x1c>
        if ((inst) && (&gnetworks[i] == inst)) {
 801fb68:	42b5      	cmp	r5, r6
 801fb6a:	d017      	beq.n	801fb9c <ai_mnetwork_destroy+0x70>
 801fb6c:	4b0d      	ldr	r3, [pc, #52]	; (801fba4 <ai_mnetwork_destroy+0x78>)
 801fb6e:	429d      	cmp	r5, r3
 801fb70:	d012      	beq.n	801fb98 <ai_mnetwork_destroy+0x6c>
 801fb72:	f103 0238 	add.w	r2, r3, #56	; 0x38
 801fb76:	4295      	cmp	r5, r2
 801fb78:	d007      	beq.n	801fb8a <ai_mnetwork_destroy+0x5e>
 801fb7a:	3370      	adds	r3, #112	; 0x70
 801fb7c:	429d      	cmp	r5, r3
    for (int i=0; i<AI_MNETWORK_NUMBER; i++) {
 801fb7e:	bf08      	it	eq
 801fb80:	2303      	moveq	r3, #3
        if ((inst) && (&gnetworks[i] == inst)) {
 801fb82:	d003      	beq.n	801fb8c <ai_mnetwork_destroy+0x60>
            network = AI_HANDLE_NULL;
 801fb84:	2400      	movs	r4, #0
}
 801fb86:	4620      	mov	r0, r4
 801fb88:	bd70      	pop	{r4, r5, r6, pc}
    for (int i=0; i<AI_MNETWORK_NUMBER; i++) {
 801fb8a:	2302      	movs	r3, #2
            gnetworks[i].entry = NULL;
 801fb8c:	ebc3 03c3 	rsb	r3, r3, r3, lsl #3
 801fb90:	00db      	lsls	r3, r3, #3
 801fb92:	2400      	movs	r4, #0
 801fb94:	50f4      	str	r4, [r6, r3]
            return;
 801fb96:	e7d7      	b.n	801fb48 <ai_mnetwork_destroy+0x1c>
    for (int i=0; i<AI_MNETWORK_NUMBER; i++) {
 801fb98:	2301      	movs	r3, #1
 801fb9a:	e7f7      	b.n	801fb8c <ai_mnetwork_destroy+0x60>
 801fb9c:	2300      	movs	r3, #0
 801fb9e:	e7f5      	b.n	801fb8c <ai_mnetwork_destroy+0x60>
 801fba0:	20010a1c 	.word	0x20010a1c
 801fba4:	20010a54 	.word	0x20010a54

0801fba8 <ai_mnetwork_get_error>:
{
 801fba8:	b410      	push	{r4}
 801fbaa:	4c0f      	ldr	r4, [pc, #60]	; (801fbe8 <ai_mnetwork_get_error+0x40>)
    for (int i=0; i<AI_MNETWORK_NUMBER; i++) {
 801fbac:	2200      	movs	r2, #0
 801fbae:	4623      	mov	r3, r4
 801fbb0:	4619      	mov	r1, r3
        if ((inst) && (&gnetworks[i] == inst))
 801fbb2:	b158      	cbz	r0, 801fbcc <ai_mnetwork_get_error+0x24>
 801fbb4:	4298      	cmp	r0, r3
 801fbb6:	d010      	beq.n	801fbda <ai_mnetwork_get_error+0x32>
    for (int i=0; i<AI_MNETWORK_NUMBER; i++) {
 801fbb8:	3201      	adds	r2, #1
 801fbba:	2a04      	cmp	r2, #4
 801fbbc:	f103 0338 	add.w	r3, r3, #56	; 0x38
 801fbc0:	d1f6      	bne.n	801fbb0 <ai_mnetwork_get_error+0x8>
}
 801fbc2:	f241 0014 	movw	r0, #4116	; 0x1014
 801fbc6:	f85d 4b04 	ldr.w	r4, [sp], #4
 801fbca:	4770      	bx	lr
        else if ((!inst) && (gnetworks[i].entry == NULL))
 801fbcc:	6819      	ldr	r1, [r3, #0]
 801fbce:	2900      	cmp	r1, #0
 801fbd0:	d1f2      	bne.n	801fbb8 <ai_mnetwork_get_error+0x10>
            return &gnetworks[i];
 801fbd2:	ebc2 02c2 	rsb	r2, r2, r2, lsl #3
 801fbd6:	eb04 01c2 	add.w	r1, r4, r2, lsl #3
        return inn->entry->ai_get_error(inn->handle);
 801fbda:	e9d1 3000 	ldrd	r3, r0, [r1]
}
 801fbde:	f85d 4b04 	ldr.w	r4, [sp], #4
        return inn->entry->ai_get_error(inn->handle);
 801fbe2:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 801fbe4:	4718      	bx	r3
 801fbe6:	bf00      	nop
 801fbe8:	20010a1c 	.word	0x20010a1c

0801fbec <ai_mnetwork_init>:
{
 801fbec:	b5f0      	push	{r4, r5, r6, r7, lr}
 801fbee:	4e28      	ldr	r6, [pc, #160]	; (801fc90 <ai_mnetwork_init+0xa4>)
 801fbf0:	b08d      	sub	sp, #52	; 0x34
 801fbf2:	460c      	mov	r4, r1
 801fbf4:	4633      	mov	r3, r6
    for (int i=0; i<AI_MNETWORK_NUMBER; i++) {
 801fbf6:	2200      	movs	r2, #0
        if ((inst) && (&gnetworks[i] == inst))
 801fbf8:	461d      	mov	r5, r3
 801fbfa:	b148      	cbz	r0, 801fc10 <ai_mnetwork_init+0x24>
 801fbfc:	4298      	cmp	r0, r3
 801fbfe:	d00e      	beq.n	801fc1e <ai_mnetwork_init+0x32>
    for (int i=0; i<AI_MNETWORK_NUMBER; i++) {
 801fc00:	3201      	adds	r2, #1
 801fc02:	2a04      	cmp	r2, #4
 801fc04:	f103 0338 	add.w	r3, r3, #56	; 0x38
 801fc08:	d1f6      	bne.n	801fbf8 <ai_mnetwork_init+0xc>
        return false;
 801fc0a:	2000      	movs	r0, #0
}
 801fc0c:	b00d      	add	sp, #52	; 0x34
 801fc0e:	bdf0      	pop	{r4, r5, r6, r7, pc}
        else if ((!inst) && (gnetworks[i].entry == NULL))
 801fc10:	6819      	ldr	r1, [r3, #0]
 801fc12:	2900      	cmp	r1, #0
 801fc14:	d1f4      	bne.n	801fc00 <ai_mnetwork_init+0x14>
            return &gnetworks[i];
 801fc16:	ebc2 02c2 	rsb	r2, r2, r2, lsl #3
 801fc1a:	eb06 05c2 	add.w	r5, r6, r2, lsl #3
        par = inn->entry->params;
 801fc1e:	682e      	ldr	r6, [r5, #0]
        if (params->activations.n_batches)
 801fc20:	8ba7      	ldrh	r7, [r4, #28]
        par = inn->entry->params;
 801fc22:	f106 0e04 	add.w	lr, r6, #4
 801fc26:	e8be 000f 	ldmia.w	lr!, {r0, r1, r2, r3}
 801fc2a:	46ec      	mov	ip, sp
 801fc2c:	e8ac 000f 	stmia.w	ip!, {r0, r1, r2, r3}
 801fc30:	e8be 000f 	ldmia.w	lr!, {r0, r1, r2, r3}
 801fc34:	e8ac 000f 	stmia.w	ip!, {r0, r1, r2, r3}
 801fc38:	e89e 000f 	ldmia.w	lr, {r0, r1, r2, r3}
 801fc3c:	e88c 000f 	stmia.w	ip, {r0, r1, r2, r3}
        if (params->activations.n_batches)
 801fc40:	b98f      	cbnz	r7, 801fc66 <ai_mnetwork_init+0x7a>
            par.activations.data = params->activations.data;
 801fc42:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 801fc44:	930a      	str	r3, [sp, #40]	; 0x28
        if (params->params.n_batches)
 801fc46:	88a3      	ldrh	r3, [r4, #4]
 801fc48:	b1e3      	cbz	r3, 801fc84 <ai_mnetwork_init+0x98>
            par.params = params->params;
 801fc4a:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 801fc4c:	46ec      	mov	ip, sp
 801fc4e:	e8ac 000f 	stmia.w	ip!, {r0, r1, r2, r3}
 801fc52:	e894 0003 	ldmia.w	r4, {r0, r1}
 801fc56:	e88c 0003 	stmia.w	ip, {r0, r1}
        return inn->entry->ai_init(inn->handle, &par);
 801fc5a:	6cf3      	ldr	r3, [r6, #76]	; 0x4c
 801fc5c:	6868      	ldr	r0, [r5, #4]
 801fc5e:	4669      	mov	r1, sp
 801fc60:	4798      	blx	r3
}
 801fc62:	b00d      	add	sp, #52	; 0x34
 801fc64:	bdf0      	pop	{r4, r5, r6, r7, pc}
            par.activations = params->activations;
 801fc66:	f104 0e18 	add.w	lr, r4, #24
 801fc6a:	e8be 000f 	ldmia.w	lr!, {r0, r1, r2, r3}
 801fc6e:	f10d 0c18 	add.w	ip, sp, #24
 801fc72:	e8ac 000f 	stmia.w	ip!, {r0, r1, r2, r3}
 801fc76:	e89e 0003 	ldmia.w	lr, {r0, r1}
        if (params->params.n_batches)
 801fc7a:	88a3      	ldrh	r3, [r4, #4]
            par.activations = params->activations;
 801fc7c:	e88c 0003 	stmia.w	ip, {r0, r1}
        if (params->params.n_batches)
 801fc80:	2b00      	cmp	r3, #0
 801fc82:	d1e2      	bne.n	801fc4a <ai_mnetwork_init+0x5e>
            par.params.data = inn->entry->ai_data_weights_get_default();
 801fc84:	6bb3      	ldr	r3, [r6, #56]	; 0x38
 801fc86:	4798      	blx	r3
        return inn->entry->ai_init(inn->handle, &par);
 801fc88:	682e      	ldr	r6, [r5, #0]
            par.params.data = inn->entry->ai_data_weights_get_default();
 801fc8a:	9004      	str	r0, [sp, #16]
 801fc8c:	e7e5      	b.n	801fc5a <ai_mnetwork_init+0x6e>
 801fc8e:	bf00      	nop
 801fc90:	20010a1c 	.word	0x20010a1c

0801fc94 <aiNetworkRetrieveDataWeightsAddress>:
{
 801fc94:	b570      	push	{r4, r5, r6, lr}
  SENSING1_PRINTF("Searching the aiNetwork\r\n");
 801fc96:	4b13      	ldr	r3, [pc, #76]	; (801fce4 <aiNetworkRetrieveDataWeightsAddress+0x50>)
 801fc98:	781b      	ldrb	r3, [r3, #0]
{
 801fc9a:	4604      	mov	r4, r0
 801fc9c:	460d      	mov	r5, r1
  SENSING1_PRINTF("Searching the aiNetwork\r\n");
 801fc9e:	b9b3      	cbnz	r3, 801fcce <aiNetworkRetrieveDataWeightsAddress+0x3a>
    if(ActivationSize==networks[NetworkNum].params.activations.channels) {
 801fca0:	f5b4 5fda 	cmp.w	r4, #6976	; 0x1b40
 801fca4:	d019      	beq.n	801fcda <aiNetworkRetrieveDataWeightsAddress+0x46>
 801fca6:	f5b4 6fd8 	cmp.w	r4, #1728	; 0x6c0
 801fcaa:	d004      	beq.n	801fcb6 <aiNetworkRetrieveDataWeightsAddress+0x22>
 801fcac:	f5b4 5fa1 	cmp.w	r4, #5152	; 0x1420
 801fcb0:	d015      	beq.n	801fcde <aiNetworkRetrieveDataWeightsAddress+0x4a>
  ai_u8 *Address=NULL;
 801fcb2:	2000      	movs	r0, #0
}
 801fcb4:	bd70      	pop	{r4, r5, r6, pc}
    NetworkNum++;
 801fcb6:	2301      	movs	r3, #1
    Address = networks[Found].ai_data_weights_get_default();
 801fcb8:	4e0b      	ldr	r6, [pc, #44]	; (801fce8 <aiNetworkRetrieveDataWeightsAddress+0x54>)
 801fcba:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 801fcbe:	eb06 1243 	add.w	r2, r6, r3, lsl #5
 801fcc2:	015c      	lsls	r4, r3, #5
 801fcc4:	6b93      	ldr	r3, [r2, #56]	; 0x38
 801fcc6:	4798      	blx	r3
    *ModelName = (uint8_t*) networks[Found].name;
 801fcc8:	5933      	ldr	r3, [r6, r4]
 801fcca:	602b      	str	r3, [r5, #0]
}
 801fccc:	bd70      	pop	{r4, r5, r6, pc}
  SENSING1_PRINTF("Searching the aiNetwork\r\n");
 801fcce:	4807      	ldr	r0, [pc, #28]	; (801fcec <aiNetworkRetrieveDataWeightsAddress+0x58>)
 801fcd0:	f008 fa40 	bl	8028154 <puts>
    if(ActivationSize==networks[NetworkNum].params.activations.channels) {
 801fcd4:	f5b4 5fda 	cmp.w	r4, #6976	; 0x1b40
 801fcd8:	d1e5      	bne.n	801fca6 <aiNetworkRetrieveDataWeightsAddress+0x12>
 801fcda:	2300      	movs	r3, #0
 801fcdc:	e7ec      	b.n	801fcb8 <aiNetworkRetrieveDataWeightsAddress+0x24>
    NetworkNum++;
 801fcde:	2303      	movs	r3, #3
 801fce0:	e7ea      	b.n	801fcb8 <aiNetworkRetrieveDataWeightsAddress+0x24>
 801fce2:	bf00      	nop
 801fce4:	20000d84 	.word	0x20000d84
 801fce8:	08039880 	.word	0x08039880
 801fcec:	08042958 	.word	0x08042958

0801fcf0 <aiConvertInputFloat_2_Int8>:
 * -----------------------------------------------------------------------------
 */
int aiConvertInputFloat_2_Int8(const char *nn_name, const int idx, 
                               ai_float *In_f32, ai_i8 *Out_int8)
{
  if( AI_HANDLE_NULL == net_ctx[idx].handle)
 801fcf0:	4847      	ldr	r0, [pc, #284]	; (801fe10 <aiConvertInputFloat_2_Int8+0x120>)
{
 801fcf2:	b570      	push	{r4, r5, r6, lr}
  if( AI_HANDLE_NULL == net_ctx[idx].handle)
 801fcf4:	ebc1 1101 	rsb	r1, r1, r1, lsl #4
 801fcf8:	eb00 01c1 	add.w	r1, r0, r1, lsl #3
{
 801fcfc:	ed2d 8b02 	vpush	{d8}
  if( AI_HANDLE_NULL == net_ctx[idx].handle)
 801fd00:	f8d1 00e0 	ldr.w	r0, [r1, #224]	; 0xe0
 801fd04:	2800      	cmp	r0, #0
 801fd06:	d072      	beq.n	801fdee <aiConvertInputFloat_2_Int8+0xfe>
  {
      SENSING1_PRINTF("E: network handle is NULL\r\n");
      return -1;
  }
  ai_buffer * bufferPtr   = &(net_ctx[idx].report.inputs[0]);
 801fd08:	f8d1 1118 	ldr.w	r1, [r1, #280]	; 0x118
  ai_buffer_format format = bufferPtr->format;
  int size  = AI_BUFFER_SIZE(bufferPtr);
 801fd0c:	88cc      	ldrh	r4, [r1, #6]
 801fd0e:	890e      	ldrh	r6, [r1, #8]
  ai_buffer_format format = bufferPtr->format;
 801fd10:	6808      	ldr	r0, [r1, #0]
  int size  = AI_BUFFER_SIZE(bufferPtr);
 801fd12:	fb04 f606 	mul.w	r6, r4, r6
 801fd16:	68cc      	ldr	r4, [r1, #12]
 801fd18:	fb04 f606 	mul.w	r6, r4, r6
  ai_float scale ;
  int zero_point ;

  if (AI_BUFFER_FMT_TYPE_Q != AI_BUFFER_FMT_GET_TYPE(format) &&\
 801fd1c:	f3c0 4443 	ubfx	r4, r0, #17, #4
 801fd20:	2c02      	cmp	r4, #2
 801fd22:	d001      	beq.n	801fd28 <aiConvertInputFloat_2_Int8+0x38>
 801fd24:	0204      	lsls	r4, r0, #8
 801fd26:	d545      	bpl.n	801fdb4 <aiConvertInputFloat_2_Int8+0xc4>
    8 != AI_BUFFER_FMT_GET_BITS(format))
  {
      SENSING1_PRINTF("E: expected signed integer 8 bits\r\n");
      return -1;
  }
  if (AI_BUFFER_META_INFO_INTQ(bufferPtr->meta_info)) {
 801fd28:	6949      	ldr	r1, [r1, #20]
 801fd2a:	2900      	cmp	r1, #0
 801fd2c:	d055      	beq.n	801fdda <aiConvertInputFloat_2_Int8+0xea>
 801fd2e:	6808      	ldr	r0, [r1, #0]
 801fd30:	07c0      	lsls	r0, r0, #31
 801fd32:	d552      	bpl.n	801fdda <aiConvertInputFloat_2_Int8+0xea>
 801fd34:	6849      	ldr	r1, [r1, #4]
 801fd36:	2900      	cmp	r1, #0
 801fd38:	d04f      	beq.n	801fdda <aiConvertInputFloat_2_Int8+0xea>
      scale = AI_BUFFER_META_INFO_INTQ_GET_SCALE(bufferPtr->meta_info, 0);
 801fd3a:	6848      	ldr	r0, [r1, #4]
 801fd3c:	2800      	cmp	r0, #0
 801fd3e:	d046      	beq.n	801fdce <aiConvertInputFloat_2_Int8+0xde>
 801fd40:	884c      	ldrh	r4, [r1, #2]
 801fd42:	2c00      	cmp	r4, #0
 801fd44:	d043      	beq.n	801fdce <aiConvertInputFloat_2_Int8+0xde>
 801fd46:	6804      	ldr	r4, [r0, #0]
 801fd48:	edd4 7a00 	vldr	s15, [r4]
      if (scale != 0.0F)
 801fd4c:	eef5 7a40 	vcmp.f32	s15, #0.0
 801fd50:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801fd54:	d03b      	beq.n	801fdce <aiConvertInputFloat_2_Int8+0xde>
      else 
      {
        SENSING1_PRINTF("E: division by zero\r\n");
        return -1;
      }   
      zero_point = AI_BUFFER_META_INFO_INTQ_GET_ZEROPOINT(bufferPtr->meta_info, 0);
 801fd56:	8809      	ldrh	r1, [r1, #0]
         scale= 1.0F/scale ;
 801fd58:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
      zero_point = AI_BUFFER_META_INFO_INTQ_GET_ZEROPOINT(bufferPtr->meta_info, 0);
 801fd5c:	0789      	lsls	r1, r1, #30
         scale= 1.0F/scale ;
 801fd5e:	eec7 8a27 	vdiv.f32	s17, s14, s15
      zero_point = AI_BUFFER_META_INFO_INTQ_GET_ZEROPOINT(bufferPtr->meta_info, 0);
 801fd62:	d422      	bmi.n	801fdaa <aiConvertInputFloat_2_Int8+0xba>
 801fd64:	6841      	ldr	r1, [r0, #4]
 801fd66:	f991 1000 	ldrsb.w	r1, [r1]
 801fd6a:	ee08 1a10 	vmov	s16, r1
  } else {
      SENSING1_PRINTF("E: no meta info\r\n");
      return -1;
  }
  
  for (int i = 0; i < size ; i++)
 801fd6e:	2e00      	cmp	r6, #0
 801fd70:	dd17      	ble.n	801fda2 <aiConvertInputFloat_2_Int8+0xb2>
  {
    Out_int8[i] = __SSAT((int32_t) roundf((float)zero_point + In_f32[i]*scale), 8);
 801fd72:	eeb8 8ac8 	vcvt.f32.s32	s16, s16
 801fd76:	4614      	mov	r4, r2
 801fd78:	1e5d      	subs	r5, r3, #1
 801fd7a:	eb02 0686 	add.w	r6, r2, r6, lsl #2
 801fd7e:	ecb4 0a01 	vldmia	r4!, {s0}
 801fd82:	ee20 0a28 	vmul.f32	s0, s0, s17
 801fd86:	ee30 0a08 	vadd.f32	s0, s0, s16
 801fd8a:	f00a ffbf 	bl	802ad0c <roundf>
 801fd8e:	eefd 7ac0 	vcvt.s32.f32	s15, s0
  for (int i = 0; i < size ; i++)
 801fd92:	42a6      	cmp	r6, r4
    Out_int8[i] = __SSAT((int32_t) roundf((float)zero_point + In_f32[i]*scale), 8);
 801fd94:	ee17 3a90 	vmov	r3, s15
 801fd98:	f303 0307 	ssat	r3, #8, r3
 801fd9c:	f805 3f01 	strb.w	r3, [r5, #1]!
  for (int i = 0; i < size ; i++)
 801fda0:	d1ed      	bne.n	801fd7e <aiConvertInputFloat_2_Int8+0x8e>
  }
  return 0; 
 801fda2:	2000      	movs	r0, #0
}
 801fda4:	ecbd 8b02 	vpop	{d8}
 801fda8:	bd70      	pop	{r4, r5, r6, pc}
      zero_point = AI_BUFFER_META_INFO_INTQ_GET_ZEROPOINT(bufferPtr->meta_info, 0);
 801fdaa:	6841      	ldr	r1, [r0, #4]
 801fdac:	7809      	ldrb	r1, [r1, #0]
 801fdae:	ee08 1a10 	vmov	s16, r1
 801fdb2:	e7dc      	b.n	801fd6e <aiConvertInputFloat_2_Int8+0x7e>
    8 != AI_BUFFER_FMT_GET_BITS(format))
 801fdb4:	f3c0 10c6 	ubfx	r0, r0, #7, #7
    ! AI_BUFFER_FMT_GET_SIGN(format) &&\
 801fdb8:	2808      	cmp	r0, #8
 801fdba:	d0b5      	beq.n	801fd28 <aiConvertInputFloat_2_Int8+0x38>
      SENSING1_PRINTF("E: expected signed integer 8 bits\r\n");
 801fdbc:	4b15      	ldr	r3, [pc, #84]	; (801fe14 <aiConvertInputFloat_2_Int8+0x124>)
 801fdbe:	781b      	ldrb	r3, [r3, #0]
 801fdc0:	b143      	cbz	r3, 801fdd4 <aiConvertInputFloat_2_Int8+0xe4>
 801fdc2:	4815      	ldr	r0, [pc, #84]	; (801fe18 <aiConvertInputFloat_2_Int8+0x128>)
 801fdc4:	f008 f9c6 	bl	8028154 <puts>
      return -1;
 801fdc8:	f04f 30ff 	mov.w	r0, #4294967295
 801fdcc:	e7ea      	b.n	801fda4 <aiConvertInputFloat_2_Int8+0xb4>
        SENSING1_PRINTF("E: division by zero\r\n");
 801fdce:	4b11      	ldr	r3, [pc, #68]	; (801fe14 <aiConvertInputFloat_2_Int8+0x124>)
 801fdd0:	781b      	ldrb	r3, [r3, #0]
 801fdd2:	b9b3      	cbnz	r3, 801fe02 <aiConvertInputFloat_2_Int8+0x112>
      return -1;
 801fdd4:	f04f 30ff 	mov.w	r0, #4294967295
 801fdd8:	e7e4      	b.n	801fda4 <aiConvertInputFloat_2_Int8+0xb4>
      SENSING1_PRINTF("E: no meta info\r\n");
 801fdda:	4b0e      	ldr	r3, [pc, #56]	; (801fe14 <aiConvertInputFloat_2_Int8+0x124>)
 801fddc:	781b      	ldrb	r3, [r3, #0]
 801fdde:	2b00      	cmp	r3, #0
 801fde0:	d0f8      	beq.n	801fdd4 <aiConvertInputFloat_2_Int8+0xe4>
 801fde2:	480e      	ldr	r0, [pc, #56]	; (801fe1c <aiConvertInputFloat_2_Int8+0x12c>)
 801fde4:	f008 f9b6 	bl	8028154 <puts>
      return -1;
 801fde8:	f04f 30ff 	mov.w	r0, #4294967295
 801fdec:	e7da      	b.n	801fda4 <aiConvertInputFloat_2_Int8+0xb4>
      SENSING1_PRINTF("E: network handle is NULL\r\n");
 801fdee:	4b09      	ldr	r3, [pc, #36]	; (801fe14 <aiConvertInputFloat_2_Int8+0x124>)
 801fdf0:	781b      	ldrb	r3, [r3, #0]
 801fdf2:	2b00      	cmp	r3, #0
 801fdf4:	d0ee      	beq.n	801fdd4 <aiConvertInputFloat_2_Int8+0xe4>
 801fdf6:	480a      	ldr	r0, [pc, #40]	; (801fe20 <aiConvertInputFloat_2_Int8+0x130>)
 801fdf8:	f008 f9ac 	bl	8028154 <puts>
      return -1;
 801fdfc:	f04f 30ff 	mov.w	r0, #4294967295
 801fe00:	e7d0      	b.n	801fda4 <aiConvertInputFloat_2_Int8+0xb4>
        SENSING1_PRINTF("E: division by zero\r\n");
 801fe02:	4808      	ldr	r0, [pc, #32]	; (801fe24 <aiConvertInputFloat_2_Int8+0x134>)
 801fe04:	f008 f9a6 	bl	8028154 <puts>
        return -1;
 801fe08:	f04f 30ff 	mov.w	r0, #4294967295
 801fe0c:	e7ca      	b.n	801fda4 <aiConvertInputFloat_2_Int8+0xb4>
 801fe0e:	bf00      	nop
 801fe10:	20010a1c 	.word	0x20010a1c
 801fe14:	20000d84 	.word	0x20000d84
 801fe18:	08042990 	.word	0x08042990
 801fe1c:	080429cc 	.word	0x080429cc
 801fe20:	08042974 	.word	0x08042974
 801fe24:	080429b4 	.word	0x080429b4

0801fe28 <aiConvertOutputInt8_2_Float>:
int aiConvertOutputInt8_2_Float(const char *nn_name, const int idx,
                                ai_i8 *In_int8, ai_float *Out_f32)
{
  if( AI_HANDLE_NULL == net_ctx[idx].handle)
 801fe28:	483b      	ldr	r0, [pc, #236]	; (801ff18 <aiConvertOutputInt8_2_Float+0xf0>)
 801fe2a:	ebc1 1101 	rsb	r1, r1, r1, lsl #4
 801fe2e:	eb00 01c1 	add.w	r1, r0, r1, lsl #3
{
 801fe32:	b538      	push	{r3, r4, r5, lr}
  if( AI_HANDLE_NULL == net_ctx[idx].handle)
 801fe34:	f8d1 00e0 	ldr.w	r0, [r1, #224]	; 0xe0
 801fe38:	2800      	cmp	r0, #0
 801fe3a:	d05c      	beq.n	801fef6 <aiConvertOutputInt8_2_Float+0xce>
  {
      SENSING1_PRINTF("E: network handle is NULL\r\n");
      return -1;
  }
  ai_buffer * bufferPtr   = &(net_ctx[idx].report.outputs[0]);
 801fe3c:	f8d1 411c 	ldr.w	r4, [r1, #284]	; 0x11c
  ai_buffer_format format = bufferPtr->format;
  int size  = AI_BUFFER_SIZE(bufferPtr);
 801fe40:	88e0      	ldrh	r0, [r4, #6]
 801fe42:	8921      	ldrh	r1, [r4, #8]
  ai_buffer_format format = bufferPtr->format;
 801fe44:	6825      	ldr	r5, [r4, #0]
  int size  = AI_BUFFER_SIZE(bufferPtr);
 801fe46:	fb00 f101 	mul.w	r1, r0, r1
 801fe4a:	68e0      	ldr	r0, [r4, #12]
 801fe4c:	fb01 f000 	mul.w	r0, r1, r0
  ai_float scale ;
  int zero_point ;

  if (AI_BUFFER_FMT_TYPE_Q != AI_BUFFER_FMT_GET_TYPE(format) &&\
 801fe50:	f3c5 4143 	ubfx	r1, r5, #17, #4
 801fe54:	2902      	cmp	r1, #2
 801fe56:	d001      	beq.n	801fe5c <aiConvertOutputInt8_2_Float+0x34>
 801fe58:	0229      	lsls	r1, r5, #8
 801fe5a:	d533      	bpl.n	801fec4 <aiConvertOutputInt8_2_Float+0x9c>
    8 != AI_BUFFER_FMT_GET_BITS(format))
  {
      SENSING1_PRINTF("E: expected signed integer 8 bits\r\n");
      return -1;
  }
  if (AI_BUFFER_META_INFO_INTQ(bufferPtr->meta_info)) {
 801fe5c:	6961      	ldr	r1, [r4, #20]
 801fe5e:	2900      	cmp	r1, #0
 801fe60:	d03f      	beq.n	801fee2 <aiConvertOutputInt8_2_Float+0xba>
 801fe62:	680c      	ldr	r4, [r1, #0]
 801fe64:	07e4      	lsls	r4, r4, #31
 801fe66:	d53c      	bpl.n	801fee2 <aiConvertOutputInt8_2_Float+0xba>
 801fe68:	684c      	ldr	r4, [r1, #4]
 801fe6a:	2c00      	cmp	r4, #0
 801fe6c:	d039      	beq.n	801fee2 <aiConvertOutputInt8_2_Float+0xba>
      scale = AI_BUFFER_META_INFO_INTQ_GET_SCALE(bufferPtr->meta_info, 0);
 801fe6e:	6865      	ldr	r5, [r4, #4]
 801fe70:	b395      	cbz	r5, 801fed8 <aiConvertOutputInt8_2_Float+0xb0>
 801fe72:	8861      	ldrh	r1, [r4, #2]
 801fe74:	b309      	cbz	r1, 801feba <aiConvertOutputInt8_2_Float+0x92>
      zero_point = AI_BUFFER_META_INFO_INTQ_GET_ZEROPOINT(bufferPtr->meta_info, 0);
 801fe76:	8821      	ldrh	r1, [r4, #0]
      scale = AI_BUFFER_META_INFO_INTQ_GET_SCALE(bufferPtr->meta_info, 0);
 801fe78:	682c      	ldr	r4, [r5, #0]
      zero_point = AI_BUFFER_META_INFO_INTQ_GET_ZEROPOINT(bufferPtr->meta_info, 0);
 801fe7a:	f011 0f02 	tst.w	r1, #2
 801fe7e:	6869      	ldr	r1, [r5, #4]
      scale = AI_BUFFER_META_INFO_INTQ_GET_SCALE(bufferPtr->meta_info, 0);
 801fe80:	edd4 6a00 	vldr	s13, [r4]
      zero_point = AI_BUFFER_META_INFO_INTQ_GET_ZEROPOINT(bufferPtr->meta_info, 0);
 801fe84:	bf14      	ite	ne
 801fe86:	7809      	ldrbne	r1, [r1, #0]
 801fe88:	f991 1000 	ldrsbeq.w	r1, [r1]
 801fe8c:	ee07 1a10 	vmov	s14, r1
  } else {
      SENSING1_PRINTF("E: no meta info\r\n");
      return -1;
  }
  
  for (uint32_t i = 0; i < size ; i++)
 801fe90:	b188      	cbz	r0, 801feb6 <aiConvertOutputInt8_2_Float+0x8e>
 801fe92:	3a01      	subs	r2, #1
  {
    Out_f32[i] = scale * ((ai_float)(In_int8[i]) - zero_point);
 801fe94:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
 801fe98:	1811      	adds	r1, r2, r0
 801fe9a:	f912 0f01 	ldrsb.w	r0, [r2, #1]!
 801fe9e:	ee07 0a90 	vmov	s15, r0
 801fea2:	eef8 7ae7 	vcvt.f32.s32	s15, s15
  for (uint32_t i = 0; i < size ; i++)
 801fea6:	4291      	cmp	r1, r2
    Out_f32[i] = scale * ((ai_float)(In_int8[i]) - zero_point);
 801fea8:	ee77 7ac7 	vsub.f32	s15, s15, s14
 801feac:	ee67 7aa6 	vmul.f32	s15, s15, s13
 801feb0:	ece3 7a01 	vstmia	r3!, {s15}
  for (uint32_t i = 0; i < size ; i++)
 801feb4:	d1f1      	bne.n	801fe9a <aiConvertOutputInt8_2_Float+0x72>
  }
  return 0; 
 801feb6:	2000      	movs	r0, #0
}
 801feb8:	bd38      	pop	{r3, r4, r5, pc}
      scale = AI_BUFFER_META_INFO_INTQ_GET_SCALE(bufferPtr->meta_info, 0);
 801feba:	eddf 6a18 	vldr	s13, [pc, #96]	; 801ff1c <aiConvertOutputInt8_2_Float+0xf4>
      zero_point = AI_BUFFER_META_INFO_INTQ_GET_ZEROPOINT(bufferPtr->meta_info, 0);
 801febe:	ee07 1a10 	vmov	s14, r1
 801fec2:	e7e5      	b.n	801fe90 <aiConvertOutputInt8_2_Float+0x68>
    8 != AI_BUFFER_FMT_GET_BITS(format))
 801fec4:	f3c5 15c6 	ubfx	r5, r5, #7, #7
    ! AI_BUFFER_FMT_GET_SIGN(format) &&\
 801fec8:	2d08      	cmp	r5, #8
 801feca:	d0c7      	beq.n	801fe5c <aiConvertOutputInt8_2_Float+0x34>
      SENSING1_PRINTF("E: expected signed integer 8 bits\r\n");
 801fecc:	4b14      	ldr	r3, [pc, #80]	; (801ff20 <aiConvertOutputInt8_2_Float+0xf8>)
 801fece:	781b      	ldrb	r3, [r3, #0]
 801fed0:	b9db      	cbnz	r3, 801ff0a <aiConvertOutputInt8_2_Float+0xe2>
      return -1;
 801fed2:	f04f 30ff 	mov.w	r0, #4294967295
}
 801fed6:	bd38      	pop	{r3, r4, r5, pc}
      scale = AI_BUFFER_META_INFO_INTQ_GET_SCALE(bufferPtr->meta_info, 0);
 801fed8:	eddf 6a10 	vldr	s13, [pc, #64]	; 801ff1c <aiConvertOutputInt8_2_Float+0xf4>
      zero_point = AI_BUFFER_META_INFO_INTQ_GET_ZEROPOINT(bufferPtr->meta_info, 0);
 801fedc:	ee07 5a10 	vmov	s14, r5
 801fee0:	e7d6      	b.n	801fe90 <aiConvertOutputInt8_2_Float+0x68>
      SENSING1_PRINTF("E: no meta info\r\n");
 801fee2:	4b0f      	ldr	r3, [pc, #60]	; (801ff20 <aiConvertOutputInt8_2_Float+0xf8>)
 801fee4:	781b      	ldrb	r3, [r3, #0]
 801fee6:	2b00      	cmp	r3, #0
 801fee8:	d0f3      	beq.n	801fed2 <aiConvertOutputInt8_2_Float+0xaa>
 801feea:	480e      	ldr	r0, [pc, #56]	; (801ff24 <aiConvertOutputInt8_2_Float+0xfc>)
 801feec:	f008 f932 	bl	8028154 <puts>
      return -1;
 801fef0:	f04f 30ff 	mov.w	r0, #4294967295
}
 801fef4:	bd38      	pop	{r3, r4, r5, pc}
      SENSING1_PRINTF("E: network handle is NULL\r\n");
 801fef6:	4b0a      	ldr	r3, [pc, #40]	; (801ff20 <aiConvertOutputInt8_2_Float+0xf8>)
 801fef8:	781b      	ldrb	r3, [r3, #0]
 801fefa:	2b00      	cmp	r3, #0
 801fefc:	d0e9      	beq.n	801fed2 <aiConvertOutputInt8_2_Float+0xaa>
 801fefe:	480a      	ldr	r0, [pc, #40]	; (801ff28 <aiConvertOutputInt8_2_Float+0x100>)
 801ff00:	f008 f928 	bl	8028154 <puts>
      return -1;
 801ff04:	f04f 30ff 	mov.w	r0, #4294967295
}
 801ff08:	bd38      	pop	{r3, r4, r5, pc}
      SENSING1_PRINTF("E: expected signed integer 8 bits\r\n");
 801ff0a:	4808      	ldr	r0, [pc, #32]	; (801ff2c <aiConvertOutputInt8_2_Float+0x104>)
 801ff0c:	f008 f922 	bl	8028154 <puts>
      return -1;
 801ff10:	f04f 30ff 	mov.w	r0, #4294967295
}
 801ff14:	bd38      	pop	{r3, r4, r5, pc}
 801ff16:	bf00      	nop
 801ff18:	20010a1c 	.word	0x20010a1c
 801ff1c:	00000000 	.word	0x00000000
 801ff20:	20000d84 	.word	0x20000d84
 801ff24:	080429cc 	.word	0x080429cc
 801ff28:	08042974 	.word	0x08042974
 801ff2c:	08042990 	.word	0x08042990

0801ff30 <aiRun>:

int aiRun(const char *nn_name, const int idx, void *in_data, void *out_data)
{
 801ff30:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 801ff34:	b08f      	sub	sp, #60	; 0x3c
  ai_buffer ai_input[1];
  ai_buffer ai_output[1];
  ai_i32 batch;
  ai_error err;

  if( AI_HANDLE_NULL == net_ctx[idx].handle)
 801ff36:	4f35      	ldr	r7, [pc, #212]	; (802000c <aiRun+0xdc>)
{
 801ff38:	4699      	mov	r9, r3
  if( AI_HANDLE_NULL == net_ctx[idx].handle)
 801ff3a:	010b      	lsls	r3, r1, #4
 801ff3c:	9301      	str	r3, [sp, #4]
 801ff3e:	ebc1 1301 	rsb	r3, r1, r1, lsl #4
 801ff42:	eb07 03c3 	add.w	r3, r7, r3, lsl #3
 801ff46:	f8d3 60e0 	ldr.w	r6, [r3, #224]	; 0xe0
 801ff4a:	2e00      	cmp	r6, #0
 801ff4c:	d04b      	beq.n	801ffe6 <aiRun+0xb6>

  ai_input[0] = net_ctx[idx].report.inputs[0];
  ai_input[0].n_batches  = 1;
  ai_input[0].data = AI_HANDLE_PTR(in_data);

  ai_output[0] = net_ctx[idx].report.outputs[0];
 801ff4e:	e9d3 5446 	ldrd	r5, r4, [r3, #280]	; 0x118
 801ff52:	4692      	mov	sl, r2
 801ff54:	4688      	mov	r8, r1
  ai_input[0] = net_ctx[idx].report.inputs[0];
 801ff56:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 801ff58:	f10d 0e08 	add.w	lr, sp, #8
 801ff5c:	e8ae 000f 	stmia.w	lr!, {r0, r1, r2, r3}
 801ff60:	e895 0003 	ldmia.w	r5, {r0, r1}
 801ff64:	e88e 0003 	stmia.w	lr, {r0, r1}
  ai_input[0].n_batches  = 1;
 801ff68:	f04f 0b01 	mov.w	fp, #1
  ai_input[0].data = AI_HANDLE_PTR(in_data);
 801ff6c:	f8cd a018 	str.w	sl, [sp, #24]
  ai_input[0].n_batches  = 1;
 801ff70:	f8ad b00c 	strh.w	fp, [sp, #12]
  ai_output[0] = net_ctx[idx].report.outputs[0];
 801ff74:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 801ff76:	f10d 0c20 	add.w	ip, sp, #32
 801ff7a:	e8ac 000f 	stmia.w	ip!, {r0, r1, r2, r3}
 801ff7e:	e894 0003 	ldmia.w	r4, {r0, r1}
        if ((inst) && (&gnetworks[i] == inst))
 801ff82:	42be      	cmp	r6, r7
  ai_output[0] = net_ctx[idx].report.outputs[0];
 801ff84:	e88c 0003 	stmia.w	ip, {r0, r1}
  ai_output[0].n_batches = 1;
 801ff88:	f8ad b024 	strh.w	fp, [sp, #36]	; 0x24
  ai_output[0].data = AI_HANDLE_PTR(out_data);
 801ff8c:	f8cd 9030 	str.w	r9, [sp, #48]	; 0x30
        if ((inst) && (&gnetworks[i] == inst))
 801ff90:	d015      	beq.n	801ffbe <aiRun+0x8e>
 801ff92:	f107 0338 	add.w	r3, r7, #56	; 0x38
 801ff96:	429e      	cmp	r6, r3
 801ff98:	d011      	beq.n	801ffbe <aiRun+0x8e>
 801ff9a:	f107 0370 	add.w	r3, r7, #112	; 0x70
 801ff9e:	429e      	cmp	r6, r3
 801ffa0:	d00d      	beq.n	801ffbe <aiRun+0x8e>
 801ffa2:	f107 03a8 	add.w	r3, r7, #168	; 0xa8
 801ffa6:	429e      	cmp	r6, r3
 801ffa8:	d009      	beq.n	801ffbe <aiRun+0x8e>

  batch = ai_mnetwork_run(net_ctx[idx].handle, &ai_input[0], &ai_output[0]);
  if (batch != 1) {
      err = ai_mnetwork_get_error(net_ctx[idx].handle);
 801ffaa:	4630      	mov	r0, r6
 801ffac:	f7ff fdfc 	bl	801fba8 <ai_mnetwork_get_error>
        SENSING1_PRINTF("E: AI error (%s) - type=%d code=%d\r\n", fct,
 801ffb0:	4b17      	ldr	r3, [pc, #92]	; (8020010 <aiRun+0xe0>)
 801ffb2:	781b      	ldrb	r3, [r3, #0]
      err = ai_mnetwork_get_error(net_ctx[idx].handle);
 801ffb4:	4602      	mov	r2, r0
        SENSING1_PRINTF("E: AI error (%s) - type=%d code=%d\r\n", fct,
 801ffb6:	b97b      	cbnz	r3, 801ffd8 <aiRun+0xa8>
      aiLogErr(err,"ai_mnetwork_run");
      return  -1;
 801ffb8:	f04f 30ff 	mov.w	r0, #4294967295
 801ffbc:	e009      	b.n	801ffd2 <aiRun+0xa2>
        return inn->entry->ai_run(inn->handle, input, output);
 801ffbe:	e9d6 3000 	ldrd	r3, r0, [r6]
 801ffc2:	aa08      	add	r2, sp, #32
 801ffc4:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 801ffc6:	a902      	add	r1, sp, #8
 801ffc8:	4798      	blx	r3
  if (batch != 1) {
 801ffca:	2801      	cmp	r0, #1
  }
  return 0;
 801ffcc:	bf08      	it	eq
 801ffce:	2000      	moveq	r0, #0
  if (batch != 1) {
 801ffd0:	d113      	bne.n	801fffa <aiRun+0xca>
}
 801ffd2:	b00f      	add	sp, #60	; 0x3c
 801ffd4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        SENSING1_PRINTF("E: AI error (%s) - type=%d code=%d\r\n", fct,
 801ffd8:	0a13      	lsrs	r3, r2, #8
 801ffda:	490e      	ldr	r1, [pc, #56]	; (8020014 <aiRun+0xe4>)
 801ffdc:	480e      	ldr	r0, [pc, #56]	; (8020018 <aiRun+0xe8>)
 801ffde:	b2d2      	uxtb	r2, r2
 801ffe0:	f008 f81c 	bl	802801c <iprintf>
 801ffe4:	e7e8      	b.n	801ffb8 <aiRun+0x88>
      SENSING1_PRINTF("E: network handle is NULL\r\n");
 801ffe6:	4b0a      	ldr	r3, [pc, #40]	; (8020010 <aiRun+0xe0>)
 801ffe8:	781b      	ldrb	r3, [r3, #0]
 801ffea:	2b00      	cmp	r3, #0
 801ffec:	d0e4      	beq.n	801ffb8 <aiRun+0x88>
 801ffee:	480b      	ldr	r0, [pc, #44]	; (802001c <aiRun+0xec>)
 801fff0:	f008 f8b0 	bl	8028154 <puts>
      return -1;
 801fff4:	f04f 30ff 	mov.w	r0, #4294967295
 801fff8:	e7eb      	b.n	801ffd2 <aiRun+0xa2>
      err = ai_mnetwork_get_error(net_ctx[idx].handle);
 801fffa:	9b01      	ldr	r3, [sp, #4]
 801fffc:	eba3 0808 	sub.w	r8, r3, r8
 8020000:	eb07 07c8 	add.w	r7, r7, r8, lsl #3
 8020004:	f8d7 60e0 	ldr.w	r6, [r7, #224]	; 0xe0
 8020008:	e7cf      	b.n	801ffaa <aiRun+0x7a>
 802000a:	bf00      	nop
 802000c:	20010a1c 	.word	0x20010a1c
 8020010:	20000d84 	.word	0x20000d84
 8020014:	080429e0 	.word	0x080429e0
 8020018:	08042910 	.word	0x08042910
 802001c:	08042974 	.word	0x08042974

08020020 <aiInit>:

int aiInit(const char *nn_name, const int idx)
{
 8020020:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  ai_error err;
  ai_u32 ext_addr =0 , sz=0;
 
  /* Creating the network */
  SENSING1_PRINTF("Creating the network \"%s\"..\r\n", nn_name);
 8020024:	f8df 8390 	ldr.w	r8, [pc, #912]	; 80203b8 <aiInit+0x398>
{
 8020028:	ed2d 8b02 	vpush	{d8}
  SENSING1_PRINTF("Creating the network \"%s\"..\r\n", nn_name);
 802002c:	f898 3000 	ldrb.w	r3, [r8]
{
 8020030:	ee08 0a10 	vmov	s16, r0
 8020034:	b091      	sub	sp, #68	; 0x44
 8020036:	460e      	mov	r6, r1
  SENSING1_PRINTF("Creating the network \"%s\"..\r\n", nn_name);
 8020038:	2b00      	cmp	r3, #0
 802003a:	f040 80cd 	bne.w	80201d8 <aiInit+0x1b8>
  err = ai_mnetwork_create(nn_name, &net_ctx[idx].handle, NULL);
 802003e:	4fc7      	ldr	r7, [pc, #796]	; (802035c <aiInit+0x33c>)
 8020040:	0133      	lsls	r3, r6, #4
 8020042:	ebc6 1106 	rsb	r1, r6, r6, lsl #4
 8020046:	9303      	str	r3, [sp, #12]
 8020048:	f107 03e0 	add.w	r3, r7, #224	; 0xe0
 802004c:	2200      	movs	r2, #0
 802004e:	ee18 0a10 	vmov	r0, s16
 8020052:	00cc      	lsls	r4, r1, #3
 8020054:	eb03 01c1 	add.w	r1, r3, r1, lsl #3
 8020058:	f7ff fcfc 	bl	801fa54 <ai_mnetwork_create>
  if (err.type) {
 802005c:	f010 02ff 	ands.w	r2, r0, #255	; 0xff
  err = ai_mnetwork_create(nn_name, &net_ctx[idx].handle, NULL);
 8020060:	4605      	mov	r5, r0
  if (err.type) {
 8020062:	f040 81ad 	bne.w	80203c0 <aiInit+0x3a0>
      aiLogErr(err, "ai_mnetwork_create");
      return -1;
  }

  /* Query the created network to get relevant info from it */
  if (ai_mnetwork_get_info(net_ctx[idx].handle, &net_ctx[idx].report)) {
 8020066:	193b      	adds	r3, r7, r4
 8020068:	463d      	mov	r5, r7
 802006a:	f8d3 00e0 	ldr.w	r0, [r3, #224]	; 0xe0
 802006e:	463b      	mov	r3, r7
        if ((inst) && (&gnetworks[i] == inst))
 8020070:	469c      	mov	ip, r3
 8020072:	b1d8      	cbz	r0, 80200ac <aiInit+0x8c>
 8020074:	4298      	cmp	r0, r3
 8020076:	d020      	beq.n	80200ba <aiInit+0x9a>
    for (int i=0; i<AI_MNETWORK_NUMBER; i++) {
 8020078:	3201      	adds	r2, #1
 802007a:	2a04      	cmp	r2, #4
 802007c:	f103 0338 	add.w	r3, r3, #56	; 0x38
 8020080:	d1f6      	bne.n	8020070 <aiInit+0x50>
      aiPrintNetworkInfo(&net_ctx[idx].report);
  } else {
      err = ai_mnetwork_get_error(net_ctx[idx].handle);
 8020082:	f7ff fd91 	bl	801fba8 <ai_mnetwork_get_error>
        SENSING1_PRINTF("E: AI error (%s) - type=%d code=%d\r\n", fct,
 8020086:	f898 3000 	ldrb.w	r3, [r8]
 802008a:	2b00      	cmp	r3, #0
 802008c:	f040 81b7 	bne.w	80203fe <aiInit+0x3de>
    				((ai_u32)ext_addr & (ai_u32)0xFF000000))?"internal":"external");
                    
  if (!ai_mnetwork_init(net_ctx[idx].handle, &params)) {
      err = ai_mnetwork_get_error(net_ctx[idx].handle);
      aiLogErr(err, "ai_mnetwork_init");
      ai_mnetwork_destroy(net_ctx[idx].handle);
 8020090:	9b03      	ldr	r3, [sp, #12]
 8020092:	1b9e      	subs	r6, r3, r6
 8020094:	eb07 07c6 	add.w	r7, r7, r6, lsl #3
 8020098:	f8d7 00e0 	ldr.w	r0, [r7, #224]	; 0xe0
 802009c:	f7ff fd46 	bl	801fb2c <ai_mnetwork_destroy>
      net_ctx[idx].handle = AI_HANDLE_NULL;
 80200a0:	2300      	movs	r3, #0
 80200a2:	f8c7 30e0 	str.w	r3, [r7, #224]	; 0xe0
      return -1;
 80200a6:	f04f 30ff 	mov.w	r0, #4294967295
 80200aa:	e06e      	b.n	802018a <aiInit+0x16a>
        else if ((!inst) && (gnetworks[i].entry == NULL))
 80200ac:	6819      	ldr	r1, [r3, #0]
 80200ae:	2900      	cmp	r1, #0
 80200b0:	d1e2      	bne.n	8020078 <aiInit+0x58>
            return &gnetworks[i];
 80200b2:	ebc2 02c2 	rsb	r2, r2, r2, lsl #3
 80200b6:	eb07 0cc2 	add.w	ip, r7, r2, lsl #3
        return inn->entry->ai_get_info(inn->handle, report);
 80200ba:	4ba9      	ldr	r3, [pc, #676]	; (8020360 <aiInit+0x340>)
  if (ai_mnetwork_get_info(net_ctx[idx].handle, &net_ctx[idx].report)) {
 80200bc:	1d21      	adds	r1, r4, #4
        return inn->entry->ai_get_info(inn->handle, report);
 80200be:	4419      	add	r1, r3
 80200c0:	e9dc 3000 	ldrd	r3, r0, [ip]
 80200c4:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 80200c6:	4798      	blx	r3
  if (ai_mnetwork_get_info(net_ctx[idx].handle, &net_ctx[idx].report)) {
 80200c8:	2800      	cmp	r0, #0
 80200ca:	f000 819f 	beq.w	802040c <aiInit+0x3ec>
    SENSING1_PRINTF("Network configuration...\r\n");
 80200ce:	f898 3000 	ldrb.w	r3, [r8]
 80200d2:	2b00      	cmp	r3, #0
 80200d4:	f040 808e 	bne.w	80201f4 <aiInit+0x1d4>
    for (i=0; i<report->n_inputs; i++)
 80200d8:	9b03      	ldr	r3, [sp, #12]
 80200da:	1b9b      	subs	r3, r3, r6
 80200dc:	eb07 09c3 	add.w	r9, r7, r3, lsl #3
 80200e0:	f8b9 2114 	ldrh.w	r2, [r9, #276]	; 0x114
 80200e4:	b192      	cbz	r2, 802010c <aiInit+0xec>
 80200e6:	f04f 0b00 	mov.w	fp, #0
        aiPrintLayoutBuffer("   I", i, &report->inputs[i]);
 80200ea:	f8df a2d0 	ldr.w	sl, [pc, #720]	; 80203bc <aiInit+0x39c>
    for (i=0; i<report->n_inputs; i++)
 80200ee:	465c      	mov	r4, fp
        aiPrintLayoutBuffer("   I", i, &report->inputs[i]);
 80200f0:	f8d9 2118 	ldr.w	r2, [r9, #280]	; 0x118
 80200f4:	4621      	mov	r1, r4
 80200f6:	445a      	add	r2, fp
 80200f8:	4650      	mov	r0, sl
 80200fa:	f7ff fc0b 	bl	801f914 <aiPrintLayoutBuffer>
    for (i=0; i<report->n_inputs; i++)
 80200fe:	f8b9 3114 	ldrh.w	r3, [r9, #276]	; 0x114
 8020102:	3401      	adds	r4, #1
 8020104:	429c      	cmp	r4, r3
 8020106:	f10b 0b18 	add.w	fp, fp, #24
 802010a:	dbf1      	blt.n	80200f0 <aiInit+0xd0>
    for (i=0; i<report->n_outputs; i++)
 802010c:	9b03      	ldr	r3, [sp, #12]
 802010e:	1b9b      	subs	r3, r3, r6
 8020110:	eb07 0ac3 	add.w	sl, r7, r3, lsl #3
 8020114:	f8ba 2116 	ldrh.w	r2, [sl, #278]	; 0x116
 8020118:	b18a      	cbz	r2, 802013e <aiInit+0x11e>
 802011a:	f04f 0b00 	mov.w	fp, #0
        aiPrintLayoutBuffer("   O", i, &report->outputs[i]);
 802011e:	4891      	ldr	r0, [pc, #580]	; (8020364 <aiInit+0x344>)
    for (i=0; i<report->n_outputs; i++)
 8020120:	465c      	mov	r4, fp
        aiPrintLayoutBuffer("   O", i, &report->outputs[i]);
 8020122:	f8da 211c 	ldr.w	r2, [sl, #284]	; 0x11c
 8020126:	4621      	mov	r1, r4
 8020128:	445a      	add	r2, fp
 802012a:	f7ff fbf3 	bl	801f914 <aiPrintLayoutBuffer>
    for (i=0; i<report->n_outputs; i++)
 802012e:	f8ba 3116 	ldrh.w	r3, [sl, #278]	; 0x116
 8020132:	488c      	ldr	r0, [pc, #560]	; (8020364 <aiInit+0x344>)
 8020134:	3401      	adds	r4, #1
 8020136:	429c      	cmp	r4, r3
 8020138:	f10b 0b18 	add.w	fp, fp, #24
 802013c:	dbf1      	blt.n	8020122 <aiInit+0x102>
  SENSING1_PRINTF("Initializing the network %s\r\n",nn_name);
 802013e:	f898 4000 	ldrb.w	r4, [r8]
 8020142:	2c00      	cmp	r4, #0
 8020144:	d14e      	bne.n	80201e4 <aiInit+0x1c4>
    ai_network_params params = {
 8020146:	222c      	movs	r2, #44	; 0x2c
 8020148:	2100      	movs	r1, #0
 802014a:	a805      	add	r0, sp, #20
 802014c:	f007 fa14 	bl	8027578 <memset>
    if (ai_mnetwork_get_ext_data_activations(net_ctx[idx].handle, &ext_addr, &sz) == 0) {
 8020150:	9b03      	ldr	r3, [sp, #12]
 8020152:	1b9b      	subs	r3, r3, r6
 8020154:	eb07 03c3 	add.w	r3, r7, r3, lsl #3
 8020158:	f8d3 00e0 	ldr.w	r0, [r3, #224]	; 0xe0
    ai_network_params params = {
 802015c:	4b82      	ldr	r3, [pc, #520]	; (8020368 <aiInit+0x348>)
 802015e:	9304      	str	r3, [sp, #16]
 8020160:	930a      	str	r3, [sp, #40]	; 0x28
    for (int i=0; i<AI_MNETWORK_NUMBER; i++) {
 8020162:	2300      	movs	r3, #0
 8020164:	462a      	mov	r2, r5
        if ((inst) && (&gnetworks[i] == inst))
 8020166:	b1a8      	cbz	r0, 8020194 <aiInit+0x174>
 8020168:	42a8      	cmp	r0, r5
 802016a:	d01a      	beq.n	80201a2 <aiInit+0x182>
    for (int i=0; i<AI_MNETWORK_NUMBER; i++) {
 802016c:	3301      	adds	r3, #1
 802016e:	2b04      	cmp	r3, #4
 8020170:	f105 0538 	add.w	r5, r5, #56	; 0x38
 8020174:	d1f6      	bne.n	8020164 <aiInit+0x144>
  ai_u32 ext_addr =0 , sz=0;
 8020176:	2200      	movs	r2, #0
 8020178:	4611      	mov	r1, r2
    SENSING1_PRINTF(" Activation buffer  : 0x%lx (%d bytes) %s\r\n", ext_addr, (int)sz,
 802017a:	b9dc      	cbnz	r4, 80201b4 <aiInit+0x194>
  if (!ai_mnetwork_init(net_ctx[idx].handle, &params)) {
 802017c:	a904      	add	r1, sp, #16
 802017e:	f7ff fd35 	bl	801fbec <ai_mnetwork_init>
 8020182:	2800      	cmp	r0, #0
 8020184:	f000 8127 	beq.w	80203d6 <aiInit+0x3b6>
  }
  return 0;
 8020188:	2000      	movs	r0, #0
}
 802018a:	b011      	add	sp, #68	; 0x44
 802018c:	ecbd 8b02 	vpop	{d8}
 8020190:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        else if ((!inst) && (gnetworks[i].entry == NULL))
 8020194:	682a      	ldr	r2, [r5, #0]
 8020196:	2a00      	cmp	r2, #0
 8020198:	d1e8      	bne.n	802016c <aiInit+0x14c>
            return &gnetworks[i];
 802019a:	ebc3 03c3 	rsb	r3, r3, r3, lsl #3
 802019e:	eb07 02c3 	add.w	r2, r7, r3, lsl #3
         *add = inn->entry->extActBufferStartAddr;
 80201a2:	6813      	ldr	r3, [r2, #0]
 80201a4:	6d99      	ldr	r1, [r3, #88]	; 0x58
    	if (ext_addr == 0xFFFFFFFF) {
 80201a6:	1c4a      	adds	r2, r1, #1
 80201a8:	f000 80c3 	beq.w	8020332 <aiInit+0x312>
         *size = inn->entry->actBufferSize;
 80201ac:	6dda      	ldr	r2, [r3, #92]	; 0x5c
    		params.activations.data = (ai_handle)ext_addr;
 80201ae:	910e      	str	r1, [sp, #56]	; 0x38
    SENSING1_PRINTF(" Activation buffer  : 0x%lx (%d bytes) %s\r\n", ext_addr, (int)sz,
 80201b0:	2c00      	cmp	r4, #0
 80201b2:	d0e3      	beq.n	802017c <aiInit+0x15c>
 80201b4:	4b6a      	ldr	r3, [pc, #424]	; (8020360 <aiInit+0x340>)
 80201b6:	486d      	ldr	r0, [pc, #436]	; (802036c <aiInit+0x34c>)
 80201b8:	404b      	eors	r3, r1
 80201ba:	f013 4f7f 	tst.w	r3, #4278190080	; 0xff000000
 80201be:	4b6c      	ldr	r3, [pc, #432]	; (8020370 <aiInit+0x350>)
 80201c0:	bf08      	it	eq
 80201c2:	4603      	moveq	r3, r0
 80201c4:	486b      	ldr	r0, [pc, #428]	; (8020374 <aiInit+0x354>)
 80201c6:	f007 ff29 	bl	802801c <iprintf>
  if (!ai_mnetwork_init(net_ctx[idx].handle, &params)) {
 80201ca:	9b03      	ldr	r3, [sp, #12]
 80201cc:	1b9b      	subs	r3, r3, r6
 80201ce:	eb07 03c3 	add.w	r3, r7, r3, lsl #3
 80201d2:	f8d3 00e0 	ldr.w	r0, [r3, #224]	; 0xe0
 80201d6:	e7d1      	b.n	802017c <aiInit+0x15c>
  SENSING1_PRINTF("Creating the network \"%s\"..\r\n", nn_name);
 80201d8:	ee18 1a10 	vmov	r1, s16
 80201dc:	4866      	ldr	r0, [pc, #408]	; (8020378 <aiInit+0x358>)
 80201de:	f007 ff1d 	bl	802801c <iprintf>
 80201e2:	e72c      	b.n	802003e <aiInit+0x1e>
  SENSING1_PRINTF("Initializing the network %s\r\n",nn_name);
 80201e4:	ee18 1a10 	vmov	r1, s16
 80201e8:	4864      	ldr	r0, [pc, #400]	; (802037c <aiInit+0x35c>)
 80201ea:	f007 ff17 	bl	802801c <iprintf>
    SENSING1_PRINTF(" Activation buffer  : 0x%lx (%d bytes) %s\r\n", ext_addr, (int)sz,
 80201ee:	f898 4000 	ldrb.w	r4, [r8]
 80201f2:	e7a8      	b.n	8020146 <aiInit+0x126>
    SENSING1_PRINTF("Network configuration...\r\n");
 80201f4:	4862      	ldr	r0, [pc, #392]	; (8020380 <aiInit+0x360>)
 80201f6:	f007 ffad 	bl	8028154 <puts>
    SENSING1_PRINTF(" Model name         : %s\r\n", report->model_name);
 80201fa:	f898 3000 	ldrb.w	r3, [r8]
 80201fe:	2b00      	cmp	r3, #0
 8020200:	f43f af6a 	beq.w	80200d8 <aiInit+0xb8>
 8020204:	9b03      	ldr	r3, [sp, #12]
 8020206:	485f      	ldr	r0, [pc, #380]	; (8020384 <aiInit+0x364>)
 8020208:	1b9c      	subs	r4, r3, r6
 802020a:	eb07 04c4 	add.w	r4, r7, r4, lsl #3
 802020e:	f8d4 10e4 	ldr.w	r1, [r4, #228]	; 0xe4
 8020212:	f007 ff03 	bl	802801c <iprintf>
    SENSING1_PRINTF(" Model signature    : %s\r\n", report->model_signature);
 8020216:	f898 3000 	ldrb.w	r3, [r8]
 802021a:	2b00      	cmp	r3, #0
 802021c:	f43f af5c 	beq.w	80200d8 <aiInit+0xb8>
 8020220:	f8d4 10e8 	ldr.w	r1, [r4, #232]	; 0xe8
 8020224:	4858      	ldr	r0, [pc, #352]	; (8020388 <aiInit+0x368>)
 8020226:	f007 fef9 	bl	802801c <iprintf>
    SENSING1_PRINTF(" Model datetime     : %s\r\n", report->model_datetime);
 802022a:	f898 3000 	ldrb.w	r3, [r8]
 802022e:	2b00      	cmp	r3, #0
 8020230:	f43f af52 	beq.w	80200d8 <aiInit+0xb8>
 8020234:	f8d4 10ec 	ldr.w	r1, [r4, #236]	; 0xec
 8020238:	4854      	ldr	r0, [pc, #336]	; (802038c <aiInit+0x36c>)
 802023a:	f007 feef 	bl	802801c <iprintf>
    SENSING1_PRINTF(" Compile datetime   : %s\r\n", report->compile_datetime);
 802023e:	f898 3000 	ldrb.w	r3, [r8]
 8020242:	2b00      	cmp	r3, #0
 8020244:	f43f af48 	beq.w	80200d8 <aiInit+0xb8>
 8020248:	f8d4 10f0 	ldr.w	r1, [r4, #240]	; 0xf0
 802024c:	4850      	ldr	r0, [pc, #320]	; (8020390 <aiInit+0x370>)
 802024e:	f007 fee5 	bl	802801c <iprintf>
    SENSING1_PRINTF(" Runtime revision   : %d.%d.%d\r\n",
 8020252:	f898 3000 	ldrb.w	r3, [r8]
 8020256:	2b00      	cmp	r3, #0
 8020258:	f43f af3e 	beq.w	80200d8 <aiInit+0xb8>
 802025c:	f894 30fa 	ldrb.w	r3, [r4, #250]	; 0xfa
 8020260:	f894 20f9 	ldrb.w	r2, [r4, #249]	; 0xf9
 8020264:	f894 10f8 	ldrb.w	r1, [r4, #248]	; 0xf8
 8020268:	484a      	ldr	r0, [pc, #296]	; (8020394 <aiInit+0x374>)
 802026a:	f007 fed7 	bl	802801c <iprintf>
    SENSING1_PRINTF(" Tool revision      : %s (%d.%d.%d)\r\n", report->tool_revision,
 802026e:	f898 3000 	ldrb.w	r3, [r8]
 8020272:	2b00      	cmp	r3, #0
 8020274:	f43f af30 	beq.w	80200d8 <aiInit+0xb8>
 8020278:	f894 3102 	ldrb.w	r3, [r4, #258]	; 0x102
 802027c:	9300      	str	r3, [sp, #0]
 802027e:	f894 3101 	ldrb.w	r3, [r4, #257]	; 0x101
 8020282:	f894 2100 	ldrb.w	r2, [r4, #256]	; 0x100
 8020286:	f8d4 10fc 	ldr.w	r1, [r4, #252]	; 0xfc
 802028a:	4843      	ldr	r0, [pc, #268]	; (8020398 <aiInit+0x378>)
 802028c:	f007 fec6 	bl	802801c <iprintf>
    SENSING1_PRINTF("Network info...\r\n");
 8020290:	f898 3000 	ldrb.w	r3, [r8]
 8020294:	2b00      	cmp	r3, #0
 8020296:	f43f af1f 	beq.w	80200d8 <aiInit+0xb8>
 802029a:	4840      	ldr	r0, [pc, #256]	; (802039c <aiInit+0x37c>)
 802029c:	f007 ff5a 	bl	8028154 <puts>
    SENSING1_PRINTF("  nodes             : %ld\r\n", report->n_nodes);
 80202a0:	f898 3000 	ldrb.w	r3, [r8]
 80202a4:	2b00      	cmp	r3, #0
 80202a6:	f43f af17 	beq.w	80200d8 <aiInit+0xb8>
 80202aa:	9b03      	ldr	r3, [sp, #12]
 80202ac:	483c      	ldr	r0, [pc, #240]	; (80203a0 <aiInit+0x380>)
 80202ae:	1b9c      	subs	r4, r3, r6
 80202b0:	eb07 04c4 	add.w	r4, r7, r4, lsl #3
 80202b4:	f8d4 1150 	ldr.w	r1, [r4, #336]	; 0x150
 80202b8:	f007 feb0 	bl	802801c <iprintf>
    SENSING1_PRINTF("  complexity        : %ld MACC\r\n", report->n_macc);
 80202bc:	f898 3000 	ldrb.w	r3, [r8]
 80202c0:	2b00      	cmp	r3, #0
 80202c2:	f43f af09 	beq.w	80200d8 <aiInit+0xb8>
 80202c6:	f8d4 1110 	ldr.w	r1, [r4, #272]	; 0x110
 80202ca:	4836      	ldr	r0, [pc, #216]	; (80203a4 <aiInit+0x384>)
 80202cc:	f007 fea6 	bl	802801c <iprintf>
    SENSING1_PRINTF("  activation        : %ld bytes\r\n",
 80202d0:	f898 3000 	ldrb.w	r3, [r8]
 80202d4:	2b00      	cmp	r3, #0
 80202d6:	f43f aeff 	beq.w	80200d8 <aiInit+0xb8>
 80202da:	f8b4 1126 	ldrh.w	r1, [r4, #294]	; 0x126
 80202de:	f8b4 3128 	ldrh.w	r3, [r4, #296]	; 0x128
 80202e2:	4831      	ldr	r0, [pc, #196]	; (80203a8 <aiInit+0x388>)
 80202e4:	fb01 f303 	mul.w	r3, r1, r3
 80202e8:	f8d4 112c 	ldr.w	r1, [r4, #300]	; 0x12c
 80202ec:	fb03 f101 	mul.w	r1, r3, r1
 80202f0:	f007 fe94 	bl	802801c <iprintf>
    SENSING1_PRINTF("  params            : %ld bytes\r\n",
 80202f4:	f898 3000 	ldrb.w	r3, [r8]
 80202f8:	2b00      	cmp	r3, #0
 80202fa:	f43f aeed 	beq.w	80200d8 <aiInit+0xb8>
 80202fe:	f8b4 113e 	ldrh.w	r1, [r4, #318]	; 0x13e
 8020302:	f8b4 3140 	ldrh.w	r3, [r4, #320]	; 0x140
 8020306:	4829      	ldr	r0, [pc, #164]	; (80203ac <aiInit+0x38c>)
 8020308:	fb01 f303 	mul.w	r3, r1, r3
 802030c:	f8d4 1144 	ldr.w	r1, [r4, #324]	; 0x144
 8020310:	fb03 f101 	mul.w	r1, r3, r1
 8020314:	f007 fe82 	bl	802801c <iprintf>
    SENSING1_PRINTF("  inputs/outputs    : %u/%u\r\n", report->n_inputs,
 8020318:	f898 3000 	ldrb.w	r3, [r8]
 802031c:	2b00      	cmp	r3, #0
 802031e:	f43f aedb 	beq.w	80200d8 <aiInit+0xb8>
 8020322:	f8b4 2116 	ldrh.w	r2, [r4, #278]	; 0x116
 8020326:	f8b4 1114 	ldrh.w	r1, [r4, #276]	; 0x114
 802032a:	4821      	ldr	r0, [pc, #132]	; (80203b0 <aiInit+0x390>)
 802032c:	f007 fe76 	bl	802801c <iprintf>
 8020330:	e6d2      	b.n	80200d8 <aiInit+0xb8>
    		sz = (ai_u32)AI_BUFFER_SIZE(&net_ctx[idx].report.activations);
 8020332:	9b03      	ldr	r3, [sp, #12]
    		params.activations.data = (ai_handle)activations;
 8020334:	491f      	ldr	r1, [pc, #124]	; (80203b4 <aiInit+0x394>)
 8020336:	910e      	str	r1, [sp, #56]	; 0x38
    		sz = (ai_u32)AI_BUFFER_SIZE(&net_ctx[idx].report.activations);
 8020338:	1b9b      	subs	r3, r3, r6
 802033a:	eb07 03c3 	add.w	r3, r7, r3, lsl #3
 802033e:	f8b3 2128 	ldrh.w	r2, [r3, #296]	; 0x128
 8020342:	f8b3 5126 	ldrh.w	r5, [r3, #294]	; 0x126
 8020346:	f8d3 312c 	ldr.w	r3, [r3, #300]	; 0x12c
 802034a:	fb05 f202 	mul.w	r2, r5, r2
 802034e:	fb03 f202 	mul.w	r2, r3, r2
    SENSING1_PRINTF(" Activation buffer  : 0x%lx (%d bytes) %s\r\n", ext_addr, (int)sz,
 8020352:	2c00      	cmp	r4, #0
 8020354:	f43f af12 	beq.w	802017c <aiInit+0x15c>
 8020358:	e72c      	b.n	80201b4 <aiInit+0x194>
 802035a:	bf00      	nop
 802035c:	20010a1c 	.word	0x20010a1c
 8020360:	20010afc 	.word	0x20010afc
 8020364:	08042bd8 	.word	0x08042bd8
 8020368:	40000040 	.word	0x40000040
 802036c:	080429f0 	.word	0x080429f0
 8020370:	080429fc 	.word	0x080429fc
 8020374:	08042c18 	.word	0x08042c18
 8020378:	08042a08 	.word	0x08042a08
 802037c:	08042bf8 	.word	0x08042bf8
 8020380:	08042a3c 	.word	0x08042a3c
 8020384:	08042a58 	.word	0x08042a58
 8020388:	08042a74 	.word	0x08042a74
 802038c:	08042a90 	.word	0x08042a90
 8020390:	08042aac 	.word	0x08042aac
 8020394:	08042ac8 	.word	0x08042ac8
 8020398:	08042aec 	.word	0x08042aec
 802039c:	08042b14 	.word	0x08042b14
 80203a0:	08042b28 	.word	0x08042b28
 80203a4:	08042b44 	.word	0x08042b44
 80203a8:	08042b68 	.word	0x08042b68
 80203ac:	08042b8c 	.word	0x08042b8c
 80203b0:	08042bb0 	.word	0x08042bb0
 80203b4:	20010cdc 	.word	0x20010cdc
 80203b8:	20000d84 	.word	0x20000d84
 80203bc:	08042bd0 	.word	0x08042bd0
        SENSING1_PRINTF("E: AI error (%s) - type=%d code=%d\r\n", fct,
 80203c0:	f898 3000 	ldrb.w	r3, [r8]
 80203c4:	2b00      	cmp	r3, #0
 80203c6:	f43f ae6e 	beq.w	80200a6 <aiInit+0x86>
 80203ca:	4914      	ldr	r1, [pc, #80]	; (802041c <aiInit+0x3fc>)
 80203cc:	4814      	ldr	r0, [pc, #80]	; (8020420 <aiInit+0x400>)
 80203ce:	0a2b      	lsrs	r3, r5, #8
 80203d0:	f007 fe24 	bl	802801c <iprintf>
      return -1;
 80203d4:	e667      	b.n	80200a6 <aiInit+0x86>
      err = ai_mnetwork_get_error(net_ctx[idx].handle);
 80203d6:	9b03      	ldr	r3, [sp, #12]
 80203d8:	1b9b      	subs	r3, r3, r6
 80203da:	eb07 03c3 	add.w	r3, r7, r3, lsl #3
 80203de:	f8d3 00e0 	ldr.w	r0, [r3, #224]	; 0xe0
 80203e2:	f7ff fbe1 	bl	801fba8 <ai_mnetwork_get_error>
        SENSING1_PRINTF("E: AI error (%s) - type=%d code=%d\r\n", fct,
 80203e6:	f898 3000 	ldrb.w	r3, [r8]
 80203ea:	2b00      	cmp	r3, #0
 80203ec:	f43f ae50 	beq.w	8020090 <aiInit+0x70>
 80203f0:	0a03      	lsrs	r3, r0, #8
 80203f2:	b2c2      	uxtb	r2, r0
 80203f4:	490b      	ldr	r1, [pc, #44]	; (8020424 <aiInit+0x404>)
 80203f6:	480a      	ldr	r0, [pc, #40]	; (8020420 <aiInit+0x400>)
 80203f8:	f007 fe10 	bl	802801c <iprintf>
 80203fc:	e648      	b.n	8020090 <aiInit+0x70>
 80203fe:	0a03      	lsrs	r3, r0, #8
 8020400:	b2c2      	uxtb	r2, r0
 8020402:	4909      	ldr	r1, [pc, #36]	; (8020428 <aiInit+0x408>)
 8020404:	4806      	ldr	r0, [pc, #24]	; (8020420 <aiInit+0x400>)
 8020406:	f007 fe09 	bl	802801c <iprintf>
 802040a:	e641      	b.n	8020090 <aiInit+0x70>
      err = ai_mnetwork_get_error(net_ctx[idx].handle);
 802040c:	9b03      	ldr	r3, [sp, #12]
 802040e:	1b9b      	subs	r3, r3, r6
 8020410:	eb07 03c3 	add.w	r3, r7, r3, lsl #3
 8020414:	f8d3 00e0 	ldr.w	r0, [r3, #224]	; 0xe0
 8020418:	e633      	b.n	8020082 <aiInit+0x62>
 802041a:	bf00      	nop
 802041c:	08042a28 	.word	0x08042a28
 8020420:	08042910 	.word	0x08042910
 8020424:	08042c44 	.word	0x08042c44
 8020428:	08042be0 	.word	0x08042be0

0802042c <aiDeInit>:
int aiDeInit(const char *nn_name, const int idx)
{
 802042c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  SENSING1_PRINTF("Releasing the network %s...\r\n",nn_name);
 8020430:	4f17      	ldr	r7, [pc, #92]	; (8020490 <aiDeInit+0x64>)
 8020432:	783a      	ldrb	r2, [r7, #0]
{
 8020434:	460c      	mov	r4, r1
  SENSING1_PRINTF("Releasing the network %s...\r\n",nn_name);
 8020436:	b95a      	cbnz	r2, 8020450 <aiDeInit+0x24>

  if (net_ctx[idx].handle) {
 8020438:	4e16      	ldr	r6, [pc, #88]	; (8020494 <aiDeInit+0x68>)
 802043a:	ebc4 1504 	rsb	r5, r4, r4, lsl #4
 802043e:	eb06 05c5 	add.w	r5, r6, r5, lsl #3
 8020442:	ea4f 1804 	mov.w	r8, r4, lsl #4
 8020446:	f8d5 00e0 	ldr.w	r0, [r5, #224]	; 0xe0
 802044a:	b938      	cbnz	r0, 802045c <aiDeInit+0x30>
      }
      net_ctx[idx].handle = NULL;
      return -1;
  }
  return 0;
}
 802044c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8020450:	4603      	mov	r3, r0
  SENSING1_PRINTF("Releasing the network %s...\r\n",nn_name);
 8020452:	4619      	mov	r1, r3
 8020454:	4810      	ldr	r0, [pc, #64]	; (8020498 <aiDeInit+0x6c>)
 8020456:	f007 fde1 	bl	802801c <iprintf>
 802045a:	e7ed      	b.n	8020438 <aiDeInit+0xc>
      if (ai_mnetwork_destroy(net_ctx[idx].handle) != AI_HANDLE_NULL) {
 802045c:	f7ff fb66 	bl	801fb2c <ai_mnetwork_destroy>
 8020460:	b128      	cbz	r0, 802046e <aiDeInit+0x42>
          aiLogErr(ai_mnetwork_get_error(net_ctx[idx].handle), "ai_mnetwork_destroy");
 8020462:	f8d5 00e0 	ldr.w	r0, [r5, #224]	; 0xe0
 8020466:	f7ff fb9f 	bl	801fba8 <ai_mnetwork_get_error>
        SENSING1_PRINTF("E: AI error (%s) - type=%d code=%d\r\n", fct,
 802046a:	783b      	ldrb	r3, [r7, #0]
 802046c:	b94b      	cbnz	r3, 8020482 <aiDeInit+0x56>
      net_ctx[idx].handle = NULL;
 802046e:	eba8 0404 	sub.w	r4, r8, r4
 8020472:	eb06 06c4 	add.w	r6, r6, r4, lsl #3
 8020476:	2300      	movs	r3, #0
 8020478:	f8c6 30e0 	str.w	r3, [r6, #224]	; 0xe0
      return -1;
 802047c:	f04f 30ff 	mov.w	r0, #4294967295
 8020480:	e7e4      	b.n	802044c <aiDeInit+0x20>
        SENSING1_PRINTF("E: AI error (%s) - type=%d code=%d\r\n", fct,
 8020482:	0a03      	lsrs	r3, r0, #8
 8020484:	b2c2      	uxtb	r2, r0
 8020486:	4905      	ldr	r1, [pc, #20]	; (802049c <aiDeInit+0x70>)
 8020488:	4805      	ldr	r0, [pc, #20]	; (80204a0 <aiDeInit+0x74>)
 802048a:	f007 fdc7 	bl	802801c <iprintf>
 802048e:	e7ee      	b.n	802046e <aiDeInit+0x42>
 8020490:	20000d84 	.word	0x20000d84
 8020494:	20010a1c 	.word	0x20010a1c
 8020498:	08042c58 	.word	0x08042c58
 802049c:	08042c78 	.word	0x08042c78
 80204a0:	08042910 	.word	0x08042910

080204a4 <aiGetReport>:
const ai_network_report* aiGetReport(const int idx)
{
  return(&net_ctx[idx].report);
 80204a4:	4b03      	ldr	r3, [pc, #12]	; (80204b4 <aiGetReport+0x10>)
 80204a6:	ebc0 1000 	rsb	r0, r0, r0, lsl #4
 80204aa:	eb03 00c0 	add.w	r0, r3, r0, lsl #3
}
 80204ae:	3004      	adds	r0, #4
 80204b0:	4770      	bx	lr
 80204b2:	bf00      	nop
 80204b4:	20010afc 	.word	0x20010afc

080204b8 <prvResetCommand>:
    return 0;
}
#endif /* SENSING1_USE_USB_MSC */

static BaseType_t prvResetCommand(char *pcWriteBuffer, size_t xWriteBufferLen, const char *pcCommandString)
{
 80204b8:	b508      	push	{r3, lr}
    /* System Reset */
    HAL_NVIC_SystemReset();
 80204ba:	f7ef fa41 	bl	800f940 <HAL_NVIC_SystemReset>

    return 0;
}
 80204be:	2000      	movs	r0, #0
 80204c0:	bd08      	pop	{r3, pc}
 80204c2:	bf00      	nop

080204c4 <prvGetAIAlgoCommand>:
  if (HAR_GMP_IDX==HarAlgo)
 80204c4:	4b0b      	ldr	r3, [pc, #44]	; (80204f4 <prvGetAIAlgoCommand+0x30>)
 80204c6:	781a      	ldrb	r2, [r3, #0]
{
 80204c8:	4603      	mov	r3, r0
  if (HAR_GMP_IDX==HarAlgo)
 80204ca:	b14a      	cbz	r2, 80204e0 <prvGetAIAlgoCommand+0x1c>
  else if (HAR_IGN_IDX==HarAlgo)
 80204cc:	2a01      	cmp	r2, #1
 80204ce:	d00c      	beq.n	80204ea <prvGetAIAlgoCommand+0x26>
  else if (HAR_IGN_WSDM_IDX==HarAlgo)
 80204d0:	2a02      	cmp	r2, #2
    sprintf(pcWriteBuffer, "3\r\n");
 80204d2:	bf0c      	ite	eq
 80204d4:	4a08      	ldreq	r2, [pc, #32]	; (80204f8 <prvGetAIAlgoCommand+0x34>)
    sprintf(pcWriteBuffer, "0\r\n");
 80204d6:	4a09      	ldrne	r2, [pc, #36]	; (80204fc <prvGetAIAlgoCommand+0x38>)
 80204d8:	6810      	ldr	r0, [r2, #0]
 80204da:	6018      	str	r0, [r3, #0]
}
 80204dc:	2000      	movs	r0, #0
 80204de:	4770      	bx	lr
    sprintf(pcWriteBuffer, "1\r\n");
 80204e0:	4a07      	ldr	r2, [pc, #28]	; (8020500 <prvGetAIAlgoCommand+0x3c>)
 80204e2:	6810      	ldr	r0, [r2, #0]
 80204e4:	6018      	str	r0, [r3, #0]
}
 80204e6:	2000      	movs	r0, #0
 80204e8:	4770      	bx	lr
    sprintf(pcWriteBuffer, "2\r\n");
 80204ea:	4a06      	ldr	r2, [pc, #24]	; (8020504 <prvGetAIAlgoCommand+0x40>)
 80204ec:	6810      	ldr	r0, [r2, #0]
 80204ee:	6018      	str	r0, [r3, #0]
}
 80204f0:	2000      	movs	r0, #0
 80204f2:	4770      	bx	lr
 80204f4:	20000d8a 	.word	0x20000d8a
 80204f8:	08042cb4 	.word	0x08042cb4
 80204fc:	08042cb8 	.word	0x08042cb8
 8020500:	08042cac 	.word	0x08042cac
 8020504:	08042cb0 	.word	0x08042cb0

08020508 <prvSetAIAlgoCommand>:
{
 8020508:	b500      	push	{lr}
  sprintf(pcWriteBuffer, "\r\n");
 802050a:	4915      	ldr	r1, [pc, #84]	; (8020560 <prvSetAIAlgoCommand+0x58>)
{
 802050c:	4603      	mov	r3, r0
  sprintf(pcWriteBuffer, "\r\n");
 802050e:	f8b1 c000 	ldrh.w	ip, [r1]
 8020512:	7889      	ldrb	r1, [r1, #2]
 8020514:	7099      	strb	r1, [r3, #2]
{
 8020516:	b083      	sub	sp, #12
 8020518:	4610      	mov	r0, r2
  sprintf(pcWriteBuffer, "\r\n");
 802051a:	f8a3 c000 	strh.w	ip, [r3]
  pcParameter = FreeRTOS_CLIGetParameter(
 802051e:	aa01      	add	r2, sp, #4
 8020520:	2101      	movs	r1, #1
 8020522:	f7fe fc89 	bl	801ee38 <FreeRTOS_CLIGetParameter>
  if (strncmp(pcParameter, "1", 1) == 0)
 8020526:	7803      	ldrb	r3, [r0, #0]
 8020528:	2b31      	cmp	r3, #49	; 0x31
 802052a:	d012      	beq.n	8020552 <prvSetAIAlgoCommand+0x4a>
  else if (strncmp(pcParameter, "2", 1) == 0)
 802052c:	2b32      	cmp	r3, #50	; 0x32
 802052e:	d009      	beq.n	8020544 <prvSetAIAlgoCommand+0x3c>
  else if (strncmp(pcParameter, "3", 1) == 0)
 8020530:	2b33      	cmp	r3, #51	; 0x33
    HarAlgo = HAR_IGN_WSDM_IDX ;
 8020532:	4b0c      	ldr	r3, [pc, #48]	; (8020564 <prvSetAIAlgoCommand+0x5c>)
 8020534:	bf0c      	ite	eq
 8020536:	2202      	moveq	r2, #2
    HarAlgo = HAR_ALGO_IDX_NONE ;
 8020538:	22ff      	movne	r2, #255	; 0xff
}
 802053a:	2000      	movs	r0, #0
    HarAlgo = HAR_ALGO_IDX_NONE ;
 802053c:	701a      	strb	r2, [r3, #0]
}
 802053e:	b003      	add	sp, #12
 8020540:	f85d fb04 	ldr.w	pc, [sp], #4
    HarAlgo = HAR_IGN_IDX ;
 8020544:	4b07      	ldr	r3, [pc, #28]	; (8020564 <prvSetAIAlgoCommand+0x5c>)
 8020546:	2201      	movs	r2, #1
}
 8020548:	2000      	movs	r0, #0
    HarAlgo = HAR_IGN_IDX ;
 802054a:	701a      	strb	r2, [r3, #0]
}
 802054c:	b003      	add	sp, #12
 802054e:	f85d fb04 	ldr.w	pc, [sp], #4
    HarAlgo = HAR_GMP_IDX ;
 8020552:	4b04      	ldr	r3, [pc, #16]	; (8020564 <prvSetAIAlgoCommand+0x5c>)
 8020554:	2200      	movs	r2, #0
}
 8020556:	2000      	movs	r0, #0
    HarAlgo = HAR_GMP_IDX ;
 8020558:	701a      	strb	r2, [r3, #0]
}
 802055a:	b003      	add	sp, #12
 802055c:	f85d fb04 	ldr.w	pc, [sp], #4
 8020560:	080430dc 	.word	0x080430dc
 8020564:	20000d8a 	.word	0x20000d8a

08020568 <prvGetAllAIAlgoCommand>:
{
 8020568:	b530      	push	{r4, r5, lr}
    sprintf(pcWriteBuffer, "1-ASC+GMP ,2-ASC+IGN,3-ASC+IGN_WSDM\n");
 802056a:	4c0e      	ldr	r4, [pc, #56]	; (80205a4 <prvGetAllAIAlgoCommand+0x3c>)
 802056c:	4684      	mov	ip, r0
 802056e:	f104 0520 	add.w	r5, r4, #32
 8020572:	46a6      	mov	lr, r4
 8020574:	e8be 000f 	ldmia.w	lr!, {r0, r1, r2, r3}
 8020578:	45ae      	cmp	lr, r5
 802057a:	f10c 0c10 	add.w	ip, ip, #16
 802057e:	f104 0410 	add.w	r4, r4, #16
 8020582:	f84c 0c10 	str.w	r0, [ip, #-16]
 8020586:	f84c 1c0c 	str.w	r1, [ip, #-12]
 802058a:	f84c 2c08 	str.w	r2, [ip, #-8]
 802058e:	f84c 3c04 	str.w	r3, [ip, #-4]
 8020592:	d1ee      	bne.n	8020572 <prvGetAllAIAlgoCommand+0xa>
 8020594:	6820      	ldr	r0, [r4, #0]
 8020596:	7923      	ldrb	r3, [r4, #4]
 8020598:	f8cc 0000 	str.w	r0, [ip]
 802059c:	f88c 3004 	strb.w	r3, [ip, #4]
}
 80205a0:	2000      	movs	r0, #0
 80205a2:	bd30      	pop	{r4, r5, pc}
 80205a4:	08042cbc 	.word	0x08042cbc

080205a8 <prvBdaddrCommand>:
{
 80205a8:	b510      	push	{r4, lr}
            bdaddr[5],bdaddr[4],bdaddr[3],bdaddr[2],bdaddr[1],bdaddr[0]);
 80205aa:	4a09      	ldr	r2, [pc, #36]	; (80205d0 <prvBdaddrCommand+0x28>)
    sprintf(pcWriteBuffer, "%02x:%02x:%02x:%02x:%02x:%02x\r\n",
 80205ac:	4909      	ldr	r1, [pc, #36]	; (80205d4 <prvBdaddrCommand+0x2c>)
 80205ae:	7814      	ldrb	r4, [r2, #0]
 80205b0:	7853      	ldrb	r3, [r2, #1]
{
 80205b2:	b084      	sub	sp, #16
    sprintf(pcWriteBuffer, "%02x:%02x:%02x:%02x:%02x:%02x\r\n",
 80205b4:	e9cd 3402 	strd	r3, r4, [sp, #8]
 80205b8:	7894      	ldrb	r4, [r2, #2]
 80205ba:	78d3      	ldrb	r3, [r2, #3]
 80205bc:	e9cd 3400 	strd	r3, r4, [sp]
 80205c0:	7913      	ldrb	r3, [r2, #4]
 80205c2:	7952      	ldrb	r2, [r2, #5]
 80205c4:	f007 fdde 	bl	8028184 <siprintf>
}
 80205c8:	2000      	movs	r0, #0
 80205ca:	b004      	add	sp, #16
 80205cc:	bd10      	pop	{r4, pc}
 80205ce:	bf00      	nop
 80205d0:	200134e8 	.word	0x200134e8
 80205d4:	08043a10 	.word	0x08043a10

080205d8 <prvUsbCommand>:
{
 80205d8:	b530      	push	{r4, r5, lr}
 80205da:	4613      	mov	r3, r2
 80205dc:	b083      	sub	sp, #12
    pcParameter = FreeRTOS_CLIGetParameter(
 80205de:	aa01      	add	r2, sp, #4
 80205e0:	2101      	movs	r1, #1
{
 80205e2:	4604      	mov	r4, r0
    pcParameter = FreeRTOS_CLIGetParameter(
 80205e4:	4618      	mov	r0, r3
 80205e6:	f7fe fc27 	bl	801ee38 <FreeRTOS_CLIGetParameter>
    if (strncmp(pcParameter, "start", strlen("start")) == 0)
 80205ea:	4923      	ldr	r1, [pc, #140]	; (8020678 <prvUsbCommand+0xa0>)
 80205ec:	2205      	movs	r2, #5
    pcParameter = FreeRTOS_CLIGetParameter(
 80205ee:	4605      	mov	r5, r0
    if (strncmp(pcParameter, "start", strlen("start")) == 0)
 80205f0:	f007 fe2b 	bl	802824a <strncmp>
 80205f4:	2800      	cmp	r0, #0
 80205f6:	d038      	beq.n	802066a <prvUsbCommand+0x92>
    else if (strncmp(pcParameter, "stop", strlen("stop")) == 0)
 80205f8:	4920      	ldr	r1, [pc, #128]	; (802067c <prvUsbCommand+0xa4>)
 80205fa:	2204      	movs	r2, #4
 80205fc:	4628      	mov	r0, r5
 80205fe:	f007 fe24 	bl	802824a <strncmp>
 8020602:	b980      	cbnz	r0, 8020626 <prvUsbCommand+0x4e>
        DATALOG_SD_Init();
 8020604:	f7fd ff62 	bl	801e4cc <DATALOG_SD_Init>
        DeInitUSBMSC();
 8020608:	f7ff f8b0 	bl	801f76c <DeInitUSBMSC>
        sprintf(pcWriteBuffer, "USB MSC stopped.\r\n");
 802060c:	4d1c      	ldr	r5, [pc, #112]	; (8020680 <prvUsbCommand+0xa8>)
 802060e:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8020610:	6061      	str	r1, [r4, #4]
 8020612:	8829      	ldrh	r1, [r5, #0]
 8020614:	8221      	strh	r1, [r4, #16]
 8020616:	78a9      	ldrb	r1, [r5, #2]
 8020618:	6020      	str	r0, [r4, #0]
}
 802061a:	2000      	movs	r0, #0
        sprintf(pcWriteBuffer, "USB MSC stopped.\r\n");
 802061c:	60a2      	str	r2, [r4, #8]
 802061e:	60e3      	str	r3, [r4, #12]
 8020620:	74a1      	strb	r1, [r4, #18]
}
 8020622:	b003      	add	sp, #12
 8020624:	bd30      	pop	{r4, r5, pc}
        sprintf(pcWriteBuffer, "Valid parameters are 'start' and 'stop'.\r\n");
 8020626:	4d17      	ldr	r5, [pc, #92]	; (8020684 <prvUsbCommand+0xac>)
 8020628:	46a4      	mov	ip, r4
 802062a:	f105 0e20 	add.w	lr, r5, #32
 802062e:	462c      	mov	r4, r5
 8020630:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 8020632:	4574      	cmp	r4, lr
 8020634:	f10c 0c10 	add.w	ip, ip, #16
 8020638:	f105 0510 	add.w	r5, r5, #16
 802063c:	f84c 0c10 	str.w	r0, [ip, #-16]
 8020640:	f84c 1c0c 	str.w	r1, [ip, #-12]
 8020644:	f84c 2c08 	str.w	r2, [ip, #-8]
 8020648:	f84c 3c04 	str.w	r3, [ip, #-4]
 802064c:	d1ef      	bne.n	802062e <prvUsbCommand+0x56>
 802064e:	cd03      	ldmia	r5!, {r0, r1}
 8020650:	882b      	ldrh	r3, [r5, #0]
 8020652:	f8ac 3008 	strh.w	r3, [ip, #8]
 8020656:	78ab      	ldrb	r3, [r5, #2]
 8020658:	f8cc 0000 	str.w	r0, [ip]
}
 802065c:	2000      	movs	r0, #0
        sprintf(pcWriteBuffer, "Valid parameters are 'start' and 'stop'.\r\n");
 802065e:	f8cc 1004 	str.w	r1, [ip, #4]
 8020662:	f88c 300a 	strb.w	r3, [ip, #10]
}
 8020666:	b003      	add	sp, #12
 8020668:	bd30      	pop	{r4, r5, pc}
        DATALOG_SD_DeInit();
 802066a:	f7fe fa85 	bl	801eb78 <DATALOG_SD_DeInit>
        sprintf(pcWriteBuffer, "USB MSC started.\r\n");
 802066e:	4d06      	ldr	r5, [pc, #24]	; (8020688 <prvUsbCommand+0xb0>)
        InitUSBMSC();
 8020670:	f7fe ff88 	bl	801f584 <InitUSBMSC>
        sprintf(pcWriteBuffer, "USB MSC started.\r\n");
 8020674:	e7cb      	b.n	802060e <prvUsbCommand+0x36>
 8020676:	bf00      	nop
 8020678:	08042ce4 	.word	0x08042ce4
 802067c:	08042d00 	.word	0x08042d00
 8020680:	08042d08 	.word	0x08042d08
 8020684:	08042d1c 	.word	0x08042d1c
 8020688:	08042cec 	.word	0x08042cec

0802068c <prvFORMATCommand>:
{
 802068c:	b538      	push	{r3, r4, r5, lr}
    sprintf(pcWriteBuffer, "Volume format complete.\r\n");
 802068e:	4c08      	ldr	r4, [pc, #32]	; (80206b0 <prvFORMATCommand+0x24>)
{
 8020690:	4605      	mov	r5, r0
    volumeInit();
 8020692:	f7fd febf 	bl	801e414 <volumeInit>
    sprintf(pcWriteBuffer, "Volume format complete.\r\n");
 8020696:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 8020698:	6028      	str	r0, [r5, #0]
 802069a:	6069      	str	r1, [r5, #4]
 802069c:	cc03      	ldmia	r4!, {r0, r1}
 802069e:	60eb      	str	r3, [r5, #12]
 80206a0:	8823      	ldrh	r3, [r4, #0]
 80206a2:	6128      	str	r0, [r5, #16]
 80206a4:	60aa      	str	r2, [r5, #8]
 80206a6:	6169      	str	r1, [r5, #20]
 80206a8:	832b      	strh	r3, [r5, #24]
}
 80206aa:	2000      	movs	r0, #0
 80206ac:	bd38      	pop	{r3, r4, r5, pc}
 80206ae:	bf00      	nop
 80206b0:	08042d48 	.word	0x08042d48

080206b4 <prvRMCommand>:
{
 80206b4:	b530      	push	{r4, r5, lr}
 80206b6:	4613      	mov	r3, r2
 80206b8:	b083      	sub	sp, #12
 80206ba:	4604      	mov	r4, r0
    pcParameter = FreeRTOS_CLIGetParameter(
 80206bc:	aa01      	add	r2, sp, #4
 80206be:	2101      	movs	r1, #1
 80206c0:	4618      	mov	r0, r3
 80206c2:	f7fe fbb9 	bl	801ee38 <FreeRTOS_CLIGetParameter>
 80206c6:	4605      	mov	r5, r0
    res = f_unlink(pcParameter);
 80206c8:	f7f7 fc4c 	bl	8017f64 <f_unlink>
    if (res != FR_OK)
 80206cc:	b140      	cbz	r0, 80206e0 <prvRMCommand+0x2c>
        sprintf(pcWriteBuffer, "Cannot remove \'%s\': error %d.\r\n", pcParameter, res);
 80206ce:	4603      	mov	r3, r0
 80206d0:	4907      	ldr	r1, [pc, #28]	; (80206f0 <prvRMCommand+0x3c>)
 80206d2:	462a      	mov	r2, r5
 80206d4:	4620      	mov	r0, r4
 80206d6:	f007 fd55 	bl	8028184 <siprintf>
}
 80206da:	2000      	movs	r0, #0
 80206dc:	b003      	add	sp, #12
 80206de:	bd30      	pop	{r4, r5, pc}
        sprintf(pcWriteBuffer, "\r\n");
 80206e0:	4b04      	ldr	r3, [pc, #16]	; (80206f4 <prvRMCommand+0x40>)
 80206e2:	881a      	ldrh	r2, [r3, #0]
 80206e4:	789b      	ldrb	r3, [r3, #2]
 80206e6:	8022      	strh	r2, [r4, #0]
}
 80206e8:	2000      	movs	r0, #0
        sprintf(pcWriteBuffer, "\r\n");
 80206ea:	70a3      	strb	r3, [r4, #2]
}
 80206ec:	b003      	add	sp, #12
 80206ee:	bd30      	pop	{r4, r5, pc}
 80206f0:	08042d64 	.word	0x08042d64
 80206f4:	080430dc 	.word	0x080430dc

080206f8 <prvCATCommand>:
{
 80206f8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    if (xReturn == 0)
 80206fc:	4f26      	ldr	r7, [pc, #152]	; (8020798 <prvCATCommand+0xa0>)
{
 80206fe:	b082      	sub	sp, #8
 8020700:	460c      	mov	r4, r1
 8020702:	4616      	mov	r6, r2
    memset(pcWriteBuffer, 0x00, xWriteBufferLen);
 8020704:	460a      	mov	r2, r1
 8020706:	2100      	movs	r1, #0
{
 8020708:	4605      	mov	r5, r0
    memset(pcWriteBuffer, 0x00, xWriteBufferLen);
 802070a:	f006 ff35 	bl	8027578 <memset>
    if (xReturn == 0)
 802070e:	683b      	ldr	r3, [r7, #0]
 8020710:	b99b      	cbnz	r3, 802073a <prvCATCommand+0x42>
        pcParameter = FreeRTOS_CLIGetParameter(
 8020712:	4630      	mov	r0, r6
 8020714:	aa01      	add	r2, sp, #4
 8020716:	2101      	movs	r1, #1
 8020718:	f7fe fb8e 	bl	801ee38 <FreeRTOS_CLIGetParameter>
        configASSERT(pcParameter);
 802071c:	4606      	mov	r6, r0
 802071e:	b1f0      	cbz	r0, 802075e <prvCATCommand+0x66>
        res = f_open(&MyFileDummy, pcParameter, FA_READ);
 8020720:	481e      	ldr	r0, [pc, #120]	; (802079c <prvCATCommand+0xa4>)
 8020722:	2201      	movs	r2, #1
 8020724:	4631      	mov	r1, r6
 8020726:	f7f6 fde3 	bl	80172f0 <f_open>
        if (res != FR_OK)
 802072a:	b138      	cbz	r0, 802073c <prvCATCommand+0x44>
            sprintf(pcWriteBuffer, "Cannot open \'%s\': error %d.\r\n", pcParameter, res);
 802072c:	4603      	mov	r3, r0
 802072e:	491c      	ldr	r1, [pc, #112]	; (80207a0 <prvCATCommand+0xa8>)
 8020730:	4632      	mov	r2, r6
 8020732:	4628      	mov	r0, r5
 8020734:	f007 fd26 	bl	8028184 <siprintf>
 8020738:	e000      	b.n	802073c <prvCATCommand+0x44>
    const char *pcParameter ="";
 802073a:	4e1a      	ldr	r6, [pc, #104]	; (80207a4 <prvCATCommand+0xac>)
    if (f_gets(pcWriteBuffer, xWriteBufferLen, &MyFileDummy) != NULL)
 802073c:	f8df 805c 	ldr.w	r8, [pc, #92]	; 802079c <prvCATCommand+0xa4>
 8020740:	4621      	mov	r1, r4
 8020742:	4642      	mov	r2, r8
 8020744:	4628      	mov	r0, r5
 8020746:	f7f7 ffb9 	bl	80186bc <f_gets>
 802074a:	4604      	mov	r4, r0
 802074c:	b1b0      	cbz	r0, 802077c <prvCATCommand+0x84>
        if (f_error(&MyFileDummy) != 0)
 802074e:	f898 3015 	ldrb.w	r3, [r8, #21]
 8020752:	b96b      	cbnz	r3, 8020770 <prvCATCommand+0x78>
        xReturn = 1;
 8020754:	2001      	movs	r0, #1
 8020756:	6038      	str	r0, [r7, #0]
}
 8020758:	b002      	add	sp, #8
 802075a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 802075e:	f04f 0350 	mov.w	r3, #80	; 0x50
 8020762:	f383 8811 	msr	BASEPRI, r3
 8020766:	f3bf 8f6f 	isb	sy
 802076a:	f3bf 8f4f 	dsb	sy
        configASSERT(pcParameter);
 802076e:	e7fe      	b.n	802076e <prvCATCommand+0x76>
            sprintf(pcWriteBuffer, "Cannot read \'%s\'\r\n", pcParameter);
 8020770:	490d      	ldr	r1, [pc, #52]	; (80207a8 <prvCATCommand+0xb0>)
 8020772:	4632      	mov	r2, r6
 8020774:	4628      	mov	r0, r5
 8020776:	f007 fd05 	bl	8028184 <siprintf>
 802077a:	e7eb      	b.n	8020754 <prvCATCommand+0x5c>
        f_close(&MyFileDummy);
 802077c:	4640      	mov	r0, r8
 802077e:	f7f7 f99b 	bl	8017ab8 <f_close>
        sprintf(pcWriteBuffer, "\r\n");
 8020782:	4b0a      	ldr	r3, [pc, #40]	; (80207ac <prvCATCommand+0xb4>)
        xReturn = 0; /* Command execution is complete */
 8020784:	603c      	str	r4, [r7, #0]
        sprintf(pcWriteBuffer, "\r\n");
 8020786:	881a      	ldrh	r2, [r3, #0]
 8020788:	789b      	ldrb	r3, [r3, #2]
 802078a:	802a      	strh	r2, [r5, #0]
        xReturn = 0; /* Command execution is complete */
 802078c:	4620      	mov	r0, r4
        sprintf(pcWriteBuffer, "\r\n");
 802078e:	70ab      	strb	r3, [r5, #2]
}
 8020790:	b002      	add	sp, #8
 8020792:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8020796:	bf00      	nop
 8020798:	2001281c 	.word	0x2001281c
 802079c:	2000d5f8 	.word	0x2000d5f8
 80207a0:	08042d84 	.word	0x08042d84
 80207a4:	080437e0 	.word	0x080437e0
 80207a8:	08042da4 	.word	0x08042da4
 80207ac:	080430dc 	.word	0x080430dc

080207b0 <prvLSCommand>:
{
 80207b0:	b5f0      	push	{r4, r5, r6, r7, lr}
    if (xReturn == 0)
 80207b2:	4d36      	ldr	r5, [pc, #216]	; (802088c <prvLSCommand+0xdc>)
{
 80207b4:	b08d      	sub	sp, #52	; 0x34
    if (xReturn == 0)
 80207b6:	686c      	ldr	r4, [r5, #4]
    char path[] = "/";
 80207b8:	232f      	movs	r3, #47	; 0x2f
{
 80207ba:	4606      	mov	r6, r0
    char path[] = "/";
 80207bc:	f8ad 302c 	strh.w	r3, [sp, #44]	; 0x2c
    if (xReturn == 0)
 80207c0:	b934      	cbnz	r4, 80207d0 <prvLSCommand+0x20>
        res = f_opendir(&Dir, path);
 80207c2:	a90b      	add	r1, sp, #44	; 0x2c
 80207c4:	f105 0008 	add.w	r0, r5, #8
 80207c8:	f7f7 faf0 	bl	8017dac <f_opendir>
        if (res != FR_OK)
 80207cc:	2800      	cmp	r0, #0
 80207ce:	d154      	bne.n	802087a <prvLSCommand+0xca>
    res = f_readdir(&Dir, &Finfo);
 80207d0:	492f      	ldr	r1, [pc, #188]	; (8020890 <prvLSCommand+0xe0>)
 80207d2:	f1a1 0034 	sub.w	r0, r1, #52	; 0x34
 80207d6:	f7f7 fb85 	bl	8017ee4 <f_readdir>
    if ((res != FR_OK) || !Finfo.fname[0])
 80207da:	b910      	cbnz	r0, 80207e2 <prvLSCommand+0x32>
 80207dc:	f895 3052 	ldrb.w	r3, [r5, #82]	; 0x52
 80207e0:	b963      	cbnz	r3, 80207fc <prvLSCommand+0x4c>
        f_closedir(&Dir);
 80207e2:	482c      	ldr	r0, [pc, #176]	; (8020894 <prvLSCommand+0xe4>)
 80207e4:	f7f7 fb48 	bl	8017e78 <f_closedir>
        sprintf(pcWriteBuffer, "\r\n");
 80207e8:	4b2b      	ldr	r3, [pc, #172]	; (8020898 <prvLSCommand+0xe8>)
        xReturn = 0; /* Command execution is complete */
 80207ea:	2400      	movs	r4, #0
        sprintf(pcWriteBuffer, "\r\n");
 80207ec:	881a      	ldrh	r2, [r3, #0]
 80207ee:	789b      	ldrb	r3, [r3, #2]
 80207f0:	8032      	strh	r2, [r6, #0]
}
 80207f2:	4620      	mov	r0, r4
        sprintf(pcWriteBuffer, "\r\n");
 80207f4:	70b3      	strb	r3, [r6, #2]
        xReturn = 0; /* Command execution is complete */
 80207f6:	606c      	str	r4, [r5, #4]
}
 80207f8:	b00d      	add	sp, #52	; 0x34
 80207fa:	bdf0      	pop	{r4, r5, r6, r7, pc}
                (Finfo.fattrib & AM_DIR) ? 'D' : '-', /* Directory */
 80207fc:	f895 4044 	ldrb.w	r4, [r5, #68]	; 0x44
                (Finfo.fdate >> 9) + 1980, (Finfo.fdate >> 5) & 15, Finfo.fdate & 31,
 8020800:	f8b5 1040 	ldrh.w	r1, [r5, #64]	; 0x40
        sprintf(pcWriteBuffer,
 8020804:	f014 0f10 	tst.w	r4, #16
 8020808:	bf14      	ite	ne
 802080a:	2244      	movne	r2, #68	; 0x44
 802080c:	222d      	moveq	r2, #45	; 0x2d
 802080e:	f014 0f01 	tst.w	r4, #1
 8020812:	bf14      	ite	ne
 8020814:	2352      	movne	r3, #82	; 0x52
 8020816:	232d      	moveq	r3, #45	; 0x2d
 8020818:	f014 0f02 	tst.w	r4, #2
 802081c:	bf14      	ite	ne
 802081e:	2748      	movne	r7, #72	; 0x48
 8020820:	272d      	moveq	r7, #45	; 0x2d
 8020822:	f014 0f04 	tst.w	r4, #4
 8020826:	9700      	str	r7, [sp, #0]
 8020828:	bf14      	ite	ne
 802082a:	2753      	movne	r7, #83	; 0x53
 802082c:	272d      	moveq	r7, #45	; 0x2d
 802082e:	f014 0f20 	tst.w	r4, #32
                (Finfo.fdate >> 9) + 1980, (Finfo.fdate >> 5) & 15, Finfo.fdate & 31,
 8020832:	ea4f 2451 	mov.w	r4, r1, lsr #9
        sprintf(pcWriteBuffer,
 8020836:	f204 74bc 	addw	r4, r4, #1980	; 0x7bc
 802083a:	9403      	str	r4, [sp, #12]
 802083c:	4630      	mov	r0, r6
 802083e:	6bec      	ldr	r4, [r5, #60]	; 0x3c
                (Finfo.ftime >> 11), (Finfo.ftime >> 5) & 63,
 8020840:	f8b5 6042 	ldrh.w	r6, [r5, #66]	; 0x42
        sprintf(pcWriteBuffer,
 8020844:	9408      	str	r4, [sp, #32]
 8020846:	bf14      	ite	ne
 8020848:	2441      	movne	r4, #65	; 0x41
 802084a:	242d      	moveq	r4, #45	; 0x2d
 802084c:	9402      	str	r4, [sp, #8]
 802084e:	f3c6 1445 	ubfx	r4, r6, #5, #6
 8020852:	9407      	str	r4, [sp, #28]
 8020854:	f001 041f 	and.w	r4, r1, #31
 8020858:	f3c1 1143 	ubfx	r1, r1, #5, #4
 802085c:	9104      	str	r1, [sp, #16]
 802085e:	0af6      	lsrs	r6, r6, #11
 8020860:	490e      	ldr	r1, [pc, #56]	; (802089c <prvLSCommand+0xec>)
 8020862:	9405      	str	r4, [sp, #20]
 8020864:	9109      	str	r1, [sp, #36]	; 0x24
 8020866:	9701      	str	r7, [sp, #4]
 8020868:	490d      	ldr	r1, [pc, #52]	; (80208a0 <prvLSCommand+0xf0>)
 802086a:	9606      	str	r6, [sp, #24]
 802086c:	f007 fc8a 	bl	8028184 <siprintf>
        xReturn = 1; /* Command execution incomplete */
 8020870:	2401      	movs	r4, #1
}
 8020872:	4620      	mov	r0, r4
        xReturn = 1; /* Command execution incomplete */
 8020874:	606c      	str	r4, [r5, #4]
}
 8020876:	b00d      	add	sp, #52	; 0x34
 8020878:	bdf0      	pop	{r4, r5, r6, r7, pc}
            sprintf(pcWriteBuffer, "Failed to open directory: error %d.\r\n", res);
 802087a:	4602      	mov	r2, r0
 802087c:	4909      	ldr	r1, [pc, #36]	; (80208a4 <prvLSCommand+0xf4>)
 802087e:	4630      	mov	r0, r6
 8020880:	f007 fc80 	bl	8028184 <siprintf>
}
 8020884:	4620      	mov	r0, r4
            xReturn = 0;
 8020886:	606c      	str	r4, [r5, #4]
}
 8020888:	b00d      	add	sp, #52	; 0x34
 802088a:	bdf0      	pop	{r4, r5, r6, r7, pc}
 802088c:	2001281c 	.word	0x2001281c
 8020890:	20012858 	.word	0x20012858
 8020894:	20012824 	.word	0x20012824
 8020898:	080430dc 	.word	0x080430dc
 802089c:	2001286e 	.word	0x2001286e
 80208a0:	08042de0 	.word	0x08042de0
 80208a4:	08042db8 	.word	0x08042db8

080208a8 <prvDatalogCommand>:
{
 80208a8:	b570      	push	{r4, r5, r6, lr}
    sprintf(pcWriteBuffer, "\r\n");
 80208aa:	4b54      	ldr	r3, [pc, #336]	; (80209fc <prvDatalogCommand+0x154>)
{
 80208ac:	b082      	sub	sp, #8
 80208ae:	4615      	mov	r5, r2
    sprintf(pcWriteBuffer, "\r\n");
 80208b0:	881a      	ldrh	r2, [r3, #0]
 80208b2:	789b      	ldrb	r3, [r3, #2]
 80208b4:	8002      	strh	r2, [r0, #0]
 80208b6:	7083      	strb	r3, [r0, #2]
    pcParameter1 = FreeRTOS_CLIGetParameter(
 80208b8:	aa01      	add	r2, sp, #4
 80208ba:	2101      	movs	r1, #1
{
 80208bc:	4604      	mov	r4, r0
    pcParameter1 = FreeRTOS_CLIGetParameter(
 80208be:	4628      	mov	r0, r5
 80208c0:	f7fe faba 	bl	801ee38 <FreeRTOS_CLIGetParameter>
 80208c4:	4603      	mov	r3, r0
    pcParameter2 = FreeRTOS_CLIGetParameter(
 80208c6:	aa01      	add	r2, sp, #4
 80208c8:	4628      	mov	r0, r5
 80208ca:	2102      	movs	r1, #2
    pcParameter1 = FreeRTOS_CLIGetParameter(
 80208cc:	461d      	mov	r5, r3
    pcParameter2 = FreeRTOS_CLIGetParameter(
 80208ce:	f7fe fab3 	bl	801ee38 <FreeRTOS_CLIGetParameter>
    configASSERT(pcParameter1);
 80208d2:	b315      	cbz	r5, 802091a <prvDatalogCommand+0x72>
    configASSERT(pcParameter2);
 80208d4:	4606      	mov	r6, r0
 80208d6:	b1b8      	cbz	r0, 8020908 <prvDatalogCommand+0x60>
    if (strncmp(pcParameter1, "start", strlen("start")) == 0)
 80208d8:	4949      	ldr	r1, [pc, #292]	; (8020a00 <prvDatalogCommand+0x158>)
 80208da:	2205      	movs	r2, #5
 80208dc:	4628      	mov	r0, r5
 80208de:	f007 fcb4 	bl	802824a <strncmp>
 80208e2:	bb18      	cbnz	r0, 802092c <prvDatalogCommand+0x84>
        if (strncmp(pcParameter2, "audio", strlen("audio")) == 0)
 80208e4:	4947      	ldr	r1, [pc, #284]	; (8020a04 <prvDatalogCommand+0x15c>)
 80208e6:	2205      	movs	r2, #5
 80208e8:	4630      	mov	r0, r6
 80208ea:	f007 fcae 	bl	802824a <strncmp>
 80208ee:	2800      	cmp	r0, #0
 80208f0:	d041      	beq.n	8020976 <prvDatalogCommand+0xce>
        else if (strncmp(pcParameter2, "mems", strlen("mems")) == 0)
 80208f2:	4945      	ldr	r1, [pc, #276]	; (8020a08 <prvDatalogCommand+0x160>)
 80208f4:	2204      	movs	r2, #4
 80208f6:	4630      	mov	r0, r6
 80208f8:	f007 fca7 	bl	802824a <strncmp>
 80208fc:	2800      	cmp	r0, #0
 80208fe:	d165      	bne.n	80209cc <prvDatalogCommand+0x124>
            SD_CardLoggingMemsStart(0);
 8020900:	f7fd fe5e 	bl	801e5c0 <SD_CardLoggingMemsStart>
            sprintf(pcWriteBuffer, "Mems datalog started\r\n");
 8020904:	4d41      	ldr	r5, [pc, #260]	; (8020a0c <prvDatalogCommand+0x164>)
 8020906:	e028      	b.n	802095a <prvDatalogCommand+0xb2>
 8020908:	f04f 0350 	mov.w	r3, #80	; 0x50
 802090c:	f383 8811 	msr	BASEPRI, r3
 8020910:	f3bf 8f6f 	isb	sy
 8020914:	f3bf 8f4f 	dsb	sy
    configASSERT(pcParameter2);
 8020918:	e7fe      	b.n	8020918 <prvDatalogCommand+0x70>
 802091a:	f04f 0350 	mov.w	r3, #80	; 0x50
 802091e:	f383 8811 	msr	BASEPRI, r3
 8020922:	f3bf 8f6f 	isb	sy
 8020926:	f3bf 8f4f 	dsb	sy
    configASSERT(pcParameter1);
 802092a:	e7fe      	b.n	802092a <prvDatalogCommand+0x82>
    else if (strncmp(pcParameter1, "stop", strlen("stop")) == 0)
 802092c:	4938      	ldr	r1, [pc, #224]	; (8020a10 <prvDatalogCommand+0x168>)
 802092e:	2204      	movs	r2, #4
 8020930:	4628      	mov	r0, r5
 8020932:	f007 fc8a 	bl	802824a <strncmp>
 8020936:	bb60      	cbnz	r0, 8020992 <prvDatalogCommand+0xea>
        if (strncmp(pcParameter2, "audio", strlen("audio")) == 0)
 8020938:	4932      	ldr	r1, [pc, #200]	; (8020a04 <prvDatalogCommand+0x15c>)
 802093a:	2205      	movs	r2, #5
 802093c:	4630      	mov	r0, r6
 802093e:	f007 fc84 	bl	802824a <strncmp>
 8020942:	2800      	cmp	r0, #0
 8020944:	d056      	beq.n	80209f4 <prvDatalogCommand+0x14c>
        else if (strncmp(pcParameter2, "mems", strlen("mems")) == 0)
 8020946:	4930      	ldr	r1, [pc, #192]	; (8020a08 <prvDatalogCommand+0x160>)
 8020948:	2204      	movs	r2, #4
 802094a:	4630      	mov	r0, r6
 802094c:	f007 fc7d 	bl	802824a <strncmp>
 8020950:	2800      	cmp	r0, #0
 8020952:	d13b      	bne.n	80209cc <prvDatalogCommand+0x124>
            SD_CardLoggingMemsStop();
 8020954:	f7fd fc6c 	bl	801e230 <SD_CardLoggingMemsStop>
            sprintf(pcWriteBuffer, "Mems datalog stopped\r\n");
 8020958:	4d2e      	ldr	r5, [pc, #184]	; (8020a14 <prvDatalogCommand+0x16c>)
 802095a:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 802095c:	6020      	str	r0, [r4, #0]
 802095e:	60a2      	str	r2, [r4, #8]
 8020960:	6828      	ldr	r0, [r5, #0]
 8020962:	88aa      	ldrh	r2, [r5, #4]
 8020964:	60e3      	str	r3, [r4, #12]
 8020966:	79ab      	ldrb	r3, [r5, #6]
 8020968:	6120      	str	r0, [r4, #16]
}
 802096a:	2000      	movs	r0, #0
            sprintf(pcWriteBuffer, "Mems datalog stopped\r\n");
 802096c:	6061      	str	r1, [r4, #4]
 802096e:	82a2      	strh	r2, [r4, #20]
 8020970:	75a3      	strb	r3, [r4, #22]
}
 8020972:	b002      	add	sp, #8
 8020974:	bd70      	pop	{r4, r5, r6, pc}
            SD_CardLoggingAudioStart();
 8020976:	f7fd ff8f 	bl	801e898 <SD_CardLoggingAudioStart>
            sprintf(pcWriteBuffer, "Audio datalog started\r\n");
 802097a:	4d27      	ldr	r5, [pc, #156]	; (8020a18 <prvDatalogCommand+0x170>)
            sprintf(pcWriteBuffer, "Audio datalog stopped\r\n");
 802097c:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 802097e:	6020      	str	r0, [r4, #0]
 8020980:	6061      	str	r1, [r4, #4]
 8020982:	cd03      	ldmia	r5!, {r0, r1}
 8020984:	6120      	str	r0, [r4, #16]
}
 8020986:	2000      	movs	r0, #0
            sprintf(pcWriteBuffer, "Audio datalog stopped\r\n");
 8020988:	60a2      	str	r2, [r4, #8]
 802098a:	60e3      	str	r3, [r4, #12]
 802098c:	6161      	str	r1, [r4, #20]
}
 802098e:	b002      	add	sp, #8
 8020990:	bd70      	pop	{r4, r5, r6, pc}
        sprintf(pcWriteBuffer, "Valid parameters are 'start' and 'stop'.\r\n");
 8020992:	4e22      	ldr	r6, [pc, #136]	; (8020a1c <prvDatalogCommand+0x174>)
 8020994:	f106 0c20 	add.w	ip, r6, #32
 8020998:	4635      	mov	r5, r6
 802099a:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 802099c:	4565      	cmp	r5, ip
 802099e:	f104 0410 	add.w	r4, r4, #16
 80209a2:	f106 0610 	add.w	r6, r6, #16
 80209a6:	f844 0c10 	str.w	r0, [r4, #-16]
 80209aa:	f844 1c0c 	str.w	r1, [r4, #-12]
 80209ae:	f844 2c08 	str.w	r2, [r4, #-8]
 80209b2:	f844 3c04 	str.w	r3, [r4, #-4]
 80209b6:	d1ef      	bne.n	8020998 <prvDatalogCommand+0xf0>
 80209b8:	ce03      	ldmia	r6!, {r0, r1}
 80209ba:	8833      	ldrh	r3, [r6, #0]
 80209bc:	8123      	strh	r3, [r4, #8]
 80209be:	78b3      	ldrb	r3, [r6, #2]
 80209c0:	6020      	str	r0, [r4, #0]
}
 80209c2:	2000      	movs	r0, #0
        sprintf(pcWriteBuffer, "Valid parameters are 'start' and 'stop'.\r\n");
 80209c4:	6061      	str	r1, [r4, #4]
 80209c6:	72a3      	strb	r3, [r4, #10]
}
 80209c8:	b002      	add	sp, #8
 80209ca:	bd70      	pop	{r4, r5, r6, pc}
            sprintf(pcWriteBuffer, "Valid parameters are 'audio' and 'mems'.\r\n");
 80209cc:	4e14      	ldr	r6, [pc, #80]	; (8020a20 <prvDatalogCommand+0x178>)
 80209ce:	f106 0c20 	add.w	ip, r6, #32
 80209d2:	4635      	mov	r5, r6
 80209d4:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 80209d6:	4565      	cmp	r5, ip
 80209d8:	f104 0410 	add.w	r4, r4, #16
 80209dc:	f106 0610 	add.w	r6, r6, #16
 80209e0:	f844 0c10 	str.w	r0, [r4, #-16]
 80209e4:	f844 1c0c 	str.w	r1, [r4, #-12]
 80209e8:	f844 2c08 	str.w	r2, [r4, #-8]
 80209ec:	f844 3c04 	str.w	r3, [r4, #-4]
 80209f0:	d1ef      	bne.n	80209d2 <prvDatalogCommand+0x12a>
 80209f2:	e7e1      	b.n	80209b8 <prvDatalogCommand+0x110>
            SD_CardLoggingAudioStop();
 80209f4:	f7fd fcae 	bl	801e354 <SD_CardLoggingAudioStop>
            sprintf(pcWriteBuffer, "Audio datalog stopped\r\n");
 80209f8:	4d0a      	ldr	r5, [pc, #40]	; (8020a24 <prvDatalogCommand+0x17c>)
 80209fa:	e7bf      	b.n	802097c <prvDatalogCommand+0xd4>
 80209fc:	080430dc 	.word	0x080430dc
 8020a00:	08042ce4 	.word	0x08042ce4
 8020a04:	08042e10 	.word	0x08042e10
 8020a08:	08042e30 	.word	0x08042e30
 8020a0c:	08042e38 	.word	0x08042e38
 8020a10:	08042d00 	.word	0x08042d00
 8020a14:	08042e94 	.word	0x08042e94
 8020a18:	08042e18 	.word	0x08042e18
 8020a1c:	08042d1c 	.word	0x08042d1c
 8020a20:	08042e50 	.word	0x08042e50
 8020a24:	08042e7c 	.word	0x08042e7c

08020a28 <prvMultiCommand>:
{
 8020a28:	b530      	push	{r4, r5, lr}
    sprintf(pcWriteBuffer, "\r\n");
 8020a2a:	4b35      	ldr	r3, [pc, #212]	; (8020b00 <prvMultiCommand+0xd8>)
{
 8020a2c:	4604      	mov	r4, r0
    sprintf(pcWriteBuffer, "\r\n");
 8020a2e:	8819      	ldrh	r1, [r3, #0]
 8020a30:	789b      	ldrb	r3, [r3, #2]
 8020a32:	8021      	strh	r1, [r4, #0]
{
 8020a34:	b083      	sub	sp, #12
 8020a36:	4610      	mov	r0, r2
    pcParameter = FreeRTOS_CLIGetParameter(
 8020a38:	2101      	movs	r1, #1
 8020a3a:	aa01      	add	r2, sp, #4
    sprintf(pcWriteBuffer, "\r\n");
 8020a3c:	70a3      	strb	r3, [r4, #2]
    pcParameter = FreeRTOS_CLIGetParameter(
 8020a3e:	f7fe f9fb 	bl	801ee38 <FreeRTOS_CLIGetParameter>
    if (strncmp(pcParameter, "start", strlen("start")) == 0)
 8020a42:	4930      	ldr	r1, [pc, #192]	; (8020b04 <prvMultiCommand+0xdc>)
 8020a44:	2205      	movs	r2, #5
    pcParameter = FreeRTOS_CLIGetParameter(
 8020a46:	4605      	mov	r5, r0
    if (strncmp(pcParameter, "start", strlen("start")) == 0)
 8020a48:	f007 fbff 	bl	802824a <strncmp>
 8020a4c:	2800      	cmp	r0, #0
 8020a4e:	d042      	beq.n	8020ad6 <prvMultiCommand+0xae>
    else if (strncmp(pcParameter, "stop", strlen("stop")) == 0)
 8020a50:	4628      	mov	r0, r5
 8020a52:	492d      	ldr	r1, [pc, #180]	; (8020b08 <prvMultiCommand+0xe0>)
 8020a54:	2204      	movs	r2, #4
 8020a56:	f007 fbf8 	bl	802824a <strncmp>
 8020a5a:	4605      	mov	r5, r0
 8020a5c:	b330      	cbz	r0, 8020aac <prvMultiCommand+0x84>
        sprintf(pcWriteBuffer, "Valid parameters are 'start' and 'stop'.\r\n");
 8020a5e:	4d2b      	ldr	r5, [pc, #172]	; (8020b0c <prvMultiCommand+0xe4>)
 8020a60:	46a4      	mov	ip, r4
 8020a62:	f105 0e20 	add.w	lr, r5, #32
 8020a66:	462c      	mov	r4, r5
 8020a68:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 8020a6a:	4574      	cmp	r4, lr
 8020a6c:	f10c 0c10 	add.w	ip, ip, #16
 8020a70:	f105 0510 	add.w	r5, r5, #16
 8020a74:	f84c 0c10 	str.w	r0, [ip, #-16]
 8020a78:	f84c 1c0c 	str.w	r1, [ip, #-12]
 8020a7c:	f84c 2c08 	str.w	r2, [ip, #-8]
 8020a80:	f84c 3c04 	str.w	r3, [ip, #-4]
 8020a84:	d1ef      	bne.n	8020a66 <prvMultiCommand+0x3e>
 8020a86:	cd03      	ldmia	r5!, {r0, r1}
 8020a88:	882b      	ldrh	r3, [r5, #0]
 8020a8a:	f8ac 3008 	strh.w	r3, [ip, #8]
 8020a8e:	78ab      	ldrb	r3, [r5, #2]
 8020a90:	f8cc 0000 	str.w	r0, [ip]
 8020a94:	f8cc 1004 	str.w	r1, [ip, #4]
 8020a98:	f88c 300a 	strb.w	r3, [ip, #10]
    if (semRun) {
 8020a9c:	4b1c      	ldr	r3, [pc, #112]	; (8020b10 <prvMultiCommand+0xe8>)
 8020a9e:	6818      	ldr	r0, [r3, #0]
 8020aa0:	b108      	cbz	r0, 8020aa6 <prvMultiCommand+0x7e>
      osSemaphoreRelease(semRun);
 8020aa2:	f7f7 ffdd 	bl	8018a60 <osSemaphoreRelease>
}
 8020aa6:	2000      	movs	r0, #0
 8020aa8:	b003      	add	sp, #12
 8020aaa:	bd30      	pop	{r4, r5, pc}
        W2ST_OFF_CONNECTION(W2ST_CONNECT_ASC_EVENT);
 8020aac:	4c19      	ldr	r4, [pc, #100]	; (8020b14 <prvMultiCommand+0xec>)
        stopProc(AUDIO_SC);
 8020aae:	2007      	movs	r0, #7
 8020ab0:	f001 f8d2 	bl	8021c58 <stopProc>
        W2ST_OFF_CONNECTION(W2ST_CONNECT_ASC_EVENT);
 8020ab4:	6823      	ldr	r3, [r4, #0]
        stopProc(ACTIVITY_IGN_WSDM);
 8020ab6:	200a      	movs	r0, #10
        W2ST_OFF_CONNECTION(W2ST_CONNECT_ASC_EVENT);
 8020ab8:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
 8020abc:	6023      	str	r3, [r4, #0]
        stopProc(ACTIVITY_IGN_WSDM);
 8020abe:	f001 f8cb 	bl	8021c58 <stopProc>
        HarAlgo = HAR_ALGO_IDX_NONE;
 8020ac2:	4a15      	ldr	r2, [pc, #84]	; (8020b18 <prvMultiCommand+0xf0>)
        W2ST_OFF_CONNECTION(W2ST_CONNECT_AR);
 8020ac4:	6823      	ldr	r3, [r4, #0]
        HarAlgo = HAR_ALGO_IDX_NONE;
 8020ac6:	21ff      	movs	r1, #255	; 0xff
 8020ac8:	7011      	strb	r1, [r2, #0]
        MultiNN = 0;
 8020aca:	4a14      	ldr	r2, [pc, #80]	; (8020b1c <prvMultiCommand+0xf4>)
        W2ST_OFF_CONNECTION(W2ST_CONNECT_AR);
 8020acc:	f023 0310 	bic.w	r3, r3, #16
 8020ad0:	6023      	str	r3, [r4, #0]
        MultiNN = 0;
 8020ad2:	6015      	str	r5, [r2, #0]
 8020ad4:	e7e2      	b.n	8020a9c <prvMultiCommand+0x74>
        W2ST_ON_CONNECTION(W2ST_CONNECT_ASC_EVENT);
 8020ad6:	4c0f      	ldr	r4, [pc, #60]	; (8020b14 <prvMultiCommand+0xec>)
        MultiNN = 1;
 8020ad8:	4a10      	ldr	r2, [pc, #64]	; (8020b1c <prvMultiCommand+0xf4>)
        W2ST_ON_CONNECTION(W2ST_CONNECT_ASC_EVENT);
 8020ada:	6823      	ldr	r3, [r4, #0]
        startProc(AUDIO_SC, 0 /* Not Used for Audio */);
 8020adc:	4601      	mov	r1, r0
        MultiNN = 1;
 8020ade:	2001      	movs	r0, #1
        W2ST_ON_CONNECTION(W2ST_CONNECT_ASC_EVENT);
 8020ae0:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
        MultiNN = 1;
 8020ae4:	6010      	str	r0, [r2, #0]
        startProc(AUDIO_SC, 0 /* Not Used for Audio */);
 8020ae6:	2007      	movs	r0, #7
        W2ST_ON_CONNECTION(W2ST_CONNECT_ASC_EVENT);
 8020ae8:	6023      	str	r3, [r4, #0]
        startProc(AUDIO_SC, 0 /* Not Used for Audio */);
 8020aea:	f000 fef3 	bl	80218d4 <startProc>
        W2ST_ON_CONNECTION(W2ST_CONNECT_AR);
 8020aee:	6823      	ldr	r3, [r4, #0]
        startProc(ACTIVITY_IGN, INERTIAL_ACQ_ACTIVITY_IGN_MS);
 8020af0:	2126      	movs	r1, #38	; 0x26
        W2ST_ON_CONNECTION(W2ST_CONNECT_AR);
 8020af2:	f043 0310 	orr.w	r3, r3, #16
        startProc(ACTIVITY_IGN, INERTIAL_ACQ_ACTIVITY_IGN_MS);
 8020af6:	2009      	movs	r0, #9
        W2ST_ON_CONNECTION(W2ST_CONNECT_AR);
 8020af8:	6023      	str	r3, [r4, #0]
        startProc(ACTIVITY_IGN, INERTIAL_ACQ_ACTIVITY_IGN_MS);
 8020afa:	f000 feeb 	bl	80218d4 <startProc>
 8020afe:	e7cd      	b.n	8020a9c <prvMultiCommand+0x74>
 8020b00:	080430dc 	.word	0x080430dc
 8020b04:	08042ce4 	.word	0x08042ce4
 8020b08:	08042d00 	.word	0x08042d00
 8020b0c:	08042d1c 	.word	0x08042d1c
 8020b10:	20012a9c 	.word	0x20012a9c
 8020b14:	2001457c 	.word	0x2001457c
 8020b18:	20000d8a 	.word	0x20000d8a
 8020b1c:	200133d8 	.word	0x200133d8

08020b20 <prvHarCommand>:
{
 8020b20:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    sprintf(pcWriteBuffer, "\r\n");
 8020b24:	4b52      	ldr	r3, [pc, #328]	; (8020c70 <prvHarCommand+0x150>)
{
 8020b26:	b082      	sub	sp, #8
    sprintf(pcWriteBuffer, "\r\n");
 8020b28:	8819      	ldrh	r1, [r3, #0]
 8020b2a:	789b      	ldrb	r3, [r3, #2]
 8020b2c:	8001      	strh	r1, [r0, #0]
{
 8020b2e:	4616      	mov	r6, r2
 8020b30:	4604      	mov	r4, r0
    sprintf(pcWriteBuffer, "\r\n");
 8020b32:	7083      	strb	r3, [r0, #2]
    pcParameter = FreeRTOS_CLIGetParameter(
 8020b34:	aa01      	add	r2, sp, #4
 8020b36:	2102      	movs	r1, #2
 8020b38:	4630      	mov	r0, r6
 8020b3a:	f7fe f97d 	bl	801ee38 <FreeRTOS_CLIGetParameter>
    configASSERT(pcParameter);
 8020b3e:	2800      	cmp	r0, #0
 8020b40:	d03b      	beq.n	8020bba <prvHarCommand+0x9a>
    if (strncmp(pcParameter, "gmp", strlen("gmp")) == 0)
 8020b42:	7807      	ldrb	r7, [r0, #0]
 8020b44:	2f67      	cmp	r7, #103	; 0x67
 8020b46:	4605      	mov	r5, r0
 8020b48:	d02d      	beq.n	8020ba6 <prvHarCommand+0x86>
    else if (strncmp(pcParameter, "ign_wsdm", strlen("ign_wsdm")) == 0)
 8020b4a:	494a      	ldr	r1, [pc, #296]	; (8020c74 <prvHarCommand+0x154>)
 8020b4c:	2208      	movs	r2, #8
 8020b4e:	4628      	mov	r0, r5
 8020b50:	f007 fb7b 	bl	802824a <strncmp>
 8020b54:	2800      	cmp	r0, #0
 8020b56:	d139      	bne.n	8020bcc <prvHarCommand+0xac>
        process_period = INERTIAL_ACQ_ACTIVITY_IGN_WSDM_MS;
 8020b58:	f04f 0832 	mov.w	r8, #50	; 0x32
        process_type = ACTIVITY_IGN_WSDM;
 8020b5c:	270a      	movs	r7, #10
    pcParameter = FreeRTOS_CLIGetParameter(
 8020b5e:	aa01      	add	r2, sp, #4
 8020b60:	2101      	movs	r1, #1
 8020b62:	4630      	mov	r0, r6
 8020b64:	f7fe f968 	bl	801ee38 <FreeRTOS_CLIGetParameter>
    if (strncmp(pcParameter, "start", strlen("start")) == 0)
 8020b68:	4943      	ldr	r1, [pc, #268]	; (8020c78 <prvHarCommand+0x158>)
 8020b6a:	2205      	movs	r2, #5
    pcParameter = FreeRTOS_CLIGetParameter(
 8020b6c:	4605      	mov	r5, r0
    if (strncmp(pcParameter, "start", strlen("start")) == 0)
 8020b6e:	f007 fb6c 	bl	802824a <strncmp>
 8020b72:	2800      	cmp	r0, #0
 8020b74:	d068      	beq.n	8020c48 <prvHarCommand+0x128>
    else if (strncmp(pcParameter, "stop", strlen("stop")) == 0)
 8020b76:	4941      	ldr	r1, [pc, #260]	; (8020c7c <prvHarCommand+0x15c>)
 8020b78:	2204      	movs	r2, #4
 8020b7a:	4628      	mov	r0, r5
 8020b7c:	f007 fb65 	bl	802824a <strncmp>
 8020b80:	2800      	cmp	r0, #0
 8020b82:	d141      	bne.n	8020c08 <prvHarCommand+0xe8>
        W2ST_OFF_CONNECTION(W2ST_CONNECT_AR);
 8020b84:	4a3e      	ldr	r2, [pc, #248]	; (8020c80 <prvHarCommand+0x160>)
 8020b86:	6813      	ldr	r3, [r2, #0]
        stopProc(process_type);
 8020b88:	4638      	mov	r0, r7
        W2ST_OFF_CONNECTION(W2ST_CONNECT_AR);
 8020b8a:	f023 0310 	bic.w	r3, r3, #16
 8020b8e:	6013      	str	r3, [r2, #0]
        stopProc(process_type);
 8020b90:	f001 f862 	bl	8021c58 <stopProc>
    if (semRun) {
 8020b94:	4b3b      	ldr	r3, [pc, #236]	; (8020c84 <prvHarCommand+0x164>)
 8020b96:	6818      	ldr	r0, [r3, #0]
 8020b98:	b108      	cbz	r0, 8020b9e <prvHarCommand+0x7e>
      osSemaphoreRelease(semRun);
 8020b9a:	f7f7 ff61 	bl	8018a60 <osSemaphoreRelease>
}
 8020b9e:	2000      	movs	r0, #0
 8020ba0:	b002      	add	sp, #8
 8020ba2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    if (strncmp(pcParameter, "gmp", strlen("gmp")) == 0)
 8020ba6:	7843      	ldrb	r3, [r0, #1]
 8020ba8:	2b6d      	cmp	r3, #109	; 0x6d
 8020baa:	d1ce      	bne.n	8020b4a <prvHarCommand+0x2a>
 8020bac:	7883      	ldrb	r3, [r0, #2]
 8020bae:	2b70      	cmp	r3, #112	; 0x70
 8020bb0:	d1cb      	bne.n	8020b4a <prvHarCommand+0x2a>
        process_period = INERTIAL_ACQ_ACTIVITY_GMP_MS;
 8020bb2:	f04f 0826 	mov.w	r8, #38	; 0x26
        process_type = ACTIVITY_GMP;
 8020bb6:	2708      	movs	r7, #8
 8020bb8:	e7d1      	b.n	8020b5e <prvHarCommand+0x3e>
 8020bba:	f04f 0350 	mov.w	r3, #80	; 0x50
 8020bbe:	f383 8811 	msr	BASEPRI, r3
 8020bc2:	f3bf 8f6f 	isb	sy
 8020bc6:	f3bf 8f4f 	dsb	sy
    configASSERT(pcParameter);
 8020bca:	e7fe      	b.n	8020bca <prvHarCommand+0xaa>
    else if (strncmp(pcParameter, "ign", strlen("ign")) == 0)
 8020bcc:	2f69      	cmp	r7, #105	; 0x69
 8020bce:	d045      	beq.n	8020c5c <prvHarCommand+0x13c>
        sprintf(pcWriteBuffer, "Valid parameters are \"gmp\", \"ign\" and \"ign_wsdm\".\r\n");
 8020bd0:	f8df c0b8 	ldr.w	ip, [pc, #184]	; 8020c8c <prvHarCommand+0x16c>
 8020bd4:	4627      	mov	r7, r4
 8020bd6:	f10c 0e30 	add.w	lr, ip, #48	; 0x30
 8020bda:	4665      	mov	r5, ip
 8020bdc:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8020bde:	4575      	cmp	r5, lr
 8020be0:	f107 0710 	add.w	r7, r7, #16
 8020be4:	f10c 0c10 	add.w	ip, ip, #16
 8020be8:	f847 0c10 	str.w	r0, [r7, #-16]
 8020bec:	f847 1c0c 	str.w	r1, [r7, #-12]
 8020bf0:	f847 2c08 	str.w	r2, [r7, #-8]
 8020bf4:	f847 3c04 	str.w	r3, [r7, #-4]
 8020bf8:	d1ef      	bne.n	8020bda <prvHarCommand+0xba>
 8020bfa:	f8dc 0000 	ldr.w	r0, [ip]
 8020bfe:	6038      	str	r0, [r7, #0]
    uint32_t process_period = INERTIAL_ACQ_ACTIVITY_GMP_MS;
 8020c00:	f04f 0826 	mov.w	r8, #38	; 0x26
    msgType_t process_type = ACTIVITY_GMP;
 8020c04:	2708      	movs	r7, #8
 8020c06:	e7aa      	b.n	8020b5e <prvHarCommand+0x3e>
        sprintf(pcWriteBuffer, "Valid parameters are 'start' and 'stop'.\r\n");
 8020c08:	4d1f      	ldr	r5, [pc, #124]	; (8020c88 <prvHarCommand+0x168>)
 8020c0a:	46a4      	mov	ip, r4
 8020c0c:	f105 0620 	add.w	r6, r5, #32
 8020c10:	462c      	mov	r4, r5
 8020c12:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 8020c14:	42b4      	cmp	r4, r6
 8020c16:	f10c 0c10 	add.w	ip, ip, #16
 8020c1a:	f105 0510 	add.w	r5, r5, #16
 8020c1e:	f84c 0c10 	str.w	r0, [ip, #-16]
 8020c22:	f84c 1c0c 	str.w	r1, [ip, #-12]
 8020c26:	f84c 2c08 	str.w	r2, [ip, #-8]
 8020c2a:	f84c 3c04 	str.w	r3, [ip, #-4]
 8020c2e:	d1ef      	bne.n	8020c10 <prvHarCommand+0xf0>
 8020c30:	cd03      	ldmia	r5!, {r0, r1}
 8020c32:	882b      	ldrh	r3, [r5, #0]
 8020c34:	f8ac 3008 	strh.w	r3, [ip, #8]
 8020c38:	78ab      	ldrb	r3, [r5, #2]
 8020c3a:	f8cc 0000 	str.w	r0, [ip]
 8020c3e:	f8cc 1004 	str.w	r1, [ip, #4]
 8020c42:	f88c 300a 	strb.w	r3, [ip, #10]
 8020c46:	e7a5      	b.n	8020b94 <prvHarCommand+0x74>
        W2ST_ON_CONNECTION(W2ST_CONNECT_AR);
 8020c48:	4a0d      	ldr	r2, [pc, #52]	; (8020c80 <prvHarCommand+0x160>)
 8020c4a:	6813      	ldr	r3, [r2, #0]
        startProc(process_type, process_period);
 8020c4c:	4641      	mov	r1, r8
        W2ST_ON_CONNECTION(W2ST_CONNECT_AR);
 8020c4e:	f043 0310 	orr.w	r3, r3, #16
        startProc(process_type, process_period);
 8020c52:	4638      	mov	r0, r7
        W2ST_ON_CONNECTION(W2ST_CONNECT_AR);
 8020c54:	6013      	str	r3, [r2, #0]
        startProc(process_type, process_period);
 8020c56:	f000 fe3d 	bl	80218d4 <startProc>
 8020c5a:	e79b      	b.n	8020b94 <prvHarCommand+0x74>
    else if (strncmp(pcParameter, "ign", strlen("ign")) == 0)
 8020c5c:	786b      	ldrb	r3, [r5, #1]
 8020c5e:	2b67      	cmp	r3, #103	; 0x67
 8020c60:	d1b6      	bne.n	8020bd0 <prvHarCommand+0xb0>
 8020c62:	78ab      	ldrb	r3, [r5, #2]
 8020c64:	2b6e      	cmp	r3, #110	; 0x6e
 8020c66:	d1b3      	bne.n	8020bd0 <prvHarCommand+0xb0>
        process_period = INERTIAL_ACQ_ACTIVITY_IGN_MS;
 8020c68:	f04f 0826 	mov.w	r8, #38	; 0x26
        process_type = ACTIVITY_IGN;
 8020c6c:	2709      	movs	r7, #9
 8020c6e:	e776      	b.n	8020b5e <prvHarCommand+0x3e>
 8020c70:	080430dc 	.word	0x080430dc
 8020c74:	08042ca0 	.word	0x08042ca0
 8020c78:	08042ce4 	.word	0x08042ce4
 8020c7c:	08042d00 	.word	0x08042d00
 8020c80:	2001457c 	.word	0x2001457c
 8020c84:	20012a9c 	.word	0x20012a9c
 8020c88:	08042d1c 	.word	0x08042d1c
 8020c8c:	08042eac 	.word	0x08042eac

08020c90 <prvAscCommand>:
{
 8020c90:	b530      	push	{r4, r5, lr}
    sprintf(pcWriteBuffer, "\r\n");
 8020c92:	4b29      	ldr	r3, [pc, #164]	; (8020d38 <prvAscCommand+0xa8>)
{
 8020c94:	4604      	mov	r4, r0
    sprintf(pcWriteBuffer, "\r\n");
 8020c96:	8819      	ldrh	r1, [r3, #0]
 8020c98:	789b      	ldrb	r3, [r3, #2]
 8020c9a:	8021      	strh	r1, [r4, #0]
{
 8020c9c:	b083      	sub	sp, #12
 8020c9e:	4610      	mov	r0, r2
    pcParameter = FreeRTOS_CLIGetParameter(
 8020ca0:	2101      	movs	r1, #1
 8020ca2:	aa01      	add	r2, sp, #4
    sprintf(pcWriteBuffer, "\r\n");
 8020ca4:	70a3      	strb	r3, [r4, #2]
    pcParameter = FreeRTOS_CLIGetParameter(
 8020ca6:	f7fe f8c7 	bl	801ee38 <FreeRTOS_CLIGetParameter>
    if (strncmp(pcParameter, "start", strlen("start")) == 0)
 8020caa:	4924      	ldr	r1, [pc, #144]	; (8020d3c <prvAscCommand+0xac>)
 8020cac:	2205      	movs	r2, #5
    pcParameter = FreeRTOS_CLIGetParameter(
 8020cae:	4605      	mov	r5, r0
    if (strncmp(pcParameter, "start", strlen("start")) == 0)
 8020cb0:	f007 facb 	bl	802824a <strncmp>
 8020cb4:	2800      	cmp	r0, #0
 8020cb6:	d035      	beq.n	8020d24 <prvAscCommand+0x94>
    else if (strncmp(pcParameter, "stop", strlen("stop")) == 0)
 8020cb8:	4921      	ldr	r1, [pc, #132]	; (8020d40 <prvAscCommand+0xb0>)
 8020cba:	2204      	movs	r2, #4
 8020cbc:	4628      	mov	r0, r5
 8020cbe:	f007 fac4 	bl	802824a <strncmp>
 8020cc2:	b330      	cbz	r0, 8020d12 <prvAscCommand+0x82>
        sprintf(pcWriteBuffer, "Valid parameters are 'start' and 'stop'.\r\n");
 8020cc4:	4d1f      	ldr	r5, [pc, #124]	; (8020d44 <prvAscCommand+0xb4>)
 8020cc6:	46a4      	mov	ip, r4
 8020cc8:	f105 0e20 	add.w	lr, r5, #32
 8020ccc:	462c      	mov	r4, r5
 8020cce:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 8020cd0:	4574      	cmp	r4, lr
 8020cd2:	f10c 0c10 	add.w	ip, ip, #16
 8020cd6:	f105 0510 	add.w	r5, r5, #16
 8020cda:	f84c 0c10 	str.w	r0, [ip, #-16]
 8020cde:	f84c 1c0c 	str.w	r1, [ip, #-12]
 8020ce2:	f84c 2c08 	str.w	r2, [ip, #-8]
 8020ce6:	f84c 3c04 	str.w	r3, [ip, #-4]
 8020cea:	d1ef      	bne.n	8020ccc <prvAscCommand+0x3c>
 8020cec:	cd03      	ldmia	r5!, {r0, r1}
 8020cee:	882b      	ldrh	r3, [r5, #0]
 8020cf0:	f8ac 3008 	strh.w	r3, [ip, #8]
 8020cf4:	78ab      	ldrb	r3, [r5, #2]
 8020cf6:	f8cc 0000 	str.w	r0, [ip]
 8020cfa:	f8cc 1004 	str.w	r1, [ip, #4]
 8020cfe:	f88c 300a 	strb.w	r3, [ip, #10]
    if (semRun) {
 8020d02:	4b11      	ldr	r3, [pc, #68]	; (8020d48 <prvAscCommand+0xb8>)
 8020d04:	6818      	ldr	r0, [r3, #0]
 8020d06:	b108      	cbz	r0, 8020d0c <prvAscCommand+0x7c>
      osSemaphoreRelease(semRun);
 8020d08:	f7f7 feaa 	bl	8018a60 <osSemaphoreRelease>
}
 8020d0c:	2000      	movs	r0, #0
 8020d0e:	b003      	add	sp, #12
 8020d10:	bd30      	pop	{r4, r5, pc}
        stopProc(AUDIO_SC);
 8020d12:	2007      	movs	r0, #7
 8020d14:	f000 ffa0 	bl	8021c58 <stopProc>
        W2ST_OFF_CONNECTION(W2ST_CONNECT_ASC_EVENT);
 8020d18:	4a0c      	ldr	r2, [pc, #48]	; (8020d4c <prvAscCommand+0xbc>)
 8020d1a:	6813      	ldr	r3, [r2, #0]
 8020d1c:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
 8020d20:	6013      	str	r3, [r2, #0]
 8020d22:	e7ee      	b.n	8020d02 <prvAscCommand+0x72>
        W2ST_ON_CONNECTION(W2ST_CONNECT_ASC_EVENT);
 8020d24:	4a09      	ldr	r2, [pc, #36]	; (8020d4c <prvAscCommand+0xbc>)
 8020d26:	6813      	ldr	r3, [r2, #0]
        startProc(AUDIO_SC, 0 /* Not Used for Audio */);
 8020d28:	4601      	mov	r1, r0
        W2ST_ON_CONNECTION(W2ST_CONNECT_ASC_EVENT);
 8020d2a:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
        startProc(AUDIO_SC, 0 /* Not Used for Audio */);
 8020d2e:	2007      	movs	r0, #7
        W2ST_ON_CONNECTION(W2ST_CONNECT_ASC_EVENT);
 8020d30:	6013      	str	r3, [r2, #0]
        startProc(AUDIO_SC, 0 /* Not Used for Audio */);
 8020d32:	f000 fdcf 	bl	80218d4 <startProc>
 8020d36:	e7e4      	b.n	8020d02 <prvAscCommand+0x72>
 8020d38:	080430dc 	.word	0x080430dc
 8020d3c:	08042ce4 	.word	0x08042ce4
 8020d40:	08042d00 	.word	0x08042d00
 8020d44:	08042d1c 	.word	0x08042d1c
 8020d48:	20012a9c 	.word	0x20012a9c
 8020d4c:	2001457c 	.word	0x2001457c

08020d50 <prvUidCommand>:
{
 8020d50:	b530      	push	{r4, r5, lr}
 8020d52:	b08d      	sub	sp, #52	; 0x34
 8020d54:	4604      	mov	r4, r0
    uint32_t mcu_dev_id = HAL_GetDEVID();
 8020d56:	f7ee fd79 	bl	800f84c <HAL_GetDEVID>
            uid[3], uid[2], uid[1], uid[0],
 8020d5a:	4916      	ldr	r1, [pc, #88]	; (8020db4 <prvUidCommand+0x64>)
    uint32_t mcu_dev_id = HAL_GetDEVID();
 8020d5c:	4605      	mov	r5, r0
    sprintf(pcWriteBuffer, "%.2X%.2X%.2X%.2X%.2X%.2X%.2X%.2X%.2X%.2X%.2X%.2X_%.3lX\n",
 8020d5e:	f891 3092 	ldrb.w	r3, [r1, #146]	; 0x92
 8020d62:	f891 2093 	ldrb.w	r2, [r1, #147]	; 0x93
 8020d66:	950a      	str	r5, [sp, #40]	; 0x28
 8020d68:	4620      	mov	r0, r4
 8020d6a:	f891 4098 	ldrb.w	r4, [r1, #152]	; 0x98
 8020d6e:	9409      	str	r4, [sp, #36]	; 0x24
 8020d70:	f891 4099 	ldrb.w	r4, [r1, #153]	; 0x99
 8020d74:	9408      	str	r4, [sp, #32]
 8020d76:	f891 409a 	ldrb.w	r4, [r1, #154]	; 0x9a
 8020d7a:	9407      	str	r4, [sp, #28]
 8020d7c:	f891 409b 	ldrb.w	r4, [r1, #155]	; 0x9b
 8020d80:	9406      	str	r4, [sp, #24]
 8020d82:	f891 4094 	ldrb.w	r4, [r1, #148]	; 0x94
 8020d86:	9405      	str	r4, [sp, #20]
 8020d88:	f891 4095 	ldrb.w	r4, [r1, #149]	; 0x95
 8020d8c:	9404      	str	r4, [sp, #16]
 8020d8e:	f891 4096 	ldrb.w	r4, [r1, #150]	; 0x96
 8020d92:	9403      	str	r4, [sp, #12]
 8020d94:	f891 4097 	ldrb.w	r4, [r1, #151]	; 0x97
 8020d98:	9402      	str	r4, [sp, #8]
 8020d9a:	f891 4090 	ldrb.w	r4, [r1, #144]	; 0x90
 8020d9e:	9401      	str	r4, [sp, #4]
 8020da0:	f891 4091 	ldrb.w	r4, [r1, #145]	; 0x91
 8020da4:	9400      	str	r4, [sp, #0]
 8020da6:	4904      	ldr	r1, [pc, #16]	; (8020db8 <prvUidCommand+0x68>)
 8020da8:	f007 f9ec 	bl	8028184 <siprintf>
}
 8020dac:	2000      	movs	r0, #0
 8020dae:	b00d      	add	sp, #52	; 0x34
 8020db0:	bd30      	pop	{r4, r5, pc}
 8020db2:	bf00      	nop
 8020db4:	1fff7500 	.word	0x1fff7500
 8020db8:	08042ee0 	.word	0x08042ee0

08020dbc <prvInfoCommand>:
{
 8020dbc:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    if (xReturn == 0)
 8020dc0:	4d1a      	ldr	r5, [pc, #104]	; (8020e2c <prvInfoCommand+0x70>)
 8020dc2:	f8d5 3154 	ldr.w	r3, [r5, #340]	; 0x154
{
 8020dc6:	b084      	sub	sp, #16
    if (xReturn == 0)
 8020dc8:	b973      	cbnz	r3, 8020de8 <prvInfoCommand+0x2c>
        sprintf(pcWriteBuffer,"\r\nSTMicroelectronics %s:\r\n"
 8020dca:	2133      	movs	r1, #51	; 0x33
 8020dcc:	2330      	movs	r3, #48	; 0x30
 8020dce:	e9cd 3100 	strd	r3, r1, [sp]
 8020dd2:	4a17      	ldr	r2, [pc, #92]	; (8020e30 <prvInfoCommand+0x74>)
 8020dd4:	4917      	ldr	r1, [pc, #92]	; (8020e34 <prvInfoCommand+0x78>)
 8020dd6:	2334      	movs	r3, #52	; 0x34
 8020dd8:	f007 f9d4 	bl	8028184 <siprintf>
        xReturn = 1; /* There is more to output */
 8020ddc:	2001      	movs	r0, #1
 8020dde:	f8c5 0154 	str.w	r0, [r5, #340]	; 0x154
}
 8020de2:	b004      	add	sp, #16
 8020de4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        sprintf(pcWriteBuffer,
 8020de8:	4604      	mov	r4, r0
            HAL_GetHalVersion() >>24,
 8020dea:	f7ee fd2b 	bl	800f844 <HAL_GetHalVersion>
 8020dee:	4607      	mov	r7, r0
            (HAL_GetHalVersion() >>16)&0xFF,
 8020df0:	f7ee fd28 	bl	800f844 <HAL_GetHalVersion>
 8020df4:	4680      	mov	r8, r0
            (HAL_GetHalVersion() >> 8)&0xFF,
 8020df6:	f7ee fd25 	bl	800f844 <HAL_GetHalVersion>
 8020dfa:	4606      	mov	r6, r0
            HAL_GetHalVersion()      &0xFF,
 8020dfc:	f7ee fd22 	bl	800f844 <HAL_GetHalVersion>
        sprintf(pcWriteBuffer,
 8020e00:	b2c0      	uxtb	r0, r0
 8020e02:	9001      	str	r0, [sp, #4]
 8020e04:	4620      	mov	r0, r4
 8020e06:	4c0c      	ldr	r4, [pc, #48]	; (8020e38 <prvInfoCommand+0x7c>)
 8020e08:	9403      	str	r4, [sp, #12]
 8020e0a:	f3c6 2607 	ubfx	r6, r6, #8, #8
 8020e0e:	4c0b      	ldr	r4, [pc, #44]	; (8020e3c <prvInfoCommand+0x80>)
 8020e10:	490b      	ldr	r1, [pc, #44]	; (8020e40 <prvInfoCommand+0x84>)
 8020e12:	9600      	str	r6, [sp, #0]
 8020e14:	f3c8 4307 	ubfx	r3, r8, #16, #8
 8020e18:	0e3a      	lsrs	r2, r7, #24
 8020e1a:	9402      	str	r4, [sp, #8]
 8020e1c:	f007 f9b2 	bl	8028184 <siprintf>
        xReturn = 0; /* done */
 8020e20:	2000      	movs	r0, #0
 8020e22:	f8c5 0154 	str.w	r0, [r5, #340]	; 0x154
}
 8020e26:	b004      	add	sp, #16
 8020e28:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8020e2c:	2001281c 	.word	0x2001281c
 8020e30:	08042f18 	.word	0x08042f18
 8020e34:	08042f24 	.word	0x08042f24
 8020e38:	08042fa8 	.word	0x08042fa8
 8020e3c:	08042fb4 	.word	0x08042fb4
 8020e40:	08042f70 	.word	0x08042f70

08020e44 <prvSdnameCommand>:
    configASSERT(pcWriteBuffer);
 8020e44:	b1d0      	cbz	r0, 8020e7c <prvSdnameCommand+0x38>
{
 8020e46:	b510      	push	{r4, lr}
 8020e48:	4613      	mov	r3, r2
 8020e4a:	b082      	sub	sp, #8
    pcParameter = FreeRTOS_CLIGetParameter(
 8020e4c:	2101      	movs	r1, #1
 8020e4e:	4604      	mov	r4, r0
 8020e50:	aa01      	add	r2, sp, #4
 8020e52:	4618      	mov	r0, r3
 8020e54:	f7fd fff0 	bl	801ee38 <FreeRTOS_CLIGetParameter>
    if (pcParameter != NULL)
 8020e58:	4601      	mov	r1, r0
 8020e5a:	b1c0      	cbz	r0, 8020e8e <prvSdnameCommand+0x4a>
        strncpy(DefaultDataFileName, pcParameter, 11);
 8020e5c:	4b10      	ldr	r3, [pc, #64]	; (8020ea0 <prvSdnameCommand+0x5c>)
 8020e5e:	220b      	movs	r2, #11
 8020e60:	4618      	mov	r0, r3
 8020e62:	f007 fa06 	bl	8028272 <strncpy>
        sprintf(pcWriteBuffer, "\r\n");
 8020e66:	4a0f      	ldr	r2, [pc, #60]	; (8020ea4 <prvSdnameCommand+0x60>)
        strncpy(DefaultDataFileName, pcParameter, 11);
 8020e68:	4603      	mov	r3, r0
        sprintf(pcWriteBuffer, "\r\n");
 8020e6a:	8811      	ldrh	r1, [r2, #0]
 8020e6c:	7892      	ldrb	r2, [r2, #2]
        DefaultDataFileName[11] = '\0';
 8020e6e:	2000      	movs	r0, #0
 8020e70:	72d8      	strb	r0, [r3, #11]
}
 8020e72:	2000      	movs	r0, #0
        sprintf(pcWriteBuffer, "\r\n");
 8020e74:	8021      	strh	r1, [r4, #0]
 8020e76:	70a2      	strb	r2, [r4, #2]
}
 8020e78:	b002      	add	sp, #8
 8020e7a:	bd10      	pop	{r4, pc}
 8020e7c:	f04f 0350 	mov.w	r3, #80	; 0x50
 8020e80:	f383 8811 	msr	BASEPRI, r3
 8020e84:	f3bf 8f6f 	isb	sy
 8020e88:	f3bf 8f4f 	dsb	sy
    configASSERT(pcWriteBuffer);
 8020e8c:	e7fe      	b.n	8020e8c <prvSdnameCommand+0x48>
        sprintf(pcWriteBuffer, "%s\r\n", DefaultDataFileName);
 8020e8e:	4a04      	ldr	r2, [pc, #16]	; (8020ea0 <prvSdnameCommand+0x5c>)
 8020e90:	4905      	ldr	r1, [pc, #20]	; (8020ea8 <prvSdnameCommand+0x64>)
 8020e92:	4620      	mov	r0, r4
 8020e94:	f007 f976 	bl	8028184 <siprintf>
}
 8020e98:	2000      	movs	r0, #0
 8020e9a:	b002      	add	sp, #8
 8020e9c:	bd10      	pop	{r4, pc}
 8020e9e:	bf00      	nop
 8020ea0:	2000b524 	.word	0x2000b524
 8020ea4:	080430dc 	.word	0x080430dc
 8020ea8:	08042e08 	.word	0x08042e08

08020eac <prvDateCommand>:
    configASSERT(pcWriteBuffer);
 8020eac:	2800      	cmp	r0, #0
 8020eae:	d079      	beq.n	8020fa4 <prvDateCommand+0xf8>
{
 8020eb0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8020eb4:	4615      	mov	r5, r2
 8020eb6:	b088      	sub	sp, #32
    pcParameter1 = FreeRTOS_CLIGetParameter(
 8020eb8:	aa06      	add	r2, sp, #24
 8020eba:	2101      	movs	r1, #1
 8020ebc:	4604      	mov	r4, r0
 8020ebe:	4628      	mov	r0, r5
 8020ec0:	f7fd ffba 	bl	801ee38 <FreeRTOS_CLIGetParameter>
 8020ec4:	4603      	mov	r3, r0
    pcParameter2 = FreeRTOS_CLIGetParameter(
 8020ec6:	aa07      	add	r2, sp, #28
 8020ec8:	4628      	mov	r0, r5
 8020eca:	2102      	movs	r1, #2
    pcParameter1 = FreeRTOS_CLIGetParameter(
 8020ecc:	461d      	mov	r5, r3
    pcParameter2 = FreeRTOS_CLIGetParameter(
 8020ece:	f7fd ffb3 	bl	801ee38 <FreeRTOS_CLIGetParameter>
    if (pcParameter1 != NULL)
 8020ed2:	2d00      	cmp	r5, #0
 8020ed4:	d06f      	beq.n	8020fb6 <prvDateCommand+0x10a>
        if (pcParameter2 == NULL)
 8020ed6:	2800      	cmp	r0, #0
 8020ed8:	f000 8082 	beq.w	8020fe0 <prvDateCommand+0x134>
        else if ((xParameterStringLength1 != 11) || (xParameterStringLength2 != 8))
 8020edc:	9b06      	ldr	r3, [sp, #24]
 8020ede:	2b0b      	cmp	r3, #11
 8020ee0:	d157      	bne.n	8020f92 <prvDateCommand+0xe6>
 8020ee2:	9b07      	ldr	r3, [sp, #28]
 8020ee4:	2b08      	cmp	r3, #8
 8020ee6:	d154      	bne.n	8020f92 <prvDateCommand+0xe6>
            date.WeekDay = pcParameter1[1] - 48;
 8020ee8:	f895 c001 	ldrb.w	ip, [r5, #1]
                           ((date.Month > 0x00) && (date.Month < 0x13)) &&
 8020eec:	f1ac 0331 	sub.w	r3, ip, #49	; 0x31
 8020ef0:	2b06      	cmp	r3, #6
 8020ef2:	d84e      	bhi.n	8020f92 <prvDateCommand+0xe6>
            date.Date    =  ((pcParameter1[3] - 48) * 16) + (pcParameter1[4] - 48);
 8020ef4:	78eb      	ldrb	r3, [r5, #3]
 8020ef6:	7929      	ldrb	r1, [r5, #4]
 8020ef8:	eb01 1103 	add.w	r1, r1, r3, lsl #4
 8020efc:	f001 01ff 	and.w	r1, r1, #255	; 0xff
            date_valid =  (((date.WeekDay > 0x00) && (date.WeekDay < 0x08)) &&
 8020f00:	f1a1 0331 	sub.w	r3, r1, #49	; 0x31
 8020f04:	2b30      	cmp	r3, #48	; 0x30
 8020f06:	d844      	bhi.n	8020f92 <prvDateCommand+0xe6>
            date.Month   = ((pcParameter1[6] - 48) * 16) + (pcParameter1[7] - 48);
 8020f08:	79ab      	ldrb	r3, [r5, #6]
 8020f0a:	79ea      	ldrb	r2, [r5, #7]
 8020f0c:	eb02 1203 	add.w	r2, r2, r3, lsl #4
 8020f10:	f002 02ff 	and.w	r2, r2, #255	; 0xff
                           ((date.Date > 0x00) && (date.Date < 0x32)) &&
 8020f14:	f1a2 0331 	sub.w	r3, r2, #49	; 0x31
 8020f18:	2b11      	cmp	r3, #17
 8020f1a:	d83a      	bhi.n	8020f92 <prvDateCommand+0xe6>
            time.Hours=   ((pcParameter2[0]  - 48) * 16) + (pcParameter2[1]  - 48);
 8020f1c:	7803      	ldrb	r3, [r0, #0]
 8020f1e:	7846      	ldrb	r6, [r0, #1]
 8020f20:	eb06 1603 	add.w	r6, r6, r3, lsl #4
 8020f24:	f5a6 764c 	sub.w	r6, r6, #816	; 0x330
 8020f28:	b2f6      	uxtb	r6, r6
                          (time.Minutes < 0x60) &&
 8020f2a:	2e23      	cmp	r6, #35	; 0x23
 8020f2c:	d831      	bhi.n	8020f92 <prvDateCommand+0xe6>
            time.Minutes= ((pcParameter2[3] - 48) * 16) + (pcParameter2[4] - 48);
 8020f2e:	78c3      	ldrb	r3, [r0, #3]
 8020f30:	7907      	ldrb	r7, [r0, #4]
 8020f32:	eb07 1703 	add.w	r7, r7, r3, lsl #4
 8020f36:	f5a7 774c 	sub.w	r7, r7, #816	; 0x330
 8020f3a:	b2ff      	uxtb	r7, r7
            time_valid = ((time.Hours   < 0x24) &&
 8020f3c:	2f5f      	cmp	r7, #95	; 0x5f
 8020f3e:	d828      	bhi.n	8020f92 <prvDateCommand+0xe6>
            time.Seconds= ((pcParameter2[6] - 48) * 16) + (pcParameter2[7] - 48);
 8020f40:	7983      	ldrb	r3, [r0, #6]
 8020f42:	f890 8007 	ldrb.w	r8, [r0, #7]
 8020f46:	eb08 1803 	add.w	r8, r8, r3, lsl #4
 8020f4a:	f5a8 784c 	sub.w	r8, r8, #816	; 0x330
 8020f4e:	fa5f f888 	uxtb.w	r8, r8
                          (time.Minutes < 0x60) &&
 8020f52:	f1b8 0f5f 	cmp.w	r8, #95	; 0x5f
 8020f56:	d81c      	bhi.n	8020f92 <prvDateCommand+0xe6>
            date.Year    =  ((pcParameter1[9] - 48) * 16) + (pcParameter1[10] - 48);
 8020f58:	7a68      	ldrb	r0, [r5, #9]
 8020f5a:	7aab      	ldrb	r3, [r5, #10]
 8020f5c:	eb03 1300 	add.w	r3, r3, r0, lsl #4
 8020f60:	f5a3 734c 	sub.w	r3, r3, #816	; 0x330
 8020f64:	b2db      	uxtb	r3, r3
            if (date_valid && time_valid)
 8020f66:	2b98      	cmp	r3, #152	; 0x98
 8020f68:	d813      	bhi.n	8020f92 <prvDateCommand+0xe6>
            date.WeekDay = pcParameter1[1] - 48;
 8020f6a:	f1ac 0030 	sub.w	r0, ip, #48	; 0x30
            date.Month   = ((pcParameter1[6] - 48) * 16) + (pcParameter1[7] - 48);
 8020f6e:	3a30      	subs	r2, #48	; 0x30
            date.Date    =  ((pcParameter1[3] - 48) * 16) + (pcParameter1[4] - 48);
 8020f70:	3930      	subs	r1, #48	; 0x30
                RTC_DateConfig(date.WeekDay, date.Date, date.Month, date.Year);
 8020f72:	b2d2      	uxtb	r2, r2
 8020f74:	b2c9      	uxtb	r1, r1
 8020f76:	b2c0      	uxtb	r0, r0
 8020f78:	f001 fd42 	bl	8022a00 <RTC_DateConfig>
                RTC_TimeConfig(time.Hours, time.Minutes, time.Seconds);
 8020f7c:	4642      	mov	r2, r8
 8020f7e:	4639      	mov	r1, r7
 8020f80:	4630      	mov	r0, r6
 8020f82:	f001 fd57 	bl	8022a34 <RTC_TimeConfig>
                sprintf(pcWriteBuffer, "\r\n");
 8020f86:	4b1d      	ldr	r3, [pc, #116]	; (8020ffc <prvDateCommand+0x150>)
 8020f88:	881a      	ldrh	r2, [r3, #0]
 8020f8a:	789b      	ldrb	r3, [r3, #2]
 8020f8c:	8022      	strh	r2, [r4, #0]
 8020f8e:	70a3      	strb	r3, [r4, #2]
 8020f90:	e004      	b.n	8020f9c <prvDateCommand+0xf0>
                sprintf(pcWriteBuffer, "Invalid date \'%s\'\r\n", pcParameter1);
 8020f92:	491b      	ldr	r1, [pc, #108]	; (8021000 <prvDateCommand+0x154>)
 8020f94:	462a      	mov	r2, r5
 8020f96:	4620      	mov	r0, r4
 8020f98:	f007 f8f4 	bl	8028184 <siprintf>
}
 8020f9c:	2000      	movs	r0, #0
 8020f9e:	b008      	add	sp, #32
 8020fa0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8020fa4:	f04f 0350 	mov.w	r3, #80	; 0x50
 8020fa8:	f383 8811 	msr	BASEPRI, r3
 8020fac:	f3bf 8f6f 	isb	sy
 8020fb0:	f3bf 8f4f 	dsb	sy
    configASSERT(pcWriteBuffer);
 8020fb4:	e7fe      	b.n	8020fb4 <prvDateCommand+0x108>
        RTC_GetCurrentDateTime();
 8020fb6:	f001 fced 	bl	8022994 <RTC_GetCurrentDateTime>
            CurrentTime.Seconds);
 8020fba:	4b12      	ldr	r3, [pc, #72]	; (8021004 <prvDateCommand+0x158>)
            CurrentDate.Date,
 8020fbc:	4a12      	ldr	r2, [pc, #72]	; (8021008 <prvDateCommand+0x15c>)
        sprintf(pcWriteBuffer,
 8020fbe:	7899      	ldrb	r1, [r3, #2]
 8020fc0:	78d0      	ldrb	r0, [r2, #3]
 8020fc2:	9104      	str	r1, [sp, #16]
 8020fc4:	7859      	ldrb	r1, [r3, #1]
 8020fc6:	781b      	ldrb	r3, [r3, #0]
 8020fc8:	9103      	str	r1, [sp, #12]
 8020fca:	7851      	ldrb	r1, [r2, #1]
 8020fcc:	e9cd 0301 	strd	r0, r3, [sp, #4]
 8020fd0:	4620      	mov	r0, r4
 8020fd2:	7893      	ldrb	r3, [r2, #2]
 8020fd4:	7812      	ldrb	r2, [r2, #0]
 8020fd6:	9100      	str	r1, [sp, #0]
 8020fd8:	490c      	ldr	r1, [pc, #48]	; (802100c <prvDateCommand+0x160>)
 8020fda:	f007 f8d3 	bl	8028184 <siprintf>
 8020fde:	e7dd      	b.n	8020f9c <prvDateCommand+0xf0>
            sprintf(pcWriteBuffer, "missing time information\r\n");
 8020fe0:	4d0b      	ldr	r5, [pc, #44]	; (8021010 <prvDateCommand+0x164>)
 8020fe2:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8020fe4:	6020      	str	r0, [r4, #0]
 8020fe6:	6061      	str	r1, [r4, #4]
 8020fe8:	cd03      	ldmia	r5!, {r0, r1}
 8020fea:	60e3      	str	r3, [r4, #12]
 8020fec:	882b      	ldrh	r3, [r5, #0]
 8020fee:	8323      	strh	r3, [r4, #24]
 8020ff0:	78ab      	ldrb	r3, [r5, #2]
 8020ff2:	60a2      	str	r2, [r4, #8]
 8020ff4:	6120      	str	r0, [r4, #16]
 8020ff6:	6161      	str	r1, [r4, #20]
 8020ff8:	76a3      	strb	r3, [r4, #26]
 8020ffa:	e7cf      	b.n	8020f9c <prvDateCommand+0xf0>
 8020ffc:	080430dc 	.word	0x080430dc
 8021000:	08042fdc 	.word	0x08042fdc
 8021004:	200134f0 	.word	0x200134f0
 8021008:	20013528 	.word	0x20013528
 802100c:	08042ff0 	.word	0x08042ff0
 8021010:	08042fc0 	.word	0x08042fc0

08021014 <prvNameCommand>:
    configASSERT(pcWriteBuffer);
 8021014:	b330      	cbz	r0, 8021064 <prvNameCommand+0x50>
{
 8021016:	b510      	push	{r4, lr}
 8021018:	4613      	mov	r3, r2
 802101a:	b082      	sub	sp, #8
    pcParameter = FreeRTOS_CLIGetParameter(
 802101c:	2101      	movs	r1, #1
 802101e:	4604      	mov	r4, r0
 8021020:	aa01      	add	r2, sp, #4
 8021022:	4618      	mov	r0, r3
 8021024:	f7fd ff08 	bl	801ee38 <FreeRTOS_CLIGetParameter>
    if (pcParameter != NULL)
 8021028:	4601      	mov	r1, r0
 802102a:	b320      	cbz	r0, 8021076 <prvNameCommand+0x62>
        strncpy((char *)NodeName + 1, pcParameter, 7);
 802102c:	2206      	movs	r2, #6
 802102e:	4816      	ldr	r0, [pc, #88]	; (8021088 <prvNameCommand+0x74>)
 8021030:	f007 f91f 	bl	8028272 <strncpy>
        NodeName[7]= '\0'; /* to suppress warning -Wstringop-truncation:
 8021034:	4915      	ldr	r1, [pc, #84]	; (802108c <prvNameCommand+0x78>)
 8021036:	2300      	movs	r3, #0
 8021038:	71cb      	strb	r3, [r1, #7]
        MDM_SaveGMD(GMD_NODE_NAME, (void *)&NodeName);
 802103a:	2008      	movs	r0, #8
 802103c:	f7fa f8d0 	bl	801b1e0 <MDM_SaveGMD>
        if (semRun) {
 8021040:	4b13      	ldr	r3, [pc, #76]	; (8021090 <prvNameCommand+0x7c>)
        NecessityToSaveMetaDataManager = 1;
 8021042:	4914      	ldr	r1, [pc, #80]	; (8021094 <prvNameCommand+0x80>)
        set_connectable = TRUE;
 8021044:	4a14      	ldr	r2, [pc, #80]	; (8021098 <prvNameCommand+0x84>)
        if (semRun) {
 8021046:	6818      	ldr	r0, [r3, #0]
        NecessityToSaveMetaDataManager = 1;
 8021048:	2301      	movs	r3, #1
 802104a:	600b      	str	r3, [r1, #0]
        set_connectable = TRUE;
 802104c:	7013      	strb	r3, [r2, #0]
        if (semRun) {
 802104e:	b108      	cbz	r0, 8021054 <prvNameCommand+0x40>
            osSemaphoreRelease(semRun);
 8021050:	f7f7 fd06 	bl	8018a60 <osSemaphoreRelease>
        sprintf(pcWriteBuffer, "\r\n");
 8021054:	4b11      	ldr	r3, [pc, #68]	; (802109c <prvNameCommand+0x88>)
 8021056:	881a      	ldrh	r2, [r3, #0]
 8021058:	789b      	ldrb	r3, [r3, #2]
 802105a:	8022      	strh	r2, [r4, #0]
}
 802105c:	2000      	movs	r0, #0
        sprintf(pcWriteBuffer, "\r\n");
 802105e:	70a3      	strb	r3, [r4, #2]
}
 8021060:	b002      	add	sp, #8
 8021062:	bd10      	pop	{r4, pc}
 8021064:	f04f 0350 	mov.w	r3, #80	; 0x50
 8021068:	f383 8811 	msr	BASEPRI, r3
 802106c:	f3bf 8f6f 	isb	sy
 8021070:	f3bf 8f4f 	dsb	sy
    configASSERT(pcWriteBuffer);
 8021074:	e7fe      	b.n	8021074 <prvNameCommand+0x60>
        sprintf(pcWriteBuffer, "%s\r\n", NodeName+1);
 8021076:	4a04      	ldr	r2, [pc, #16]	; (8021088 <prvNameCommand+0x74>)
 8021078:	4909      	ldr	r1, [pc, #36]	; (80210a0 <prvNameCommand+0x8c>)
 802107a:	4620      	mov	r0, r4
 802107c:	f007 f882 	bl	8028184 <siprintf>
}
 8021080:	2000      	movs	r0, #0
 8021082:	b002      	add	sp, #8
 8021084:	bd10      	pop	{r4, pc}
 8021086:	bf00      	nop
 8021088:	200134e1 	.word	0x200134e1
 802108c:	200134e0 	.word	0x200134e0
 8021090:	20012a9c 	.word	0x20012a9c
 8021094:	200080e8 	.word	0x200080e8
 8021098:	20000db9 	.word	0x20000db9
 802109c:	080430dc 	.word	0x080430dc
 80210a0:	08042e08 	.word	0x08042e08

080210a4 <RegisterCLICommands>:
{
 80210a4:	b510      	push	{r4, lr}
    FreeRTOS_CLIRegisterCommand(&xInfoCommand);
 80210a6:	4c27      	ldr	r4, [pc, #156]	; (8021144 <RegisterCLICommands+0xa0>)
 80210a8:	4620      	mov	r0, r4
 80210aa:	f7fd fe2d 	bl	801ed08 <FreeRTOS_CLIRegisterCommand>
    FreeRTOS_CLIRegisterCommand(&xUidCommand);
 80210ae:	f104 0010 	add.w	r0, r4, #16
 80210b2:	f7fd fe29 	bl	801ed08 <FreeRTOS_CLIRegisterCommand>
    FreeRTOS_CLIRegisterCommand(&xNameCommand);
 80210b6:	f104 0020 	add.w	r0, r4, #32
 80210ba:	f7fd fe25 	bl	801ed08 <FreeRTOS_CLIRegisterCommand>
    FreeRTOS_CLIRegisterCommand(&xDateCommand);
 80210be:	f104 0030 	add.w	r0, r4, #48	; 0x30
 80210c2:	f7fd fe21 	bl	801ed08 <FreeRTOS_CLIRegisterCommand>
    FreeRTOS_CLIRegisterCommand(&xBdaddrCommand);
 80210c6:	f104 0040 	add.w	r0, r4, #64	; 0x40
 80210ca:	f7fd fe1d 	bl	801ed08 <FreeRTOS_CLIRegisterCommand>
    FreeRTOS_CLIRegisterCommand(&xAscCommand);
 80210ce:	f104 0050 	add.w	r0, r4, #80	; 0x50
 80210d2:	f7fd fe19 	bl	801ed08 <FreeRTOS_CLIRegisterCommand>
    FreeRTOS_CLIRegisterCommand(&xHarCommand);
 80210d6:	f104 0060 	add.w	r0, r4, #96	; 0x60
 80210da:	f7fd fe15 	bl	801ed08 <FreeRTOS_CLIRegisterCommand>
    FreeRTOS_CLIRegisterCommand(&xMultiCommand);
 80210de:	f104 0070 	add.w	r0, r4, #112	; 0x70
 80210e2:	f7fd fe11 	bl	801ed08 <FreeRTOS_CLIRegisterCommand>
    FreeRTOS_CLIRegisterCommand(&xGetAllAIAlgoCommand);
 80210e6:	f104 0080 	add.w	r0, r4, #128	; 0x80
 80210ea:	f7fd fe0d 	bl	801ed08 <FreeRTOS_CLIRegisterCommand>
    FreeRTOS_CLIRegisterCommand(&xSetAIAlgoCommand);
 80210ee:	f104 0090 	add.w	r0, r4, #144	; 0x90
 80210f2:	f7fd fe09 	bl	801ed08 <FreeRTOS_CLIRegisterCommand>
    FreeRTOS_CLIRegisterCommand(&xGetAIAlgoCommand);
 80210f6:	f104 00a0 	add.w	r0, r4, #160	; 0xa0
 80210fa:	f7fd fe05 	bl	801ed08 <FreeRTOS_CLIRegisterCommand>
    FreeRTOS_CLIRegisterCommand(&xSdnameCommand);
 80210fe:	f104 00b0 	add.w	r0, r4, #176	; 0xb0
 8021102:	f7fd fe01 	bl	801ed08 <FreeRTOS_CLIRegisterCommand>
    FreeRTOS_CLIRegisterCommand(&xDatalogCommand);
 8021106:	f104 00c0 	add.w	r0, r4, #192	; 0xc0
 802110a:	f7fd fdfd 	bl	801ed08 <FreeRTOS_CLIRegisterCommand>
    FreeRTOS_CLIRegisterCommand(&xLSCommand);
 802110e:	f104 00d0 	add.w	r0, r4, #208	; 0xd0
 8021112:	f7fd fdf9 	bl	801ed08 <FreeRTOS_CLIRegisterCommand>
    FreeRTOS_CLIRegisterCommand(&xCATCommand);
 8021116:	f104 00e0 	add.w	r0, r4, #224	; 0xe0
 802111a:	f7fd fdf5 	bl	801ed08 <FreeRTOS_CLIRegisterCommand>
    FreeRTOS_CLIRegisterCommand(&xRMCommand);
 802111e:	f104 00f0 	add.w	r0, r4, #240	; 0xf0
 8021122:	f7fd fdf1 	bl	801ed08 <FreeRTOS_CLIRegisterCommand>
    FreeRTOS_CLIRegisterCommand(&xFORMATCommand);
 8021126:	f504 7080 	add.w	r0, r4, #256	; 0x100
 802112a:	f7fd fded 	bl	801ed08 <FreeRTOS_CLIRegisterCommand>
    FreeRTOS_CLIRegisterCommand(&xUsbCommand);
 802112e:	f504 7088 	add.w	r0, r4, #272	; 0x110
 8021132:	f7fd fde9 	bl	801ed08 <FreeRTOS_CLIRegisterCommand>
    FreeRTOS_CLIRegisterCommand(&xResetCommand);
 8021136:	f504 7090 	add.w	r0, r4, #288	; 0x120
}
 802113a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    FreeRTOS_CLIRegisterCommand(&xResetCommand);
 802113e:	f7fd bde3 	b.w	801ed08 <FreeRTOS_CLIRegisterCommand>
 8021142:	bf00      	nop
 8021144:	08039a00 	.word	0x08039a00

08021148 <uartReceiveChar>:
/** @brief Receives a character from serial port
 * @param None
 * @retval Character received
 */
int uartReceiveChar(void)
{
 8021148:	b500      	push	{lr}
 802114a:	b083      	sub	sp, #12
  uint8_t ch;
  HAL_UART_Receive(&UartHandle, &ch, 1, HAL_MAX_DELAY);
 802114c:	f04f 33ff 	mov.w	r3, #4294967295
 8021150:	2201      	movs	r2, #1
 8021152:	f10d 0106 	add.w	r1, sp, #6
 8021156:	4811      	ldr	r0, [pc, #68]	; (802119c <uartReceiveChar+0x54>)
 8021158:	f7f3 fed4 	bl	8014f04 <HAL_UART_Receive>

  /* Echo character back to console */
  HAL_UART_Transmit(&UartHandle, &ch, 1, HAL_MAX_DELAY);
 802115c:	480f      	ldr	r0, [pc, #60]	; (802119c <uartReceiveChar+0x54>)
 802115e:	f04f 33ff 	mov.w	r3, #4294967295
 8021162:	2201      	movs	r2, #1
 8021164:	f10d 0106 	add.w	r1, sp, #6
 8021168:	f7f3 fe62 	bl	8014e30 <HAL_UART_Transmit>

  /* And cope with Windows */
  if(ch == '\r'){
 802116c:	f89d 0006 	ldrb.w	r0, [sp, #6]
 8021170:	280d      	cmp	r0, #13
 8021172:	d002      	beq.n	802117a <uartReceiveChar+0x32>
    uint8_t ret = '\n';
    HAL_UART_Transmit(&UartHandle, &ret, 1, HAL_MAX_DELAY);
  }

  return ch;
}
 8021174:	b003      	add	sp, #12
 8021176:	f85d fb04 	ldr.w	pc, [sp], #4
    uint8_t ret = '\n';
 802117a:	f04f 0c0a 	mov.w	ip, #10
    HAL_UART_Transmit(&UartHandle, &ret, 1, HAL_MAX_DELAY);
 802117e:	f04f 33ff 	mov.w	r3, #4294967295
 8021182:	2201      	movs	r2, #1
 8021184:	f10d 0107 	add.w	r1, sp, #7
 8021188:	4804      	ldr	r0, [pc, #16]	; (802119c <uartReceiveChar+0x54>)
    uint8_t ret = '\n';
 802118a:	f88d c007 	strb.w	ip, [sp, #7]
    HAL_UART_Transmit(&UartHandle, &ret, 1, HAL_MAX_DELAY);
 802118e:	f7f3 fe4f 	bl	8014e30 <HAL_UART_Transmit>
  return ch;
 8021192:	f89d 0006 	ldrb.w	r0, [sp, #6]
}
 8021196:	b003      	add	sp, #12
 8021198:	f85d fb04 	ldr.w	pc, [sp], #4
 802119c:	20002214 	.word	0x20002214

080211a0 <HAL_UART_RxCpltCallback>:

void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart)
{
  if (semRxChar) {
 80211a0:	4b02      	ldr	r3, [pc, #8]	; (80211ac <HAL_UART_RxCpltCallback+0xc>)
 80211a2:	6818      	ldr	r0, [r3, #0]
 80211a4:	b108      	cbz	r0, 80211aa <HAL_UART_RxCpltCallback+0xa>
    osSemaphoreRelease(semRxChar);
 80211a6:	f7f7 bc5b 	b.w	8018a60 <osSemaphoreRelease>
  }
}
 80211aa:	4770      	bx	lr
 80211ac:	20012aa0 	.word	0x20012aa0

080211b0 <__io_putchar>:
/** @brief putchar call for standard output implementation
 * @param ch Character to print
 * @retval Character printed
 */
int __io_putchar(int ch)
{
 80211b0:	b510      	push	{r4, lr}
  if (semUart != NULL) {
 80211b2:	4c11      	ldr	r4, [pc, #68]	; (80211f8 <__io_putchar+0x48>)
{
 80211b4:	b082      	sub	sp, #8
  if (semUart != NULL) {
 80211b6:	6823      	ldr	r3, [r4, #0]
 80211b8:	9001      	str	r0, [sp, #4]
 80211ba:	b17b      	cbz	r3, 80211dc <__io_putchar+0x2c>
    if (osSemaphoreWait(semUart, osWaitForever) != osOK)
 80211bc:	f04f 31ff 	mov.w	r1, #4294967295
 80211c0:	4618      	mov	r0, r3
 80211c2:	f7f7 fc21 	bl	8018a08 <osSemaphoreWait>
 80211c6:	b100      	cbz	r0, 80211ca <__io_putchar+0x1a>
      while(1);
 80211c8:	e7fe      	b.n	80211c8 <__io_putchar+0x18>
    if (HAL_UART_Transmit(&UartHandle, (uint8_t *)&ch, 1, HAL_MAX_DELAY) != HAL_OK)
 80211ca:	480c      	ldr	r0, [pc, #48]	; (80211fc <__io_putchar+0x4c>)
 80211cc:	f04f 33ff 	mov.w	r3, #4294967295
 80211d0:	2201      	movs	r2, #1
 80211d2:	a901      	add	r1, sp, #4
 80211d4:	f7f3 fe2c 	bl	8014e30 <HAL_UART_Transmit>
 80211d8:	b150      	cbz	r0, 80211f0 <__io_putchar+0x40>
      while(1);
 80211da:	e7fe      	b.n	80211da <__io_putchar+0x2a>
    HAL_UART_Transmit(&UartHandle,(uint8_t *)&ch, 1, HAL_MAX_DELAY);
 80211dc:	4807      	ldr	r0, [pc, #28]	; (80211fc <__io_putchar+0x4c>)
 80211de:	f04f 33ff 	mov.w	r3, #4294967295
 80211e2:	2201      	movs	r2, #1
 80211e4:	a901      	add	r1, sp, #4
 80211e6:	f7f3 fe23 	bl	8014e30 <HAL_UART_Transmit>
  return uartSendChar(ch);
}
 80211ea:	9801      	ldr	r0, [sp, #4]
 80211ec:	b002      	add	sp, #8
 80211ee:	bd10      	pop	{r4, pc}
    osSemaphoreRelease(semUart);
 80211f0:	6820      	ldr	r0, [r4, #0]
 80211f2:	f7f7 fc35 	bl	8018a60 <osSemaphoreRelease>
 80211f6:	e7f8      	b.n	80211ea <__io_putchar+0x3a>
 80211f8:	20012aa4 	.word	0x20012aa4
 80211fc:	20002214 	.word	0x20002214

08021200 <__io_getchar>:
 * @param None
 * @retval Character acquired from standard input
 */
int __io_getchar(void)
{
  return uartReceiveChar();
 8021200:	f7ff bfa2 	b.w	8021148 <uartReceiveChar>

08021204 <HCI_TL_SPI_Init>:
  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(HCI_TL_SPI_CS_PORT, HCI_TL_SPI_CS_PIN, GPIO_PIN_SET);

#elif defined(USE_STM32L475E_IOT01)

  __HAL_RCC_GPIOA_CLK_ENABLE();
 8021204:	4b3a      	ldr	r3, [pc, #232]	; (80212f0 <HCI_TL_SPI_Init+0xec>)
{
 8021206:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  __HAL_RCC_GPIOA_CLK_ENABLE();
 802120a:	6cda      	ldr	r2, [r3, #76]	; 0x4c
  
  /*Configure EXTI Line */
  GPIO_InitStruct.Pin = HCI_TL_SPI_EXTI_PIN;
  GPIO_InitStruct.Mode = GPIO_MODE_IT_RISING;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  HAL_GPIO_Init(HCI_TL_SPI_EXTI_PORT, &GPIO_InitStruct);
 802120c:	4e39      	ldr	r6, [pc, #228]	; (80212f4 <HCI_TL_SPI_Init+0xf0>)
  /* Deselect Sub-GHz module (SPSGRF-xxx) */
  GPIO_InitStruct.Pin = GPIO_PIN_5;
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
  HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 802120e:	4f3a      	ldr	r7, [pc, #232]	; (80212f8 <HCI_TL_SPI_Init+0xf4>)
  __HAL_RCC_GPIOA_CLK_ENABLE();
 8021210:	f042 0201 	orr.w	r2, r2, #1
 8021214:	64da      	str	r2, [r3, #76]	; 0x4c
 8021216:	6cda      	ldr	r2, [r3, #76]	; 0x4c
{
 8021218:	b08a      	sub	sp, #40	; 0x28
  __HAL_RCC_GPIOA_CLK_ENABLE();
 802121a:	f002 0201 	and.w	r2, r2, #1
 802121e:	9200      	str	r2, [sp, #0]
 8021220:	9a00      	ldr	r2, [sp, #0]
  __HAL_RCC_GPIOB_CLK_ENABLE();
 8021222:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 8021224:	f042 0202 	orr.w	r2, r2, #2
 8021228:	64da      	str	r2, [r3, #76]	; 0x4c
 802122a:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 802122c:	f002 0202 	and.w	r2, r2, #2
 8021230:	9201      	str	r2, [sp, #4]
 8021232:	9a01      	ldr	r2, [sp, #4]
  __HAL_RCC_GPIOE_CLK_ENABLE();
 8021234:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 8021236:	f042 0210 	orr.w	r2, r2, #16
 802123a:	64da      	str	r2, [r3, #76]	; 0x4c
 802123c:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 802123e:	f002 0210 	and.w	r2, r2, #16
 8021242:	9202      	str	r2, [sp, #8]
 8021244:	9a02      	ldr	r2, [sp, #8]
  __HAL_RCC_GPIOD_CLK_ENABLE();
 8021246:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 8021248:	f042 0208 	orr.w	r2, r2, #8
 802124c:	64da      	str	r2, [r3, #76]	; 0x4c
 802124e:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 8021250:	f002 0208 	and.w	r2, r2, #8
 8021254:	9203      	str	r2, [sp, #12]
 8021256:	9a03      	ldr	r2, [sp, #12]
  __HAL_RCC_GPIOE_CLK_ENABLE();
 8021258:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 802125a:	f042 0210 	orr.w	r2, r2, #16
 802125e:	64da      	str	r2, [r3, #76]	; 0x4c
 8021260:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
  GPIO_InitStruct.Pin = HCI_TL_SPI_EXTI_PIN;
 8021262:	4a26      	ldr	r2, [pc, #152]	; (80212fc <HCI_TL_SPI_Init+0xf8>)
  __HAL_RCC_GPIOE_CLK_ENABLE();
 8021264:	f003 0310 	and.w	r3, r3, #16
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 8021268:	2400      	movs	r4, #0
  __HAL_RCC_GPIOE_CLK_ENABLE();
 802126a:	9304      	str	r3, [sp, #16]
  HAL_GPIO_Init(HCI_TL_SPI_EXTI_PORT, &GPIO_InitStruct);
 802126c:	a905      	add	r1, sp, #20
 802126e:	4630      	mov	r0, r6
  GPIO_InitStruct.Pin = HCI_TL_SPI_EXTI_PIN;
 8021270:	2340      	movs	r3, #64	; 0x40
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 8021272:	2501      	movs	r5, #1
  GPIO_InitStruct.Pin = HCI_TL_SPI_EXTI_PIN;
 8021274:	e9cd 3205 	strd	r3, r2, [sp, #20]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 8021278:	9407      	str	r4, [sp, #28]
  __HAL_RCC_GPIOE_CLK_ENABLE();
 802127a:	9b04      	ldr	r3, [sp, #16]
  HAL_GPIO_Init(HCI_TL_SPI_EXTI_PORT, &GPIO_InitStruct);
 802127c:	f7ef fade 	bl	801083c <HAL_GPIO_Init>
  HAL_GPIO_Init(HCI_TL_RST_PORT, &GPIO_InitStruct);
 8021280:	a905      	add	r1, sp, #20
  GPIO_InitStruct.Pin =  HCI_TL_RST_PIN ;
 8021282:	f44f 7380 	mov.w	r3, #256	; 0x100
  HAL_GPIO_Init(HCI_TL_RST_PORT, &GPIO_InitStruct);
 8021286:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 802128a:	e9cd 3505 	strd	r3, r5, [sp, #20]
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 802128e:	e9cd 4407 	strd	r4, r4, [sp, #28]
  HAL_GPIO_Init(HCI_TL_RST_PORT, &GPIO_InitStruct);
 8021292:	f7ef fad3 	bl	801083c <HAL_GPIO_Init>
  GPIO_InitStruct.Pin = HCI_TL_SPI_CS_PIN ;
 8021296:	f44f 5300 	mov.w	r3, #8192	; 0x2000
  HAL_GPIO_Init(HCI_TL_SPI_CS_PORT, &GPIO_InitStruct);
 802129a:	a905      	add	r1, sp, #20
 802129c:	4818      	ldr	r0, [pc, #96]	; (8021300 <HCI_TL_SPI_Init+0xfc>)
  GPIO_InitStruct.Pin = HCI_TL_SPI_CS_PIN ;
 802129e:	9305      	str	r3, [sp, #20]
  GPIO_InitStruct.Pin = GPIO_PIN_5;
 80212a0:	f04f 0820 	mov.w	r8, #32
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 80212a4:	e9cd 5406 	strd	r5, r4, [sp, #24]
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 80212a8:	9408      	str	r4, [sp, #32]
  HAL_GPIO_Init(HCI_TL_SPI_CS_PORT, &GPIO_InitStruct);
 80212aa:	f7ef fac7 	bl	801083c <HAL_GPIO_Init>
  HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 80212ae:	a905      	add	r1, sp, #20
 80212b0:	4638      	mov	r0, r7
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 80212b2:	e9cd 5406 	strd	r5, r4, [sp, #24]
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 80212b6:	9408      	str	r4, [sp, #32]
  GPIO_InitStruct.Pin = GPIO_PIN_5;
 80212b8:	f8cd 8014 	str.w	r8, [sp, #20]
  HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 80212bc:	f7ef fabe 	bl	801083c <HAL_GPIO_Init>
  HAL_GPIO_WritePin(GPIOB, GPIO_PIN_5, GPIO_PIN_SET);
 80212c0:	462a      	mov	r2, r5
 80212c2:	4641      	mov	r1, r8
 80212c4:	4638      	mov	r0, r7
 80212c6:	f7ef fc8b 	bl	8010be0 <HAL_GPIO_WritePin>
  /* Deselect WiFi module (ISM43362) */
  GPIO_InitStruct.Pin = GPIO_PIN_0;
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
  HAL_GPIO_Init(GPIOE, &GPIO_InitStruct);
 80212ca:	a905      	add	r1, sp, #20
 80212cc:	4630      	mov	r0, r6
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 80212ce:	e9cd 5505 	strd	r5, r5, [sp, #20]
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 80212d2:	e9cd 4407 	strd	r4, r4, [sp, #28]
  HAL_GPIO_Init(GPIOE, &GPIO_InitStruct);
 80212d6:	f7ef fab1 	bl	801083c <HAL_GPIO_Init>
  HAL_GPIO_WritePin(GPIOE, GPIO_PIN_0, GPIO_PIN_SET);
 80212da:	462a      	mov	r2, r5
 80212dc:	4629      	mov	r1, r5
 80212de:	4630      	mov	r0, r6
 80212e0:	f7ef fc7e 	bl	8010be0 <HAL_GPIO_WritePin>
#endif /* USE_STM32L475E_IOT01 */

  return BSP_SPI_Init();
 80212e4:	f003 fb06 	bl	80248f4 <BSP_SPI3_Init>
}
 80212e8:	b00a      	add	sp, #40	; 0x28
 80212ea:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 80212ee:	bf00      	nop
 80212f0:	40021000 	.word	0x40021000
 80212f4:	48001000 	.word	0x48001000
 80212f8:	48000400 	.word	0x48000400
 80212fc:	10110000 	.word	0x10110000
 8021300:	48000c00 	.word	0x48000c00

08021304 <HCI_TL_SPI_DeInit>:
 *
 * @param  None
 * @retval int32_t 0
 */
int32_t HCI_TL_SPI_DeInit(void)
{
 8021304:	b508      	push	{r3, lr}
  HAL_GPIO_DeInit(HCI_TL_SPI_EXTI_PORT, HCI_TL_SPI_EXTI_PIN); 
 8021306:	4808      	ldr	r0, [pc, #32]	; (8021328 <HCI_TL_SPI_DeInit+0x24>)
 8021308:	2140      	movs	r1, #64	; 0x40
 802130a:	f7ef fbbd 	bl	8010a88 <HAL_GPIO_DeInit>
  HAL_GPIO_DeInit(HCI_TL_SPI_CS_PORT, HCI_TL_SPI_CS_PIN); 
 802130e:	4807      	ldr	r0, [pc, #28]	; (802132c <HCI_TL_SPI_DeInit+0x28>)
 8021310:	f44f 5100 	mov.w	r1, #8192	; 0x2000
 8021314:	f7ef fbb8 	bl	8010a88 <HAL_GPIO_DeInit>
  HAL_GPIO_DeInit(HCI_TL_RST_PORT, HCI_TL_RST_PIN);   
 8021318:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
 802131c:	f44f 7180 	mov.w	r1, #256	; 0x100
 8021320:	f7ef fbb2 	bl	8010a88 <HAL_GPIO_DeInit>
  return 0;
}
 8021324:	2000      	movs	r0, #0
 8021326:	bd08      	pop	{r3, pc}
 8021328:	48001000 	.word	0x48001000
 802132c:	48000c00 	.word	0x48000c00

08021330 <HCI_TL_SPI_Reset>:
 *
 * @param  None
 * @retval int32_t 0
 */
int32_t HCI_TL_SPI_Reset(void)
{
 8021330:	b508      	push	{r3, lr}
#ifdef SENSING1_BlueNRG2
  // Deselect CS PIN for BlueNRG to avoid spurious commands
  HAL_GPIO_WritePin(HCI_TL_SPI_CS_PORT, HCI_TL_SPI_CS_PIN, GPIO_PIN_SET);
#endif /* SENSING1_BlueNRG2 */

  HAL_GPIO_WritePin(HCI_TL_RST_PORT, HCI_TL_RST_PIN, GPIO_PIN_RESET);
 8021332:	2200      	movs	r2, #0
 8021334:	f44f 7180 	mov.w	r1, #256	; 0x100
 8021338:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
 802133c:	f7ef fc50 	bl	8010be0 <HAL_GPIO_WritePin>
  HAL_Delay(5);
 8021340:	2005      	movs	r0, #5
 8021342:	f001 fb3b 	bl	80229bc <HAL_Delay>
  HAL_GPIO_WritePin(HCI_TL_RST_PORT, HCI_TL_RST_PIN, GPIO_PIN_SET);
 8021346:	2201      	movs	r2, #1
 8021348:	f44f 7180 	mov.w	r1, #256	; 0x100
 802134c:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
 8021350:	f7ef fc46 	bl	8010be0 <HAL_GPIO_WritePin>
  HAL_Delay(5);    
 8021354:	2005      	movs	r0, #5
 8021356:	f001 fb31 	bl	80229bc <HAL_Delay>
  return 0;
}  
 802135a:	2000      	movs	r0, #0
 802135c:	bd08      	pop	{r3, pc}
 802135e:	bf00      	nop

08021360 <HCI_TL_SPI_Receive>:
 * @param  buffer : Buffer where data from SPI are stored
 * @param  size   : Buffer size
 * @retval int32_t: Number of read bytes
 */
int32_t HCI_TL_SPI_Receive(uint8_t* buffer, uint16_t size)
{
 8021360:	b570      	push	{r4, r5, r6, lr}
  uint16_t byte_count;
  uint8_t len = 0;
  uint8_t char_ff = 0xff;
  volatile uint8_t read_char;

  uint8_t header_master[HEADER_SIZE] = {0x0b, 0x00, 0x00, 0x00, 0x00};
 8021362:	4b20      	ldr	r3, [pc, #128]	; (80213e4 <HCI_TL_SPI_Receive+0x84>)
{
 8021364:	4606      	mov	r6, r0
 8021366:	460d      	mov	r5, r1
  uint8_t header_master[HEADER_SIZE] = {0x0b, 0x00, 0x00, 0x00, 0x00};
 8021368:	e893 0003 	ldmia.w	r3, {r0, r1}
{
 802136c:	b086      	sub	sp, #24
  uint8_t char_ff = 0xff;
 802136e:	23ff      	movs	r3, #255	; 0xff
#ifdef SENSING1_BlueNRG2  
  HCI_TL_SPI_Disable_IRQ();
#endif /* SENSING1_BlueNRG2 */

  /* CS reset */
  HAL_GPIO_WritePin(HCI_TL_SPI_CS_PORT, HCI_TL_SPI_CS_PIN, GPIO_PIN_RESET);
 8021370:	2200      	movs	r2, #0
  uint8_t header_master[HEADER_SIZE] = {0x0b, 0x00, 0x00, 0x00, 0x00};
 8021372:	9002      	str	r0, [sp, #8]
 8021374:	f88d 100c 	strb.w	r1, [sp, #12]
  HAL_GPIO_WritePin(HCI_TL_SPI_CS_PORT, HCI_TL_SPI_CS_PIN, GPIO_PIN_RESET);
 8021378:	481b      	ldr	r0, [pc, #108]	; (80213e8 <HCI_TL_SPI_Receive+0x88>)
  uint8_t char_ff = 0xff;
 802137a:	f88d 3006 	strb.w	r3, [sp, #6]
  HAL_GPIO_WritePin(HCI_TL_SPI_CS_PORT, HCI_TL_SPI_CS_PIN, GPIO_PIN_RESET);
 802137e:	f44f 5100 	mov.w	r1, #8192	; 0x2000
 8021382:	f7ef fc2d 	bl	8010be0 <HAL_GPIO_WritePin>

  /* Read the header */  
  BSP_SPI_SendRecv(header_master, header_slave, HEADER_SIZE);
 8021386:	2205      	movs	r2, #5
 8021388:	a904      	add	r1, sp, #16
 802138a:	a802      	add	r0, sp, #8
 802138c:	f003 fb18 	bl	80249c0 <BSP_SPI3_SendRecv>

#ifndef SENSING1_BlueNRG2
  if(header_slave[0] == 0x02)
 8021390:	f89d 3010 	ldrb.w	r3, [sp, #16]
 8021394:	2b02      	cmp	r3, #2
 8021396:	d009      	beq.n	80213ac <HCI_TL_SPI_Receive+0x4c>
 8021398:	2400      	movs	r4, #0
        buffer[len] = read_char;
      }      
    }    
  }
  /* Release CS line */
  HAL_GPIO_WritePin(HCI_TL_SPI_CS_PORT, HCI_TL_SPI_CS_PIN, GPIO_PIN_SET);
 802139a:	4813      	ldr	r0, [pc, #76]	; (80213e8 <HCI_TL_SPI_Receive+0x88>)
 802139c:	2201      	movs	r2, #1
 802139e:	f44f 5100 	mov.w	r1, #8192	; 0x2000
 80213a2:	f7ef fc1d 	bl	8010be0 <HAL_GPIO_WritePin>
    PRINT_CSV("\n");
  }
#endif
  
  return len;  
}
 80213a6:	4620      	mov	r0, r4
 80213a8:	b006      	add	sp, #24
 80213aa:	bd70      	pop	{r4, r5, r6, pc}
    byte_count = (header_slave[4] << 8)| header_slave[3];
 80213ac:	f8bd 4013 	ldrh.w	r4, [sp, #19]
    if(byte_count > 0) {
 80213b0:	2c00      	cmp	r4, #0
 80213b2:	d0f2      	beq.n	802139a <HCI_TL_SPI_Receive+0x3a>
      if (byte_count > size){
 80213b4:	42ac      	cmp	r4, r5
 80213b6:	bf28      	it	cs
 80213b8:	462c      	movcs	r4, r5
      for(len = 0; len < byte_count; len++)
 80213ba:	2c00      	cmp	r4, #0
 80213bc:	d0ed      	beq.n	802139a <HCI_TL_SPI_Receive+0x3a>
 80213be:	2500      	movs	r5, #0
        BSP_SPI_SendRecv(&char_ff, (uint8_t*)&read_char, 1);  
 80213c0:	2201      	movs	r2, #1
 80213c2:	f10d 0107 	add.w	r1, sp, #7
 80213c6:	f10d 0006 	add.w	r0, sp, #6
 80213ca:	f003 faf9 	bl	80249c0 <BSP_SPI3_SendRecv>
      for(len = 0; len < byte_count; len++)
 80213ce:	1c6b      	adds	r3, r5, #1
 80213d0:	b2da      	uxtb	r2, r3
        buffer[len] = read_char;
 80213d2:	f89d 1007 	ldrb.w	r1, [sp, #7]
 80213d6:	5571      	strb	r1, [r6, r5]
      for(len = 0; len < byte_count; len++)
 80213d8:	4294      	cmp	r4, r2
 80213da:	4615      	mov	r5, r2
 80213dc:	d8f0      	bhi.n	80213c0 <HCI_TL_SPI_Receive+0x60>
  return len;  
 80213de:	4614      	mov	r4, r2
 80213e0:	e7db      	b.n	802139a <HCI_TL_SPI_Receive+0x3a>
 80213e2:	bf00      	nop
 80213e4:	08039b30 	.word	0x08039b30
 80213e8:	48000c00 	.word	0x48000c00

080213ec <HCI_TL_SPI_Send>:
 * @param  buffer : data buffer to be written
 * @param  size   : size of first data buffer to be written
 * @retval int32_t: Number of read bytes
 */
int32_t HCI_TL_SPI_Send(uint8_t* buffer, uint16_t size)
{
 80213ec:	b5f0      	push	{r4, r5, r6, r7, lr}
  uint16_t rx_bytes;
#endif /* SENSING1_BlueNRG2 */

  int32_t result;  
  
  uint8_t header_master[HEADER_SIZE] = {0x0a, 0x00, 0x00, 0x00, 0x00};
 80213ee:	4b22      	ldr	r3, [pc, #136]	; (8021478 <HCI_TL_SPI_Send+0x8c>)
#endif /* SENSING1_BlueNRG2 */
    
    result = 0;
    
    /* CS reset */
    HAL_GPIO_WritePin(HCI_TL_SPI_CS_PORT, HCI_TL_SPI_CS_PIN, GPIO_PIN_RESET);
 80213f0:	4c22      	ldr	r4, [pc, #136]	; (802147c <HCI_TL_SPI_Send+0x90>)
{
 80213f2:	4607      	mov	r7, r0
 80213f4:	460e      	mov	r6, r1
  uint8_t header_master[HEADER_SIZE] = {0x0a, 0x00, 0x00, 0x00, 0x00};
 80213f6:	e893 0003 	ldmia.w	r3, {r0, r1}
{
 80213fa:	b085      	sub	sp, #20
  uint8_t header_master[HEADER_SIZE] = {0x0a, 0x00, 0x00, 0x00, 0x00};
 80213fc:	9000      	str	r0, [sp, #0]
 80213fe:	f88d 1004 	strb.w	r1, [sp, #4]
  uint32_t tickstart = HAL_GetTick();
 8021402:	f7ee fa19 	bl	800f838 <HAL_GetTick>
 8021406:	4605      	mov	r5, r0
 8021408:	e006      	b.n	8021418 <HCI_TL_SPI_Send+0x2c>
      result = -1;
    }
#endif /* SENSING1_BlueNRG2 */
    
    /* Release CS line */
    HAL_GPIO_WritePin(HCI_TL_SPI_CS_PORT, HCI_TL_SPI_CS_PIN, GPIO_PIN_SET);
 802140a:	f7ef fbe9 	bl	8010be0 <HAL_GPIO_WritePin>
    
    if((HAL_GetTick() - tickstart) > TIMEOUT_DURATION)
 802140e:	f7ee fa13 	bl	800f838 <HAL_GetTick>
 8021412:	1b43      	subs	r3, r0, r5
 8021414:	2b0f      	cmp	r3, #15
 8021416:	d827      	bhi.n	8021468 <HCI_TL_SPI_Send+0x7c>
    HAL_GPIO_WritePin(HCI_TL_SPI_CS_PORT, HCI_TL_SPI_CS_PIN, GPIO_PIN_RESET);
 8021418:	2200      	movs	r2, #0
 802141a:	f44f 5100 	mov.w	r1, #8192	; 0x2000
 802141e:	4620      	mov	r0, r4
 8021420:	f7ef fbde 	bl	8010be0 <HAL_GPIO_WritePin>
    BSP_SPI_SendRecv(header_master, header_slave, HEADER_SIZE);
 8021424:	2205      	movs	r2, #5
 8021426:	a902      	add	r1, sp, #8
 8021428:	4668      	mov	r0, sp
 802142a:	f003 fac9 	bl	80249c0 <BSP_SPI3_SendRecv>
    if(header_slave[0] == 0x02) 
 802142e:	f89d 3008 	ldrb.w	r3, [sp, #8]
 8021432:	2b02      	cmp	r3, #2
    HAL_GPIO_WritePin(HCI_TL_SPI_CS_PORT, HCI_TL_SPI_CS_PIN, GPIO_PIN_SET);
 8021434:	f04f 0201 	mov.w	r2, #1
 8021438:	f44f 5100 	mov.w	r1, #8192	; 0x2000
 802143c:	4620      	mov	r0, r4
    if(header_slave[0] == 0x02) 
 802143e:	d1e4      	bne.n	802140a <HCI_TL_SPI_Send+0x1e>
      if(header_slave[1] >= size) 
 8021440:	f89d 3009 	ldrb.w	r3, [sp, #9]
 8021444:	42b3      	cmp	r3, r6
 8021446:	d3e0      	bcc.n	802140a <HCI_TL_SPI_Send+0x1e>
        BSP_SPI_SendRecv(buffer, read_char_buf, size);
 8021448:	490d      	ldr	r1, [pc, #52]	; (8021480 <HCI_TL_SPI_Send+0x94>)
 802144a:	4632      	mov	r2, r6
 802144c:	4638      	mov	r0, r7
 802144e:	f003 fab7 	bl	80249c0 <BSP_SPI3_SendRecv>
    HAL_GPIO_WritePin(HCI_TL_SPI_CS_PORT, HCI_TL_SPI_CS_PIN, GPIO_PIN_SET);
 8021452:	480a      	ldr	r0, [pc, #40]	; (802147c <HCI_TL_SPI_Send+0x90>)
 8021454:	2201      	movs	r2, #1
 8021456:	f44f 5100 	mov.w	r1, #8192	; 0x2000
 802145a:	f7ef fbc1 	bl	8010be0 <HAL_GPIO_WritePin>
    if((HAL_GetTick() - tickstart) > TIMEOUT_DURATION)
 802145e:	f7ee f9eb 	bl	800f838 <HAL_GetTick>
 8021462:	1b40      	subs	r0, r0, r5
 8021464:	280f      	cmp	r0, #15
 8021466:	d903      	bls.n	8021470 <HCI_TL_SPI_Send+0x84>
    {
      result = -3;
 8021468:	f06f 0002 	mvn.w	r0, #2
#ifdef SENSING1_BlueNRG2
  HCI_TL_SPI_Enable_IRQ();
#endif /* SENSING1_BlueNRG2 */
  
  return result;
}
 802146c:	b005      	add	sp, #20
 802146e:	bdf0      	pop	{r4, r5, r6, r7, pc}
    if((HAL_GetTick() - tickstart) > TIMEOUT_DURATION)
 8021470:	2000      	movs	r0, #0
}
 8021472:	b005      	add	sp, #20
 8021474:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8021476:	bf00      	nop
 8021478:	08039b38 	.word	0x08039b38
 802147c:	48000c00 	.word	0x48000c00
 8021480:	20012974 	.word	0x20012974

08021484 <hci_tl_lowlevel_init>:
 *
 * @param  None
 * @retval None
 */ 
void hci_tl_lowlevel_init(void)
{
 8021484:	b510      	push	{r4, lr}
  /* USER CODE END hci_tl_lowlevel_init 1 */
#ifdef HCI_TL
  tHciIO fops;  
  
  /* Register IO bus services */
  fops.Init    = HCI_TL_SPI_Init;
 8021486:	4a0d      	ldr	r2, [pc, #52]	; (80214bc <hci_tl_lowlevel_init+0x38>)
  fops.DeInit  = HCI_TL_SPI_DeInit;
 8021488:	4b0d      	ldr	r3, [pc, #52]	; (80214c0 <hci_tl_lowlevel_init+0x3c>)
  fops.Send    = HCI_TL_SPI_Send;
  fops.Receive = HCI_TL_SPI_Receive;
 802148a:	490e      	ldr	r1, [pc, #56]	; (80214c4 <hci_tl_lowlevel_init+0x40>)
  fops.Send    = HCI_TL_SPI_Send;
 802148c:	4c0e      	ldr	r4, [pc, #56]	; (80214c8 <hci_tl_lowlevel_init+0x44>)
{
 802148e:	b088      	sub	sp, #32
  fops.DeInit  = HCI_TL_SPI_DeInit;
 8021490:	e9cd 2301 	strd	r2, r3, [sp, #4]
  fops.Reset   = HCI_TL_SPI_Reset;
  fops.GetTick = BSP_GetTick;
  
  hci_register_io_bus (&fops);
 8021494:	a801      	add	r0, sp, #4
  fops.GetTick = BSP_GetTick;
 8021496:	4b0d      	ldr	r3, [pc, #52]	; (80214cc <hci_tl_lowlevel_init+0x48>)
  fops.Reset   = HCI_TL_SPI_Reset;
 8021498:	4a0d      	ldr	r2, [pc, #52]	; (80214d0 <hci_tl_lowlevel_init+0x4c>)
  fops.GetTick = BSP_GetTick;
 802149a:	9307      	str	r3, [sp, #28]
  fops.Receive = HCI_TL_SPI_Receive;
 802149c:	e9cd 1404 	strd	r1, r4, [sp, #16]
  fops.Reset   = HCI_TL_SPI_Reset;
 80214a0:	9203      	str	r2, [sp, #12]
  hci_register_io_bus (&fops);
 80214a2:	f7fa fb25 	bl	801baf0 <hci_register_io_bus>
    HAL_NVIC_SetPriority(EXTI0_IRQn, 5, 0);
    HAL_NVIC_EnableIRQ(EXTI0_IRQn);

  #elif defined(USE_STM32L475E_IOT01)

    HAL_NVIC_SetPriority(EXTI9_5_IRQn, 5, 0);
 80214a6:	2200      	movs	r2, #0
 80214a8:	2105      	movs	r1, #5
 80214aa:	2017      	movs	r0, #23
 80214ac:	f7ee f9e8 	bl	800f880 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(EXTI9_5_IRQn);
 80214b0:	2017      	movs	r0, #23
 80214b2:	f7ee fa23 	bl	800f8fc <HAL_NVIC_EnableIRQ>

  /* USER CODE BEGIN hci_tl_lowlevel_init 3 */
  
  /* USER CODE END hci_tl_lowlevel_init 3 */

}
 80214b6:	b008      	add	sp, #32
 80214b8:	bd10      	pop	{r4, pc}
 80214ba:	bf00      	nop
 80214bc:	08021205 	.word	0x08021205
 80214c0:	08021305 	.word	0x08021305
 80214c4:	08021361 	.word	0x08021361
 80214c8:	080213ed 	.word	0x080213ed
 80214cc:	0800c4a9 	.word	0x0800c4a9
 80214d0:	08021331 	.word	0x08021331

080214d4 <hci_tl_lowlevel_isr>:
  *
  * @param  None
  * @retval None
  */
void hci_tl_lowlevel_isr(void)
{
 80214d4:	b510      	push	{r4, lr}
  return (HAL_GPIO_ReadPin(HCI_TL_SPI_EXTI_PORT, HCI_TL_SPI_EXTI_PIN) == GPIO_PIN_SET);
 80214d6:	4c07      	ldr	r4, [pc, #28]	; (80214f4 <hci_tl_lowlevel_isr+0x20>)
  /* Call hci_notify_asynch_evt() */
#ifdef HCI_TL
  while(IsDataAvailable())
 80214d8:	e002      	b.n	80214e0 <hci_tl_lowlevel_isr+0xc>
  {
#ifdef SENSING1_BlueNRG2
    hci_notify_asynch_evt(NULL);
#else /* SENSING1_BlueNRG2 */
    if (hci_notify_asynch_evt(NULL))
 80214da:	f7fa fc17 	bl	801bd0c <hci_notify_asynch_evt>
 80214de:	b940      	cbnz	r0, 80214f2 <hci_tl_lowlevel_isr+0x1e>
  return (HAL_GPIO_ReadPin(HCI_TL_SPI_EXTI_PORT, HCI_TL_SPI_EXTI_PIN) == GPIO_PIN_SET);
 80214e0:	2140      	movs	r1, #64	; 0x40
 80214e2:	4620      	mov	r0, r4
 80214e4:	f7ef fb76 	bl	8010bd4 <HAL_GPIO_ReadPin>
 80214e8:	4603      	mov	r3, r0
  while(IsDataAvailable())
 80214ea:	2b01      	cmp	r3, #1
    if (hci_notify_asynch_evt(NULL))
 80214ec:	f04f 0000 	mov.w	r0, #0
  while(IsDataAvailable())
 80214f0:	d0f3      	beq.n	80214da <hci_tl_lowlevel_isr+0x6>
#endif /* HCI_TL */

  /* USER CODE BEGIN hci_tl_lowlevel_isr */

  /* USER CODE END hci_tl_lowlevel_isr */ 
}
 80214f2:	bd10      	pop	{r4, pc}
 80214f4:	48001000 	.word	0x48001000

080214f8 <startProcessing>:
#endif /* STM32_SENSORTILEBOX */
  return 0;
}

static void startProcessing  (void const *arg)
{
 80214f8:	b510      	push	{r4, lr}
  if(arg == timEnvId){
 80214fa:	4c18      	ldr	r4, [pc, #96]	; (802155c <startProcessing+0x64>)
 80214fc:	6823      	ldr	r3, [r4, #0]
 80214fe:	4283      	cmp	r3, r0
 8021500:	d01c      	beq.n	802153c <startProcessing+0x44>
      SendBatteryInfo= 1;
    }
  }
#endif /* SENSING1_USE_BATTERY */

  else if (arg == timMotionId){
 8021502:	68a3      	ldr	r3, [r4, #8]
 8021504:	4283      	cmp	r3, r0
 8021506:	4601      	mov	r1, r0
 8021508:	d00f      	beq.n	802152a <startProcessing+0x32>
    SendAccGyroMag=1;
  }
  else if (arg == timAudioLevId){
 802150a:	6923      	ldr	r3, [r4, #16]
 802150c:	4283      	cmp	r3, r0
 802150e:	d01f      	beq.n	8021550 <startProcessing+0x58>
    SendAudioLevel=1;
  }
  else if (arg == timActivityId){
 8021510:	69a3      	ldr	r3, [r4, #24]
 8021512:	4283      	cmp	r3, r0
 8021514:	d01f      	beq.n	8021556 <startProcessing+0x5e>
    UpdateMotionAR=1;
  }
#if SENSING1_USE_DATALOG
  else if(arg == timSdCardLoggingId){
 8021516:	6a23      	ldr	r3, [r4, #32]
 8021518:	4283      	cmp	r3, r0
 802151a:	d016      	beq.n	802154a <startProcessing+0x52>
    SD_CardLogging= 1;
  }
#endif /* SENSING1_USE_DATALOG */
  else{
    SENSING1_PRINTF("wrong timer : %ld\n",(uint32_t)arg);
 802151c:	4b10      	ldr	r3, [pc, #64]	; (8021560 <startProcessing+0x68>)
 802151e:	781b      	ldrb	r3, [r3, #0]
 8021520:	b12b      	cbz	r3, 802152e <startProcessing+0x36>
 8021522:	4810      	ldr	r0, [pc, #64]	; (8021564 <startProcessing+0x6c>)
 8021524:	f006 fd7a 	bl	802801c <iprintf>
 8021528:	e001      	b.n	802152e <startProcessing+0x36>
    SendAccGyroMag=1;
 802152a:	2301      	movs	r3, #1
 802152c:	60e3      	str	r3, [r4, #12]
  }
  if(semRun) {
 802152e:	6aa0      	ldr	r0, [r4, #40]	; 0x28
 8021530:	b118      	cbz	r0, 802153a <startProcessing+0x42>
    osSemaphoreRelease(semRun);
  }
}
 8021532:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    osSemaphoreRelease(semRun);
 8021536:	f7f7 ba93 	b.w	8018a60 <osSemaphoreRelease>
}
 802153a:	bd10      	pop	{r4, pc}
    if(W2ST_CHECK_CONNECTION(W2ST_CONNECT_ENV)) {
 802153c:	4b0a      	ldr	r3, [pc, #40]	; (8021568 <startProcessing+0x70>)
 802153e:	681b      	ldr	r3, [r3, #0]
 8021540:	07db      	lsls	r3, r3, #31
 8021542:	d5f4      	bpl.n	802152e <startProcessing+0x36>
      SendEnv=1;
 8021544:	2301      	movs	r3, #1
 8021546:	6063      	str	r3, [r4, #4]
 8021548:	e7f1      	b.n	802152e <startProcessing+0x36>
    SD_CardLogging= 1;
 802154a:	2301      	movs	r3, #1
 802154c:	6263      	str	r3, [r4, #36]	; 0x24
 802154e:	e7ee      	b.n	802152e <startProcessing+0x36>
    SendAudioLevel=1;
 8021550:	2301      	movs	r3, #1
 8021552:	6163      	str	r3, [r4, #20]
 8021554:	e7eb      	b.n	802152e <startProcessing+0x36>
    UpdateMotionAR=1;
 8021556:	2301      	movs	r3, #1
 8021558:	61e3      	str	r3, [r4, #28]
 802155a:	e7e8      	b.n	802152e <startProcessing+0x36>
 802155c:	20012a74 	.word	0x20012a74
 8021560:	20000d84 	.word	0x20000d84
 8021564:	0804358c 	.word	0x0804358c
 8021568:	2001457c 	.word	0x2001457c

0802156c <UARTConsoleThread>:
{
 802156c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    HAL_NVIC_SetPriority(USART1_IRQn, 0x0FU, 0x00);
 8021570:	210f      	movs	r1, #15
 8021572:	2200      	movs	r2, #0
 8021574:	2025      	movs	r0, #37	; 0x25
 8021576:	f7ee f983 	bl	800f880 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(USART1_IRQn);
 802157a:	2025      	movs	r0, #37	; 0x25
 802157c:	f7ee f9be 	bl	800f8fc <HAL_NVIC_EnableIRQ>
    SENSING1_PRINTF_FLUSH();
 8021580:	4d72      	ldr	r5, [pc, #456]	; (802174c <UARTConsoleThread+0x1e0>)
    _SENSING1_PRINTF(pcWelcomeMessage);
 8021582:	4873      	ldr	r0, [pc, #460]	; (8021750 <UARTConsoleThread+0x1e4>)
    if (osSemaphoreWait(semRxChar, osWaitForever) != osOK)
 8021584:	4c73      	ldr	r4, [pc, #460]	; (8021754 <UARTConsoleThread+0x1e8>)
    _SENSING1_PRINTF(pcWelcomeMessage);
 8021586:	f006 fde5 	bl	8028154 <puts>
    _SENSING1_PRINTF(pcPromptMessage);
 802158a:	4873      	ldr	r0, [pc, #460]	; (8021758 <UARTConsoleThread+0x1ec>)
 802158c:	f006 fd46 	bl	802801c <iprintf>
    SENSING1_PRINTF_FLUSH();
 8021590:	682b      	ldr	r3, [r5, #0]
 8021592:	6898      	ldr	r0, [r3, #8]
 8021594:	f005 fe78 	bl	8027288 <fflush>
    if (osSemaphoreWait(semRxChar, osWaitForever) != osOK)
 8021598:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
 802159a:	f04f 31ff 	mov.w	r1, #4294967295
 802159e:	f7f7 fa33 	bl	8018a08 <osSemaphoreWait>
 80215a2:	b100      	cbz	r0, 80215a6 <UARTConsoleThread+0x3a>
        while(1);
 80215a4:	e7fe      	b.n	80215a4 <UARTConsoleThread+0x38>
    if (osSemaphoreWait(semUart, osWaitForever) != osOK)
 80215a6:	6b20      	ldr	r0, [r4, #48]	; 0x30
 80215a8:	f04f 31ff 	mov.w	r1, #4294967295
 80215ac:	f7f7 fa2c 	bl	8018a08 <osSemaphoreWait>
 80215b0:	b100      	cbz	r0, 80215b4 <UARTConsoleThread+0x48>
        while(1);
 80215b2:	e7fe      	b.n	80215b2 <UARTConsoleThread+0x46>
    if (HAL_UART_Receive_IT(&UartHandle, &cRxedChar, 1) != HAL_OK)
 80215b4:	4869      	ldr	r0, [pc, #420]	; (802175c <UARTConsoleThread+0x1f0>)
 80215b6:	2201      	movs	r2, #1
 80215b8:	f104 0134 	add.w	r1, r4, #52	; 0x34
 80215bc:	f7f3 f806 	bl	80145cc <HAL_UART_Receive_IT>
 80215c0:	4607      	mov	r7, r0
 80215c2:	b100      	cbz	r0, 80215c6 <UARTConsoleThread+0x5a>
        while(1);
 80215c4:	e7fe      	b.n	80215c4 <UARTConsoleThread+0x58>
    osSemaphoreRelease(semUart);
 80215c6:	6b20      	ldr	r0, [r4, #48]	; 0x30
 80215c8:	f8df 81bc 	ldr.w	r8, [pc, #444]	; 8021788 <UARTConsoleThread+0x21c>
              _SENSING1_PRINTF(pcPromptMessage);
 80215cc:	f8df 9188 	ldr.w	r9, [pc, #392]	; 8021758 <UARTConsoleThread+0x1ec>
                SENSING1_PRINTF("\n\r<esc> key is pressed");
 80215d0:	f8df a1b8 	ldr.w	sl, [pc, #440]	; 802178c <UARTConsoleThread+0x220>
    osSemaphoreRelease(semUart);
 80215d4:	f7f7 fa44 	bl	8018a60 <osSemaphoreRelease>
        if (osSemaphoreWait(semRxChar, osWaitForever) == osOK)
 80215d8:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
 80215da:	f04f 31ff 	mov.w	r1, #4294967295
 80215de:	f7f7 fa13 	bl	8018a08 <osSemaphoreWait>
 80215e2:	2800      	cmp	r0, #0
 80215e4:	d1f8      	bne.n	80215d8 <UARTConsoleThread+0x6c>
            if (cRxedChar == ESC)
 80215e6:	f894 0034 	ldrb.w	r0, [r4, #52]	; 0x34
 80215ea:	281b      	cmp	r0, #27
 80215ec:	d13b      	bne.n	8021666 <UARTConsoleThread+0xfa>
              if (Sensing1PrintfEnabled)
 80215ee:	f898 3000 	ldrb.w	r3, [r8]
 80215f2:	2b00      	cmp	r3, #0
 80215f4:	d05d      	beq.n	80216b2 <UARTConsoleThread+0x146>
                SENSING1_PRINTF("\n\r<esc> key is pressed");
 80215f6:	4650      	mov	r0, sl
 80215f8:	f006 fd10 	bl	802801c <iprintf>
                SENSING1_PRINTF("\n\rInhibiting Console Out mode is entered");
 80215fc:	f898 3000 	ldrb.w	r3, [r8]
 8021600:	2b00      	cmp	r3, #0
 8021602:	d17e      	bne.n	8021702 <UARTConsoleThread+0x196>
                Sensing1PrintfEnabled = !Sensing1PrintfEnabled;
 8021604:	f898 3000 	ldrb.w	r3, [r8]
 8021608:	fab3 f383 	clz	r3, r3
 802160c:	095b      	lsrs	r3, r3, #5
 802160e:	f888 3000 	strb.w	r3, [r8]
              _SENSING1_PRINTF(pcPromptMessage);
 8021612:	4648      	mov	r0, r9
 8021614:	f006 fd02 	bl	802801c <iprintf>
            SENSING1_PRINTF_FLUSH();
 8021618:	682b      	ldr	r3, [r5, #0]
 802161a:	6898      	ldr	r0, [r3, #8]
 802161c:	f005 fe34 	bl	8027288 <fflush>
            if (osSemaphoreWait(semUart, osWaitForever) != osOK)
 8021620:	6b20      	ldr	r0, [r4, #48]	; 0x30
 8021622:	f04f 31ff 	mov.w	r1, #4294967295
 8021626:	f7f7 f9ef 	bl	8018a08 <osSemaphoreWait>
 802162a:	b9d0      	cbnz	r0, 8021662 <UARTConsoleThread+0xf6>
            if (HAL_UART_Receive_IT(&UartHandle, &cRxedChar, 1) != HAL_OK)
 802162c:	494c      	ldr	r1, [pc, #304]	; (8021760 <UARTConsoleThread+0x1f4>)
 802162e:	484b      	ldr	r0, [pc, #300]	; (802175c <UARTConsoleThread+0x1f0>)
 8021630:	2201      	movs	r2, #1
 8021632:	f7f2 ffcb 	bl	80145cc <HAL_UART_Receive_IT>
 8021636:	4606      	mov	r6, r0
 8021638:	b9a0      	cbnz	r0, 8021664 <UARTConsoleThread+0xf8>
            osSemaphoreRelease(semUart);
 802163a:	6b20      	ldr	r0, [r4, #48]	; 0x30
 802163c:	f7f7 fa10 	bl	8018a60 <osSemaphoreRelease>
            if (cRxedChar == '\r' )
 8021640:	f894 3034 	ldrb.w	r3, [r4, #52]	; 0x34
 8021644:	2b0d      	cmp	r3, #13
 8021646:	d011      	beq.n	802166c <UARTConsoleThread+0x100>
                if (cRxedChar == '\b')
 8021648:	2b08      	cmp	r3, #8
 802164a:	d047      	beq.n	80216dc <UARTConsoleThread+0x170>
                else if ((cRxedChar != ESC) && (cRxedChar != '\0'))
 802164c:	2b1b      	cmp	r3, #27
 802164e:	d0c3      	beq.n	80215d8 <UARTConsoleThread+0x6c>
 8021650:	2b00      	cmp	r3, #0
 8021652:	d0c1      	beq.n	80215d8 <UARTConsoleThread+0x6c>
                    if (cInputIndex < MAX_INPUT_LENGTH)
 8021654:	2f31      	cmp	r7, #49	; 0x31
 8021656:	d8bf      	bhi.n	80215d8 <UARTConsoleThread+0x6c>
                        pcInputString[ cInputIndex ] = cRxedChar;
 8021658:	19e2      	adds	r2, r4, r7
                        cInputIndex++;
 802165a:	3701      	adds	r7, #1
                        pcInputString[ cInputIndex ] = cRxedChar;
 802165c:	f882 3038 	strb.w	r3, [r2, #56]	; 0x38
                        cInputIndex++;
 8021660:	e7ba      	b.n	80215d8 <UARTConsoleThread+0x6c>
                while(1);
 8021662:	e7fe      	b.n	8021662 <UARTConsoleThread+0xf6>
                while(1);
 8021664:	e7fe      	b.n	8021664 <UARTConsoleThread+0xf8>
              _SENSING1_PRINTF("%c", cRxedChar);
 8021666:	f006 fcf1 	bl	802804c <putchar>
 802166a:	e7d5      	b.n	8021618 <UARTConsoleThread+0xac>
                SENSING1_PRINTF("\n");
 802166c:	f898 3000 	ldrb.w	r3, [r8]
 8021670:	2b00      	cmp	r3, #0
 8021672:	d13e      	bne.n	80216f2 <UARTConsoleThread+0x186>
                  Sensing1PrintfEnabled = !Sensing1PrintfEnabled;
 8021674:	2301      	movs	r3, #1
                  SENSING1_PRINTF("\n\r<esc> key is pressed");
 8021676:	4650      	mov	r0, sl
                  Sensing1PrintfEnabled = !Sensing1PrintfEnabled;
 8021678:	f888 3000 	strb.w	r3, [r8]
                  SENSING1_PRINTF("\n\r<esc> key is pressed");
 802167c:	f006 fcce 	bl	802801c <iprintf>
                  SENSING1_PRINTF("\n\rInhibiting Console Out mode is auto-exited");
 8021680:	f898 3000 	ldrb.w	r3, [r8]
 8021684:	2b00      	cmp	r3, #0
 8021686:	d15d      	bne.n	8021744 <UARTConsoleThread+0x1d8>
                  _SENSING1_PRINTF(pcPromptMessage);
 8021688:	4648      	mov	r0, r9
 802168a:	f006 fcc7 	bl	802801c <iprintf>
                if (strlen(pcInputString) != 0)
 802168e:	f894 3038 	ldrb.w	r3, [r4, #56]	; 0x38
 8021692:	2b00      	cmp	r3, #0
 8021694:	d149      	bne.n	802172a <UARTConsoleThread+0x1be>
                memset(pcInputString, 0x00, MAX_INPUT_LENGTH);
 8021696:	2232      	movs	r2, #50	; 0x32
 8021698:	2100      	movs	r1, #0
 802169a:	4832      	ldr	r0, [pc, #200]	; (8021764 <UARTConsoleThread+0x1f8>)
 802169c:	f005 ff6c 	bl	8027578 <memset>
                _SENSING1_PRINTF(pcPromptMessage);
 80216a0:	4648      	mov	r0, r9
 80216a2:	f006 fcbb 	bl	802801c <iprintf>
                SENSING1_PRINTF_FLUSH();
 80216a6:	682b      	ldr	r3, [r5, #0]
 80216a8:	6898      	ldr	r0, [r3, #8]
 80216aa:	f005 fded 	bl	8027288 <fflush>
                cInputIndex = 0;
 80216ae:	2700      	movs	r7, #0
 80216b0:	e792      	b.n	80215d8 <UARTConsoleThread+0x6c>
                Sensing1PrintfEnabled = !Sensing1PrintfEnabled;
 80216b2:	2301      	movs	r3, #1
                SENSING1_PRINTF("\n\r<esc> key is pressed");
 80216b4:	4650      	mov	r0, sl
                Sensing1PrintfEnabled = !Sensing1PrintfEnabled;
 80216b6:	f888 3000 	strb.w	r3, [r8]
                SENSING1_PRINTF("\n\r<esc> key is pressed");
 80216ba:	f006 fcaf 	bl	802801c <iprintf>
                SENSING1_PRINTF("\n\rInhibiting Console Out mode is exited");
 80216be:	f898 3000 	ldrb.w	r3, [r8]
 80216c2:	2b00      	cmp	r3, #0
 80216c4:	d0a5      	beq.n	8021612 <UARTConsoleThread+0xa6>
 80216c6:	4828      	ldr	r0, [pc, #160]	; (8021768 <UARTConsoleThread+0x1fc>)
 80216c8:	f006 fca8 	bl	802801c <iprintf>
                SENSING1_PRINTF("\n\rhit <esc> key to enter this mode again\n\r");
 80216cc:	f898 3000 	ldrb.w	r3, [r8]
 80216d0:	2b00      	cmp	r3, #0
 80216d2:	d09e      	beq.n	8021612 <UARTConsoleThread+0xa6>
 80216d4:	4825      	ldr	r0, [pc, #148]	; (802176c <UARTConsoleThread+0x200>)
 80216d6:	f006 fca1 	bl	802801c <iprintf>
 80216da:	e79a      	b.n	8021612 <UARTConsoleThread+0xa6>
                    if (cInputIndex > 0 )
 80216dc:	2f00      	cmp	r7, #0
 80216de:	f43f af7b 	beq.w	80215d8 <UARTConsoleThread+0x6c>
                        cInputIndex--;
 80216e2:	3f01      	subs	r7, #1
                        pcInputString[ cInputIndex ] = '\0';
 80216e4:	19e3      	adds	r3, r4, r7
                        _SENSING1_PRINTF(" \b");
 80216e6:	4822      	ldr	r0, [pc, #136]	; (8021770 <UARTConsoleThread+0x204>)
                        pcInputString[ cInputIndex ] = '\0';
 80216e8:	f883 6038 	strb.w	r6, [r3, #56]	; 0x38
                        _SENSING1_PRINTF(" \b");
 80216ec:	f006 fc96 	bl	802801c <iprintf>
 80216f0:	e772      	b.n	80215d8 <UARTConsoleThread+0x6c>
                SENSING1_PRINTF("\n");
 80216f2:	200a      	movs	r0, #10
 80216f4:	f006 fcaa 	bl	802804c <putchar>
                if (!Sensing1PrintfEnabled)
 80216f8:	f898 3000 	ldrb.w	r3, [r8]
 80216fc:	2b00      	cmp	r3, #0
 80216fe:	d1c6      	bne.n	802168e <UARTConsoleThread+0x122>
 8021700:	e7b8      	b.n	8021674 <UARTConsoleThread+0x108>
                SENSING1_PRINTF("\n\rInhibiting Console Out mode is entered");
 8021702:	481c      	ldr	r0, [pc, #112]	; (8021774 <UARTConsoleThread+0x208>)
 8021704:	f006 fc8a 	bl	802801c <iprintf>
                SENSING1_PRINTF("\n\rmode will auto-exit after next command");
 8021708:	f898 3000 	ldrb.w	r3, [r8]
 802170c:	2b00      	cmp	r3, #0
 802170e:	f43f af79 	beq.w	8021604 <UARTConsoleThread+0x98>
 8021712:	4819      	ldr	r0, [pc, #100]	; (8021778 <UARTConsoleThread+0x20c>)
 8021714:	f006 fc82 	bl	802801c <iprintf>
                SENSING1_PRINTF("\n\ror hit <esc> key again to exit manually\n\r");
 8021718:	f898 3000 	ldrb.w	r3, [r8]
 802171c:	2b00      	cmp	r3, #0
 802171e:	f43f af71 	beq.w	8021604 <UARTConsoleThread+0x98>
 8021722:	4816      	ldr	r0, [pc, #88]	; (802177c <UARTConsoleThread+0x210>)
 8021724:	f006 fc7a 	bl	802801c <iprintf>
 8021728:	e76c      	b.n	8021604 <UARTConsoleThread+0x98>
                        xMoreDataToFollow = FreeRTOS_CLIProcessCommand(
 802172a:	4f15      	ldr	r7, [pc, #84]	; (8021780 <UARTConsoleThread+0x214>)
 802172c:	480d      	ldr	r0, [pc, #52]	; (8021764 <UARTConsoleThread+0x1f8>)
 802172e:	22c8      	movs	r2, #200	; 0xc8
 8021730:	4639      	mov	r1, r7
 8021732:	f7fd fb13 	bl	801ed5c <FreeRTOS_CLIProcessCommand>
 8021736:	4606      	mov	r6, r0
                        _SENSING1_PRINTF(pcOutputString);
 8021738:	4638      	mov	r0, r7
 802173a:	f006 fc6f 	bl	802801c <iprintf>
                    } while (xMoreDataToFollow != 0);
 802173e:	2e00      	cmp	r6, #0
 8021740:	d1f4      	bne.n	802172c <UARTConsoleThread+0x1c0>
 8021742:	e7a8      	b.n	8021696 <UARTConsoleThread+0x12a>
                  SENSING1_PRINTF("\n\rInhibiting Console Out mode is auto-exited");
 8021744:	480f      	ldr	r0, [pc, #60]	; (8021784 <UARTConsoleThread+0x218>)
 8021746:	f006 fc69 	bl	802801c <iprintf>
 802174a:	e79d      	b.n	8021688 <UARTConsoleThread+0x11c>
 802174c:	20002020 	.word	0x20002020
 8021750:	080435a0 	.word	0x080435a0
 8021754:	20012a74 	.word	0x20012a74
 8021758:	080435f0 	.word	0x080435f0
 802175c:	20002214 	.word	0x20002214
 8021760:	20012aa8 	.word	0x20012aa8
 8021764:	20012aac 	.word	0x20012aac
 8021768:	08043694 	.word	0x08043694
 802176c:	080436bc 	.word	0x080436bc
 8021770:	08043718 	.word	0x08043718
 8021774:	08043610 	.word	0x08043610
 8021778:	0804363c 	.word	0x0804363c
 802177c:	08043668 	.word	0x08043668
 8021780:	20012ae0 	.word	0x20012ae0
 8021784:	080436e8 	.word	0x080436e8
 8021788:	20000d84 	.word	0x20000d84
 802178c:	080435f8 	.word	0x080435f8

08021790 <AudioProcess.part.0>:
/**
* @brief  Function that is called when data has been appended to Fill Buffer
* @param  none
* @retval None
*/
static void AudioProcess(void)
 8021790:	b510      	push	{r4, lr}
 8021792:	4b17      	ldr	r3, [pc, #92]	; (80217f0 <AudioProcess.part.0+0x60>)
 8021794:	4a17      	ldr	r2, [pc, #92]	; (80217f4 <AudioProcess.part.0+0x64>)
  if (index_buff_fill == FILL_BUFFER_SIZE) {
    /* Copy Fill Buffer in Proc Buffer */
    for (uint32_t i = 0; i < FILL_BUFFER_SIZE; i++) {
      sample = ((float32_t) Fill_Buffer[i]);
      /* Invert the scale of the data */
      sample /= (float32_t) ((1 << (8 * sizeof(int16_t) - 1)));
 8021796:	ed9f 7a18 	vldr	s14, [pc, #96]	; 80217f8 <AudioProcess.part.0+0x68>
 802179a:	f503 6100 	add.w	r1, r3, #2048	; 0x800
      sample = ((float32_t) Fill_Buffer[i]);
 802179e:	f933 0f02 	ldrsh.w	r0, [r3, #2]!
 80217a2:	ee07 0a90 	vmov	s15, r0
 80217a6:	eef8 7ae7 	vcvt.f32.s32	s15, s15
    for (uint32_t i = 0; i < FILL_BUFFER_SIZE; i++) {
 80217aa:	428b      	cmp	r3, r1
      sample /= (float32_t) ((1 << (8 * sizeof(int16_t) - 1)));
 80217ac:	ee67 7a87 	vmul.f32	s15, s15, s14
      Proc_Buffer_f[i] = sample;
 80217b0:	ece2 7a01 	vstmia	r2!, {s15}
    for (uint32_t i = 0; i < FILL_BUFFER_SIZE; i++) {
 80217b4:	d1f3      	bne.n	802179e <AudioProcess.part.0+0xe>
    }

    /* Left shift Fill Buffer by 512 samples */
    memmove(Fill_Buffer, Fill_Buffer + (FILL_BUFFER_SIZE / 2), sizeof(int16_t) * (FILL_BUFFER_SIZE / 2));
 80217b6:	4c11      	ldr	r4, [pc, #68]	; (80217fc <AudioProcess.part.0+0x6c>)
 80217b8:	f44f 6280 	mov.w	r2, #1024	; 0x400
 80217bc:	f204 5134 	addw	r1, r4, #1332	; 0x534
 80217c0:	f504 709a 	add.w	r0, r4, #308	; 0x134
 80217c4:	f005 feb0 	bl	8027528 <memcpy>
    index_buff_fill = (FILL_BUFFER_SIZE / 2);

    if(W2ST_CHECK_CONNECTION(W2ST_CONNECT_ASC_EVENT)) {
 80217c8:	4b0d      	ldr	r3, [pc, #52]	; (8021800 <AudioProcess.part.0+0x70>)
      /* Release processing thread to start Audio Feature Extraction */
      RunASCEvent = 1;
    }

    if (semRun) {
 80217ca:	6aa0      	ldr	r0, [r4, #40]	; 0x28
    if(W2ST_CHECK_CONNECTION(W2ST_CONNECT_ASC_EVENT)) {
 80217cc:	681b      	ldr	r3, [r3, #0]
 80217ce:	051b      	lsls	r3, r3, #20
    index_buff_fill = (FILL_BUFFER_SIZE / 2);
 80217d0:	f44f 7200 	mov.w	r2, #512	; 0x200
      RunASCEvent = 1;
 80217d4:	bf48      	it	mi
 80217d6:	2301      	movmi	r3, #1
    index_buff_fill = (FILL_BUFFER_SIZE / 2);
 80217d8:	f8c4 2934 	str.w	r2, [r4, #2356]	; 0x934
      RunASCEvent = 1;
 80217dc:	bf48      	it	mi
 80217de:	f8c4 3938 	strmi.w	r3, [r4, #2360]	; 0x938
    if (semRun) {
 80217e2:	b118      	cbz	r0, 80217ec <AudioProcess.part.0+0x5c>
      osSemaphoreRelease(semRun);
    }
  }
}
 80217e4:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
      osSemaphoreRelease(semRun);
 80217e8:	f7f7 b93a 	b.w	8018a60 <osSemaphoreRelease>
}
 80217ec:	bd10      	pop	{r4, pc}
 80217ee:	bf00      	nop
 80217f0:	20012ba6 	.word	0x20012ba6
 80217f4:	20013538 	.word	0x20013538
 80217f8:	38000000 	.word	0x38000000
 80217fc:	20012a74 	.word	0x20012a74
 8021800:	2001457c 	.word	0x2001457c

08021804 <LedBlinkCb>:
  ledTimer = (uint32_t)NULL;
  }
}

static void LedBlinkCb  (void const *arg)
{
 8021804:	b510      	push	{r4, lr}
  if (ledTimer == LED_TIME_ON){
 8021806:	4c11      	ldr	r4, [pc, #68]	; (802184c <LedBlinkCb+0x48>)
 8021808:	f8d4 393c 	ldr.w	r3, [r4, #2364]	; 0x93c
 802180c:	2b64      	cmp	r3, #100	; 0x64
 802180e:	d010      	beq.n	8021832 <LedBlinkCb+0x2e>
    ledTimer = LED_TIME_OFF;
    LedOffTargetPlatform();
  } else {
    ledTimer = LED_TIME_ON;
 8021810:	2364      	movs	r3, #100	; 0x64
 8021812:	f8c4 393c 	str.w	r3, [r4, #2364]	; 0x93c
    LedOnTargetPlatform();
 8021816:	f7fd ffb5 	bl	801f784 <LedOnTargetPlatform>
  }
  if (timLedId){
 802181a:	f8d4 0940 	ldr.w	r0, [r4, #2368]	; 0x940
 802181e:	b138      	cbz	r0, 8021830 <LedBlinkCb+0x2c>
    if  (osTimerStart (timLedId, ledTimer) != osOK){
 8021820:	f8d4 193c 	ldr.w	r1, [r4, #2364]	; 0x93c
 8021824:	f7f7 f86a 	bl	80188fc <osTimerStart>
 8021828:	b110      	cbz	r0, 8021830 <LedBlinkCb+0x2c>
      SENSING1_PRINTF("failed starting timer\n\r");
 802182a:	4b09      	ldr	r3, [pc, #36]	; (8021850 <LedBlinkCb+0x4c>)
 802182c:	781b      	ldrb	r3, [r3, #0]
 802182e:	b93b      	cbnz	r3, 8021840 <LedBlinkCb+0x3c>
    }
  }
}
 8021830:	bd10      	pop	{r4, pc}
    ledTimer = LED_TIME_OFF;
 8021832:	f44f 63fa 	mov.w	r3, #2000	; 0x7d0
 8021836:	f8c4 393c 	str.w	r3, [r4, #2364]	; 0x93c
    LedOffTargetPlatform();
 802183a:	f7fd ffa7 	bl	801f78c <LedOffTargetPlatform>
 802183e:	e7ec      	b.n	802181a <LedBlinkCb+0x16>
}
 8021840:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
      SENSING1_PRINTF("failed starting timer\n\r");
 8021844:	4803      	ldr	r0, [pc, #12]	; (8021854 <LedBlinkCb+0x50>)
 8021846:	f006 bbe9 	b.w	802801c <iprintf>
 802184a:	bf00      	nop
 802184c:	20012a74 	.word	0x20012a74
 8021850:	20000d84 	.word	0x20000d84
 8021854:	0804371c 	.word	0x0804371c

08021858 <SendMsgToHost>:
{
 8021858:	b570      	push	{r4, r5, r6, lr}
  if (mail) {
 802185a:	4e1b      	ldr	r6, [pc, #108]	; (80218c8 <SendMsgToHost+0x70>)
 802185c:	f8d6 3944 	ldr.w	r3, [r6, #2372]	; 0x944
 8021860:	b32b      	cbz	r3, 80218ae <SendMsgToHost+0x56>
    ptr = osMailAlloc(mail, osWaitForever);
 8021862:	4604      	mov	r4, r0
 8021864:	f04f 31ff 	mov.w	r1, #4294967295
 8021868:	4618      	mov	r0, r3
 802186a:	f7f7 f9cd 	bl	8018c08 <osMailAlloc>
    if (ptr) {
 802186e:	4605      	mov	r5, r0
 8021870:	b1f8      	cbz	r0, 80218b2 <SendMsgToHost+0x5a>
      BLUENRG_memcpy(ptr,msgPtr, sizeof(msgData_t));
 8021872:	4623      	mov	r3, r4
 8021874:	4602      	mov	r2, r0
 8021876:	f104 0e20 	add.w	lr, r4, #32
 802187a:	681c      	ldr	r4, [r3, #0]
 802187c:	6858      	ldr	r0, [r3, #4]
 802187e:	6899      	ldr	r1, [r3, #8]
 8021880:	f8d3 c00c 	ldr.w	ip, [r3, #12]
 8021884:	f8c2 c00c 	str.w	ip, [r2, #12]
 8021888:	3310      	adds	r3, #16
 802188a:	4573      	cmp	r3, lr
 802188c:	6014      	str	r4, [r2, #0]
 802188e:	6050      	str	r0, [r2, #4]
 8021890:	6091      	str	r1, [r2, #8]
 8021892:	f102 0210 	add.w	r2, r2, #16
 8021896:	d1f0      	bne.n	802187a <SendMsgToHost+0x22>
 8021898:	6819      	ldr	r1, [r3, #0]
 802189a:	685b      	ldr	r3, [r3, #4]
 802189c:	6053      	str	r3, [r2, #4]
 802189e:	6011      	str	r1, [r2, #0]
      osMailPut(mail, ptr);
 80218a0:	f8d6 0944 	ldr.w	r0, [r6, #2372]	; 0x944
 80218a4:	4629      	mov	r1, r5
 80218a6:	f7f7 f9b5 	bl	8018c14 <osMailPut>
  return 1;
 80218aa:	2001      	movs	r0, #1
}
 80218ac:	bd70      	pop	{r4, r5, r6, pc}
  return 1;
 80218ae:	2001      	movs	r0, #1
}
 80218b0:	bd70      	pop	{r4, r5, r6, pc}
      SENSING1_PRINTF("SendMsgToHost: mem allocation failed %d\r\n",msgPtr->type);
 80218b2:	4b06      	ldr	r3, [pc, #24]	; (80218cc <SendMsgToHost+0x74>)
 80218b4:	7818      	ldrb	r0, [r3, #0]
 80218b6:	2800      	cmp	r0, #0
 80218b8:	d0f8      	beq.n	80218ac <SendMsgToHost+0x54>
 80218ba:	7821      	ldrb	r1, [r4, #0]
 80218bc:	4804      	ldr	r0, [pc, #16]	; (80218d0 <SendMsgToHost+0x78>)
 80218be:	f006 fbad 	bl	802801c <iprintf>
 80218c2:	4628      	mov	r0, r5
}
 80218c4:	bd70      	pop	{r4, r5, r6, pc}
 80218c6:	bf00      	nop
 80218c8:	20012a74 	.word	0x20012a74
 80218cc:	20000d84 	.word	0x20000d84
 80218d0:	08043734 	.word	0x08043734

080218d4 <startProc>:
{
 80218d4:	b5f0      	push	{r4, r5, r6, r7, lr}
 80218d6:	b095      	sub	sp, #84	; 0x54
  msg.type         = SET_HOST_LINK_TYPE;
 80218d8:	2412      	movs	r4, #18
  msg.HostLinkType = DEFAULT_HOST_LINK;
 80218da:	2201      	movs	r2, #1
  switch (type)
 80218dc:	1f43      	subs	r3, r0, #5
{
 80218de:	460e      	mov	r6, r1
  msg.type         = SET_HOST_LINK_TYPE;
 80218e0:	f88d 4000 	strb.w	r4, [sp]
  msg.HostLinkType = DEFAULT_HOST_LINK;
 80218e4:	f88d 2004 	strb.w	r2, [sp, #4]
  switch (type)
 80218e8:	2b0c      	cmp	r3, #12
 80218ea:	d80e      	bhi.n	802190a <startProc+0x36>
 80218ec:	e8df f013 	tbh	[pc, r3, lsl #1]
 80218f0:	00370018 	.word	0x00370018
 80218f4:	00700056 	.word	0x00700056
 80218f8:	00d600a8 	.word	0x00d600a8
 80218fc:	014e0104 	.word	0x014e0104
 8021900:	000d000d 	.word	0x000d000d
 8021904:	000d000d 	.word	0x000d000d
 8021908:	015d      	.short	0x015d
      SENSING1_PRINTF("wrong type : %d\n",type);
 802190a:	4bbc      	ldr	r3, [pc, #752]	; (8021bfc <startProc+0x328>)
 802190c:	781b      	ldrb	r3, [r3, #0]
 802190e:	2b00      	cmp	r3, #0
 8021910:	f040 815b 	bne.w	8021bca <startProc+0x2f6>
  SendMsgToHost(&msg);
 8021914:	4668      	mov	r0, sp
 8021916:	f7ff ff9f 	bl	8021858 <SendMsgToHost>
}
 802191a:	2000      	movs	r0, #0
 802191c:	b015      	add	sp, #84	; 0x54
 802191e:	bdf0      	pop	{r4, r5, r6, r7, pc}
      if (!timEnvId) {
 8021920:	4cb7      	ldr	r4, [pc, #732]	; (8021c00 <startProc+0x32c>)
 8021922:	6822      	ldr	r2, [r4, #0]
 8021924:	2a00      	cmp	r2, #0
 8021926:	f000 8155 	beq.w	8021bd4 <startProc+0x300>
      if(!TargetBoardFeatures.EnvSensorEnabled) {
 802192a:	4bb6      	ldr	r3, [pc, #728]	; (8021c04 <startProc+0x330>)
 802192c:	f893 303c 	ldrb.w	r3, [r3, #60]	; 0x3c
 8021930:	2b00      	cmp	r3, #0
 8021932:	f000 8147 	beq.w	8021bc4 <startProc+0x2f0>
      msg.HostLinkType  = ENV_HOST_LINK;
 8021936:	2302      	movs	r3, #2
      id = timEnvId;
 8021938:	6825      	ldr	r5, [r4, #0]
      msg.HostLinkType  = ENV_HOST_LINK;
 802193a:	f88d 3004 	strb.w	r3, [sp, #4]
  if (id){
 802193e:	2d00      	cmp	r5, #0
 8021940:	d0e8      	beq.n	8021914 <startProc+0x40>
    if  (osTimerStart (id, period) != osOK){
 8021942:	4631      	mov	r1, r6
 8021944:	4628      	mov	r0, r5
 8021946:	f7f6 ffd9 	bl	80188fc <osTimerStart>
 802194a:	2800      	cmp	r0, #0
 802194c:	d0e2      	beq.n	8021914 <startProc+0x40>
      SENSING1_PRINTF("failed starting timer\n");
 802194e:	4bab      	ldr	r3, [pc, #684]	; (8021bfc <startProc+0x328>)
 8021950:	781b      	ldrb	r3, [r3, #0]
 8021952:	2b00      	cmp	r3, #0
 8021954:	d0de      	beq.n	8021914 <startProc+0x40>
 8021956:	48ac      	ldr	r0, [pc, #688]	; (8021c08 <startProc+0x334>)
 8021958:	f006 fbfc 	bl	8028154 <puts>
 802195c:	e7da      	b.n	8021914 <startProc+0x40>
      if (!timMotionId) {
 802195e:	4ca8      	ldr	r4, [pc, #672]	; (8021c00 <startProc+0x32c>)
 8021960:	68a2      	ldr	r2, [r4, #8]
 8021962:	2a00      	cmp	r2, #0
 8021964:	f000 8144 	beq.w	8021bf0 <startProc+0x31c>
  MOTION_SENSOR_SetFullScale( TargetBoardFeatures.HandleAccSensor,MOTION_ACCELERO,2);
 8021968:	4fa6      	ldr	r7, [pc, #664]	; (8021c04 <startProc+0x330>)
      EnableMotionSensors ();
 802196a:	f7fd fc95 	bl	801f298 <EnableMotionSensors>
  MOTION_SENSOR_SetFullScale( TargetBoardFeatures.HandleAccSensor,MOTION_ACCELERO,2);
 802196e:	2202      	movs	r2, #2
 8021970:	4611      	mov	r1, r2
 8021972:	69b8      	ldr	r0, [r7, #24]
 8021974:	f7eb f8da 	bl	800cb2c <BSP_MOTION_SENSOR_SetFullScale>
  MOTION_SENSOR_GetSensitivity(TargetBoardFeatures.HandleAccSensor,MOTION_ACCELERO,&sensitivity);
 8021978:	69b8      	ldr	r0, [r7, #24]
 802197a:	aa0a      	add	r2, sp, #40	; 0x28
 802197c:	2102      	movs	r1, #2
 802197e:	f7eb f835 	bl	800c9ec <BSP_MOTION_SENSOR_GetSensitivity>
  TargetBoardFeatures.AccSensiMultInG = sensitivity * FROM_MG_TO_G ;
 8021982:	eddd 7a0a 	vldr	s15, [sp, #40]	; 0x28
 8021986:	ed9f 7aa1 	vldr	s14, [pc, #644]	; 8021c0c <startProc+0x338>
      id = timMotionId;
 802198a:	68a5      	ldr	r5, [r4, #8]
  TargetBoardFeatures.AccSensiMultInG = sensitivity * FROM_MG_TO_G ;
 802198c:	ee67 7a87 	vmul.f32	s15, s15, s14
      msg.HostLinkType  = MOTION_HOST_LINK;
 8021990:	2304      	movs	r3, #4
  TargetBoardFeatures.AccSensiMultInG = sensitivity * FROM_MG_TO_G ;
 8021992:	edc7 7a0c 	vstr	s15, [r7, #48]	; 0x30
      msg.HostLinkType  = MOTION_HOST_LINK;
 8021996:	f88d 3004 	strb.w	r3, [sp, #4]
      break;
 802199a:	e7d0      	b.n	802193e <startProc+0x6a>
      ascResultStored = ASC_UNDEFINED;
 802199c:	4c97      	ldr	r4, [pc, #604]	; (8021bfc <startProc+0x328>)
 802199e:	23ff      	movs	r3, #255	; 0xff
 80219a0:	7063      	strb	r3, [r4, #1]
      PowerCtrlLock();
 80219a2:	f7fd fc31 	bl	801f208 <PowerCtrlLock>
      InitMics(AUDIO_SAMPLING_FREQUENCY);
 80219a6:	f44f 507a 	mov.w	r0, #16000	; 0x3e80
 80219aa:	f7fd fd99 	bl	801f4e0 <InitMics>
      ASC_Init();
 80219ae:	f7fb fef9 	bl	801d7a4 <ASC_Init>
      msgAcq.audio_scene = ascResultStored;
 80219b2:	7863      	ldrb	r3, [r4, #1]
 80219b4:	f88d 302c 	strb.w	r3, [sp, #44]	; 0x2c
      msgAcq.type        = AUDIO_SC;
 80219b8:	2207      	movs	r2, #7
      SendMsgToHost(&msgAcq);
 80219ba:	a80a      	add	r0, sp, #40	; 0x28
      msgAcq.type        = AUDIO_SC;
 80219bc:	f88d 2028 	strb.w	r2, [sp, #40]	; 0x28
      SendMsgToHost(&msgAcq);
 80219c0:	f7ff ff4a 	bl	8021858 <SendMsgToHost>
  SendMsgToHost(&msg);
 80219c4:	4668      	mov	r0, sp
 80219c6:	f7ff ff47 	bl	8021858 <SendMsgToHost>
}
 80219ca:	2000      	movs	r0, #0
 80219cc:	b015      	add	sp, #84	; 0x54
 80219ce:	bdf0      	pop	{r4, r5, r6, r7, pc}
     if (HarAlgo == HAR_ALGO_IDX_NONE )
 80219d0:	4d8a      	ldr	r5, [pc, #552]	; (8021bfc <startProc+0x328>)
      if (!timActivityId) {
 80219d2:	4c8b      	ldr	r4, [pc, #556]	; (8021c00 <startProc+0x32c>)
     if (HarAlgo == HAR_ALGO_IDX_NONE )
 80219d4:	79ab      	ldrb	r3, [r5, #6]
      if (!timActivityId) {
 80219d6:	69a2      	ldr	r2, [r4, #24]
     if (HarAlgo == HAR_ALGO_IDX_NONE )
 80219d8:	2bff      	cmp	r3, #255	; 0xff
          HarAlgo = HAR_GMP_IDX;
 80219da:	bf04      	itt	eq
 80219dc:	2300      	moveq	r3, #0
 80219de:	71ab      	strbeq	r3, [r5, #6]
      if (!timActivityId) {
 80219e0:	2a00      	cmp	r2, #0
 80219e2:	f000 8131 	beq.w	8021c48 <startProc+0x374>
      MOTION_SENSOR_Enable(TargetBoardFeatures.HandleAccSensor, MOTION_ACCELERO);
 80219e6:	4f87      	ldr	r7, [pc, #540]	; (8021c04 <startProc+0x330>)
 80219e8:	2102      	movs	r1, #2
 80219ea:	69b8      	ldr	r0, [r7, #24]
 80219ec:	f7ea ff2a 	bl	800c844 <BSP_MOTION_SENSOR_Enable>
  MOTION_SENSOR_SetFullScale( TargetBoardFeatures.HandleAccSensor,MOTION_ACCELERO,4);
 80219f0:	2204      	movs	r2, #4
 80219f2:	2102      	movs	r1, #2
 80219f4:	69b8      	ldr	r0, [r7, #24]
 80219f6:	f7eb f899 	bl	800cb2c <BSP_MOTION_SENSOR_SetFullScale>
  MOTION_SENSOR_GetSensitivity(TargetBoardFeatures.HandleAccSensor,MOTION_ACCELERO,&sensitivity);
 80219fa:	aa0a      	add	r2, sp, #40	; 0x28
 80219fc:	2102      	movs	r1, #2
 80219fe:	69b8      	ldr	r0, [r7, #24]
 8021a00:	f7ea fff4 	bl	800c9ec <BSP_MOTION_SENSOR_GetSensitivity>
  TargetBoardFeatures.AccSensiMultInG = sensitivity * FROM_MG_TO_G;
 8021a04:	ed9f 7a81 	vldr	s14, [pc, #516]	; 8021c0c <startProc+0x338>
 8021a08:	eddd 7a0a 	vldr	s15, [sp, #40]	; 0x28
      MOTION_SENSOR_SetOutputDataRate(TargetBoardFeatures.HandleAccSensor, MOTION_ACCELERO,INERTIAL_ACQ_ACTIVITY_GMP_HZ);
 8021a0c:	69b8      	ldr	r0, [r7, #24]
  TargetBoardFeatures.AccSensiMultInG = sensitivity * FROM_MG_TO_G;
 8021a0e:	ee67 7a87 	vmul.f32	s15, s15, s14
      MOTION_SENSOR_SetOutputDataRate(TargetBoardFeatures.HandleAccSensor, MOTION_ACCELERO,INERTIAL_ACQ_ACTIVITY_GMP_HZ);
 8021a12:	eeb3 0a0a 	vmov.f32	s0, #58	; 0x41d00000  26.0
 8021a16:	2102      	movs	r1, #2
  TargetBoardFeatures.AccSensiMultInG = sensitivity * FROM_MG_TO_G;
 8021a18:	edc7 7a0c 	vstr	s15, [r7, #48]	; 0x30
      MOTION_SENSOR_SetOutputDataRate(TargetBoardFeatures.HandleAccSensor, MOTION_ACCELERO,INERTIAL_ACQ_ACTIVITY_GMP_HZ);
 8021a1c:	f7eb f852 	bl	800cac4 <BSP_MOTION_SENSOR_SetOutputDataRate>
      HAR_Initialize(HarAlgo);
 8021a20:	79a8      	ldrb	r0, [r5, #6]
 8021a22:	f003 ff7d 	bl	8025920 <HAR_Initialize>
      ActivityCodeStored = HAR_NOACTIVITY;
 8021a26:	2300      	movs	r3, #0
      msgAcq.type        = ACTIVITY_GMP;
 8021a28:	2208      	movs	r2, #8
      SendMsgToHost(&msgAcq);
 8021a2a:	a80a      	add	r0, sp, #40	; 0x28
      ActivityCodeStored = HAR_NOACTIVITY;
 8021a2c:	f884 394c 	strb.w	r3, [r4, #2380]	; 0x94c
      msgAcq.type        = ACTIVITY_IGN_WSDM;
 8021a30:	f88d 2028 	strb.w	r2, [sp, #40]	; 0x28
      msgAcq.activity    = ActivityCodeStored;
 8021a34:	f88d 302c 	strb.w	r3, [sp, #44]	; 0x2c
      SendMsgToHost(&msgAcq);
 8021a38:	f7ff ff0e 	bl	8021858 <SendMsgToHost>
      id = timActivityId;
 8021a3c:	69a5      	ldr	r5, [r4, #24]
      break;
 8021a3e:	e77e      	b.n	802193e <startProc+0x6a>
      if (HarAlgo == HAR_ALGO_IDX_NONE )
 8021a40:	4d6e      	ldr	r5, [pc, #440]	; (8021bfc <startProc+0x328>)
      if (!timActivityId) {
 8021a42:	4c6f      	ldr	r4, [pc, #444]	; (8021c00 <startProc+0x32c>)
      if (HarAlgo == HAR_ALGO_IDX_NONE )
 8021a44:	79ab      	ldrb	r3, [r5, #6]
      if (!timActivityId) {
 8021a46:	69a2      	ldr	r2, [r4, #24]
      if (HarAlgo == HAR_ALGO_IDX_NONE )
 8021a48:	2bff      	cmp	r3, #255	; 0xff
          HarAlgo = HAR_IGN_IDX;
 8021a4a:	bf04      	itt	eq
 8021a4c:	2301      	moveq	r3, #1
 8021a4e:	71ab      	strbeq	r3, [r5, #6]
      if (!timActivityId) {
 8021a50:	2a00      	cmp	r2, #0
 8021a52:	f000 80f3 	beq.w	8021c3c <startProc+0x368>
      MOTION_SENSOR_Enable(TargetBoardFeatures.HandleAccSensor, MOTION_ACCELERO);
 8021a56:	4f6b      	ldr	r7, [pc, #428]	; (8021c04 <startProc+0x330>)
 8021a58:	2102      	movs	r1, #2
 8021a5a:	69b8      	ldr	r0, [r7, #24]
 8021a5c:	f7ea fef2 	bl	800c844 <BSP_MOTION_SENSOR_Enable>
  MOTION_SENSOR_SetFullScale( TargetBoardFeatures.HandleAccSensor,MOTION_ACCELERO,4);
 8021a60:	2204      	movs	r2, #4
 8021a62:	2102      	movs	r1, #2
 8021a64:	69b8      	ldr	r0, [r7, #24]
 8021a66:	f7eb f861 	bl	800cb2c <BSP_MOTION_SENSOR_SetFullScale>
  MOTION_SENSOR_GetSensitivity(TargetBoardFeatures.HandleAccSensor,MOTION_ACCELERO,&sensitivity);
 8021a6a:	aa0a      	add	r2, sp, #40	; 0x28
 8021a6c:	2102      	movs	r1, #2
 8021a6e:	69b8      	ldr	r0, [r7, #24]
 8021a70:	f7ea ffbc 	bl	800c9ec <BSP_MOTION_SENSOR_GetSensitivity>
  TargetBoardFeatures.AccSensiMultInG = sensitivity * FROM_MG_TO_G;
 8021a74:	ed9f 7a65 	vldr	s14, [pc, #404]	; 8021c0c <startProc+0x338>
 8021a78:	eddd 7a0a 	vldr	s15, [sp, #40]	; 0x28
      MOTION_SENSOR_SetOutputDataRate(TargetBoardFeatures.HandleAccSensor, MOTION_ACCELERO,INERTIAL_ACQ_ACTIVITY_IGN_HZ);
 8021a7c:	69b8      	ldr	r0, [r7, #24]
  TargetBoardFeatures.AccSensiMultInG = sensitivity * FROM_MG_TO_G;
 8021a7e:	ee67 7a87 	vmul.f32	s15, s15, s14
      MOTION_SENSOR_SetOutputDataRate(TargetBoardFeatures.HandleAccSensor, MOTION_ACCELERO,INERTIAL_ACQ_ACTIVITY_IGN_HZ);
 8021a82:	eeb3 0a0a 	vmov.f32	s0, #58	; 0x41d00000  26.0
 8021a86:	2102      	movs	r1, #2
  TargetBoardFeatures.AccSensiMultInG = sensitivity * FROM_MG_TO_G;
 8021a88:	edc7 7a0c 	vstr	s15, [r7, #48]	; 0x30
      MOTION_SENSOR_SetOutputDataRate(TargetBoardFeatures.HandleAccSensor, MOTION_ACCELERO,INERTIAL_ACQ_ACTIVITY_IGN_HZ);
 8021a8c:	f7eb f81a 	bl	800cac4 <BSP_MOTION_SENSOR_SetOutputDataRate>
      HAR_Initialize(HarAlgo);
 8021a90:	79a8      	ldrb	r0, [r5, #6]
 8021a92:	f003 ff45 	bl	8025920 <HAR_Initialize>
      ActivityCodeStored = HAR_NOACTIVITY;
 8021a96:	2300      	movs	r3, #0
      msgAcq.type        = ACTIVITY_IGN;
 8021a98:	2209      	movs	r2, #9
 8021a9a:	e7c6      	b.n	8021a2a <startProc+0x156>
      if (HarAlgo == HAR_ALGO_IDX_NONE )
 8021a9c:	4d57      	ldr	r5, [pc, #348]	; (8021bfc <startProc+0x328>)
      if (!timActivityId) {
 8021a9e:	4c58      	ldr	r4, [pc, #352]	; (8021c00 <startProc+0x32c>)
      if (HarAlgo == HAR_ALGO_IDX_NONE )
 8021aa0:	79ab      	ldrb	r3, [r5, #6]
      if (!timActivityId) {
 8021aa2:	69a2      	ldr	r2, [r4, #24]
      if (HarAlgo == HAR_ALGO_IDX_NONE )
 8021aa4:	2bff      	cmp	r3, #255	; 0xff
          HarAlgo = HAR_IGN_WSDM_IDX;
 8021aa6:	bf04      	itt	eq
 8021aa8:	2302      	moveq	r3, #2
 8021aaa:	71ab      	strbeq	r3, [r5, #6]
      if (!timActivityId) {
 8021aac:	2a00      	cmp	r2, #0
 8021aae:	f000 80bf 	beq.w	8021c30 <startProc+0x35c>
      MOTION_SENSOR_Enable(TargetBoardFeatures.HandleAccSensor, MOTION_ACCELERO);
 8021ab2:	4f54      	ldr	r7, [pc, #336]	; (8021c04 <startProc+0x330>)
 8021ab4:	2102      	movs	r1, #2
 8021ab6:	69b8      	ldr	r0, [r7, #24]
 8021ab8:	f7ea fec4 	bl	800c844 <BSP_MOTION_SENSOR_Enable>
  MOTION_SENSOR_SetFullScale( TargetBoardFeatures.HandleAccSensor,MOTION_ACCELERO,2);
 8021abc:	2202      	movs	r2, #2
 8021abe:	4611      	mov	r1, r2
 8021ac0:	69b8      	ldr	r0, [r7, #24]
 8021ac2:	f7eb f833 	bl	800cb2c <BSP_MOTION_SENSOR_SetFullScale>
  MOTION_SENSOR_GetSensitivity(TargetBoardFeatures.HandleAccSensor,MOTION_ACCELERO,&sensitivity);
 8021ac6:	aa0a      	add	r2, sp, #40	; 0x28
 8021ac8:	2102      	movs	r1, #2
 8021aca:	69b8      	ldr	r0, [r7, #24]
 8021acc:	f7ea ff8e 	bl	800c9ec <BSP_MOTION_SENSOR_GetSensitivity>
  TargetBoardFeatures.AccSensiMultInG = sensitivity * FROM_MG_TO_G ;
 8021ad0:	ed9f 7a4e 	vldr	s14, [pc, #312]	; 8021c0c <startProc+0x338>
 8021ad4:	eddd 7a0a 	vldr	s15, [sp, #40]	; 0x28
      MOTION_SENSOR_SetOutputDataRate(TargetBoardFeatures.HandleAccSensor, MOTION_ACCELERO,INERTIAL_ACQ_ACTIVITY_IGN_WSDM_HZ);
 8021ad8:	69b8      	ldr	r0, [r7, #24]
  TargetBoardFeatures.AccSensiMultInG = sensitivity * FROM_MG_TO_G ;
 8021ada:	ee67 7a87 	vmul.f32	s15, s15, s14
      MOTION_SENSOR_SetOutputDataRate(TargetBoardFeatures.HandleAccSensor, MOTION_ACCELERO,INERTIAL_ACQ_ACTIVITY_IGN_WSDM_HZ);
 8021ade:	eeb3 0a04 	vmov.f32	s0, #52	; 0x41a00000  20.0
 8021ae2:	2102      	movs	r1, #2
  TargetBoardFeatures.AccSensiMultInG = sensitivity * FROM_MG_TO_G ;
 8021ae4:	edc7 7a0c 	vstr	s15, [r7, #48]	; 0x30
      MOTION_SENSOR_SetOutputDataRate(TargetBoardFeatures.HandleAccSensor, MOTION_ACCELERO,INERTIAL_ACQ_ACTIVITY_IGN_WSDM_HZ);
 8021ae8:	f7ea ffec 	bl	800cac4 <BSP_MOTION_SENSOR_SetOutputDataRate>
      HAR_Initialize(HarAlgo);
 8021aec:	79a8      	ldrb	r0, [r5, #6]
 8021aee:	f003 ff17 	bl	8025920 <HAR_Initialize>
      ActivityCodeStored = HAR_NOACTIVITY;
 8021af2:	2300      	movs	r3, #0
      msgAcq.type        = ACTIVITY_IGN_WSDM;
 8021af4:	220a      	movs	r2, #10
 8021af6:	e798      	b.n	8021a2a <startProc+0x156>
      ascResultStored           = ASC_UNDEFINED;
 8021af8:	4d40      	ldr	r5, [pc, #256]	; (8021bfc <startProc+0x328>)
      ActivityCodeStored        = HAR_NOACTIVITY;
 8021afa:	4c41      	ldr	r4, [pc, #260]	; (8021c00 <startProc+0x32c>)
      ascResultStored           = ASC_UNDEFINED;
 8021afc:	23ff      	movs	r3, #255	; 0xff
 8021afe:	706b      	strb	r3, [r5, #1]
      MultiNN_OutStored.harOut  = ActivityCodeStored;
 8021b00:	f44f 437f 	mov.w	r3, #65280	; 0xff00
      ActivityCodeStored        = HAR_NOACTIVITY;
 8021b04:	2200      	movs	r2, #0
      MultiNN_OutStored.harOut  = ActivityCodeStored;
 8021b06:	80ab      	strh	r3, [r5, #4]
      ActivityCodeStored        = HAR_NOACTIVITY;
 8021b08:	f884 294c 	strb.w	r2, [r4, #2380]	; 0x94c
      ASC_Init();
 8021b0c:	f7fb fe4a 	bl	801d7a4 <ASC_Init>
      if (HarAlgo == HAR_ALGO_IDX_NONE )
 8021b10:	79ab      	ldrb	r3, [r5, #6]
      if (!timActivityId) {
 8021b12:	69a2      	ldr	r2, [r4, #24]
      if (HarAlgo == HAR_ALGO_IDX_NONE )
 8021b14:	2bff      	cmp	r3, #255	; 0xff
          HarAlgo = HAR_IGN_IDX;
 8021b16:	bf04      	itt	eq
 8021b18:	2301      	moveq	r3, #1
 8021b1a:	71ab      	strbeq	r3, [r5, #6]
      if (!timActivityId) {
 8021b1c:	2a00      	cmp	r2, #0
 8021b1e:	f000 8081 	beq.w	8021c24 <startProc+0x350>
      MOTION_SENSOR_Enable(TargetBoardFeatures.HandleAccSensor, MOTION_ACCELERO);
 8021b22:	4f38      	ldr	r7, [pc, #224]	; (8021c04 <startProc+0x330>)
 8021b24:	2102      	movs	r1, #2
 8021b26:	69b8      	ldr	r0, [r7, #24]
 8021b28:	f7ea fe8c 	bl	800c844 <BSP_MOTION_SENSOR_Enable>
  MOTION_SENSOR_SetFullScale( TargetBoardFeatures.HandleAccSensor,MOTION_ACCELERO,4);
 8021b2c:	69b8      	ldr	r0, [r7, #24]
 8021b2e:	2204      	movs	r2, #4
 8021b30:	2102      	movs	r1, #2
 8021b32:	f7ea fffb 	bl	800cb2c <BSP_MOTION_SENSOR_SetFullScale>
  MOTION_SENSOR_GetSensitivity(TargetBoardFeatures.HandleAccSensor,MOTION_ACCELERO,&sensitivity);
 8021b36:	aa0a      	add	r2, sp, #40	; 0x28
 8021b38:	69b8      	ldr	r0, [r7, #24]
 8021b3a:	2102      	movs	r1, #2
 8021b3c:	f7ea ff56 	bl	800c9ec <BSP_MOTION_SENSOR_GetSensitivity>
  TargetBoardFeatures.AccSensiMultInG = sensitivity * FROM_MG_TO_G;
 8021b40:	ed9f 7a32 	vldr	s14, [pc, #200]	; 8021c0c <startProc+0x338>
 8021b44:	eddd 7a0a 	vldr	s15, [sp, #40]	; 0x28
      MOTION_SENSOR_SetOutputDataRate(TargetBoardFeatures.HandleAccSensor, MOTION_ACCELERO,INERTIAL_ACQ_ACTIVITY_IGN_HZ);
 8021b48:	69b8      	ldr	r0, [r7, #24]
  TargetBoardFeatures.AccSensiMultInG = sensitivity * FROM_MG_TO_G;
 8021b4a:	ee67 7a87 	vmul.f32	s15, s15, s14
      MOTION_SENSOR_SetOutputDataRate(TargetBoardFeatures.HandleAccSensor, MOTION_ACCELERO,INERTIAL_ACQ_ACTIVITY_IGN_HZ);
 8021b4e:	eeb3 0a0a 	vmov.f32	s0, #58	; 0x41d00000  26.0
 8021b52:	2102      	movs	r1, #2
  TargetBoardFeatures.AccSensiMultInG = sensitivity * FROM_MG_TO_G;
 8021b54:	edc7 7a0c 	vstr	s15, [r7, #48]	; 0x30
      MOTION_SENSOR_SetOutputDataRate(TargetBoardFeatures.HandleAccSensor, MOTION_ACCELERO,INERTIAL_ACQ_ACTIVITY_IGN_HZ);
 8021b58:	f7ea ffb4 	bl	800cac4 <BSP_MOTION_SENSOR_SetOutputDataRate>
      HAR_Initialize(HarAlgo);
 8021b5c:	79a8      	ldrb	r0, [r5, #6]
 8021b5e:	f003 fedf 	bl	8025920 <HAR_Initialize>
      msgAcq.audio_scene = ascResultStored;
 8021b62:	786b      	ldrb	r3, [r5, #1]
 8021b64:	f88d 302c 	strb.w	r3, [sp, #44]	; 0x2c
      SendMsgToHost(&msgAcq);
 8021b68:	a80a      	add	r0, sp, #40	; 0x28
      msgAcq.type        = AUDIO_SC;
 8021b6a:	2307      	movs	r3, #7
 8021b6c:	f88d 3028 	strb.w	r3, [sp, #40]	; 0x28
      id = timActivityId;
 8021b70:	69a5      	ldr	r5, [r4, #24]
      SendMsgToHost(&msgAcq);
 8021b72:	f7ff fe71 	bl	8021858 <SendMsgToHost>
      msgAcq.activity    = ActivityCodeStored;
 8021b76:	f894 394c 	ldrb.w	r3, [r4, #2380]	; 0x94c
 8021b7a:	f88d 302c 	strb.w	r3, [sp, #44]	; 0x2c
      msgAcq.type        = ACTIVITY_IGN;
 8021b7e:	2209      	movs	r2, #9
      SendMsgToHost(&msgAcq);
 8021b80:	a80a      	add	r0, sp, #40	; 0x28
      msgAcq.type        = ACTIVITY_IGN;
 8021b82:	f88d 2028 	strb.w	r2, [sp, #40]	; 0x28
      SendMsgToHost(&msgAcq);
 8021b86:	f7ff fe67 	bl	8021858 <SendMsgToHost>
      break;
 8021b8a:	e6d8      	b.n	802193e <startProc+0x6a>
      if (!timAudioLevId) {
 8021b8c:	4c1c      	ldr	r4, [pc, #112]	; (8021c00 <startProc+0x32c>)
 8021b8e:	6925      	ldr	r5, [r4, #16]
 8021b90:	b335      	cbz	r5, 8021be0 <startProc+0x30c>
      PowerCtrlLock();
 8021b92:	f7fd fb39 	bl	801f208 <PowerCtrlLock>
      audioInProgress |= 0x1 ;
 8021b96:	f8d4 3948 	ldr.w	r3, [r4, #2376]	; 0x948
      msg.HostLinkType  = AUDIO_HOST_LINK;
 8021b9a:	2203      	movs	r2, #3
      audioInProgress |= 0x1 ;
 8021b9c:	f043 0301 	orr.w	r3, r3, #1
      msg.HostLinkType  = AUDIO_HOST_LINK;
 8021ba0:	f88d 2004 	strb.w	r2, [sp, #4]
      audioInProgress |= 0x1 ;
 8021ba4:	f8c4 3948 	str.w	r3, [r4, #2376]	; 0x948
      break;
 8021ba8:	e6c9      	b.n	802193e <startProc+0x6a>
       if (!timSdCardLoggingId) {
 8021baa:	4c15      	ldr	r4, [pc, #84]	; (8021c00 <startProc+0x32c>)
 8021bac:	6a25      	ldr	r5, [r4, #32]
 8021bae:	2d00      	cmp	r5, #0
 8021bb0:	f47f aec7 	bne.w	8021942 <startProc+0x6e>
         timSdCardLoggingId = osTimerCreate (osTimer(TimerSdRecordingHandle), osTimerPeriodic, NULL);
 8021bb4:	462a      	mov	r2, r5
 8021bb6:	4816      	ldr	r0, [pc, #88]	; (8021c10 <startProc+0x33c>)
 8021bb8:	2101      	movs	r1, #1
 8021bba:	f7f6 fe8b 	bl	80188d4 <osTimerCreate>
 8021bbe:	4605      	mov	r5, r0
 8021bc0:	6220      	str	r0, [r4, #32]
       break;
 8021bc2:	e6bc      	b.n	802193e <startProc+0x6a>
        EnableEnvSensors();
 8021bc4:	f7fd fbf0 	bl	801f3a8 <EnableEnvSensors>
 8021bc8:	e6b5      	b.n	8021936 <startProc+0x62>
      SENSING1_PRINTF("wrong type : %d\n",type);
 8021bca:	4601      	mov	r1, r0
 8021bcc:	4811      	ldr	r0, [pc, #68]	; (8021c14 <startProc+0x340>)
 8021bce:	f006 fa25 	bl	802801c <iprintf>
  if (id){
 8021bd2:	e69f      	b.n	8021914 <startProc+0x40>
        timEnvId = osTimerCreate (osTimer(TimerEnvHandle), osTimerPeriodic, NULL);
 8021bd4:	4810      	ldr	r0, [pc, #64]	; (8021c18 <startProc+0x344>)
 8021bd6:	2101      	movs	r1, #1
 8021bd8:	f7f6 fe7c 	bl	80188d4 <osTimerCreate>
 8021bdc:	6020      	str	r0, [r4, #0]
 8021bde:	e6a4      	b.n	802192a <startProc+0x56>
        timAudioLevId = osTimerCreate (osTimer(TimerAudioLevHandle),osTimerPeriodic, NULL);
 8021be0:	462a      	mov	r2, r5
 8021be2:	480e      	ldr	r0, [pc, #56]	; (8021c1c <startProc+0x348>)
 8021be4:	2101      	movs	r1, #1
 8021be6:	f7f6 fe75 	bl	80188d4 <osTimerCreate>
 8021bea:	4605      	mov	r5, r0
 8021bec:	6120      	str	r0, [r4, #16]
 8021bee:	e7d0      	b.n	8021b92 <startProc+0x2be>
        timMotionId = osTimerCreate (osTimer(TimerMotionHandle),osTimerPeriodic, NULL);
 8021bf0:	480b      	ldr	r0, [pc, #44]	; (8021c20 <startProc+0x34c>)
 8021bf2:	2101      	movs	r1, #1
 8021bf4:	f7f6 fe6e 	bl	80188d4 <osTimerCreate>
 8021bf8:	60a0      	str	r0, [r4, #8]
 8021bfa:	e6b5      	b.n	8021968 <startProc+0x94>
 8021bfc:	20000d84 	.word	0x20000d84
 8021c00:	20012a74 	.word	0x20012a74
 8021c04:	200106a4 	.word	0x200106a4
 8021c08:	08043774 	.word	0x08043774
 8021c0c:	3a83126f 	.word	0x3a83126f
 8021c10:	08039b50 	.word	0x08039b50
 8021c14:	08043760 	.word	0x08043760
 8021c18:	08039b40 	.word	0x08039b40
 8021c1c:	08039b48 	.word	0x08039b48
 8021c20:	08039b44 	.word	0x08039b44
        timActivityId = osTimerCreate (osTimer(TimerActivityHandle),osTimerPeriodic, NULL);
 8021c24:	480b      	ldr	r0, [pc, #44]	; (8021c54 <startProc+0x380>)
 8021c26:	2101      	movs	r1, #1
 8021c28:	f7f6 fe54 	bl	80188d4 <osTimerCreate>
 8021c2c:	61a0      	str	r0, [r4, #24]
 8021c2e:	e778      	b.n	8021b22 <startProc+0x24e>
        timActivityId = osTimerCreate (osTimer(TimerActivityHandle),osTimerPeriodic, NULL);
 8021c30:	4808      	ldr	r0, [pc, #32]	; (8021c54 <startProc+0x380>)
 8021c32:	2101      	movs	r1, #1
 8021c34:	f7f6 fe4e 	bl	80188d4 <osTimerCreate>
 8021c38:	61a0      	str	r0, [r4, #24]
 8021c3a:	e73a      	b.n	8021ab2 <startProc+0x1de>
        timActivityId = osTimerCreate (osTimer(TimerActivityHandle),osTimerPeriodic, NULL);
 8021c3c:	4805      	ldr	r0, [pc, #20]	; (8021c54 <startProc+0x380>)
 8021c3e:	2101      	movs	r1, #1
 8021c40:	f7f6 fe48 	bl	80188d4 <osTimerCreate>
 8021c44:	61a0      	str	r0, [r4, #24]
 8021c46:	e706      	b.n	8021a56 <startProc+0x182>
        timActivityId = osTimerCreate (osTimer(TimerActivityHandle),osTimerPeriodic, NULL);
 8021c48:	4802      	ldr	r0, [pc, #8]	; (8021c54 <startProc+0x380>)
 8021c4a:	2101      	movs	r1, #1
 8021c4c:	f7f6 fe42 	bl	80188d4 <osTimerCreate>
 8021c50:	61a0      	str	r0, [r4, #24]
 8021c52:	e6c8      	b.n	80219e6 <startProc+0x112>
 8021c54:	08039b4c 	.word	0x08039b4c

08021c58 <stopProc>:
{
 8021c58:	b530      	push	{r4, r5, lr}
 8021c5a:	b08b      	sub	sp, #44	; 0x2c
  msg.type          = SET_HOST_LINK_TYPE;
 8021c5c:	2212      	movs	r2, #18
  msg.HostLinkType  = DEFAULT_HOST_LINK;
 8021c5e:	2301      	movs	r3, #1
  switch (type) {
 8021c60:	3805      	subs	r0, #5
  msg.type          = SET_HOST_LINK_TYPE;
 8021c62:	f88d 2000 	strb.w	r2, [sp]
  msg.HostLinkType  = DEFAULT_HOST_LINK;
 8021c66:	f88d 3004 	strb.w	r3, [sp, #4]
  switch (type) {
 8021c6a:	280c      	cmp	r0, #12
 8021c6c:	d82a      	bhi.n	8021cc4 <stopProc+0x6c>
 8021c6e:	e8df f000 	tbb	[pc, r0]
 8021c72:	544d      	.short	0x544d
 8021c74:	0909092f 	.word	0x0909092f
 8021c78:	29293b07 	.word	0x29293b07
 8021c7c:	2929      	.short	0x2929
 8021c7e:	48          	.byte	0x48
 8021c7f:	00          	.byte	0x00
      ASC_DeInit();
 8021c80:	f7fb fddc 	bl	801d83c <ASC_DeInit>
      MOTION_SENSOR_Disable(TargetBoardFeatures.HandleAccSensor, MOTION_ACCELERO);
 8021c84:	4a2f      	ldr	r2, [pc, #188]	; (8021d44 <stopProc+0xec>)
      id            = timActivityId;
 8021c86:	4b30      	ldr	r3, [pc, #192]	; (8021d48 <stopProc+0xf0>)
      HAR_DeInitialize(HarAlgo);
 8021c88:	4d30      	ldr	r5, [pc, #192]	; (8021d4c <stopProc+0xf4>)
      MOTION_SENSOR_Disable(TargetBoardFeatures.HandleAccSensor, MOTION_ACCELERO);
 8021c8a:	6990      	ldr	r0, [r2, #24]
      id            = timActivityId;
 8021c8c:	699c      	ldr	r4, [r3, #24]
      timActivityId = NULL;
 8021c8e:	2200      	movs	r2, #0
      MOTION_SENSOR_Disable(TargetBoardFeatures.HandleAccSensor, MOTION_ACCELERO);
 8021c90:	2102      	movs	r1, #2
      timActivityId = NULL;
 8021c92:	619a      	str	r2, [r3, #24]
      MOTION_SENSOR_Disable(TargetBoardFeatures.HandleAccSensor, MOTION_ACCELERO);
 8021c94:	f7ea fe0a 	bl	800c8ac <BSP_MOTION_SENSOR_Disable>
      HAR_DeInitialize(HarAlgo);
 8021c98:	79a8      	ldrb	r0, [r5, #6]
 8021c9a:	f003 fe73 	bl	8025984 <HAR_DeInitialize>
      HarAlgo = HAR_ALGO_IDX_NONE;
 8021c9e:	23ff      	movs	r3, #255	; 0xff
 8021ca0:	71ab      	strb	r3, [r5, #6]
  if (id){
 8021ca2:	b17c      	cbz	r4, 8021cc4 <stopProc+0x6c>
    if  (osTimerStop (id) != osOK){
 8021ca4:	4620      	mov	r0, r4
 8021ca6:	f7f6 fe57 	bl	8018958 <osTimerStop>
 8021caa:	b118      	cbz	r0, 8021cb4 <stopProc+0x5c>
      SENSING1_PRINTF("could not stop timer\n");
 8021cac:	4b27      	ldr	r3, [pc, #156]	; (8021d4c <stopProc+0xf4>)
 8021cae:	781b      	ldrb	r3, [r3, #0]
 8021cb0:	2b00      	cmp	r3, #0
 8021cb2:	d13d      	bne.n	8021d30 <stopProc+0xd8>
    if (osTimerDelete (id) != osOK)  {
 8021cb4:	4620      	mov	r0, r4
 8021cb6:	f7f6 fe7b 	bl	80189b0 <osTimerDelete>
 8021cba:	b118      	cbz	r0, 8021cc4 <stopProc+0x6c>
      SENSING1_PRINTF("could not delete timer\n");
 8021cbc:	4b23      	ldr	r3, [pc, #140]	; (8021d4c <stopProc+0xf4>)
 8021cbe:	781b      	ldrb	r3, [r3, #0]
 8021cc0:	2b00      	cmp	r3, #0
 8021cc2:	d131      	bne.n	8021d28 <stopProc+0xd0>
  SendMsgToHost(&msg);
 8021cc4:	4668      	mov	r0, sp
 8021cc6:	f7ff fdc7 	bl	8021858 <SendMsgToHost>
}
 8021cca:	2000      	movs	r0, #0
 8021ccc:	b00b      	add	sp, #44	; 0x2c
 8021cce:	bd30      	pop	{r4, r5, pc}
      ASC_DeInit();
 8021cd0:	f7fb fdb4 	bl	801d83c <ASC_DeInit>
      DeInitMics();
 8021cd4:	f7fd fc38 	bl	801f548 <DeInitMics>
      PowerCtrlUnLock();
 8021cd8:	f7fd fa9e 	bl	801f218 <PowerCtrlUnLock>
  SendMsgToHost(&msg);
 8021cdc:	4668      	mov	r0, sp
 8021cde:	f7ff fdbb 	bl	8021858 <SendMsgToHost>
}
 8021ce2:	2000      	movs	r0, #0
 8021ce4:	b00b      	add	sp, #44	; 0x2c
 8021ce6:	bd30      	pop	{r4, r5, pc}
      id            = timAudioLevId;
 8021ce8:	4d17      	ldr	r5, [pc, #92]	; (8021d48 <stopProc+0xf0>)
      if (audioInProgress&0x1) {
 8021cea:	f8d5 3948 	ldr.w	r3, [r5, #2376]	; 0x948
      id            = timAudioLevId;
 8021cee:	692c      	ldr	r4, [r5, #16]
      if (audioInProgress&0x1) {
 8021cf0:	07da      	lsls	r2, r3, #31
 8021cf2:	d421      	bmi.n	8021d38 <stopProc+0xe0>
      timAudioLevId = NULL;
 8021cf4:	2200      	movs	r2, #0
      audioInProgress &= 0x2+0x4 ;
 8021cf6:	f003 0306 	and.w	r3, r3, #6
      timAudioLevId = NULL;
 8021cfa:	612a      	str	r2, [r5, #16]
      audioInProgress &= 0x2+0x4 ;
 8021cfc:	f8c5 3948 	str.w	r3, [r5, #2376]	; 0x948
      break;
 8021d00:	e7cf      	b.n	8021ca2 <stopProc+0x4a>
      id                 = timSdCardLoggingId;
 8021d02:	4b11      	ldr	r3, [pc, #68]	; (8021d48 <stopProc+0xf0>)
      timSdCardLoggingId = NULL;
 8021d04:	2200      	movs	r2, #0
      id                 = timSdCardLoggingId;
 8021d06:	6a1c      	ldr	r4, [r3, #32]
      timSdCardLoggingId = NULL;
 8021d08:	621a      	str	r2, [r3, #32]
      break;
 8021d0a:	e7ca      	b.n	8021ca2 <stopProc+0x4a>
      id           = timEnvId;
 8021d0c:	4b0e      	ldr	r3, [pc, #56]	; (8021d48 <stopProc+0xf0>)
      timEnvId     = NULL;
 8021d0e:	2200      	movs	r2, #0
      id           = timEnvId;
 8021d10:	681c      	ldr	r4, [r3, #0]
      timEnvId     = NULL;
 8021d12:	601a      	str	r2, [r3, #0]
      DisableEnvSensors();
 8021d14:	f7fd fb96 	bl	801f444 <DisableEnvSensors>
      break;
 8021d18:	e7c3      	b.n	8021ca2 <stopProc+0x4a>
      id            = timMotionId;
 8021d1a:	4b0b      	ldr	r3, [pc, #44]	; (8021d48 <stopProc+0xf0>)
      timMotionId   = NULL;
 8021d1c:	2200      	movs	r2, #0
      id            = timMotionId;
 8021d1e:	689c      	ldr	r4, [r3, #8]
      timMotionId   = NULL;
 8021d20:	609a      	str	r2, [r3, #8]
      DisableMotionSensors ();
 8021d22:	f7fd fafd 	bl	801f320 <DisableMotionSensors>
      break;
 8021d26:	e7bc      	b.n	8021ca2 <stopProc+0x4a>
      SENSING1_PRINTF("could not delete timer\n");
 8021d28:	4809      	ldr	r0, [pc, #36]	; (8021d50 <stopProc+0xf8>)
 8021d2a:	f006 fa13 	bl	8028154 <puts>
 8021d2e:	e7c9      	b.n	8021cc4 <stopProc+0x6c>
      SENSING1_PRINTF("could not stop timer\n");
 8021d30:	4808      	ldr	r0, [pc, #32]	; (8021d54 <stopProc+0xfc>)
 8021d32:	f006 fa0f 	bl	8028154 <puts>
 8021d36:	e7bd      	b.n	8021cb4 <stopProc+0x5c>
        PowerCtrlUnLock();
 8021d38:	f7fd fa6e 	bl	801f218 <PowerCtrlUnLock>
      audioInProgress &= 0x2+0x4 ;
 8021d3c:	f8d5 3948 	ldr.w	r3, [r5, #2376]	; 0x948
 8021d40:	e7d8      	b.n	8021cf4 <stopProc+0x9c>
 8021d42:	bf00      	nop
 8021d44:	200106a4 	.word	0x200106a4
 8021d48:	20012a74 	.word	0x20012a74
 8021d4c:	20000d84 	.word	0x20000d84
 8021d50:	080437a4 	.word	0x080437a4
 8021d54:	0804378c 	.word	0x0804378c

08021d58 <Set2GAccelerometerFullScale>:
{
 8021d58:	b510      	push	{r4, lr}
  MOTION_SENSOR_SetFullScale( TargetBoardFeatures.HandleAccSensor,MOTION_ACCELERO,2);
 8021d5a:	4c0b      	ldr	r4, [pc, #44]	; (8021d88 <Set2GAccelerometerFullScale+0x30>)
 8021d5c:	2202      	movs	r2, #2
{
 8021d5e:	b082      	sub	sp, #8
  MOTION_SENSOR_SetFullScale( TargetBoardFeatures.HandleAccSensor,MOTION_ACCELERO,2);
 8021d60:	4611      	mov	r1, r2
 8021d62:	69a0      	ldr	r0, [r4, #24]
 8021d64:	f7ea fee2 	bl	800cb2c <BSP_MOTION_SENSOR_SetFullScale>
  MOTION_SENSOR_GetSensitivity(TargetBoardFeatures.HandleAccSensor,MOTION_ACCELERO,&sensitivity);
 8021d68:	69a0      	ldr	r0, [r4, #24]
 8021d6a:	aa01      	add	r2, sp, #4
 8021d6c:	2102      	movs	r1, #2
 8021d6e:	f7ea fe3d 	bl	800c9ec <BSP_MOTION_SENSOR_GetSensitivity>
  TargetBoardFeatures.AccSensiMultInG = sensitivity * FROM_MG_TO_G ;
 8021d72:	eddd 7a01 	vldr	s15, [sp, #4]
 8021d76:	ed9f 7a05 	vldr	s14, [pc, #20]	; 8021d8c <Set2GAccelerometerFullScale+0x34>
 8021d7a:	ee67 7a87 	vmul.f32	s15, s15, s14
 8021d7e:	edc4 7a0c 	vstr	s15, [r4, #48]	; 0x30
}
 8021d82:	b002      	add	sp, #8
 8021d84:	bd10      	pop	{r4, pc}
 8021d86:	bf00      	nop
 8021d88:	200106a4 	.word	0x200106a4
 8021d8c:	3a83126f 	.word	0x3a83126f

08021d90 <BSP_AUDIO_IN_HalfTransfer_CallBack>:
{
 8021d90:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8021d92:	f8df e0fc 	ldr.w	lr, [pc, #252]	; 8021e90 <BSP_AUDIO_IN_HalfTransfer_CallBack+0x100>
 8021d96:	4e36      	ldr	r6, [pc, #216]	; (8021e70 <BSP_AUDIO_IN_HalfTransfer_CallBack+0xe0>)
 8021d98:	f8de 2954 	ldr.w	r2, [lr, #2388]	; 0x954
 8021d9c:	f8de 0958 	ldr.w	r0, [lr, #2392]	; 0x958
    PCM_Buffer[i] = (uint16_t) SaturaLH(HP_Filter.oldOut, -32768, 32767);
 8021da0:	4f34      	ldr	r7, [pc, #208]	; (8021e74 <BSP_AUDIO_IN_HalfTransfer_CallBack+0xe4>)
 8021da2:	4d35      	ldr	r5, [pc, #212]	; (8021e78 <BSP_AUDIO_IN_HalfTransfer_CallBack+0xe8>)
 8021da4:	f106 0420 	add.w	r4, r6, #32
{
 8021da8:	4631      	mov	r1, r6
    HP_Filter.Z = (int32_t) PCM_Buffer[i];
 8021daa:	4603      	mov	r3, r0
 8021dac:	f931 0f02 	ldrsh.w	r0, [r1, #2]!
    HP_Filter.oldOut = (0xFC * (HP_Filter.oldOut + HP_Filter.Z - HP_Filter.oldIn)) / 256;
 8021db0:	4402      	add	r2, r0
 8021db2:	1ad3      	subs	r3, r2, r3
 8021db4:	ebc3 1383 	rsb	r3, r3, r3, lsl #6
 8021db8:	009b      	lsls	r3, r3, #2
 8021dba:	2b00      	cmp	r3, #0
 8021dbc:	461a      	mov	r2, r3
 8021dbe:	bfb8      	it	lt
 8021dc0:	f103 02ff 	addlt.w	r2, r3, #255	; 0xff
    PCM_Buffer[i] = (uint16_t) SaturaLH(HP_Filter.oldOut, -32768, 32767);
 8021dc4:	42bb      	cmp	r3, r7
 8021dc6:	46ac      	mov	ip, r5
    HP_Filter.oldOut = (0xFC * (HP_Filter.oldOut + HP_Filter.Z - HP_Filter.oldIn)) / 256;
 8021dc8:	ea4f 2222 	mov.w	r2, r2, asr #8
    PCM_Buffer[i] = (uint16_t) SaturaLH(HP_Filter.oldOut, -32768, 32767);
 8021dcc:	db06      	blt.n	8021ddc <BSP_AUDIO_IN_HalfTransfer_CallBack+0x4c>
 8021dce:	f5b3 0f00 	cmp.w	r3, #8388608	; 0x800000
 8021dd2:	bfb4      	ite	lt
 8021dd4:	fa0f fc82 	sxthlt.w	ip, r2
 8021dd8:	f647 7cff 	movwge	ip, #32767	; 0x7fff
  for (uint32_t i = 0; i < nb_samples; i++)
 8021ddc:	428c      	cmp	r4, r1
    PCM_Buffer[i] = (uint16_t) SaturaLH(HP_Filter.oldOut, -32768, 32767);
 8021dde:	f8a1 c000 	strh.w	ip, [r1]
  for (uint32_t i = 0; i < nb_samples; i++)
 8021de2:	d1e2      	bne.n	8021daa <BSP_AUDIO_IN_HalfTransfer_CallBack+0x1a>
  memcpy(Fill_Buffer + index_buff_fill, PCM_Buffer, buffer_size);
 8021de4:	4b25      	ldr	r3, [pc, #148]	; (8021e7c <BSP_AUDIO_IN_HalfTransfer_CallBack+0xec>)
 8021de6:	f8ce 2954 	str.w	r2, [lr, #2388]	; 0x954
 8021dea:	f8ce 0950 	str.w	r0, [lr, #2384]	; 0x950
 8021dee:	f8ce 0958 	str.w	r0, [lr, #2392]	; 0x958
 8021df2:	f8de 1934 	ldr.w	r1, [lr, #2356]	; 0x934
 8021df6:	4d22      	ldr	r5, [pc, #136]	; (8021e80 <BSP_AUDIO_IN_HalfTransfer_CallBack+0xf0>)
 8021df8:	6818      	ldr	r0, [r3, #0]
 8021dfa:	f845 0011 	str.w	r0, [r5, r1, lsl #1]
 8021dfe:	eb05 0241 	add.w	r2, r5, r1, lsl #1
  index_buff_fill += nb_samples;
 8021e02:	3110      	adds	r1, #16
 8021e04:	f8ce 1934 	str.w	r1, [lr, #2356]	; 0x934
  memcpy(Fill_Buffer + index_buff_fill, PCM_Buffer, buffer_size);
 8021e08:	6858      	ldr	r0, [r3, #4]
 8021e0a:	6050      	str	r0, [r2, #4]
 8021e0c:	6898      	ldr	r0, [r3, #8]
 8021e0e:	6090      	str	r0, [r2, #8]
 8021e10:	68d8      	ldr	r0, [r3, #12]
 8021e12:	60d0      	str	r0, [r2, #12]
 8021e14:	6918      	ldr	r0, [r3, #16]
 8021e16:	6110      	str	r0, [r2, #16]
 8021e18:	6958      	ldr	r0, [r3, #20]
 8021e1a:	6150      	str	r0, [r2, #20]
 8021e1c:	6998      	ldr	r0, [r3, #24]
 8021e1e:	6190      	str	r0, [r2, #24]
 8021e20:	69d8      	ldr	r0, [r3, #28]
 8021e22:	61d0      	str	r0, [r2, #28]
  if (index_buff_fill == FILL_BUFFER_SIZE) {
 8021e24:	f5b1 6f80 	cmp.w	r1, #1024	; 0x400
 8021e28:	d101      	bne.n	8021e2e <BSP_AUDIO_IN_HalfTransfer_CallBack+0x9e>
 8021e2a:	f7ff fcb1 	bl	8021790 <AudioProcess.part.0>
  if (SD_LogAudio_Enabled)
 8021e2e:	4b15      	ldr	r3, [pc, #84]	; (8021e84 <BSP_AUDIO_IN_HalfTransfer_CallBack+0xf4>)
 8021e30:	681b      	ldr	r3, [r3, #0]
 8021e32:	b9b3      	cbnz	r3, 8021e62 <BSP_AUDIO_IN_HalfTransfer_CallBack+0xd2>
    if (W2ST_CHECK_CONNECTION(W2ST_CONNECT_AUDIO_LEVEL))
 8021e34:	4b14      	ldr	r3, [pc, #80]	; (8021e88 <BSP_AUDIO_IN_HalfTransfer_CallBack+0xf8>)
 8021e36:	681b      	ldr	r3, [r3, #0]
 8021e38:	071b      	lsls	r3, r3, #28
 8021e3a:	d400      	bmi.n	8021e3e <BSP_AUDIO_IN_HalfTransfer_CallBack+0xae>
}
 8021e3c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8021e3e:	4a13      	ldr	r2, [pc, #76]	; (8021e8c <BSP_AUDIO_IN_HalfTransfer_CallBack+0xfc>)
      RMS_Ch[NumberMic] += (float)((int16_t)PCM_Buffer[i*AUDIO_CHANNELS+NumberMic] * ((int16_t)PCM_Buffer[i*AUDIO_CHANNELS+NumberMic]));
 8021e40:	f936 3f02 	ldrsh.w	r3, [r6, #2]!
 8021e44:	ed92 7a00 	vldr	s14, [r2]
 8021e48:	fb03 f303 	mul.w	r3, r3, r3
 8021e4c:	ee07 3a90 	vmov	s15, r3
 8021e50:	eef8 7ae7 	vcvt.f32.s32	s15, s15
  for(i = 0; i < 16; i++){
 8021e54:	42b4      	cmp	r4, r6
      RMS_Ch[NumberMic] += (float)((int16_t)PCM_Buffer[i*AUDIO_CHANNELS+NumberMic] * ((int16_t)PCM_Buffer[i*AUDIO_CHANNELS+NumberMic]));
 8021e56:	ee77 7a87 	vadd.f32	s15, s15, s14
 8021e5a:	edc2 7a00 	vstr	s15, [r2]
  for(i = 0; i < 16; i++){
 8021e5e:	d1ef      	bne.n	8021e40 <BSP_AUDIO_IN_HalfTransfer_CallBack+0xb0>
}
 8021e60:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8021e62:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
    AudioProcess_SD_Recording((uint16_t *) PCM_Buffer, nb_samples);
 8021e66:	4805      	ldr	r0, [pc, #20]	; (8021e7c <BSP_AUDIO_IN_HalfTransfer_CallBack+0xec>)
 8021e68:	2110      	movs	r1, #16
 8021e6a:	f7fc b9b3 	b.w	801e1d4 <AudioProcess_SD_Recording>
 8021e6e:	bf00      	nop
 8021e70:	200106f6 	.word	0x200106f6
 8021e74:	ff7fff01 	.word	0xff7fff01
 8021e78:	ffff8000 	.word	0xffff8000
 8021e7c:	200106f8 	.word	0x200106f8
 8021e80:	20012ba8 	.word	0x20012ba8
 8021e84:	2000b530 	.word	0x2000b530
 8021e88:	2001457c 	.word	0x2001457c
 8021e8c:	20010a18 	.word	0x20010a18
 8021e90:	20012a74 	.word	0x20012a74

08021e94 <BSP_AUDIO_IN_TransferComplete_CallBack>:
{
 8021e94:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8021e98:	4e3c      	ldr	r6, [pc, #240]	; (8021f8c <BSP_AUDIO_IN_TransferComplete_CallBack+0xf8>)
 8021e9a:	f8df 810c 	ldr.w	r8, [pc, #268]	; 8021fa8 <BSP_AUDIO_IN_TransferComplete_CallBack+0x114>
    PCM_Buffer[i + nb_samples] = (uint16_t) SaturaLH(HP_Filter.oldOut, -32768, 32767);
 8021e9e:	4d3c      	ldr	r5, [pc, #240]	; (8021f90 <BSP_AUDIO_IN_TransferComplete_CallBack+0xfc>)
 8021ea0:	f8d8 2954 	ldr.w	r2, [r8, #2388]	; 0x954
 8021ea4:	f8d8 0958 	ldr.w	r0, [r8, #2392]	; 0x958
 8021ea8:	f8df e100 	ldr.w	lr, [pc, #256]	; 8021fac <BSP_AUDIO_IN_TransferComplete_CallBack+0x118>
 8021eac:	4631      	mov	r1, r6
 8021eae:	f1a6 0720 	sub.w	r7, r6, #32
 8021eb2:	f106 0c20 	add.w	ip, r6, #32
 8021eb6:	e007      	b.n	8021ec8 <BSP_AUDIO_IN_TransferComplete_CallBack+0x34>
 8021eb8:	f5b3 0f00 	cmp.w	r3, #8388608	; 0x800000
 8021ebc:	da48      	bge.n	8021f50 <BSP_AUDIO_IN_TransferComplete_CallBack+0xbc>
 8021ebe:	b213      	sxth	r3, r2
  for (uint32_t i = 0; i < nb_samples; i++)
 8021ec0:	4561      	cmp	r1, ip
    PCM_Buffer[i + nb_samples] = (uint16_t) SaturaLH(HP_Filter.oldOut, -32768, 32767);
 8021ec2:	f821 3c02 	strh.w	r3, [r1, #-2]
  for (uint32_t i = 0; i < nb_samples; i++)
 8021ec6:	d016      	beq.n	8021ef6 <BSP_AUDIO_IN_TransferComplete_CallBack+0x62>
    HP_Filter.Z = (int32_t) PCM_Buffer[i + nb_samples];
 8021ec8:	f931 4b02 	ldrsh.w	r4, [r1], #2
 8021ecc:	4603      	mov	r3, r0
    HP_Filter.oldOut = (0xFC * (HP_Filter.oldOut + HP_Filter.Z - HP_Filter.oldIn)) / 256;
 8021ece:	4422      	add	r2, r4
 8021ed0:	1ad3      	subs	r3, r2, r3
 8021ed2:	ebc3 1383 	rsb	r3, r3, r3, lsl #6
 8021ed6:	009b      	lsls	r3, r3, #2
 8021ed8:	2b00      	cmp	r3, #0
 8021eda:	461a      	mov	r2, r3
 8021edc:	bfb8      	it	lt
 8021ede:	f103 02ff 	addlt.w	r2, r3, #255	; 0xff
    PCM_Buffer[i + nb_samples] = (uint16_t) SaturaLH(HP_Filter.oldOut, -32768, 32767);
 8021ee2:	42ab      	cmp	r3, r5
    HP_Filter.Z = (int32_t) PCM_Buffer[i + nb_samples];
 8021ee4:	4620      	mov	r0, r4
    HP_Filter.oldOut = (0xFC * (HP_Filter.oldOut + HP_Filter.Z - HP_Filter.oldIn)) / 256;
 8021ee6:	ea4f 2222 	mov.w	r2, r2, asr #8
    PCM_Buffer[i + nb_samples] = (uint16_t) SaturaLH(HP_Filter.oldOut, -32768, 32767);
 8021eea:	dae5      	bge.n	8021eb8 <BSP_AUDIO_IN_TransferComplete_CallBack+0x24>
 8021eec:	4673      	mov	r3, lr
  for (uint32_t i = 0; i < nb_samples; i++)
 8021eee:	4561      	cmp	r1, ip
    PCM_Buffer[i + nb_samples] = (uint16_t) SaturaLH(HP_Filter.oldOut, -32768, 32767);
 8021ef0:	f821 3c02 	strh.w	r3, [r1, #-2]
  for (uint32_t i = 0; i < nb_samples; i++)
 8021ef4:	d1e8      	bne.n	8021ec8 <BSP_AUDIO_IN_TransferComplete_CallBack+0x34>
  memcpy(Fill_Buffer + index_buff_fill, PCM_Buffer + nb_samples, buffer_size);
 8021ef6:	4b27      	ldr	r3, [pc, #156]	; (8021f94 <BSP_AUDIO_IN_TransferComplete_CallBack+0x100>)
 8021ef8:	f8c8 2954 	str.w	r2, [r8, #2388]	; 0x954
 8021efc:	f8d8 2934 	ldr.w	r2, [r8, #2356]	; 0x934
 8021f00:	6831      	ldr	r1, [r6, #0]
 8021f02:	f843 1012 	str.w	r1, [r3, r2, lsl #1]
 8021f06:	eb03 0342 	add.w	r3, r3, r2, lsl #1
 8021f0a:	6871      	ldr	r1, [r6, #4]
 8021f0c:	6059      	str	r1, [r3, #4]
 8021f0e:	6931      	ldr	r1, [r6, #16]
 8021f10:	6119      	str	r1, [r3, #16]
 8021f12:	68b1      	ldr	r1, [r6, #8]
 8021f14:	6099      	str	r1, [r3, #8]
 8021f16:	68f1      	ldr	r1, [r6, #12]
 8021f18:	60d9      	str	r1, [r3, #12]
 8021f1a:	6971      	ldr	r1, [r6, #20]
 8021f1c:	6159      	str	r1, [r3, #20]
 8021f1e:	69b1      	ldr	r1, [r6, #24]
 8021f20:	6199      	str	r1, [r3, #24]
  index_buff_fill += nb_samples;
 8021f22:	3210      	adds	r2, #16
  memcpy(Fill_Buffer + index_buff_fill, PCM_Buffer + nb_samples, buffer_size);
 8021f24:	69f1      	ldr	r1, [r6, #28]
 8021f26:	f8c8 4950 	str.w	r4, [r8, #2384]	; 0x950
  if (index_buff_fill == FILL_BUFFER_SIZE) {
 8021f2a:	f5b2 6f80 	cmp.w	r2, #1024	; 0x400
 8021f2e:	f8c8 4958 	str.w	r4, [r8, #2392]	; 0x958
  index_buff_fill += nb_samples;
 8021f32:	f8c8 2934 	str.w	r2, [r8, #2356]	; 0x934
  memcpy(Fill_Buffer + index_buff_fill, PCM_Buffer + nb_samples, buffer_size);
 8021f36:	61d9      	str	r1, [r3, #28]
  if (index_buff_fill == FILL_BUFFER_SIZE) {
 8021f38:	d101      	bne.n	8021f3e <BSP_AUDIO_IN_TransferComplete_CallBack+0xaa>
 8021f3a:	f7ff fc29 	bl	8021790 <AudioProcess.part.0>
  if (SD_LogAudio_Enabled)
 8021f3e:	4b16      	ldr	r3, [pc, #88]	; (8021f98 <BSP_AUDIO_IN_TransferComplete_CallBack+0x104>)
 8021f40:	681b      	ldr	r3, [r3, #0]
 8021f42:	b9eb      	cbnz	r3, 8021f80 <BSP_AUDIO_IN_TransferComplete_CallBack+0xec>
    if (W2ST_CHECK_CONNECTION(W2ST_CONNECT_AUDIO_LEVEL))
 8021f44:	4b15      	ldr	r3, [pc, #84]	; (8021f9c <BSP_AUDIO_IN_TransferComplete_CallBack+0x108>)
 8021f46:	681b      	ldr	r3, [r3, #0]
 8021f48:	071b      	lsls	r3, r3, #28
 8021f4a:	d404      	bmi.n	8021f56 <BSP_AUDIO_IN_TransferComplete_CallBack+0xc2>
}
 8021f4c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    PCM_Buffer[i + nb_samples] = (uint16_t) SaturaLH(HP_Filter.oldOut, -32768, 32767);
 8021f50:	f647 73ff 	movw	r3, #32767	; 0x7fff
 8021f54:	e7b4      	b.n	8021ec0 <BSP_AUDIO_IN_TransferComplete_CallBack+0x2c>
 8021f56:	4a12      	ldr	r2, [pc, #72]	; (8021fa0 <BSP_AUDIO_IN_TransferComplete_CallBack+0x10c>)
 8021f58:	4912      	ldr	r1, [pc, #72]	; (8021fa4 <BSP_AUDIO_IN_TransferComplete_CallBack+0x110>)
 8021f5a:	371e      	adds	r7, #30
      RMS_Ch[NumberMic] += (float)((int16_t)PCM_Buffer[i*AUDIO_CHANNELS+NumberMic] * ((int16_t)PCM_Buffer[i*AUDIO_CHANNELS+NumberMic]));
 8021f5c:	f932 3f02 	ldrsh.w	r3, [r2, #2]!
 8021f60:	ed91 7a00 	vldr	s14, [r1]
 8021f64:	fb03 f303 	mul.w	r3, r3, r3
 8021f68:	ee07 3a90 	vmov	s15, r3
 8021f6c:	eef8 7ae7 	vcvt.f32.s32	s15, s15
  for(i = 0; i < 16; i++){
 8021f70:	4297      	cmp	r7, r2
      RMS_Ch[NumberMic] += (float)((int16_t)PCM_Buffer[i*AUDIO_CHANNELS+NumberMic] * ((int16_t)PCM_Buffer[i*AUDIO_CHANNELS+NumberMic]));
 8021f72:	ee77 7a87 	vadd.f32	s15, s15, s14
 8021f76:	edc1 7a00 	vstr	s15, [r1]
  for(i = 0; i < 16; i++){
 8021f7a:	d1ef      	bne.n	8021f5c <BSP_AUDIO_IN_TransferComplete_CallBack+0xc8>
}
 8021f7c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8021f80:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    AudioProcess_SD_Recording((uint16_t *) PCM_Buffer + nb_samples, nb_samples);
 8021f84:	4801      	ldr	r0, [pc, #4]	; (8021f8c <BSP_AUDIO_IN_TransferComplete_CallBack+0xf8>)
 8021f86:	2110      	movs	r1, #16
 8021f88:	f7fc b924 	b.w	801e1d4 <AudioProcess_SD_Recording>
 8021f8c:	20010718 	.word	0x20010718
 8021f90:	ff7fff01 	.word	0xff7fff01
 8021f94:	20012ba8 	.word	0x20012ba8
 8021f98:	2000b530 	.word	0x2000b530
 8021f9c:	2001457c 	.word	0x2001457c
 8021fa0:	200106f6 	.word	0x200106f6
 8021fa4:	20010a18 	.word	0x20010a18
 8021fa8:	20012a74 	.word	0x20012a74
 8021fac:	ffff8000 	.word	0xffff8000

08021fb0 <ReadEnvironmentalData>:
{
 8021fb0:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
  *PressToSend=0;
 8021fb4:	2400      	movs	r4, #0
{
 8021fb6:	ed2d 8b02 	vpush	{d8}
  *PressToSend=0;
 8021fba:	6004      	str	r4, [r0, #0]
  *HumToSend=0;
 8021fbc:	800c      	strh	r4, [r1, #0]
  *Temp2ToSend=0,*Temp1ToSend=0;
 8021fbe:	801c      	strh	r4, [r3, #0]
 8021fc0:	8014      	strh	r4, [r2, #0]
  if(TargetBoardFeatures.HandleHumSensor != SENSING1_SNS_NOT_VALID) {
 8021fc2:	4c4b      	ldr	r4, [pc, #300]	; (80220f0 <ReadEnvironmentalData+0x140>)
{
 8021fc4:	4605      	mov	r5, r0
  if(TargetBoardFeatures.HandleHumSensor != SENSING1_SNS_NOT_VALID) {
 8021fc6:	6960      	ldr	r0, [r4, #20]
 8021fc8:	f242 790f 	movw	r9, #9999	; 0x270f
 8021fcc:	4548      	cmp	r0, r9
{
 8021fce:	b083      	sub	sp, #12
 8021fd0:	461e      	mov	r6, r3
  if(TargetBoardFeatures.HandleHumSensor != SENSING1_SNS_NOT_VALID) {
 8021fd2:	d109      	bne.n	8021fe8 <ReadEnvironmentalData+0x38>
  if(TargetBoardFeatures.HandlePressSensor != SENSING1_SNS_NOT_VALID) {
 8021fd4:	6920      	ldr	r0, [r4, #16]
 8021fd6:	f242 770f 	movw	r7, #9999	; 0x270f
 8021fda:	42b8      	cmp	r0, r7
 8021fdc:	d147      	bne.n	802206e <ReadEnvironmentalData+0xbe>
}
 8021fde:	b003      	add	sp, #12
 8021fe0:	ecbd 8b02 	vpop	{d8}
 8021fe4:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    ENV_SENSOR_GetValue(TargetBoardFeatures.HandleHumSensor,ENV_HUMIDITY,&SensorValue);
 8021fe8:	460f      	mov	r7, r1
 8021fea:	4690      	mov	r8, r2
 8021fec:	2104      	movs	r1, #4
 8021fee:	aa01      	add	r2, sp, #4
 8021ff0:	f7ea fb5e 	bl	800c6b0 <BSP_ENV_SENSOR_GetValue>
    MCR_BLUEMS_F2I_1D(SensorValue, intPart, decPart);
 8021ff4:	eddd 7a01 	vldr	s15, [sp, #4]
    if(TargetBoardFeatures.HandleTempSensors[0] != SENSING1_SNS_NOT_VALID) {
 8021ff8:	68a0      	ldr	r0, [r4, #8]
    MCR_BLUEMS_F2I_1D(SensorValue, intPart, decPart);
 8021ffa:	eebd 7ae7 	vcvt.s32.f32	s14, s15
 8021ffe:	eeb2 8a04 	vmov.f32	s16, #36	; 0x41200000  10.0
 8022002:	ee17 ca10 	vmov	ip, s14
 8022006:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
    *HumToSend = intPart*10+decPart;
 802200a:	eb0c 0c8c 	add.w	ip, ip, ip, lsl #2
    MCR_BLUEMS_F2I_1D(SensorValue, intPart, decPart);
 802200e:	ee77 7ac7 	vsub.f32	s15, s15, s14
    if(TargetBoardFeatures.HandleTempSensors[0] != SENSING1_SNS_NOT_VALID) {
 8022012:	4548      	cmp	r0, r9
    MCR_BLUEMS_F2I_1D(SensorValue, intPart, decPart);
 8022014:	ee67 7a88 	vmul.f32	s15, s15, s16
 8022018:	eefd 7ae7 	vcvt.s32.f32	s15, s15
    *HumToSend = intPart*10+decPart;
 802201c:	ee17 3a90 	vmov	r3, s15
 8022020:	eb03 0c4c 	add.w	ip, r3, ip, lsl #1
 8022024:	f8a7 c000 	strh.w	ip, [r7]
    if(TargetBoardFeatures.HandleTempSensors[0] != SENSING1_SNS_NOT_VALID) {
 8022028:	d019      	beq.n	802205e <ReadEnvironmentalData+0xae>
      ENV_SENSOR_GetValue(TargetBoardFeatures.HandleTempSensors[0],ENV_TEMPERATURE,&SensorValue);
 802202a:	aa01      	add	r2, sp, #4
 802202c:	2101      	movs	r1, #1
 802202e:	f7ea fb3f 	bl	800c6b0 <BSP_ENV_SENSOR_GetValue>
      MCR_BLUEMS_F2I_1D(SensorValue, intPart, decPart);
 8022032:	eddd 7a01 	vldr	s15, [sp, #4]
 8022036:	eebd 7ae7 	vcvt.s32.f32	s14, s15
 802203a:	ee17 3a10 	vmov	r3, s14
 802203e:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
      *Temp1ToSend = intPart*10+decPart;
 8022042:	eb03 0383 	add.w	r3, r3, r3, lsl #2
      MCR_BLUEMS_F2I_1D(SensorValue, intPart, decPart);
 8022046:	ee77 7ac7 	vsub.f32	s15, s15, s14
 802204a:	ee67 7a88 	vmul.f32	s15, s15, s16
 802204e:	eefd 7ae7 	vcvt.s32.f32	s15, s15
      *Temp1ToSend = intPart*10+decPart;
 8022052:	ee17 2a90 	vmov	r2, s15
 8022056:	eb02 0343 	add.w	r3, r2, r3, lsl #1
 802205a:	f8a8 3000 	strh.w	r3, [r8]
    ENV_SENSOR_Set_One_Shot(TargetBoardFeatures.HandleHumSensor);
 802205e:	6960      	ldr	r0, [r4, #20]
 8022060:	f002 fcc4 	bl	80249ec <BSP_ENV_SENSOR_Set_One_Shot>
  if(TargetBoardFeatures.HandlePressSensor != SENSING1_SNS_NOT_VALID) {
 8022064:	6920      	ldr	r0, [r4, #16]
 8022066:	f242 770f 	movw	r7, #9999	; 0x270f
 802206a:	42b8      	cmp	r0, r7
 802206c:	d0b7      	beq.n	8021fde <ReadEnvironmentalData+0x2e>
    ENV_SENSOR_GetValue(TargetBoardFeatures.HandlePressSensor,ENV_PRESSURE,&SensorValue);
 802206e:	aa01      	add	r2, sp, #4
 8022070:	2102      	movs	r1, #2
 8022072:	f7ea fb1d 	bl	800c6b0 <BSP_ENV_SENSOR_GetValue>
    MCR_BLUEMS_F2I_2D(SensorValue, intPart, decPart);
 8022076:	eddd 7a01 	vldr	s15, [sp, #4]
 802207a:	eddf 6a1e 	vldr	s13, [pc, #120]	; 80220f4 <ReadEnvironmentalData+0x144>
 802207e:	eebd 7ae7 	vcvt.s32.f32	s14, s15
    *PressToSend=intPart*100+decPart;
 8022082:	2264      	movs	r2, #100	; 0x64
    MCR_BLUEMS_F2I_2D(SensorValue, intPart, decPart);
 8022084:	eeb8 6ac7 	vcvt.f32.s32	s12, s14
    *PressToSend=intPart*100+decPart;
 8022088:	ee17 1a10 	vmov	r1, s14
    MCR_BLUEMS_F2I_2D(SensorValue, intPart, decPart);
 802208c:	ee77 7ac6 	vsub.f32	s15, s15, s12
 8022090:	ee67 7aa6 	vmul.f32	s15, s15, s13
 8022094:	eefd 7ae7 	vcvt.s32.f32	s15, s15
    *PressToSend=intPart*100+decPart;
 8022098:	ee17 3a90 	vmov	r3, s15
 802209c:	fb02 3201 	mla	r2, r2, r1, r3
 80220a0:	602a      	str	r2, [r5, #0]
    if(TargetBoardFeatures.HandleTempSensors[1] != SENSING1_SNS_NOT_VALID) {
 80220a2:	68e0      	ldr	r0, [r4, #12]
 80220a4:	42b8      	cmp	r0, r7
 80220a6:	d01a      	beq.n	80220de <ReadEnvironmentalData+0x12e>
      ENV_SENSOR_GetValue(TargetBoardFeatures.HandleTempSensors[1],ENV_TEMPERATURE,&SensorValue);
 80220a8:	aa01      	add	r2, sp, #4
 80220aa:	2101      	movs	r1, #1
 80220ac:	f7ea fb00 	bl	800c6b0 <BSP_ENV_SENSOR_GetValue>
      MCR_BLUEMS_F2I_1D(SensorValue, intPart, decPart);
 80220b0:	eddd 7a01 	vldr	s15, [sp, #4]
 80220b4:	eefd 6ae7 	vcvt.s32.f32	s13, s15
 80220b8:	eeb2 7a04 	vmov.f32	s14, #36	; 0x41200000  10.0
 80220bc:	ee16 3a90 	vmov	r3, s13
 80220c0:	eef8 6ae6 	vcvt.f32.s32	s13, s13
      *Temp2ToSend = intPart*10+decPart;
 80220c4:	eb03 0383 	add.w	r3, r3, r3, lsl #2
      MCR_BLUEMS_F2I_1D(SensorValue, intPart, decPart);
 80220c8:	ee77 7ae6 	vsub.f32	s15, s15, s13
 80220cc:	ee67 7a87 	vmul.f32	s15, s15, s14
 80220d0:	eefd 7ae7 	vcvt.s32.f32	s15, s15
      *Temp2ToSend = intPart*10+decPart;
 80220d4:	ee17 2a90 	vmov	r2, s15
 80220d8:	eb02 0343 	add.w	r3, r2, r3, lsl #1
 80220dc:	8033      	strh	r3, [r6, #0]
    ENV_SENSOR_Set_One_Shot(TargetBoardFeatures.HandlePressSensor);
 80220de:	6920      	ldr	r0, [r4, #16]
 80220e0:	f002 fc84 	bl	80249ec <BSP_ENV_SENSOR_Set_One_Shot>
}
 80220e4:	b003      	add	sp, #12
 80220e6:	ecbd 8b02 	vpop	{d8}
 80220ea:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 80220ee:	bf00      	nop
 80220f0:	200106a4 	.word	0x200106a4
 80220f4:	42c80000 	.word	0x42c80000

080220f8 <ProcessThread>:
{
 80220f8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80220fc:	ed2d 8b08 	vpush	{d8-d11}
 8022100:	4cc0      	ldr	r4, [pc, #768]	; (8022404 <ProcessThread+0x30c>)
 8022102:	f8df 8334 	ldr.w	r8, [pc, #820]	; 8022438 <ProcessThread+0x340>
 8022106:	f8df b334 	ldr.w	fp, [pc, #820]	; 802243c <ProcessThread+0x344>
 802210a:	4dbf      	ldr	r5, [pc, #764]	; (8022408 <ProcessThread+0x310>)
    RMS_Ch[NumberMic] /= (16.0f*MICS_DB_UPDATE_MS);
 802210c:	ed9f babf 	vldr	s22, [pc, #764]	; 802240c <ProcessThread+0x314>
    DBNOISE_Value_Ch[NumberMic] = (uint16_t)((120.0f - 20 * log10f(32768 * (1 + 0.25f * (TargetBoardFeatures.AudioVolume /*AudioInVolume*/ - 4))) + 10.0f * log10f(RMS_Ch[NumberMic])) * 0.3f + DBNOISE_Value_Old_Ch[NumberMic] * 0.7f);
 8022110:	eddf aabf 	vldr	s21, [pc, #764]	; 8022410 <ProcessThread+0x318>
 8022114:	ed9f aabf 	vldr	s20, [pc, #764]	; 8022414 <ProcessThread+0x31c>
 8022118:	eddf 9abf 	vldr	s19, [pc, #764]	; 8022418 <ProcessThread+0x320>
 802211c:	f8df a320 	ldr.w	sl, [pc, #800]	; 8022440 <ProcessThread+0x348>
 8022120:	4fbe      	ldr	r7, [pc, #760]	; (802241c <ProcessThread+0x324>)
 8022122:	f8df 9320 	ldr.w	r9, [pc, #800]	; 8022444 <ProcessThread+0x34c>
{
 8022126:	b0a1      	sub	sp, #132	; 0x84
 8022128:	ae09      	add	r6, sp, #36	; 0x24
    DBNOISE_Value_Ch[NumberMic] = (uint16_t)((120.0f - 20 * log10f(32768 * (1 + 0.25f * (TargetBoardFeatures.AudioVolume /*AudioInVolume*/ - 4))) + 10.0f * log10f(RMS_Ch[NumberMic])) * 0.3f + DBNOISE_Value_Old_Ch[NumberMic] * 0.7f);
 802212a:	ed9f 9abd 	vldr	s18, [pc, #756]	; 8022420 <ProcessThread+0x328>
    RMS_Ch[NumberMic] = 0.0f;
 802212e:	eddf 8abd 	vldr	s17, [pc, #756]	; 8022424 <ProcessThread+0x32c>
  if (semRun != NULL){
 8022132:	6aa0      	ldr	r0, [r4, #40]	; 0x28
 8022134:	b900      	cbnz	r0, 8022138 <ProcessThread+0x40>
 8022136:	e7fe      	b.n	8022136 <ProcessThread+0x3e>
    if(osSemaphoreWait(semRun, osWaitForever) == osOK) {
 8022138:	f04f 31ff 	mov.w	r1, #4294967295
 802213c:	f7f6 fc64 	bl	8018a08 <osSemaphoreWait>
 8022140:	2800      	cmp	r0, #0
 8022142:	d1f6      	bne.n	8022132 <ProcessThread+0x3a>
      if(set_connectable){
 8022144:	f898 3000 	ldrb.w	r3, [r8]
 8022148:	b16b      	cbz	r3, 8022166 <ProcessThread+0x6e>
        if(NecessityToSaveMetaDataManager) {
 802214a:	f8db 3000 	ldr.w	r3, [fp]
 802214e:	2b00      	cmp	r3, #0
 8022150:	f040 8141 	bne.w	80223d6 <ProcessThread+0x2de>
        msg.type  = SET_CONNECTABLE ;
 8022154:	2300      	movs	r3, #0
        SendMsgToHost(&msg);
 8022156:	a80c      	add	r0, sp, #48	; 0x30
        msg.type  = SET_CONNECTABLE ;
 8022158:	f88d 3030 	strb.w	r3, [sp, #48]	; 0x30
        SendMsgToHost(&msg);
 802215c:	f7ff fb7c 	bl	8021858 <SendMsgToHost>
        set_connectable =0;
 8022160:	2300      	movs	r3, #0
 8022162:	f888 3000 	strb.w	r3, [r8]
      if(ButtonPressed) {
 8022166:	f8d4 395c 	ldr.w	r3, [r4, #2396]	; 0x95c
 802216a:	2b00      	cmp	r3, #0
 802216c:	f040 812c 	bne.w	80223c8 <ProcessThread+0x2d0>
      if(SendEnv) {
 8022170:	6863      	ldr	r3, [r4, #4]
 8022172:	2b00      	cmp	r3, #0
 8022174:	f040 8105 	bne.w	8022382 <ProcessThread+0x28a>
      if (SendAudioLevel) {
 8022178:	6963      	ldr	r3, [r4, #20]
 802217a:	2b00      	cmp	r3, #0
 802217c:	f040 80ba 	bne.w	80222f4 <ProcessThread+0x1fc>
      if(RebootBoard) {
 8022180:	f8d4 3960 	ldr.w	r3, [r4, #2400]	; 0x960
 8022184:	2b00      	cmp	r3, #0
 8022186:	f040 80af 	bne.w	80222e8 <ProcessThread+0x1f0>
      if (RunASCEvent) {
 802218a:	f8d4 3938 	ldr.w	r3, [r4, #2360]	; 0x938
 802218e:	2b00      	cmp	r3, #0
 8022190:	f040 8087 	bne.w	80222a2 <ProcessThread+0x1aa>
      if(SendAccGyroMag) {
 8022194:	68e3      	ldr	r3, [r4, #12]
 8022196:	2b00      	cmp	r3, #0
 8022198:	d14b      	bne.n	8022232 <ProcessThread+0x13a>
      if(UpdateMotionAR) {
 802219a:	69e3      	ldr	r3, [r4, #28]
 802219c:	b983      	cbnz	r3, 80221c0 <ProcessThread+0xc8>
      if(SD_CardLogging) {
 802219e:	6a63      	ldr	r3, [r4, #36]	; 0x24
 80221a0:	b94b      	cbnz	r3, 80221b6 <ProcessThread+0xbe>
      if(writeAudio_flag) {
 80221a2:	f899 3000 	ldrb.w	r3, [r9]
 80221a6:	2b00      	cmp	r3, #0
 80221a8:	d0c3      	beq.n	8022132 <ProcessThread+0x3a>
        writeAudio_flag=0;
 80221aa:	2300      	movs	r3, #0
 80221ac:	f889 3000 	strb.w	r3, [r9]
        SdCardAudioRecordingRun();
 80221b0:	f7fc fcaa 	bl	801eb08 <SdCardAudioRecordingRun>
 80221b4:	e7b9      	b.n	802212a <ProcessThread+0x32>
        SD_CardLogging=0;
 80221b6:	2000      	movs	r0, #0
 80221b8:	6260      	str	r0, [r4, #36]	; 0x24
        SdCardMemsRecordingRun(0);
 80221ba:	f7fc fb53 	bl	801e864 <SdCardMemsRecordingRun>
 80221be:	e7f0      	b.n	80221a2 <ProcessThread+0xaa>
  if(HarAlgo != HAR_ALGO_IDX_NONE)
 80221c0:	79ab      	ldrb	r3, [r5, #6]
        UpdateMotionAR=0;
 80221c2:	2200      	movs	r2, #0
  if(HarAlgo != HAR_ALGO_IDX_NONE)
 80221c4:	2bff      	cmp	r3, #255	; 0xff
        UpdateMotionAR=0;
 80221c6:	61e2      	str	r2, [r4, #28]
  if(HarAlgo != HAR_ALGO_IDX_NONE)
 80221c8:	d0e9      	beq.n	802219e <ProcessThread+0xa6>
    MOTION_SENSOR_GetAxesRaw(TargetBoardFeatures.HandleAccSensor,MOTION_ACCELERO,&ACC_Value_Raw);
 80221ca:	4632      	mov	r2, r6
 80221cc:	2102      	movs	r1, #2
 80221ce:	69b8      	ldr	r0, [r7, #24]
 80221d0:	f7ea fbd6 	bl	800c980 <BSP_MOTION_SENSOR_GetAxesRaw>
    ActivityCode =  HAR_run(ACC_Value_Raw,HarAlgo);
 80221d4:	e896 0003 	ldmia.w	r6, {r0, r1}
 80221d8:	79aa      	ldrb	r2, [r5, #6]
 80221da:	f003 fab5 	bl	8025748 <HAR_run>
    if(ActivityCodeStored!=ActivityCode){
 80221de:	f894 394c 	ldrb.w	r3, [r4, #2380]	; 0x94c
 80221e2:	4283      	cmp	r3, r0
    ActivityCode =  HAR_run(ACC_Value_Raw,HarAlgo);
 80221e4:	4601      	mov	r1, r0
    if(ActivityCodeStored!=ActivityCode){
 80221e6:	d0da      	beq.n	802219e <ProcessThread+0xa6>
      if (MultiNN)
 80221e8:	f8d4 3964 	ldr.w	r3, [r4, #2404]	; 0x964
      ActivityCodeStored = ActivityCode;
 80221ec:	f884 094c 	strb.w	r0, [r4, #2380]	; 0x94c
      if (MultiNN)
 80221f0:	2b00      	cmp	r3, #0
 80221f2:	f040 8145 	bne.w	8022480 <ProcessThread+0x388>
         switch (HarAlgo){
 80221f6:	79ab      	ldrb	r3, [r5, #6]
 80221f8:	2b01      	cmp	r3, #1
 80221fa:	f000 8172 	beq.w	80224e2 <ProcessThread+0x3ea>
 80221fe:	2b02      	cmp	r3, #2
 8022200:	f000 816b 	beq.w	80224da <ProcessThread+0x3e2>
 8022204:	2b00      	cmp	r3, #0
 8022206:	f000 8164 	beq.w	80224d2 <ProcessThread+0x3da>
        SendMsgToHost(&msg);
 802220a:	a816      	add	r0, sp, #88	; 0x58
        msg.activity       = ActivityCode ;
 802220c:	f88d 105c 	strb.w	r1, [sp, #92]	; 0x5c
 8022210:	9101      	str	r1, [sp, #4]
        SendMsgToHost(&msg);
 8022212:	f7ff fb21 	bl	8021858 <SendMsgToHost>
        if(W2ST_CHECK_CONNECTION(W2ST_CONNECT_STD_TERM)) {
 8022216:	4b84      	ldr	r3, [pc, #528]	; (8022428 <ProcessThread+0x330>)
 8022218:	9901      	ldr	r1, [sp, #4]
 802221a:	681b      	ldr	r3, [r3, #0]
 802221c:	f013 0f20 	tst.w	r3, #32
 8022220:	f040 814b 	bne.w	80224ba <ProcessThread+0x3c2>
          SENSING1_PRINTF("Sending: AR=%d\r\n",ActivityCode);
 8022224:	782b      	ldrb	r3, [r5, #0]
 8022226:	2b00      	cmp	r3, #0
 8022228:	d0b9      	beq.n	802219e <ProcessThread+0xa6>
 802222a:	4880      	ldr	r0, [pc, #512]	; (802242c <ProcessThread+0x334>)
 802222c:	f005 fef6 	bl	802801c <iprintf>
}
 8022230:	e7b5      	b.n	802219e <ProcessThread+0xa6>
  if(TargetBoardFeatures.HandleAccSensor != SENSING1_SNS_NOT_VALID ) {
 8022232:	69b8      	ldr	r0, [r7, #24]
 8022234:	f242 720f 	movw	r2, #9999	; 0x270f
        SendAccGyroMag=0;
 8022238:	2300      	movs	r3, #0
  if(TargetBoardFeatures.HandleAccSensor != SENSING1_SNS_NOT_VALID ) {
 802223a:	4290      	cmp	r0, r2
        SendAccGyroMag=0;
 802223c:	60e3      	str	r3, [r4, #12]
  if(TargetBoardFeatures.HandleAccSensor != SENSING1_SNS_NOT_VALID ) {
 802223e:	f000 80dc 	beq.w	80223fa <ProcessThread+0x302>
    MOTION_SENSOR_GetAxes(TargetBoardFeatures.HandleAccSensor,MOTION_ACCELERO,&ACC_Value);
 8022242:	aa03      	add	r2, sp, #12
 8022244:	2102      	movs	r1, #2
 8022246:	f7ea fb65 	bl	800c914 <BSP_MOTION_SENSOR_GetAxes>
  if(TargetBoardFeatures.HandleMagSensor != SENSING1_SNS_NOT_VALID ) {
 802224a:	6a38      	ldr	r0, [r7, #32]
 802224c:	f242 730f 	movw	r3, #9999	; 0x270f
 8022250:	4298      	cmp	r0, r3
 8022252:	f000 80cd 	beq.w	80223f0 <ProcessThread+0x2f8>
    MOTION_SENSOR_GetAxes(TargetBoardFeatures.HandleMagSensor,MOTION_MAGNETO,&MAG_Value);
 8022256:	4632      	mov	r2, r6
 8022258:	2104      	movs	r1, #4
 802225a:	f7ea fb5b 	bl	800c914 <BSP_MOTION_SENSOR_GetAxes>
  if(TargetBoardFeatures.HandleGyroSensor != SENSING1_SNS_NOT_VALID ) {
 802225e:	69f8      	ldr	r0, [r7, #28]
 8022260:	f242 730f 	movw	r3, #9999	; 0x270f
 8022264:	4298      	cmp	r0, r3
 8022266:	f000 80be 	beq.w	80223e6 <ProcessThread+0x2ee>
    MOTION_SENSOR_GetAxes(TargetBoardFeatures.HandleGyroSensor,MOTION_GYRO,&GYR_Value);
 802226a:	aa06      	add	r2, sp, #24
 802226c:	2101      	movs	r1, #1
 802226e:	f7ea fb51 	bl	800c914 <BSP_MOTION_SENSOR_GetAxes>
  msg.type        = MOTION;
 8022272:	2306      	movs	r3, #6
 8022274:	f88d 3058 	strb.w	r3, [sp, #88]	; 0x58
  msg.motion.acc  = ACC_Value ;
 8022278:	ab03      	add	r3, sp, #12
 802227a:	e893 0007 	ldmia.w	r3, {r0, r1, r2}
 802227e:	ab17      	add	r3, sp, #92	; 0x5c
 8022280:	e883 0007 	stmia.w	r3, {r0, r1, r2}
  msg.motion.gyr  = GYR_Value;
 8022284:	ab06      	add	r3, sp, #24
 8022286:	e893 0007 	ldmia.w	r3, {r0, r1, r2}
 802228a:	ab1a      	add	r3, sp, #104	; 0x68
 802228c:	e883 0007 	stmia.w	r3, {r0, r1, r2}
  msg.motion.mag  = MAG_Value;
 8022290:	e896 0007 	ldmia.w	r6, {r0, r1, r2}
 8022294:	ab1d      	add	r3, sp, #116	; 0x74
 8022296:	e883 0007 	stmia.w	r3, {r0, r1, r2}
  SendMsgToHost(&msg);
 802229a:	a816      	add	r0, sp, #88	; 0x58
 802229c:	f7ff fadc 	bl	8021858 <SendMsgToHost>
}
 80222a0:	e77b      	b.n	802219a <ProcessThread+0xa2>
        RunASCEvent = 0;
 80222a2:	2300      	movs	r3, #0
  classification_result = ASC_Run(Proc_Buffer_f);
 80222a4:	4862      	ldr	r0, [pc, #392]	; (8022430 <ProcessThread+0x338>)
        RunASCEvent = 0;
 80222a6:	f8c4 3938 	str.w	r3, [r4, #2360]	; 0x938
  classification_result = ASC_Run(Proc_Buffer_f);
 80222aa:	f7fb fb13 	bl	801d8d4 <ASC_Run>
  if (classification_result != ASC_UNDEFINED) {
 80222ae:	28ff      	cmp	r0, #255	; 0xff
  classification_result = ASC_Run(Proc_Buffer_f);
 80222b0:	4602      	mov	r2, r0
  if (classification_result != ASC_UNDEFINED) {
 80222b2:	f43f af6f 	beq.w	8022194 <ProcessThread+0x9c>
    if (ascResultStored != classification_result) {
 80222b6:	786b      	ldrb	r3, [r5, #1]
 80222b8:	4283      	cmp	r3, r0
 80222ba:	f43f af6b 	beq.w	8022194 <ProcessThread+0x9c>
      if (MultiNN)
 80222be:	f8d4 3964 	ldr.w	r3, [r4, #2404]	; 0x964
      ascResultStored = classification_result;
 80222c2:	7068      	strb	r0, [r5, #1]
      if (MultiNN)
 80222c4:	2b00      	cmp	r3, #0
 80222c6:	f000 80c3 	beq.w	8022450 <ProcessThread+0x358>
  SENSING1_PRINTF("<multi %d %d> \r\n",MultiNN_OutStored.harOut,MultiNN_OutStored.ascOut);
 80222ca:	782b      	ldrb	r3, [r5, #0]
    MultiNN_OutStored.ascOut = (ASC_OutputTypeDef)code;
 80222cc:	7168      	strb	r0, [r5, #5]
  msg.type = MULTI_NN;
 80222ce:	210b      	movs	r1, #11
 80222d0:	f88d 1058 	strb.w	r1, [sp, #88]	; 0x58
  SENSING1_PRINTF("<multi %d %d> \r\n",MultiNN_OutStored.harOut,MultiNN_OutStored.ascOut);
 80222d4:	2b00      	cmp	r3, #0
 80222d6:	f040 80eb 	bne.w	80224b0 <ProcessThread+0x3b8>
  msg.multiNN = MultiNN_OutStored ;
 80222da:	88ab      	ldrh	r3, [r5, #4]
 80222dc:	f8ad 305c 	strh.w	r3, [sp, #92]	; 0x5c
  SendMsgToHost(&msg);
 80222e0:	a816      	add	r0, sp, #88	; 0x58
 80222e2:	f7ff fab9 	bl	8021858 <SendMsgToHost>
}
 80222e6:	e755      	b.n	8022194 <ProcessThread+0x9c>
        RebootBoard=0;
 80222e8:	2300      	movs	r3, #0
 80222ea:	f8c4 3960 	str.w	r3, [r4, #2400]	; 0x960
        HAL_NVIC_SystemReset();
 80222ee:	f7ed fb27 	bl	800f940 <HAL_NVIC_SystemReset>
 80222f2:	e74a      	b.n	802218a <ProcessThread+0x92>
        SendAudioLevel = 0;
 80222f4:	2300      	movs	r3, #0
 80222f6:	6163      	str	r3, [r4, #20]
    RMS_Ch[NumberMic] /= (16.0f*MICS_DB_UPDATE_MS);
 80222f8:	edda 6a00 	vldr	s13, [sl]
    DBNOISE_Value_Ch[NumberMic] = (uint16_t)((120.0f - 20 * log10f(32768 * (1 + 0.25f * (TargetBoardFeatures.AudioVolume /*AudioInVolume*/ - 4))) + 10.0f * log10f(RMS_Ch[NumberMic])) * 0.3f + DBNOISE_Value_Old_Ch[NumberMic] * 0.7f);
 80222fc:	6bbb      	ldr	r3, [r7, #56]	; 0x38
    RMS_Ch[NumberMic] /= (16.0f*MICS_DB_UPDATE_MS);
 80222fe:	ee86 7a8b 	vdiv.f32	s14, s13, s22
    DBNOISE_Value_Ch[NumberMic] = (uint16_t)((120.0f - 20 * log10f(32768 * (1 + 0.25f * (TargetBoardFeatures.AudioVolume /*AudioInVolume*/ - 4))) + 10.0f * log10f(RMS_Ch[NumberMic])) * 0.3f + DBNOISE_Value_Old_Ch[NumberMic] * 0.7f);
 8022302:	3b04      	subs	r3, #4
 8022304:	ee00 3a10 	vmov	s0, r3
 8022308:	eebb 0acf 	vcvt.f32.u32	s0, s0, #2
 802230c:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
 8022310:	ee30 0a27 	vadd.f32	s0, s0, s15
    RMS_Ch[NumberMic] /= (16.0f*MICS_DB_UPDATE_MS);
 8022314:	ed8a 7a00 	vstr	s14, [sl]
    DBNOISE_Value_Ch[NumberMic] = (uint16_t)((120.0f - 20 * log10f(32768 * (1 + 0.25f * (TargetBoardFeatures.AudioVolume /*AudioInVolume*/ - 4))) + 10.0f * log10f(RMS_Ch[NumberMic])) * 0.3f + DBNOISE_Value_Old_Ch[NumberMic] * 0.7f);
 8022318:	ee20 0a2a 	vmul.f32	s0, s0, s21
 802231c:	f008 ff32 	bl	802b184 <log10f>
 8022320:	eeb0 8a40 	vmov.f32	s16, s0
 8022324:	ed9a 0a00 	vldr	s0, [sl]
 8022328:	f008 ff2c 	bl	802b184 <log10f>
 802232c:	eef3 7a04 	vmov.f32	s15, #52	; 0x41a00000  20.0
 8022330:	ee28 8a27 	vmul.f32	s16, s16, s15
 8022334:	eef2 7a04 	vmov.f32	s15, #36	; 0x41200000  10.0
 8022338:	ee20 0a27 	vmul.f32	s0, s0, s15
 802233c:	4a3d      	ldr	r2, [pc, #244]	; (8022434 <ProcessThread+0x33c>)
 802233e:	ee7a 7a48 	vsub.f32	s15, s20, s16
 8022342:	ed92 7a00 	vldr	s14, [r2]
    RMS_Ch[NumberMic] = 0.0f;
 8022346:	edca 8a00 	vstr	s17, [sl]
    DBNOISE_Value_Ch[NumberMic] = (uint16_t)((120.0f - 20 * log10f(32768 * (1 + 0.25f * (TargetBoardFeatures.AudioVolume /*AudioInVolume*/ - 4))) + 10.0f * log10f(RMS_Ch[NumberMic])) * 0.3f + DBNOISE_Value_Old_Ch[NumberMic] * 0.7f);
 802234a:	ee77 7a80 	vadd.f32	s15, s15, s0
 802234e:	ee27 7a09 	vmul.f32	s14, s14, s18
 8022352:	ee67 7aa9 	vmul.f32	s15, s15, s19
  msg.type  = AUDIO_LEV;
 8022356:	230c      	movs	r3, #12
    DBNOISE_Value_Ch[NumberMic] = (uint16_t)((120.0f - 20 * log10f(32768 * (1 + 0.25f * (TargetBoardFeatures.AudioVolume /*AudioInVolume*/ - 4))) + 10.0f * log10f(RMS_Ch[NumberMic])) * 0.3f + DBNOISE_Value_Old_Ch[NumberMic] * 0.7f);
 8022358:	ee77 7a87 	vadd.f32	s15, s15, s14
  msg.type  = AUDIO_LEV;
 802235c:	f88d 3058 	strb.w	r3, [sp, #88]	; 0x58
    DBNOISE_Value_Ch[NumberMic] = (uint16_t)((120.0f - 20 * log10f(32768 * (1 + 0.25f * (TargetBoardFeatures.AudioVolume /*AudioInVolume*/ - 4))) + 10.0f * log10f(RMS_Ch[NumberMic])) * 0.3f + DBNOISE_Value_Old_Ch[NumberMic] * 0.7f);
 8022360:	eefc 7ae7 	vcvt.u32.f32	s15, s15
  SendMsgToHost(&msg);
 8022364:	a816      	add	r0, sp, #88	; 0x58
    DBNOISE_Value_Ch[NumberMic] = (uint16_t)((120.0f - 20 * log10f(32768 * (1 + 0.25f * (TargetBoardFeatures.AudioVolume /*AudioInVolume*/ - 4))) + 10.0f * log10f(RMS_Ch[NumberMic])) * 0.3f + DBNOISE_Value_Old_Ch[NumberMic] * 0.7f);
 8022366:	ee17 3a90 	vmov	r3, s15
 802236a:	b29b      	uxth	r3, r3
    DBNOISE_Value_Old_Ch[NumberMic] = DBNOISE_Value_Ch[NumberMic];
 802236c:	ee07 3a90 	vmov	s15, r3
 8022370:	eef8 7a67 	vcvt.f32.u32	s15, s15
  memcpy(&(msg.DBNOISE_Value_Ch),&DBNOISE_Value_Ch,AUDIO_CHANNELS* sizeof(uint16_t));
 8022374:	f8ad 305c 	strh.w	r3, [sp, #92]	; 0x5c
    DBNOISE_Value_Old_Ch[NumberMic] = DBNOISE_Value_Ch[NumberMic];
 8022378:	edc2 7a00 	vstr	s15, [r2]
  SendMsgToHost(&msg);
 802237c:	f7ff fa6c 	bl	8021858 <SendMsgToHost>
}
 8022380:	e6fe      	b.n	8022180 <ProcessThread+0x88>
  if(W2ST_CHECK_CONNECTION(W2ST_CONNECT_ENV)) {
 8022382:	4b29      	ldr	r3, [pc, #164]	; (8022428 <ProcessThread+0x330>)
 8022384:	681b      	ldr	r3, [r3, #0]
        SendEnv=0;
 8022386:	2200      	movs	r2, #0
  if(W2ST_CHECK_CONNECTION(W2ST_CONNECT_ENV)) {
 8022388:	07db      	lsls	r3, r3, #31
        SendEnv=0;
 802238a:	6062      	str	r2, [r4, #4]
  if(W2ST_CHECK_CONNECTION(W2ST_CONNECT_ENV)) {
 802238c:	f57f aef4 	bpl.w	8022178 <ProcessThread+0x80>
    ReadEnvironmentalData(&PressToSend,&HumToSend, &Temp1ToSend,&Temp2ToSend);
 8022390:	4630      	mov	r0, r6
 8022392:	ab03      	add	r3, sp, #12
 8022394:	aa06      	add	r2, sp, #24
 8022396:	f10d 010a 	add.w	r1, sp, #10
 802239a:	f7ff fe09 	bl	8021fb0 <ReadEnvironmentalData>
    msg.env.press = PressToSend;
 802239e:	9b09      	ldr	r3, [sp, #36]	; 0x24
 80223a0:	9317      	str	r3, [sp, #92]	; 0x5c
    msg.env.hum   = HumToSend;
 80223a2:	f8bd 300a 	ldrh.w	r3, [sp, #10]
 80223a6:	f8ad 3060 	strh.w	r3, [sp, #96]	; 0x60
    msg.env.temp2 = Temp2ToSend;
 80223aa:	f8bd 300c 	ldrh.w	r3, [sp, #12]
 80223ae:	f8ad 3062 	strh.w	r3, [sp, #98]	; 0x62
    msg.env.temp1 = Temp1ToSend;
 80223b2:	f8bd 3018 	ldrh.w	r3, [sp, #24]
 80223b6:	f8ad 3064 	strh.w	r3, [sp, #100]	; 0x64
    SendMsgToHost(&msg);
 80223ba:	a816      	add	r0, sp, #88	; 0x58
    msg.type      = ENV;
 80223bc:	2305      	movs	r3, #5
 80223be:	f88d 3058 	strb.w	r3, [sp, #88]	; 0x58
    SendMsgToHost(&msg);
 80223c2:	f7ff fa49 	bl	8021858 <SendMsgToHost>
}
 80223c6:	e6d7      	b.n	8022178 <ProcessThread+0x80>
  SENSING1_PRINTF("UserButton Pressed\r\n");
 80223c8:	782b      	ldrb	r3, [r5, #0]
 80223ca:	2b00      	cmp	r3, #0
 80223cc:	d13c      	bne.n	8022448 <ProcessThread+0x350>
        ButtonPressed=0;
 80223ce:	2300      	movs	r3, #0
 80223d0:	f8c4 395c 	str.w	r3, [r4, #2396]	; 0x95c
 80223d4:	e6cc      	b.n	8022170 <ProcessThread+0x78>
          uint32_t Success = EraseMetaDataManager();
 80223d6:	f7f8 fecf 	bl	801b178 <EraseMetaDataManager>
          if(Success) {
 80223da:	2800      	cmp	r0, #0
 80223dc:	f43f aeba 	beq.w	8022154 <ProcessThread+0x5c>
            SaveMetaDataManager();
 80223e0:	f7f8 fede 	bl	801b1a0 <SaveMetaDataManager>
 80223e4:	e6b6      	b.n	8022154 <ProcessThread+0x5c>
    GYR_Value.x = GYR_Value.y = GYR_Value.z =0;
 80223e6:	2300      	movs	r3, #0
 80223e8:	e9cd 3307 	strd	r3, r3, [sp, #28]
 80223ec:	9306      	str	r3, [sp, #24]
 80223ee:	e740      	b.n	8022272 <ProcessThread+0x17a>
    MAG_Value.x = MAG_Value.y = MAG_Value.z =0;
 80223f0:	2300      	movs	r3, #0
 80223f2:	e9cd 330a 	strd	r3, r3, [sp, #40]	; 0x28
 80223f6:	9309      	str	r3, [sp, #36]	; 0x24
 80223f8:	e731      	b.n	802225e <ProcessThread+0x166>
    ACC_Value.x = ACC_Value.y = ACC_Value.z =0;
 80223fa:	e9cd 3304 	strd	r3, r3, [sp, #16]
 80223fe:	9303      	str	r3, [sp, #12]
 8022400:	e723      	b.n	802224a <ProcessThread+0x152>
 8022402:	bf00      	nop
 8022404:	20012a74 	.word	0x20012a74
 8022408:	20000d84 	.word	0x20000d84
 802240c:	44480000 	.word	0x44480000
 8022410:	47000000 	.word	0x47000000
 8022414:	42f00000 	.word	0x42f00000
 8022418:	3e99999a 	.word	0x3e99999a
 802241c:	200106a4 	.word	0x200106a4
 8022420:	3f333333 	.word	0x3f333333
 8022424:	00000000 	.word	0x00000000
 8022428:	2001457c 	.word	0x2001457c
 802242c:	0804381c 	.word	0x0804381c
 8022430:	20013538 	.word	0x20013538
 8022434:	20010a14 	.word	0x20010a14
 8022438:	20000db9 	.word	0x20000db9
 802243c:	200080e8 	.word	0x200080e8
 8022440:	20010a18 	.word	0x20010a18
 8022444:	2000b574 	.word	0x2000b574
  SENSING1_PRINTF("UserButton Pressed\r\n");
 8022448:	482a      	ldr	r0, [pc, #168]	; (80224f4 <ProcessThread+0x3fc>)
 802244a:	f005 fe83 	bl	8028154 <puts>
 802244e:	e7be      	b.n	80223ce <ProcessThread+0x2d6>
        msg.type       = AUDIO_SC;
 8022450:	2307      	movs	r3, #7
        msg.audio_scene = classification_result;
 8022452:	f88d 005c 	strb.w	r0, [sp, #92]	; 0x5c
 8022456:	9001      	str	r0, [sp, #4]
        SendMsgToHost(&msg);
 8022458:	a816      	add	r0, sp, #88	; 0x58
        msg.type       = AUDIO_SC;
 802245a:	f88d 3058 	strb.w	r3, [sp, #88]	; 0x58
        SendMsgToHost(&msg);
 802245e:	f7ff f9fb 	bl	8021858 <SendMsgToHost>
        if(W2ST_CHECK_CONNECTION(W2ST_CONNECT_STD_TERM)) {
 8022462:	4b25      	ldr	r3, [pc, #148]	; (80224f8 <ProcessThread+0x400>)
 8022464:	9a01      	ldr	r2, [sp, #4]
 8022466:	681b      	ldr	r3, [r3, #0]
 8022468:	f013 0f20 	tst.w	r3, #32
 802246c:	d115      	bne.n	802249a <ProcessThread+0x3a2>
          SENSING1_PRINTF("Sending: ASC=%d\r\n", classification_result);
 802246e:	782b      	ldrb	r3, [r5, #0]
 8022470:	2b00      	cmp	r3, #0
 8022472:	f43f ae8f 	beq.w	8022194 <ProcessThread+0x9c>
 8022476:	4611      	mov	r1, r2
 8022478:	4820      	ldr	r0, [pc, #128]	; (80224fc <ProcessThread+0x404>)
 802247a:	f005 fdcf 	bl	802801c <iprintf>
}
 802247e:	e689      	b.n	8022194 <ProcessThread+0x9c>
  SENSING1_PRINTF("<multi %d %d> \r\n",MultiNN_OutStored.harOut,MultiNN_OutStored.ascOut);
 8022480:	782b      	ldrb	r3, [r5, #0]
    MultiNN_OutStored.harOut = (HAR_output_t)code;
 8022482:	7128      	strb	r0, [r5, #4]
  msg.type = MULTI_NN;
 8022484:	220b      	movs	r2, #11
 8022486:	f88d 2058 	strb.w	r2, [sp, #88]	; 0x58
  SENSING1_PRINTF("<multi %d %d> \r\n",MultiNN_OutStored.harOut,MultiNN_OutStored.ascOut);
 802248a:	bb73      	cbnz	r3, 80224ea <ProcessThread+0x3f2>
  msg.multiNN = MultiNN_OutStored ;
 802248c:	88ab      	ldrh	r3, [r5, #4]
 802248e:	f8ad 305c 	strh.w	r3, [sp, #92]	; 0x5c
  SendMsgToHost(&msg);
 8022492:	a816      	add	r0, sp, #88	; 0x58
 8022494:	f7ff f9e0 	bl	8021858 <SendMsgToHost>
}
 8022498:	e681      	b.n	802219e <ProcessThread+0xa6>
           BytesToWrite = sprintf((char *)BufferToWrite,"Sending: ASC=%d\n", classification_result);
 802249a:	4919      	ldr	r1, [pc, #100]	; (8022500 <ProcessThread+0x408>)
 802249c:	4819      	ldr	r0, [pc, #100]	; (8022504 <ProcessThread+0x40c>)
 802249e:	f005 fe71 	bl	8028184 <siprintf>
 80224a2:	f8c4 0a68 	str.w	r0, [r4, #2664]	; 0xa68
           Term_Update(BufferToWrite,BytesToWrite);
 80224a6:	b2c1      	uxtb	r1, r0
 80224a8:	4816      	ldr	r0, [pc, #88]	; (8022504 <ProcessThread+0x40c>)
 80224aa:	f000 fe01 	bl	80230b0 <Term_Update>
 80224ae:	e671      	b.n	8022194 <ProcessThread+0x9c>
  SENSING1_PRINTF("<multi %d %d> \r\n",MultiNN_OutStored.harOut,MultiNN_OutStored.ascOut);
 80224b0:	7929      	ldrb	r1, [r5, #4]
 80224b2:	4815      	ldr	r0, [pc, #84]	; (8022508 <ProcessThread+0x410>)
 80224b4:	f005 fdb2 	bl	802801c <iprintf>
 80224b8:	e70f      	b.n	80222da <ProcessThread+0x1e2>
           BytesToWrite = sprintf((char *)BufferToWrite,"Sending: AR=%d\n",ActivityCode);
 80224ba:	460a      	mov	r2, r1
 80224bc:	4811      	ldr	r0, [pc, #68]	; (8022504 <ProcessThread+0x40c>)
 80224be:	4913      	ldr	r1, [pc, #76]	; (802250c <ProcessThread+0x414>)
 80224c0:	f005 fe60 	bl	8028184 <siprintf>
 80224c4:	f8c4 0a68 	str.w	r0, [r4, #2664]	; 0xa68
           Term_Update(BufferToWrite,BytesToWrite);
 80224c8:	b2c1      	uxtb	r1, r0
 80224ca:	480e      	ldr	r0, [pc, #56]	; (8022504 <ProcessThread+0x40c>)
 80224cc:	f000 fdf0 	bl	80230b0 <Term_Update>
 80224d0:	e665      	b.n	802219e <ProcessThread+0xa6>
          case HAR_GMP_IDX      : msg.type = ACTIVITY_GMP      ; break;
 80224d2:	2308      	movs	r3, #8
 80224d4:	f88d 3058 	strb.w	r3, [sp, #88]	; 0x58
 80224d8:	e697      	b.n	802220a <ProcessThread+0x112>
          case HAR_IGN_WSDM_IDX : msg.type = ACTIVITY_IGN_WSDM ; break;
 80224da:	230a      	movs	r3, #10
 80224dc:	f88d 3058 	strb.w	r3, [sp, #88]	; 0x58
 80224e0:	e693      	b.n	802220a <ProcessThread+0x112>
          case HAR_IGN_IDX      : msg.type = ACTIVITY_IGN      ; break;
 80224e2:	2309      	movs	r3, #9
 80224e4:	f88d 3058 	strb.w	r3, [sp, #88]	; 0x58
 80224e8:	e68f      	b.n	802220a <ProcessThread+0x112>
  SENSING1_PRINTF("<multi %d %d> \r\n",MultiNN_OutStored.harOut,MultiNN_OutStored.ascOut);
 80224ea:	796a      	ldrb	r2, [r5, #5]
 80224ec:	4806      	ldr	r0, [pc, #24]	; (8022508 <ProcessThread+0x410>)
 80224ee:	f005 fd95 	bl	802801c <iprintf>
 80224f2:	e7cb      	b.n	802248c <ProcessThread+0x394>
 80224f4:	080437bc 	.word	0x080437bc
 80224f8:	2001457c 	.word	0x2001457c
 80224fc:	080437f8 	.word	0x080437f8
 8022500:	080437e4 	.word	0x080437e4
 8022504:	200133dc 	.word	0x200133dc
 8022508:	080437d0 	.word	0x080437d0
 802250c:	0804380c 	.word	0x0804380c

08022510 <SystemClock_Config>:
{
 8022510:	b570      	push	{r4, r5, r6, lr}
  __HAL_RCC_PWR_CLK_ENABLE();
 8022512:	4c2f      	ldr	r4, [pc, #188]	; (80225d0 <SystemClock_Config+0xc0>)
 8022514:	6da3      	ldr	r3, [r4, #88]	; 0x58
 8022516:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 802251a:	65a3      	str	r3, [r4, #88]	; 0x58
 802251c:	6da3      	ldr	r3, [r4, #88]	; 0x58
{
 802251e:	b0ba      	sub	sp, #232	; 0xe8
  __HAL_RCC_PWR_CLK_ENABLE();
 8022520:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 8022524:	9301      	str	r3, [sp, #4]
 8022526:	9b01      	ldr	r3, [sp, #4]
  HAL_PWR_EnableBkUpAccess();
 8022528:	f7ef fcca 	bl	8011ec0 <HAL_PWR_EnableBkUpAccess>
  __HAL_RCC_BACKUPRESET_FORCE();
 802252c:	f8d4 3090 	ldr.w	r3, [r4, #144]	; 0x90
 8022530:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 8022534:	f8c4 3090 	str.w	r3, [r4, #144]	; 0x90
  __HAL_RCC_BACKUPRESET_RELEASE();
 8022538:	f8d4 3090 	ldr.w	r3, [r4, #144]	; 0x90
 802253c:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 8022540:	f8c4 3090 	str.w	r3, [r4, #144]	; 0x90
  __HAL_RCC_LSEDRIVE_CONFIG(RCC_LSEDRIVE_LOW);
 8022544:	f8d4 3090 	ldr.w	r3, [r4, #144]	; 0x90
 8022548:	f023 0318 	bic.w	r3, r3, #24
 802254c:	f8c4 3090 	str.w	r3, [r4, #144]	; 0x90
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_LSE;
 8022550:	2504      	movs	r5, #4
  RCC_OscInitStruct.PLL.PLLState   = RCC_PLL_NONE;
 8022552:	2200      	movs	r2, #0
  RCC_OscInitStruct.LSEState       = RCC_LSE_ON;
 8022554:	2601      	movs	r6, #1
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
 8022556:	a807      	add	r0, sp, #28
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_LSE;
 8022558:	9507      	str	r5, [sp, #28]
  RCC_OscInitStruct.PLL.PLLState   = RCC_PLL_NONE;
 802255a:	9211      	str	r2, [sp, #68]	; 0x44
  RCC_OscInitStruct.LSEState       = RCC_LSE_ON;
 802255c:	9609      	str	r6, [sp, #36]	; 0x24
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
 802255e:	f7f0 f8a9 	bl	80126b4 <HAL_RCC_OscConfig>
 8022562:	b100      	cbz	r0, 8022566 <SystemClock_Config+0x56>
    while(1);
 8022564:	e7fe      	b.n	8022564 <SystemClock_Config+0x54>
  HAL_RCCEx_DisableLSECSS();
 8022566:	4604      	mov	r4, r0
 8022568:	f7f1 fae2 	bl	8013b30 <HAL_RCCEx_DisableLSECSS>
  RCC_OscInitStruct.OscillatorType      = RCC_OSCILLATORTYPE_MSI;
 802256c:	2310      	movs	r3, #16
 802256e:	9307      	str	r3, [sp, #28]
  RCC_OscInitStruct.MSIClockRange       = RCC_MSIRANGE_11;
 8022570:	23b0      	movs	r3, #176	; 0xb0
 8022572:	930f      	str	r3, [sp, #60]	; 0x3c
  RCC_OscInitStruct.PLL.PLLState        = RCC_PLL_ON;
 8022574:	2302      	movs	r3, #2
  RCC_OscInitStruct.PLL.PLLSource       = RCC_PLLSOURCE_MSI;
 8022576:	e9cd 3611 	strd	r3, r6, [sp, #68]	; 0x44
  RCC_OscInitStruct.PLL.PLLM            = 6;
 802257a:	2106      	movs	r1, #6
  RCC_OscInitStruct.PLL.PLLN            = 40;
 802257c:	2228      	movs	r2, #40	; 0x28
  RCC_OscInitStruct.PLL.PLLP            = 7;
 802257e:	2307      	movs	r3, #7
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
 8022580:	a807      	add	r0, sp, #28
  RCC_OscInitStruct.HSICalibrationValue = RCC_MSICALIBRATION_DEFAULT;
 8022582:	940b      	str	r4, [sp, #44]	; 0x2c
  RCC_OscInitStruct.PLL.PLLN            = 40;
 8022584:	e9cd 1213 	strd	r1, r2, [sp, #76]	; 0x4c
  RCC_OscInitStruct.PLL.PLLQ            = 4;
 8022588:	e9cd 3515 	strd	r3, r5, [sp, #84]	; 0x54
  RCC_OscInitStruct.MSIState            = RCC_MSI_ON;
 802258c:	960d      	str	r6, [sp, #52]	; 0x34
  RCC_OscInitStruct.PLL.PLLR            = 4;
 802258e:	9517      	str	r5, [sp, #92]	; 0x5c
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
 8022590:	f7f0 f890 	bl	80126b4 <HAL_RCC_OscConfig>
 8022594:	4604      	mov	r4, r0
 8022596:	b100      	cbz	r0, 802259a <SystemClock_Config+0x8a>
    while(1);
 8022598:	e7fe      	b.n	8022598 <SystemClock_Config+0x88>
  HAL_RCCEx_EnableMSIPLLMode();
 802259a:	f7f1 fad7 	bl	8013b4c <HAL_RCCEx_EnableMSIPLLMode>
  PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_USB;
 802259e:	f44f 5200 	mov.w	r2, #8192	; 0x2000
  PeriphClkInitStruct.UsbClockSelection    = RCC_USBCLKSOURCE_MSI;
 80225a2:	f04f 6340 	mov.w	r3, #201326592	; 0xc000000
  HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct);
 80225a6:	a818      	add	r0, sp, #96	; 0x60
  PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_USB;
 80225a8:	9218      	str	r2, [sp, #96]	; 0x60
  PeriphClkInitStruct.UsbClockSelection    = RCC_USBCLKSOURCE_MSI;
 80225aa:	9333      	str	r3, [sp, #204]	; 0xcc
  HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct);
 80225ac:	f7f0 fd9e 	bl	80130ec <HAL_RCCEx_PeriphCLKConfig>
  RCC_ClkInitStruct.ClockType      = (RCC_CLOCKTYPE_SYSCLK |
 80225b0:	220f      	movs	r2, #15
  RCC_ClkInitStruct.SYSCLKSource   = RCC_SYSCLKSOURCE_PLLCLK;
 80225b2:	2303      	movs	r3, #3
  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_4) != HAL_OK)
 80225b4:	4629      	mov	r1, r5
 80225b6:	a802      	add	r0, sp, #8
  RCC_ClkInitStruct.SYSCLKSource   = RCC_SYSCLKSOURCE_PLLCLK;
 80225b8:	e9cd 2302 	strd	r2, r3, [sp, #8]
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;
 80225bc:	e9cd 4404 	strd	r4, r4, [sp, #16]
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
 80225c0:	9406      	str	r4, [sp, #24]
  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_4) != HAL_OK)
 80225c2:	f7f0 fb43 	bl	8012c4c <HAL_RCC_ClockConfig>
 80225c6:	b908      	cbnz	r0, 80225cc <SystemClock_Config+0xbc>
}
 80225c8:	b03a      	add	sp, #232	; 0xe8
 80225ca:	bd70      	pop	{r4, r5, r6, pc}
    while(1);
 80225cc:	e7fe      	b.n	80225cc <SystemClock_Config+0xbc>
 80225ce:	bf00      	nop
 80225d0:	40021000 	.word	0x40021000

080225d4 <main>:
{
 80225d4:	b580      	push	{r7, lr}
    SENSING1_PRINTF("\r\n------------------------------------------------------------\r\n");
 80225d6:	4db0      	ldr	r5, [pc, #704]	; (8022898 <main+0x2c4>)
{
 80225d8:	b088      	sub	sp, #32
  HAL_Init();
 80225da:	f7ed f911 	bl	800f800 <HAL_Init>
  SystemClock_Config();
 80225de:	f7ff ff97 	bl	8022510 <SystemClock_Config>
  initPowerController();
 80225e2:	f7fc fe25 	bl	801f230 <initPowerController>
  InitTargetPlatform(TARGET_IOT01A1);
 80225e6:	2002      	movs	r0, #2
 80225e8:	f7fc fff4 	bl	801f5d4 <InitTargetPlatform>
    SENSING1_PRINTF("\r\n------------------------------------------------------------\r\n");
 80225ec:	782b      	ldrb	r3, [r5, #0]
 80225ee:	2b00      	cmp	r3, #0
 80225f0:	f040 80c8 	bne.w	8022784 <main+0x1b0>
 InitMetaDataManager((void *)&known_MetaData,MDM_DATA_TYPE_GMD,NULL);
 80225f4:	48a9      	ldr	r0, [pc, #676]	; (802289c <main+0x2c8>)
  MDM_ReCallGMD(GMD_NODE_NAME,(void *)&NodeName);
 80225f6:	4caa      	ldr	r4, [pc, #680]	; (80228a0 <main+0x2cc>)
 InitMetaDataManager((void *)&known_MetaData,MDM_DATA_TYPE_GMD,NULL);
 80225f8:	2200      	movs	r2, #0
 80225fa:	2101      	movs	r1, #1
 80225fc:	f7f8 fad0 	bl	801aba0 <InitMetaDataManager>
  const char DefaultBoardName[7] = {NAME_BLUEMS};
 8022600:	4ba8      	ldr	r3, [pc, #672]	; (80228a4 <main+0x2d0>)
 8022602:	e893 0003 	ldmia.w	r3, {r0, r1}
 8022606:	0c0b      	lsrs	r3, r1, #16
 8022608:	9006      	str	r0, [sp, #24]
 802260a:	f8ad 101c 	strh.w	r1, [sp, #28]
  MDM_ReCallGMD(GMD_NODE_NAME,(void *)&NodeName);
 802260e:	2008      	movs	r0, #8
 8022610:	f604 216c 	addw	r1, r4, #2668	; 0xa6c
  const char DefaultBoardName[7] = {NAME_BLUEMS};
 8022614:	f88d 301e 	strb.w	r3, [sp, #30]
  MDM_ReCallGMD(GMD_NODE_NAME,(void *)&NodeName);
 8022618:	f7f8 fe16 	bl	801b248 <MDM_ReCallGMD>
  if(NodeName[0] != 0x12) {
 802261c:	f894 3a6c 	ldrb.w	r3, [r4, #2668]	; 0xa6c
 8022620:	2b12      	cmp	r3, #18
 8022622:	d015      	beq.n	8022650 <main+0x7c>
      NodeName[i+1]= DefaultBoardName[i];
 8022624:	9806      	ldr	r0, [sp, #24]
 8022626:	f8bd 101c 	ldrh.w	r1, [sp, #28]
 802262a:	f89d 201e 	ldrb.w	r2, [sp, #30]
 802262e:	f8c4 0a6d 	str.w	r0, [r4, #2669]	; 0xa6d
    NodeName[0]= 0x12;
 8022632:	2012      	movs	r0, #18
 8022634:	f884 0a6c 	strb.w	r0, [r4, #2668]	; 0xa6c
      NodeName[i+1]= DefaultBoardName[i];
 8022638:	f8a4 1a71 	strh.w	r1, [r4, #2673]	; 0xa71
 802263c:	f884 2a73 	strb.w	r2, [r4, #2675]	; 0xa73
    MDM_SaveGMD(GMD_NODE_NAME,(void *)&NodeName);
 8022640:	f604 216c 	addw	r1, r4, #2668	; 0xa6c
 8022644:	2008      	movs	r0, #8
 8022646:	f7f8 fdcb 	bl	801b1e0 <MDM_SaveGMD>
    NecessityToSaveMetaDataManager=1;
 802264a:	4b97      	ldr	r3, [pc, #604]	; (80228a8 <main+0x2d4>)
 802264c:	2201      	movs	r2, #1
 802264e:	601a      	str	r2, [r3, #0]
char BoardName[8] = {'C','H','I','P','H','E','D','\0'};
 8022650:	4b96      	ldr	r3, [pc, #600]	; (80228ac <main+0x2d8>)
 8022652:	e893 0003 	ldmia.w	r3, {r0, r1}
 8022656:	4b96      	ldr	r3, [pc, #600]	; (80228b0 <main+0x2dc>)
      NodeName[i+1]= DefaultBoardName[i];
 8022658:	ae06      	add	r6, sp, #24
char BoardName[8] = {'C','H','I','P','H','E','D','\0'};
 802265a:	e886 0003 	stmia.w	r6, {r0, r1}
 802265e:	2243      	movs	r2, #67	; 0x43
 8022660:	f10d 0119 	add.w	r1, sp, #25
 8022664:	1dd8      	adds	r0, r3, #7
 8022666:	e001      	b.n	802266c <main+0x98>
	  NodeName[i+1] = BoardName[i]; //BoardName[i]= NodeName[i+1];
 8022668:	f811 2b01 	ldrb.w	r2, [r1], #1
 802266c:	f803 2b01 	strb.w	r2, [r3], #1
  for(int i=0; i<7; i++) {
 8022670:	4283      	cmp	r3, r0
 8022672:	d1f9      	bne.n	8022668 <main+0x94>
  hci_init(HCI_Event_CB, NULL);
 8022674:	2100      	movs	r1, #0
 8022676:	488f      	ldr	r0, [pc, #572]	; (80228b4 <main+0x2e0>)
 8022678:	f7f9 fa0e 	bl	801ba98 <hci_init>
  hci_reset();
 802267c:	f7f9 f9c4 	bl	801ba08 <hci_reset>
   ret = aci_hal_read_config_data(CONFIG_DATA_RANDOM_ADDRESS, 6, &data_len_out, bdaddr);
 8022680:	4b8d      	ldr	r3, [pc, #564]	; (80228b8 <main+0x2e4>)
 8022682:	f10d 0216 	add.w	r2, sp, #22
 8022686:	2106      	movs	r1, #6
 8022688:	2080      	movs	r0, #128	; 0x80
 802268a:	f7f9 f943 	bl	801b914 <aci_hal_read_config_data>
    if(ret){
 802268e:	2800      	cmp	r0, #0
 8022690:	d05b      	beq.n	802274a <main+0x176>
      SENSING1_PRINTF("\r\nReading  Random BD_ADDR failed\r\n");
 8022692:	782b      	ldrb	r3, [r5, #0]
 8022694:	2b00      	cmp	r3, #0
 8022696:	f040 80be 	bne.w	8022816 <main+0x242>
  ret = Add_HW_SW_ServW2ST_Service();
 802269a:	f000 fe49 	bl	8023330 <Add_HW_SW_ServW2ST_Service>
     SENSING1_PRINTF("HW & SW Service W2ST added successfully\r\n");
 802269e:	782b      	ldrb	r3, [r5, #0]
  if(ret == BLE_STATUS_SUCCESS) {
 80226a0:	2800      	cmp	r0, #0
 80226a2:	d04c      	beq.n	802273e <main+0x16a>
     SENSING1_PRINTF("\r\nError while adding HW & SW Service W2ST\r\n");
 80226a4:	2b00      	cmp	r3, #0
 80226a6:	f040 80d4 	bne.w	8022852 <main+0x27e>
  ret = Add_ConsoleW2ST_Service();
 80226aa:	f000 fbc5 	bl	8022e38 <Add_ConsoleW2ST_Service>
     SENSING1_PRINTF("Console Service W2ST added successfully\r\n");
 80226ae:	782b      	ldrb	r3, [r5, #0]
  if(ret == BLE_STATUS_SUCCESS) {
 80226b0:	2800      	cmp	r0, #0
 80226b2:	d161      	bne.n	8022778 <main+0x1a4>
     SENSING1_PRINTF("Console Service W2ST added successfully\r\n");
 80226b4:	2b00      	cmp	r3, #0
 80226b6:	f040 80c8 	bne.w	802284a <main+0x276>
  ret = Add_ConfigW2ST_Service();
 80226ba:	f000 fb41 	bl	8022d40 <Add_ConfigW2ST_Service>
     SENSING1_PRINTF("Config  Service W2ST added successfully\r\n");
 80226be:	782b      	ldrb	r3, [r5, #0]
  if(ret == BLE_STATUS_SUCCESS) {
 80226c0:	2800      	cmp	r0, #0
 80226c2:	d153      	bne.n	802276c <main+0x198>
     SENSING1_PRINTF("Config  Service W2ST added successfully\r\n");
 80226c4:	2b00      	cmp	r3, #0
 80226c6:	f040 80bc 	bne.w	8022842 <main+0x26e>
  if(CheckBootLoaderCompliance()) {
 80226ca:	f7fc fbdf 	bl	801ee8c <CheckBootLoaderCompliance>
    SENSING1_PRINTF("BootLoader Compliant with FOTA\r\n");
 80226ce:	782b      	ldrb	r3, [r5, #0]
  if(CheckBootLoaderCompliance()) {
 80226d0:	2800      	cmp	r0, #0
 80226d2:	d045      	beq.n	8022760 <main+0x18c>
    SENSING1_PRINTF("BootLoader Compliant with FOTA\r\n");
 80226d4:	2b00      	cmp	r3, #0
 80226d6:	f040 80b0 	bne.w	802283a <main+0x266>
  SENSING1_PRINTF_FLUSH();
 80226da:	4b78      	ldr	r3, [pc, #480]	; (80228bc <main+0x2e8>)
 80226dc:	681b      	ldr	r3, [r3, #0]
 80226de:	6898      	ldr	r0, [r3, #8]
 80226e0:	f004 fdd2 	bl	8027288 <fflush>
  osThreadCreate(osThread(THREAD_1), NULL);
 80226e4:	2100      	movs	r1, #0
 80226e6:	4876      	ldr	r0, [pc, #472]	; (80228c0 <main+0x2ec>)
 80226e8:	f7f6 f8d0 	bl	801888c <osThreadCreate>
  osThreadCreate(osThread(THREAD_2), NULL);
 80226ec:	2100      	movs	r1, #0
 80226ee:	4875      	ldr	r0, [pc, #468]	; (80228c4 <main+0x2f0>)
 80226f0:	f7f6 f8cc 	bl	801888c <osThreadCreate>
  osThreadCreate(osThread(THREAD_3), NULL);
 80226f4:	2100      	movs	r1, #0
 80226f6:	4874      	ldr	r0, [pc, #464]	; (80228c8 <main+0x2f4>)
 80226f8:	f7f6 f8c8 	bl	801888c <osThreadCreate>
  RegisterCLICommands();
 80226fc:	f7fe fcd2 	bl	80210a4 <RegisterCLICommands>
  semRun = osSemaphoreCreate(osSemaphore(SEM_Sm1), 1);
 8022700:	2101      	movs	r1, #1
 8022702:	4872      	ldr	r0, [pc, #456]	; (80228cc <main+0x2f8>)
 8022704:	f7f6 f96c 	bl	80189e0 <osSemaphoreCreate>
  semRxChar = osSemaphoreCreate(osSemaphore(SEM_Sm2), 1);
 8022708:	2101      	movs	r1, #1
  semRun = osSemaphoreCreate(osSemaphore(SEM_Sm1), 1);
 802270a:	4603      	mov	r3, r0
  semRxChar = osSemaphoreCreate(osSemaphore(SEM_Sm2), 1);
 802270c:	4870      	ldr	r0, [pc, #448]	; (80228d0 <main+0x2fc>)
  semRun = osSemaphoreCreate(osSemaphore(SEM_Sm1), 1);
 802270e:	62a3      	str	r3, [r4, #40]	; 0x28
  semRxChar = osSemaphoreCreate(osSemaphore(SEM_Sm2), 1);
 8022710:	f7f6 f966 	bl	80189e0 <osSemaphoreCreate>
  semUart = osSemaphoreCreate(osSemaphore(SEM_Sm3), 1);
 8022714:	2101      	movs	r1, #1
  semRxChar = osSemaphoreCreate(osSemaphore(SEM_Sm2), 1);
 8022716:	4603      	mov	r3, r0
  semUart = osSemaphoreCreate(osSemaphore(SEM_Sm3), 1);
 8022718:	486e      	ldr	r0, [pc, #440]	; (80228d4 <main+0x300>)
  semRxChar = osSemaphoreCreate(osSemaphore(SEM_Sm2), 1);
 802271a:	62e3      	str	r3, [r4, #44]	; 0x2c
  semUart = osSemaphoreCreate(osSemaphore(SEM_Sm3), 1);
 802271c:	f7f6 f960 	bl	80189e0 <osSemaphoreCreate>
  mail = osMailCreate(osMailQ(mail), NULL);
 8022720:	2100      	movs	r1, #0
  semUart = osSemaphoreCreate(osSemaphore(SEM_Sm3), 1);
 8022722:	4603      	mov	r3, r0
  mail = osMailCreate(osMailQ(mail), NULL);
 8022724:	486c      	ldr	r0, [pc, #432]	; (80228d8 <main+0x304>)
  semUart = osSemaphoreCreate(osSemaphore(SEM_Sm3), 1);
 8022726:	6323      	str	r3, [r4, #48]	; 0x30
  mail = osMailCreate(osMailQ(mail), NULL);
 8022728:	f7f6 fa3e 	bl	8018ba8 <osMailCreate>
 802272c:	4603      	mov	r3, r0
  SetMinPowerMode(IDLE_SLEEP_STOP);
 802272e:	2003      	movs	r0, #3
  mail = osMailCreate(osMailQ(mail), NULL);
 8022730:	f8c4 3944 	str.w	r3, [r4, #2372]	; 0x944
  SetMinPowerMode(IDLE_SLEEP_STOP);
 8022734:	f7fc fd62 	bl	801f1fc <SetMinPowerMode>
  osKernelStart();
 8022738:	f7f6 f8a2 	bl	8018880 <osKernelStart>
  for (;;);
 802273c:	e7fe      	b.n	802273c <main+0x168>
     SENSING1_PRINTF("HW & SW Service W2ST added successfully\r\n");
 802273e:	2b00      	cmp	r3, #0
 8022740:	d0b3      	beq.n	80226aa <main+0xd6>
 8022742:	4866      	ldr	r0, [pc, #408]	; (80228dc <main+0x308>)
 8022744:	f005 fd06 	bl	8028154 <puts>
 8022748:	e7af      	b.n	80226aa <main+0xd6>
  ret = aci_gatt_init();
 802274a:	f7f8 ffad 	bl	801b6a8 <aci_gatt_init>
  if(ret){
 802274e:	2800      	cmp	r0, #0
 8022750:	d04c      	beq.n	80227ec <main+0x218>
     SENSING1_PRINTF("\r\nGATT_Init failed\r\n");
 8022752:	782b      	ldrb	r3, [r5, #0]
 8022754:	2b00      	cmp	r3, #0
 8022756:	d0a0      	beq.n	802269a <main+0xc6>
 8022758:	4861      	ldr	r0, [pc, #388]	; (80228e0 <main+0x30c>)
 802275a:	f005 fcfb 	bl	8028154 <puts>
 802275e:	e79c      	b.n	802269a <main+0xc6>
    SENSING1_PRINTF("ERROR: BootLoader NOT Compliant with FOTA\r\n");
 8022760:	2b00      	cmp	r3, #0
 8022762:	d0ba      	beq.n	80226da <main+0x106>
 8022764:	485f      	ldr	r0, [pc, #380]	; (80228e4 <main+0x310>)
 8022766:	f005 fcf5 	bl	8028154 <puts>
 802276a:	e7b6      	b.n	80226da <main+0x106>
     SENSING1_PRINTF("\r\nError while adding Config Service W2ST\r\n");
 802276c:	2b00      	cmp	r3, #0
 802276e:	d0ac      	beq.n	80226ca <main+0xf6>
 8022770:	485d      	ldr	r0, [pc, #372]	; (80228e8 <main+0x314>)
 8022772:	f005 fcef 	bl	8028154 <puts>
 8022776:	e7a8      	b.n	80226ca <main+0xf6>
     SENSING1_PRINTF("\r\nError while adding Console Service W2ST\r\n");
 8022778:	2b00      	cmp	r3, #0
 802277a:	d09e      	beq.n	80226ba <main+0xe6>
 802277c:	485b      	ldr	r0, [pc, #364]	; (80228ec <main+0x318>)
 802277e:	f005 fce9 	bl	8028154 <puts>
 8022782:	e79a      	b.n	80226ba <main+0xe6>
    SENSING1_PRINTF("\r\n------------------------------------------------------------\r\n");
 8022784:	485a      	ldr	r0, [pc, #360]	; (80228f0 <main+0x31c>)
 8022786:	f005 fce5 	bl	8028154 <puts>
    SENSING1_PRINTF("STMicroelectronics %s\r\n"
 802278a:	782b      	ldrb	r3, [r5, #0]
 802278c:	2b00      	cmp	r3, #0
 802278e:	f43f af31 	beq.w	80225f4 <main+0x20>
 8022792:	2333      	movs	r3, #51	; 0x33
 8022794:	9300      	str	r3, [sp, #0]
 8022796:	4957      	ldr	r1, [pc, #348]	; (80228f4 <main+0x320>)
 8022798:	4857      	ldr	r0, [pc, #348]	; (80228f8 <main+0x324>)
 802279a:	2330      	movs	r3, #48	; 0x30
 802279c:	2234      	movs	r2, #52	; 0x34
 802279e:	f005 fc3d 	bl	802801c <iprintf>
    SENSING1_PRINTF("\t(HAL %ld.%ld.%ld_%ld)\r\n\tCompiled %s %s"
 80227a2:	782b      	ldrb	r3, [r5, #0]
 80227a4:	2b00      	cmp	r3, #0
 80227a6:	f43f af25 	beq.w	80225f4 <main+0x20>
 80227aa:	f7ed f84b 	bl	800f844 <HAL_GetHalVersion>
 80227ae:	4604      	mov	r4, r0
 80227b0:	f7ed f848 	bl	800f844 <HAL_GetHalVersion>
 80227b4:	4606      	mov	r6, r0
 80227b6:	f7ed f845 	bl	800f844 <HAL_GetHalVersion>
 80227ba:	4607      	mov	r7, r0
 80227bc:	f7ed f842 	bl	800f844 <HAL_GetHalVersion>
 80227c0:	0e21      	lsrs	r1, r4, #24
 80227c2:	4c4e      	ldr	r4, [pc, #312]	; (80228fc <main+0x328>)
 80227c4:	9402      	str	r4, [sp, #8]
 80227c6:	b2c0      	uxtb	r0, r0
 80227c8:	4c4d      	ldr	r4, [pc, #308]	; (8022900 <main+0x32c>)
 80227ca:	9000      	str	r0, [sp, #0]
 80227cc:	f3c7 2307 	ubfx	r3, r7, #8, #8
 80227d0:	484c      	ldr	r0, [pc, #304]	; (8022904 <main+0x330>)
 80227d2:	9401      	str	r4, [sp, #4]
 80227d4:	f3c6 4207 	ubfx	r2, r6, #16, #8
 80227d8:	f005 fc20 	bl	802801c <iprintf>
  SENSING1_PRINTF("------------------------------------------------------------\r\n");
 80227dc:	782b      	ldrb	r3, [r5, #0]
 80227de:	2b00      	cmp	r3, #0
 80227e0:	f43f af08 	beq.w	80225f4 <main+0x20>
 80227e4:	4848      	ldr	r0, [pc, #288]	; (8022908 <main+0x334>)
 80227e6:	f005 fcb5 	bl	8028154 <puts>
 80227ea:	e703      	b.n	80225f4 <main+0x20>
  ret = aci_gap_init_IDB05A1(GAP_PERIPHERAL_ROLE_IDB05A1, 0, 0x07, &service_handle, &dev_name_char_handle, &appearance_char_handle);
 80227ec:	f10d 0316 	add.w	r3, sp, #22
 80227f0:	9301      	str	r3, [sp, #4]
 80227f2:	ab05      	add	r3, sp, #20
 80227f4:	9300      	str	r3, [sp, #0]
 80227f6:	4601      	mov	r1, r0
 80227f8:	f10d 0312 	add.w	r3, sp, #18
 80227fc:	2207      	movs	r2, #7
 80227fe:	2001      	movs	r0, #1
 8022800:	f7f8 fe4c 	bl	801b49c <aci_gap_init_IDB05A1>
  if(ret != BLE_STATUS_SUCCESS){
 8022804:	b158      	cbz	r0, 802281e <main+0x24a>
     SENSING1_PRINTF("\r\nGAP_Init failed\r\n");
 8022806:	782b      	ldrb	r3, [r5, #0]
 8022808:	2b00      	cmp	r3, #0
 802280a:	f43f af46 	beq.w	802269a <main+0xc6>
 802280e:	483f      	ldr	r0, [pc, #252]	; (802290c <main+0x338>)
 8022810:	f005 fca0 	bl	8028154 <puts>
 8022814:	e741      	b.n	802269a <main+0xc6>
      SENSING1_PRINTF("\r\nReading  Random BD_ADDR failed\r\n");
 8022816:	483e      	ldr	r0, [pc, #248]	; (8022910 <main+0x33c>)
 8022818:	f005 fc9c 	bl	8028154 <puts>
      goto fail;
 802281c:	e73d      	b.n	802269a <main+0xc6>
  ret = aci_gatt_update_char_value(service_handle, dev_name_char_handle, 0,
 802281e:	4602      	mov	r2, r0
 8022820:	f8bd 1014 	ldrh.w	r1, [sp, #20]
 8022824:	f8bd 0012 	ldrh.w	r0, [sp, #18]
 8022828:	9600      	str	r6, [sp, #0]
 802282a:	2307      	movs	r3, #7
 802282c:	f7f9 f820 	bl	801b870 <aci_gatt_update_char_value>
  if(ret){
 8022830:	4602      	mov	r2, r0
 8022832:	b1b0      	cbz	r0, 8022862 <main+0x28e>
     SENSING1_PRINTF("\r\naci_gatt_update_char_value failed\r\n");
 8022834:	782b      	ldrb	r3, [r5, #0]
 8022836:	b983      	cbnz	r3, 802285a <main+0x286>
    while(1);
 8022838:	e7fe      	b.n	8022838 <main+0x264>
    SENSING1_PRINTF("BootLoader Compliant with FOTA\r\n");
 802283a:	4836      	ldr	r0, [pc, #216]	; (8022914 <main+0x340>)
 802283c:	f005 fc8a 	bl	8028154 <puts>
 8022840:	e74b      	b.n	80226da <main+0x106>
     SENSING1_PRINTF("Config  Service W2ST added successfully\r\n");
 8022842:	4835      	ldr	r0, [pc, #212]	; (8022918 <main+0x344>)
 8022844:	f005 fc86 	bl	8028154 <puts>
 8022848:	e73f      	b.n	80226ca <main+0xf6>
     SENSING1_PRINTF("Console Service W2ST added successfully\r\n");
 802284a:	4834      	ldr	r0, [pc, #208]	; (802291c <main+0x348>)
 802284c:	f005 fc82 	bl	8028154 <puts>
 8022850:	e733      	b.n	80226ba <main+0xe6>
     SENSING1_PRINTF("\r\nError while adding HW & SW Service W2ST\r\n");
 8022852:	4833      	ldr	r0, [pc, #204]	; (8022920 <main+0x34c>)
 8022854:	f005 fc7e 	bl	8028154 <puts>
 8022858:	e727      	b.n	80226aa <main+0xd6>
     SENSING1_PRINTF("\r\naci_gatt_update_char_value failed\r\n");
 802285a:	4832      	ldr	r0, [pc, #200]	; (8022924 <main+0x350>)
 802285c:	f005 fc7a 	bl	8028154 <puts>
 8022860:	e7ea      	b.n	8022838 <main+0x264>
  ret = aci_gap_set_auth_requirement(MITM_PROTECTION_REQUIRED,
 8022862:	4b31      	ldr	r3, [pc, #196]	; (8022928 <main+0x354>)
 8022864:	9302      	str	r3, [sp, #8]
 8022866:	2001      	movs	r0, #1
 8022868:	2310      	movs	r3, #16
 802286a:	9300      	str	r3, [sp, #0]
 802286c:	9003      	str	r0, [sp, #12]
 802286e:	2307      	movs	r3, #7
 8022870:	9201      	str	r2, [sp, #4]
 8022872:	4611      	mov	r1, r2
 8022874:	f7f8 feb0 	bl	801b5d8 <aci_gap_set_auth_requirement>
     SENSING1_PRINTF("\r\nGAP setting Authentication failed\r\n");
 8022878:	782b      	ldrb	r3, [r5, #0]
  if (ret != BLE_STATUS_SUCCESS) {
 802287a:	b930      	cbnz	r0, 802288a <main+0x2b6>
  SENSING1_PRINTF("\r\nSERVER: BLE Stack Initialized \r\n"
 802287c:	2b00      	cmp	r3, #0
 802287e:	d157      	bne.n	8022930 <main+0x35c>
  aci_hal_set_tx_power_level(1,4); /* -2,1 dBm */
 8022880:	2104      	movs	r1, #4
 8022882:	2001      	movs	r0, #1
 8022884:	f7f9 f878 	bl	801b978 <aci_hal_set_tx_power_level>
  return;
 8022888:	e707      	b.n	802269a <main+0xc6>
     SENSING1_PRINTF("\r\nGAP setting Authentication failed\r\n");
 802288a:	2b00      	cmp	r3, #0
 802288c:	f43f af05 	beq.w	802269a <main+0xc6>
 8022890:	4826      	ldr	r0, [pc, #152]	; (802292c <main+0x358>)
 8022892:	f005 fc5f 	bl	8028154 <puts>
 8022896:	e700      	b.n	802269a <main+0xc6>
 8022898:	20000d84 	.word	0x20000d84
 802289c:	20000d8c 	.word	0x20000d8c
 80228a0:	20012a74 	.word	0x20012a74
 80228a4:	08043b84 	.word	0x08043b84
 80228a8:	200080e8 	.word	0x200080e8
 80228ac:	08043b8c 	.word	0x08043b8c
 80228b0:	200134e1 	.word	0x200134e1
 80228b4:	08023c39 	.word	0x08023c39
 80228b8:	200134e8 	.word	0x200134e8
 80228bc:	20002020 	.word	0x20002020
 80228c0:	08039b54 	.word	0x08039b54
 80228c4:	08039b68 	.word	0x08039b68
 80228c8:	08039b7c 	.word	0x08039b7c
 80228cc:	08039b90 	.word	0x08039b90
 80228d0:	08039b94 	.word	0x08039b94
 80228d4:	08039b98 	.word	0x08039b98
 80228d8:	08039b9c 	.word	0x08039b9c
 80228dc:	08043a30 	.word	0x08043a30
 80228e0:	08043958 	.word	0x08043958
 80228e4:	08043b58 	.word	0x08043b58
 80228e8:	08043b0c 	.word	0x08043b0c
 80228ec:	08043ab4 	.word	0x08043ab4
 80228f0:	08043830 	.word	0x08043830
 80228f4:	08042f18 	.word	0x08042f18
 80228f8:	08043870 	.word	0x08043870
 80228fc:	080438e8 	.word	0x080438e8
 8022900:	08042fb4 	.word	0x08042fb4
 8022904:	080438b8 	.word	0x080438b8
 8022908:	080438f4 	.word	0x080438f4
 802290c:	0804396c 	.word	0x0804396c
 8022910:	08043934 	.word	0x08043934
 8022914:	08043b38 	.word	0x08043b38
 8022918:	08043ae0 	.word	0x08043ae0
 802291c:	08043a88 	.word	0x08043a88
 8022920:	08043a5c 	.word	0x08043a5c
 8022924:	08043980 	.word	0x08043980
 8022928:	0001e240 	.word	0x0001e240
 802292c:	080439a8 	.word	0x080439a8
  SENSING1_PRINTF("\r\nSERVER: BLE Stack Initialized \r\n"
 8022930:	f894 2a74 	ldrb.w	r2, [r4, #2676]	; 0xa74
 8022934:	f894 3a75 	ldrb.w	r3, [r4, #2677]	; 0xa75
 8022938:	4808      	ldr	r0, [pc, #32]	; (802295c <main+0x388>)
 802293a:	e9cd 3202 	strd	r3, r2, [sp, #8]
 802293e:	f894 2a76 	ldrb.w	r2, [r4, #2678]	; 0xa76
 8022942:	f894 3a77 	ldrb.w	r3, [r4, #2679]	; 0xa77
 8022946:	e9cd 3200 	strd	r3, r2, [sp]
 802294a:	4631      	mov	r1, r6
 802294c:	f894 3a78 	ldrb.w	r3, [r4, #2680]	; 0xa78
 8022950:	f894 2a79 	ldrb.w	r2, [r4, #2681]	; 0xa79
 8022954:	f005 fb62 	bl	802801c <iprintf>
 8022958:	e792      	b.n	8022880 <main+0x2ac>
 802295a:	bf00      	nop
 802295c:	080439d0 	.word	0x080439d0

08022960 <MX_DFSDM1_ClockConfig>:
{
 8022960:	b510      	push	{r4, lr}
 8022962:	b0a2      	sub	sp, #136	; 0x88
  HAL_RCCEx_GetPeriphCLKConfig(&RCC_ExCLKInitStruct);
 8022964:	4668      	mov	r0, sp
 8022966:	f7f0 fde1 	bl	801352c <HAL_RCCEx_GetPeriphCLKConfig>
  RCC_ExCLKInitStruct.PLLSAI1.PLLSAI1M        = 6;
 802296a:	2406      	movs	r4, #6
  RCC_ExCLKInitStruct.PeriphClockSelection    = RCC_PERIPHCLK_SAI1;
 802296c:	f44f 6100 	mov.w	r1, #2048	; 0x800
  RCC_ExCLKInitStruct.PLLSAI1.PLLSAI1Source   = RCC_PLLSOURCE_MSI;
 8022970:	2201      	movs	r2, #1
  RCC_ExCLKInitStruct.PLLSAI1.PLLSAI1N        = 43;
 8022972:	232b      	movs	r3, #43	; 0x2b
  RCC_ExCLKInitStruct.PLLSAI1.PLLSAI1Source   = RCC_PLLSOURCE_MSI;
 8022974:	e9cd 1200 	strd	r1, r2, [sp]
  RCC_ExCLKInitStruct.PLLSAI1.PLLSAI1N        = 43;
 8022978:	e9cd 4302 	strd	r4, r3, [sp, #8]
  RCC_ExCLKInitStruct.PLLSAI1.PLLSAI1P        = 7;
 802297c:	2107      	movs	r1, #7
  RCC_ExCLKInitStruct.PLLSAI1.PLLSAI1ClockOut = RCC_PLLSAI1_SAI1CLK;
 802297e:	f44f 3280 	mov.w	r2, #65536	; 0x10000
  RCC_ExCLKInitStruct.Sai1ClockSelection      = RCC_SAI1CLKSOURCE_PLLSAI1;
 8022982:	2300      	movs	r3, #0
  status = HAL_RCCEx_PeriphCLKConfig(&RCC_ExCLKInitStruct);
 8022984:	4668      	mov	r0, sp
  RCC_ExCLKInitStruct.PLLSAI1.PLLSAI1P        = 7;
 8022986:	9104      	str	r1, [sp, #16]
  RCC_ExCLKInitStruct.PLLSAI1.PLLSAI1ClockOut = RCC_PLLSAI1_SAI1CLK;
 8022988:	9207      	str	r2, [sp, #28]
  RCC_ExCLKInitStruct.Sai1ClockSelection      = RCC_SAI1CLKSOURCE_PLLSAI1;
 802298a:	9319      	str	r3, [sp, #100]	; 0x64
  status = HAL_RCCEx_PeriphCLKConfig(&RCC_ExCLKInitStruct);
 802298c:	f7f0 fbae 	bl	80130ec <HAL_RCCEx_PeriphCLKConfig>
}
 8022990:	b022      	add	sp, #136	; 0x88
 8022992:	bd10      	pop	{r4, pc}

08022994 <RTC_GetCurrentDateTime>:
{
 8022994:	b538      	push	{r3, r4, r5, lr}
  Status = HAL_RTC_GetTime(&RtcHandle, &CurrentTime, RTC_FORMAT_BIN);
 8022996:	4c08      	ldr	r4, [pc, #32]	; (80229b8 <RTC_GetCurrentDateTime+0x24>)
 8022998:	f504 6529 	add.w	r5, r4, #2704	; 0xa90
 802299c:	f604 217c 	addw	r1, r4, #2684	; 0xa7c
 80229a0:	2200      	movs	r2, #0
 80229a2:	4628      	mov	r0, r5
 80229a4:	f7f1 f8da 	bl	8013b5c <HAL_RTC_GetTime>
  Status = HAL_RTC_GetDate(&RtcHandle, &CurrentDate, RTC_FORMAT_BIN);
 80229a8:	f604 21b4 	addw	r1, r4, #2740	; 0xab4
 80229ac:	4628      	mov	r0, r5
 80229ae:	2200      	movs	r2, #0
}
 80229b0:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  Status = HAL_RTC_GetDate(&RtcHandle, &CurrentDate, RTC_FORMAT_BIN);
 80229b4:	f7f1 b90a 	b.w	8013bcc <HAL_RTC_GetDate>
 80229b8:	20012a74 	.word	0x20012a74

080229bc <HAL_Delay>:
{
 80229bc:	b510      	push	{r4, lr}
 80229be:	b082      	sub	sp, #8
 80229c0:	9001      	str	r0, [sp, #4]
  tickstart = HAL_GetTick();
 80229c2:	f7ec ff39 	bl	800f838 <HAL_GetTick>
 80229c6:	4604      	mov	r4, r0
  while((HAL_GetTick() - tickstart) < Delay){
 80229c8:	e000      	b.n	80229cc <HAL_Delay+0x10>
    __WFI();
 80229ca:	bf30      	wfi
  while((HAL_GetTick() - tickstart) < Delay){
 80229cc:	f7ec ff34 	bl	800f838 <HAL_GetTick>
 80229d0:	9b01      	ldr	r3, [sp, #4]
 80229d2:	1b00      	subs	r0, r0, r4
 80229d4:	4298      	cmp	r0, r3
 80229d6:	d3f8      	bcc.n	80229ca <HAL_Delay+0xe>
}
 80229d8:	b002      	add	sp, #8
 80229da:	bd10      	pop	{r4, pc}

080229dc <Error_Handler>:
{
 80229dc:	b508      	push	{r3, lr}
  SENSING1_PRINTF("Error_Handler\r\n");
 80229de:	4b04      	ldr	r3, [pc, #16]	; (80229f0 <Error_Handler+0x14>)
 80229e0:	781b      	ldrb	r3, [r3, #0]
 80229e2:	b903      	cbnz	r3, 80229e6 <Error_Handler+0xa>
  while(1){
 80229e4:	e7fe      	b.n	80229e4 <Error_Handler+0x8>
  SENSING1_PRINTF("Error_Handler\r\n");
 80229e6:	4803      	ldr	r0, [pc, #12]	; (80229f4 <Error_Handler+0x18>)
 80229e8:	f005 fbb4 	bl	8028154 <puts>
 80229ec:	e7fa      	b.n	80229e4 <Error_Handler+0x8>
 80229ee:	bf00      	nop
 80229f0:	20000d84 	.word	0x20000d84
 80229f4:	08043b94 	.word	0x08043b94

080229f8 <BSP_AUDIO_IN_Error_CallBack>:
{
 80229f8:	b508      	push	{r3, lr}
  Error_Handler();
 80229fa:	f7ff ffef 	bl	80229dc <Error_Handler>
 80229fe:	bf00      	nop

08022a00 <RTC_DateConfig>:
{
 8022a00:	b500      	push	{lr}
 8022a02:	b083      	sub	sp, #12
 8022a04:	4686      	mov	lr, r0
 8022a06:	4694      	mov	ip, r2
  sdatestructure.Date = Date;
 8022a08:	f88d 1006 	strb.w	r1, [sp, #6]
  if(HAL_RTC_SetDate(&RtcHandle,&sdatestructure,RTC_FORMAT_BCD) != HAL_OK) {
 8022a0c:	4808      	ldr	r0, [pc, #32]	; (8022a30 <RTC_DateConfig+0x30>)
  sdatestructure.WeekDay = WeekDay;
 8022a0e:	f88d e004 	strb.w	lr, [sp, #4]
  if(HAL_RTC_SetDate(&RtcHandle,&sdatestructure,RTC_FORMAT_BCD) != HAL_OK) {
 8022a12:	2201      	movs	r2, #1
 8022a14:	a901      	add	r1, sp, #4
  sdatestructure.Month = Month;
 8022a16:	f88d c005 	strb.w	ip, [sp, #5]
  sdatestructure.Year = Year;
 8022a1a:	f88d 3007 	strb.w	r3, [sp, #7]
  if(HAL_RTC_SetDate(&RtcHandle,&sdatestructure,RTC_FORMAT_BCD) != HAL_OK) {
 8022a1e:	f7f1 fa4d 	bl	8013ebc <HAL_RTC_SetDate>
 8022a22:	b910      	cbnz	r0, 8022a2a <RTC_DateConfig+0x2a>
}
 8022a24:	b003      	add	sp, #12
 8022a26:	f85d fb04 	ldr.w	pc, [sp], #4
    Error_Handler();
 8022a2a:	f7ff ffd7 	bl	80229dc <Error_Handler>
 8022a2e:	bf00      	nop
 8022a30:	20013504 	.word	0x20013504

08022a34 <RTC_TimeConfig>:
{
 8022a34:	b500      	push	{lr}
 8022a36:	b087      	sub	sp, #28
  stimestructure.TimeFormat = RTC_HOURFORMAT12_AM;
 8022a38:	2300      	movs	r3, #0
{
 8022a3a:	4686      	mov	lr, r0
 8022a3c:	4694      	mov	ip, r2
  stimestructure.Minutes = Minutes;
 8022a3e:	f88d 1005 	strb.w	r1, [sp, #5]
  if(HAL_RTC_SetTime(&RtcHandle,&stimestructure,RTC_FORMAT_BCD) != HAL_OK) {
 8022a42:	4809      	ldr	r0, [pc, #36]	; (8022a68 <RTC_TimeConfig+0x34>)
  stimestructure.Hours = Hours;
 8022a44:	f88d e004 	strb.w	lr, [sp, #4]
  if(HAL_RTC_SetTime(&RtcHandle,&stimestructure,RTC_FORMAT_BCD) != HAL_OK) {
 8022a48:	2201      	movs	r2, #1
 8022a4a:	a901      	add	r1, sp, #4
  stimestructure.StoreOperation = RTC_STOREOPERATION_RESET;
 8022a4c:	e9cd 3304 	strd	r3, r3, [sp, #16]
  stimestructure.Seconds = Seconds;
 8022a50:	f88d c006 	strb.w	ip, [sp, #6]
  stimestructure.TimeFormat = RTC_HOURFORMAT12_AM;
 8022a54:	f88d 3007 	strb.w	r3, [sp, #7]
  if(HAL_RTC_SetTime(&RtcHandle,&stimestructure,RTC_FORMAT_BCD) != HAL_OK) {
 8022a58:	f7f1 f9a0 	bl	8013d9c <HAL_RTC_SetTime>
 8022a5c:	b910      	cbnz	r0, 8022a64 <RTC_TimeConfig+0x30>
}
 8022a5e:	b007      	add	sp, #28
 8022a60:	f85d fb04 	ldr.w	pc, [sp], #4
    Error_Handler();
 8022a64:	f7ff ffba 	bl	80229dc <Error_Handler>
 8022a68:	20013504 	.word	0x20013504

08022a6c <HAL_GPIO_EXTI_Callback>:
  switch(GPIO_Pin){
 8022a6c:	2840      	cmp	r0, #64	; 0x40
 8022a6e:	d00c      	beq.n	8022a8a <HAL_GPIO_EXTI_Callback+0x1e>
 8022a70:	f5b0 5f00 	cmp.w	r0, #8192	; 0x2000
 8022a74:	d108      	bne.n	8022a88 <HAL_GPIO_EXTI_Callback+0x1c>
    ButtonPressed = 1;
 8022a76:	4b0b      	ldr	r3, [pc, #44]	; (8022aa4 <HAL_GPIO_EXTI_Callback+0x38>)
    if(semRun) {
 8022a78:	6a98      	ldr	r0, [r3, #40]	; 0x28
    ButtonPressed = 1;
 8022a7a:	2201      	movs	r2, #1
 8022a7c:	f8c3 295c 	str.w	r2, [r3, #2396]	; 0x95c
    if(semRun) {
 8022a80:	b108      	cbz	r0, 8022a86 <HAL_GPIO_EXTI_Callback+0x1a>
      osSemaphoreRelease(semRun);
 8022a82:	f7f5 bfed 	b.w	8018a60 <osSemaphoreRelease>
 8022a86:	4770      	bx	lr
 8022a88:	4770      	bx	lr
{
 8022a8a:	b500      	push	{lr}
 8022a8c:	b08b      	sub	sp, #44	; 0x2c
      hci_tl_lowlevel_isr();
 8022a8e:	f7fe fd21 	bl	80214d4 <hci_tl_lowlevel_isr>
      msg.type  = PROCESS_EVENT;
 8022a92:	2302      	movs	r3, #2
      SendMsgToHost(&msg);
 8022a94:	4668      	mov	r0, sp
      msg.type  = PROCESS_EVENT;
 8022a96:	f88d 3000 	strb.w	r3, [sp]
      SendMsgToHost(&msg);
 8022a9a:	f7fe fedd 	bl	8021858 <SendMsgToHost>
}
 8022a9e:	b00b      	add	sp, #44	; 0x2c
 8022aa0:	f85d fb04 	ldr.w	pc, [sp], #4
 8022aa4:	20012a74 	.word	0x20012a74

08022aa8 <LedBlinkStart>:
{
 8022aa8:	b510      	push	{r4, lr}
  ledTimer = LED_TIME_ON;
 8022aaa:	4c10      	ldr	r4, [pc, #64]	; (8022aec <LedBlinkStart+0x44>)
 8022aac:	2364      	movs	r3, #100	; 0x64
 8022aae:	f8c4 393c 	str.w	r3, [r4, #2364]	; 0x93c
  LedOnTargetPlatform();
 8022ab2:	f7fc fe67 	bl	801f784 <LedOnTargetPlatform>
  if (!timLedId) {
 8022ab6:	f8d4 0940 	ldr.w	r0, [r4, #2368]	; 0x940
 8022aba:	b140      	cbz	r0, 8022ace <LedBlinkStart+0x26>
    if  (osTimerStart (timLedId, ledTimer) != osOK) {
 8022abc:	f8d4 193c 	ldr.w	r1, [r4, #2364]	; 0x93c
 8022ac0:	f7f5 ff1c 	bl	80188fc <osTimerStart>
 8022ac4:	b110      	cbz	r0, 8022acc <LedBlinkStart+0x24>
      SENSING1_PRINTF("failed starting timer\n\r");
 8022ac6:	4b0a      	ldr	r3, [pc, #40]	; (8022af0 <LedBlinkStart+0x48>)
 8022ac8:	781b      	ldrb	r3, [r3, #0]
 8022aca:	b953      	cbnz	r3, 8022ae2 <LedBlinkStart+0x3a>
}
 8022acc:	bd10      	pop	{r4, pc}
    timLedId     = osTimerCreate (osTimer(TimerLedHandle),osTimerOnce, NULL);
 8022ace:	4602      	mov	r2, r0
 8022ad0:	4601      	mov	r1, r0
 8022ad2:	4808      	ldr	r0, [pc, #32]	; (8022af4 <LedBlinkStart+0x4c>)
 8022ad4:	f7f5 fefe 	bl	80188d4 <osTimerCreate>
 8022ad8:	f8c4 0940 	str.w	r0, [r4, #2368]	; 0x940
  if (timLedId){
 8022adc:	2800      	cmp	r0, #0
 8022ade:	d1ed      	bne.n	8022abc <LedBlinkStart+0x14>
}
 8022ae0:	bd10      	pop	{r4, pc}
 8022ae2:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
      SENSING1_PRINTF("failed starting timer\n\r");
 8022ae6:	4804      	ldr	r0, [pc, #16]	; (8022af8 <LedBlinkStart+0x50>)
 8022ae8:	f005 ba98 	b.w	802801c <iprintf>
 8022aec:	20012a74 	.word	0x20012a74
 8022af0:	20000d84 	.word	0x20000d84
 8022af4:	08039ba8 	.word	0x08039ba8
 8022af8:	0804371c 	.word	0x0804371c

08022afc <HostThread>:
{
 8022afc:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8022b00:	4c3a      	ldr	r4, [pc, #232]	; (8022bec <HostThread+0xf0>)
 8022b02:	4e3b      	ldr	r6, [pc, #236]	; (8022bf0 <HostThread+0xf4>)
          SENSING1_PRINTF("HostThread unexpected message:%d\r\n",msgPtr->type );
 8022b04:	f8df 80ec 	ldr.w	r8, [pc, #236]	; 8022bf4 <HostThread+0xf8>
{
 8022b08:	b084      	sub	sp, #16
          hciProcessEnable = 1 ;
 8022b0a:	2701      	movs	r7, #1
    evt = osMailGet(mail, osWaitForever);
 8022b0c:	f8d4 1944 	ldr.w	r1, [r4, #2372]	; 0x944
 8022b10:	f04f 32ff 	mov.w	r2, #4294967295
 8022b14:	a801      	add	r0, sp, #4
 8022b16:	f7f6 f8ad 	bl	8018c74 <osMailGet>
    if (evt.status == osEventMail) {
 8022b1a:	9b01      	ldr	r3, [sp, #4]
 8022b1c:	2b20      	cmp	r3, #32
 8022b1e:	d1f5      	bne.n	8022b0c <HostThread+0x10>
      msgPtr = evt.value.p;
 8022b20:	9d02      	ldr	r5, [sp, #8]
      switch(msgPtr->type) {
 8022b22:	7829      	ldrb	r1, [r5, #0]
 8022b24:	2912      	cmp	r1, #18
 8022b26:	d81a      	bhi.n	8022b5e <HostThread+0x62>
 8022b28:	e8df f001 	tbb	[pc, r1]
 8022b2c:	195a363c 	.word	0x195a363c
 8022b30:	45495119 	.word	0x45495119
 8022b34:	0e0a0a0a 	.word	0x0e0a0a0a
 8022b38:	1920252a 	.word	0x1920252a
 8022b3c:	0e19      	.short	0x0e19
 8022b3e:	2e          	.byte	0x2e
 8022b3f:	00          	.byte	0x00
          ActivityRec_Update(msgPtr->activity,HarAlgo);
 8022b40:	79b1      	ldrb	r1, [r6, #6]
 8022b42:	7928      	ldrb	r0, [r5, #4]
 8022b44:	f000 fae4 	bl	8023110 <ActivityRec_Update>
      osMailFree(mail, msgPtr);
 8022b48:	f8d4 0944 	ldr.w	r0, [r4, #2372]	; 0x944
 8022b4c:	4629      	mov	r1, r5
 8022b4e:	f7f6 f8d3 	bl	8018cf8 <osMailFree>
      if(semRun) {
 8022b52:	6aa0      	ldr	r0, [r4, #40]	; 0x28
 8022b54:	2800      	cmp	r0, #0
 8022b56:	d0d9      	beq.n	8022b0c <HostThread+0x10>
        osSemaphoreRelease(semRun);
 8022b58:	f7f5 ff82 	bl	8018a60 <osSemaphoreRelease>
 8022b5c:	e7d6      	b.n	8022b0c <HostThread+0x10>
          SENSING1_PRINTF("HostThread unexpected message:%d\r\n",msgPtr->type );
 8022b5e:	7833      	ldrb	r3, [r6, #0]
 8022b60:	2b00      	cmp	r3, #0
 8022b62:	d0f1      	beq.n	8022b48 <HostThread+0x4c>
 8022b64:	4640      	mov	r0, r8
 8022b66:	f005 fa59 	bl	802801c <iprintf>
 8022b6a:	e7ed      	b.n	8022b48 <HostThread+0x4c>
          UpdateTermStdErr(msgPtr->term.data,msgPtr->term.length);
 8022b6c:	7929      	ldrb	r1, [r5, #4]
 8022b6e:	1d68      	adds	r0, r5, #5
 8022b70:	f000 fa46 	bl	8023000 <UpdateTermStdErr>
          break;
 8022b74:	e7e8      	b.n	8022b48 <HostThread+0x4c>
          UpdateTermStdOut(msgPtr->term.data,msgPtr->term.length);
 8022b76:	7929      	ldrb	r1, [r5, #4]
 8022b78:	1d68      	adds	r0, r5, #5
 8022b7a:	f000 fa19 	bl	8022fb0 <UpdateTermStdOut>
          break;
 8022b7e:	e7e3      	b.n	8022b48 <HostThread+0x4c>
          AudioLevel_Update(msgPtr->DBNOISE_Value_Ch);
 8022b80:	1d28      	adds	r0, r5, #4
 8022b82:	f000 ff1f 	bl	80239c4 <AudioLevel_Update>
          break;
 8022b86:	e7df      	b.n	8022b48 <HostThread+0x4c>
          if (msgPtr->HostLinkType != hostConnection) {
 8022b88:	f894 2ab8 	ldrb.w	r2, [r4, #2744]	; 0xab8
 8022b8c:	792b      	ldrb	r3, [r5, #4]
 8022b8e:	4293      	cmp	r3, r2
 8022b90:	d0da      	beq.n	8022b48 <HostThread+0x4c>
            hostConnection = msgPtr->HostLinkType;
 8022b92:	f884 3ab8 	strb.w	r3, [r4, #2744]	; 0xab8
 8022b96:	e7d7      	b.n	8022b48 <HostThread+0x4c>
          Config_NotifyBLE(msgPtr->conf.feature,msgPtr->conf.command,msgPtr->conf.data);
 8022b98:	7a6a      	ldrb	r2, [r5, #9]
 8022b9a:	7a29      	ldrb	r1, [r5, #8]
 8022b9c:	6868      	ldr	r0, [r5, #4]
 8022b9e:	f000 fb63 	bl	8023268 <Config_NotifyBLE>
          break;
 8022ba2:	e7d1      	b.n	8022b48 <HostThread+0x4c>
          hciProcessEnable = 1 ;
 8022ba4:	61b7      	str	r7, [r6, #24]
          setConnectable();
 8022ba6:	f000 ff9f 	bl	8023ae8 <setConnectable>
          hostConnection = NOT_CONNECTED;
 8022baa:	2300      	movs	r3, #0
 8022bac:	f884 3ab8 	strb.w	r3, [r4, #2744]	; 0xab8
          LedBlinkStart();
 8022bb0:	f7ff ff7a 	bl	8022aa8 <LedBlinkStart>
          break;
 8022bb4:	e7c8      	b.n	8022b48 <HostThread+0x4c>
          AudioSRec_Update(msgPtr->audio_scene);
 8022bb6:	7928      	ldrb	r0, [r5, #4]
 8022bb8:	f000 fb0a 	bl	80231d0 <AudioSRec_Update>
          break;
 8022bbc:	e7c4      	b.n	8022b48 <HostThread+0x4c>
          AccGyroMag_Update(&(msgPtr->motion.acc),&(msgPtr->motion.gyr),&(msgPtr->motion.mag));
 8022bbe:	f105 021c 	add.w	r2, r5, #28
 8022bc2:	f105 0110 	add.w	r1, r5, #16
 8022bc6:	1d28      	adds	r0, r5, #4
 8022bc8:	f000 fda8 	bl	802371c <AccGyroMag_Update>
          break;
 8022bcc:	e7bc      	b.n	8022b48 <HostThread+0x4c>
          Environmental_Update(msgPtr->env.press,msgPtr->env.hum,msgPtr->env.temp1,msgPtr->env.temp2);
 8022bce:	f9b5 300a 	ldrsh.w	r3, [r5, #10]
 8022bd2:	f9b5 200c 	ldrsh.w	r2, [r5, #12]
 8022bd6:	8929      	ldrh	r1, [r5, #8]
 8022bd8:	6868      	ldr	r0, [r5, #4]
 8022bda:	f000 fe47 	bl	802386c <Environmental_Update>
          break;
 8022bde:	e7b3      	b.n	8022b48 <HostThread+0x4c>
          if (hciProcessEnable) {
 8022be0:	69b3      	ldr	r3, [r6, #24]
 8022be2:	2b00      	cmp	r3, #0
 8022be4:	d0b0      	beq.n	8022b48 <HostThread+0x4c>
            hci_user_evt_proc();
 8022be6:	f7f9 f86f 	bl	801bcc8 <hci_user_evt_proc>
 8022bea:	e7ad      	b.n	8022b48 <HostThread+0x4c>
 8022bec:	20012a74 	.word	0x20012a74
 8022bf0:	20000d84 	.word	0x20000d84
 8022bf4:	08043ba4 	.word	0x08043ba4

08022bf8 <LedBlinkStop>:
{
 8022bf8:	b510      	push	{r4, lr}
  if (timLedId) {
 8022bfa:	4c11      	ldr	r4, [pc, #68]	; (8022c40 <LedBlinkStop+0x48>)
  LedOffTargetPlatform();
 8022bfc:	f7fc fdc6 	bl	801f78c <LedOffTargetPlatform>
  if (timLedId) {
 8022c00:	f8d4 0940 	ldr.w	r0, [r4, #2368]	; 0x940
 8022c04:	b190      	cbz	r0, 8022c2c <LedBlinkStop+0x34>
    if  (osTimerStop (timLedId) != osOK){
 8022c06:	f7f5 fea7 	bl	8018958 <osTimerStop>
 8022c0a:	b110      	cbz	r0, 8022c12 <LedBlinkStop+0x1a>
      SENSING1_PRINTF("could not stop led timer\n\r");
 8022c0c:	4b0d      	ldr	r3, [pc, #52]	; (8022c44 <LedBlinkStop+0x4c>)
 8022c0e:	781b      	ldrb	r3, [r3, #0]
 8022c10:	b96b      	cbnz	r3, 8022c2e <LedBlinkStop+0x36>
    if (osTimerDelete (timLedId) != osOK)  {
 8022c12:	f8d4 0940 	ldr.w	r0, [r4, #2368]	; 0x940
 8022c16:	f7f5 fecb 	bl	80189b0 <osTimerDelete>
 8022c1a:	b110      	cbz	r0, 8022c22 <LedBlinkStop+0x2a>
      SENSING1_PRINTF("could not delete led timer\n\r");
 8022c1c:	4b09      	ldr	r3, [pc, #36]	; (8022c44 <LedBlinkStop+0x4c>)
 8022c1e:	781b      	ldrb	r3, [r3, #0]
 8022c20:	b94b      	cbnz	r3, 8022c36 <LedBlinkStop+0x3e>
  timLedId = NULL;
 8022c22:	2300      	movs	r3, #0
 8022c24:	f8c4 3940 	str.w	r3, [r4, #2368]	; 0x940
  ledTimer = (uint32_t)NULL;
 8022c28:	f8c4 393c 	str.w	r3, [r4, #2364]	; 0x93c
}
 8022c2c:	bd10      	pop	{r4, pc}
      SENSING1_PRINTF("could not stop led timer\n\r");
 8022c2e:	4806      	ldr	r0, [pc, #24]	; (8022c48 <LedBlinkStop+0x50>)
 8022c30:	f005 f9f4 	bl	802801c <iprintf>
 8022c34:	e7ed      	b.n	8022c12 <LedBlinkStop+0x1a>
      SENSING1_PRINTF("could not delete led timer\n\r");
 8022c36:	4805      	ldr	r0, [pc, #20]	; (8022c4c <LedBlinkStop+0x54>)
 8022c38:	f005 f9f0 	bl	802801c <iprintf>
 8022c3c:	e7f1      	b.n	8022c22 <LedBlinkStop+0x2a>
 8022c3e:	bf00      	nop
 8022c40:	20012a74 	.word	0x20012a74
 8022c44:	20000d84 	.word	0x20000d84
 8022c48:	08043bc8 	.word	0x08043bc8
 8022c4c:	08043be4 	.word	0x08043be4

08022c50 <vApplicationStackOverflowHook>:

void vApplicationStackOverflowHook (void)
{
  while (1)
 8022c50:	e7fe      	b.n	8022c50 <vApplicationStackOverflowHook>
 8022c52:	bf00      	nop

08022c54 <QSPI_initialize>:
  * @retval DSTATUS: Operation status
  */
DSTATUS QSPI_initialize (
	BYTE pdrv           /* Physical drive number to identify the drive */
)
{
 8022c54:	b530      	push	{r4, r5, lr}

  Stat = STA_NOINIT;

  /* QSPI device configuration */
  // QSPI_InitStruct.InterfaceMode = BSP_QSPI_SPI_MODE;
  QSPI_InitStruct.InterfaceMode = BSP_QSPI_QUAD_IO_MODE;
 8022c56:	2304      	movs	r3, #4
{
 8022c58:	b083      	sub	sp, #12
  Stat = STA_NOINIT;
 8022c5a:	4c09      	ldr	r4, [pc, #36]	; (8022c80 <QSPI_initialize+0x2c>)
  QSPI_InitStruct.InterfaceMode = BSP_QSPI_QUAD_IO_MODE;
 8022c5c:	f88d 3004 	strb.w	r3, [sp, #4]
  Stat = STA_NOINIT;
 8022c60:	2501      	movs	r5, #1
  status = BSP_QSPI_Init(0, &QSPI_InitStruct);
 8022c62:	eb0d 0103 	add.w	r1, sp, r3
 8022c66:	2000      	movs	r0, #0
  Stat = STA_NOINIT;
 8022c68:	7025      	strb	r5, [r4, #0]
  status = BSP_QSPI_Init(0, &QSPI_InitStruct);
 8022c6a:	f7ea f8c9 	bl	800ce00 <BSP_QSPI_Init>

  if (status != BSP_ERROR_NONE)
 8022c6e:	b118      	cbz	r0, 8022c78 <QSPI_initialize+0x24>
  {
    Stat = RES_ERROR;
 8022c70:	7025      	strb	r5, [r4, #0]
  else
  {
    Stat = RES_OK;
  }

  return Stat;
 8022c72:	7820      	ldrb	r0, [r4, #0]
}
 8022c74:	b003      	add	sp, #12
 8022c76:	bd30      	pop	{r4, r5, pc}
    Stat = RES_OK;
 8022c78:	7020      	strb	r0, [r4, #0]
  return Stat;
 8022c7a:	7820      	ldrb	r0, [r4, #0]
}
 8022c7c:	b003      	add	sp, #12
 8022c7e:	bd30      	pop	{r4, r5, pc}
 8022c80:	20000da0 	.word	0x20000da0

08022c84 <QSPI_status>:
  * @retval DSTATUS: Operation status
  */
DSTATUS QSPI_status (
	BYTE pdrv       /* Physical drive number to identify the drive */
)
{
 8022c84:	b508      	push	{r3, lr}
  if (BSP_QSPI_GetStatus(0) == BSP_ERROR_NONE) {
 8022c86:	2000      	movs	r0, #0
 8022c88:	f7ea f816 	bl	800ccb8 <BSP_QSPI_GetStatus>
    Stat &= ~STA_NOINIT;
 8022c8c:	4b03      	ldr	r3, [pc, #12]	; (8022c9c <QSPI_status+0x18>)
  if (BSP_QSPI_GetStatus(0) == BSP_ERROR_NONE) {
 8022c8e:	b918      	cbnz	r0, 8022c98 <QSPI_status+0x14>
    Stat &= ~STA_NOINIT;
 8022c90:	781a      	ldrb	r2, [r3, #0]
 8022c92:	f002 02fe 	and.w	r2, r2, #254	; 0xfe
 8022c96:	701a      	strb	r2, [r3, #0]
  }

  return Stat;
 8022c98:	7818      	ldrb	r0, [r3, #0]
}
 8022c9a:	bd08      	pop	{r3, pc}
 8022c9c:	20000da0 	.word	0x20000da0

08022ca0 <QSPI_read>:
	BYTE pdrv,      /* Physical drive number to identify the drive */
	BYTE *buff,     /* Data buffer to store read data */
	DWORD sector,   /* Sector address in LBA */
	UINT count      /* Number of sectors to read */
)
{
 8022ca0:	b508      	push	{r3, lr}
  uint32_t BufferSize = (MX25R6435F_SECTOR_4K * count) / 4; // Read size?
 8022ca2:	031b      	lsls	r3, r3, #12
  uint32_t read_addr = (MX25R6435F_SECTOR_4K * sector);

  if (BSP_QSPI_Read(0, buff, read_addr, BufferSize) != BSP_ERROR_NONE)
 8022ca4:	089b      	lsrs	r3, r3, #2
 8022ca6:	0312      	lsls	r2, r2, #12
 8022ca8:	2000      	movs	r0, #0
 8022caa:	f7e9 ff8b 	bl	800cbc4 <BSP_QSPI_Read>
  {
    return RES_ERROR;
  }

  return RES_OK;
}
 8022cae:	3800      	subs	r0, #0
 8022cb0:	bf18      	it	ne
 8022cb2:	2001      	movne	r0, #1
 8022cb4:	bd08      	pop	{r3, pc}
 8022cb6:	bf00      	nop

08022cb8 <QSPI_ioctl>:
DRESULT QSPI_ioctl (
	BYTE pdrv,      /* Physical drive nmuber (0..) */
	BYTE cmd,       /* Control code */
	void *buff      /* Buffer to send/receive control data */
)
{
 8022cb8:	b508      	push	{r3, lr}
  DRESULT res = RES_ERROR;

  if (Stat & STA_NOINIT) return RES_NOTRDY;
 8022cba:	4b10      	ldr	r3, [pc, #64]	; (8022cfc <QSPI_ioctl+0x44>)
 8022cbc:	7818      	ldrb	r0, [r3, #0]
 8022cbe:	f010 0001 	ands.w	r0, r0, #1
 8022cc2:	d105      	bne.n	8022cd0 <QSPI_ioctl+0x18>

  switch (cmd)
 8022cc4:	2903      	cmp	r1, #3
 8022cc6:	d817      	bhi.n	8022cf8 <QSPI_ioctl+0x40>
 8022cc8:	e8df f001 	tbb	[pc, r1]
 8022ccc:	04120e07 	.word	0x04120e07
  if (Stat & STA_NOINIT) return RES_NOTRDY;
 8022cd0:	2003      	movs	r0, #3
  default:
    res = RES_PARERR;
  }

  return res;
}
 8022cd2:	bd08      	pop	{r3, pc}
    *(DWORD*)buff = MX25R6435F_BLOCK_64K / MX25R6435F_SECTOR_4K; /* 16 sector blocks */
 8022cd4:	2310      	movs	r3, #16
 8022cd6:	6013      	str	r3, [r2, #0]
}
 8022cd8:	bd08      	pop	{r3, pc}
    if (BSP_QSPI_GetStatus(0) != BSP_ERROR_NONE) {
 8022cda:	2000      	movs	r0, #0
 8022cdc:	f7e9 ffec 	bl	800ccb8 <BSP_QSPI_GetStatus>
  if (Stat & STA_NOINIT) return RES_NOTRDY;
 8022ce0:	3800      	subs	r0, #0
 8022ce2:	bf18      	it	ne
 8022ce4:	2001      	movne	r0, #1
}
 8022ce6:	bd08      	pop	{r3, pc}
    *(DWORD*)buff = MX25R6435F_FLASH_SIZE / MX25R6435F_SECTOR_4K; /* 2048 Sectors of 4kBytes */
 8022ce8:	f44f 6300 	mov.w	r3, #2048	; 0x800
 8022cec:	6013      	str	r3, [r2, #0]
}
 8022cee:	bd08      	pop	{r3, pc}
    *(DWORD*)buff = MX25R6435F_SECTOR_4K; /* 0x1000 = 4kBytes */
 8022cf0:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 8022cf4:	6013      	str	r3, [r2, #0]
}
 8022cf6:	bd08      	pop	{r3, pc}
  switch (cmd)
 8022cf8:	2004      	movs	r0, #4
}
 8022cfa:	bd08      	pop	{r3, pc}
 8022cfc:	20000da0 	.word	0x20000da0

08022d00 <QSPI_write>:
{
 8022d00:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  uint32_t write_addr = (MX25R6435F_SECTOR_4K * sector);
 8022d02:	0315      	lsls	r5, r2, #12
  if (BSP_QSPI_Erase_Block(0, write_addr, BSP_QSPI_ERASE_4K) != BSP_ERROR_NONE)
 8022d04:	2200      	movs	r2, #0
{
 8022d06:	460e      	mov	r6, r1
  if (BSP_QSPI_Erase_Block(0, write_addr, BSP_QSPI_ERASE_4K) != BSP_ERROR_NONE)
 8022d08:	4610      	mov	r0, r2
 8022d0a:	4629      	mov	r1, r5
{
 8022d0c:	461f      	mov	r7, r3
  if (BSP_QSPI_Erase_Block(0, write_addr, BSP_QSPI_ERASE_4K) != BSP_ERROR_NONE)
 8022d0e:	f7e9 ffb7 	bl	800cc80 <BSP_QSPI_Erase_Block>
 8022d12:	b108      	cbz	r0, 8022d18 <QSPI_write+0x18>
    return RES_ERROR;
 8022d14:	2001      	movs	r0, #1
}
 8022d16:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  BSP_QSPIEx_WaitForEndOfOperation(0, 300);
 8022d18:	4604      	mov	r4, r0
 8022d1a:	f44f 7196 	mov.w	r1, #300	; 0x12c
 8022d1e:	f001 fe7d 	bl	8024a1c <BSP_QSPIEx_WaitForEndOfOperation>
  if (BSP_QSPI_Write(0, (uint8_t *) buff, write_addr, BufferSize) != BSP_ERROR_NONE)
 8022d22:	4620      	mov	r0, r4
 8022d24:	033b      	lsls	r3, r7, #12
 8022d26:	462a      	mov	r2, r5
 8022d28:	4631      	mov	r1, r6
 8022d2a:	f7e9 ff63 	bl	800cbf4 <BSP_QSPI_Write>
 8022d2e:	4604      	mov	r4, r0
 8022d30:	2800      	cmp	r0, #0
 8022d32:	d1ef      	bne.n	8022d14 <QSPI_write+0x14>
  BSP_QSPIEx_WaitForEndOfOperation(0, 300);
 8022d34:	f44f 7196 	mov.w	r1, #300	; 0x12c
 8022d38:	f001 fe70 	bl	8024a1c <BSP_QSPIEx_WaitForEndOfOperation>
 8022d3c:	4620      	mov	r0, r4
}
 8022d3e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

08022d40 <Add_ConfigW2ST_Service>:
 * @brief  Add the Config service using a vendor specific profile
 * @param  None
 * @retval tBleStatus Status
 */
tBleStatus Add_ConfigW2ST_Service(void)
{
 8022d40:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}

  uint8_t uuid[16];

  COPY_CONFIG_SERVICE_UUID(uuid);
#ifndef SENSING1_BlueNRG2
  ret = aci_gatt_add_serv(UUID_TYPE_128,  uuid, PRIMARY_SERVICE, 1+3,&ConfigServW2STHandle);
 8022d44:	4d3b      	ldr	r5, [pc, #236]	; (8022e34 <Add_ConfigW2ST_Service+0xf4>)
{
 8022d46:	b08b      	sub	sp, #44	; 0x2c
  COPY_CONFIG_SERVICE_UUID(uuid);
 8022d48:	2300      	movs	r3, #0
 8022d4a:	f88d 301d 	strb.w	r3, [sp, #29]
 8022d4e:	f88d 3023 	strb.w	r3, [sp, #35]	; 0x23
 8022d52:	f88d 3024 	strb.w	r3, [sp, #36]	; 0x24
 8022d56:	f88d 3025 	strb.w	r3, [sp, #37]	; 0x25
 8022d5a:	f88d 3026 	strb.w	r3, [sp, #38]	; 0x26
 8022d5e:	f88d 3027 	strb.w	r3, [sp, #39]	; 0x27
  ret = aci_gatt_add_serv(UUID_TYPE_128,  uuid, PRIMARY_SERVICE, 1+3,&ConfigServW2STHandle);
 8022d62:	1d2b      	adds	r3, r5, #4
 8022d64:	9300      	str	r3, [sp, #0]
  COPY_CONFIG_SERVICE_UUID(uuid);
 8022d66:	23b4      	movs	r3, #180	; 0xb4
 8022d68:	f88d 301e 	strb.w	r3, [sp, #30]
 8022d6c:	239a      	movs	r3, #154	; 0x9a
 8022d6e:	2402      	movs	r4, #2
 8022d70:	f88d 301f 	strb.w	r3, [sp, #31]
 8022d74:	f04f 030f 	mov.w	r3, #15
 8022d78:	f04f 0b1b 	mov.w	fp, #27
 8022d7c:	f04f 0ac5 	mov.w	sl, #197	; 0xc5
 8022d80:	f04f 09d5 	mov.w	r9, #213	; 0xd5
 8022d84:	f04f 08a5 	mov.w	r8, #165	; 0xa5
 8022d88:	27e1      	movs	r7, #225	; 0xe1
 8022d8a:	2611      	movs	r6, #17
 8022d8c:	f88d 3022 	strb.w	r3, [sp, #34]	; 0x22
  ret = aci_gatt_add_serv(UUID_TYPE_128,  uuid, PRIMARY_SERVICE, 1+3,&ConfigServW2STHandle);
 8022d90:	2201      	movs	r2, #1
 8022d92:	2304      	movs	r3, #4
 8022d94:	a906      	add	r1, sp, #24
 8022d96:	4620      	mov	r0, r4
  COPY_CONFIG_SERVICE_UUID(uuid);
 8022d98:	f88d b018 	strb.w	fp, [sp, #24]
 8022d9c:	f88d a019 	strb.w	sl, [sp, #25]
 8022da0:	f88d 901a 	strb.w	r9, [sp, #26]
 8022da4:	f88d 401c 	strb.w	r4, [sp, #28]
 8022da8:	f88d 801b 	strb.w	r8, [sp, #27]
 8022dac:	f88d 7020 	strb.w	r7, [sp, #32]
 8022db0:	f88d 6021 	strb.w	r6, [sp, #33]	; 0x21
  ret = aci_gatt_add_serv(UUID_TYPE_128,  uuid, PRIMARY_SERVICE, 1+3,&ConfigServW2STHandle);
 8022db4:	f7f8 fc92 	bl	801b6dc <aci_gatt_add_serv>
#else /* SENSING1_BlueNRG2 */
  BLUENRG_memcpy(&service_uuid.Service_UUID_128, uuid, 16);
  ret = aci_gatt_add_service(UUID_TYPE_128,  &service_uuid, PRIMARY_SERVICE, 1+3,&ConfigServW2STHandle);
#endif /* SENSING1_BlueNRG2 */

  if (ret != BLE_STATUS_SUCCESS) {
 8022db8:	bbc0      	cbnz	r0, 8022e2c <Add_ConfigW2ST_Service+0xec>
    goto fail;
  }

  COPY_CONFIG_W2ST_CHAR_UUID(uuid);
 8022dba:	f04f 030f 	mov.w	r3, #15
 8022dbe:	f88d 3022 	strb.w	r3, [sp, #34]	; 0x22
#ifndef SENSING1_BlueNRG2
  ret =  aci_gatt_add_char(ConfigServW2STHandle, UUID_TYPE_128, uuid, W2ST_MAX_CHAR_LEN,
 8022dc2:	1dab      	adds	r3, r5, #6
 8022dc4:	2101      	movs	r1, #1
 8022dc6:	9305      	str	r3, [sp, #20]
 8022dc8:	2310      	movs	r3, #16
 8022dca:	e9cd 3103 	strd	r3, r1, [sp, #12]
 8022dce:	2305      	movs	r3, #5
  COPY_CONFIG_W2ST_CHAR_UUID(uuid);
 8022dd0:	f88d 401c 	strb.w	r4, [sp, #28]
  ret =  aci_gatt_add_char(ConfigServW2STHandle, UUID_TYPE_128, uuid, W2ST_MAX_CHAR_LEN,
 8022dd4:	9302      	str	r3, [sp, #8]
  COPY_CONFIG_W2ST_CHAR_UUID(uuid);
 8022dd6:	f88d 4024 	strb.w	r4, [sp, #36]	; 0x24
  ret =  aci_gatt_add_char(ConfigServW2STHandle, UUID_TYPE_128, uuid, W2ST_MAX_CHAR_LEN,
 8022dda:	2314      	movs	r3, #20
 8022ddc:	4621      	mov	r1, r4
  COPY_CONFIG_W2ST_CHAR_UUID(uuid);
 8022dde:	2436      	movs	r4, #54	; 0x36
 8022de0:	4684      	mov	ip, r0
  ret =  aci_gatt_add_char(ConfigServW2STHandle, UUID_TYPE_128, uuid, W2ST_MAX_CHAR_LEN,
 8022de2:	9001      	str	r0, [sp, #4]
  COPY_CONFIG_W2ST_CHAR_UUID(uuid);
 8022de4:	f88d 001d 	strb.w	r0, [sp, #29]
 8022de8:	f88d 401e 	strb.w	r4, [sp, #30]
  ret =  aci_gatt_add_char(ConfigServW2STHandle, UUID_TYPE_128, uuid, W2ST_MAX_CHAR_LEN,
 8022dec:	88a8      	ldrh	r0, [r5, #4]
 8022dee:	9300      	str	r3, [sp, #0]
  COPY_CONFIG_W2ST_CHAR_UUID(uuid);
 8022df0:	24ac      	movs	r4, #172	; 0xac
  ret =  aci_gatt_add_char(ConfigServW2STHandle, UUID_TYPE_128, uuid, W2ST_MAX_CHAR_LEN,
 8022df2:	aa06      	add	r2, sp, #24
  COPY_CONFIG_W2ST_CHAR_UUID(uuid);
 8022df4:	f88d b018 	strb.w	fp, [sp, #24]
 8022df8:	f88d a019 	strb.w	sl, [sp, #25]
 8022dfc:	f88d 901a 	strb.w	r9, [sp, #26]
 8022e00:	f88d 801b 	strb.w	r8, [sp, #27]
 8022e04:	f88d 7020 	strb.w	r7, [sp, #32]
 8022e08:	f88d 6021 	strb.w	r6, [sp, #33]	; 0x21
 8022e0c:	f88d c023 	strb.w	ip, [sp, #35]	; 0x23
 8022e10:	f88d c025 	strb.w	ip, [sp, #37]	; 0x25
 8022e14:	f88d c026 	strb.w	ip, [sp, #38]	; 0x26
 8022e18:	f88d c027 	strb.w	ip, [sp, #39]	; 0x27
 8022e1c:	f88d 401f 	strb.w	r4, [sp, #31]
  ret =  aci_gatt_add_char(ConfigServW2STHandle, UUID_TYPE_128, uuid, W2ST_MAX_CHAR_LEN,
 8022e20:	f7f8 fca6 	bl	801b770 <aci_gatt_add_char>
                           ATTR_PERMISSION_NONE,
                           GATT_NOTIFY_ATTRIBUTE_WRITE | GATT_NOTIFY_READ_REQ_AND_WAIT_FOR_APPL_RESP,
                           16, 1, &ConfigCharHandle);
#endif /* SENSING1_BlueNRG2 */

  if (ret != BLE_STATUS_SUCCESS) {
 8022e24:	b910      	cbnz	r0, 8022e2c <Add_ConfigW2ST_Service+0xec>

  return BLE_STATUS_SUCCESS;

fail:
  return BLE_STATUS_ERROR;
}
 8022e26:	b00b      	add	sp, #44	; 0x2c
 8022e28:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  return BLE_STATUS_ERROR;
 8022e2c:	2047      	movs	r0, #71	; 0x47
}
 8022e2e:	b00b      	add	sp, #44	; 0x2c
 8022e30:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8022e34:	20014538 	.word	0x20014538

08022e38 <Add_ConsoleW2ST_Service>:
 * @brief  Add the Console service using a vendor specific profile
 * @param  None
 * @retval tBleStatus Status
 */
tBleStatus Add_ConsoleW2ST_Service(void)
{
 8022e38:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}

  uint8_t uuid[16];

  COPY_CONSOLE_SERVICE_UUID(uuid);
#ifndef SENSING1_BlueNRG2
  ret = aci_gatt_add_serv(UUID_TYPE_128,  uuid, PRIMARY_SERVICE, 1+3*2,&ConsoleW2STHandle);
 8022e3c:	4d5b      	ldr	r5, [pc, #364]	; (8022fac <Add_ConsoleW2ST_Service+0x174>)
{
 8022e3e:	b08b      	sub	sp, #44	; 0x2c
  COPY_CONSOLE_SERVICE_UUID(uuid);
 8022e40:	2300      	movs	r3, #0
 8022e42:	f88d 301d 	strb.w	r3, [sp, #29]
 8022e46:	f88d 3023 	strb.w	r3, [sp, #35]	; 0x23
 8022e4a:	f88d 3024 	strb.w	r3, [sp, #36]	; 0x24
 8022e4e:	f88d 3025 	strb.w	r3, [sp, #37]	; 0x25
 8022e52:	f88d 3026 	strb.w	r3, [sp, #38]	; 0x26
 8022e56:	f88d 3027 	strb.w	r3, [sp, #39]	; 0x27
  ret = aci_gatt_add_serv(UUID_TYPE_128,  uuid, PRIMARY_SERVICE, 1+3*2,&ConsoleW2STHandle);
 8022e5a:	f105 0308 	add.w	r3, r5, #8
 8022e5e:	9300      	str	r3, [sp, #0]
  COPY_CONSOLE_SERVICE_UUID(uuid);
 8022e60:	23b4      	movs	r3, #180	; 0xb4
 8022e62:	f88d 301e 	strb.w	r3, [sp, #30]
 8022e66:	239a      	movs	r3, #154	; 0x9a
 8022e68:	2402      	movs	r4, #2
 8022e6a:	f88d 301f 	strb.w	r3, [sp, #31]
 8022e6e:	f04f 030e 	mov.w	r3, #14
 8022e72:	f04f 0b1b 	mov.w	fp, #27
 8022e76:	f04f 0ac5 	mov.w	sl, #197	; 0xc5
 8022e7a:	f04f 09d5 	mov.w	r9, #213	; 0xd5
 8022e7e:	f04f 08a5 	mov.w	r8, #165	; 0xa5
 8022e82:	27e1      	movs	r7, #225	; 0xe1
 8022e84:	2611      	movs	r6, #17
 8022e86:	f88d 3022 	strb.w	r3, [sp, #34]	; 0x22
  ret = aci_gatt_add_serv(UUID_TYPE_128,  uuid, PRIMARY_SERVICE, 1+3*2,&ConsoleW2STHandle);
 8022e8a:	2201      	movs	r2, #1
 8022e8c:	2307      	movs	r3, #7
 8022e8e:	a906      	add	r1, sp, #24
 8022e90:	4620      	mov	r0, r4
  COPY_CONSOLE_SERVICE_UUID(uuid);
 8022e92:	f88d b018 	strb.w	fp, [sp, #24]
 8022e96:	f88d a019 	strb.w	sl, [sp, #25]
 8022e9a:	f88d 901a 	strb.w	r9, [sp, #26]
 8022e9e:	f88d 401c 	strb.w	r4, [sp, #28]
 8022ea2:	f88d 801b 	strb.w	r8, [sp, #27]
 8022ea6:	f88d 7020 	strb.w	r7, [sp, #32]
 8022eaa:	f88d 6021 	strb.w	r6, [sp, #33]	; 0x21
  ret = aci_gatt_add_serv(UUID_TYPE_128,  uuid, PRIMARY_SERVICE, 1+3*2,&ConsoleW2STHandle);
 8022eae:	f7f8 fc15 	bl	801b6dc <aci_gatt_add_serv>
#else /* SENSING1_BlueNRG2 */
  BLUENRG_memcpy(&service_uuid.Service_UUID_128, uuid, 16);
  ret = aci_gatt_add_service(UUID_TYPE_128,  &service_uuid, PRIMARY_SERVICE, 1+3*2,&ConsoleW2STHandle);
#endif /* SENSING1_BlueNRG2 */
  if (ret != BLE_STATUS_SUCCESS) {
 8022eb2:	2800      	cmp	r0, #0
 8022eb4:	d176      	bne.n	8022fa4 <Add_ConsoleW2ST_Service+0x16c>
    goto fail;
  }

  COPY_TERM_CHAR_UUID(uuid);
 8022eb6:	f04f 030e 	mov.w	r3, #14
#ifndef SENSING1_BlueNRG2
  ret =  aci_gatt_add_char(ConsoleW2STHandle, UUID_TYPE_128, uuid, W2ST_MAX_CHAR_LEN,
 8022eba:	2201      	movs	r2, #1
  COPY_TERM_CHAR_UUID(uuid);
 8022ebc:	f88d 3022 	strb.w	r3, [sp, #34]	; 0x22
  ret =  aci_gatt_add_char(ConsoleW2STHandle, UUID_TYPE_128, uuid, W2ST_MAX_CHAR_LEN,
 8022ec0:	f105 030a 	add.w	r3, r5, #10
 8022ec4:	9204      	str	r2, [sp, #16]
  COPY_TERM_CHAR_UUID(uuid);
 8022ec6:	f88d 2024 	strb.w	r2, [sp, #36]	; 0x24
  ret =  aci_gatt_add_char(ConsoleW2STHandle, UUID_TYPE_128, uuid, W2ST_MAX_CHAR_LEN,
 8022eca:	9305      	str	r3, [sp, #20]
 8022ecc:	2210      	movs	r2, #16
 8022ece:	2305      	movs	r3, #5
 8022ed0:	f10d 0c18 	add.w	ip, sp, #24
 8022ed4:	9203      	str	r2, [sp, #12]
 8022ed6:	9302      	str	r3, [sp, #8]
  COPY_TERM_CHAR_UUID(uuid);
 8022ed8:	f04f 0236 	mov.w	r2, #54	; 0x36
  ret =  aci_gatt_add_char(ConsoleW2STHandle, UUID_TYPE_128, uuid, W2ST_MAX_CHAR_LEN,
 8022edc:	231e      	movs	r3, #30
  COPY_TERM_CHAR_UUID(uuid);
 8022ede:	f06f 0153 	mvn.w	r1, #83	; 0x53
  ret =  aci_gatt_add_char(ConsoleW2STHandle, UUID_TYPE_128, uuid, W2ST_MAX_CHAR_LEN,
 8022ee2:	9001      	str	r0, [sp, #4]
  COPY_TERM_CHAR_UUID(uuid);
 8022ee4:	f88d 001d 	strb.w	r0, [sp, #29]
 8022ee8:	f88d 0023 	strb.w	r0, [sp, #35]	; 0x23
 8022eec:	f88d 0025 	strb.w	r0, [sp, #37]	; 0x25
 8022ef0:	f88d 0026 	strb.w	r0, [sp, #38]	; 0x26
 8022ef4:	f88d 0027 	strb.w	r0, [sp, #39]	; 0x27
  ret =  aci_gatt_add_char(ConsoleW2STHandle, UUID_TYPE_128, uuid, W2ST_MAX_CHAR_LEN,
 8022ef8:	9300      	str	r3, [sp, #0]
  COPY_TERM_CHAR_UUID(uuid);
 8022efa:	f88d 201e 	strb.w	r2, [sp, #30]
 8022efe:	f88d 101f 	strb.w	r1, [sp, #31]
  ret =  aci_gatt_add_char(ConsoleW2STHandle, UUID_TYPE_128, uuid, W2ST_MAX_CHAR_LEN,
 8022f02:	4662      	mov	r2, ip
 8022f04:	8928      	ldrh	r0, [r5, #8]
  COPY_TERM_CHAR_UUID(uuid);
 8022f06:	f88d b018 	strb.w	fp, [sp, #24]
  ret =  aci_gatt_add_char(ConsoleW2STHandle, UUID_TYPE_128, uuid, W2ST_MAX_CHAR_LEN,
 8022f0a:	2314      	movs	r3, #20
 8022f0c:	4621      	mov	r1, r4
  COPY_TERM_CHAR_UUID(uuid);
 8022f0e:	f88d a019 	strb.w	sl, [sp, #25]
 8022f12:	f88d 901a 	strb.w	r9, [sp, #26]
 8022f16:	f88d 801b 	strb.w	r8, [sp, #27]
 8022f1a:	f88d 401c 	strb.w	r4, [sp, #28]
 8022f1e:	f88d 7020 	strb.w	r7, [sp, #32]
 8022f22:	f88d 6021 	strb.w	r6, [sp, #33]	; 0x21
  ret =  aci_gatt_add_char(ConsoleW2STHandle, UUID_TYPE_128, uuid, W2ST_MAX_CHAR_LEN,
 8022f26:	f7f8 fc23 	bl	801b770 <aci_gatt_add_char>
                           ATTR_PERMISSION_NONE,
                           GATT_NOTIFY_ATTRIBUTE_WRITE | GATT_NOTIFY_READ_REQ_AND_WAIT_FOR_APPL_RESP,
                           16, 1, &TermCharHandle);
#endif /* SENSING1_BlueNRG2 */  

  if (ret != BLE_STATUS_SUCCESS) {
 8022f2a:	4684      	mov	ip, r0
 8022f2c:	2800      	cmp	r0, #0
 8022f2e:	d139      	bne.n	8022fa4 <Add_ConsoleW2ST_Service+0x16c>
    goto fail;
  }

  COPY_STDERR_CHAR_UUID(uuid);
 8022f30:	f04f 030e 	mov.w	r3, #14
 8022f34:	f88d 3022 	strb.w	r3, [sp, #34]	; 0x22
#ifndef SENSING1_BlueNRG2
  ret =  aci_gatt_add_char(ConsoleW2STHandle, UUID_TYPE_128, uuid, W2ST_MAX_CHAR_LEN,
 8022f38:	f105 030c 	add.w	r3, r5, #12
 8022f3c:	2001      	movs	r0, #1
 8022f3e:	9305      	str	r3, [sp, #20]
 8022f40:	2304      	movs	r3, #4
  COPY_STDERR_CHAR_UUID(uuid);
 8022f42:	f04f 0236 	mov.w	r2, #54	; 0x36
 8022f46:	f06f 0153 	mvn.w	r1, #83	; 0x53
  ret =  aci_gatt_add_char(ConsoleW2STHandle, UUID_TYPE_128, uuid, W2ST_MAX_CHAR_LEN,
 8022f4a:	9004      	str	r0, [sp, #16]
 8022f4c:	9302      	str	r3, [sp, #8]
 8022f4e:	2010      	movs	r0, #16
 8022f50:	2312      	movs	r3, #18
 8022f52:	9003      	str	r0, [sp, #12]
  COPY_STDERR_CHAR_UUID(uuid);
 8022f54:	f88d 201e 	strb.w	r2, [sp, #30]
 8022f58:	f88d 101f 	strb.w	r1, [sp, #31]
  ret =  aci_gatt_add_char(ConsoleW2STHandle, UUID_TYPE_128, uuid, W2ST_MAX_CHAR_LEN,
 8022f5c:	9300      	str	r3, [sp, #0]
 8022f5e:	8928      	ldrh	r0, [r5, #8]
 8022f60:	f8cd c004 	str.w	ip, [sp, #4]
 8022f64:	aa06      	add	r2, sp, #24
 8022f66:	2314      	movs	r3, #20
 8022f68:	4621      	mov	r1, r4
  COPY_STDERR_CHAR_UUID(uuid);
 8022f6a:	f88d b018 	strb.w	fp, [sp, #24]
 8022f6e:	f88d a019 	strb.w	sl, [sp, #25]
 8022f72:	f88d 901a 	strb.w	r9, [sp, #26]
 8022f76:	f88d 801b 	strb.w	r8, [sp, #27]
 8022f7a:	f88d 7020 	strb.w	r7, [sp, #32]
 8022f7e:	f88d 6021 	strb.w	r6, [sp, #33]	; 0x21
 8022f82:	f88d 401c 	strb.w	r4, [sp, #28]
 8022f86:	f88d c01d 	strb.w	ip, [sp, #29]
 8022f8a:	f88d c023 	strb.w	ip, [sp, #35]	; 0x23
 8022f8e:	f88d 4024 	strb.w	r4, [sp, #36]	; 0x24
 8022f92:	f88d c025 	strb.w	ip, [sp, #37]	; 0x25
 8022f96:	f88d c026 	strb.w	ip, [sp, #38]	; 0x26
 8022f9a:	f88d c027 	strb.w	ip, [sp, #39]	; 0x27
  ret =  aci_gatt_add_char(ConsoleW2STHandle, UUID_TYPE_128, uuid, W2ST_MAX_CHAR_LEN,
 8022f9e:	f7f8 fbe7 	bl	801b770 <aci_gatt_add_char>
                           ATTR_PERMISSION_NONE,
                           GATT_NOTIFY_READ_REQ_AND_WAIT_FOR_APPL_RESP,
                           16, 1, &StdErrCharHandle);
#endif /* SENSING1_BlueNRG2 */ 

  if (ret != BLE_STATUS_SUCCESS) {
 8022fa2:	b100      	cbz	r0, 8022fa6 <Add_ConsoleW2ST_Service+0x16e>
  }

  return BLE_STATUS_SUCCESS;

fail:
  return BLE_STATUS_ERROR;
 8022fa4:	2047      	movs	r0, #71	; 0x47
}
 8022fa6:	b00b      	add	sp, #44	; 0x2c
 8022fa8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8022fac:	20014538 	.word	0x20014538

08022fb0 <UpdateTermStdOut>:


tBleStatus UpdateTermStdOut(uint8_t *data,uint8_t length)
{
 8022fb0:	b510      	push	{r4, lr}
  if (aci_gatt_update_char_value(ConsoleW2STHandle, TermCharHandle, 0, length , data) != BLE_STATUS_SUCCESS) {
 8022fb2:	4a10      	ldr	r2, [pc, #64]	; (8022ff4 <UpdateTermStdOut+0x44>)
{
 8022fb4:	b082      	sub	sp, #8
 8022fb6:	4604      	mov	r4, r0
 8022fb8:	460b      	mov	r3, r1
  if (aci_gatt_update_char_value(ConsoleW2STHandle, TermCharHandle, 0, length , data) != BLE_STATUS_SUCCESS) {
 8022fba:	8910      	ldrh	r0, [r2, #8]
 8022fbc:	8951      	ldrh	r1, [r2, #10]
 8022fbe:	9400      	str	r4, [sp, #0]
 8022fc0:	2200      	movs	r2, #0
 8022fc2:	f7f8 fc55 	bl	801b870 <aci_gatt_update_char_value>
 8022fc6:	b930      	cbnz	r0, 8022fd6 <UpdateTermStdOut+0x26>
 8022fc8:	4604      	mov	r4, r0
      SENSING1_PRINTF("Error Updating Stdout Char\r\n");
    return BLE_STATUS_ERROR;
  }
  osDelay(20);
 8022fca:	2014      	movs	r0, #20
 8022fcc:	f7f5 fc7a 	bl	80188c4 <osDelay>
  return BLE_STATUS_SUCCESS;
}
 8022fd0:	4620      	mov	r0, r4
 8022fd2:	b002      	add	sp, #8
 8022fd4:	bd10      	pop	{r4, pc}
      SENSING1_PRINTF("Error Updating Stdout Char\r\n");
 8022fd6:	4b08      	ldr	r3, [pc, #32]	; (8022ff8 <UpdateTermStdOut+0x48>)
 8022fd8:	781b      	ldrb	r3, [r3, #0]
 8022fda:	b91b      	cbnz	r3, 8022fe4 <UpdateTermStdOut+0x34>
    return BLE_STATUS_ERROR;
 8022fdc:	2447      	movs	r4, #71	; 0x47
}
 8022fde:	4620      	mov	r0, r4
 8022fe0:	b002      	add	sp, #8
 8022fe2:	bd10      	pop	{r4, pc}
      SENSING1_PRINTF("Error Updating Stdout Char\r\n");
 8022fe4:	4805      	ldr	r0, [pc, #20]	; (8022ffc <UpdateTermStdOut+0x4c>)
 8022fe6:	f005 f8b5 	bl	8028154 <puts>
    return BLE_STATUS_ERROR;
 8022fea:	2447      	movs	r4, #71	; 0x47
}
 8022fec:	4620      	mov	r0, r4
 8022fee:	b002      	add	sp, #8
 8022ff0:	bd10      	pop	{r4, pc}
 8022ff2:	bf00      	nop
 8022ff4:	20014538 	.word	0x20014538
 8022ff8:	20000d84 	.word	0x20000d84
 8022ffc:	08043c28 	.word	0x08043c28

08023000 <UpdateTermStdErr>:

tBleStatus UpdateTermStdErr(uint8_t *data,uint8_t length)
{
 8023000:	b510      	push	{r4, lr}
  if (aci_gatt_update_char_value(ConsoleW2STHandle, StdErrCharHandle, 0, length , data) != BLE_STATUS_SUCCESS) {
 8023002:	4a10      	ldr	r2, [pc, #64]	; (8023044 <UpdateTermStdErr+0x44>)
{
 8023004:	b082      	sub	sp, #8
 8023006:	4604      	mov	r4, r0
 8023008:	460b      	mov	r3, r1
  if (aci_gatt_update_char_value(ConsoleW2STHandle, StdErrCharHandle, 0, length , data) != BLE_STATUS_SUCCESS) {
 802300a:	8910      	ldrh	r0, [r2, #8]
 802300c:	8991      	ldrh	r1, [r2, #12]
 802300e:	9400      	str	r4, [sp, #0]
 8023010:	2200      	movs	r2, #0
 8023012:	f7f8 fc2d 	bl	801b870 <aci_gatt_update_char_value>
 8023016:	b930      	cbnz	r0, 8023026 <UpdateTermStdErr+0x26>
 8023018:	4604      	mov	r4, r0
      SENSING1_PRINTF("Error Updating StdErr Char\r\n");
    return BLE_STATUS_ERROR;
  }
  osDelay(20);
 802301a:	2014      	movs	r0, #20
 802301c:	f7f5 fc52 	bl	80188c4 <osDelay>
  return BLE_STATUS_SUCCESS;
}
 8023020:	4620      	mov	r0, r4
 8023022:	b002      	add	sp, #8
 8023024:	bd10      	pop	{r4, pc}
      SENSING1_PRINTF("Error Updating StdErr Char\r\n");
 8023026:	4b08      	ldr	r3, [pc, #32]	; (8023048 <UpdateTermStdErr+0x48>)
 8023028:	781b      	ldrb	r3, [r3, #0]
 802302a:	b91b      	cbnz	r3, 8023034 <UpdateTermStdErr+0x34>
    return BLE_STATUS_ERROR;
 802302c:	2447      	movs	r4, #71	; 0x47
}
 802302e:	4620      	mov	r0, r4
 8023030:	b002      	add	sp, #8
 8023032:	bd10      	pop	{r4, pc}
      SENSING1_PRINTF("Error Updating StdErr Char\r\n");
 8023034:	4805      	ldr	r0, [pc, #20]	; (802304c <UpdateTermStdErr+0x4c>)
 8023036:	f005 f88d 	bl	8028154 <puts>
    return BLE_STATUS_ERROR;
 802303a:	2447      	movs	r4, #71	; 0x47
}
 802303c:	4620      	mov	r0, r4
 802303e:	b002      	add	sp, #8
 8023040:	bd10      	pop	{r4, pc}
 8023042:	bf00      	nop
 8023044:	20014538 	.word	0x20014538
 8023048:	20000d84 	.word	0x20000d84
 802304c:	08043c44 	.word	0x08043c44

08023050 <Stderr_Update>:
 * @param  uint8_t *data string to write
 * @param  uint8_t length length of string to write
 * @retval tBleStatus      Status
 */
tBleStatus Stderr_Update(uint8_t *data, uint8_t length)
{
 8023050:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 8023054:	b08d      	sub	sp, #52	; 0x34
  uint8_t Offset;
  uint8_t DataToSend;
  msgData_t msg;
  msg.type        = TERM_STDERR;
 8023056:	230e      	movs	r3, #14
 8023058:	f88d 3008 	strb.w	r3, [sp, #8]

  /* Split the code in packages*/
  for(Offset =0; Offset<length; Offset +=W2ST_MAX_CHAR_LEN){
 802305c:	b311      	cbz	r1, 80230a4 <Stderr_Update+0x54>
 802305e:	4f13      	ldr	r7, [pc, #76]	; (80230ac <Stderr_Update+0x5c>)
 8023060:	4606      	mov	r6, r0
 8023062:	4689      	mov	r9, r1
 8023064:	2500      	movs	r5, #0
    DataToSend = (length-Offset);
    DataToSend = (DataToSend>W2ST_MAX_CHAR_LEN) ?  W2ST_MAX_CHAR_LEN : DataToSend;

    /* keep a copy */
    memcpy(LastStderrBuffer,data+Offset,DataToSend);
 8023066:	f107 0810 	add.w	r8, r7, #16
    DataToSend = (DataToSend>W2ST_MAX_CHAR_LEN) ?  W2ST_MAX_CHAR_LEN : DataToSend;
 802306a:	eba9 0405 	sub.w	r4, r9, r5
 802306e:	b2e4      	uxtb	r4, r4
 8023070:	2c14      	cmp	r4, #20
 8023072:	bf28      	it	cs
 8023074:	2414      	movcs	r4, #20
    memcpy(LastStderrBuffer,data+Offset,DataToSend);
 8023076:	1971      	adds	r1, r6, r5
 8023078:	4622      	mov	r2, r4
 802307a:	4640      	mov	r0, r8
 802307c:	9101      	str	r1, [sp, #4]
  for(Offset =0; Offset<length; Offset +=W2ST_MAX_CHAR_LEN){
 802307e:	3514      	adds	r5, #20
    memcpy(LastStderrBuffer,data+Offset,DataToSend);
 8023080:	f004 fa52 	bl	8027528 <memcpy>
    LastStderrLen = DataToSend;

    msg.term.length   =  DataToSend;
    memcpy(msg.term.data,data+Offset,DataToSend);
 8023084:	9901      	ldr	r1, [sp, #4]
    LastStderrLen = DataToSend;
 8023086:	f887 4024 	strb.w	r4, [r7, #36]	; 0x24
    memcpy(msg.term.data,data+Offset,DataToSend);
 802308a:	4622      	mov	r2, r4
 802308c:	f10d 000d 	add.w	r0, sp, #13
    msg.term.length   =  DataToSend;
 8023090:	f88d 400c 	strb.w	r4, [sp, #12]
  for(Offset =0; Offset<length; Offset +=W2ST_MAX_CHAR_LEN){
 8023094:	b2ed      	uxtb	r5, r5
    memcpy(msg.term.data,data+Offset,DataToSend);
 8023096:	f004 fa47 	bl	8027528 <memcpy>
    SendMsgToHost(&msg);
 802309a:	a802      	add	r0, sp, #8
 802309c:	f7fe fbdc 	bl	8021858 <SendMsgToHost>
  for(Offset =0; Offset<length; Offset +=W2ST_MAX_CHAR_LEN){
 80230a0:	45a9      	cmp	r9, r5
 80230a2:	d8e2      	bhi.n	802306a <Stderr_Update+0x1a>

  }
  return BLE_STATUS_SUCCESS;
}
 80230a4:	2000      	movs	r0, #0
 80230a6:	b00d      	add	sp, #52	; 0x34
 80230a8:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 80230ac:	20014538 	.word	0x20014538

080230b0 <Term_Update>:
 * @param  uint8_t *data string to write
 * @param  uint32_t length Length of string to write
 * @retval tBleStatus      Status
 */
tBleStatus Term_Update(uint8_t *data, uint8_t length)
{
 80230b0:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 80230b4:	b08d      	sub	sp, #52	; 0x34
  uint32_t  Offset;
  uint8_t   DataToSend;
  msgData_t msg;
  msg.type = TERM_STDOUT;
 80230b6:	230d      	movs	r3, #13
 80230b8:	f88d 3008 	strb.w	r3, [sp, #8]

  /* Split the code in packages */
  for(Offset =0; Offset<length; Offset +=W2ST_MAX_CHAR_LEN){
 80230bc:	b309      	cbz	r1, 8023102 <Term_Update+0x52>
 80230be:	4f13      	ldr	r7, [pc, #76]	; (802310c <Term_Update+0x5c>)
 80230c0:	4606      	mov	r6, r0
 80230c2:	4689      	mov	r9, r1
 80230c4:	2500      	movs	r5, #0
    DataToSend = (length-Offset);
    DataToSend = (DataToSend>W2ST_MAX_CHAR_LEN) ?  W2ST_MAX_CHAR_LEN : DataToSend;

    /* keep a copy */
    memcpy(LastTermBuffer,data+Offset,DataToSend);
 80230c6:	f107 0828 	add.w	r8, r7, #40	; 0x28
    DataToSend = (DataToSend>W2ST_MAX_CHAR_LEN) ?  W2ST_MAX_CHAR_LEN : DataToSend;
 80230ca:	eba9 0405 	sub.w	r4, r9, r5
 80230ce:	b2e4      	uxtb	r4, r4
 80230d0:	2c14      	cmp	r4, #20
 80230d2:	bf28      	it	cs
 80230d4:	2414      	movcs	r4, #20
    memcpy(LastTermBuffer,data+Offset,DataToSend);
 80230d6:	1971      	adds	r1, r6, r5
 80230d8:	4622      	mov	r2, r4
 80230da:	4640      	mov	r0, r8
 80230dc:	9101      	str	r1, [sp, #4]
 80230de:	f004 fa23 	bl	8027528 <memcpy>
    LastTermLen = DataToSend;

    msg.term.length   =  DataToSend;
    memcpy(msg.term.data,data+Offset,DataToSend);
 80230e2:	9901      	ldr	r1, [sp, #4]
    LastTermLen = DataToSend;
 80230e4:	f887 403c 	strb.w	r4, [r7, #60]	; 0x3c
    memcpy(msg.term.data,data+Offset,DataToSend);
 80230e8:	4622      	mov	r2, r4
 80230ea:	f10d 000d 	add.w	r0, sp, #13
    msg.term.length   =  DataToSend;
 80230ee:	f88d 400c 	strb.w	r4, [sp, #12]
  for(Offset =0; Offset<length; Offset +=W2ST_MAX_CHAR_LEN){
 80230f2:	3514      	adds	r5, #20
    memcpy(msg.term.data,data+Offset,DataToSend);
 80230f4:	f004 fa18 	bl	8027528 <memcpy>
    SendMsgToHost(&msg);
 80230f8:	a802      	add	r0, sp, #8
 80230fa:	f7fe fbad 	bl	8021858 <SendMsgToHost>
  for(Offset =0; Offset<length; Offset +=W2ST_MAX_CHAR_LEN){
 80230fe:	454d      	cmp	r5, r9
 8023100:	d3e3      	bcc.n	80230ca <Term_Update+0x1a>
  }
  return BLE_STATUS_SUCCESS;
}
 8023102:	2000      	movs	r0, #0
 8023104:	b00d      	add	sp, #52	; 0x34
 8023106:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 802310a:	bf00      	nop
 802310c:	20014538 	.word	0x20014538

08023110 <ActivityRec_Update>:
 * @brief  Update Activity Recognition value
 * @param  HAR_output_t ActivityCode Activity Recognized
 * @retval tBleStatus      Status
 */
tBleStatus ActivityRec_Update(HAR_output_t ActivityCode, HAR_algoIdx_t algoIdx)
{
 8023110:	b570      	push	{r4, r5, r6, lr}
 8023112:	b084      	sub	sp, #16
 8023114:	460c      	mov	r4, r1
 8023116:	4605      	mov	r5, r0
  tBleStatus ret;
  uint8_t buff[2+1+1];

  STORE_LE_16(buff  ,(HAL_GetTick()>>3));
 8023118:	f7ec fb8e 	bl	800f838 <HAL_GetTick>
 802311c:	08c0      	lsrs	r0, r0, #3
 802311e:	f88d 000c 	strb.w	r0, [sp, #12]
 8023122:	f7ec fb89 	bl	800f838 <HAL_GetTick>
  buff[2] = ActivityCode;
  
  if (HAR_IGN_WSDM_IDX == algoIdx) {
 8023126:	2c02      	cmp	r4, #2
  STORE_LE_16(buff  ,(HAL_GetTick()>>3));
 8023128:	ea4f 20d0 	mov.w	r0, r0, lsr #11
 802312c:	f88d 000d 	strb.w	r0, [sp, #13]
  buff[2] = ActivityCode;
 8023130:	f88d 500e 	strb.w	r5, [sp, #14]
  if (HAR_IGN_WSDM_IDX == algoIdx) {
 8023134:	d012      	beq.n	802315c <ActivityRec_Update+0x4c>
    buff[3] = HAR_IGN_WSDM_ALG_ID;
  } else if (HAR_IGN_IDX == algoIdx) {
    buff[3] = HAR_IGN_ALG_ID ;
  }else if (HAR_GMP_IDX == algoIdx) {
 8023136:	2c01      	cmp	r4, #1
 8023138:	d90c      	bls.n	8023154 <ActivityRec_Update+0x44>
    buff[3] = HAR_GMP_ALG_ID;
  }

  ret = aci_gatt_update_char_value(HWServW2STHandle, ActivityRecCharHandle, 0, 2+1+1, buff);
 802313a:	4c1f      	ldr	r4, [pc, #124]	; (80231b8 <ActivityRec_Update+0xa8>)
 802313c:	ab03      	add	r3, sp, #12
 802313e:	8fe1      	ldrh	r1, [r4, #62]	; 0x3e
 8023140:	f8b4 0040 	ldrh.w	r0, [r4, #64]	; 0x40
 8023144:	9300      	str	r3, [sp, #0]
 8023146:	2200      	movs	r2, #0
 8023148:	2304      	movs	r3, #4
 802314a:	f7f8 fb91 	bl	801b870 <aci_gatt_update_char_value>

  if (ret != BLE_STATUS_SUCCESS){
 802314e:	b940      	cbnz	r0, 8023162 <ActivityRec_Update+0x52>
      SENSING1_PRINTF("Error Updating ActivityRec Char\r\n");
    }
    return BLE_STATUS_ERROR;
  }
  return BLE_STATUS_SUCCESS;
}
 8023150:	b004      	add	sp, #16
 8023152:	bd70      	pop	{r4, r5, r6, pc}
    buff[3] = HAR_IGN_ALG_ID ;
 8023154:	2301      	movs	r3, #1
 8023156:	f88d 300f 	strb.w	r3, [sp, #15]
 802315a:	e7ee      	b.n	802313a <ActivityRec_Update+0x2a>
    buff[3] = HAR_IGN_WSDM_ALG_ID;
 802315c:	f88d 400f 	strb.w	r4, [sp, #15]
 8023160:	e7eb      	b.n	802313a <ActivityRec_Update+0x2a>
    if(W2ST_CHECK_CONNECTION(W2ST_CONNECT_STD_ERR)){
 8023162:	6c63      	ldr	r3, [r4, #68]	; 0x44
 8023164:	065b      	lsls	r3, r3, #25
 8023166:	d404      	bmi.n	8023172 <ActivityRec_Update+0x62>
      SENSING1_PRINTF("Error Updating ActivityRec Char\r\n");
 8023168:	4b14      	ldr	r3, [pc, #80]	; (80231bc <ActivityRec_Update+0xac>)
 802316a:	781b      	ldrb	r3, [r3, #0]
 802316c:	b9fb      	cbnz	r3, 80231ae <ActivityRec_Update+0x9e>
    return BLE_STATUS_ERROR;
 802316e:	2047      	movs	r0, #71	; 0x47
 8023170:	e7ee      	b.n	8023150 <ActivityRec_Update+0x40>
      BytesToWrite =sprintf((char *)BufferToWrite, "Error Updating ActivityRec Char\n");
 8023172:	4e13      	ldr	r6, [pc, #76]	; (80231c0 <ActivityRec_Update+0xb0>)
 8023174:	4d13      	ldr	r5, [pc, #76]	; (80231c4 <ActivityRec_Update+0xb4>)
 8023176:	f106 0c20 	add.w	ip, r6, #32
 802317a:	4634      	mov	r4, r6
 802317c:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 802317e:	4564      	cmp	r4, ip
 8023180:	f105 0510 	add.w	r5, r5, #16
 8023184:	f106 0610 	add.w	r6, r6, #16
 8023188:	f845 0c10 	str.w	r0, [r5, #-16]
 802318c:	f845 1c0c 	str.w	r1, [r5, #-12]
 8023190:	f845 2c08 	str.w	r2, [r5, #-8]
 8023194:	f845 3c04 	str.w	r3, [r5, #-4]
 8023198:	d1ef      	bne.n	802317a <ActivityRec_Update+0x6a>
 802319a:	4b0b      	ldr	r3, [pc, #44]	; (80231c8 <ActivityRec_Update+0xb8>)
 802319c:	7832      	ldrb	r2, [r6, #0]
 802319e:	702a      	strb	r2, [r5, #0]
 80231a0:	2120      	movs	r1, #32
      Stderr_Update(BufferToWrite,BytesToWrite);
 80231a2:	4808      	ldr	r0, [pc, #32]	; (80231c4 <ActivityRec_Update+0xb4>)
      BytesToWrite =sprintf((char *)BufferToWrite, "Error Updating ActivityRec Char\n");
 80231a4:	6019      	str	r1, [r3, #0]
      Stderr_Update(BufferToWrite,BytesToWrite);
 80231a6:	f7ff ff53 	bl	8023050 <Stderr_Update>
    return BLE_STATUS_ERROR;
 80231aa:	2047      	movs	r0, #71	; 0x47
 80231ac:	e7d0      	b.n	8023150 <ActivityRec_Update+0x40>
      SENSING1_PRINTF("Error Updating ActivityRec Char\r\n");
 80231ae:	4807      	ldr	r0, [pc, #28]	; (80231cc <ActivityRec_Update+0xbc>)
 80231b0:	f004 ffd0 	bl	8028154 <puts>
    return BLE_STATUS_ERROR;
 80231b4:	2047      	movs	r0, #71	; 0x47
 80231b6:	e7cb      	b.n	8023150 <ActivityRec_Update+0x40>
 80231b8:	20014538 	.word	0x20014538
 80231bc:	20000d84 	.word	0x20000d84
 80231c0:	08043c60 	.word	0x08043c60
 80231c4:	200133dc 	.word	0x200133dc
 80231c8:	200134dc 	.word	0x200134dc
 80231cc:	08043c84 	.word	0x08043c84

080231d0 <AudioSRec_Update>:
 * @brief  Update Audio Scene Recognition value
 * @param  ASC_OutputTypeDef SceneClassificationCode Scene Recognized
 * @retval tBleStatus      Status
 */
tBleStatus AudioSRec_Update(ASC_OutputTypeDef SceneClassificationCode)
{
 80231d0:	b530      	push	{r4, r5, lr}
 80231d2:	b085      	sub	sp, #20
 80231d4:	4604      	mov	r4, r0
  tBleStatus ret;

  uint8_t buff[2+ 1];

  STORE_LE_16(buff, (HAL_GetTick() >> 3));
 80231d6:	f7ec fb2f 	bl	800f838 <HAL_GetTick>
 80231da:	08c0      	lsrs	r0, r0, #3
 80231dc:	f88d 000c 	strb.w	r0, [sp, #12]
 80231e0:	f7ec fb2a 	bl	800f838 <HAL_GetTick>
  buff[2] = SceneClassificationCode;

  ret = aci_gatt_update_char_value(HWServW2STHandle, AudioSRecCharHandle, 0, 2+1, buff);
 80231e4:	4d1a      	ldr	r5, [pc, #104]	; (8023250 <AudioSRec_Update+0x80>)
  buff[2] = SceneClassificationCode;
 80231e6:	f88d 400e 	strb.w	r4, [sp, #14]
  ret = aci_gatt_update_char_value(HWServW2STHandle, AudioSRecCharHandle, 0, 2+1, buff);
 80231ea:	ab03      	add	r3, sp, #12
 80231ec:	9300      	str	r3, [sp, #0]
  STORE_LE_16(buff, (HAL_GetTick() >> 3));
 80231ee:	0ac0      	lsrs	r0, r0, #11
 80231f0:	f88d 000d 	strb.w	r0, [sp, #13]
  ret = aci_gatt_update_char_value(HWServW2STHandle, AudioSRecCharHandle, 0, 2+1, buff);
 80231f4:	f8b5 1048 	ldrh.w	r1, [r5, #72]	; 0x48
 80231f8:	f8b5 0040 	ldrh.w	r0, [r5, #64]	; 0x40
 80231fc:	2303      	movs	r3, #3
 80231fe:	2200      	movs	r2, #0
 8023200:	f7f8 fb36 	bl	801b870 <aci_gatt_update_char_value>

  if (ret != BLE_STATUS_SUCCESS) {
 8023204:	b908      	cbnz	r0, 802320a <AudioSRec_Update+0x3a>
      SENSING1_PRINTF("Error Updating AudioRec Char\r\n");
    }
    return BLE_STATUS_ERROR;
  }
  return BLE_STATUS_SUCCESS;
}
 8023206:	b005      	add	sp, #20
 8023208:	bd30      	pop	{r4, r5, pc}
    if(W2ST_CHECK_CONNECTION(W2ST_CONNECT_STD_ERR)){
 802320a:	6c6b      	ldr	r3, [r5, #68]	; 0x44
 802320c:	065b      	lsls	r3, r3, #25
 802320e:	d404      	bmi.n	802321a <AudioSRec_Update+0x4a>
      SENSING1_PRINTF("Error Updating AudioRec Char\r\n");
 8023210:	4b10      	ldr	r3, [pc, #64]	; (8023254 <AudioSRec_Update+0x84>)
 8023212:	781b      	ldrb	r3, [r3, #0]
 8023214:	b9bb      	cbnz	r3, 8023246 <AudioSRec_Update+0x76>
 8023216:	2047      	movs	r0, #71	; 0x47
 8023218:	e7f5      	b.n	8023206 <AudioSRec_Update+0x36>
      BytesToWrite =sprintf((char *)BufferToWrite, "Error Updating AudioRec Char\n");
 802321a:	4c0f      	ldr	r4, [pc, #60]	; (8023258 <AudioSRec_Update+0x88>)
 802321c:	4d0f      	ldr	r5, [pc, #60]	; (802325c <AudioSRec_Update+0x8c>)
 802321e:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 8023220:	6028      	str	r0, [r5, #0]
 8023222:	6069      	str	r1, [r5, #4]
 8023224:	60aa      	str	r2, [r5, #8]
 8023226:	cc07      	ldmia	r4!, {r0, r1, r2}
 8023228:	6128      	str	r0, [r5, #16]
 802322a:	480d      	ldr	r0, [pc, #52]	; (8023260 <AudioSRec_Update+0x90>)
 802322c:	8824      	ldrh	r4, [r4, #0]
 802322e:	60eb      	str	r3, [r5, #12]
 8023230:	231d      	movs	r3, #29
 8023232:	6003      	str	r3, [r0, #0]
 8023234:	6169      	str	r1, [r5, #20]
 8023236:	61aa      	str	r2, [r5, #24]
      Stderr_Update(BufferToWrite, BytesToWrite);
 8023238:	4619      	mov	r1, r3
 802323a:	4628      	mov	r0, r5
      BytesToWrite =sprintf((char *)BufferToWrite, "Error Updating AudioRec Char\n");
 802323c:	83ac      	strh	r4, [r5, #28]
      Stderr_Update(BufferToWrite, BytesToWrite);
 802323e:	f7ff ff07 	bl	8023050 <Stderr_Update>
 8023242:	2047      	movs	r0, #71	; 0x47
 8023244:	e7df      	b.n	8023206 <AudioSRec_Update+0x36>
      SENSING1_PRINTF("Error Updating AudioRec Char\r\n");
 8023246:	4807      	ldr	r0, [pc, #28]	; (8023264 <AudioSRec_Update+0x94>)
 8023248:	f004 ff84 	bl	8028154 <puts>
 802324c:	2047      	movs	r0, #71	; 0x47
 802324e:	e7da      	b.n	8023206 <AudioSRec_Update+0x36>
 8023250:	20014538 	.word	0x20014538
 8023254:	20000d84 	.word	0x20000d84
 8023258:	08043ca8 	.word	0x08043ca8
 802325c:	200133dc 	.word	0x200133dc
 8023260:	200134dc 	.word	0x200134dc
 8023264:	08043cc8 	.word	0x08043cc8

08023268 <Config_NotifyBLE>:
  SendMsgToHost(&msg);
  return 0;  //!!!
}

tBleStatus Config_NotifyBLE(uint32_t Feature,uint8_t Command,uint8_t data)
{
 8023268:	b5f0      	push	{r4, r5, r6, r7, lr}
 802326a:	b085      	sub	sp, #20
 802326c:	4604      	mov	r4, r0
 802326e:	460e      	mov	r6, r1
 8023270:	4615      	mov	r5, r2
  tBleStatus ret;
  uint8_t buff[2+4+1+1];

  STORE_LE_16(buff  ,(HAL_GetTick()>>3));
 8023272:	f7ec fae1 	bl	800f838 <HAL_GetTick>
 8023276:	08c0      	lsrs	r0, r0, #3
 8023278:	f88d 0008 	strb.w	r0, [sp, #8]
 802327c:	f7ec fadc 	bl	800f838 <HAL_GetTick>
  STORE_BE_32(buff+2,Feature);
 8023280:	0a23      	lsrs	r3, r4, #8
 8023282:	f88d 300c 	strb.w	r3, [sp, #12]
 8023286:	0c23      	lsrs	r3, r4, #16
  buff[6] = Command;
  buff[7] = data;

  ret = aci_gatt_update_char_value (ConfigServW2STHandle, ConfigCharHandle, 0, 8,buff);
 8023288:	4f23      	ldr	r7, [pc, #140]	; (8023318 <Config_NotifyBLE+0xb0>)
  STORE_BE_32(buff+2,Feature);
 802328a:	f88d 300b 	strb.w	r3, [sp, #11]
  ret = aci_gatt_update_char_value (ConfigServW2STHandle, ConfigCharHandle, 0, 8,buff);
 802328e:	ab02      	add	r3, sp, #8
 8023290:	9300      	str	r3, [sp, #0]
  STORE_LE_16(buff  ,(HAL_GetTick()>>3));
 8023292:	0ac0      	lsrs	r0, r0, #11
 8023294:	f88d 0009 	strb.w	r0, [sp, #9]
  STORE_BE_32(buff+2,Feature);
 8023298:	f88d 400d 	strb.w	r4, [sp, #13]
  ret = aci_gatt_update_char_value (ConfigServW2STHandle, ConfigCharHandle, 0, 8,buff);
 802329c:	88f9      	ldrh	r1, [r7, #6]
 802329e:	88b8      	ldrh	r0, [r7, #4]
  buff[6] = Command;
 80232a0:	f88d 600e 	strb.w	r6, [sp, #14]
  STORE_BE_32(buff+2,Feature);
 80232a4:	0e24      	lsrs	r4, r4, #24
  ret = aci_gatt_update_char_value (ConfigServW2STHandle, ConfigCharHandle, 0, 8,buff);
 80232a6:	2308      	movs	r3, #8
 80232a8:	2200      	movs	r2, #0
  STORE_BE_32(buff+2,Feature);
 80232aa:	f88d 400a 	strb.w	r4, [sp, #10]
  buff[7] = data;
 80232ae:	f88d 500f 	strb.w	r5, [sp, #15]
  ret = aci_gatt_update_char_value (ConfigServW2STHandle, ConfigCharHandle, 0, 8,buff);
 80232b2:	f7f8 fadd 	bl	801b870 <aci_gatt_update_char_value>
  if (ret != BLE_STATUS_SUCCESS){
 80232b6:	b908      	cbnz	r0, 80232bc <Config_NotifyBLE+0x54>
      SENSING1_PRINTF("Error Updating Configuration Char\r\n");
    }
    return BLE_STATUS_ERROR;
  }
  return BLE_STATUS_SUCCESS;
}
 80232b8:	b005      	add	sp, #20
 80232ba:	bdf0      	pop	{r4, r5, r6, r7, pc}
    if(W2ST_CHECK_CONNECTION(W2ST_CONNECT_STD_ERR)){
 80232bc:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 80232be:	065b      	lsls	r3, r3, #25
 80232c0:	d404      	bmi.n	80232cc <Config_NotifyBLE+0x64>
      SENSING1_PRINTF("Error Updating Configuration Char\r\n");
 80232c2:	4b16      	ldr	r3, [pc, #88]	; (802331c <Config_NotifyBLE+0xb4>)
 80232c4:	781b      	ldrb	r3, [r3, #0]
 80232c6:	bb0b      	cbnz	r3, 802330c <Config_NotifyBLE+0xa4>
    return BLE_STATUS_ERROR;
 80232c8:	2047      	movs	r0, #71	; 0x47
 80232ca:	e7f5      	b.n	80232b8 <Config_NotifyBLE+0x50>
      BytesToWrite =sprintf((char *)BufferToWrite, "Error Updating Configuration Char\n");
 80232cc:	4e14      	ldr	r6, [pc, #80]	; (8023320 <Config_NotifyBLE+0xb8>)
 80232ce:	4d15      	ldr	r5, [pc, #84]	; (8023324 <Config_NotifyBLE+0xbc>)
 80232d0:	f106 0720 	add.w	r7, r6, #32
 80232d4:	4634      	mov	r4, r6
 80232d6:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 80232d8:	42bc      	cmp	r4, r7
 80232da:	f105 0510 	add.w	r5, r5, #16
 80232de:	f106 0610 	add.w	r6, r6, #16
 80232e2:	f845 0c10 	str.w	r0, [r5, #-16]
 80232e6:	f845 1c0c 	str.w	r1, [r5, #-12]
 80232ea:	f845 2c08 	str.w	r2, [r5, #-8]
 80232ee:	f845 3c04 	str.w	r3, [r5, #-4]
 80232f2:	d1ef      	bne.n	80232d4 <Config_NotifyBLE+0x6c>
 80232f4:	8832      	ldrh	r2, [r6, #0]
 80232f6:	802a      	strh	r2, [r5, #0]
 80232f8:	4b0b      	ldr	r3, [pc, #44]	; (8023328 <Config_NotifyBLE+0xc0>)
 80232fa:	78b2      	ldrb	r2, [r6, #2]
 80232fc:	70aa      	strb	r2, [r5, #2]
 80232fe:	2122      	movs	r1, #34	; 0x22
      Stderr_Update(BufferToWrite,BytesToWrite);
 8023300:	4808      	ldr	r0, [pc, #32]	; (8023324 <Config_NotifyBLE+0xbc>)
      BytesToWrite =sprintf((char *)BufferToWrite, "Error Updating Configuration Char\n");
 8023302:	6019      	str	r1, [r3, #0]
      Stderr_Update(BufferToWrite,BytesToWrite);
 8023304:	f7ff fea4 	bl	8023050 <Stderr_Update>
    return BLE_STATUS_ERROR;
 8023308:	2047      	movs	r0, #71	; 0x47
 802330a:	e7d5      	b.n	80232b8 <Config_NotifyBLE+0x50>
      SENSING1_PRINTF("Error Updating Configuration Char\r\n");
 802330c:	4807      	ldr	r0, [pc, #28]	; (802332c <Config_NotifyBLE+0xc4>)
 802330e:	f004 ff21 	bl	8028154 <puts>
    return BLE_STATUS_ERROR;
 8023312:	2047      	movs	r0, #71	; 0x47
 8023314:	e7d0      	b.n	80232b8 <Config_NotifyBLE+0x50>
 8023316:	bf00      	nop
 8023318:	20014538 	.word	0x20014538
 802331c:	20000d84 	.word	0x20000d84
 8023320:	08043ce8 	.word	0x08043ce8
 8023324:	200133dc 	.word	0x200133dc
 8023328:	200134dc 	.word	0x200134dc
 802332c:	08043d0c 	.word	0x08043d0c

08023330 <Add_HW_SW_ServW2ST_Service>:
 * @brief  Add the HW Features service using a vendor specific profile
 * @param  None
 * @retval tBleStatus Status
 */
tBleStatus Add_HW_SW_ServW2ST_Service(void)
{
 8023330:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8023334:	b08b      	sub	sp, #44	; 0x2c
/* SD Log Feature */
#if SENSING1_USE_DATALOG
  max_attr_records++;
#endif /* SENSING1_USE_DATALOG */

  COPY_HW_SENS_W2ST_SERVICE_UUID(uuid);
 8023336:	2300      	movs	r3, #0
 8023338:	f88d 301d 	strb.w	r3, [sp, #29]
 802333c:	f88d 3023 	strb.w	r3, [sp, #35]	; 0x23
 8023340:	f88d 3024 	strb.w	r3, [sp, #36]	; 0x24
 8023344:	f88d 3025 	strb.w	r3, [sp, #37]	; 0x25
 8023348:	f88d 3026 	strb.w	r3, [sp, #38]	; 0x26
 802334c:	f88d 3027 	strb.w	r3, [sp, #39]	; 0x27
 8023350:	23b4      	movs	r3, #180	; 0xb4
#ifndef SENSING1_BlueNRG2
  ret = aci_gatt_add_serv(UUID_TYPE_128,  uuid, PRIMARY_SERVICE,
 8023352:	4ae4      	ldr	r2, [pc, #912]	; (80236e4 <Add_HW_SW_ServW2ST_Service+0x3b4>)
  COPY_HW_SENS_W2ST_SERVICE_UUID(uuid);
 8023354:	f88d 301e 	strb.w	r3, [sp, #30]
 8023358:	2402      	movs	r4, #2
 802335a:	f04f 0b01 	mov.w	fp, #1
 802335e:	239a      	movs	r3, #154	; 0x9a
  ret = aci_gatt_add_serv(UUID_TYPE_128,  uuid, PRIMARY_SERVICE,
 8023360:	9200      	str	r2, [sp, #0]
  COPY_HW_SENS_W2ST_SERVICE_UUID(uuid);
 8023362:	f04f 0a1b 	mov.w	sl, #27
 8023366:	f04f 09c5 	mov.w	r9, #197	; 0xc5
 802336a:	f04f 08d5 	mov.w	r8, #213	; 0xd5
 802336e:	27a5      	movs	r7, #165	; 0xa5
 8023370:	f88d 301f 	strb.w	r3, [sp, #31]
 8023374:	26e1      	movs	r6, #225	; 0xe1
 8023376:	2511      	movs	r5, #17
  ret = aci_gatt_add_serv(UUID_TYPE_128,  uuid, PRIMARY_SERVICE,
 8023378:	2319      	movs	r3, #25
 802337a:	465a      	mov	r2, fp
 802337c:	a906      	add	r1, sp, #24
 802337e:	4620      	mov	r0, r4
  COPY_HW_SENS_W2ST_SERVICE_UUID(uuid);
 8023380:	f88d a018 	strb.w	sl, [sp, #24]
 8023384:	f88d 401c 	strb.w	r4, [sp, #28]
 8023388:	f88d b022 	strb.w	fp, [sp, #34]	; 0x22
 802338c:	f88d 9019 	strb.w	r9, [sp, #25]
 8023390:	f88d 801a 	strb.w	r8, [sp, #26]
 8023394:	f88d 701b 	strb.w	r7, [sp, #27]
 8023398:	f88d 6020 	strb.w	r6, [sp, #32]
 802339c:	f88d 5021 	strb.w	r5, [sp, #33]	; 0x21
  ret = aci_gatt_add_serv(UUID_TYPE_128,  uuid, PRIMARY_SERVICE,
 80233a0:	f7f8 f99c 	bl	801b6dc <aci_gatt_add_serv>
#else /* SENSING1_BlueNRG2 */
  BLUENRG_memcpy(&service_uuid.Service_UUID_128, uuid, 16);
  ret = aci_gatt_add_service(UUID_TYPE_128,  &service_uuid, PRIMARY_SERVICE, 1+3*max_attr_records,&HWServW2STHandle);
#endif /* SENSING1_BlueNRG2 */

  if (ret != BLE_STATUS_SUCCESS) {
 80233a4:	2800      	cmp	r0, #0
 80233a6:	f040 81a5 	bne.w	80236f4 <Add_HW_SW_ServW2ST_Service+0x3c4>
    goto fail;
  }

  /* Fill the Environmental BLE Characteristc */
  COPY_ENVIRONMENTAL_W2ST_CHAR_UUID(uuid);
  if(TargetBoardFeatures.NumTempSensors==2) {
 80233aa:	4acf      	ldr	r2, [pc, #828]	; (80236e8 <Add_HW_SW_ServW2ST_Service+0x3b8>)
  COPY_ENVIRONMENTAL_W2ST_CHAR_UUID(uuid);
 80233ac:	f88d 001d 	strb.w	r0, [sp, #29]
  if(TargetBoardFeatures.NumTempSensors==2) {
 80233b0:	6853      	ldr	r3, [r2, #4]
  COPY_ENVIRONMENTAL_W2ST_CHAR_UUID(uuid);
 80233b2:	f88d 0023 	strb.w	r0, [sp, #35]	; 0x23
 80233b6:	21ac      	movs	r1, #172	; 0xac
 80233b8:	f88d 0024 	strb.w	r0, [sp, #36]	; 0x24
 80233bc:	f88d 0025 	strb.w	r0, [sp, #37]	; 0x25
 80233c0:	f88d 0026 	strb.w	r0, [sp, #38]	; 0x26
 80233c4:	f88d 0027 	strb.w	r0, [sp, #39]	; 0x27
  if(TargetBoardFeatures.NumTempSensors==2) {
 80233c8:	2b02      	cmp	r3, #2
  COPY_ENVIRONMENTAL_W2ST_CHAR_UUID(uuid);
 80233ca:	f04f 0036 	mov.w	r0, #54	; 0x36
 80233ce:	f88d 101f 	strb.w	r1, [sp, #31]
 80233d2:	f88d a018 	strb.w	sl, [sp, #24]
    uuid[14] |= 0x05; /* Two Temperature values*/
    EnvironmentalCharSize+=2*2;
 80233d6:	49c5      	ldr	r1, [pc, #788]	; (80236ec <Add_HW_SW_ServW2ST_Service+0x3bc>)
  COPY_ENVIRONMENTAL_W2ST_CHAR_UUID(uuid);
 80233d8:	f88d 9019 	strb.w	r9, [sp, #25]
 80233dc:	f88d 801a 	strb.w	r8, [sp, #26]
 80233e0:	f88d 701b 	strb.w	r7, [sp, #27]
 80233e4:	f88d 401c 	strb.w	r4, [sp, #28]
 80233e8:	f88d 6020 	strb.w	r6, [sp, #32]
 80233ec:	f88d 5021 	strb.w	r5, [sp, #33]	; 0x21
 80233f0:	f88d b022 	strb.w	fp, [sp, #34]	; 0x22
 80233f4:	f88d 001e 	strb.w	r0, [sp, #30]
  if(TargetBoardFeatures.NumTempSensors==2) {
 80233f8:	f000 8180 	beq.w	80236fc <Add_HW_SW_ServW2ST_Service+0x3cc>
  } else if(TargetBoardFeatures.NumTempSensors==1) {
 80233fc:	2b01      	cmp	r3, #1
 80233fe:	f000 8185 	beq.w	802370c <Add_HW_SW_ServW2ST_Service+0x3dc>
    EnvironmentalCharSize+=2;
  }
  
  if (TargetBoardFeatures.HandleHumSensor != SENSING1_SNS_NOT_VALID) {
    uuid[14] |= 0x08; /* Humidity */
    EnvironmentalCharSize+=2;
 8023402:	780b      	ldrb	r3, [r1, #0]
  if (TargetBoardFeatures.HandleHumSensor != SENSING1_SNS_NOT_VALID) {
 8023404:	6954      	ldr	r4, [r2, #20]
 8023406:	f242 700f 	movw	r0, #9999	; 0x270f
 802340a:	4284      	cmp	r4, r0
 802340c:	d008      	beq.n	8023420 <Add_HW_SW_ServW2ST_Service+0xf0>
    uuid[14] |= 0x08; /* Humidity */
 802340e:	f89d 0026 	ldrb.w	r0, [sp, #38]	; 0x26
    EnvironmentalCharSize+=2;
 8023412:	3302      	adds	r3, #2
    uuid[14] |= 0x08; /* Humidity */
 8023414:	f040 0008 	orr.w	r0, r0, #8
    EnvironmentalCharSize+=2;
 8023418:	b2db      	uxtb	r3, r3
    uuid[14] |= 0x08; /* Humidity */
 802341a:	f88d 0026 	strb.w	r0, [sp, #38]	; 0x26
    EnvironmentalCharSize+=2;
 802341e:	700b      	strb	r3, [r1, #0]
  }

  if (TargetBoardFeatures.HandlePressSensor != SENSING1_SNS_NOT_VALID) {
 8023420:	6910      	ldr	r0, [r2, #16]
 8023422:	f242 720f 	movw	r2, #9999	; 0x270f
 8023426:	4290      	cmp	r0, r2
 8023428:	d008      	beq.n	802343c <Add_HW_SW_ServW2ST_Service+0x10c>
    uuid[14] |= 0x10; /* Pressure value*/
 802342a:	f89d 2026 	ldrb.w	r2, [sp, #38]	; 0x26
    EnvironmentalCharSize+=4;
 802342e:	3304      	adds	r3, #4
    uuid[14] |= 0x10; /* Pressure value*/
 8023430:	f042 0210 	orr.w	r2, r2, #16
    EnvironmentalCharSize+=4;
 8023434:	b2db      	uxtb	r3, r3
    uuid[14] |= 0x10; /* Pressure value*/
 8023436:	f88d 2026 	strb.w	r2, [sp, #38]	; 0x26
    EnvironmentalCharSize+=4;
 802343a:	700b      	strb	r3, [r1, #0]
  }

#ifndef SENSING1_BlueNRG2
  ret =  aci_gatt_add_char(HWServW2STHandle, UUID_TYPE_128, uuid, EnvironmentalCharSize,
 802343c:	4cac      	ldr	r4, [pc, #688]	; (80236f0 <Add_HW_SW_ServW2ST_Service+0x3c0>)
 802343e:	2200      	movs	r2, #0
 8023440:	f104 014a 	add.w	r1, r4, #74	; 0x4a
 8023444:	2510      	movs	r5, #16
 8023446:	2712      	movs	r7, #18
 8023448:	2604      	movs	r6, #4
 802344a:	9105      	str	r1, [sp, #20]
 802344c:	9204      	str	r2, [sp, #16]
 802344e:	9201      	str	r2, [sp, #4]
 8023450:	9503      	str	r5, [sp, #12]
 8023452:	9700      	str	r7, [sp, #0]
 8023454:	9602      	str	r6, [sp, #8]
 8023456:	f8b4 0040 	ldrh.w	r0, [r4, #64]	; 0x40
 802345a:	aa06      	add	r2, sp, #24
 802345c:	2102      	movs	r1, #2
 802345e:	f7f8 f987 	bl	801b770 <aci_gatt_add_char>
                           ATTR_PERMISSION_NONE,
                           GATT_NOTIFY_READ_REQ_AND_WAIT_FOR_APPL_RESP,
                           16, 0, &EnvironmentalCharHandle);
#endif /* SENSING1_BlueNRG2 */  

  if (ret != BLE_STATUS_SUCCESS) {
 8023462:	2800      	cmp	r0, #0
 8023464:	f040 8146 	bne.w	80236f4 <Add_HW_SW_ServW2ST_Service+0x3c4>
    goto fail;
  }

  COPY_ACC_GYRO_MAG_W2ST_CHAR_UUID(uuid);
#ifndef SENSING1_BlueNRG2
  ret =  aci_gatt_add_char(HWServW2STHandle, UUID_TYPE_128, uuid, 2+3*3*2,
 8023468:	f104 034c 	add.w	r3, r4, #76	; 0x4c
 802346c:	9305      	str	r3, [sp, #20]
 802346e:	e9cd 5003 	strd	r5, r0, [sp, #12]
  COPY_ACC_GYRO_MAG_W2ST_CHAR_UUID(uuid);
 8023472:	f06f 035a 	mvn.w	r3, #90	; 0x5a
  ret =  aci_gatt_add_char(HWServW2STHandle, UUID_TYPE_128, uuid, 2+3*3*2,
 8023476:	e9cd 0601 	strd	r0, r6, [sp, #4]
  COPY_ACC_GYRO_MAG_W2ST_CHAR_UUID(uuid);
 802347a:	f88d 301b 	strb.w	r3, [sp, #27]
 802347e:	f04f 0301 	mov.w	r3, #1
 8023482:	f04f 0802 	mov.w	r8, #2
 8023486:	f04f 0236 	mov.w	r2, #54	; 0x36
 802348a:	f06f 0153 	mvn.w	r1, #83	; 0x53
  ret =  aci_gatt_add_char(HWServW2STHandle, UUID_TYPE_128, uuid, 2+3*3*2,
 802348e:	9500      	str	r5, [sp, #0]
  COPY_ACC_GYRO_MAG_W2ST_CHAR_UUID(uuid);
 8023490:	f88d 3022 	strb.w	r3, [sp, #34]	; 0x22
 8023494:	23e0      	movs	r3, #224	; 0xe0
 8023496:	f88d 001d 	strb.w	r0, [sp, #29]
 802349a:	f88d 0023 	strb.w	r0, [sp, #35]	; 0x23
 802349e:	f88d 0024 	strb.w	r0, [sp, #36]	; 0x24
 80234a2:	f88d 0025 	strb.w	r0, [sp, #37]	; 0x25
 80234a6:	f88d 0027 	strb.w	r0, [sp, #39]	; 0x27
 80234aa:	f04f 0b1b 	mov.w	fp, #27
 80234ae:	f04f 0ac5 	mov.w	sl, #197	; 0xc5
 80234b2:	f04f 09d5 	mov.w	r9, #213	; 0xd5
 80234b6:	f88d 201e 	strb.w	r2, [sp, #30]
 80234ba:	f88d 101f 	strb.w	r1, [sp, #31]
 80234be:	f06f 0c1e 	mvn.w	ip, #30
 80234c2:	f04f 0e11 	mov.w	lr, #17
 80234c6:	f88d 3026 	strb.w	r3, [sp, #38]	; 0x26
  ret =  aci_gatt_add_char(HWServW2STHandle, UUID_TYPE_128, uuid, 2+3*3*2,
 80234ca:	f8b4 0040 	ldrh.w	r0, [r4, #64]	; 0x40
  COPY_ACC_GYRO_MAG_W2ST_CHAR_UUID(uuid);
 80234ce:	f88d 801c 	strb.w	r8, [sp, #28]
  ret =  aci_gatt_add_char(HWServW2STHandle, UUID_TYPE_128, uuid, 2+3*3*2,
 80234d2:	2314      	movs	r3, #20
 80234d4:	aa06      	add	r2, sp, #24
 80234d6:	4641      	mov	r1, r8
  COPY_ACC_GYRO_MAG_W2ST_CHAR_UUID(uuid);
 80234d8:	f88d b018 	strb.w	fp, [sp, #24]
 80234dc:	f88d a019 	strb.w	sl, [sp, #25]
 80234e0:	f88d 901a 	strb.w	r9, [sp, #26]
 80234e4:	f88d c020 	strb.w	ip, [sp, #32]
 80234e8:	f88d e021 	strb.w	lr, [sp, #33]	; 0x21
  ret =  aci_gatt_add_char(HWServW2STHandle, UUID_TYPE_128, uuid, 2+3*3*2,
 80234ec:	f7f8 f940 	bl	801b770 <aci_gatt_add_char>
                           ATTR_PERMISSION_NONE,
                           GATT_NOTIFY_READ_REQ_AND_WAIT_FOR_APPL_RESP,
                           16, 0, &AccGyroMagCharHandle);
#endif /* SENSING1_BlueNRG2 */

  if (ret != BLE_STATUS_SUCCESS) {
 80234f0:	2800      	cmp	r0, #0
 80234f2:	f040 80ff 	bne.w	80236f4 <Add_HW_SW_ServW2ST_Service+0x3c4>
  if (ret != BLE_STATUS_SUCCESS) {
    goto fail;
  }
#endif /* USE_STM32L475E_IOT01 */

  COPY_MIC_W2ST_CHAR_UUID(uuid);
 80234f6:	f06f 035a 	mvn.w	r3, #90	; 0x5a
#ifndef SENSING1_BlueNRG2
  ret =  aci_gatt_add_char(HWServW2STHandle, UUID_TYPE_128, uuid,2+AUDIO_CHANNELS,
 80234fa:	e9cd 5003 	strd	r5, r0, [sp, #12]
 80234fe:	e9cd 0601 	strd	r0, r6, [sp, #4]
  COPY_MIC_W2ST_CHAR_UUID(uuid);
 8023502:	f88d 301b 	strb.w	r3, [sp, #27]
 8023506:	f04f 0301 	mov.w	r3, #1
 802350a:	f88d 3022 	strb.w	r3, [sp, #34]	; 0x22
  ret =  aci_gatt_add_char(HWServW2STHandle, UUID_TYPE_128, uuid,2+AUDIO_CHANNELS,
 802350e:	f104 034e 	add.w	r3, r4, #78	; 0x4e
  COPY_MIC_W2ST_CHAR_UUID(uuid);
 8023512:	f04f 0236 	mov.w	r2, #54	; 0x36
 8023516:	f06f 0153 	mvn.w	r1, #83	; 0x53
  ret =  aci_gatt_add_char(HWServW2STHandle, UUID_TYPE_128, uuid,2+AUDIO_CHANNELS,
 802351a:	9305      	str	r3, [sp, #20]
 802351c:	9500      	str	r5, [sp, #0]
  COPY_MIC_W2ST_CHAR_UUID(uuid);
 802351e:	f88d 001d 	strb.w	r0, [sp, #29]
 8023522:	f88d 201e 	strb.w	r2, [sp, #30]
 8023526:	f88d 101f 	strb.w	r1, [sp, #31]
 802352a:	f06f 0c1e 	mvn.w	ip, #30
 802352e:	f04f 0e11 	mov.w	lr, #17
 8023532:	f88d 0023 	strb.w	r0, [sp, #35]	; 0x23
 8023536:	f88d 0024 	strb.w	r0, [sp, #36]	; 0x24
 802353a:	f88d 0025 	strb.w	r0, [sp, #37]	; 0x25
 802353e:	f88d 0026 	strb.w	r0, [sp, #38]	; 0x26
  ret =  aci_gatt_add_char(HWServW2STHandle, UUID_TYPE_128, uuid,2+AUDIO_CHANNELS,
 8023542:	2303      	movs	r3, #3
 8023544:	f8b4 0040 	ldrh.w	r0, [r4, #64]	; 0x40
  COPY_MIC_W2ST_CHAR_UUID(uuid);
 8023548:	f88d b018 	strb.w	fp, [sp, #24]
  ret =  aci_gatt_add_char(HWServW2STHandle, UUID_TYPE_128, uuid,2+AUDIO_CHANNELS,
 802354c:	aa06      	add	r2, sp, #24
 802354e:	4641      	mov	r1, r8
  COPY_MIC_W2ST_CHAR_UUID(uuid);
 8023550:	f88d a019 	strb.w	sl, [sp, #25]
 8023554:	f88d 901a 	strb.w	r9, [sp, #26]
 8023558:	f88d 801c 	strb.w	r8, [sp, #28]
 802355c:	f88d c020 	strb.w	ip, [sp, #32]
 8023560:	f88d e021 	strb.w	lr, [sp, #33]	; 0x21
 8023564:	f88d 6027 	strb.w	r6, [sp, #39]	; 0x27
  ret =  aci_gatt_add_char(HWServW2STHandle, UUID_TYPE_128, uuid,2+AUDIO_CHANNELS,
 8023568:	f7f8 f902 	bl	801b770 <aci_gatt_add_char>
                           CHAR_PROP_NOTIFY,
                           ATTR_PERMISSION_NONE,
                           GATT_NOTIFY_READ_REQ_AND_WAIT_FOR_APPL_RESP,
                           16, 0, &AudioLevelCharHandle);
#endif /* SENSING1_BlueNRG2 */
  if (ret != BLE_STATUS_SUCCESS) {
 802356c:	2800      	cmp	r0, #0
 802356e:	f040 80c1 	bne.w	80236f4 <Add_HW_SW_ServW2ST_Service+0x3c4>
    goto fail;
  }
  

  COPY_ACTIVITY_REC_W2ST_CHAR_UUID(uuid);
 8023572:	f06f 035a 	mvn.w	r3, #90	; 0x5a
#ifndef SENSING1_BlueNRG2
  ret =  aci_gatt_add_char(HWServW2STHandle, UUID_TYPE_128, uuid, 2+1+1, /* 2 byte timestamp, 1 byte action, 1 byte algorithm */
 8023576:	e9cd 5003 	strd	r5, r0, [sp, #12]
 802357a:	e9cd 0601 	strd	r0, r6, [sp, #4]
  COPY_ACTIVITY_REC_W2ST_CHAR_UUID(uuid);
 802357e:	f88d 301b 	strb.w	r3, [sp, #27]
 8023582:	f04f 0301 	mov.w	r3, #1
 8023586:	f88d 3022 	strb.w	r3, [sp, #34]	; 0x22
  ret =  aci_gatt_add_char(HWServW2STHandle, UUID_TYPE_128, uuid, 2+1+1, /* 2 byte timestamp, 1 byte action, 1 byte algorithm */
 802358a:	f104 033e 	add.w	r3, r4, #62	; 0x3e
  COPY_ACTIVITY_REC_W2ST_CHAR_UUID(uuid);
 802358e:	f04f 0236 	mov.w	r2, #54	; 0x36
 8023592:	f06f 0153 	mvn.w	r1, #83	; 0x53
  ret =  aci_gatt_add_char(HWServW2STHandle, UUID_TYPE_128, uuid, 2+1+1, /* 2 byte timestamp, 1 byte action, 1 byte algorithm */
 8023596:	9305      	str	r3, [sp, #20]
 8023598:	9700      	str	r7, [sp, #0]
  COPY_ACTIVITY_REC_W2ST_CHAR_UUID(uuid);
 802359a:	f88d 001d 	strb.w	r0, [sp, #29]
 802359e:	f88d 201e 	strb.w	r2, [sp, #30]
 80235a2:	f88d 101f 	strb.w	r1, [sp, #31]
 80235a6:	f06f 0c1e 	mvn.w	ip, #30
 80235aa:	f04f 0e11 	mov.w	lr, #17
 80235ae:	f88d 0023 	strb.w	r0, [sp, #35]	; 0x23
 80235b2:	f88d 0025 	strb.w	r0, [sp, #37]	; 0x25
 80235b6:	f88d 0026 	strb.w	r0, [sp, #38]	; 0x26
 80235ba:	f88d 0027 	strb.w	r0, [sp, #39]	; 0x27
  ret =  aci_gatt_add_char(HWServW2STHandle, UUID_TYPE_128, uuid, 2+1+1, /* 2 byte timestamp, 1 byte action, 1 byte algorithm */
 80235be:	4633      	mov	r3, r6
 80235c0:	f8b4 0040 	ldrh.w	r0, [r4, #64]	; 0x40
  COPY_ACTIVITY_REC_W2ST_CHAR_UUID(uuid);
 80235c4:	f88d b018 	strb.w	fp, [sp, #24]
  ret =  aci_gatt_add_char(HWServW2STHandle, UUID_TYPE_128, uuid, 2+1+1, /* 2 byte timestamp, 1 byte action, 1 byte algorithm */
 80235c8:	aa06      	add	r2, sp, #24
 80235ca:	4641      	mov	r1, r8
  COPY_ACTIVITY_REC_W2ST_CHAR_UUID(uuid);
 80235cc:	f88d a019 	strb.w	sl, [sp, #25]
 80235d0:	f88d 901a 	strb.w	r9, [sp, #26]
 80235d4:	f88d 801c 	strb.w	r8, [sp, #28]
 80235d8:	f88d c020 	strb.w	ip, [sp, #32]
 80235dc:	f88d e021 	strb.w	lr, [sp, #33]	; 0x21
 80235e0:	f88d 5024 	strb.w	r5, [sp, #36]	; 0x24
  ret =  aci_gatt_add_char(HWServW2STHandle, UUID_TYPE_128, uuid, 2+1+1, /* 2 byte timestamp, 1 byte action, 1 byte algorithm */
 80235e4:	f7f8 f8c4 	bl	801b770 <aci_gatt_add_char>
                           ATTR_PERMISSION_NONE,
                           GATT_NOTIFY_READ_REQ_AND_WAIT_FOR_APPL_RESP,
                           16, 0, &ActivityRecCharHandle);
#endif /* SENSING1_BlueNRG2 */

  if (ret != BLE_STATUS_SUCCESS) {
 80235e8:	2800      	cmp	r0, #0
 80235ea:	f040 8083 	bne.w	80236f4 <Add_HW_SW_ServW2ST_Service+0x3c4>
    goto fail;
  }

   COPY_AUDIO_REC_W2ST_CHAR_UUID(uuid);
 #ifndef SENSING1_BlueNRG2
   ret =  aci_gatt_add_char(HWServW2STHandle, UUID_TYPE_128, uuid, 2+1, /* 2 byte timestamp, 1 byte aucoustic scene classification */
 80235ee:	e9cd 5003 	strd	r5, r0, [sp, #12]
 80235f2:	e9cd 0601 	strd	r0, r6, [sp, #4]
   COPY_AUDIO_REC_W2ST_CHAR_UUID(uuid);
 80235f6:	f04f 0236 	mov.w	r2, #54	; 0x36
 80235fa:	f88d 201e 	strb.w	r2, [sp, #30]
   ret =  aci_gatt_add_char(HWServW2STHandle, UUID_TYPE_128, uuid, 2+1, /* 2 byte timestamp, 1 byte aucoustic scene classification */
 80235fe:	f104 0248 	add.w	r2, r4, #72	; 0x48
 8023602:	9700      	str	r7, [sp, #0]
 8023604:	9205      	str	r2, [sp, #20]
   COPY_AUDIO_REC_W2ST_CHAR_UUID(uuid);
 8023606:	f06f 035a 	mvn.w	r3, #90	; 0x5a
 802360a:	f06f 0153 	mvn.w	r1, #83	; 0x53
   ret =  aci_gatt_add_char(HWServW2STHandle, UUID_TYPE_128, uuid, 2+1, /* 2 byte timestamp, 1 byte aucoustic scene classification */
 802360e:	af06      	add	r7, sp, #24
   COPY_AUDIO_REC_W2ST_CHAR_UUID(uuid);
 8023610:	f88d 301b 	strb.w	r3, [sp, #27]
 8023614:	f88d 001d 	strb.w	r0, [sp, #29]
 8023618:	f88d 101f 	strb.w	r1, [sp, #31]
 802361c:	f06f 0c1e 	mvn.w	ip, #30
 8023620:	f04f 0e11 	mov.w	lr, #17
 8023624:	f88d 0023 	strb.w	r0, [sp, #35]	; 0x23
 8023628:	f88d 0025 	strb.w	r0, [sp, #37]	; 0x25
 802362c:	f88d 0026 	strb.w	r0, [sp, #38]	; 0x26
 8023630:	f88d 0027 	strb.w	r0, [sp, #39]	; 0x27
 8023634:	2303      	movs	r3, #3
   ret =  aci_gatt_add_char(HWServW2STHandle, UUID_TYPE_128, uuid, 2+1, /* 2 byte timestamp, 1 byte aucoustic scene classification */
 8023636:	463a      	mov	r2, r7
 8023638:	f8b4 0040 	ldrh.w	r0, [r4, #64]	; 0x40
   COPY_AUDIO_REC_W2ST_CHAR_UUID(uuid);
 802363c:	f88d b018 	strb.w	fp, [sp, #24]
   ret =  aci_gatt_add_char(HWServW2STHandle, UUID_TYPE_128, uuid, 2+1, /* 2 byte timestamp, 1 byte aucoustic scene classification */
 8023640:	4641      	mov	r1, r8
   COPY_AUDIO_REC_W2ST_CHAR_UUID(uuid);
 8023642:	f88d a019 	strb.w	sl, [sp, #25]
 8023646:	f88d 901a 	strb.w	r9, [sp, #26]
 802364a:	f88d 801c 	strb.w	r8, [sp, #28]
 802364e:	f88d c020 	strb.w	ip, [sp, #32]
 8023652:	f88d e021 	strb.w	lr, [sp, #33]	; 0x21
 8023656:	f88d 8022 	strb.w	r8, [sp, #34]	; 0x22
 802365a:	f88d 3024 	strb.w	r3, [sp, #36]	; 0x24
   ret =  aci_gatt_add_char(HWServW2STHandle, UUID_TYPE_128, uuid, 2+1, /* 2 byte timestamp, 1 byte aucoustic scene classification */
 802365e:	f7f8 f887 	bl	801b770 <aci_gatt_add_char>
                            CHAR_PROP_NOTIFY | CHAR_PROP_READ,
                            ATTR_PERMISSION_NONE,
                            GATT_NOTIFY_READ_REQ_AND_WAIT_FOR_APPL_RESP,
                            16, 0, &AudioSRecCharHandle);
 #endif /* SENSING1_BlueNRG2 */
   if (ret != BLE_STATUS_SUCCESS) {
 8023662:	4607      	mov	r7, r0
 8023664:	2800      	cmp	r0, #0
 8023666:	d145      	bne.n	80236f4 <Add_HW_SW_ServW2ST_Service+0x3c4>
#endif /* ((defined STM32_SENSORTILE) | (defined STM32_SENSORTILEBOX)) */

#if SENSING1_USE_DATALOG
    COPY_SDLOG_W2ST_CHAR_UUID(uuid);
#ifndef SENSING1_BlueNRG2
    ret =  aci_gatt_add_char(HWServW2STHandle, UUID_TYPE_128, uuid, W2ST_MAX_CHAR_LEN,
 8023668:	2001      	movs	r0, #1
 802366a:	e9cd 5003 	strd	r5, r0, [sp, #12]
    COPY_SDLOG_W2ST_CHAR_UUID(uuid);
 802366e:	f06f 035a 	mvn.w	r3, #90	; 0x5a
 8023672:	f88d 301b 	strb.w	r3, [sp, #27]
    ret =  aci_gatt_add_char(HWServW2STHandle, UUID_TYPE_128, uuid, W2ST_MAX_CHAR_LEN,
 8023676:	9701      	str	r7, [sp, #4]
 8023678:	f104 0350 	add.w	r3, r4, #80	; 0x50
 802367c:	f8b4 0040 	ldrh.w	r0, [r4, #64]	; 0x40
 8023680:	9305      	str	r3, [sp, #20]
 8023682:	2305      	movs	r3, #5
    COPY_SDLOG_W2ST_CHAR_UUID(uuid);
 8023684:	f04f 0236 	mov.w	r2, #54	; 0x36
 8023688:	f06f 0153 	mvn.w	r1, #83	; 0x53
    ret =  aci_gatt_add_char(HWServW2STHandle, UUID_TYPE_128, uuid, W2ST_MAX_CHAR_LEN,
 802368c:	9302      	str	r3, [sp, #8]
 802368e:	2314      	movs	r3, #20
    COPY_SDLOG_W2ST_CHAR_UUID(uuid);
 8023690:	f88d 201e 	strb.w	r2, [sp, #30]
 8023694:	f88d 101f 	strb.w	r1, [sp, #31]
 8023698:	f06f 0c1e 	mvn.w	ip, #30
 802369c:	f04f 0e11 	mov.w	lr, #17
    ret =  aci_gatt_add_char(HWServW2STHandle, UUID_TYPE_128, uuid, W2ST_MAX_CHAR_LEN,
 80236a0:	aa06      	add	r2, sp, #24
 80236a2:	4641      	mov	r1, r8
 80236a4:	9300      	str	r3, [sp, #0]
    COPY_SDLOG_W2ST_CHAR_UUID(uuid);
 80236a6:	f88d b018 	strb.w	fp, [sp, #24]
 80236aa:	f88d a019 	strb.w	sl, [sp, #25]
 80236ae:	f88d 901a 	strb.w	r9, [sp, #26]
 80236b2:	f88d c020 	strb.w	ip, [sp, #32]
 80236b6:	f88d e021 	strb.w	lr, [sp, #33]	; 0x21
 80236ba:	f88d 801c 	strb.w	r8, [sp, #28]
 80236be:	f88d 701d 	strb.w	r7, [sp, #29]
 80236c2:	f88d 8022 	strb.w	r8, [sp, #34]	; 0x22
 80236c6:	f88d 7023 	strb.w	r7, [sp, #35]	; 0x23
 80236ca:	f88d 6024 	strb.w	r6, [sp, #36]	; 0x24
 80236ce:	f88d 7025 	strb.w	r7, [sp, #37]	; 0x25
 80236d2:	f88d 7026 	strb.w	r7, [sp, #38]	; 0x26
 80236d6:	f88d 7027 	strb.w	r7, [sp, #39]	; 0x27
    ret =  aci_gatt_add_char(HWServW2STHandle, UUID_TYPE_128, uuid, W2ST_MAX_CHAR_LEN,
 80236da:	f7f8 f849 	bl	801b770 <aci_gatt_add_char>
                           CHAR_PROP_NOTIFY| CHAR_PROP_WRITE_WITHOUT_RESP,
                           ATTR_PERMISSION_NONE,
                           GATT_NOTIFY_ATTRIBUTE_WRITE | GATT_NOTIFY_READ_REQ_AND_WAIT_FOR_APPL_RESP,
                           16, 1, &SDLogFeaturesCharHandle);
#endif /* SENSING1_BlueNRG2 */
    if (ret != BLE_STATUS_SUCCESS) {
 80236de:	b150      	cbz	r0, 80236f6 <Add_HW_SW_ServW2ST_Service+0x3c6>
 80236e0:	e008      	b.n	80236f4 <Add_HW_SW_ServW2ST_Service+0x3c4>
 80236e2:	bf00      	nop
 80236e4:	20014578 	.word	0x20014578
 80236e8:	200106a4 	.word	0x200106a4
 80236ec:	20000db8 	.word	0x20000db8
 80236f0:	20014538 	.word	0x20014538
#endif /* SENSING1_USE_DATALOG */

  return BLE_STATUS_SUCCESS;

fail:
  return BLE_STATUS_ERROR;
 80236f4:	2047      	movs	r0, #71	; 0x47
}
 80236f6:	b00b      	add	sp, #44	; 0x2c
 80236f8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    EnvironmentalCharSize+=2*2;
 80236fc:	780b      	ldrb	r3, [r1, #0]
 80236fe:	3304      	adds	r3, #4
    uuid[14] |= 0x05; /* Two Temperature values*/
 8023700:	2005      	movs	r0, #5
    EnvironmentalCharSize+=2*2;
 8023702:	b2db      	uxtb	r3, r3
    uuid[14] |= 0x05; /* Two Temperature values*/
 8023704:	f88d 0026 	strb.w	r0, [sp, #38]	; 0x26
    EnvironmentalCharSize+=2*2;
 8023708:	700b      	strb	r3, [r1, #0]
 802370a:	e67b      	b.n	8023404 <Add_HW_SW_ServW2ST_Service+0xd4>
    EnvironmentalCharSize+=2;
 802370c:	780b      	ldrb	r3, [r1, #0]
 802370e:	3302      	adds	r3, #2
    uuid[14] |= 0x04; /* One Temperature value*/
 8023710:	2004      	movs	r0, #4
    EnvironmentalCharSize+=2;
 8023712:	b2db      	uxtb	r3, r3
    uuid[14] |= 0x04; /* One Temperature value*/
 8023714:	f88d 0026 	strb.w	r0, [sp, #38]	; 0x26
    EnvironmentalCharSize+=2;
 8023718:	700b      	strb	r3, [r1, #0]
 802371a:	e673      	b.n	8023404 <Add_HW_SW_ServW2ST_Service+0xd4>

0802371c <AccGyroMag_Update>:
 * @param  MOTION_SENSOR_Axes_t Gyro Structure containing Gyroscope value
 * @param  MOTION_SENSOR_Axes_t Mag Structure containing magneto value
 * @retval tBleStatus      Status
 */
tBleStatus AccGyroMag_Update(MOTION_SENSOR_Axes_t *Acc,MOTION_SENSOR_Axes_t *Gyro,MOTION_SENSOR_Axes_t *Mag)
{
 802371c:	b570      	push	{r4, r5, r6, lr}
 802371e:	b088      	sub	sp, #32
 8023720:	460d      	mov	r5, r1
 8023722:	4616      	mov	r6, r2
 8023724:	4604      	mov	r4, r0
  tBleStatus ret;

  uint8_t buff[2+3*3*2];

  STORE_LE_16(buff   ,(HAL_GetTick()>>3));
 8023726:	f7ec f887 	bl	800f838 <HAL_GetTick>
 802372a:	08c0      	lsrs	r0, r0, #3
 802372c:	f88d 000c 	strb.w	r0, [sp, #12]
 8023730:	f7ec f882 	bl	800f838 <HAL_GetTick>

  STORE_LE_16(buff+2 ,Acc->x);
 8023734:	6823      	ldr	r3, [r4, #0]
 8023736:	f88d 300e 	strb.w	r3, [sp, #14]
 802373a:	121b      	asrs	r3, r3, #8
 802373c:	f88d 300f 	strb.w	r3, [sp, #15]
  STORE_LE_16(buff+4 ,Acc->y);
  STORE_LE_16(buff+6 ,Acc->z);
 8023740:	e9d4 3101 	ldrd	r3, r1, [r4, #4]
  STORE_LE_16(buff+4 ,Acc->y);
 8023744:	121a      	asrs	r2, r3, #8
  STORE_LE_16(buff   ,(HAL_GetTick()>>3));
 8023746:	0ac0      	lsrs	r0, r0, #11
  STORE_LE_16(buff+4 ,Acc->y);
 8023748:	f88d 3010 	strb.w	r3, [sp, #16]
 802374c:	f88d 2011 	strb.w	r2, [sp, #17]

  Gyro->x/=100;
 8023750:	682b      	ldr	r3, [r5, #0]
 8023752:	4a3f      	ldr	r2, [pc, #252]	; (8023850 <AccGyroMag_Update+0x134>)
  STORE_LE_16(buff   ,(HAL_GetTick()>>3));
 8023754:	f88d 000d 	strb.w	r0, [sp, #13]
  STORE_LE_16(buff+6 ,Acc->z);
 8023758:	1208      	asrs	r0, r1, #8
 802375a:	f88d 0013 	strb.w	r0, [sp, #19]
 802375e:	f88d 1012 	strb.w	r1, [sp, #18]
  Gyro->y/=100;
  Gyro->z/=100;
 8023762:	e9d5 4001 	ldrd	r4, r0, [r5, #4]
  Gyro->x/=100;
 8023766:	fb82 c103 	smull	ip, r1, r2, r3
 802376a:	17db      	asrs	r3, r3, #31
 802376c:	ebc3 1361 	rsb	r3, r3, r1, asr #5
 8023770:	602b      	str	r3, [r5, #0]

  STORE_LE_16(buff+8 ,Gyro->x);
 8023772:	f88d 3014 	strb.w	r3, [sp, #20]
 8023776:	121b      	asrs	r3, r3, #8
 8023778:	f88d 3015 	strb.w	r3, [sp, #21]
  Gyro->y/=100;
 802377c:	fb82 1304 	smull	r1, r3, r2, r4
 8023780:	17e4      	asrs	r4, r4, #31
 8023782:	ebc4 1463 	rsb	r4, r4, r3, asr #5
  Gyro->z/=100;
 8023786:	fb82 3200 	smull	r3, r2, r2, r0
 802378a:	17c3      	asrs	r3, r0, #31
 802378c:	ebc3 1362 	rsb	r3, r3, r2, asr #5
 8023790:	e9c5 4301 	strd	r4, r3, [r5, #4]
  STORE_LE_16(buff+10,Gyro->y);
  STORE_LE_16(buff+12,Gyro->z);

  STORE_LE_16(buff+14, Mag->x);
 8023794:	6830      	ldr	r0, [r6, #0]
  STORE_LE_16(buff+10,Gyro->y);
 8023796:	f88d 4016 	strb.w	r4, [sp, #22]
 802379a:	1222      	asrs	r2, r4, #8
  if (breath > 0) {
 802379c:	4c2d      	ldr	r4, [pc, #180]	; (8023854 <AccGyroMag_Update+0x138>)
  STORE_LE_16(buff+10,Gyro->y);
 802379e:	f88d 2017 	strb.w	r2, [sp, #23]
  STORE_LE_16(buff+12,Gyro->z);
 80237a2:	121d      	asrs	r5, r3, #8
  STORE_LE_16(buff+16, Mag->y);
  STORE_LE_16(buff+18, Mag->z);
 80237a4:	e9d6 1201 	ldrd	r1, r2, [r6, #4]
  STORE_LE_16(buff+12,Gyro->z);
 80237a8:	f88d 3018 	strb.w	r3, [sp, #24]
  STORE_LE_16(buff+14, Mag->x);
 80237ac:	1203      	asrs	r3, r0, #8
 80237ae:	f88d 301b 	strb.w	r3, [sp, #27]
  if (breath > 0) {
 80237b2:	6823      	ldr	r3, [r4, #0]
  STORE_LE_16(buff+14, Mag->x);
 80237b4:	f88d 001a 	strb.w	r0, [sp, #26]
  STORE_LE_16(buff+16, Mag->y);
 80237b8:	f88d 101c 	strb.w	r1, [sp, #28]
 80237bc:	1208      	asrs	r0, r1, #8
  if (breath > 0) {
 80237be:	2b00      	cmp	r3, #0
  STORE_LE_16(buff+18, Mag->z);
 80237c0:	ea4f 2122 	mov.w	r1, r2, asr #8
  STORE_LE_16(buff+12,Gyro->z);
 80237c4:	f88d 5019 	strb.w	r5, [sp, #25]
  STORE_LE_16(buff+16, Mag->y);
 80237c8:	f88d 001d 	strb.w	r0, [sp, #29]
  STORE_LE_16(buff+18, Mag->z);
 80237cc:	f88d 201e 	strb.w	r2, [sp, #30]
 80237d0:	f88d 101f 	strb.w	r1, [sp, #31]
  if (breath > 0) {
 80237d4:	dd0a      	ble.n	80237ec <AccGyroMag_Update+0xd0>
    breath--;
 80237d6:	3b01      	subs	r3, #1
 80237d8:	6023      	str	r3, [r4, #0]

  ret = ACI_GATT_UPDATE_CHAR_VALUE(HWServW2STHandle, AccGyroMagCharHandle, 0, 2+3*3*2, buff);

  if (ret != BLE_STATUS_SUCCESS){
    if(W2ST_CHECK_CONNECTION(W2ST_CONNECT_STD_ERR)){
 80237da:	6c63      	ldr	r3, [r4, #68]	; 0x44
 80237dc:	065b      	lsls	r3, r3, #25
 80237de:	d414      	bmi.n	802380a <AccGyroMag_Update+0xee>
      BytesToWrite =sprintf((char *)BufferToWrite, "Error Updating Acc/Gyro/Mag Char\n");
      Stderr_Update(BufferToWrite,BytesToWrite);
    } else {
      SENSING1_PRINTF("Error Updating Acc/Gyro/Mag Char\r\n");
 80237e0:	4b1d      	ldr	r3, [pc, #116]	; (8023858 <AccGyroMag_Update+0x13c>)
 80237e2:	781b      	ldrb	r3, [r3, #0]
 80237e4:	bb7b      	cbnz	r3, 8023846 <AccGyroMag_Update+0x12a>
    }
    return BLE_STATUS_ERROR;
 80237e6:	2047      	movs	r0, #71	; 0x47
  }
  return BLE_STATUS_SUCCESS;
}
 80237e8:	b008      	add	sp, #32
 80237ea:	bd70      	pop	{r4, r5, r6, pc}
    ret = aci_gatt_update_char_value(servHandle,charHandle,charValOffset,charValueLen,charValue);
 80237ec:	ab03      	add	r3, sp, #12
 80237ee:	f8b4 104c 	ldrh.w	r1, [r4, #76]	; 0x4c
 80237f2:	f8b4 0040 	ldrh.w	r0, [r4, #64]	; 0x40
 80237f6:	9300      	str	r3, [sp, #0]
 80237f8:	2200      	movs	r2, #0
 80237fa:	2314      	movs	r3, #20
 80237fc:	f7f8 f838 	bl	801b870 <aci_gatt_update_char_value>
    if (ret != BLE_STATUS_SUCCESS){
 8023800:	2800      	cmp	r0, #0
 8023802:	d0f1      	beq.n	80237e8 <AccGyroMag_Update+0xcc>
      breath = ACC_BLUENRG_CONGESTION_SKIP;
 8023804:	231e      	movs	r3, #30
 8023806:	6023      	str	r3, [r4, #0]
  if (ret != BLE_STATUS_SUCCESS){
 8023808:	e7e7      	b.n	80237da <AccGyroMag_Update+0xbe>
      BytesToWrite =sprintf((char *)BufferToWrite, "Error Updating Acc/Gyro/Mag Char\n");
 802380a:	4e14      	ldr	r6, [pc, #80]	; (802385c <AccGyroMag_Update+0x140>)
 802380c:	4d14      	ldr	r5, [pc, #80]	; (8023860 <AccGyroMag_Update+0x144>)
 802380e:	f106 0c20 	add.w	ip, r6, #32
 8023812:	4634      	mov	r4, r6
 8023814:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 8023816:	4564      	cmp	r4, ip
 8023818:	f105 0510 	add.w	r5, r5, #16
 802381c:	f106 0610 	add.w	r6, r6, #16
 8023820:	f845 0c10 	str.w	r0, [r5, #-16]
 8023824:	f845 1c0c 	str.w	r1, [r5, #-12]
 8023828:	f845 2c08 	str.w	r2, [r5, #-8]
 802382c:	f845 3c04 	str.w	r3, [r5, #-4]
 8023830:	d1ef      	bne.n	8023812 <AccGyroMag_Update+0xf6>
 8023832:	4b0c      	ldr	r3, [pc, #48]	; (8023864 <AccGyroMag_Update+0x148>)
 8023834:	8832      	ldrh	r2, [r6, #0]
 8023836:	802a      	strh	r2, [r5, #0]
 8023838:	2121      	movs	r1, #33	; 0x21
      Stderr_Update(BufferToWrite,BytesToWrite);
 802383a:	4809      	ldr	r0, [pc, #36]	; (8023860 <AccGyroMag_Update+0x144>)
      BytesToWrite =sprintf((char *)BufferToWrite, "Error Updating Acc/Gyro/Mag Char\n");
 802383c:	6019      	str	r1, [r3, #0]
      Stderr_Update(BufferToWrite,BytesToWrite);
 802383e:	f7ff fc07 	bl	8023050 <Stderr_Update>
    return BLE_STATUS_ERROR;
 8023842:	2047      	movs	r0, #71	; 0x47
 8023844:	e7d0      	b.n	80237e8 <AccGyroMag_Update+0xcc>
      SENSING1_PRINTF("Error Updating Acc/Gyro/Mag Char\r\n");
 8023846:	4808      	ldr	r0, [pc, #32]	; (8023868 <AccGyroMag_Update+0x14c>)
 8023848:	f004 fc84 	bl	8028154 <puts>
    return BLE_STATUS_ERROR;
 802384c:	2047      	movs	r0, #71	; 0x47
 802384e:	e7cb      	b.n	80237e8 <AccGyroMag_Update+0xcc>
 8023850:	51eb851f 	.word	0x51eb851f
 8023854:	20014538 	.word	0x20014538
 8023858:	20000d84 	.word	0x20000d84
 802385c:	08043d30 	.word	0x08043d30
 8023860:	200133dc 	.word	0x200133dc
 8023864:	200134dc 	.word	0x200134dc
 8023868:	08043d54 	.word	0x08043d54

0802386c <Environmental_Update>:
 * @param  int16_t Temp1 Temperature in tenths of degree first  sensor
 * @param  int16_t Temp2 Temperature in tenths of degree second sensor
 * @retval tBleStatus   Status
 */
tBleStatus Environmental_Update(int32_t Press,uint16_t Hum,int16_t Temp1,int16_t Temp2)
{
 802386c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8023870:	b086      	sub	sp, #24
 8023872:	4615      	mov	r5, r2
 8023874:	4698      	mov	r8, r3
 8023876:	460e      	mov	r6, r1
 8023878:	4604      	mov	r4, r0
  tBleStatus ret;
  uint8_t BuffPos;

  uint8_t buff[2+4/*Press*/+2/*Hum*/+2/*Temp2*/+2/*Temp1*/];

  STORE_LE_16(buff  ,(HAL_GetTick()>>3));
 802387a:	f7eb ffdd 	bl	800f838 <HAL_GetTick>
  BuffPos=2;

  if (TargetBoardFeatures.HandlePressSensor != SENSING1_SNS_NOT_VALID) {
 802387e:	4f49      	ldr	r7, [pc, #292]	; (80239a4 <Environmental_Update+0x138>)
  STORE_LE_16(buff  ,(HAL_GetTick()>>3));
 8023880:	08c0      	lsrs	r0, r0, #3
 8023882:	f88d 000c 	strb.w	r0, [sp, #12]
 8023886:	f7eb ffd7 	bl	800f838 <HAL_GetTick>
  if (TargetBoardFeatures.HandlePressSensor != SENSING1_SNS_NOT_VALID) {
 802388a:	693a      	ldr	r2, [r7, #16]
 802388c:	f242 730f 	movw	r3, #9999	; 0x270f
  STORE_LE_16(buff  ,(HAL_GetTick()>>3));
 8023890:	0ac0      	lsrs	r0, r0, #11
  if (TargetBoardFeatures.HandlePressSensor != SENSING1_SNS_NOT_VALID) {
 8023892:	429a      	cmp	r2, r3
  STORE_LE_16(buff  ,(HAL_GetTick()>>3));
 8023894:	f88d 000d 	strb.w	r0, [sp, #13]
  if (TargetBoardFeatures.HandlePressSensor != SENSING1_SNS_NOT_VALID) {
 8023898:	d054      	beq.n	8023944 <Environmental_Update+0xd8>
    STORE_LE_32(buff+BuffPos,Press);
 802389a:	1223      	asrs	r3, r4, #8
 802389c:	f88d 400e 	strb.w	r4, [sp, #14]
 80238a0:	f88d 300f 	strb.w	r3, [sp, #15]
 80238a4:	1423      	asrs	r3, r4, #16
 80238a6:	1624      	asrs	r4, r4, #24
 80238a8:	f88d 3010 	strb.w	r3, [sp, #16]
 80238ac:	f88d 4011 	strb.w	r4, [sp, #17]
    BuffPos+=4;
 80238b0:	2006      	movs	r0, #6
  }

  if (TargetBoardFeatures.HandleHumSensor != SENSING1_SNS_NOT_VALID) {
 80238b2:	697a      	ldr	r2, [r7, #20]
 80238b4:	f242 730f 	movw	r3, #9999	; 0x270f
 80238b8:	429a      	cmp	r2, r3
 80238ba:	d00d      	beq.n	80238d8 <Environmental_Update+0x6c>
    STORE_LE_16(buff+BuffPos,Hum);
 80238bc:	1c43      	adds	r3, r0, #1
 80238be:	aa06      	add	r2, sp, #24
 80238c0:	fa52 f383 	uxtab	r3, r2, r3
 80238c4:	f100 0218 	add.w	r2, r0, #24
 80238c8:	446a      	add	r2, sp
    BuffPos+=2;
 80238ca:	3002      	adds	r0, #2
    STORE_LE_16(buff+BuffPos,Hum);
 80238cc:	f802 6c0c 	strb.w	r6, [r2, #-12]
 80238d0:	0a36      	lsrs	r6, r6, #8
 80238d2:	f803 6c0c 	strb.w	r6, [r3, #-12]
    BuffPos+=2;
 80238d6:	b2c0      	uxtb	r0, r0
  }

  if (TargetBoardFeatures.HandleTempSensors[0] != SENSING1_SNS_NOT_VALID) {
 80238d8:	68ba      	ldr	r2, [r7, #8]
 80238da:	f242 730f 	movw	r3, #9999	; 0x270f
 80238de:	429a      	cmp	r2, r3
 80238e0:	d00d      	beq.n	80238fe <Environmental_Update+0x92>
    STORE_LE_16(buff+BuffPos,Temp1);
 80238e2:	f100 0318 	add.w	r3, r0, #24
 80238e6:	446b      	add	r3, sp
 80238e8:	aa06      	add	r2, sp, #24
 80238ea:	f803 5c0c 	strb.w	r5, [r3, #-12]
 80238ee:	1c43      	adds	r3, r0, #1
 80238f0:	fa52 f383 	uxtab	r3, r2, r3
 80238f4:	122d      	asrs	r5, r5, #8
    BuffPos+=2;
 80238f6:	3002      	adds	r0, #2
    STORE_LE_16(buff+BuffPos,Temp1);
 80238f8:	f803 5c0c 	strb.w	r5, [r3, #-12]
    BuffPos+=2;
 80238fc:	b2c0      	uxtb	r0, r0
  }

  if (TargetBoardFeatures.HandleTempSensors[1] != SENSING1_SNS_NOT_VALID) {
 80238fe:	68fa      	ldr	r2, [r7, #12]
 8023900:	f242 730f 	movw	r3, #9999	; 0x270f
 8023904:	429a      	cmp	r2, r3
 8023906:	d00d      	beq.n	8023924 <Environmental_Update+0xb8>
    STORE_LE_16(buff+BuffPos,Temp2);
 8023908:	f100 0218 	add.w	r2, r0, #24
 802390c:	1c43      	adds	r3, r0, #1
 802390e:	eb0d 0002 	add.w	r0, sp, r2
 8023912:	aa06      	add	r2, sp, #24
 8023914:	fa52 f383 	uxtab	r3, r2, r3
 8023918:	ea4f 2228 	mov.w	r2, r8, asr #8
 802391c:	f800 8c0c 	strb.w	r8, [r0, #-12]
 8023920:	f803 2c0c 	strb.w	r2, [r3, #-12]
    BuffPos+=2;
  }

  ret = aci_gatt_update_char_value(HWServW2STHandle, EnvironmentalCharHandle, 0, EnvironmentalCharSize,buff);
 8023924:	4c20      	ldr	r4, [pc, #128]	; (80239a8 <Environmental_Update+0x13c>)
 8023926:	4b21      	ldr	r3, [pc, #132]	; (80239ac <Environmental_Update+0x140>)
 8023928:	f8b4 104a 	ldrh.w	r1, [r4, #74]	; 0x4a
 802392c:	781b      	ldrb	r3, [r3, #0]
 802392e:	f8b4 0040 	ldrh.w	r0, [r4, #64]	; 0x40
 8023932:	aa03      	add	r2, sp, #12
 8023934:	9200      	str	r2, [sp, #0]
 8023936:	2200      	movs	r2, #0
 8023938:	f7f7 ff9a 	bl	801b870 <aci_gatt_update_char_value>

  if (ret != BLE_STATUS_SUCCESS){
 802393c:	b920      	cbnz	r0, 8023948 <Environmental_Update+0xdc>
      SENSING1_PRINTF("Error Updating Environmental Char\r\n");
    }
    return BLE_STATUS_ERROR;
  }
  return BLE_STATUS_SUCCESS;
}
 802393e:	b006      	add	sp, #24
 8023940:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  BuffPos=2;
 8023944:	2002      	movs	r0, #2
 8023946:	e7b4      	b.n	80238b2 <Environmental_Update+0x46>
    if(W2ST_CHECK_CONNECTION(W2ST_CONNECT_STD_ERR)){
 8023948:	6c63      	ldr	r3, [r4, #68]	; 0x44
 802394a:	065b      	lsls	r3, r3, #25
 802394c:	d404      	bmi.n	8023958 <Environmental_Update+0xec>
      SENSING1_PRINTF("Error Updating Environmental Char\r\n");
 802394e:	4b18      	ldr	r3, [pc, #96]	; (80239b0 <Environmental_Update+0x144>)
 8023950:	781b      	ldrb	r3, [r3, #0]
 8023952:	bb0b      	cbnz	r3, 8023998 <Environmental_Update+0x12c>
    return BLE_STATUS_ERROR;
 8023954:	2047      	movs	r0, #71	; 0x47
 8023956:	e7f2      	b.n	802393e <Environmental_Update+0xd2>
      BytesToWrite =sprintf((char *)BufferToWrite, "Error Updating Environmental Char\n");
 8023958:	4e16      	ldr	r6, [pc, #88]	; (80239b4 <Environmental_Update+0x148>)
 802395a:	4d17      	ldr	r5, [pc, #92]	; (80239b8 <Environmental_Update+0x14c>)
 802395c:	f106 0720 	add.w	r7, r6, #32
 8023960:	4634      	mov	r4, r6
 8023962:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 8023964:	42bc      	cmp	r4, r7
 8023966:	f105 0510 	add.w	r5, r5, #16
 802396a:	f106 0610 	add.w	r6, r6, #16
 802396e:	f845 0c10 	str.w	r0, [r5, #-16]
 8023972:	f845 1c0c 	str.w	r1, [r5, #-12]
 8023976:	f845 2c08 	str.w	r2, [r5, #-8]
 802397a:	f845 3c04 	str.w	r3, [r5, #-4]
 802397e:	d1ef      	bne.n	8023960 <Environmental_Update+0xf4>
 8023980:	8832      	ldrh	r2, [r6, #0]
 8023982:	802a      	strh	r2, [r5, #0]
 8023984:	4b0d      	ldr	r3, [pc, #52]	; (80239bc <Environmental_Update+0x150>)
 8023986:	78b2      	ldrb	r2, [r6, #2]
 8023988:	70aa      	strb	r2, [r5, #2]
 802398a:	2122      	movs	r1, #34	; 0x22
      Stderr_Update(BufferToWrite,BytesToWrite);
 802398c:	480a      	ldr	r0, [pc, #40]	; (80239b8 <Environmental_Update+0x14c>)
      BytesToWrite =sprintf((char *)BufferToWrite, "Error Updating Environmental Char\n");
 802398e:	6019      	str	r1, [r3, #0]
      Stderr_Update(BufferToWrite,BytesToWrite);
 8023990:	f7ff fb5e 	bl	8023050 <Stderr_Update>
    return BLE_STATUS_ERROR;
 8023994:	2047      	movs	r0, #71	; 0x47
 8023996:	e7d2      	b.n	802393e <Environmental_Update+0xd2>
      SENSING1_PRINTF("Error Updating Environmental Char\r\n");
 8023998:	4809      	ldr	r0, [pc, #36]	; (80239c0 <Environmental_Update+0x154>)
 802399a:	f004 fbdb 	bl	8028154 <puts>
    return BLE_STATUS_ERROR;
 802399e:	2047      	movs	r0, #71	; 0x47
 80239a0:	e7cd      	b.n	802393e <Environmental_Update+0xd2>
 80239a2:	bf00      	nop
 80239a4:	200106a4 	.word	0x200106a4
 80239a8:	20014538 	.word	0x20014538
 80239ac:	20000db8 	.word	0x20000db8
 80239b0:	20000d84 	.word	0x20000d84
 80239b4:	08043d78 	.word	0x08043d78
 80239b8:	200133dc 	.word	0x200133dc
 80239bc:	200134dc 	.word	0x200134dc
 80239c0:	08043d9c 	.word	0x08043d9c

080239c4 <AudioLevel_Update>:
 * @brief  Update Microphones characteristic values
 * @param  uint16_t *Mic SNR dB Microphones array
 * @retval tBleStatus   Status
 */
tBleStatus AudioLevel_Update(uint16_t *Mic)
{
 80239c4:	b570      	push	{r4, r5, r6, lr}
 80239c6:	b084      	sub	sp, #16
 80239c8:	4604      	mov	r4, r0
  tBleStatus ret;
  uint16_t Counter;

  uint8_t buff[2+1*AUDIO_CHANNELS]; /* BlueCoin has 4 Mics */

  STORE_LE_16(buff  ,(HAL_GetTick()>>3));
 80239ca:	f7eb ff35 	bl	800f838 <HAL_GetTick>
  if (breath > 0) {
 80239ce:	4d1d      	ldr	r5, [pc, #116]	; (8023a44 <AudioLevel_Update+0x80>)
  STORE_LE_16(buff  ,(HAL_GetTick()>>3));
 80239d0:	08c0      	lsrs	r0, r0, #3
 80239d2:	f88d 000c 	strb.w	r0, [sp, #12]
 80239d6:	f7eb ff2f 	bl	800f838 <HAL_GetTick>
  if (breath > 0) {
 80239da:	682b      	ldr	r3, [r5, #0]
  for(Counter=0;Counter<AUDIO_CHANNELS;Counter++) {
    buff[2+Counter]= Mic[Counter]&0xFF;
 80239dc:	8822      	ldrh	r2, [r4, #0]
 80239de:	f88d 200e 	strb.w	r2, [sp, #14]
  STORE_LE_16(buff  ,(HAL_GetTick()>>3));
 80239e2:	0ac0      	lsrs	r0, r0, #11
  if (breath > 0) {
 80239e4:	2b00      	cmp	r3, #0
  STORE_LE_16(buff  ,(HAL_GetTick()>>3));
 80239e6:	f88d 000d 	strb.w	r0, [sp, #13]
  if (breath > 0) {
 80239ea:	dd07      	ble.n	80239fc <AudioLevel_Update+0x38>
    breath--;
 80239ec:	3b01      	subs	r3, #1
 80239ee:	602b      	str	r3, [r5, #0]
  }

  ret = ACI_GATT_UPDATE_CHAR_VALUE(HWServW2STHandle, AudioLevelCharHandle, 0, 2+AUDIO_CHANNELS,buff);

  if (ret != BLE_STATUS_SUCCESS){
    if(W2ST_CHECK_CONNECTION(W2ST_CONNECT_STD_ERR)){
 80239f0:	6c6b      	ldr	r3, [r5, #68]	; 0x44
 80239f2:	065b      	lsls	r3, r3, #25
 80239f4:	d411      	bmi.n	8023a1a <AudioLevel_Update+0x56>
      BytesToWrite = sprintf((char *)BufferToWrite, "Error Updating Mic Char\n");
      Stderr_Update(BufferToWrite,BytesToWrite);
    }
    return BLE_STATUS_ERROR;
 80239f6:	2047      	movs	r0, #71	; 0x47
  }
  return BLE_STATUS_SUCCESS;
}
 80239f8:	b004      	add	sp, #16
 80239fa:	bd70      	pop	{r4, r5, r6, pc}
    ret = aci_gatt_update_char_value(servHandle,charHandle,charValOffset,charValueLen,charValue);
 80239fc:	ab03      	add	r3, sp, #12
 80239fe:	f8b5 104e 	ldrh.w	r1, [r5, #78]	; 0x4e
 8023a02:	f8b5 0040 	ldrh.w	r0, [r5, #64]	; 0x40
 8023a06:	9300      	str	r3, [sp, #0]
 8023a08:	2200      	movs	r2, #0
 8023a0a:	2303      	movs	r3, #3
 8023a0c:	f7f7 ff30 	bl	801b870 <aci_gatt_update_char_value>
    if (ret != BLE_STATUS_SUCCESS){
 8023a10:	2800      	cmp	r0, #0
 8023a12:	d0f1      	beq.n	80239f8 <AudioLevel_Update+0x34>
      breath = ACC_BLUENRG_CONGESTION_SKIP;
 8023a14:	231e      	movs	r3, #30
 8023a16:	602b      	str	r3, [r5, #0]
  if (ret != BLE_STATUS_SUCCESS){
 8023a18:	e7ea      	b.n	80239f0 <AudioLevel_Update+0x2c>
      BytesToWrite = sprintf((char *)BufferToWrite, "Error Updating Mic Char\n");
 8023a1a:	4c0b      	ldr	r4, [pc, #44]	; (8023a48 <AudioLevel_Update+0x84>)
 8023a1c:	4d0b      	ldr	r5, [pc, #44]	; (8023a4c <AudioLevel_Update+0x88>)
 8023a1e:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 8023a20:	6069      	str	r1, [r5, #4]
 8023a22:	490b      	ldr	r1, [pc, #44]	; (8023a50 <AudioLevel_Update+0x8c>)
 8023a24:	6028      	str	r0, [r5, #0]
 8023a26:	2618      	movs	r6, #24
 8023a28:	600e      	str	r6, [r1, #0]
 8023a2a:	cc03      	ldmia	r4!, {r0, r1}
 8023a2c:	60eb      	str	r3, [r5, #12]
 8023a2e:	7823      	ldrb	r3, [r4, #0]
 8023a30:	6128      	str	r0, [r5, #16]
 8023a32:	6169      	str	r1, [r5, #20]
 8023a34:	60aa      	str	r2, [r5, #8]
      Stderr_Update(BufferToWrite,BytesToWrite);
 8023a36:	4628      	mov	r0, r5
 8023a38:	4631      	mov	r1, r6
      BytesToWrite = sprintf((char *)BufferToWrite, "Error Updating Mic Char\n");
 8023a3a:	762b      	strb	r3, [r5, #24]
      Stderr_Update(BufferToWrite,BytesToWrite);
 8023a3c:	f7ff fb08 	bl	8023050 <Stderr_Update>
    return BLE_STATUS_ERROR;
 8023a40:	2047      	movs	r0, #71	; 0x47
 8023a42:	e7d9      	b.n	80239f8 <AudioLevel_Update+0x34>
 8023a44:	20014538 	.word	0x20014538
 8023a48:	08043dc0 	.word	0x08043dc0
 8023a4c:	200133dc 	.word	0x200133dc
 8023a50:	200134dc 	.word	0x200134dc

08023a54 <SDLog_Update>:
 * @brief  Update SD Log characteristic
 * @param  None
 * @retval tBleStatus   Status
 */
tBleStatus SDLog_Update(uint8_t ErrorCode)
{
 8023a54:	b530      	push	{r4, r5, lr}
 8023a56:	b085      	sub	sp, #20
 8023a58:	4604      	mov	r4, r0
  tBleStatus ret;
  uint8_t buff[2+1];

  STORE_LE_16(buff  ,(HAL_GetTick()>>3));
 8023a5a:	f7eb feed 	bl	800f838 <HAL_GetTick>
 8023a5e:	08c0      	lsrs	r0, r0, #3
 8023a60:	f88d 000c 	strb.w	r0, [sp, #12]
 8023a64:	f7eb fee8 	bl	800f838 <HAL_GetTick>
  buff[2] = ErrorCode;

  ret = aci_gatt_update_char_value(HWServW2STHandle, SDLogFeaturesCharHandle, 0, 3,buff);
 8023a68:	4d19      	ldr	r5, [pc, #100]	; (8023ad0 <SDLog_Update+0x7c>)
  buff[2] = ErrorCode;
 8023a6a:	f88d 400e 	strb.w	r4, [sp, #14]
  ret = aci_gatt_update_char_value(HWServW2STHandle, SDLogFeaturesCharHandle, 0, 3,buff);
 8023a6e:	ab03      	add	r3, sp, #12
 8023a70:	9300      	str	r3, [sp, #0]
  STORE_LE_16(buff  ,(HAL_GetTick()>>3));
 8023a72:	0ac0      	lsrs	r0, r0, #11
 8023a74:	f88d 000d 	strb.w	r0, [sp, #13]
  ret = aci_gatt_update_char_value(HWServW2STHandle, SDLogFeaturesCharHandle, 0, 3,buff);
 8023a78:	f8b5 1050 	ldrh.w	r1, [r5, #80]	; 0x50
 8023a7c:	f8b5 0040 	ldrh.w	r0, [r5, #64]	; 0x40
 8023a80:	2303      	movs	r3, #3
 8023a82:	2200      	movs	r2, #0
 8023a84:	f7f7 fef4 	bl	801b870 <aci_gatt_update_char_value>

  if (ret != BLE_STATUS_SUCCESS){
 8023a88:	b908      	cbnz	r0, 8023a8e <SDLog_Update+0x3a>
      SENSING1_PRINTF("Error Updating SD Log Char\r\n");
    }
    return BLE_STATUS_ERROR;
  }
  return BLE_STATUS_SUCCESS;
}
 8023a8a:	b005      	add	sp, #20
 8023a8c:	bd30      	pop	{r4, r5, pc}
    if(W2ST_CHECK_CONNECTION(W2ST_CONNECT_STD_ERR)){
 8023a8e:	6c6b      	ldr	r3, [r5, #68]	; 0x44
 8023a90:	065b      	lsls	r3, r3, #25
 8023a92:	d404      	bmi.n	8023a9e <SDLog_Update+0x4a>
      SENSING1_PRINTF("Error Updating SD Log Char\r\n");
 8023a94:	4b0f      	ldr	r3, [pc, #60]	; (8023ad4 <SDLog_Update+0x80>)
 8023a96:	781b      	ldrb	r3, [r3, #0]
 8023a98:	b9ab      	cbnz	r3, 8023ac6 <SDLog_Update+0x72>
 8023a9a:	2047      	movs	r0, #71	; 0x47
 8023a9c:	e7f5      	b.n	8023a8a <SDLog_Update+0x36>
      BytesToWrite = sprintf((char *)BufferToWrite, "Error Updating SD Log Char\n");
 8023a9e:	4c0e      	ldr	r4, [pc, #56]	; (8023ad8 <SDLog_Update+0x84>)
 8023aa0:	4d0e      	ldr	r5, [pc, #56]	; (8023adc <SDLog_Update+0x88>)
 8023aa2:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 8023aa4:	6028      	str	r0, [r5, #0]
 8023aa6:	6069      	str	r1, [r5, #4]
 8023aa8:	60aa      	str	r2, [r5, #8]
 8023aaa:	cc07      	ldmia	r4!, {r0, r1, r2}
 8023aac:	60eb      	str	r3, [r5, #12]
 8023aae:	4c0c      	ldr	r4, [pc, #48]	; (8023ae0 <SDLog_Update+0x8c>)
 8023ab0:	6128      	str	r0, [r5, #16]
 8023ab2:	231b      	movs	r3, #27
 8023ab4:	6169      	str	r1, [r5, #20]
      Stderr_Update(BufferToWrite,BytesToWrite);
 8023ab6:	4628      	mov	r0, r5
 8023ab8:	4619      	mov	r1, r3
      BytesToWrite = sprintf((char *)BufferToWrite, "Error Updating SD Log Char\n");
 8023aba:	61aa      	str	r2, [r5, #24]
 8023abc:	6023      	str	r3, [r4, #0]
      Stderr_Update(BufferToWrite,BytesToWrite);
 8023abe:	f7ff fac7 	bl	8023050 <Stderr_Update>
 8023ac2:	2047      	movs	r0, #71	; 0x47
 8023ac4:	e7e1      	b.n	8023a8a <SDLog_Update+0x36>
      SENSING1_PRINTF("Error Updating SD Log Char\r\n");
 8023ac6:	4807      	ldr	r0, [pc, #28]	; (8023ae4 <SDLog_Update+0x90>)
 8023ac8:	f004 fb44 	bl	8028154 <puts>
 8023acc:	2047      	movs	r0, #71	; 0x47
 8023ace:	e7dc      	b.n	8023a8a <SDLog_Update+0x36>
 8023ad0:	20014538 	.word	0x20014538
 8023ad4:	20000d84 	.word	0x20000d84
 8023ad8:	08043ddc 	.word	0x08043ddc
 8023adc:	200133dc 	.word	0x200133dc
 8023ae0:	200134dc 	.word	0x200134dc
 8023ae4:	08043df8 	.word	0x08043df8

08023ae8 <setConnectable>:
 * @brief  Puts the device in connectable mode.
 * @param  None
 * @retval None
 */
void setConnectable(void)
{
 8023ae8:	b510      	push	{r4, lr}
#ifndef SENSING1_BlueNRG2
  char local_name[8] = {AD_TYPE_COMPLETE_LOCAL_NAME,NodeName[1],NodeName[2],NodeName[3],NodeName[4],NodeName[5],NodeName[6],NodeName[7]};
 8023aea:	4b4f      	ldr	r3, [pc, #316]	; (8023c28 <setConnectable+0x140>)
{
 8023aec:	b092      	sub	sp, #72	; 0x48
  char local_name[8] = {AD_TYPE_COMPLETE_LOCAL_NAME,NodeName[1],NodeName[2],NodeName[3],NodeName[4],NodeName[5],NodeName[6],NodeName[7]};
 8023aee:	78d8      	ldrb	r0, [r3, #3]
 8023af0:	f88d 0027 	strb.w	r0, [sp, #39]	; 0x27
#else /* SENSING1_BlueNRG2 */
  uint8_t local_name[8] = {AD_TYPE_COMPLETE_LOCAL_NAME,NodeName[1],NodeName[2],NodeName[3],NodeName[4],NodeName[5],NodeName[6],NodeName[7]};
#endif /* SENSING1_BlueNRG2 */

  uint8_t manuf_data[26] = {
 8023af4:	f88d 0033 	strb.w	r0, [sp, #51]	; 0x33
 8023af8:	2001      	movs	r0, #1
 8023afa:	f88d 003a 	strb.w	r0, [sp, #58]	; 0x3a
 8023afe:	20e0      	movs	r0, #224	; 0xe0
 8023b00:	f88d 003d 	strb.w	r0, [sp, #61]	; 0x3d
  char local_name[8] = {AD_TYPE_COMPLETE_LOCAL_NAME,NodeName[1],NodeName[2],NodeName[3],NodeName[4],NodeName[5],NodeName[6],NodeName[7]};
 8023b04:	7918      	ldrb	r0, [r3, #4]
 8023b06:	f88d 0028 	strb.w	r0, [sp, #40]	; 0x28
  uint8_t manuf_data[26] = {
 8023b0a:	f88d 0034 	strb.w	r0, [sp, #52]	; 0x34
  char local_name[8] = {AD_TYPE_COMPLETE_LOCAL_NAME,NodeName[1],NodeName[2],NodeName[3],NodeName[4],NodeName[5],NodeName[6],NodeName[7]};
 8023b0e:	7958      	ldrb	r0, [r3, #5]
 8023b10:	f88d 0029 	strb.w	r0, [sp, #41]	; 0x29
  uint8_t manuf_data[26] = {
 8023b14:	f88d 0035 	strb.w	r0, [sp, #53]	; 0x35
  char local_name[8] = {AD_TYPE_COMPLETE_LOCAL_NAME,NodeName[1],NodeName[2],NodeName[3],NodeName[4],NodeName[5],NodeName[6],NodeName[7]};
 8023b18:	7998      	ldrb	r0, [r3, #6]
 8023b1a:	789a      	ldrb	r2, [r3, #2]
 8023b1c:	f88d 002a 	strb.w	r0, [sp, #42]	; 0x2a
  uint8_t manuf_data[26] = {
 8023b20:	f88d 0036 	strb.w	r0, [sp, #54]	; 0x36
 8023b24:	2008      	movs	r0, #8
  char local_name[8] = {AD_TYPE_COMPLETE_LOCAL_NAME,NodeName[1],NodeName[2],NodeName[3],NodeName[4],NodeName[5],NodeName[6],NodeName[7]};
 8023b26:	7859      	ldrb	r1, [r3, #1]
 8023b28:	f88d 2026 	strb.w	r2, [sp, #38]	; 0x26
 8023b2c:	79db      	ldrb	r3, [r3, #7]
  uint8_t manuf_data[26] = {
 8023b2e:	f88d 2032 	strb.w	r2, [sp, #50]	; 0x32
  char local_name[8] = {AD_TYPE_COMPLETE_LOCAL_NAME,NodeName[1],NodeName[2],NodeName[3],NodeName[4],NodeName[5],NodeName[6],NodeName[7]};
 8023b32:	f04f 0c09 	mov.w	ip, #9
    0x00,
    0x00, /* BLE MAC stop */
  };

  /* BLE MAC */
  manuf_data[20] = bdaddr[5];
 8023b36:	4a3d      	ldr	r2, [pc, #244]	; (8023c2c <setConnectable+0x144>)
  uint8_t manuf_data[26] = {
 8023b38:	f88d 002f 	strb.w	r0, [sp, #47]	; 0x2f
 8023b3c:	240d      	movs	r4, #13
 8023b3e:	2002      	movs	r0, #2
  char local_name[8] = {AD_TYPE_COMPLETE_LOCAL_NAME,NodeName[1],NodeName[2],NodeName[3],NodeName[4],NodeName[5],NodeName[6],NodeName[7]};
 8023b40:	f88d c024 	strb.w	ip, [sp, #36]	; 0x24
  uint8_t manuf_data[26] = {
 8023b44:	f88d c030 	strb.w	ip, [sp, #48]	; 0x30
 8023b48:	f88d 4038 	strb.w	r4, [sp, #56]	; 0x38
  char local_name[8] = {AD_TYPE_COMPLETE_LOCAL_NAME,NodeName[1],NodeName[2],NodeName[3],NodeName[4],NodeName[5],NodeName[6],NodeName[7]};
 8023b4c:	f88d 302b 	strb.w	r3, [sp, #43]	; 0x2b
  uint8_t manuf_data[26] = {
 8023b50:	2407      	movs	r4, #7
 8023b52:	f88d 3037 	strb.w	r3, [sp, #55]	; 0x37
 8023b56:	f88d 002c 	strb.w	r0, [sp, #44]	; 0x2c
 8023b5a:	2300      	movs	r3, #0
 8023b5c:	200a      	movs	r0, #10
 8023b5e:	f04f 0cff 	mov.w	ip, #255	; 0xff
  char local_name[8] = {AD_TYPE_COMPLETE_LOCAL_NAME,NodeName[1],NodeName[2],NodeName[3],NodeName[4],NodeName[5],NodeName[6],NodeName[7]};
 8023b62:	f88d 1025 	strb.w	r1, [sp, #37]	; 0x25
  uint8_t manuf_data[26] = {
 8023b66:	f88d 1031 	strb.w	r1, [sp, #49]	; 0x31
 8023b6a:	f88d 403b 	strb.w	r4, [sp, #59]	; 0x3b
 8023b6e:	f88d 302e 	strb.w	r3, [sp, #46]	; 0x2e
  }
#endif /* ((defined STM32_SENSORTILE) | (defined STM32_SENSORTILEBOX)) */

  manuf_data[16] |= 0x04; /* Mic */

  if(TargetBoardFeatures.NumTempSensors==2) {
 8023b72:	492f      	ldr	r1, [pc, #188]	; (8023c30 <setConnectable+0x148>)
  uint8_t manuf_data[26] = {
 8023b74:	f88d c039 	strb.w	ip, [sp, #57]	; 0x39
 8023b78:	f88d 002d 	strb.w	r0, [sp, #45]	; 0x2d
  manuf_data[20] = bdaddr[5];
 8023b7c:	7950      	ldrb	r0, [r2, #5]
 8023b7e:	f88d 0040 	strb.w	r0, [sp, #64]	; 0x40
  manuf_data[21] = bdaddr[4];
 8023b82:	7910      	ldrb	r0, [r2, #4]
  uint8_t manuf_data[26] = {
 8023b84:	f88d 303e 	strb.w	r3, [sp, #62]	; 0x3e
  manuf_data[21] = bdaddr[4];
 8023b88:	f88d 0041 	strb.w	r0, [sp, #65]	; 0x41
  if(TargetBoardFeatures.NumTempSensors==2) {
 8023b8c:	684b      	ldr	r3, [r1, #4]
  manuf_data[22] = bdaddr[3];
 8023b8e:	78d0      	ldrb	r0, [r2, #3]
 8023b90:	f88d 0042 	strb.w	r0, [sp, #66]	; 0x42
  manuf_data[23] = bdaddr[2];
 8023b94:	7890      	ldrb	r0, [r2, #2]
 8023b96:	f88d 0043 	strb.w	r0, [sp, #67]	; 0x43
  manuf_data[16] |= 0x04; /* Mic */
 8023b9a:	2404      	movs	r4, #4
  manuf_data[24] = bdaddr[1];
 8023b9c:	7850      	ldrb	r0, [r2, #1]
  manuf_data[25] = bdaddr[0];
 8023b9e:	7812      	ldrb	r2, [r2, #0]
  manuf_data[24] = bdaddr[1];
 8023ba0:	f88d 0044 	strb.w	r0, [sp, #68]	; 0x44
  if(TargetBoardFeatures.NumTempSensors==2) {
 8023ba4:	2b02      	cmp	r3, #2
  manuf_data[25] = bdaddr[0];
 8023ba6:	f88d 2045 	strb.w	r2, [sp, #69]	; 0x45
  manuf_data[16] |= 0x04; /* Mic */
 8023baa:	f88d 403c 	strb.w	r4, [sp, #60]	; 0x3c
  if(TargetBoardFeatures.NumTempSensors==2) {
 8023bae:	d037      	beq.n	8023c20 <setConnectable+0x138>
    manuf_data[17] |= 0x05; /* Two Temperature values*/
  } else if(TargetBoardFeatures.NumTempSensors==1) {
 8023bb0:	2b01      	cmp	r3, #1
    manuf_data[17] |= 0x04; /* One Temperature value*/
 8023bb2:	bf04      	itt	eq
 8023bb4:	23e4      	moveq	r3, #228	; 0xe4
 8023bb6:	f88d 303d 	strbeq.w	r3, [sp, #61]	; 0x3d
  }

  if (TargetBoardFeatures.HandleHumSensor != SENSING1_SNS_NOT_VALID) {
 8023bba:	694a      	ldr	r2, [r1, #20]
 8023bbc:	f242 730f 	movw	r3, #9999	; 0x270f
 8023bc0:	429a      	cmp	r2, r3
 8023bc2:	d005      	beq.n	8023bd0 <setConnectable+0xe8>
    manuf_data[17] |= 0x08; /* Humidity */
 8023bc4:	f89d 303d 	ldrb.w	r3, [sp, #61]	; 0x3d
 8023bc8:	f043 0308 	orr.w	r3, r3, #8
 8023bcc:	f88d 303d 	strb.w	r3, [sp, #61]	; 0x3d
  }

  if (TargetBoardFeatures.HandlePressSensor != SENSING1_SNS_NOT_VALID) {
 8023bd0:	690a      	ldr	r2, [r1, #16]
 8023bd2:	f242 730f 	movw	r3, #9999	; 0x270f
 8023bd6:	429a      	cmp	r2, r3
 8023bd8:	d005      	beq.n	8023be6 <setConnectable+0xfe>
    manuf_data[17] |= 0x10; /* Pressure value*/
 8023bda:	f89d 303d 	ldrb.w	r3, [sp, #61]	; 0x3d
 8023bde:	f043 0310 	orr.w	r3, r3, #16
 8023be2:	f88d 303d 	strb.w	r3, [sp, #61]	; 0x3d

    manuf_data[19] |= 0x10;

  /* disable scan response */
#ifndef SENSING1_BlueNRG2
  hci_le_set_scan_resp_data(0,NULL);
 8023be6:	2100      	movs	r1, #0
    manuf_data[19] |= 0x10;
 8023be8:	2310      	movs	r3, #16
  hci_le_set_scan_resp_data(0,NULL);
 8023bea:	4608      	mov	r0, r1
    manuf_data[19] |= 0x10;
 8023bec:	f88d 303f 	strb.w	r3, [sp, #63]	; 0x3f
#endif /* SENSING1_BlueNRG2 */

#ifndef BLE_CHANGE_ADV_INTERVAL
  aci_gap_set_discoverable(ADV_IND, 0, 0,
#else /* BLE_CHANGE_ADV_INTERVAL */
  aci_gap_set_discoverable(ADV_IND, 0x0640, 0x0640,
 8023bf0:	ac09      	add	r4, sp, #36	; 0x24
  hci_le_set_scan_resp_data(0,NULL);
 8023bf2:	f7f7 ff23 	bl	801ba3c <hci_le_set_scan_resp_data>
  aci_gap_set_discoverable(ADV_IND, 0x0640, 0x0640,
 8023bf6:	2000      	movs	r0, #0
 8023bf8:	f44f 62c8 	mov.w	r2, #1600	; 0x640
 8023bfc:	2308      	movs	r3, #8
 8023bfe:	4611      	mov	r1, r2
 8023c00:	e9cd 3401 	strd	r3, r4, [sp, #4]
 8023c04:	e9cd 0005 	strd	r0, r0, [sp, #20]
 8023c08:	2301      	movs	r3, #1
 8023c0a:	e9cd 0003 	strd	r0, r0, [sp, #12]
 8023c0e:	9000      	str	r0, [sp, #0]
 8023c10:	f7f7 fc7e 	bl	801b510 <aci_gap_set_discoverable>
#endif /* MAC_SENSING1 */
                           NO_WHITE_LIST_USE,
                           sizeof(local_name), local_name, 0, NULL, 0, 0);

  /* Send Advertising data */
  aci_gap_update_adv_data(26, manuf_data);
 8023c14:	a90b      	add	r1, sp, #44	; 0x2c
 8023c16:	201a      	movs	r0, #26
 8023c18:	f7f7 fd1c 	bl	801b654 <aci_gap_update_adv_data>
}
 8023c1c:	b012      	add	sp, #72	; 0x48
 8023c1e:	bd10      	pop	{r4, pc}
    manuf_data[17] |= 0x05; /* Two Temperature values*/
 8023c20:	23e5      	movs	r3, #229	; 0xe5
 8023c22:	f88d 303d 	strb.w	r3, [sp, #61]	; 0x3d
 8023c26:	e7c8      	b.n	8023bba <setConnectable+0xd2>
 8023c28:	200134e0 	.word	0x200134e0
 8023c2c:	200134e8 	.word	0x200134e8
 8023c30:	200106a4 	.word	0x200106a4
 8023c34:	00000000 	.word	0x00000000

08023c38 <HCI_Event_CB>:
void HCI_Event_CB(void *pckt)
{
  hci_uart_pckt *hci_pckt = pckt;
  hci_event_pckt *event_pckt = (hci_event_pckt*)hci_pckt->data;

  if (hci_pckt->type != HCI_EVENT_PKT) {
 8023c38:	7803      	ldrb	r3, [r0, #0]
 8023c3a:	2b04      	cmp	r3, #4
 8023c3c:	d000      	beq.n	8023c40 <HCI_Event_CB+0x8>
 8023c3e:	4770      	bx	lr
{
 8023c40:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    TRACE_HCI_CB_PRINTF("HCI_Event_CB: INVALID\n\r");
    return;
  }

  switch (event_pckt->evt) {
 8023c44:	7843      	ldrb	r3, [r0, #1]
 8023c46:	2b3e      	cmp	r3, #62	; 0x3e
{
 8023c48:	b093      	sub	sp, #76	; 0x4c
 8023c4a:	4604      	mov	r4, r0
  switch (event_pckt->evt) {
 8023c4c:	d063      	beq.n	8023d16 <HCI_Event_CB+0xde>
 8023c4e:	2bff      	cmp	r3, #255	; 0xff
 8023c50:	d004      	beq.n	8023c5c <HCI_Event_CB+0x24>
 8023c52:	2b05      	cmp	r3, #5
 8023c54:	d032      	beq.n	8023cbc <HCI_Event_CB+0x84>
      evt_blue_aci *blue_evt = (void*)event_pckt->data;
      HCI_Vendor_Event_CB(blue_evt);
      break;
    }
  }
}
 8023c56:	b013      	add	sp, #76	; 0x4c
 8023c58:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

static void HCI_Vendor_Event_CB(evt_blue_aci *blue_evt)
{
  TRACE_HCI_CB_PRINTF("HCI_Event_CB: vendor");

  switch (blue_evt->ecode) {
 8023c5c:	f8b0 3003 	ldrh.w	r3, [r0, #3]
 8023c60:	f640 4201 	movw	r2, #3073	; 0xc01
 8023c64:	4293      	cmp	r3, r2
 8023c66:	d07e      	beq.n	8023d66 <HCI_Event_CB+0x12e>
 8023c68:	f640 4214 	movw	r2, #3092	; 0xc14
 8023c6c:	4293      	cmp	r3, r2
 8023c6e:	d1f2      	bne.n	8023c56 <HCI_Event_CB+0x1e>
  if(handle == EnvironmentalCharHandle + 1){
 8023c70:	4db3      	ldr	r5, [pc, #716]	; (8023f40 <HCI_Event_CB+0x308>)
 8023c72:	f8b0 3007 	ldrh.w	r3, [r0, #7]
 8023c76:	f8b5 204a 	ldrh.w	r2, [r5, #74]	; 0x4a
 8023c7a:	3201      	adds	r2, #1
 8023c7c:	4293      	cmp	r3, r2
 8023c7e:	d060      	beq.n	8023d42 <HCI_Event_CB+0x10a>
  } else if (handle == StdErrCharHandle + 1) {
 8023c80:	89aa      	ldrh	r2, [r5, #12]
 8023c82:	3201      	adds	r2, #1
 8023c84:	4293      	cmp	r3, r2
 8023c86:	f000 812d 	beq.w	8023ee4 <HCI_Event_CB+0x2ac>
  } else if (handle == TermCharHandle + 1) {
 8023c8a:	896a      	ldrh	r2, [r5, #10]
 8023c8c:	3201      	adds	r2, #1
 8023c8e:	4293      	cmp	r3, r2
 8023c90:	f000 8144 	beq.w	8023f1c <HCI_Event_CB+0x2e4>
  } else if (handle == ActivityRecCharHandle + 1) {
 8023c94:	8fea      	ldrh	r2, [r5, #62]	; 0x3e
 8023c96:	3201      	adds	r2, #1
 8023c98:	4293      	cmp	r3, r2
 8023c9a:	f000 818c 	beq.w	8023fb6 <HCI_Event_CB+0x37e>
  } else if (handle == AudioSRecCharHandle + 1) {
 8023c9e:	f8b5 2048 	ldrh.w	r2, [r5, #72]	; 0x48
 8023ca2:	3201      	adds	r2, #1
 8023ca4:	4293      	cmp	r3, r2
 8023ca6:	f000 8199 	beq.w	8023fdc <HCI_Event_CB+0x3a4>
  if(connection_handle != 0)
 8023caa:	f8b5 0058 	ldrh.w	r0, [r5, #88]	; 0x58
 8023cae:	2800      	cmp	r0, #0
 8023cb0:	d0d1      	beq.n	8023c56 <HCI_Event_CB+0x1e>
}
 8023cb2:	b013      	add	sp, #76	; 0x4c
 8023cb4:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    aci_gatt_allow_read(connection_handle);
 8023cb8:	f7f7 be0e 	b.w	801b8d8 <aci_gatt_allow_read>
  SENSING1_PRINTF("<<<<<<DISCONNECTED\r\n");
 8023cbc:	4ba1      	ldr	r3, [pc, #644]	; (8023f44 <HCI_Event_CB+0x30c>)
 8023cbe:	781b      	ldrb	r3, [r3, #0]
 8023cc0:	2b00      	cmp	r3, #0
 8023cc2:	f040 80bd 	bne.w	8023e40 <HCI_Event_CB+0x208>
  if(SD_LogMems_Enabled) {
 8023cc6:	4aa0      	ldr	r2, [pc, #640]	; (8023f48 <HCI_Event_CB+0x310>)
  ConnectionBleStatus=0;
 8023cc8:	4b9d      	ldr	r3, [pc, #628]	; (8023f40 <HCI_Event_CB+0x308>)
  set_connectable = TRUE;
 8023cca:	48a0      	ldr	r0, [pc, #640]	; (8023f4c <HCI_Event_CB+0x314>)
  if(SD_LogMems_Enabled) {
 8023ccc:	6811      	ldr	r1, [r2, #0]
  set_connectable = TRUE;
 8023cce:	2401      	movs	r4, #1
  ConnectionBleStatus=0;
 8023cd0:	2200      	movs	r2, #0
  set_connectable = TRUE;
 8023cd2:	7044      	strb	r4, [r0, #1]
  ConnectionBleStatus=0;
 8023cd4:	645a      	str	r2, [r3, #68]	; 0x44
  SizeOfUpdateBlueFW = 0;
 8023cd6:	655a      	str	r2, [r3, #84]	; 0x54
  if(SD_LogMems_Enabled) {
 8023cd8:	2900      	cmp	r1, #0
 8023cda:	f040 80a9 	bne.w	8023e30 <HCI_Event_CB+0x1f8>
  if(SD_LogAudio_Enabled) {
 8023cde:	4b9c      	ldr	r3, [pc, #624]	; (8023f50 <HCI_Event_CB+0x318>)
 8023ce0:	681b      	ldr	r3, [r3, #0]
 8023ce2:	2b00      	cmp	r3, #0
 8023ce4:	f040 8099 	bne.w	8023e1a <HCI_Event_CB+0x1e2>
  switch(HarAlgo) {
 8023ce8:	4b9a      	ldr	r3, [pc, #616]	; (8023f54 <HCI_Event_CB+0x31c>)
 8023cea:	781b      	ldrb	r3, [r3, #0]
 8023cec:	2b01      	cmp	r3, #1
 8023cee:	f000 80b3 	beq.w	8023e58 <HCI_Event_CB+0x220>
 8023cf2:	2b02      	cmp	r3, #2
 8023cf4:	f000 80ac 	beq.w	8023e50 <HCI_Event_CB+0x218>
 8023cf8:	2b00      	cmp	r3, #0
 8023cfa:	f000 80a5 	beq.w	8023e48 <HCI_Event_CB+0x210>
  stopProc(MOTION);
 8023cfe:	2006      	movs	r0, #6
 8023d00:	f7fd ffaa 	bl	8021c58 <stopProc>
  stopProc(ENV);
 8023d04:	2005      	movs	r0, #5
 8023d06:	f7fd ffa7 	bl	8021c58 <stopProc>
  stopProc(AUDIO_LEV);
 8023d0a:	200c      	movs	r0, #12
}
 8023d0c:	b013      	add	sp, #76	; 0x4c
 8023d0e:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
      stopProc(AUDIO_SC);
 8023d12:	f7fd bfa1 	b.w	8021c58 <stopProc>
  switch (le_meta_evt->subevent) {
 8023d16:	78c3      	ldrb	r3, [r0, #3]
 8023d18:	2b01      	cmp	r3, #1
 8023d1a:	d19c      	bne.n	8023c56 <HCI_Event_CB+0x1e>
  SENSING1_PRINTF(">>>>>>CONNECTED %02x:%02x:%02x:%02x:%02x:%02x\r\n", addr[5],addr[4],addr[3],addr[2],addr[1],addr[0]);
 8023d1c:	4a89      	ldr	r2, [pc, #548]	; (8023f44 <HCI_Event_CB+0x30c>)
      GAP_ConnectionComplete_CB(cc->peer_bdaddr, cc->handle);
 8023d1e:	7981      	ldrb	r1, [r0, #6]
 8023d20:	7943      	ldrb	r3, [r0, #5]
  connection_handle = handle;
 8023d22:	4d87      	ldr	r5, [pc, #540]	; (8023f40 <HCI_Event_CB+0x308>)
  SENSING1_PRINTF(">>>>>>CONNECTED %02x:%02x:%02x:%02x:%02x:%02x\r\n", addr[5],addr[4],addr[3],addr[2],addr[1],addr[0]);
 8023d24:	7812      	ldrb	r2, [r2, #0]
      GAP_ConnectionComplete_CB(cc->peer_bdaddr, cc->handle);
 8023d26:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
  connection_handle = handle;
 8023d2a:	f8a5 3058 	strh.w	r3, [r5, #88]	; 0x58
  SENSING1_PRINTF(">>>>>>CONNECTED %02x:%02x:%02x:%02x:%02x:%02x\r\n", addr[5],addr[4],addr[3],addr[2],addr[1],addr[0]);
 8023d2e:	2a00      	cmp	r2, #0
 8023d30:	f040 80cb 	bne.w	8023eca <HCI_Event_CB+0x292>
  ConnectionBleStatus=0;
 8023d34:	2300      	movs	r3, #0
 8023d36:	646b      	str	r3, [r5, #68]	; 0x44
}
 8023d38:	b013      	add	sp, #76	; 0x4c
 8023d3a:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  LedBlinkStop();
 8023d3e:	f7fe bf5b 	b.w	8022bf8 <LedBlinkStop>
    ReadEnvironmentalData(&PressToSend,&HumToSend, &Temp1ToSend,&Temp2ToSend);
 8023d42:	ab07      	add	r3, sp, #28
 8023d44:	f10d 021e 	add.w	r2, sp, #30
 8023d48:	f10d 011a 	add.w	r1, sp, #26
 8023d4c:	a808      	add	r0, sp, #32
 8023d4e:	f7fe f92f 	bl	8021fb0 <ReadEnvironmentalData>
    Environmental_Update(PressToSend,HumToSend,Temp1ToSend,Temp2ToSend);
 8023d52:	f9bd 301c 	ldrsh.w	r3, [sp, #28]
 8023d56:	f9bd 201e 	ldrsh.w	r2, [sp, #30]
 8023d5a:	f8bd 101a 	ldrh.w	r1, [sp, #26]
 8023d5e:	9808      	ldr	r0, [sp, #32]
 8023d60:	f7ff fd84 	bl	802386c <Environmental_Update>
 8023d64:	e7a1      	b.n	8023caa <HCI_Event_CB+0x72>
  if(SizeOfUpdateBlueFW==0) {
 8023d66:	4d76      	ldr	r5, [pc, #472]	; (8023f40 <HCI_Event_CB+0x308>)
    /* Client modifies attribute on the server */
    case EVT_BLUE_GATT_ATTRIBUTE_MODIFIED:
    {
      evt_gatt_attr_modified_IDB05A1 *evt = (evt_gatt_attr_modified_IDB05A1 *)blue_evt->data;
      TRACE_HCI_CB_PRINTF(" - attr modified (attr_handle = %#04x)\n\r", evt->attr_handle);
      Attribute_Modified_CB(evt->attr_handle, evt->att_data, evt->data_length);
 8023d68:	f8b0 7007 	ldrh.w	r7, [r0, #7]
  if(SizeOfUpdateBlueFW==0) {
 8023d6c:	6d6b      	ldr	r3, [r5, #84]	; 0x54
      Attribute_Modified_CB(evt->attr_handle, evt->att_data, evt->data_length);
 8023d6e:	7a46      	ldrb	r6, [r0, #9]
  if(SizeOfUpdateBlueFW==0) {
 8023d70:	2b00      	cmp	r3, #0
 8023d72:	f000 8099 	beq.w	8023ea8 <HCI_Event_CB+0x270>
  if (attr_handle == ActivityRecCharHandle + 2) {
 8023d76:	8fea      	ldrh	r2, [r5, #62]	; 0x3e
 8023d78:	3202      	adds	r2, #2
 8023d7a:	4297      	cmp	r7, r2
 8023d7c:	d070      	beq.n	8023e60 <HCI_Event_CB+0x228>
  if (attr_handle == AudioSRecCharHandle + 2) {
 8023d7e:	f8b5 3048 	ldrh.w	r3, [r5, #72]	; 0x48
 8023d82:	3302      	adds	r3, #2
 8023d84:	429f      	cmp	r7, r3
 8023d86:	f000 8093 	beq.w	8023eb0 <HCI_Event_CB+0x278>
   } else if(attr_handle == ConfigCharHandle + 2){
 8023d8a:	88eb      	ldrh	r3, [r5, #6]
 8023d8c:	1c9a      	adds	r2, r3, #2
 8023d8e:	4297      	cmp	r7, r2
 8023d90:	f000 80b9 	beq.w	8023f06 <HCI_Event_CB+0x2ce>
    } else if(attr_handle == SDLogFeaturesCharHandle + 2){
 8023d94:	f8b5 1050 	ldrh.w	r1, [r5, #80]	; 0x50
 8023d98:	1c8a      	adds	r2, r1, #2
 8023d9a:	4297      	cmp	r7, r2
 8023d9c:	f000 8113 	beq.w	8023fc6 <HCI_Event_CB+0x38e>
  } else if(attr_handle == AccGyroMagCharHandle + 2) {
 8023da0:	f8b5 204c 	ldrh.w	r2, [r5, #76]	; 0x4c
 8023da4:	3202      	adds	r2, #2
 8023da6:	4297      	cmp	r7, r2
 8023da8:	f000 811d 	beq.w	8023fe6 <HCI_Event_CB+0x3ae>
  } else if(attr_handle == EnvironmentalCharHandle + 2){
 8023dac:	f8b5 204a 	ldrh.w	r2, [r5, #74]	; 0x4a
 8023db0:	3202      	adds	r2, #2
 8023db2:	4297      	cmp	r7, r2
 8023db4:	f000 8133 	beq.w	802401e <HCI_Event_CB+0x3e6>
  } else if(attr_handle == StdErrCharHandle + 2){
 8023db8:	89aa      	ldrh	r2, [r5, #12]
 8023dba:	3202      	adds	r2, #2
 8023dbc:	4297      	cmp	r7, r2
 8023dbe:	f000 8148 	beq.w	8024052 <HCI_Event_CB+0x41a>
  } else if(attr_handle == TermCharHandle + 2){
 8023dc2:	896a      	ldrh	r2, [r5, #10]
 8023dc4:	1c90      	adds	r0, r2, #2
 8023dc6:	4287      	cmp	r7, r0
 8023dc8:	f000 8163 	beq.w	8024092 <HCI_Event_CB+0x45a>
  } else if (attr_handle == TermCharHandle + 1){
 8023dcc:	3201      	adds	r2, #1
 8023dce:	4297      	cmp	r7, r2
      Attribute_Modified_CB(evt->attr_handle, evt->att_data, evt->data_length);
 8023dd0:	f104 0a0c 	add.w	sl, r4, #12
  } else if (attr_handle == TermCharHandle + 1){
 8023dd4:	f000 8168 	beq.w	80240a8 <HCI_Event_CB+0x470>
  } else if (attr_handle == AudioLevelCharHandle + 2) {
 8023dd8:	f8b5 204e 	ldrh.w	r2, [r5, #78]	; 0x4e
 8023ddc:	3202      	adds	r2, #2
 8023dde:	4297      	cmp	r7, r2
 8023de0:	f000 819f 	beq.w	8024122 <HCI_Event_CB+0x4ea>
  } else if (attr_handle == ConfigCharHandle + 1) {
 8023de4:	3301      	adds	r3, #1
 8023de6:	429f      	cmp	r7, r3
 8023de8:	f43f af35 	beq.w	8023c56 <HCI_Event_CB+0x1e>
  } else if (attr_handle == SDLogFeaturesCharHandle + 1) {
 8023dec:	3101      	adds	r1, #1
 8023dee:	428f      	cmp	r7, r1
 8023df0:	f000 81e6 	beq.w	80241c0 <HCI_Event_CB+0x588>
  } else if (attr_handle==(0x0002+2)) {
 8023df4:	2f04      	cmp	r7, #4
 8023df6:	f000 82c0 	beq.w	802437a <HCI_Event_CB+0x742>
    if(W2ST_CHECK_CONNECTION(W2ST_CONNECT_STD_ERR)){
 8023dfa:	6c6b      	ldr	r3, [r5, #68]	; 0x44
 8023dfc:	065b      	lsls	r3, r3, #25
 8023dfe:	f100 824b 	bmi.w	8024298 <HCI_Event_CB+0x660>
      SENSING1_PRINTF("Notification UNKNOWN handle =%d\r\n",attr_handle);
 8023e02:	4b50      	ldr	r3, [pc, #320]	; (8023f44 <HCI_Event_CB+0x30c>)
 8023e04:	781b      	ldrb	r3, [r3, #0]
 8023e06:	2b00      	cmp	r3, #0
 8023e08:	f43f af25 	beq.w	8023c56 <HCI_Event_CB+0x1e>
 8023e0c:	4852      	ldr	r0, [pc, #328]	; (8023f58 <HCI_Event_CB+0x320>)
 8023e0e:	4639      	mov	r1, r7
}
 8023e10:	b013      	add	sp, #76	; 0x4c
 8023e12:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
      SENSING1_PRINTF("Notification UNKNOWN handle =%d\r\n",attr_handle);
 8023e16:	f004 b901 	b.w	802801c <iprintf>
    osDelay(100);
 8023e1a:	2064      	movs	r0, #100	; 0x64
 8023e1c:	f7f4 fd52 	bl	80188c4 <osDelay>
    SD_Card_FeaturesMask &= ~FEATURE_MASK_BLUEVOICE;
 8023e20:	4a4e      	ldr	r2, [pc, #312]	; (8023f5c <HCI_Event_CB+0x324>)
 8023e22:	6813      	ldr	r3, [r2, #0]
 8023e24:	f023 6300 	bic.w	r3, r3, #134217728	; 0x8000000
 8023e28:	6013      	str	r3, [r2, #0]
    SD_CardLoggingAudioStop();
 8023e2a:	f7fa fa93 	bl	801e354 <SD_CardLoggingAudioStop>
 8023e2e:	e75b      	b.n	8023ce8 <HCI_Event_CB+0xb0>
    SD_Card_FeaturesMask &= ~(FEATURE_MASK_TEMP1 |
 8023e30:	4a4a      	ldr	r2, [pc, #296]	; (8023f5c <HCI_Event_CB+0x324>)
 8023e32:	6813      	ldr	r3, [r2, #0]
 8023e34:	f423 037d 	bic.w	r3, r3, #16580608	; 0xfd0000
 8023e38:	6013      	str	r3, [r2, #0]
    SD_CardLoggingMemsStop();
 8023e3a:	f7fa f9f9 	bl	801e230 <SD_CardLoggingMemsStop>
 8023e3e:	e74e      	b.n	8023cde <HCI_Event_CB+0xa6>
  SENSING1_PRINTF("<<<<<<DISCONNECTED\r\n");
 8023e40:	4847      	ldr	r0, [pc, #284]	; (8023f60 <HCI_Event_CB+0x328>)
 8023e42:	f004 f987 	bl	8028154 <puts>
 8023e46:	e73e      	b.n	8023cc6 <HCI_Event_CB+0x8e>
      stopProc(ACTIVITY_GMP);
 8023e48:	2008      	movs	r0, #8
 8023e4a:	f7fd ff05 	bl	8021c58 <stopProc>
    break;
 8023e4e:	e756      	b.n	8023cfe <HCI_Event_CB+0xc6>
      stopProc(ACTIVITY_IGN_WSDM);
 8023e50:	200a      	movs	r0, #10
 8023e52:	f7fd ff01 	bl	8021c58 <stopProc>
    break;
 8023e56:	e752      	b.n	8023cfe <HCI_Event_CB+0xc6>
      stopProc(ACTIVITY_IGN);
 8023e58:	2009      	movs	r0, #9
 8023e5a:	f7fd fefd 	bl	8021c58 <stopProc>
    break;
 8023e5e:	e74e      	b.n	8023cfe <HCI_Event_CB+0xc6>
    if (att_data[0] == 01) {
 8023e60:	7b23      	ldrb	r3, [r4, #12]
 8023e62:	2b01      	cmp	r3, #1
 8023e64:	f000 8082 	beq.w	8023f6c <HCI_Event_CB+0x334>
    } else if (att_data[0] == 0) {
 8023e68:	2b00      	cmp	r3, #0
 8023e6a:	f47f aef4 	bne.w	8023c56 <HCI_Event_CB+0x1e>
      switch(HarAlgo) {
 8023e6e:	4b39      	ldr	r3, [pc, #228]	; (8023f54 <HCI_Event_CB+0x31c>)
      W2ST_OFF_CONNECTION(W2ST_CONNECT_AR);
 8023e70:	6c6a      	ldr	r2, [r5, #68]	; 0x44
      switch(HarAlgo) {
 8023e72:	781b      	ldrb	r3, [r3, #0]
      W2ST_OFF_CONNECTION(W2ST_CONNECT_AR);
 8023e74:	f022 0210 	bic.w	r2, r2, #16
      switch(HarAlgo) {
 8023e78:	2b01      	cmp	r3, #1
      W2ST_OFF_CONNECTION(W2ST_CONNECT_AR);
 8023e7a:	646a      	str	r2, [r5, #68]	; 0x44
      switch(HarAlgo) {
 8023e7c:	f000 80f4 	beq.w	8024068 <HCI_Event_CB+0x430>
 8023e80:	2b02      	cmp	r3, #2
 8023e82:	f000 80dc 	beq.w	802403e <HCI_Event_CB+0x406>
 8023e86:	2b00      	cmp	r3, #0
 8023e88:	f47f aee5 	bne.w	8023c56 <HCI_Event_CB+0x1e>
          stopProc(ACTIVITY_GMP);
 8023e8c:	2008      	movs	r0, #8
 8023e8e:	f7fd fee3 	bl	8021c58 <stopProc>
          SENSING1_PRINTF("HAR GMP halted\r\n");
 8023e92:	4b2c      	ldr	r3, [pc, #176]	; (8023f44 <HCI_Event_CB+0x30c>)
 8023e94:	781b      	ldrb	r3, [r3, #0]
 8023e96:	2b00      	cmp	r3, #0
 8023e98:	f43f aedd 	beq.w	8023c56 <HCI_Event_CB+0x1e>
 8023e9c:	4831      	ldr	r0, [pc, #196]	; (8023f64 <HCI_Event_CB+0x32c>)
}
 8023e9e:	b013      	add	sp, #76	; 0x4c
 8023ea0:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
          SENSING1_PRINTF("HAR IGN started\r\n");
 8023ea4:	f004 b956 	b.w	8028154 <puts>
    osDelay(100);
 8023ea8:	2064      	movs	r0, #100	; 0x64
 8023eaa:	f7f4 fd0b 	bl	80188c4 <osDelay>
 8023eae:	e762      	b.n	8023d76 <HCI_Event_CB+0x13e>
    if (att_data[0] == 01) {
 8023eb0:	7b23      	ldrb	r3, [r4, #12]
 8023eb2:	2b01      	cmp	r3, #1
 8023eb4:	f000 80a8 	beq.w	8024008 <HCI_Event_CB+0x3d0>
    } else if (att_data[0] == 0) {
 8023eb8:	2b00      	cmp	r3, #0
 8023eba:	f47f aecc 	bne.w	8023c56 <HCI_Event_CB+0x1e>
      W2ST_OFF_CONNECTION(W2ST_CONNECT_ASC_EVENT);
 8023ebe:	6c6b      	ldr	r3, [r5, #68]	; 0x44
      stopProc(AUDIO_SC);
 8023ec0:	2007      	movs	r0, #7
      W2ST_OFF_CONNECTION(W2ST_CONNECT_ASC_EVENT);
 8023ec2:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
 8023ec6:	646b      	str	r3, [r5, #68]	; 0x44
 8023ec8:	e720      	b.n	8023d0c <HCI_Event_CB+0xd4>
  SENSING1_PRINTF(">>>>>>CONNECTED %02x:%02x:%02x:%02x:%02x:%02x\r\n", addr[5],addr[4],addr[3],addr[2],addr[1],addr[0]);
 8023eca:	7a42      	ldrb	r2, [r0, #9]
 8023ecc:	7a83      	ldrb	r3, [r0, #10]
 8023ece:	7ac0      	ldrb	r0, [r0, #11]
 8023ed0:	e9cd 3201 	strd	r3, r2, [sp, #4]
 8023ed4:	7b23      	ldrb	r3, [r4, #12]
 8023ed6:	7b62      	ldrb	r2, [r4, #13]
 8023ed8:	7ba1      	ldrb	r1, [r4, #14]
 8023eda:	9000      	str	r0, [sp, #0]
 8023edc:	4822      	ldr	r0, [pc, #136]	; (8023f68 <HCI_Event_CB+0x330>)
 8023ede:	f004 f89d 	bl	802801c <iprintf>
 8023ee2:	e727      	b.n	8023d34 <HCI_Event_CB+0xfc>
  msg.term.length = LastStderrLen;
 8023ee4:	f895 2024 	ldrb.w	r2, [r5, #36]	; 0x24
 8023ee8:	f88d 2024 	strb.w	r2, [sp, #36]	; 0x24
  msg.type        = TERM_STDERR;
 8023eec:	230e      	movs	r3, #14
  memcpy(msg.term.data,LastStderrBuffer,LastStderrLen);
 8023eee:	f105 0110 	add.w	r1, r5, #16
 8023ef2:	f10d 0025 	add.w	r0, sp, #37	; 0x25
  msg.type        = TERM_STDERR;
 8023ef6:	f88d 3020 	strb.w	r3, [sp, #32]
  memcpy(msg.term.data,LastStderrBuffer,LastStderrLen);
 8023efa:	f003 fb15 	bl	8027528 <memcpy>
  SendMsgToHost(&msg);
 8023efe:	a808      	add	r0, sp, #32
 8023f00:	f7fd fcaa 	bl	8021858 <SendMsgToHost>
  return BLE_STATUS_SUCCESS;
 8023f04:	e6d1      	b.n	8023caa <HCI_Event_CB+0x72>
      if (att_data[0] == 01) {
 8023f06:	7b23      	ldrb	r3, [r4, #12]
 8023f08:	2b01      	cmp	r3, #1
 8023f0a:	d078      	beq.n	8023ffe <HCI_Event_CB+0x3c6>
      } else if (att_data[0] == 0){
 8023f0c:	2b00      	cmp	r3, #0
 8023f0e:	f47f aea2 	bne.w	8023c56 <HCI_Event_CB+0x1e>
        W2ST_OFF_CONNECTION(W2ST_CONNECT_CONF_EVENT);
 8023f12:	6c6b      	ldr	r3, [r5, #68]	; 0x44
 8023f14:	f423 7300 	bic.w	r3, r3, #512	; 0x200
 8023f18:	646b      	str	r3, [r5, #68]	; 0x44
 8023f1a:	e69c      	b.n	8023c56 <HCI_Event_CB+0x1e>
  msg.term.length = LastTermLen;
 8023f1c:	f895 203c 	ldrb.w	r2, [r5, #60]	; 0x3c
 8023f20:	f88d 2024 	strb.w	r2, [sp, #36]	; 0x24
  msg.type        = TERM_STDOUT;
 8023f24:	230d      	movs	r3, #13
  memcpy(msg.term.data,LastTermBuffer,LastTermLen);
 8023f26:	f105 0128 	add.w	r1, r5, #40	; 0x28
 8023f2a:	f10d 0025 	add.w	r0, sp, #37	; 0x25
  msg.type        = TERM_STDOUT;
 8023f2e:	f88d 3020 	strb.w	r3, [sp, #32]
  memcpy(msg.term.data,LastTermBuffer,LastTermLen);
 8023f32:	f003 faf9 	bl	8027528 <memcpy>
  SendMsgToHost(&msg);
 8023f36:	a808      	add	r0, sp, #32
 8023f38:	f7fd fc8e 	bl	8021858 <SendMsgToHost>
  return BLE_STATUS_SUCCESS;
 8023f3c:	e6b5      	b.n	8023caa <HCI_Event_CB+0x72>
 8023f3e:	bf00      	nop
 8023f40:	20014538 	.word	0x20014538
 8023f44:	20000d84 	.word	0x20000d84
 8023f48:	2000b520 	.word	0x2000b520
 8023f4c:	20000db8 	.word	0x20000db8
 8023f50:	2000b530 	.word	0x2000b530
 8023f54:	20000d8a 	.word	0x20000d8a
 8023f58:	08044124 	.word	0x08044124
 8023f5c:	2000b51c 	.word	0x2000b51c
 8023f60:	08043e14 	.word	0x08043e14
 8023f64:	08043e98 	.word	0x08043e98
 8023f68:	08043e28 	.word	0x08043e28
      switch(HarAlgo) {
 8023f6c:	4ca4      	ldr	r4, [pc, #656]	; (8024200 <HCI_Event_CB+0x5c8>)
      W2ST_ON_CONNECTION(W2ST_CONNECT_AR);
 8023f6e:	6c6a      	ldr	r2, [r5, #68]	; 0x44
      switch(HarAlgo) {
 8023f70:	7823      	ldrb	r3, [r4, #0]
      W2ST_ON_CONNECTION(W2ST_CONNECT_AR);
 8023f72:	f042 0210 	orr.w	r2, r2, #16
      switch(HarAlgo) {
 8023f76:	2b02      	cmp	r3, #2
      W2ST_ON_CONNECTION(W2ST_CONNECT_AR);
 8023f78:	646a      	str	r2, [r5, #68]	; 0x44
      switch(HarAlgo) {
 8023f7a:	d07f      	beq.n	802407c <HCI_Event_CB+0x444>
 8023f7c:	d80b      	bhi.n	8023f96 <HCI_Event_CB+0x35e>
 8023f7e:	b16b      	cbz	r3, 8023f9c <HCI_Event_CB+0x364>
          startProc(ACTIVITY_IGN,INERTIAL_ACQ_ACTIVITY_IGN_MS);
 8023f80:	2126      	movs	r1, #38	; 0x26
 8023f82:	2009      	movs	r0, #9
 8023f84:	f7fd fca6 	bl	80218d4 <startProc>
          SENSING1_PRINTF("HAR IGN started\r\n");
 8023f88:	4b9e      	ldr	r3, [pc, #632]	; (8024204 <HCI_Event_CB+0x5cc>)
 8023f8a:	781b      	ldrb	r3, [r3, #0]
 8023f8c:	2b00      	cmp	r3, #0
 8023f8e:	f43f ae62 	beq.w	8023c56 <HCI_Event_CB+0x1e>
 8023f92:	489d      	ldr	r0, [pc, #628]	; (8024208 <HCI_Event_CB+0x5d0>)
 8023f94:	e783      	b.n	8023e9e <HCI_Event_CB+0x266>
      switch(HarAlgo) {
 8023f96:	2bff      	cmp	r3, #255	; 0xff
 8023f98:	f47f ae5d 	bne.w	8023c56 <HCI_Event_CB+0x1e>
          HarAlgo = HAR_GMP_IDX;
 8023f9c:	2300      	movs	r3, #0
          startProc(ACTIVITY_GMP,INERTIAL_ACQ_ACTIVITY_GMP_MS);
 8023f9e:	2126      	movs	r1, #38	; 0x26
 8023fa0:	2008      	movs	r0, #8
          HarAlgo = HAR_GMP_IDX;
 8023fa2:	7023      	strb	r3, [r4, #0]
          startProc(ACTIVITY_GMP,INERTIAL_ACQ_ACTIVITY_GMP_MS);
 8023fa4:	f7fd fc96 	bl	80218d4 <startProc>
          SENSING1_PRINTF("HAR GMP started\r\n");
 8023fa8:	4b96      	ldr	r3, [pc, #600]	; (8024204 <HCI_Event_CB+0x5cc>)
 8023faa:	781b      	ldrb	r3, [r3, #0]
 8023fac:	2b00      	cmp	r3, #0
 8023fae:	f43f ae52 	beq.w	8023c56 <HCI_Event_CB+0x1e>
 8023fb2:	4896      	ldr	r0, [pc, #600]	; (802420c <HCI_Event_CB+0x5d4>)
 8023fb4:	e773      	b.n	8023e9e <HCI_Event_CB+0x266>
     ActivityRec_Update(HAR_get_Activity_Code(HarAlgo), HarAlgo);
 8023fb6:	4c92      	ldr	r4, [pc, #584]	; (8024200 <HCI_Event_CB+0x5c8>)
 8023fb8:	7820      	ldrb	r0, [r4, #0]
 8023fba:	f001 fd07 	bl	80259cc <HAR_get_Activity_Code>
 8023fbe:	7821      	ldrb	r1, [r4, #0]
 8023fc0:	f7ff f8a6 	bl	8023110 <ActivityRec_Update>
 8023fc4:	e671      	b.n	8023caa <HCI_Event_CB+0x72>
      if (att_data[0] == 01) {
 8023fc6:	7b23      	ldrb	r3, [r4, #12]
 8023fc8:	2b01      	cmp	r3, #1
 8023fca:	d033      	beq.n	8024034 <HCI_Event_CB+0x3fc>
      } else if (att_data[0] == 0){
 8023fcc:	2b00      	cmp	r3, #0
 8023fce:	f47f ae42 	bne.w	8023c56 <HCI_Event_CB+0x1e>
        W2ST_OFF_CONNECTION(W2ST_CONNECT_SD_CARD_LOGGING);
 8023fd2:	6c6b      	ldr	r3, [r5, #68]	; 0x44
 8023fd4:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 8023fd8:	646b      	str	r3, [r5, #68]	; 0x44
 8023fda:	e63c      	b.n	8023c56 <HCI_Event_CB+0x1e>
    AudioSRec_Update(ASC_GetClassificationCode());
 8023fdc:	f7f9 fc40 	bl	801d860 <ASC_GetClassificationCode>
 8023fe0:	f7ff f8f6 	bl	80231d0 <AudioSRec_Update>
 8023fe4:	e661      	b.n	8023caa <HCI_Event_CB+0x72>
     if (att_data[0] == 01) {
 8023fe6:	7b23      	ldrb	r3, [r4, #12]
 8023fe8:	2b01      	cmp	r3, #1
 8023fea:	f000 8081 	beq.w	80240f0 <HCI_Event_CB+0x4b8>
    } else if (att_data[0] == 0) {
 8023fee:	2b00      	cmp	r3, #0
 8023ff0:	f47f ae31 	bne.w	8023c56 <HCI_Event_CB+0x1e>
       W2ST_OFF_CONNECTION(W2ST_CONNECT_ACC_GYRO_MAG);
 8023ff4:	6c6b      	ldr	r3, [r5, #68]	; 0x44
       stopProc(MOTION);
 8023ff6:	2006      	movs	r0, #6
       W2ST_OFF_CONNECTION(W2ST_CONNECT_ACC_GYRO_MAG);
 8023ff8:	f023 0304 	bic.w	r3, r3, #4
 8023ffc:	e763      	b.n	8023ec6 <HCI_Event_CB+0x28e>
        W2ST_ON_CONNECTION(W2ST_CONNECT_CONF_EVENT);
 8023ffe:	6c6b      	ldr	r3, [r5, #68]	; 0x44
 8024000:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 8024004:	646b      	str	r3, [r5, #68]	; 0x44
 8024006:	e626      	b.n	8023c56 <HCI_Event_CB+0x1e>
      W2ST_ON_CONNECTION(W2ST_CONNECT_ASC_EVENT);
 8024008:	6c6b      	ldr	r3, [r5, #68]	; 0x44
 802400a:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
      startProc(AUDIO_SC, 0 /* Not Used for Audio */);
 802400e:	2100      	movs	r1, #0
 8024010:	2007      	movs	r0, #7
      W2ST_ON_CONNECTION(W2ST_CONNECT_ASC_EVENT);
 8024012:	646b      	str	r3, [r5, #68]	; 0x44
}
 8024014:	b013      	add	sp, #76	; 0x4c
 8024016:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
      startProc(AUDIO_LEV,MICS_DB_UPDATE_MS);
 802401a:	f7fd bc5b 	b.w	80218d4 <startProc>
    if (att_data[0] == 01) {
 802401e:	7b23      	ldrb	r3, [r4, #12]
 8024020:	2b01      	cmp	r3, #1
 8024022:	d071      	beq.n	8024108 <HCI_Event_CB+0x4d0>
    } else if (att_data[0] == 0){
 8024024:	2b00      	cmp	r3, #0
 8024026:	f47f ae16 	bne.w	8023c56 <HCI_Event_CB+0x1e>
      W2ST_OFF_CONNECTION(W2ST_CONNECT_ENV);
 802402a:	6c6b      	ldr	r3, [r5, #68]	; 0x44
      stopProc(ENV);
 802402c:	2005      	movs	r0, #5
      W2ST_OFF_CONNECTION(W2ST_CONNECT_ENV);
 802402e:	f023 0301 	bic.w	r3, r3, #1
 8024032:	e748      	b.n	8023ec6 <HCI_Event_CB+0x28e>
        W2ST_ON_CONNECTION(W2ST_CONNECT_SD_CARD_LOGGING);
 8024034:	6c6b      	ldr	r3, [r5, #68]	; 0x44
 8024036:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
 802403a:	646b      	str	r3, [r5, #68]	; 0x44
 802403c:	e60b      	b.n	8023c56 <HCI_Event_CB+0x1e>
          stopProc(ACTIVITY_IGN_WSDM);
 802403e:	200a      	movs	r0, #10
 8024040:	f7fd fe0a 	bl	8021c58 <stopProc>
          SENSING1_PRINTF("HAR IGN_WSDM halted\r\n");
 8024044:	4b6f      	ldr	r3, [pc, #444]	; (8024204 <HCI_Event_CB+0x5cc>)
 8024046:	781b      	ldrb	r3, [r3, #0]
 8024048:	2b00      	cmp	r3, #0
 802404a:	f43f ae04 	beq.w	8023c56 <HCI_Event_CB+0x1e>
 802404e:	4870      	ldr	r0, [pc, #448]	; (8024210 <HCI_Event_CB+0x5d8>)
 8024050:	e725      	b.n	8023e9e <HCI_Event_CB+0x266>
    if (att_data[0] == 01) {
 8024052:	7b23      	ldrb	r3, [r4, #12]
 8024054:	2b01      	cmp	r3, #1
 8024056:	d052      	beq.n	80240fe <HCI_Event_CB+0x4c6>
    } else if (att_data[0] == 0){
 8024058:	2b00      	cmp	r3, #0
 802405a:	f47f adfc 	bne.w	8023c56 <HCI_Event_CB+0x1e>
      W2ST_OFF_CONNECTION(W2ST_CONNECT_STD_ERR);
 802405e:	6c6b      	ldr	r3, [r5, #68]	; 0x44
 8024060:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 8024064:	646b      	str	r3, [r5, #68]	; 0x44
 8024066:	e5f6      	b.n	8023c56 <HCI_Event_CB+0x1e>
          stopProc(ACTIVITY_IGN);
 8024068:	2009      	movs	r0, #9
 802406a:	f7fd fdf5 	bl	8021c58 <stopProc>
          SENSING1_PRINTF("HAR IGN halted\r\n");
 802406e:	4b65      	ldr	r3, [pc, #404]	; (8024204 <HCI_Event_CB+0x5cc>)
 8024070:	781b      	ldrb	r3, [r3, #0]
 8024072:	2b00      	cmp	r3, #0
 8024074:	f43f adef 	beq.w	8023c56 <HCI_Event_CB+0x1e>
 8024078:	4866      	ldr	r0, [pc, #408]	; (8024214 <HCI_Event_CB+0x5dc>)
 802407a:	e710      	b.n	8023e9e <HCI_Event_CB+0x266>
          startProc(ACTIVITY_IGN_WSDM,INERTIAL_ACQ_ACTIVITY_IGN_WSDM_MS);
 802407c:	2132      	movs	r1, #50	; 0x32
 802407e:	200a      	movs	r0, #10
 8024080:	f7fd fc28 	bl	80218d4 <startProc>
          SENSING1_PRINTF("HAR IGN_WSDM started\r\n");
 8024084:	4b5f      	ldr	r3, [pc, #380]	; (8024204 <HCI_Event_CB+0x5cc>)
 8024086:	781b      	ldrb	r3, [r3, #0]
 8024088:	2b00      	cmp	r3, #0
 802408a:	f43f ade4 	beq.w	8023c56 <HCI_Event_CB+0x1e>
 802408e:	4862      	ldr	r0, [pc, #392]	; (8024218 <HCI_Event_CB+0x5e0>)
 8024090:	e705      	b.n	8023e9e <HCI_Event_CB+0x266>
    if (att_data[0] == 01) {
 8024092:	7b23      	ldrb	r3, [r4, #12]
 8024094:	2b01      	cmp	r3, #1
 8024096:	d03f      	beq.n	8024118 <HCI_Event_CB+0x4e0>
    } else if (att_data[0] == 0){
 8024098:	2b00      	cmp	r3, #0
 802409a:	f47f addc 	bne.w	8023c56 <HCI_Event_CB+0x1e>
      W2ST_OFF_CONNECTION(W2ST_CONNECT_STD_TERM);
 802409e:	6c6b      	ldr	r3, [r5, #68]	; 0x44
 80240a0:	f023 0320 	bic.w	r3, r3, #32
 80240a4:	646b      	str	r3, [r5, #68]	; 0x44
 80240a6:	e5d6      	b.n	8023c56 <HCI_Event_CB+0x1e>
    if(SizeOfUpdateBlueFW!=0) {
 80240a8:	6d6b      	ldr	r3, [r5, #84]	; 0x54
 80240aa:	2b00      	cmp	r3, #0
 80240ac:	d048      	beq.n	8024140 <HCI_Event_CB+0x508>
      int8_t RetValue = UpdateFWBlueMS(&SizeOfUpdateBlueFW,att_data, data_length,1);
 80240ae:	485b      	ldr	r0, [pc, #364]	; (802421c <HCI_Event_CB+0x5e4>)
 80240b0:	2301      	movs	r3, #1
 80240b2:	4632      	mov	r2, r6
 80240b4:	4651      	mov	r1, sl
 80240b6:	f7fa ff3b 	bl	801ef30 <UpdateFWBlueMS>
 80240ba:	f88d 0020 	strb.w	r0, [sp, #32]
      if(RetValue!=0) {
 80240be:	2800      	cmp	r0, #0
 80240c0:	f43f adc9 	beq.w	8023c56 <HCI_Event_CB+0x1e>
        MCR_FAST_TERM_UPDATE_FOR_OTA(((uint8_t *)&RetValue));
 80240c4:	ab08      	add	r3, sp, #32
 80240c6:	8969      	ldrh	r1, [r5, #10]
 80240c8:	8928      	ldrh	r0, [r5, #8]
 80240ca:	9300      	str	r3, [sp, #0]
 80240cc:	2200      	movs	r2, #0
 80240ce:	2301      	movs	r3, #1
 80240d0:	f7f7 fbce 	bl	801b870 <aci_gatt_update_char_value>
        if(RetValue==1) {
 80240d4:	f99d 3020 	ldrsb.w	r3, [sp, #32]
 80240d8:	2b01      	cmp	r3, #1
 80240da:	f47f adbc 	bne.w	8023c56 <HCI_Event_CB+0x1e>
          SENSING1_PRINTF("%s will restart\r\n",SENSING1_PACKAGENAME);
 80240de:	4b49      	ldr	r3, [pc, #292]	; (8024204 <HCI_Event_CB+0x5cc>)
 80240e0:	781b      	ldrb	r3, [r3, #0]
 80240e2:	2b00      	cmp	r3, #0
 80240e4:	f040 83c5 	bne.w	8024872 <HCI_Event_CB+0xc3a>
          RebootBoard = 1;
 80240e8:	4b4d      	ldr	r3, [pc, #308]	; (8024220 <HCI_Event_CB+0x5e8>)
 80240ea:	2201      	movs	r2, #1
 80240ec:	601a      	str	r2, [r3, #0]
    if(SendBackData) {
 80240ee:	e5b2      	b.n	8023c56 <HCI_Event_CB+0x1e>
       W2ST_ON_CONNECTION(W2ST_CONNECT_ACC_GYRO_MAG);
 80240f0:	6c6b      	ldr	r3, [r5, #68]	; 0x44
 80240f2:	f043 0304 	orr.w	r3, r3, #4
       startProc(MOTION, INERTIAL_UPDATE_MS );
 80240f6:	2132      	movs	r1, #50	; 0x32
 80240f8:	2006      	movs	r0, #6
       W2ST_ON_CONNECTION(W2ST_CONNECT_ACC_GYRO_MAG);
 80240fa:	646b      	str	r3, [r5, #68]	; 0x44
       startProc(MOTION, INERTIAL_UPDATE_MS );
 80240fc:	e78a      	b.n	8024014 <HCI_Event_CB+0x3dc>
      W2ST_ON_CONNECTION(W2ST_CONNECT_STD_ERR);
 80240fe:	6c6b      	ldr	r3, [r5, #68]	; 0x44
 8024100:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8024104:	646b      	str	r3, [r5, #68]	; 0x44
 8024106:	e5a6      	b.n	8023c56 <HCI_Event_CB+0x1e>
      W2ST_ON_CONNECTION(W2ST_CONNECT_ENV);
 8024108:	6c6b      	ldr	r3, [r5, #68]	; 0x44
 802410a:	f043 0301 	orr.w	r3, r3, #1
      startProc(ENV,ENV_UPDATE_MS);
 802410e:	f44f 71fa 	mov.w	r1, #500	; 0x1f4
 8024112:	2005      	movs	r0, #5
      W2ST_ON_CONNECTION(W2ST_CONNECT_ENV);
 8024114:	646b      	str	r3, [r5, #68]	; 0x44
      startProc(ENV,ENV_UPDATE_MS);
 8024116:	e77d      	b.n	8024014 <HCI_Event_CB+0x3dc>
      W2ST_ON_CONNECTION(W2ST_CONNECT_STD_TERM);
 8024118:	6c6b      	ldr	r3, [r5, #68]	; 0x44
 802411a:	f043 0320 	orr.w	r3, r3, #32
 802411e:	646b      	str	r3, [r5, #68]	; 0x44
 8024120:	e599      	b.n	8023c56 <HCI_Event_CB+0x1e>
    if (att_data[0] == 01) {
 8024122:	7b23      	ldrb	r3, [r4, #12]
 8024124:	2b01      	cmp	r3, #1
 8024126:	f000 80ce 	beq.w	80242c6 <HCI_Event_CB+0x68e>
    } else if (att_data[0] == 0) {
 802412a:	2b00      	cmp	r3, #0
 802412c:	f47f ad93 	bne.w	8023c56 <HCI_Event_CB+0x1e>
      W2ST_OFF_CONNECTION(W2ST_CONNECT_AUDIO_LEVEL);
 8024130:	6c6b      	ldr	r3, [r5, #68]	; 0x44
 8024132:	f023 0308 	bic.w	r3, r3, #8
 8024136:	646b      	str	r3, [r5, #68]	; 0x44
      DeInitMics();
 8024138:	f7fb fa06 	bl	801f548 <DeInitMics>
      stopProc(AUDIO_LEV);
 802413c:	200c      	movs	r0, #12
 802413e:	e5e5      	b.n	8023d0c <HCI_Event_CB+0xd4>
  if (!strncmp("upgradeFw", (char *)att_data, 9))
 8024140:	4838      	ldr	r0, [pc, #224]	; (8024224 <HCI_Event_CB+0x5ec>)
 8024142:	2209      	movs	r2, #9
 8024144:	4651      	mov	r1, sl
 8024146:	f004 f880 	bl	802824a <strncmp>
 802414a:	2800      	cmp	r0, #0
 802414c:	f000 80d5 	beq.w	80242fa <HCI_Event_CB+0x6c2>
  else if (!strncmp("setName ", (char *)att_data, 8))
 8024150:	4835      	ldr	r0, [pc, #212]	; (8024228 <HCI_Event_CB+0x5f0>)
 8024152:	2208      	movs	r2, #8
 8024154:	4651      	mov	r1, sl
 8024156:	f004 f878 	bl	802824a <strncmp>
 802415a:	2800      	cmp	r0, #0
 802415c:	d041      	beq.n	80241e2 <HCI_Event_CB+0x5aa>
  else if (!strncmp("setDate", (char *)(att_data), 7))
 802415e:	4833      	ldr	r0, [pc, #204]	; (802422c <HCI_Event_CB+0x5f4>)
 8024160:	2207      	movs	r2, #7
 8024162:	4651      	mov	r1, sl
 8024164:	f004 f871 	bl	802824a <strncmp>
 8024168:	2800      	cmp	r0, #0
 802416a:	f000 8323 	beq.w	80247b4 <HCI_Event_CB+0xb7c>
  else if (!strncmp("setTime", (char *)(att_data), 7))
 802416e:	4830      	ldr	r0, [pc, #192]	; (8024230 <HCI_Event_CB+0x5f8>)
 8024170:	2207      	movs	r2, #7
 8024172:	4651      	mov	r1, sl
 8024174:	f004 f869 	bl	802824a <strncmp>
 8024178:	2800      	cmp	r0, #0
 802417a:	f040 82cd 	bne.w	8024718 <HCI_Event_CB+0xae0>
    if (NameLength == 16)
 802417e:	2e11      	cmp	r6, #17
 8024180:	f000 824d 	beq.w	802461e <HCI_Event_CB+0x9e6>
  if (att_data[data_length - 1] == '\n') {
 8024184:	3e01      	subs	r6, #1
  Term_Update((uint8_t *)"\r\n", 2);
 8024186:	482b      	ldr	r0, [pc, #172]	; (8024234 <HCI_Event_CB+0x5fc>)
  if (att_data[data_length - 1] == '\n') {
 8024188:	f81a 3006 	ldrb.w	r3, [sl, r6]
    xMoreDataToFollow = FreeRTOS_CLIProcessCommand(
 802418c:	4c2a      	ldr	r4, [pc, #168]	; (8024238 <HCI_Event_CB+0x600>)
  if (att_data[data_length - 1] == '\n') {
 802418e:	2b0a      	cmp	r3, #10
    att_data[data_length - 1] = '\0';
 8024190:	bf04      	itt	eq
 8024192:	2300      	moveq	r3, #0
 8024194:	f80a 3006 	strbeq.w	r3, [sl, r6]
  Term_Update((uint8_t *)"\r\n", 2);
 8024198:	2102      	movs	r1, #2
 802419a:	f7fe ff89 	bl	80230b0 <Term_Update>
    xMoreDataToFollow = FreeRTOS_CLIProcessCommand(
 802419e:	4621      	mov	r1, r4
 80241a0:	f44f 7280 	mov.w	r2, #256	; 0x100
 80241a4:	4650      	mov	r0, sl
 80241a6:	f7fa fdd9 	bl	801ed5c <FreeRTOS_CLIProcessCommand>
 80241aa:	4605      	mov	r5, r0
    Term_Update(BufferToWrite, strlen((char *)BufferToWrite));
 80241ac:	4620      	mov	r0, r4
 80241ae:	f7e6 f960 	bl	800a472 <strlen>
 80241b2:	b2c1      	uxtb	r1, r0
 80241b4:	4620      	mov	r0, r4
 80241b6:	f7fe ff7b 	bl	80230b0 <Term_Update>
  } while (xMoreDataToFollow != 0);
 80241ba:	2d00      	cmp	r5, #0
 80241bc:	d1ef      	bne.n	802419e <HCI_Event_CB+0x566>
 80241be:	e54a      	b.n	8023c56 <HCI_Event_CB+0x1e>
    switch(att_data[0]) {
 80241c0:	7b21      	ldrb	r1, [r4, #12]
 80241c2:	2901      	cmp	r1, #1
 80241c4:	f000 817a 	beq.w	80244bc <HCI_Event_CB+0x884>
 80241c8:	2904      	cmp	r1, #4
 80241ca:	f000 813c 	beq.w	8024446 <HCI_Event_CB+0x80e>
 80241ce:	2900      	cmp	r1, #0
 80241d0:	f000 810c 	beq.w	80243ec <HCI_Event_CB+0x7b4>
        SENSING1_PRINTF("SD Log Feature Error First Byte=%d\n",att_data[0]);
 80241d4:	4b0b      	ldr	r3, [pc, #44]	; (8024204 <HCI_Event_CB+0x5cc>)
 80241d6:	781b      	ldrb	r3, [r3, #0]
 80241d8:	2b00      	cmp	r3, #0
 80241da:	f43f ad3c 	beq.w	8023c56 <HCI_Event_CB+0x1e>
 80241de:	4817      	ldr	r0, [pc, #92]	; (802423c <HCI_Event_CB+0x604>)
 80241e0:	e616      	b.n	8023e10 <HCI_Event_CB+0x1d8>
    int32_t NameLength = data_length - 1;
 80241e2:	1e73      	subs	r3, r6, #1
    if (NameLength > 8)
 80241e4:	2b08      	cmp	r3, #8
 80241e6:	f340 826c 	ble.w	80246c2 <HCI_Event_CB+0xa8a>
      if ((NameLength - 8) > 7)
 80241ea:	2b0f      	cmp	r3, #15
 80241ec:	f300 8253 	bgt.w	8024696 <HCI_Event_CB+0xa5e>
        NameLength = NameLength - 8;
 80241f0:	f8df b050 	ldr.w	fp, [pc, #80]	; 8024244 <HCI_Event_CB+0x60c>
 80241f4:	3e09      	subs	r6, #9
      for (i = 1; i < NameLength + 1; i++)
 80241f6:	4812      	ldr	r0, [pc, #72]	; (8024240 <HCI_Event_CB+0x608>)
 80241f8:	2301      	movs	r3, #1
        NodeName[i] = att_data[i + 7];
 80241fa:	3413      	adds	r4, #19
      for (i = 1; i < NameLength + 1; i++)
 80241fc:	e027      	b.n	802424e <HCI_Event_CB+0x616>
 80241fe:	bf00      	nop
 8024200:	20000d8a 	.word	0x20000d8a
 8024204:	20000d84 	.word	0x20000d84
 8024208:	08043e6c 	.word	0x08043e6c
 802420c:	08043e58 	.word	0x08043e58
 8024210:	08043eb8 	.word	0x08043eb8
 8024214:	08043ea8 	.word	0x08043ea8
 8024218:	08043e80 	.word	0x08043e80
 802421c:	2001458c 	.word	0x2001458c
 8024220:	200133d4 	.word	0x200133d4
 8024224:	08043ee4 	.word	0x08043ee4
 8024228:	08043f64 	.word	0x08043f64
 802422c:	08043fac 	.word	0x08043fac
 8024230:	08044000 	.word	0x08044000
 8024234:	080430dc 	.word	0x080430dc
 8024238:	200133dc 	.word	0x200133dc
 802423c:	080440ac 	.word	0x080440ac
 8024240:	200134e0 	.word	0x200134e0
 8024244:	200134dc 	.word	0x200134dc
        NodeName[i] = att_data[i + 7];
 8024248:	5ce2      	ldrb	r2, [r4, r3]
 802424a:	54c2      	strb	r2, [r0, r3]
      for (i = 1; i < NameLength + 1; i++)
 802424c:	3301      	adds	r3, #1
 802424e:	42b3      	cmp	r3, r6
 8024250:	ddfa      	ble.n	8024248 <HCI_Event_CB+0x610>
 8024252:	ea26 73e6 	bic.w	r3, r6, r6, asr #31
        NodeName[i] = ' ';
 8024256:	f1c3 0207 	rsb	r2, r3, #7
 802425a:	2e07      	cmp	r6, #7
 802425c:	f103 0301 	add.w	r3, r3, #1
 8024260:	bfc8      	it	gt
 8024262:	2200      	movgt	r2, #0
 8024264:	4418      	add	r0, r3
 8024266:	2120      	movs	r1, #32
 8024268:	f003 f986 	bl	8027578 <memset>
      MDM_SaveGMD(GMD_NODE_NAME, (void *)&NodeName);
 802426c:	4981      	ldr	r1, [pc, #516]	; (8024474 <HCI_Event_CB+0x83c>)
 802426e:	2008      	movs	r0, #8
 8024270:	f7f6 ffb6 	bl	801b1e0 <MDM_SaveGMD>
      NecessityToSaveMetaDataManager = 1;
 8024274:	4b80      	ldr	r3, [pc, #512]	; (8024478 <HCI_Event_CB+0x840>)
      BytesToWrite = sprintf((char *)BufferToWrite, "New NodeName= %s\n", NodeName);
 8024276:	4981      	ldr	r1, [pc, #516]	; (802447c <HCI_Event_CB+0x844>)
 8024278:	4a7e      	ldr	r2, [pc, #504]	; (8024474 <HCI_Event_CB+0x83c>)
 802427a:	4881      	ldr	r0, [pc, #516]	; (8024480 <HCI_Event_CB+0x848>)
      NecessityToSaveMetaDataManager = 1;
 802427c:	2401      	movs	r4, #1
 802427e:	601c      	str	r4, [r3, #0]
      BytesToWrite = sprintf((char *)BufferToWrite, "New NodeName= %s\n", NodeName);
 8024280:	f003 ff80 	bl	8028184 <siprintf>
 8024284:	4603      	mov	r3, r0
      Term_Update(BufferToWrite, BytesToWrite);
 8024286:	487e      	ldr	r0, [pc, #504]	; (8024480 <HCI_Event_CB+0x848>)
      BytesToWrite = sprintf((char *)BufferToWrite, "New NodeName= %s\n", NodeName);
 8024288:	f8cb 3000 	str.w	r3, [fp]
      Term_Update(BufferToWrite, BytesToWrite);
 802428c:	b2d9      	uxtb	r1, r3
}
 802428e:	b013      	add	sp, #76	; 0x4c
 8024290:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
          Term_Update(BufferToWrite,BytesToWrite);
 8024294:	f7fe bf0c 	b.w	80230b0 <Term_Update>
      BytesToWrite =sprintf((char *)BufferToWrite, "Notification UNKNOWN handle\n");
 8024298:	4c7a      	ldr	r4, [pc, #488]	; (8024484 <HCI_Event_CB+0x84c>)
 802429a:	4d79      	ldr	r5, [pc, #484]	; (8024480 <HCI_Event_CB+0x848>)
 802429c:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 802429e:	6028      	str	r0, [r5, #0]
 80242a0:	6069      	str	r1, [r5, #4]
 80242a2:	60aa      	str	r2, [r5, #8]
 80242a4:	cc07      	ldmia	r4!, {r0, r1, r2}
 80242a6:	6128      	str	r0, [r5, #16]
 80242a8:	4877      	ldr	r0, [pc, #476]	; (8024488 <HCI_Event_CB+0x850>)
 80242aa:	7824      	ldrb	r4, [r4, #0]
 80242ac:	60eb      	str	r3, [r5, #12]
 80242ae:	231c      	movs	r3, #28
 80242b0:	6003      	str	r3, [r0, #0]
 80242b2:	6169      	str	r1, [r5, #20]
      Stderr_Update(BufferToWrite,BytesToWrite);
 80242b4:	4628      	mov	r0, r5
 80242b6:	4619      	mov	r1, r3
      BytesToWrite =sprintf((char *)BufferToWrite, "Notification UNKNOWN handle\n");
 80242b8:	61aa      	str	r2, [r5, #24]
 80242ba:	772c      	strb	r4, [r5, #28]
}
 80242bc:	b013      	add	sp, #76	; 0x4c
 80242be:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
      Stderr_Update(BufferToWrite,BytesToWrite);
 80242c2:	f7fe bec5 	b.w	8023050 <Stderr_Update>
      W2ST_ON_CONNECTION(W2ST_CONNECT_AUDIO_LEVEL);
 80242c6:	6c6b      	ldr	r3, [r5, #68]	; 0x44
      InitMics(AUDIO_SAMPLING_FREQUENCY);
 80242c8:	f44f 507a 	mov.w	r0, #16000	; 0x3e80
      W2ST_ON_CONNECTION(W2ST_CONNECT_AUDIO_LEVEL);
 80242cc:	f043 0308 	orr.w	r3, r3, #8
 80242d0:	646b      	str	r3, [r5, #68]	; 0x44
      InitMics(AUDIO_SAMPLING_FREQUENCY);
 80242d2:	f7fb f905 	bl	801f4e0 <InitMics>
      for(Count=0;Count<TargetBoardFeatures.NumMicSensors;Count++) {
 80242d6:	4b6d      	ldr	r3, [pc, #436]	; (802448c <HCI_Event_CB+0x854>)
 80242d8:	496d      	ldr	r1, [pc, #436]	; (8024490 <HCI_Event_CB+0x858>)
 80242da:	6b5c      	ldr	r4, [r3, #52]	; 0x34
        RMS_Ch[Count]=0;
 80242dc:	486d      	ldr	r0, [pc, #436]	; (8024494 <HCI_Event_CB+0x85c>)
 80242de:	2200      	movs	r2, #0
      for(Count=0;Count<TargetBoardFeatures.NumMicSensors;Count++) {
 80242e0:	2300      	movs	r3, #0
 80242e2:	e005      	b.n	80242f0 <HCI_Event_CB+0x6b8>
        RMS_Ch[Count]=0;
 80242e4:	eb00 0583 	add.w	r5, r0, r3, lsl #2
      for(Count=0;Count<TargetBoardFeatures.NumMicSensors;Count++) {
 80242e8:	3301      	adds	r3, #1
        RMS_Ch[Count]=0;
 80242ea:	602a      	str	r2, [r5, #0]
        DBNOISE_Value_Old_Ch[Count] =0;
 80242ec:	f841 2b04 	str.w	r2, [r1], #4
      for(Count=0;Count<TargetBoardFeatures.NumMicSensors;Count++) {
 80242f0:	42a3      	cmp	r3, r4
 80242f2:	dbf7      	blt.n	80242e4 <HCI_Event_CB+0x6ac>
      startProc(AUDIO_LEV,MICS_DB_UPDATE_MS);
 80242f4:	2132      	movs	r1, #50	; 0x32
 80242f6:	200c      	movs	r0, #12
 80242f8:	e68c      	b.n	8024014 <HCI_Event_CB+0x3dc>
    SizeOfUpdateBlueFW = atoi((char *)(att_data + 9));
 80242fa:	f104 0015 	add.w	r0, r4, #21
 80242fe:	f002 fef6 	bl	80270ee <atoi>
    PointerByte[1] = att_data[10];
 8024302:	7da3      	ldrb	r3, [r4, #22]
    PointerByte[2] = att_data[11];
 8024304:	7de2      	ldrb	r2, [r4, #23]
    PointerByte[1] = att_data[10];
 8024306:	f885 3055 	strb.w	r3, [r5, #85]	; 0x55
    PointerByte[0] = att_data[9];
 802430a:	7d61      	ldrb	r1, [r4, #21]
    PointerByte[3] = att_data[12];
 802430c:	7e23      	ldrb	r3, [r4, #24]
 802430e:	f885 3057 	strb.w	r3, [r5, #87]	; 0x57
    PointerByte[0] = att_data[9];
 8024312:	f885 1054 	strb.w	r1, [r5, #84]	; 0x54
    PointerByte[2] = att_data[11];
 8024316:	f885 2056 	strb.w	r2, [r5, #86]	; 0x56
    if (SizeOfUpdateBlueFW > OTA_MAX_PROG_SIZE)
 802431a:	6d6a      	ldr	r2, [r5, #84]	; 0x54
 802431c:	4b5e      	ldr	r3, [pc, #376]	; (8024498 <HCI_Event_CB+0x860>)
 802431e:	429a      	cmp	r2, r3
 8024320:	d84d      	bhi.n	80243be <HCI_Event_CB+0x786>
      SENSING1_PRINTF("OTA %s SIZE=%ld uwCRCValue=%lx\r\n",
 8024322:	4e5e      	ldr	r6, [pc, #376]	; (802449c <HCI_Event_CB+0x864>)
      PointerByte[0] = att_data[13];
 8024324:	f894 9019 	ldrb.w	r9, [r4, #25]
      SENSING1_PRINTF("OTA %s SIZE=%ld uwCRCValue=%lx\r\n",
 8024328:	7833      	ldrb	r3, [r6, #0]
      PointerByte[1] = att_data[14];
 802432a:	f894 801a 	ldrb.w	r8, [r4, #26]
      PointerByte[2] = att_data[15];
 802432e:	7ee7      	ldrb	r7, [r4, #27]
      PointerByte[3] = att_data[16];
 8024330:	7f24      	ldrb	r4, [r4, #28]
      PointerByte[0] = att_data[13];
 8024332:	f88d 9020 	strb.w	r9, [sp, #32]
      PointerByte[1] = att_data[14];
 8024336:	f88d 8021 	strb.w	r8, [sp, #33]	; 0x21
      PointerByte[2] = att_data[15];
 802433a:	f88d 7022 	strb.w	r7, [sp, #34]	; 0x22
      PointerByte[3] = att_data[16];
 802433e:	f88d 4023 	strb.w	r4, [sp, #35]	; 0x23
      SENSING1_PRINTF("OTA %s SIZE=%ld uwCRCValue=%lx\r\n",
 8024342:	2b00      	cmp	r3, #0
 8024344:	f040 8165 	bne.w	8024612 <HCI_Event_CB+0x9da>
      StartUpdateFWBlueMS(SizeOfUpdateBlueFW, uwCRCValue);
 8024348:	9908      	ldr	r1, [sp, #32]
 802434a:	6d68      	ldr	r0, [r5, #84]	; 0x54
 802434c:	f7fa ff1c 	bl	801f188 <StartUpdateFWBlueMS>
           int ret = aci_l2cap_connection_parameter_update_request(
 8024350:	f44f 73c8 	mov.w	r3, #400	; 0x190
 8024354:	220a      	movs	r2, #10
 8024356:	f8b5 0058 	ldrh.w	r0, [r5, #88]	; 0x58
 802435a:	9300      	str	r3, [sp, #0]
 802435c:	4611      	mov	r1, r2
 802435e:	2300      	movs	r3, #0
 8024360:	f7f7 fb2a 	bl	801b9b8 <aci_l2cap_connection_parameter_update_request>
          if (ret != BLE_STATUS_SUCCESS) {
 8024364:	2800      	cmp	r0, #0
 8024366:	f000 8149 	beq.w	80245fc <HCI_Event_CB+0x9c4>
              SENSING1_PRINTF("Problem Changing the connection interval\r\n");
 802436a:	4c4d      	ldr	r4, [pc, #308]	; (80244a0 <HCI_Event_CB+0x868>)
 802436c:	7833      	ldrb	r3, [r6, #0]
 802436e:	b903      	cbnz	r3, 8024372 <HCI_Event_CB+0x73a>
 8024370:	e7fe      	b.n	8024370 <HCI_Event_CB+0x738>
 8024372:	4620      	mov	r0, r4
 8024374:	f003 feee 	bl	8028154 <puts>
 8024378:	e7f8      	b.n	802436c <HCI_Event_CB+0x734>
    STORE_LE_16(buff+2,0xFFFF);
 802437a:	21ff      	movs	r1, #255	; 0xff
    ret = aci_gatt_update_char_value(0x0001,0x0002,0,4,buff);
 802437c:	ab08      	add	r3, sp, #32
    STORE_LE_16(buff  ,0x0001);
 802437e:	2001      	movs	r0, #1
 8024380:	2200      	movs	r2, #0
    ret = aci_gatt_update_char_value(0x0001,0x0002,0,4,buff);
 8024382:	9300      	str	r3, [sp, #0]
    STORE_LE_16(buff+2,0xFFFF);
 8024384:	f88d 1022 	strb.w	r1, [sp, #34]	; 0x22
    ret = aci_gatt_update_char_value(0x0001,0x0002,0,4,buff);
 8024388:	463b      	mov	r3, r7
    STORE_LE_16(buff+2,0xFFFF);
 802438a:	f88d 1023 	strb.w	r1, [sp, #35]	; 0x23
    ret = aci_gatt_update_char_value(0x0001,0x0002,0,4,buff);
 802438e:	2102      	movs	r1, #2
    STORE_LE_16(buff  ,0x0001);
 8024390:	f88d 0020 	strb.w	r0, [sp, #32]
 8024394:	f88d 2021 	strb.w	r2, [sp, #33]	; 0x21
    ret = aci_gatt_update_char_value(0x0001,0x0002,0,4,buff);
 8024398:	f7f7 fa6a 	bl	801b870 <aci_gatt_update_char_value>
      SENSING1_PRINTF("UUID Rescan Forced\r\n");
 802439c:	4b3f      	ldr	r3, [pc, #252]	; (802449c <HCI_Event_CB+0x864>)
 802439e:	781b      	ldrb	r3, [r3, #0]
    if (ret == BLE_STATUS_SUCCESS){
 80243a0:	b930      	cbnz	r0, 80243b0 <HCI_Event_CB+0x778>
      SENSING1_PRINTF("UUID Rescan Forced\r\n");
 80243a2:	2b00      	cmp	r3, #0
 80243a4:	f43f ac57 	beq.w	8023c56 <HCI_Event_CB+0x1e>
 80243a8:	483e      	ldr	r0, [pc, #248]	; (80244a4 <HCI_Event_CB+0x86c>)
 80243aa:	f003 fed3 	bl	8028154 <puts>
 80243ae:	e452      	b.n	8023c56 <HCI_Event_CB+0x1e>
      SENSING1_PRINTF("Problem forcing UUID Rescan\r\n");
 80243b0:	2b00      	cmp	r3, #0
 80243b2:	f43f ac50 	beq.w	8023c56 <HCI_Event_CB+0x1e>
 80243b6:	483c      	ldr	r0, [pc, #240]	; (80244a8 <HCI_Event_CB+0x870>)
 80243b8:	f003 fecc 	bl	8028154 <puts>
 80243bc:	e44b      	b.n	8023c56 <HCI_Event_CB+0x1e>
      SENSING1_PRINTF("OTA %s SIZE=%ld > %d Max Allowed\r\n",
 80243be:	4937      	ldr	r1, [pc, #220]	; (802449c <HCI_Event_CB+0x864>)
 80243c0:	7809      	ldrb	r1, [r1, #0]
 80243c2:	bb41      	cbnz	r1, 8024416 <HCI_Event_CB+0x7de>
      PointerByte[1] = (att_data[14] != 0) ? 0 : 1; /* In order to be sure to have a wrong CRC */
 80243c4:	7ea3      	ldrb	r3, [r4, #26]
      BytesToWrite = 4;
 80243c6:	4a30      	ldr	r2, [pc, #192]	; (8024488 <HCI_Event_CB+0x850>)
      PointerByte[0] = att_data[13];
 80243c8:	7e60      	ldrb	r0, [r4, #25]
 80243ca:	f885 0054 	strb.w	r0, [r5, #84]	; 0x54
      PointerByte[1] = (att_data[14] != 0) ? 0 : 1; /* In order to be sure to have a wrong CRC */
 80243ce:	fab3 f383 	clz	r3, r3
 80243d2:	095b      	lsrs	r3, r3, #5
      BytesToWrite = 4;
 80243d4:	2104      	movs	r1, #4
 80243d6:	6011      	str	r1, [r2, #0]
      PointerByte[1] = (att_data[14] != 0) ? 0 : 1; /* In order to be sure to have a wrong CRC */
 80243d8:	f885 3055 	strb.w	r3, [r5, #85]	; 0x55
      PointerByte[2] = att_data[15];
 80243dc:	7ee2      	ldrb	r2, [r4, #27]
      PointerByte[3] = att_data[16];
 80243de:	7f23      	ldrb	r3, [r4, #28]
      Term_Update(BufferToWrite, BytesToWrite);
 80243e0:	4827      	ldr	r0, [pc, #156]	; (8024480 <HCI_Event_CB+0x848>)
      PointerByte[2] = att_data[15];
 80243e2:	f885 2056 	strb.w	r2, [r5, #86]	; 0x56
      PointerByte[3] = att_data[16];
 80243e6:	f885 3057 	strb.w	r3, [r5, #87]	; 0x57
      Term_Update(BufferToWrite, BytesToWrite);
 80243ea:	e750      	b.n	802428e <HCI_Event_CB+0x656>
        if(SD_Card_FeaturesMask & (FEATURE_MASK_TEMP1 |
 80243ec:	4f2f      	ldr	r7, [pc, #188]	; (80244ac <HCI_Event_CB+0x874>)
 80243ee:	683b      	ldr	r3, [r7, #0]
 80243f0:	f413 0f7d 	tst.w	r3, #16580608	; 0xfd0000
 80243f4:	d121      	bne.n	802443a <HCI_Event_CB+0x802>
       } else if(SD_Card_FeaturesMask == FEATURE_MASK_BLUEVOICE) {
 80243f6:	f1b3 6f00 	cmp.w	r3, #134217728	; 0x8000000
 80243fa:	d01b      	beq.n	8024434 <HCI_Event_CB+0x7fc>
        if(SD_Card_FeaturesMask & FEATURE_MASK_BLUEVOICE) {
 80243fc:	683b      	ldr	r3, [r7, #0]
 80243fe:	011e      	lsls	r6, r3, #4
 8024400:	d40e      	bmi.n	8024420 <HCI_Event_CB+0x7e8>
        if(W2ST_CHECK_CONNECTION(W2ST_CONNECT_SD_CARD_LOGGING)) {
 8024402:	6c6b      	ldr	r3, [r5, #68]	; 0x44
 8024404:	055c      	lsls	r4, r3, #21
 8024406:	f57f ac26 	bpl.w	8023c56 <HCI_Event_CB+0x1e>
          SDLog_Update(SD_CARD_LOGGING_STOP);
 802440a:	2000      	movs	r0, #0
}
 802440c:	b013      	add	sp, #76	; 0x4c
 802440e:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
            SDLog_Update(SD_CARD_LOGGING_START);
 8024412:	f7ff bb1f 	b.w	8023a54 <SDLog_Update>
      SENSING1_PRINTF("OTA %s SIZE=%ld > %d Max Allowed\r\n",
 8024416:	4926      	ldr	r1, [pc, #152]	; (80244b0 <HCI_Event_CB+0x878>)
 8024418:	4826      	ldr	r0, [pc, #152]	; (80244b4 <HCI_Event_CB+0x87c>)
 802441a:	f003 fdff 	bl	802801c <iprintf>
 802441e:	e7d1      	b.n	80243c4 <HCI_Event_CB+0x78c>
          osDelay(100);
 8024420:	2064      	movs	r0, #100	; 0x64
 8024422:	f7f4 fa4f 	bl	80188c4 <osDelay>
          SD_Card_FeaturesMask &= ~FEATURE_MASK_BLUEVOICE;
 8024426:	683b      	ldr	r3, [r7, #0]
 8024428:	f023 6300 	bic.w	r3, r3, #134217728	; 0x8000000
 802442c:	603b      	str	r3, [r7, #0]
          SD_CardLoggingAudioStop();
 802442e:	f7f9 ff91 	bl	801e354 <SD_CardLoggingAudioStop>
 8024432:	e7e6      	b.n	8024402 <HCI_Event_CB+0x7ca>
          SD_CardLoggingMemsStop();
 8024434:	f7f9 fefc 	bl	801e230 <SD_CardLoggingMemsStop>
 8024438:	e7e0      	b.n	80243fc <HCI_Event_CB+0x7c4>
          SD_Card_FeaturesMask &= ~(FEATURE_MASK_TEMP1 |
 802443a:	f423 037d 	bic.w	r3, r3, #16580608	; 0xfd0000
 802443e:	603b      	str	r3, [r7, #0]
          SD_CardLoggingMemsStop();
 8024440:	f7f9 fef6 	bl	801e230 <SD_CardLoggingMemsStop>
 8024444:	e7da      	b.n	80243fc <HCI_Event_CB+0x7c4>
        SaveDataAnnotation(att_data+1);
 8024446:	f104 020d 	add.w	r2, r4, #13
 802444a:	4610      	mov	r0, r2
 802444c:	9205      	str	r2, [sp, #20]
 802444e:	f7fa fb99 	bl	801eb84 <SaveDataAnnotation>
        if(W2ST_CHECK_CONNECTION(W2ST_CONNECT_STD_ERR)){
 8024452:	6c6b      	ldr	r3, [r5, #68]	; 0x44
 8024454:	9a05      	ldr	r2, [sp, #20]
 8024456:	f013 0f40 	tst.w	r3, #64	; 0x40
 802445a:	f43f abfc 	beq.w	8023c56 <HCI_Event_CB+0x1e>
          BytesToWrite =sprintf((char *)BufferToWrite, "Ann->[%s]\n",att_data+1);
 802445e:	4916      	ldr	r1, [pc, #88]	; (80244b8 <HCI_Event_CB+0x880>)
 8024460:	4807      	ldr	r0, [pc, #28]	; (8024480 <HCI_Event_CB+0x848>)
 8024462:	f003 fe8f 	bl	8028184 <siprintf>
 8024466:	4a08      	ldr	r2, [pc, #32]	; (8024488 <HCI_Event_CB+0x850>)
 8024468:	4603      	mov	r3, r0
          Term_Update(BufferToWrite,BytesToWrite);
 802446a:	b2d9      	uxtb	r1, r3
 802446c:	4804      	ldr	r0, [pc, #16]	; (8024480 <HCI_Event_CB+0x848>)
          BytesToWrite =sprintf((char *)BufferToWrite, "Ann->[%s]\n",att_data+1);
 802446e:	6013      	str	r3, [r2, #0]
 8024470:	e70d      	b.n	802428e <HCI_Event_CB+0x656>
 8024472:	bf00      	nop
 8024474:	200134e0 	.word	0x200134e0
 8024478:	200080e8 	.word	0x200080e8
 802447c:	08043f84 	.word	0x08043f84
 8024480:	200133dc 	.word	0x200133dc
 8024484:	08044104 	.word	0x08044104
 8024488:	200134dc 	.word	0x200134dc
 802448c:	200106a4 	.word	0x200106a4
 8024490:	20010a14 	.word	0x20010a14
 8024494:	20010a18 	.word	0x20010a18
 8024498:	0007bff0 	.word	0x0007bff0
 802449c:	20000d84 	.word	0x20000d84
 80244a0:	08043f38 	.word	0x08043f38
 80244a4:	080440d0 	.word	0x080440d0
 80244a8:	080440e4 	.word	0x080440e4
 80244ac:	2000b51c 	.word	0x2000b51c
 80244b0:	08042f18 	.word	0x08042f18
 80244b4:	08043ef0 	.word	0x08043ef0
 80244b8:	080440a0 	.word	0x080440a0
          p8_SampleRateIneFeatures[0] = att_data[7];
 80244bc:	4ba6      	ldr	r3, [pc, #664]	; (8024758 <HCI_Event_CB+0xb20>)
 80244be:	7ce2      	ldrb	r2, [r4, #19]
 80244c0:	701a      	strb	r2, [r3, #0]
          p8_SampleRateIneFeatures[1] = att_data[8];
 80244c2:	7d22      	ldrb	r2, [r4, #20]
          p8_Feature[0] = att_data[1];
 80244c4:	4fa5      	ldr	r7, [pc, #660]	; (802475c <HCI_Event_CB+0xb24>)
          p8_SampleRateIneFeatures[1] = att_data[8];
 80244c6:	705a      	strb	r2, [r3, #1]
          RoundedInertialWakeUpTimer = (int32_t) round(1000.0/(SampleRateIneFeatures/10));
 80244c8:	8818      	ldrh	r0, [r3, #0]
          p8_Feature[0] = att_data[1];
 80244ca:	7b63      	ldrb	r3, [r4, #13]
 80244cc:	703b      	strb	r3, [r7, #0]
          p8_Feature[1] = att_data[2];
 80244ce:	7ba3      	ldrb	r3, [r4, #14]
 80244d0:	707b      	strb	r3, [r7, #1]
          p8_Feature[2] = att_data[3];
 80244d2:	7be3      	ldrb	r3, [r4, #15]
 80244d4:	70bb      	strb	r3, [r7, #2]
          p8_Feature[3] = att_data[4];
 80244d6:	7c23      	ldrb	r3, [r4, #16]
 80244d8:	70fb      	strb	r3, [r7, #3]
          p8_SampleRateEnvFeatures[0] = att_data[5];
 80244da:	7c63      	ldrb	r3, [r4, #17]
 80244dc:	f88d 3020 	strb.w	r3, [sp, #32]
          p8_SampleRateEnvFeatures[1] = att_data[6];
 80244e0:	7ca3      	ldrb	r3, [r4, #18]
 80244e2:	f88d 3021 	strb.w	r3, [sp, #33]	; 0x21
          RoundedInertialWakeUpTimer = (int32_t) round(1000.0/(SampleRateIneFeatures/10));
 80244e6:	230a      	movs	r3, #10
 80244e8:	fbb0 f0f3 	udiv	r0, r0, r3
 80244ec:	f7e6 f972 	bl	800a7d4 <__aeabi_i2d>
 80244f0:	4602      	mov	r2, r0
 80244f2:	460b      	mov	r3, r1
 80244f4:	2000      	movs	r0, #0
 80244f6:	499a      	ldr	r1, [pc, #616]	; (8024760 <HCI_Event_CB+0xb28>)
            BytesToWrite =sprintf((char *)BufferToWrite,"setMicVol Correct =%ld\n",
 80244f8:	f8df b28c 	ldr.w	fp, [pc, #652]	; 8024788 <HCI_Event_CB+0xb50>
          RoundedInertialWakeUpTimer = (int32_t) round(1000.0/(SampleRateIneFeatures/10));
 80244fc:	f7e6 fafe 	bl	800aafc <__aeabi_ddiv>
 8024500:	ec41 0b10 	vmov	d0, r0, r1
 8024504:	f005 fed8 	bl	802a2b8 <round>
 8024508:	ec51 0b10 	vmov	r0, r1, d0
 802450c:	f7e6 fc7c 	bl	800ae08 <__aeabi_d2iz>
 8024510:	4b94      	ldr	r3, [pc, #592]	; (8024764 <HCI_Event_CB+0xb2c>)
 8024512:	9005      	str	r0, [sp, #20]
 8024514:	6018      	str	r0, [r3, #0]
          RoundCounterEnvironmental  = (int32_t) round((10000.0/RoundedInertialWakeUpTimer)/SampleRateEnvFeatures);
 8024516:	f7e6 f94d 	bl	800a7b4 <__aeabi_ui2d>
 802451a:	4602      	mov	r2, r0
 802451c:	460b      	mov	r3, r1
 802451e:	a18c      	add	r1, pc, #560	; (adr r1, 8024750 <HCI_Event_CB+0xb18>)
 8024520:	e9d1 0100 	ldrd	r0, r1, [r1]
 8024524:	f7e6 faea 	bl	800aafc <__aeabi_ddiv>
 8024528:	4680      	mov	r8, r0
 802452a:	f8bd 0020 	ldrh.w	r0, [sp, #32]
 802452e:	4689      	mov	r9, r1
 8024530:	f7e6 f950 	bl	800a7d4 <__aeabi_i2d>
 8024534:	4602      	mov	r2, r0
 8024536:	460b      	mov	r3, r1
 8024538:	4640      	mov	r0, r8
 802453a:	4649      	mov	r1, r9
 802453c:	f7e6 fade 	bl	800aafc <__aeabi_ddiv>
 8024540:	ec41 0b10 	vmov	d0, r0, r1
 8024544:	f005 feb8 	bl	802a2b8 <round>
 8024548:	ec51 0b10 	vmov	r0, r1, d0
 802454c:	f7e6 fc5c 	bl	800ae08 <__aeabi_d2iz>
          RoundedEnvironmentalFreq   = (int32_t) round(10000.0/(RoundCounterEnvironmental*RoundedInertialWakeUpTimer));
 8024550:	9a05      	ldr	r2, [sp, #20]
          RoundCounterEnvironmental  = (int32_t) round((10000.0/RoundedInertialWakeUpTimer)/SampleRateEnvFeatures);
 8024552:	4603      	mov	r3, r0
          RoundedEnvironmentalFreq   = (int32_t) round(10000.0/(RoundCounterEnvironmental*RoundedInertialWakeUpTimer));
 8024554:	fb00 f002 	mul.w	r0, r0, r2
          RoundCounterEnvironmental  = (int32_t) round((10000.0/RoundedInertialWakeUpTimer)/SampleRateEnvFeatures);
 8024558:	4a83      	ldr	r2, [pc, #524]	; (8024768 <HCI_Event_CB+0xb30>)
 802455a:	6013      	str	r3, [r2, #0]
          RoundedEnvironmentalFreq   = (int32_t) round(10000.0/(RoundCounterEnvironmental*RoundedInertialWakeUpTimer));
 802455c:	f7e6 f92a 	bl	800a7b4 <__aeabi_ui2d>
 8024560:	4602      	mov	r2, r0
 8024562:	460b      	mov	r3, r1
 8024564:	a17a      	add	r1, pc, #488	; (adr r1, 8024750 <HCI_Event_CB+0xb18>)
 8024566:	e9d1 0100 	ldrd	r0, r1, [r1]
 802456a:	f7e6 fac7 	bl	800aafc <__aeabi_ddiv>
 802456e:	ec41 0b10 	vmov	d0, r0, r1
 8024572:	f005 fea1 	bl	802a2b8 <round>
 8024576:	ec51 0b10 	vmov	r0, r1, d0
 802457a:	f7e6 fc45 	bl	800ae08 <__aeabi_d2iz>
 802457e:	4b7b      	ldr	r3, [pc, #492]	; (802476c <HCI_Event_CB+0xb34>)
            TargetBoardFeatures.AudioVolume = AudioVolume;
 8024580:	f994 2015 	ldrsb.w	r2, [r4, #21]
          RoundedEnvironmentalFreq   = (int32_t) round(10000.0/(RoundCounterEnvironmental*RoundedInertialWakeUpTimer));
 8024584:	6018      	str	r0, [r3, #0]
            TargetBoardFeatures.AudioVolume = AudioVolume;
 8024586:	4b7a      	ldr	r3, [pc, #488]	; (8024770 <HCI_Event_CB+0xb38>)
            BytesToWrite =sprintf((char *)BufferToWrite,"setMicVol Correct =%ld\n",
 8024588:	497a      	ldr	r1, [pc, #488]	; (8024774 <HCI_Event_CB+0xb3c>)
 802458a:	487b      	ldr	r0, [pc, #492]	; (8024778 <HCI_Event_CB+0xb40>)
            TargetBoardFeatures.AudioVolume = AudioVolume;
 802458c:	639a      	str	r2, [r3, #56]	; 0x38
            BytesToWrite =sprintf((char *)BufferToWrite,"setMicVol Correct =%ld\n",
 802458e:	f003 fdf9 	bl	8028184 <siprintf>
 8024592:	f8cb 0000 	str.w	r0, [fp]
            Term_Update(BufferToWrite,BytesToWrite);
 8024596:	b2c1      	uxtb	r1, r0
 8024598:	4877      	ldr	r0, [pc, #476]	; (8024778 <HCI_Event_CB+0xb40>)
 802459a:	f7fe fd89 	bl	80230b0 <Term_Update>
        if(data_length>10) {
 802459e:	2e0a      	cmp	r6, #10
 80245a0:	d912      	bls.n	80245c8 <HCI_Event_CB+0x990>
          for(Count=0;Count<(data_length-10);Count++) {
 80245a2:	2200      	movs	r2, #0
 80245a4:	4975      	ldr	r1, [pc, #468]	; (802477c <HCI_Event_CB+0xb44>)
 80245a6:	3e0a      	subs	r6, #10
 80245a8:	4613      	mov	r3, r2
            DefaultDataFileName[Count]=att_data[Count+9];
 80245aa:	eb0a 0003 	add.w	r0, sl, r3
          for(Count=0;Count<(data_length-10);Count++) {
 80245ae:	3301      	adds	r3, #1
 80245b0:	b2db      	uxtb	r3, r3
            DefaultDataFileName[Count]=att_data[Count+9];
 80245b2:	7a40      	ldrb	r0, [r0, #9]
 80245b4:	5488      	strb	r0, [r1, r2]
          for(Count=0;Count<(data_length-10);Count++) {
 80245b6:	42b3      	cmp	r3, r6
 80245b8:	461a      	mov	r2, r3
 80245ba:	dbf6      	blt.n	80245aa <HCI_Event_CB+0x972>
          if(W2ST_CHECK_CONNECTION(W2ST_CONNECT_STD_ERR)){
 80245bc:	6c6a      	ldr	r2, [r5, #68]	; 0x44
          DefaultDataFileName[Count] ='\0';
 80245be:	2000      	movs	r0, #0
 80245c0:	54c8      	strb	r0, [r1, r3]
          if(W2ST_CHECK_CONNECTION(W2ST_CONNECT_STD_ERR)){
 80245c2:	0650      	lsls	r0, r2, #25
 80245c4:	f100 808d 	bmi.w	80246e2 <HCI_Event_CB+0xaaa>
           ((SD_Card_FeaturesMask&FEATURE_MASK_GRYO )!=0) |
 80245c8:	683b      	ldr	r3, [r7, #0]
        if(((SD_Card_FeaturesMask&FEATURE_MASK_TEMP1 )!=0) |
 80245ca:	f413 0f7d 	tst.w	r3, #16580608	; 0xfd0000
 80245ce:	f040 809f 	bne.w	8024710 <HCI_Event_CB+0xad8>
         } else if (SD_Card_FeaturesMask==FEATURE_MASK_BLUEVOICE) {
 80245d2:	f1b3 6f00 	cmp.w	r3, #134217728	; 0x8000000
 80245d6:	f000 8097 	beq.w	8024708 <HCI_Event_CB+0xad0>
        if(SD_Card_FeaturesMask&FEATURE_MASK_BLUEVOICE) {
 80245da:	683b      	ldr	r3, [r7, #0]
 80245dc:	0119      	lsls	r1, r3, #4
 80245de:	f100 808d 	bmi.w	80246fc <HCI_Event_CB+0xac4>
        if(SD_LogAudio_Enabled | SD_LogMems_Enabled) {
 80245e2:	4a67      	ldr	r2, [pc, #412]	; (8024780 <HCI_Event_CB+0xb48>)
 80245e4:	4b67      	ldr	r3, [pc, #412]	; (8024784 <HCI_Event_CB+0xb4c>)
 80245e6:	6812      	ldr	r2, [r2, #0]
 80245e8:	681b      	ldr	r3, [r3, #0]
 80245ea:	4313      	orrs	r3, r2
 80245ec:	f43f ab33 	beq.w	8023c56 <HCI_Event_CB+0x1e>
          if(W2ST_CHECK_CONNECTION(W2ST_CONNECT_SD_CARD_LOGGING)) {
 80245f0:	6c6b      	ldr	r3, [r5, #68]	; 0x44
 80245f2:	055a      	lsls	r2, r3, #21
 80245f4:	f57f ab2f 	bpl.w	8023c56 <HCI_Event_CB+0x1e>
            SDLog_Update(SD_CARD_LOGGING_START);
 80245f8:	2001      	movs	r0, #1
 80245fa:	e707      	b.n	802440c <HCI_Event_CB+0x7d4>
        BufferToWrite[0] = PointerByte[0];
 80245fc:	485e      	ldr	r0, [pc, #376]	; (8024778 <HCI_Event_CB+0xb40>)
        BytesToWrite = 4;
 80245fe:	4b62      	ldr	r3, [pc, #392]	; (8024788 <HCI_Event_CB+0xb50>)
        BufferToWrite[0] = PointerByte[0];
 8024600:	f880 9000 	strb.w	r9, [r0]
        BytesToWrite = 4;
 8024604:	2104      	movs	r1, #4
 8024606:	6019      	str	r1, [r3, #0]
        BufferToWrite[1] = PointerByte[1];
 8024608:	f880 8001 	strb.w	r8, [r0, #1]
        BufferToWrite[2] = PointerByte[2];
 802460c:	7087      	strb	r7, [r0, #2]
        BufferToWrite[3] = PointerByte[3];
 802460e:	70c4      	strb	r4, [r0, #3]
        Term_Update(BufferToWrite, BytesToWrite);
 8024610:	e63d      	b.n	802428e <HCI_Event_CB+0x656>
      SENSING1_PRINTF("OTA %s SIZE=%ld uwCRCValue=%lx\r\n",
 8024612:	9b08      	ldr	r3, [sp, #32]
 8024614:	495d      	ldr	r1, [pc, #372]	; (802478c <HCI_Event_CB+0xb54>)
 8024616:	485e      	ldr	r0, [pc, #376]	; (8024790 <HCI_Event_CB+0xb58>)
 8024618:	f003 fd00 	bl	802801c <iprintf>
 802461c:	e694      	b.n	8024348 <HCI_Event_CB+0x710>
      StartTime.Hours = ((att_data[8] - 48) * 16) + (att_data[9] - 48);
 802461e:	7d23      	ldrb	r3, [r4, #20]
 8024620:	7d60      	ldrb	r0, [r4, #21]
 8024622:	eb00 1003 	add.w	r0, r0, r3, lsl #4
 8024626:	f5a0 704c 	sub.w	r0, r0, #816	; 0x330
 802462a:	b2c0      	uxtb	r0, r0
      if ((StartTime.Hours < 0x24) &&
 802462c:	2823      	cmp	r0, #35	; 0x23
 802462e:	d812      	bhi.n	8024656 <HCI_Event_CB+0xa1e>
      StartTime.Minutes = ((att_data[11] - 48) * 16) + (att_data[12] - 48);
 8024630:	7de3      	ldrb	r3, [r4, #23]
 8024632:	7e21      	ldrb	r1, [r4, #24]
 8024634:	eb01 1103 	add.w	r1, r1, r3, lsl #4
 8024638:	f5a1 714c 	sub.w	r1, r1, #816	; 0x330
 802463c:	b2c9      	uxtb	r1, r1
      if ((StartTime.Hours < 0x24) &&
 802463e:	295f      	cmp	r1, #95	; 0x5f
 8024640:	d809      	bhi.n	8024656 <HCI_Event_CB+0xa1e>
      StartTime.Seconds = ((att_data[14] - 48) * 16) + (att_data[15] - 48);
 8024642:	7ea3      	ldrb	r3, [r4, #26]
 8024644:	7ee2      	ldrb	r2, [r4, #27]
 8024646:	eb02 1203 	add.w	r2, r2, r3, lsl #4
 802464a:	f5a2 724c 	sub.w	r2, r2, #816	; 0x330
 802464e:	b2d2      	uxtb	r2, r2
          (StartTime.Minutes < 0x60) &&
 8024650:	2a5f      	cmp	r2, #95	; 0x5f
 8024652:	f240 8113 	bls.w	802487c <HCI_Event_CB+0xc44>
        BytesToWrite = sprintf((char *)BufferToWrite, "Time format not correct\n");
 8024656:	4d4f      	ldr	r5, [pc, #316]	; (8024794 <HCI_Event_CB+0xb5c>)
 8024658:	4c47      	ldr	r4, [pc, #284]	; (8024778 <HCI_Event_CB+0xb40>)
 802465a:	4f4b      	ldr	r7, [pc, #300]	; (8024788 <HCI_Event_CB+0xb50>)
 802465c:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 802465e:	6020      	str	r0, [r4, #0]
 8024660:	6061      	str	r1, [r4, #4]
 8024662:	cd03      	ldmia	r5!, {r0, r1}
 8024664:	60a2      	str	r2, [r4, #8]
 8024666:	60e3      	str	r3, [r4, #12]
 8024668:	782a      	ldrb	r2, [r5, #0]
        BytesToWrite = sprintf((char *)BufferToWrite, "setTime hh:mm:ss\n");
 802466a:	4d4b      	ldr	r5, [pc, #300]	; (8024798 <HCI_Event_CB+0xb60>)
        BytesToWrite = sprintf((char *)BufferToWrite, "Time format not correct\n");
 802466c:	6120      	str	r0, [r4, #16]
 802466e:	2318      	movs	r3, #24
 8024670:	6161      	str	r1, [r4, #20]
 8024672:	7622      	strb	r2, [r4, #24]
        Term_Update(BufferToWrite, BytesToWrite);
 8024674:	4619      	mov	r1, r3
 8024676:	4620      	mov	r0, r4
        BytesToWrite = sprintf((char *)BufferToWrite, "Time format not correct\n");
 8024678:	603b      	str	r3, [r7, #0]
        Term_Update(BufferToWrite, BytesToWrite);
 802467a:	f7fe fd19 	bl	80230b0 <Term_Update>
        BytesToWrite = sprintf((char *)BufferToWrite, "setTime hh:mm:ss\n");
 802467e:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8024680:	2611      	movs	r6, #17
 8024682:	882d      	ldrh	r5, [r5, #0]
 8024684:	6020      	str	r0, [r4, #0]
 8024686:	6061      	str	r1, [r4, #4]
 8024688:	603e      	str	r6, [r7, #0]
        Term_Update(BufferToWrite, BytesToWrite);
 802468a:	4631      	mov	r1, r6
        BytesToWrite = sprintf((char *)BufferToWrite, "setTime hh:mm:ss\n");
 802468c:	60a2      	str	r2, [r4, #8]
        Term_Update(BufferToWrite, BytesToWrite);
 802468e:	4620      	mov	r0, r4
        BytesToWrite = sprintf((char *)BufferToWrite, "setTime hh:mm:ss\n");
 8024690:	60e3      	str	r3, [r4, #12]
 8024692:	8225      	strh	r5, [r4, #16]
 8024694:	e5fb      	b.n	802428e <HCI_Event_CB+0x656>
        BytesToWrite = sprintf((char *)BufferToWrite, "NodeName too long\n");
 8024696:	4d41      	ldr	r5, [pc, #260]	; (802479c <HCI_Event_CB+0xb64>)
 8024698:	4e37      	ldr	r6, [pc, #220]	; (8024778 <HCI_Event_CB+0xb40>)
 802469a:	f8df b0ec 	ldr.w	fp, [pc, #236]	; 8024788 <HCI_Event_CB+0xb50>
 802469e:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 80246a0:	60f3      	str	r3, [r6, #12]
 80246a2:	882b      	ldrh	r3, [r5, #0]
 80246a4:	8233      	strh	r3, [r6, #16]
 80246a6:	2712      	movs	r7, #18
 80246a8:	78ab      	ldrb	r3, [r5, #2]
 80246aa:	6030      	str	r0, [r6, #0]
 80246ac:	6071      	str	r1, [r6, #4]
 80246ae:	60b2      	str	r2, [r6, #8]
 80246b0:	74b3      	strb	r3, [r6, #18]
        Term_Update(BufferToWrite, BytesToWrite);
 80246b2:	4630      	mov	r0, r6
 80246b4:	4639      	mov	r1, r7
        BytesToWrite = sprintf((char *)BufferToWrite, "NodeName too long\n");
 80246b6:	f8cb 7000 	str.w	r7, [fp]
        NameLength = 7;
 80246ba:	2607      	movs	r6, #7
        Term_Update(BufferToWrite, BytesToWrite);
 80246bc:	f7fe fcf8 	bl	80230b0 <Term_Update>
 80246c0:	e599      	b.n	80241f6 <HCI_Event_CB+0x5be>
      BytesToWrite = sprintf((char *)BufferToWrite, "Node Name missing\n");
 80246c2:	4c37      	ldr	r4, [pc, #220]	; (80247a0 <HCI_Event_CB+0xb68>)
 80246c4:	4d2c      	ldr	r5, [pc, #176]	; (8024778 <HCI_Event_CB+0xb40>)
 80246c6:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 80246c8:	6028      	str	r0, [r5, #0]
 80246ca:	482f      	ldr	r0, [pc, #188]	; (8024788 <HCI_Event_CB+0xb50>)
 80246cc:	6069      	str	r1, [r5, #4]
 80246ce:	2112      	movs	r1, #18
 80246d0:	6001      	str	r1, [r0, #0]
 80246d2:	8820      	ldrh	r0, [r4, #0]
 80246d4:	78a4      	ldrb	r4, [r4, #2]
 80246d6:	8228      	strh	r0, [r5, #16]
 80246d8:	60aa      	str	r2, [r5, #8]
 80246da:	60eb      	str	r3, [r5, #12]
      Term_Update(BufferToWrite, BytesToWrite);
 80246dc:	4628      	mov	r0, r5
      BytesToWrite = sprintf((char *)BufferToWrite, "Node Name missing\n");
 80246de:	74ac      	strb	r4, [r5, #18]
 80246e0:	e5d5      	b.n	802428e <HCI_Event_CB+0x656>
            BytesToWrite =sprintf((char *)BufferToWrite, "FileName %s\n",DefaultDataFileName);
 80246e2:	4930      	ldr	r1, [pc, #192]	; (80247a4 <HCI_Event_CB+0xb6c>)
 80246e4:	4a25      	ldr	r2, [pc, #148]	; (802477c <HCI_Event_CB+0xb44>)
 80246e6:	4824      	ldr	r0, [pc, #144]	; (8024778 <HCI_Event_CB+0xb40>)
 80246e8:	f003 fd4c 	bl	8028184 <siprintf>
 80246ec:	4603      	mov	r3, r0
            Term_Update(BufferToWrite,BytesToWrite);
 80246ee:	b2d9      	uxtb	r1, r3
 80246f0:	4821      	ldr	r0, [pc, #132]	; (8024778 <HCI_Event_CB+0xb40>)
            BytesToWrite =sprintf((char *)BufferToWrite, "FileName %s\n",DefaultDataFileName);
 80246f2:	f8cb 3000 	str.w	r3, [fp]
            Term_Update(BufferToWrite,BytesToWrite);
 80246f6:	f7fe fcdb 	bl	80230b0 <Term_Update>
 80246fa:	e765      	b.n	80245c8 <HCI_Event_CB+0x990>
          osDelay(100);
 80246fc:	2064      	movs	r0, #100	; 0x64
 80246fe:	f7f4 f8e1 	bl	80188c4 <osDelay>
          SD_CardLoggingAudioStart();
 8024702:	f7fa f8c9 	bl	801e898 <SD_CardLoggingAudioStart>
 8024706:	e76c      	b.n	80245e2 <HCI_Event_CB+0x9aa>
           SD_CardLoggingMemsStart(1);
 8024708:	2001      	movs	r0, #1
 802470a:	f7f9 ff59 	bl	801e5c0 <SD_CardLoggingMemsStart>
 802470e:	e764      	b.n	80245da <HCI_Event_CB+0x9a2>
          SD_CardLoggingMemsStart(0);
 8024710:	2000      	movs	r0, #0
 8024712:	f7f9 ff55 	bl	801e5c0 <SD_CardLoggingMemsStart>
 8024716:	e760      	b.n	80245da <HCI_Event_CB+0x9a2>
  else if(!strncmp("versionFw",(char *)(att_data),9))
 8024718:	4823      	ldr	r0, [pc, #140]	; (80247a8 <HCI_Event_CB+0xb70>)
 802471a:	2209      	movs	r2, #9
 802471c:	4651      	mov	r1, sl
 802471e:	f003 fd94 	bl	802824a <strncmp>
 8024722:	2800      	cmp	r0, #0
 8024724:	f47f ad2e 	bne.w	8024184 <HCI_Event_CB+0x54c>
      BytesToWrite =sprintf((char *)BufferToWrite,"%s_%s_%c.%c.%c\r\n",
 8024728:	2233      	movs	r2, #51	; 0x33
 802472a:	2034      	movs	r0, #52	; 0x34
 802472c:	2430      	movs	r4, #48	; 0x30
 802472e:	e9cd 0400 	strd	r0, r4, [sp]
 8024732:	491e      	ldr	r1, [pc, #120]	; (80247ac <HCI_Event_CB+0xb74>)
 8024734:	4b15      	ldr	r3, [pc, #84]	; (802478c <HCI_Event_CB+0xb54>)
 8024736:	9202      	str	r2, [sp, #8]
 8024738:	480f      	ldr	r0, [pc, #60]	; (8024778 <HCI_Event_CB+0xb40>)
 802473a:	4a1d      	ldr	r2, [pc, #116]	; (80247b0 <HCI_Event_CB+0xb78>)
 802473c:	f003 fd22 	bl	8028184 <siprintf>
 8024740:	4b11      	ldr	r3, [pc, #68]	; (8024788 <HCI_Event_CB+0xb50>)
      Term_Update(BufferToWrite,BytesToWrite);
 8024742:	480d      	ldr	r0, [pc, #52]	; (8024778 <HCI_Event_CB+0xb40>)
      BytesToWrite =sprintf((char *)BufferToWrite,"%s_%s_%c.%c.%c\r\n",
 8024744:	2118      	movs	r1, #24
 8024746:	6019      	str	r1, [r3, #0]
      Term_Update(BufferToWrite,BytesToWrite);
 8024748:	e5a1      	b.n	802428e <HCI_Event_CB+0x656>
 802474a:	bf00      	nop
 802474c:	f3af 8000 	nop.w
 8024750:	00000000 	.word	0x00000000
 8024754:	40c38800 	.word	0x40c38800
 8024758:	20000d64 	.word	0x20000d64
 802475c:	2000b51c 	.word	0x2000b51c
 8024760:	408f4000 	.word	0x408f4000
 8024764:	20000d70 	.word	0x20000d70
 8024768:	20000d60 	.word	0x20000d60
 802476c:	20000d68 	.word	0x20000d68
 8024770:	200106a4 	.word	0x200106a4
 8024774:	08044078 	.word	0x08044078
 8024778:	200133dc 	.word	0x200133dc
 802477c:	2000b524 	.word	0x2000b524
 8024780:	2000b530 	.word	0x2000b530
 8024784:	2000b520 	.word	0x2000b520
 8024788:	200134dc 	.word	0x200134dc
 802478c:	08042f18 	.word	0x08042f18
 8024790:	08043f14 	.word	0x08043f14
 8024794:	08044020 	.word	0x08044020
 8024798:	0804403c 	.word	0x0804403c
 802479c:	08043f70 	.word	0x08043f70
 80247a0:	08043f98 	.word	0x08043f98
 80247a4:	08044090 	.word	0x08044090
 80247a8:	08044050 	.word	0x08044050
 80247ac:	08044064 	.word	0x08044064
 80247b0:	0804405c 	.word	0x0804405c
    if (NameLength == 19)
 80247b4:	2e14      	cmp	r6, #20
 80247b6:	f47f aa4e 	bne.w	8023c56 <HCI_Event_CB+0x1e>
      StartDate.WeekDay = att_data[9] - 48;
 80247ba:	7d60      	ldrb	r0, [r4, #21]
      if (((StartDate.WeekDay > 0x00) && (StartDate.WeekDay < 0x08)) &&
 80247bc:	f1a0 0331 	sub.w	r3, r0, #49	; 0x31
 80247c0:	2b06      	cmp	r3, #6
 80247c2:	d81c      	bhi.n	80247fe <HCI_Event_CB+0xbc6>
      StartDate.Date = ((att_data[11] - 48) * 16) + (att_data[12] - 48);
 80247c4:	7de3      	ldrb	r3, [r4, #23]
 80247c6:	7e21      	ldrb	r1, [r4, #24]
 80247c8:	eb01 1103 	add.w	r1, r1, r3, lsl #4
 80247cc:	f001 01ff 	and.w	r1, r1, #255	; 0xff
      if (((StartDate.WeekDay > 0x00) && (StartDate.WeekDay < 0x08)) &&
 80247d0:	f1a1 0331 	sub.w	r3, r1, #49	; 0x31
 80247d4:	2b30      	cmp	r3, #48	; 0x30
 80247d6:	d812      	bhi.n	80247fe <HCI_Event_CB+0xbc6>
      StartDate.Month = ((att_data[14] - 48) * 16) + (att_data[15] - 48);
 80247d8:	7ea3      	ldrb	r3, [r4, #26]
 80247da:	7ee2      	ldrb	r2, [r4, #27]
 80247dc:	eb02 1203 	add.w	r2, r2, r3, lsl #4
 80247e0:	f002 02ff 	and.w	r2, r2, #255	; 0xff
          ((StartDate.Date > 0x00) && (StartDate.Date < 0x32)) &&
 80247e4:	f1a2 0331 	sub.w	r3, r2, #49	; 0x31
 80247e8:	2b11      	cmp	r3, #17
 80247ea:	d808      	bhi.n	80247fe <HCI_Event_CB+0xbc6>
      StartDate.Year = ((att_data[17] - 48) * 16) + (att_data[18] - 48);
 80247ec:	7f65      	ldrb	r5, [r4, #29]
 80247ee:	7fa3      	ldrb	r3, [r4, #30]
 80247f0:	eb03 1305 	add.w	r3, r3, r5, lsl #4
 80247f4:	f5a3 734c 	sub.w	r3, r3, #816	; 0x330
 80247f8:	b2db      	uxtb	r3, r3
          ((StartDate.Month > 0x00) && (StartDate.Month < 0x13)) &&
 80247fa:	2b98      	cmp	r3, #152	; 0x98
 80247fc:	d921      	bls.n	8024842 <HCI_Event_CB+0xc0a>
        BytesToWrite = sprintf((char *)BufferToWrite, "Date format not correct\n");
 80247fe:	4d28      	ldr	r5, [pc, #160]	; (80248a0 <HCI_Event_CB+0xc68>)
 8024800:	4c28      	ldr	r4, [pc, #160]	; (80248a4 <HCI_Event_CB+0xc6c>)
 8024802:	4f29      	ldr	r7, [pc, #164]	; (80248a8 <HCI_Event_CB+0xc70>)
 8024804:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8024806:	6020      	str	r0, [r4, #0]
 8024808:	6061      	str	r1, [r4, #4]
 802480a:	cd03      	ldmia	r5!, {r0, r1}
 802480c:	60a2      	str	r2, [r4, #8]
 802480e:	60e3      	str	r3, [r4, #12]
 8024810:	782a      	ldrb	r2, [r5, #0]
        BytesToWrite = sprintf((char *)BufferToWrite, "setDate wd/dd/mm/yy\n");
 8024812:	4d26      	ldr	r5, [pc, #152]	; (80248ac <HCI_Event_CB+0xc74>)
        BytesToWrite = sprintf((char *)BufferToWrite, "Date format not correct\n");
 8024814:	6120      	str	r0, [r4, #16]
 8024816:	2318      	movs	r3, #24
 8024818:	6161      	str	r1, [r4, #20]
 802481a:	7622      	strb	r2, [r4, #24]
        Term_Update(BufferToWrite, BytesToWrite);
 802481c:	4619      	mov	r1, r3
 802481e:	4620      	mov	r0, r4
        BytesToWrite = sprintf((char *)BufferToWrite, "Date format not correct\n");
 8024820:	603b      	str	r3, [r7, #0]
        Term_Update(BufferToWrite, BytesToWrite);
 8024822:	f7fe fc45 	bl	80230b0 <Term_Update>
        BytesToWrite = sprintf((char *)BufferToWrite, "setDate wd/dd/mm/yy\n");
 8024826:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8024828:	2614      	movs	r6, #20
 802482a:	6020      	str	r0, [r4, #0]
 802482c:	60a2      	str	r2, [r4, #8]
 802482e:	6828      	ldr	r0, [r5, #0]
 8024830:	792a      	ldrb	r2, [r5, #4]
 8024832:	6061      	str	r1, [r4, #4]
 8024834:	6120      	str	r0, [r4, #16]
 8024836:	603e      	str	r6, [r7, #0]
        Term_Update(BufferToWrite, BytesToWrite);
 8024838:	4631      	mov	r1, r6
 802483a:	4620      	mov	r0, r4
        BytesToWrite = sprintf((char *)BufferToWrite, "setDate wd/dd/mm/yy\n");
 802483c:	60e3      	str	r3, [r4, #12]
 802483e:	7522      	strb	r2, [r4, #20]
 8024840:	e525      	b.n	802428e <HCI_Event_CB+0x656>
      StartDate.Month = ((att_data[14] - 48) * 16) + (att_data[15] - 48);
 8024842:	3a30      	subs	r2, #48	; 0x30
      StartDate.Date = ((att_data[11] - 48) * 16) + (att_data[12] - 48);
 8024844:	3930      	subs	r1, #48	; 0x30
      StartDate.WeekDay = att_data[9] - 48;
 8024846:	3830      	subs	r0, #48	; 0x30
        RTC_DateConfig(StartDate.WeekDay, StartDate.Date, StartDate.Month, StartDate.Year);
 8024848:	b2d2      	uxtb	r2, r2
 802484a:	b2c9      	uxtb	r1, r1
 802484c:	b2c0      	uxtb	r0, r0
 802484e:	f7fe f8d7 	bl	8022a00 <RTC_DateConfig>
        BytesToWrite = sprintf((char *)BufferToWrite, "Date format Correct\n");
 8024852:	4c17      	ldr	r4, [pc, #92]	; (80248b0 <HCI_Event_CB+0xc78>)
 8024854:	4b14      	ldr	r3, [pc, #80]	; (80248a8 <HCI_Event_CB+0xc70>)
 8024856:	4d13      	ldr	r5, [pc, #76]	; (80248a4 <HCI_Event_CB+0xc6c>)
 8024858:	601e      	str	r6, [r3, #0]
 802485a:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 802485c:	6028      	str	r0, [r5, #0]
 802485e:	60aa      	str	r2, [r5, #8]
 8024860:	6820      	ldr	r0, [r4, #0]
 8024862:	7922      	ldrb	r2, [r4, #4]
 8024864:	6069      	str	r1, [r5, #4]
 8024866:	6128      	str	r0, [r5, #16]
        Term_Update(BufferToWrite, BytesToWrite);
 8024868:	4631      	mov	r1, r6
 802486a:	4628      	mov	r0, r5
        BytesToWrite = sprintf((char *)BufferToWrite, "Date format Correct\n");
 802486c:	60eb      	str	r3, [r5, #12]
 802486e:	752a      	strb	r2, [r5, #20]
 8024870:	e50d      	b.n	802428e <HCI_Event_CB+0x656>
          SENSING1_PRINTF("%s will restart\r\n",SENSING1_PACKAGENAME);
 8024872:	4910      	ldr	r1, [pc, #64]	; (80248b4 <HCI_Event_CB+0xc7c>)
 8024874:	4810      	ldr	r0, [pc, #64]	; (80248b8 <HCI_Event_CB+0xc80>)
 8024876:	f003 fbd1 	bl	802801c <iprintf>
 802487a:	e435      	b.n	80240e8 <HCI_Event_CB+0x4b0>
        BytesToWrite = sprintf((char *)BufferToWrite, "Time format Correct\n");
 802487c:	4c0f      	ldr	r4, [pc, #60]	; (80248bc <HCI_Event_CB+0xc84>)
 802487e:	4d09      	ldr	r5, [pc, #36]	; (80248a4 <HCI_Event_CB+0xc6c>)
        RTC_TimeConfig(StartTime.Hours, StartTime.Minutes, StartTime.Seconds);
 8024880:	f7fe f8d8 	bl	8022a34 <RTC_TimeConfig>
        BytesToWrite = sprintf((char *)BufferToWrite, "Time format Correct\n");
 8024884:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 8024886:	6028      	str	r0, [r5, #0]
 8024888:	6820      	ldr	r0, [r4, #0]
 802488a:	6128      	str	r0, [r5, #16]
 802488c:	4806      	ldr	r0, [pc, #24]	; (80248a8 <HCI_Event_CB+0xc70>)
 802488e:	7924      	ldrb	r4, [r4, #4]
 8024890:	6069      	str	r1, [r5, #4]
 8024892:	2114      	movs	r1, #20
 8024894:	6001      	str	r1, [r0, #0]
 8024896:	60aa      	str	r2, [r5, #8]
 8024898:	60eb      	str	r3, [r5, #12]
 802489a:	752c      	strb	r4, [r5, #20]
        Term_Update(BufferToWrite, BytesToWrite);
 802489c:	4628      	mov	r0, r5
 802489e:	e4f6      	b.n	802428e <HCI_Event_CB+0x656>
 80248a0:	08043fcc 	.word	0x08043fcc
 80248a4:	200133dc 	.word	0x200133dc
 80248a8:	200134dc 	.word	0x200134dc
 80248ac:	08043fe8 	.word	0x08043fe8
 80248b0:	08043fb4 	.word	0x08043fb4
 80248b4:	08042f18 	.word	0x08042f18
 80248b8:	08043ed0 	.word	0x08043ed0
 80248bc:	08044008 	.word	0x08044008

080248c0 <MX_SPI3_Init>:
  * @brief  Initializes MX SPI3 HAL.
  * @param  phspi SPI handler
  * @retval HAL status
  */
__weak HAL_StatusTypeDef MX_SPI3_Init(SPI_HandleTypeDef* phspi, uint32_t baudrate_presc)
{
 80248c0:	b510      	push	{r4, lr}
  HAL_StatusTypeDef ret = HAL_OK;

  phspi->Init.Mode              = SPI_MODE_MASTER;
 80248c2:	f44f 7482 	mov.w	r4, #260	; 0x104
  phspi->Init.Direction         = SPI_DIRECTION_2LINES;
 80248c6:	2200      	movs	r2, #0
  phspi->Init.Mode              = SPI_MODE_MASTER;
 80248c8:	6044      	str	r4, [r0, #4]
  phspi->Init.DataSize          = SPI_DATASIZE_8BIT;
 80248ca:	f44f 64e0 	mov.w	r4, #1792	; 0x700
 80248ce:	e9c0 2402 	strd	r2, r4, [r0, #8]
  phspi->Init.CLKPolarity       = SPI_POLARITY_LOW;
  phspi->Init.CLKPhase          = SPI_PHASE_1EDGE;
  phspi->Init.NSS               = SPI_NSS_SOFT;
 80248d2:	f44f 7400 	mov.w	r4, #512	; 0x200
 80248d6:	6184      	str	r4, [r0, #24]
  phspi->Init.BaudRatePrescaler = baudrate_presc;
  phspi->Init.FirstBit          = SPI_FIRSTBIT_MSB;
  phspi->Init.TIMode            = SPI_TIMODE_DISABLE;
  phspi->Init.CRCCalculation    = SPI_CRCCALCULATION_DISABLE;
  phspi->Init.CRCPolynomial     = 7;
 80248d8:	2407      	movs	r4, #7
  phspi->Init.CLKPhase          = SPI_PHASE_1EDGE;
 80248da:	e9c0 2204 	strd	r2, r2, [r0, #16]
  phspi->Init.FirstBit          = SPI_FIRSTBIT_MSB;
 80248de:	e9c0 1207 	strd	r1, r2, [r0, #28]
  phspi->Init.CRCCalculation    = SPI_CRCCALCULATION_DISABLE;
 80248e2:	e9c0 2209 	strd	r2, r2, [r0, #36]	; 0x24
  phspi->Init.CRCPolynomial     = 7;
 80248e6:	62c4      	str	r4, [r0, #44]	; 0x2c

  if(HAL_SPI_Init(phspi) != HAL_OK)
 80248e8:	f7ef fbf2 	bl	80140d0 <HAL_SPI_Init>
  {
    ret = HAL_ERROR;
  }

  return ret;
}
 80248ec:	3800      	subs	r0, #0
 80248ee:	bf18      	it	ne
 80248f0:	2001      	movne	r0, #1
 80248f2:	bd10      	pop	{r4, pc}

080248f4 <BSP_SPI3_Init>:
/**
  * @brief  Initializes SPI HAL.
  * @retval BSP status
  */
int32_t BSP_SPI3_Init(void)
{
 80248f4:	b530      	push	{r4, r5, lr}
  int32_t ret = BSP_ERROR_NONE;

  hbus_spi3.Instance  = BUS_SPI3_INSTANCE;
 80248f6:	482c      	ldr	r0, [pc, #176]	; (80249a8 <BSP_SPI3_Init+0xb4>)
 80248f8:	4b2c      	ldr	r3, [pc, #176]	; (80249ac <BSP_SPI3_Init+0xb8>)
 80248fa:	6003      	str	r3, [r0, #0]
{
 80248fc:	b08b      	sub	sp, #44	; 0x2c

  if (HAL_SPI_GetState(&hbus_spi3) == HAL_SPI_STATE_RESET)
 80248fe:	f7ef fe5f 	bl	80145c0 <HAL_SPI_GetState>
 8024902:	b110      	cbz	r0, 802490a <BSP_SPI3_Init+0x16>
  int32_t ret = BSP_ERROR_NONE;
 8024904:	2000      	movs	r0, #0
      ret = BSP_ERROR_BUS_FAILURE;
    }
  }

  return ret;
}
 8024906:	b00b      	add	sp, #44	; 0x2c
 8024908:	bd30      	pop	{r4, r5, pc}
static void SPI3_MspInit(SPI_HandleTypeDef* hspi)
{
  GPIO_InitTypeDef gpio_init;

  /* Peripheral clock enable */
  BUS_SPI3_CLK_ENABLE();
 802490a:	4b29      	ldr	r3, [pc, #164]	; (80249b0 <BSP_SPI3_Init+0xbc>)
 802490c:	6d9a      	ldr	r2, [r3, #88]	; 0x58
 802490e:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
 8024912:	659a      	str	r2, [r3, #88]	; 0x58
 8024914:	6d9a      	ldr	r2, [r3, #88]	; 0x58
 8024916:	f402 4200 	and.w	r2, r2, #32768	; 0x8000
 802491a:	9201      	str	r2, [sp, #4]
 802491c:	9a01      	ldr	r2, [sp, #4]

  /* Enable GPIO clock */
  BUS_SPI3_SCK_GPIO_CLK_ENABLE();
 802491e:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 8024920:	f042 0204 	orr.w	r2, r2, #4
 8024924:	64da      	str	r2, [r3, #76]	; 0x4c
 8024926:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 8024928:	f002 0204 	and.w	r2, r2, #4
 802492c:	9202      	str	r2, [sp, #8]
 802492e:	9a02      	ldr	r2, [sp, #8]
  BUS_SPI3_MISO_GPIO_CLK_ENABLE();
 8024930:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 8024932:	f042 0204 	orr.w	r2, r2, #4
 8024936:	64da      	str	r2, [r3, #76]	; 0x4c
 8024938:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 802493a:	f002 0204 	and.w	r2, r2, #4
 802493e:	9203      	str	r2, [sp, #12]
 8024940:	9a03      	ldr	r2, [sp, #12]
  BUS_SPI3_MOSI_GPIO_CLK_ENABLE();
 8024942:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 8024944:	f042 0204 	orr.w	r2, r2, #4
 8024948:	64da      	str	r2, [r3, #76]	; 0x4c
 802494a:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 802494c:	f003 0304 	and.w	r3, r3, #4
 8024950:	9304      	str	r3, [sp, #16]

  /* SPI3 GPIO Configuration */
  gpio_init.Pin = BUS_SPI3_SCK_GPIO_PIN | BUS_SPI3_MISO_GPIO_PIN | BUS_SPI3_MOSI_GPIO_PIN;
 8024952:	f44f 52e0 	mov.w	r2, #7168	; 0x1c00
  gpio_init.Mode = GPIO_MODE_AF_PP;
 8024956:	2302      	movs	r3, #2
 8024958:	e9cd 2305 	strd	r2, r3, [sp, #20]
 802495c:	4604      	mov	r4, r0
  gpio_init.Pull = GPIO_NOPULL;
  gpio_init.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
  gpio_init.Alternate = BUS_SPI3_SCK_GPIO_AF;
 802495e:	2203      	movs	r2, #3
 8024960:	2306      	movs	r3, #6
  HAL_GPIO_Init(BUS_SPI3_SCK_GPIO_PORT, &gpio_init);
 8024962:	4814      	ldr	r0, [pc, #80]	; (80249b4 <BSP_SPI3_Init+0xc0>)
  BUS_SPI3_MOSI_GPIO_CLK_ENABLE();
 8024964:	9d04      	ldr	r5, [sp, #16]
  gpio_init.Pull = GPIO_NOPULL;
 8024966:	9407      	str	r4, [sp, #28]
  HAL_GPIO_Init(BUS_SPI3_SCK_GPIO_PORT, &gpio_init);
 8024968:	a905      	add	r1, sp, #20
  gpio_init.Alternate = BUS_SPI3_SCK_GPIO_AF;
 802496a:	e9cd 2308 	strd	r2, r3, [sp, #32]
  HAL_GPIO_Init(BUS_SPI3_SCK_GPIO_PORT, &gpio_init);
 802496e:	f7eb ff65 	bl	801083c <HAL_GPIO_Init>
    if (MX_SPI3_Init(&hbus_spi3, SPI_GetPrescaler(HAL_RCC_GetPCLK2Freq(), BUS_SPI3_BAUDRATE)) != HAL_OK)
 8024972:	f7ee fa1b 	bl	8012dac <HAL_RCC_GetPCLK2Freq>
    SPI_BAUDRATEPRESCALER_64,
    SPI_BAUDRATEPRESCALER_128,
    SPI_BAUDRATEPRESCALER_256,
  };

  while( spi_clk > baudrate_mbps)
 8024976:	4a10      	ldr	r2, [pc, #64]	; (80249b8 <BSP_SPI3_Init+0xc4>)
 8024978:	4290      	cmp	r0, r2
 802497a:	d912      	bls.n	80249a2 <BSP_SPI3_Init+0xae>
 802497c:	4b0f      	ldr	r3, [pc, #60]	; (80249bc <BSP_SPI3_Init+0xc8>)
  {
    presc = baudrate[divisor];
 802497e:	4621      	mov	r1, r4
 8024980:	f103 041c 	add.w	r4, r3, #28
    if (++divisor > 7)
      break;

    spi_clk= ( spi_clk >> 1);
 8024984:	0840      	lsrs	r0, r0, #1
  while( spi_clk > baudrate_mbps)
 8024986:	4290      	cmp	r0, r2
 8024988:	d903      	bls.n	8024992 <BSP_SPI3_Init+0x9e>
    presc = baudrate[divisor];
 802498a:	f853 1b04 	ldr.w	r1, [r3], #4
    if (++divisor > 7)
 802498e:	42a3      	cmp	r3, r4
 8024990:	d1f8      	bne.n	8024984 <BSP_SPI3_Init+0x90>
    if (MX_SPI3_Init(&hbus_spi3, SPI_GetPrescaler(HAL_RCC_GetPCLK2Freq(), BUS_SPI3_BAUDRATE)) != HAL_OK)
 8024992:	4805      	ldr	r0, [pc, #20]	; (80249a8 <BSP_SPI3_Init+0xb4>)
 8024994:	f7ff ff94 	bl	80248c0 <MX_SPI3_Init>
 8024998:	2800      	cmp	r0, #0
 802499a:	d0b3      	beq.n	8024904 <BSP_SPI3_Init+0x10>
      ret = BSP_ERROR_BUS_FAILURE;
 802499c:	f06f 0007 	mvn.w	r0, #7
  return ret;
 80249a0:	e7b1      	b.n	8024906 <BSP_SPI3_Init+0x12>
  uint32_t presc = 0;
 80249a2:	4621      	mov	r1, r4
 80249a4:	e7f5      	b.n	8024992 <BSP_SPI3_Init+0x9e>
 80249a6:	bf00      	nop
 80249a8:	20014594 	.word	0x20014594
 80249ac:	40003c00 	.word	0x40003c00
 80249b0:	40021000 	.word	0x40021000
 80249b4:	48000800 	.word	0x48000800
 80249b8:	00f42400 	.word	0x00f42400
 80249bc:	08039bb0 	.word	0x08039bb0

080249c0 <BSP_SPI3_SendRecv>:
{
 80249c0:	b500      	push	{lr}
 80249c2:	b083      	sub	sp, #12
 80249c4:	4684      	mov	ip, r0
 80249c6:	4613      	mov	r3, r2
  if(HAL_SPI_TransmitReceive(&hbus_spi3, pTxData,pRxData, Length, 0x1000) == HAL_OK)
 80249c8:	f44f 5280 	mov.w	r2, #4096	; 0x1000
 80249cc:	9200      	str	r2, [sp, #0]
 80249ce:	4806      	ldr	r0, [pc, #24]	; (80249e8 <BSP_SPI3_SendRecv+0x28>)
 80249d0:	460a      	mov	r2, r1
 80249d2:	4661      	mov	r1, ip
 80249d4:	f7ef fbf2 	bl	80141bc <HAL_SPI_TransmitReceive>
    ret = BSP_ERROR_NONE;
 80249d8:	2800      	cmp	r0, #0
}
 80249da:	bf14      	ite	ne
 80249dc:	f06f 0005 	mvnne.w	r0, #5
 80249e0:	2000      	moveq	r0, #0
 80249e2:	b003      	add	sp, #12
 80249e4:	f85d fb04 	ldr.w	pc, [sp], #4
 80249e8:	20014594 	.word	0x20014594

080249ec <BSP_ENV_SENSOR_Set_One_Shot>:
 */
int32_t BSP_ENV_SENSOR_Set_One_Shot(uint32_t Instance)
{
  int32_t status = BSP_ERROR_NONE;

  if (Instance >= ENV_SENSOR_INSTANCES_NBR)
 80249ec:	2801      	cmp	r0, #1
 80249ee:	d810      	bhi.n	8024a12 <BSP_ENV_SENSOR_Set_One_Shot+0x26>
{
 80249f0:	b508      	push	{r3, lr}
  }
  else
  {
    if (Instance == 0U)
    {
      if (HTS221_Set_One_Shot(Env_Sensor_CompObj[Instance]) != BSP_ERROR_NONE)
 80249f2:	4b09      	ldr	r3, [pc, #36]	; (8024a18 <BSP_ENV_SENSOR_Set_One_Shot+0x2c>)
    if (Instance == 0U)
 80249f4:	b128      	cbz	r0, 8024a02 <BSP_ENV_SENSOR_Set_One_Shot+0x16>
        status = BSP_ERROR_COMPONENT_FAILURE;
      }
    }
    else /* Instance = 1 */
    {
      if (LPS22HB_Set_One_Shot(Env_Sensor_CompObj[Instance]) != BSP_ERROR_NONE)
 80249f6:	6858      	ldr	r0, [r3, #4]
 80249f8:	f7e9 fcbe 	bl	800e378 <LPS22HB_Set_One_Shot>
 80249fc:	b930      	cbnz	r0, 8024a0c <BSP_ENV_SENSOR_Set_One_Shot+0x20>
  int32_t status = BSP_ERROR_NONE;
 80249fe:	2000      	movs	r0, #0
      }
    }
  }

  return status;
}
 8024a00:	bd08      	pop	{r3, pc}
      if (HTS221_Set_One_Shot(Env_Sensor_CompObj[Instance]) != BSP_ERROR_NONE)
 8024a02:	6818      	ldr	r0, [r3, #0]
 8024a04:	f7e8 fd2a 	bl	800d45c <HTS221_Set_One_Shot>
 8024a08:	2800      	cmp	r0, #0
 8024a0a:	d0f8      	beq.n	80249fe <BSP_ENV_SENSOR_Set_One_Shot+0x12>
        status = BSP_ERROR_COMPONENT_FAILURE;
 8024a0c:	f06f 0004 	mvn.w	r0, #4
}
 8024a10:	bd08      	pop	{r3, pc}
    status = BSP_ERROR_WRONG_PARAM;
 8024a12:	f06f 0001 	mvn.w	r0, #1
}
 8024a16:	4770      	bx	lr
 8024a18:	200031b4 	.word	0x200031b4

08024a1c <BSP_QSPIEx_WaitForEndOfOperation>:
  * @brief  Wait for QSPI operation to complete on memory side.
  * @param  Instance  QSPI instance
  * @retval BSP status
  */
int32_t BSP_QSPIEx_WaitForEndOfOperation(uint32_t Instance, uint32_t Timeout)
{
 8024a1c:	b570      	push	{r4, r5, r6, lr}
 8024a1e:	4604      	mov	r4, r0
 8024a20:	460d      	mov	r5, r1
  uint32_t tickstart = HAL_GetTick();
 8024a22:	f7ea ff09 	bl	800f838 <HAL_GetTick>
 8024a26:	4606      	mov	r6, r0
  int32_t ret;

  /* Check if the instance is supported */
  if (Instance >= QSPI_INSTANCES_NUMBER)
 8024a28:	b97c      	cbnz	r4, 8024a4a <BSP_QSPIEx_WaitForEndOfOperation+0x2e>
  }
  else
  {
    do
    {
      ret = BSP_QSPI_GetStatus(Instance);
 8024a2a:	2000      	movs	r0, #0
 8024a2c:	f7e8 f944 	bl	800ccb8 <BSP_QSPI_GetStatus>
      if (Timeout != HAL_MAX_DELAY)
 8024a30:	1c6a      	adds	r2, r5, #1
      ret = BSP_QSPI_GetStatus(Instance);
 8024a32:	4604      	mov	r4, r0
      if (Timeout != HAL_MAX_DELAY)
 8024a34:	d004      	beq.n	8024a40 <BSP_QSPIEx_WaitForEndOfOperation+0x24>
      {
        if ((HAL_GetTick() - tickstart) >= Timeout)
 8024a36:	f7ea feff 	bl	800f838 <HAL_GetTick>
 8024a3a:	1b83      	subs	r3, r0, r6
 8024a3c:	42ab      	cmp	r3, r5
 8024a3e:	d2f4      	bcs.n	8024a2a <BSP_QSPIEx_WaitForEndOfOperation+0xe>
        {
          ret = BSP_ERROR_UNKNOWN_FAILURE;
        }
      }
    } while ((ret != BSP_ERROR_NONE) && (ret != BSP_ERROR_COMPONENT_FAILURE));
 8024a40:	b10c      	cbz	r4, 8024a46 <BSP_QSPIEx_WaitForEndOfOperation+0x2a>
 8024a42:	1d63      	adds	r3, r4, #5
 8024a44:	d1f1      	bne.n	8024a2a <BSP_QSPIEx_WaitForEndOfOperation+0xe>
  }

  /* Return BSP status */
  return ret;
}
 8024a46:	4620      	mov	r0, r4
 8024a48:	bd70      	pop	{r4, r5, r6, pc}
    ret = BSP_ERROR_WRONG_PARAM;
 8024a4a:	f06f 0401 	mvn.w	r4, #1
  return ret;
 8024a4e:	e7fa      	b.n	8024a46 <BSP_QSPIEx_WaitForEndOfOperation+0x2a>

08024a50 <HAL_PCD_MspInit>:
  * @brief  Initializes the PCD MSP.
  * @param  hpcd: PCD handle
  * @retval None
  */
void HAL_PCD_MspInit(PCD_HandleTypeDef *hpcd)
{
 8024a50:	b530      	push	{r4, r5, lr}
  GPIO_InitTypeDef  GPIO_InitStruct;

  /* Configure USB FS GPIOs */
  __HAL_RCC_GPIOA_CLK_ENABLE();
 8024a52:	4c17      	ldr	r4, [pc, #92]	; (8024ab0 <HAL_PCD_MspInit+0x60>)
 8024a54:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
 8024a56:	f043 0301 	orr.w	r3, r3, #1
 8024a5a:	64e3      	str	r3, [r4, #76]	; 0x4c
 8024a5c:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
{
 8024a5e:	b089      	sub	sp, #36	; 0x24
  __HAL_RCC_GPIOA_CLK_ENABLE();
 8024a60:	f003 0301 	and.w	r3, r3, #1
 8024a64:	9301      	str	r3, [sp, #4]

  /* Configure DM DP Pins */
  GPIO_InitStruct.Pin = (GPIO_PIN_11 | GPIO_PIN_12);
 8024a66:	f44f 53c0 	mov.w	r3, #6144	; 0x1800
 8024a6a:	9303      	str	r3, [sp, #12]
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8024a6c:	2302      	movs	r3, #2
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 8024a6e:	2500      	movs	r5, #0
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8024a70:	9304      	str	r3, [sp, #16]
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 8024a72:	2303      	movs	r3, #3
 8024a74:	e9cd 5305 	strd	r5, r3, [sp, #20]
  GPIO_InitStruct.Alternate = GPIO_AF10_OTG_FS;
  HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8024a78:	a903      	add	r1, sp, #12
  GPIO_InitStruct.Alternate = GPIO_AF10_OTG_FS;
 8024a7a:	230a      	movs	r3, #10
  HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8024a7c:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
  __HAL_RCC_GPIOA_CLK_ENABLE();
 8024a80:	9a01      	ldr	r2, [sp, #4]
  GPIO_InitStruct.Alternate = GPIO_AF10_OTG_FS;
 8024a82:	9307      	str	r3, [sp, #28]
  HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8024a84:	f7eb feda 	bl	801083c <HAL_GPIO_Init>

  /* Enable USB FS Clock */
  __HAL_RCC_USB_OTG_FS_CLK_ENABLE();
 8024a88:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
 8024a8a:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
 8024a8e:	64e3      	str	r3, [r4, #76]	; 0x4c
 8024a90:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
 8024a92:	f403 5380 	and.w	r3, r3, #4096	; 0x1000

  /* Set USB FS Interrupt priority */
  HAL_NVIC_SetPriority(OTG_FS_IRQn, 6, 0);
 8024a96:	462a      	mov	r2, r5
  __HAL_RCC_USB_OTG_FS_CLK_ENABLE();
 8024a98:	9302      	str	r3, [sp, #8]
  HAL_NVIC_SetPriority(OTG_FS_IRQn, 6, 0);
 8024a9a:	2106      	movs	r1, #6
 8024a9c:	2043      	movs	r0, #67	; 0x43
  __HAL_RCC_USB_OTG_FS_CLK_ENABLE();
 8024a9e:	9b02      	ldr	r3, [sp, #8]
  HAL_NVIC_SetPriority(OTG_FS_IRQn, 6, 0);
 8024aa0:	f7ea feee 	bl	800f880 <HAL_NVIC_SetPriority>

  /* Enable USB FS Interrupt */
  HAL_NVIC_EnableIRQ(OTG_FS_IRQn);
 8024aa4:	2043      	movs	r0, #67	; 0x43
 8024aa6:	f7ea ff29 	bl	800f8fc <HAL_NVIC_EnableIRQ>
}
 8024aaa:	b009      	add	sp, #36	; 0x24
 8024aac:	bd30      	pop	{r4, r5, pc}
 8024aae:	bf00      	nop
 8024ab0:	40021000 	.word	0x40021000

08024ab4 <HAL_PCD_MspDeInit>:
  * @retval None
  */
void HAL_PCD_MspDeInit(PCD_HandleTypeDef *hpcd)
{
  /* Disable USB FS Clock */
  __HAL_RCC_USB_OTG_FS_CLK_DISABLE();
 8024ab4:	4b04      	ldr	r3, [pc, #16]	; (8024ac8 <HAL_PCD_MspDeInit+0x14>)
 8024ab6:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 8024ab8:	f422 5280 	bic.w	r2, r2, #4096	; 0x1000
 8024abc:	64da      	str	r2, [r3, #76]	; 0x4c
  __HAL_RCC_SYSCFG_CLK_DISABLE();
 8024abe:	6e1a      	ldr	r2, [r3, #96]	; 0x60
 8024ac0:	f022 0201 	bic.w	r2, r2, #1
 8024ac4:	661a      	str	r2, [r3, #96]	; 0x60
}
 8024ac6:	4770      	bx	lr
 8024ac8:	40021000 	.word	0x40021000

08024acc <HAL_RTC_MspInit>:
  *        order to modify the RTC Clock source, as consequence RTC registers (including 
  *        the backup registers) and RCC_CSR register are set to their reset values.  
  * @retval None
  */
void HAL_RTC_MspInit(RTC_HandleTypeDef *hrtc)
{
 8024acc:	b500      	push	{lr}
 8024ace:	b0a3      	sub	sp, #140	; 0x8c
  RCC_PeriphCLKInitTypeDef  PeriphClkInitStruct;

  /*##-1- Configure LSE as RTC clock source ##################################*/
  PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_RTC;
 8024ad0:	f44f 3200 	mov.w	r2, #131072	; 0x20000
  PeriphClkInitStruct.RTCClockSelection    = RCC_RTCCLKSOURCE_LSE;
 8024ad4:	f44f 7380 	mov.w	r3, #256	; 0x100
  if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK)
 8024ad8:	4668      	mov	r0, sp
  PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_RTC;
 8024ada:	9200      	str	r2, [sp, #0]
  PeriphClkInitStruct.RTCClockSelection    = RCC_RTCCLKSOURCE_LSE;
 8024adc:	9321      	str	r3, [sp, #132]	; 0x84
  if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK)
 8024ade:	f7ee fb05 	bl	80130ec <HAL_RCCEx_PeriphCLKConfig>
 8024ae2:	b100      	cbz	r0, 8024ae6 <HAL_RTC_MspInit+0x1a>
  {
    while(1);
 8024ae4:	e7fe      	b.n	8024ae4 <HAL_RTC_MspInit+0x18>
  }

  /*##-2- Enable the RTC peripheral Clock ####################################*/
  /* Enable RTC Clock */
  __HAL_RCC_RTC_ENABLE();
 8024ae6:	4909      	ldr	r1, [pc, #36]	; (8024b0c <HAL_RTC_MspInit+0x40>)
 8024ae8:	f8d1 3090 	ldr.w	r3, [r1, #144]	; 0x90
 8024aec:	4602      	mov	r2, r0
 8024aee:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 8024af2:	f8c1 3090 	str.w	r3, [r1, #144]	; 0x90

  /*##-3- Configure the NVIC for RTC Wake up #################################*/
  HAL_NVIC_SetPriority(RTC_WKUP_IRQn, 0x00, 0);
 8024af6:	2003      	movs	r0, #3
 8024af8:	4611      	mov	r1, r2
 8024afa:	f7ea fec1 	bl	800f880 <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(RTC_WKUP_IRQn);
 8024afe:	2003      	movs	r0, #3
 8024b00:	f7ea fefc 	bl	800f8fc <HAL_NVIC_EnableIRQ>
}
 8024b04:	b023      	add	sp, #140	; 0x8c
 8024b06:	f85d fb04 	ldr.w	pc, [sp], #4
 8024b0a:	bf00      	nop
 8024b0c:	40021000 	.word	0x40021000

08024b10 <HAL_CRC_MspInit>:
  * @retval None
  */
void HAL_CRC_MspInit(CRC_HandleTypeDef *hcrc)
{
  /* CRC Peripheral clock enable */
  __HAL_RCC_CRC_CLK_ENABLE();
 8024b10:	4b06      	ldr	r3, [pc, #24]	; (8024b2c <HAL_CRC_MspInit+0x1c>)
 8024b12:	6c9a      	ldr	r2, [r3, #72]	; 0x48
 8024b14:	f442 5280 	orr.w	r2, r2, #4096	; 0x1000
 8024b18:	649a      	str	r2, [r3, #72]	; 0x48
 8024b1a:	6c9b      	ldr	r3, [r3, #72]	; 0x48
{
 8024b1c:	b082      	sub	sp, #8
  __HAL_RCC_CRC_CLK_ENABLE();
 8024b1e:	f403 5380 	and.w	r3, r3, #4096	; 0x1000
 8024b22:	9301      	str	r3, [sp, #4]
 8024b24:	9b01      	ldr	r3, [sp, #4]
}
 8024b26:	b002      	add	sp, #8
 8024b28:	4770      	bx	lr
 8024b2a:	bf00      	nop
 8024b2c:	40021000 	.word	0x40021000

08024b30 <HAL_CRC_MspDeInit>:
  * @retval None
  */
void HAL_CRC_MspDeInit(CRC_HandleTypeDef *hcrc)
{
  /* Enable CRC reset state */
  __HAL_RCC_CRC_FORCE_RESET();
 8024b30:	4b04      	ldr	r3, [pc, #16]	; (8024b44 <HAL_CRC_MspDeInit+0x14>)
 8024b32:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 8024b34:	f442 5280 	orr.w	r2, r2, #4096	; 0x1000
 8024b38:	629a      	str	r2, [r3, #40]	; 0x28

  /* Release CRC from reset state */
  __HAL_RCC_CRC_RELEASE_RESET();
 8024b3a:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 8024b3c:	f422 5280 	bic.w	r2, r2, #4096	; 0x1000
 8024b40:	629a      	str	r2, [r3, #40]	; 0x28
}
 8024b42:	4770      	bx	lr
 8024b44:	40021000 	.word	0x40021000

08024b48 <NMI_Handler>:
  * @param  None
  * @retval None
  */
void NMI_Handler(void)
{
}
 8024b48:	4770      	bx	lr
 8024b4a:	bf00      	nop

08024b4c <HardFault_Handler>:
  * @retval None
  */
void HardFault_Handler(void)
{
  /* Go to infinite loop when Hard Fault exception occurs */
  while (1)
 8024b4c:	e7fe      	b.n	8024b4c <HardFault_Handler>
 8024b4e:	bf00      	nop

08024b50 <MemManage_Handler>:
  * @retval None
  */
void MemManage_Handler(void)
{
  /* Go to infinite loop when Memory Manage exception occurs */
  while (1)
 8024b50:	e7fe      	b.n	8024b50 <MemManage_Handler>
 8024b52:	bf00      	nop

08024b54 <BusFault_Handler>:
  * @retval None
  */
void BusFault_Handler(void)
{
  /* Go to infinite loop when Bus Fault exception occurs */
  while (1)
 8024b54:	e7fe      	b.n	8024b54 <BusFault_Handler>
 8024b56:	bf00      	nop

08024b58 <UsageFault_Handler>:
  * @retval None
  */
void UsageFault_Handler(void)
{
  /* Go to infinite loop when Usage Fault exception occurs */
  while (1)
 8024b58:	e7fe      	b.n	8024b58 <UsageFault_Handler>
 8024b5a:	bf00      	nop

08024b5c <DebugMon_Handler>:
 8024b5c:	4770      	bx	lr
 8024b5e:	bf00      	nop

08024b60 <SysTick_Handler>:
  * @brief  This function handles SysTick Handler.
  * @param  None
  * @retval None
  */
void SysTick_Handler(void)
{
 8024b60:	b508      	push	{r3, lr}
  osSystickHandler();
 8024b62:	f7f4 f8e7 	bl	8018d34 <osSystickHandler>
  HAL_IncTick();
}
 8024b66:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  HAL_IncTick();
 8024b6a:	f7ea be59 	b.w	800f820 <HAL_IncTick>
 8024b6e:	bf00      	nop

08024b70 <DMA1_Channel4_IRQHandler>:
#if defined(USE_STM32L4XX_NUCLEO)
  HAL_DMA_IRQHandler(&hDmaDfsdm[0]);
#elif defined(STM32_SENSORTILE)
  HAL_DMA_IRQHandler(&hDmaDfsdm);
#elif defined(USE_STM32L475E_IOT01)
  HAL_DMA_IRQHandler(haudio_in_dfsdm_filter[0].hdmaReg);
 8024b70:	4b01      	ldr	r3, [pc, #4]	; (8024b78 <DMA1_Channel4_IRQHandler+0x8>)
 8024b72:	6a98      	ldr	r0, [r3, #40]	; 0x28
 8024b74:	f7eb bc6c 	b.w	8010450 <HAL_DMA_IRQHandler>
 8024b78:	200023a4 	.word	0x200023a4

08024b7c <OTG_FS_IRQHandler>:
  * @param  None
  * @retval None
  */
void OTG_FS_IRQHandler(void)
{
  HAL_PCD_IRQHandler(&hpcd);
 8024b7c:	4801      	ldr	r0, [pc, #4]	; (8024b84 <OTG_FS_IRQHandler+0x8>)
 8024b7e:	f7ec bd51 	b.w	8011624 <HAL_PCD_IRQHandler>
 8024b82:	bf00      	nop
 8024b84:	200145f8 	.word	0x200145f8

08024b88 <EXTI9_5_IRQHandler>:
  * @param  None
  * @retval None
  */
void EXTI9_5_IRQHandler(void)
{
  HAL_GPIO_EXTI_IRQHandler(HCI_TL_SPI_EXTI_PIN);
 8024b88:	2040      	movs	r0, #64	; 0x40
 8024b8a:	f7ec b82f 	b.w	8010bec <HAL_GPIO_EXTI_IRQHandler>
 8024b8e:	bf00      	nop

08024b90 <EXTI15_10_IRQHandler>:
* @param  None
* @retval None
*/
void EXTI15_10_IRQHandler(void)
{
  HAL_GPIO_EXTI_IRQHandler(BUTTON_USER_PIN);
 8024b90:	f44f 5000 	mov.w	r0, #8192	; 0x2000
 8024b94:	f7ec b82a 	b.w	8010bec <HAL_GPIO_EXTI_IRQHandler>

08024b98 <USART1_IRQHandler>:
}

void USART1_IRQHandler(void)
{
  HAL_UART_IRQHandler(&UartHandle);
 8024b98:	4801      	ldr	r0, [pc, #4]	; (8024ba0 <USART1_IRQHandler+0x8>)
 8024b9a:	f7ef bde9 	b.w	8014770 <HAL_UART_IRQHandler>
 8024b9e:	bf00      	nop
 8024ba0:	20002214 	.word	0x20002214

08024ba4 <RTC_WKUP_IRQHandler>:
  * @param  None
  * @retval None
  */
void RTC_WKUP_IRQHandler(void)
{
  HAL_RTCEx_WakeUpTimerIRQHandler(&RtcHandle);
 8024ba4:	4801      	ldr	r0, [pc, #4]	; (8024bac <RTC_WKUP_IRQHandler+0x8>)
 8024ba6:	f7ef ba05 	b.w	8013fb4 <HAL_RTCEx_WakeUpTimerIRQHandler>
 8024baa:	bf00      	nop
 8024bac:	20013504 	.word	0x20013504

08024bb0 <HAL_PCD_SetupStageCallback>:
* @param  hpcd: PCD handle
* @retval None
*/
void HAL_PCD_SetupStageCallback(PCD_HandleTypeDef *hpcd)
{
  USBD_LL_SetupStage(hpcd->pData, (uint8_t *)hpcd->Setup);
 8024bb0:	f500 7171 	add.w	r1, r0, #964	; 0x3c4
 8024bb4:	f8d0 0404 	ldr.w	r0, [r0, #1028]	; 0x404
 8024bb8:	f7f7 bfea 	b.w	801cb90 <USBD_LL_SetupStage>

08024bbc <HAL_PCD_DataOutStageCallback>:
* @param  hpcd: PCD handle
* @retval None
*/
void HAL_PCD_DataOutStageCallback(PCD_HandleTypeDef *hpcd, uint8_t epnum)
{
  USBD_LL_DataOutStage(hpcd->pData, epnum, hpcd->OUT_ep[epnum].xfer_buff);
 8024bbc:	ebc1 03c1 	rsb	r3, r1, r1, lsl #3
 8024bc0:	eb00 0383 	add.w	r3, r0, r3, lsl #2
 8024bc4:	f8d0 0404 	ldr.w	r0, [r0, #1028]	; 0x404
 8024bc8:	f8d3 2208 	ldr.w	r2, [r3, #520]	; 0x208
 8024bcc:	f7f8 b810 	b.w	801cbf0 <USBD_LL_DataOutStage>

08024bd0 <HAL_PCD_DataInStageCallback>:
* @param  hpcd: PCD handle
* @retval None
*/
void HAL_PCD_DataInStageCallback(PCD_HandleTypeDef *hpcd, uint8_t epnum)
{
  USBD_LL_DataInStage(hpcd->pData, epnum, hpcd->IN_ep[epnum].xfer_buff);
 8024bd0:	ebc1 03c1 	rsb	r3, r1, r1, lsl #3
 8024bd4:	eb00 0383 	add.w	r3, r0, r3, lsl #2
 8024bd8:	f8d0 0404 	ldr.w	r0, [r0, #1028]	; 0x404
 8024bdc:	6c9a      	ldr	r2, [r3, #72]	; 0x48
 8024bde:	f7f8 b845 	b.w	801cc6c <USBD_LL_DataInStage>
 8024be2:	bf00      	nop

08024be4 <HAL_PCD_SOFCallback>:
* @param  hpcd: PCD handle
* @retval None
*/
void HAL_PCD_SOFCallback(PCD_HandleTypeDef *hpcd)
{
  USBD_LL_SOF(hpcd->pData);
 8024be4:	f8d0 0404 	ldr.w	r0, [r0, #1028]	; 0x404
 8024be8:	f7f8 b8e0 	b.w	801cdac <USBD_LL_SOF>

08024bec <HAL_PCD_ResetCallback>:
* @brief  SOF callback.
* @param  hpcd: PCD handle
* @retval None
*/
void HAL_PCD_ResetCallback(PCD_HandleTypeDef *hpcd)
{
 8024bec:	b510      	push	{r4, lr}
 8024bee:	4604      	mov	r4, r0
  /* Reset Device */
  USBD_LL_Reset(hpcd->pData);
 8024bf0:	f8d0 0404 	ldr.w	r0, [r0, #1028]	; 0x404
 8024bf4:	f7f8 f89c 	bl	801cd30 <USBD_LL_Reset>

  /* Set USB Current Speed */
  USBD_LL_SetSpeed(hpcd->pData, USBD_SPEED_FULL);
 8024bf8:	f8d4 0404 	ldr.w	r0, [r4, #1028]	; 0x404
 8024bfc:	2101      	movs	r1, #1
}
 8024bfe:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  USBD_LL_SetSpeed(hpcd->pData, USBD_SPEED_FULL);
 8024c02:	f7f8 b8bd 	b.w	801cd80 <USBD_LL_SetSpeed>
 8024c06:	bf00      	nop

08024c08 <HAL_PCD_SuspendCallback>:
* @param  hpcd: PCD handle
* @retval None
*/
void HAL_PCD_SuspendCallback(PCD_HandleTypeDef *hpcd)
{
  USBD_LL_Suspend(hpcd->pData);
 8024c08:	f8d0 0404 	ldr.w	r0, [r0, #1028]	; 0x404
 8024c0c:	f7f8 b8bc 	b.w	801cd88 <USBD_LL_Suspend>

08024c10 <HAL_PCD_ResumeCallback>:
* @param  hpcd: PCD handle
* @retval None
*/
void HAL_PCD_ResumeCallback(PCD_HandleTypeDef *hpcd)
{
  USBD_LL_Resume(hpcd->pData);
 8024c10:	f8d0 0404 	ldr.w	r0, [r0, #1028]	; 0x404
 8024c14:	f7f8 b8c2 	b.w	801cd9c <USBD_LL_Resume>

08024c18 <HAL_PCD_ISOOUTIncompleteCallback>:
* @param  hpcd: PCD handle
* @retval None
*/
void HAL_PCD_ISOOUTIncompleteCallback(PCD_HandleTypeDef *hpcd, uint8_t epnum)
{
  USBD_LL_IsoOUTIncomplete(hpcd->pData, epnum);
 8024c18:	f8d0 0404 	ldr.w	r0, [r0, #1028]	; 0x404
 8024c1c:	f7f8 b8d6 	b.w	801cdcc <USBD_LL_IsoOUTIncomplete>

08024c20 <HAL_PCD_ISOINIncompleteCallback>:
* @param  hpcd: PCD handle
* @retval None
*/
void HAL_PCD_ISOINIncompleteCallback(PCD_HandleTypeDef *hpcd, uint8_t epnum)
{
  USBD_LL_IsoINIncomplete(hpcd->pData, epnum);
 8024c20:	f8d0 0404 	ldr.w	r0, [r0, #1028]	; 0x404
 8024c24:	f7f8 b8d0 	b.w	801cdc8 <USBD_LL_IsoINIncomplete>

08024c28 <HAL_PCD_ConnectCallback>:
* @param  hpcd: PCD handle
* @retval None
*/
void HAL_PCD_ConnectCallback(PCD_HandleTypeDef *hpcd)
{
  USBD_LL_DevConnected(hpcd->pData);
 8024c28:	f8d0 0404 	ldr.w	r0, [r0, #1028]	; 0x404
 8024c2c:	f7f8 b8d0 	b.w	801cdd0 <USBD_LL_DevConnected>

08024c30 <HAL_PCD_DisconnectCallback>:
* @param  hpcd: PCD handle
* @retval None
*/
void HAL_PCD_DisconnectCallback(PCD_HandleTypeDef *hpcd)
{
  USBD_LL_DevDisconnected(hpcd->pData);
 8024c30:	f8d0 0404 	ldr.w	r0, [r0, #1028]	; 0x404
 8024c34:	f7f8 b8ce 	b.w	801cdd4 <USBD_LL_DevDisconnected>

08024c38 <USBD_LL_Init>:
*         Initialize the Low Level portion of the Device driver.
* @param  pdev: Device handle
* @retval USBD Status
*/
USBD_StatusTypeDef  USBD_LL_Init (USBD_HandleTypeDef *pdev)
{
 8024c38:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  /* Change Systick prioity */
  NVIC_SetPriority (SysTick_IRQn, 0);

  /* Set LL Driver parameters */
  hpcd.Instance = USB_OTG_FS;
 8024c3a:	4c1b      	ldr	r4, [pc, #108]	; (8024ca8 <USBD_LL_Init+0x70>)
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8024c3c:	4b1b      	ldr	r3, [pc, #108]	; (8024cac <USBD_LL_Init+0x74>)
 8024c3e:	2500      	movs	r5, #0
 8024c40:	f883 5023 	strb.w	r5, [r3, #35]	; 0x23
  hpcd.Init.dev_endpoints = 4;
  hpcd.Init.use_dedicated_ep1 = 0;
  hpcd.Init.ep0_mps = 0x40;
 8024c44:	2640      	movs	r6, #64	; 0x40
  hpcd.Init.dev_endpoints = 4;
 8024c46:	2304      	movs	r3, #4
  hpcd.Init.phy_itface = PCD_PHY_EMBEDDED;
  hpcd.Init.Sof_enable = 0;
  hpcd.Init.speed = PCD_SPEED_FULL;
  hpcd.Init.vbus_sensing_enable = 0;
  /* Link The driver to the stack */
  hpcd.pData = pdev;
 8024c48:	f8c4 0404 	str.w	r0, [r4, #1028]	; 0x404
  hpcd.Instance = USB_OTG_FS;
 8024c4c:	f04f 42a0 	mov.w	r2, #1342177280	; 0x50000000
  hpcd.Init.phy_itface = PCD_PHY_EMBEDDED;
 8024c50:	2702      	movs	r7, #2
  pdev->pData = &hpcd;
 8024c52:	f8c0 4298 	str.w	r4, [r0, #664]	; 0x298
  /* Initialize LL Driver */
  HAL_PCD_Init(&hpcd);
 8024c56:	4620      	mov	r0, r4
  hpcd.Init.dev_endpoints = 4;
 8024c58:	e9c4 2300 	strd	r2, r3, [r4]
  hpcd.Init.dma_enable = 0;
 8024c5c:	e9c4 5604 	strd	r5, r6, [r4, #16]
  hpcd.Init.lpm_enable = 0;
 8024c60:	e9c4 5508 	strd	r5, r5, [r4, #32]
  hpcd.Init.Sof_enable = 0;
 8024c64:	e9c4 7506 	strd	r7, r5, [r4, #24]
  hpcd.Init.use_dedicated_ep1 = 0;
 8024c68:	6325      	str	r5, [r4, #48]	; 0x30
  hpcd.Init.battery_charging_enable = 0;
 8024c6a:	62a5      	str	r5, [r4, #40]	; 0x28
  hpcd.Init.speed = PCD_SPEED_FULL;
 8024c6c:	60e7      	str	r7, [r4, #12]
  hpcd.Init.vbus_sensing_enable = 0;
 8024c6e:	62e5      	str	r5, [r4, #44]	; 0x2c
  HAL_PCD_Init(&hpcd);
 8024c70:	f7ec fbd6 	bl	8011420 <HAL_PCD_Init>

  /* configure EPs FIFOs */
  HAL_PCD_SetRxFiFo(&hpcd, 64);
 8024c74:	4631      	mov	r1, r6
 8024c76:	4620      	mov	r0, r4
 8024c78:	f7ed f906 	bl	8011e88 <HAL_PCDEx_SetRxFiFo>
  HAL_PCD_SetTxFiFo(&hpcd, 0, 32);
 8024c7c:	4629      	mov	r1, r5
 8024c7e:	2220      	movs	r2, #32
 8024c80:	4620      	mov	r0, r4
 8024c82:	f7ed f8d7 	bl	8011e34 <HAL_PCDEx_SetTxFiFo>
  HAL_PCD_SetTxFiFo(&hpcd, 1, 64);
 8024c86:	4632      	mov	r2, r6
 8024c88:	2101      	movs	r1, #1
 8024c8a:	4620      	mov	r0, r4
 8024c8c:	f7ed f8d2 	bl	8011e34 <HAL_PCDEx_SetTxFiFo>
  HAL_PCD_SetTxFiFo(&hpcd, 2, 64);
 8024c90:	4632      	mov	r2, r6
 8024c92:	4639      	mov	r1, r7
 8024c94:	4620      	mov	r0, r4
 8024c96:	f7ed f8cd 	bl	8011e34 <HAL_PCDEx_SetTxFiFo>
  HAL_PCD_SetTxFiFo(&hpcd, 3, 36);
 8024c9a:	2224      	movs	r2, #36	; 0x24
 8024c9c:	2103      	movs	r1, #3
 8024c9e:	4620      	mov	r0, r4
 8024ca0:	f7ed f8c8 	bl	8011e34 <HAL_PCDEx_SetTxFiFo>

  return USBD_OK;
}
 8024ca4:	4628      	mov	r0, r5
 8024ca6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8024ca8:	200145f8 	.word	0x200145f8
 8024cac:	e000ed00 	.word	0xe000ed00

08024cb0 <USBD_LL_DeInit>:
*         De-Initialize the Low Level portion of the Device driver.
* @param  pdev: Device handle
* @retval USBD Status
*/
USBD_StatusTypeDef  USBD_LL_DeInit (USBD_HandleTypeDef *pdev)
{
 8024cb0:	b508      	push	{r3, lr}
  HAL_PCD_DeInit(pdev->pData);
 8024cb2:	f8d0 0298 	ldr.w	r0, [r0, #664]	; 0x298
 8024cb6:	f7ec fc49 	bl	801154c <HAL_PCD_DeInit>
  return USBD_OK;
}
 8024cba:	2000      	movs	r0, #0
 8024cbc:	bd08      	pop	{r3, pc}
 8024cbe:	bf00      	nop

08024cc0 <USBD_LL_Start>:
*         Start the Low Level portion of the Device driver.
* @param  pdev: Device handle
* @retval USBD Status
*/
USBD_StatusTypeDef  USBD_LL_Start(USBD_HandleTypeDef *pdev)
{
 8024cc0:	b508      	push	{r3, lr}
  HAL_PCD_Start(pdev->pData);
 8024cc2:	f8d0 0298 	ldr.w	r0, [r0, #664]	; 0x298
 8024cc6:	f7ec fc6f 	bl	80115a8 <HAL_PCD_Start>
  return USBD_OK;
}
 8024cca:	2000      	movs	r0, #0
 8024ccc:	bd08      	pop	{r3, pc}
 8024cce:	bf00      	nop

08024cd0 <USBD_LL_Stop>:
*         Stop the Low Level portion of the Device driver.
* @param  pdev: Device handle
* @retval USBD Status
*/
USBD_StatusTypeDef  USBD_LL_Stop (USBD_HandleTypeDef *pdev)
{
 8024cd0:	b508      	push	{r3, lr}
  HAL_PCD_Stop(pdev->pData);
 8024cd2:	f8d0 0298 	ldr.w	r0, [r0, #664]	; 0x298
 8024cd6:	f7ec fc83 	bl	80115e0 <HAL_PCD_Stop>
  return USBD_OK;
}
 8024cda:	2000      	movs	r0, #0
 8024cdc:	bd08      	pop	{r3, pc}
 8024cde:	bf00      	nop

08024ce0 <USBD_LL_OpenEP>:
*/
USBD_StatusTypeDef  USBD_LL_OpenEP  (USBD_HandleTypeDef *pdev,
                                     uint8_t  ep_addr,
                                     uint8_t  ep_type,
                                     uint16_t ep_mps)
{
 8024ce0:	b508      	push	{r3, lr}
 8024ce2:	4694      	mov	ip, r2
  HAL_PCD_EP_Open(pdev->pData,
 8024ce4:	f8d0 0298 	ldr.w	r0, [r0, #664]	; 0x298
{
 8024ce8:	461a      	mov	r2, r3
  HAL_PCD_EP_Open(pdev->pData,
 8024cea:	4663      	mov	r3, ip
 8024cec:	f7ec ff52 	bl	8011b94 <HAL_PCD_EP_Open>
                  ep_addr,
                  ep_mps,
                  ep_type);

  return USBD_OK;
}
 8024cf0:	2000      	movs	r0, #0
 8024cf2:	bd08      	pop	{r3, pc}

08024cf4 <USBD_LL_CloseEP>:
* @param  pdev: device handle
* @param  ep_addr: Endpoint Number
* @retval USBD Status
*/
USBD_StatusTypeDef  USBD_LL_CloseEP (USBD_HandleTypeDef *pdev, uint8_t ep_addr)
{
 8024cf4:	b508      	push	{r3, lr}
  HAL_PCD_EP_Close(pdev->pData, ep_addr);
 8024cf6:	f8d0 0298 	ldr.w	r0, [r0, #664]	; 0x298
 8024cfa:	f7ec ff89 	bl	8011c10 <HAL_PCD_EP_Close>
  return USBD_OK;
}
 8024cfe:	2000      	movs	r0, #0
 8024d00:	bd08      	pop	{r3, pc}
 8024d02:	bf00      	nop

08024d04 <USBD_LL_FlushEP>:
* @param  pdev: device handle
* @param  ep_addr: Endpoint Number
* @retval USBD Status
*/
USBD_StatusTypeDef  USBD_LL_FlushEP (USBD_HandleTypeDef *pdev, uint8_t ep_addr)
{
 8024d04:	b508      	push	{r3, lr}
  HAL_PCD_EP_Flush(pdev->pData, ep_addr);
 8024d06:	f8d0 0298 	ldr.w	r0, [r0, #664]	; 0x298
 8024d0a:	f7ed f877 	bl	8011dfc <HAL_PCD_EP_Flush>
  return USBD_OK;
}
 8024d0e:	2000      	movs	r0, #0
 8024d10:	bd08      	pop	{r3, pc}
 8024d12:	bf00      	nop

08024d14 <USBD_LL_StallEP>:
* @param  pdev: device handle
* @param  ep_addr: Endpoint Number
* @retval USBD Status
*/
USBD_StatusTypeDef  USBD_LL_StallEP (USBD_HandleTypeDef *pdev, uint8_t ep_addr)
{
 8024d14:	b508      	push	{r3, lr}
  HAL_PCD_EP_SetStall(pdev->pData, ep_addr);
 8024d16:	f8d0 0298 	ldr.w	r0, [r0, #664]	; 0x298
 8024d1a:	f7ec fff5 	bl	8011d08 <HAL_PCD_EP_SetStall>
  return USBD_OK;
}
 8024d1e:	2000      	movs	r0, #0
 8024d20:	bd08      	pop	{r3, pc}
 8024d22:	bf00      	nop

08024d24 <USBD_LL_ClearStallEP>:
* @param  pdev: device handle
* @param  ep_addr: Endpoint Number
* @retval USBD Status
*/
USBD_StatusTypeDef  USBD_LL_ClearStallEP (USBD_HandleTypeDef *pdev, uint8_t ep_addr)
{
 8024d24:	b508      	push	{r3, lr}
  HAL_PCD_EP_ClrStall(pdev->pData, ep_addr);
 8024d26:	f8d0 0298 	ldr.w	r0, [r0, #664]	; 0x298
 8024d2a:	f7ed f82f 	bl	8011d8c <HAL_PCD_EP_ClrStall>
  return USBD_OK;
}
 8024d2e:	2000      	movs	r0, #0
 8024d30:	bd08      	pop	{r3, pc}
 8024d32:	bf00      	nop

08024d34 <USBD_LL_IsStallEP>:
*/
uint8_t USBD_LL_IsStallEP (USBD_HandleTypeDef *pdev, uint8_t ep_addr)
{
  PCD_HandleTypeDef *hpcd = pdev->pData;

  if((ep_addr & 0x80) == 0x80)
 8024d34:	060a      	lsls	r2, r1, #24
  PCD_HandleTypeDef *hpcd = pdev->pData;
 8024d36:	f8d0 3298 	ldr.w	r3, [r0, #664]	; 0x298
  if((ep_addr & 0x80) == 0x80)
 8024d3a:	d406      	bmi.n	8024d4a <USBD_LL_IsStallEP+0x16>
  {
    return hpcd->IN_ep[ep_addr & 0x7F].is_stall;
  }
  else
  {
    return hpcd->OUT_ep[ep_addr & 0x7F].is_stall;
 8024d3c:	ebc1 01c1 	rsb	r1, r1, r1, lsl #3
 8024d40:	eb03 0181 	add.w	r1, r3, r1, lsl #2
 8024d44:	f891 01fe 	ldrb.w	r0, [r1, #510]	; 0x1fe
  }
}
 8024d48:	4770      	bx	lr
    return hpcd->IN_ep[ep_addr & 0x7F].is_stall;
 8024d4a:	f001 017f 	and.w	r1, r1, #127	; 0x7f
 8024d4e:	ebc1 01c1 	rsb	r1, r1, r1, lsl #3
 8024d52:	eb03 0181 	add.w	r1, r3, r1, lsl #2
 8024d56:	f891 003e 	ldrb.w	r0, [r1, #62]	; 0x3e
 8024d5a:	4770      	bx	lr

08024d5c <USBD_LL_SetUSBAddress>:
* @param  pdev: device handle
* @param  ep_addr: Endpoint Number
* @retval USBD Status
*/
USBD_StatusTypeDef  USBD_LL_SetUSBAddress (USBD_HandleTypeDef *pdev, uint8_t dev_addr)
{
 8024d5c:	b508      	push	{r3, lr}
  HAL_PCD_SetAddress(pdev->pData, dev_addr);
 8024d5e:	f8d0 0298 	ldr.w	r0, [r0, #664]	; 0x298
 8024d62:	f7ec ff03 	bl	8011b6c <HAL_PCD_SetAddress>
  return USBD_OK;
}
 8024d66:	2000      	movs	r0, #0
 8024d68:	bd08      	pop	{r3, pc}
 8024d6a:	bf00      	nop

08024d6c <USBD_LL_Transmit>:
*/
USBD_StatusTypeDef  USBD_LL_Transmit (USBD_HandleTypeDef *pdev,
                                      uint8_t  ep_addr,
                                      uint8_t  *pbuf,
                                      uint16_t  size)
{
 8024d6c:	b508      	push	{r3, lr}
  HAL_PCD_EP_Transmit(pdev->pData, ep_addr, pbuf, size);
 8024d6e:	f8d0 0298 	ldr.w	r0, [r0, #664]	; 0x298
 8024d72:	f7ec ffa7 	bl	8011cc4 <HAL_PCD_EP_Transmit>
  return USBD_OK;
}
 8024d76:	2000      	movs	r0, #0
 8024d78:	bd08      	pop	{r3, pc}
 8024d7a:	bf00      	nop

08024d7c <USBD_LL_PrepareReceive>:
*/
USBD_StatusTypeDef  USBD_LL_PrepareReceive(USBD_HandleTypeDef *pdev,
                                           uint8_t  ep_addr,
                                           uint8_t  *pbuf,
                                           uint16_t  size)
{
 8024d7c:	b508      	push	{r3, lr}
  HAL_PCD_EP_Receive(pdev->pData, ep_addr, pbuf, size);
 8024d7e:	f8d0 0298 	ldr.w	r0, [r0, #664]	; 0x298
 8024d82:	f7ec ff73 	bl	8011c6c <HAL_PCD_EP_Receive>
  return USBD_OK;
}
 8024d86:	2000      	movs	r0, #0
 8024d88:	bd08      	pop	{r3, pc}
 8024d8a:	bf00      	nop

08024d8c <USBD_LL_GetRxDataSize>:
* @param  ep_addr: Endpoint Number
* @retval Recived Data Size
*/
uint32_t USBD_LL_GetRxDataSize  (USBD_HandleTypeDef *pdev, uint8_t  ep_addr)
{
  return HAL_PCD_EP_GetRxCount(pdev->pData, ep_addr);
 8024d8c:	f8d0 0298 	ldr.w	r0, [r0, #664]	; 0x298
 8024d90:	f7ec bf8e 	b.w	8011cb0 <HAL_PCD_EP_GetRxCount>

08024d94 <USBD_DeviceDescriptor>:
  * @param  length: Pointer to data length variable
  * @retval Pointer to descriptor buffer
  */
uint8_t *USBD_DeviceDescriptor(USBD_SpeedTypeDef speed, uint16_t *length)
{
  *length = sizeof(USBD_DeviceDesc);
 8024d94:	2312      	movs	r3, #18
  return (uint8_t*)USBD_DeviceDesc;
}
 8024d96:	4801      	ldr	r0, [pc, #4]	; (8024d9c <USBD_DeviceDescriptor+0x8>)
  *length = sizeof(USBD_DeviceDesc);
 8024d98:	800b      	strh	r3, [r1, #0]
}
 8024d9a:	4770      	bx	lr
 8024d9c:	20000dbc 	.word	0x20000dbc

08024da0 <USBD_LangIDStrDescriptor>:
  * @param  length: Pointer to data length variable
  * @retval Pointer to descriptor buffer
  */
uint8_t *USBD_LangIDStrDescriptor(USBD_SpeedTypeDef speed, uint16_t *length)
{
  *length = sizeof(USBD_LangIDDesc);
 8024da0:	2304      	movs	r3, #4
  return (uint8_t*)USBD_LangIDDesc;
}
 8024da2:	4801      	ldr	r0, [pc, #4]	; (8024da8 <USBD_LangIDStrDescriptor+0x8>)
  *length = sizeof(USBD_LangIDDesc);
 8024da4:	800b      	strh	r3, [r1, #0]
}
 8024da6:	4770      	bx	lr
 8024da8:	20000dd0 	.word	0x20000dd0

08024dac <USBD_ProductStrDescriptor>:
  * @param  speed: Current device speed
  * @param  length: Pointer to data length variable
  * @retval Pointer to descriptor buffer
  */
uint8_t *USBD_ProductStrDescriptor(USBD_SpeedTypeDef speed, uint16_t *length)
{
 8024dac:	b510      	push	{r4, lr}
  USBD_GetString((uint8_t *)USBD_PRODUCT_FS_STRING, USBD_StrDesc, length);
 8024dae:	4c04      	ldr	r4, [pc, #16]	; (8024dc0 <USBD_ProductStrDescriptor+0x14>)
 8024db0:	4804      	ldr	r0, [pc, #16]	; (8024dc4 <USBD_ProductStrDescriptor+0x18>)
{
 8024db2:	460a      	mov	r2, r1
  USBD_GetString((uint8_t *)USBD_PRODUCT_FS_STRING, USBD_StrDesc, length);
 8024db4:	4621      	mov	r1, r4
 8024db6:	f7f8 fa81 	bl	801d2bc <USBD_GetString>
  return USBD_StrDesc;
}
 8024dba:	4620      	mov	r0, r4
 8024dbc:	bd10      	pop	{r4, pc}
 8024dbe:	bf00      	nop
 8024dc0:	20014a00 	.word	0x20014a00
 8024dc4:	08044148 	.word	0x08044148

08024dc8 <USBD_ManufacturerStrDescriptor>:
  * @param  speed: Current device speed
  * @param  length: Pointer to data length variable
  * @retval Pointer to descriptor buffer
  */
uint8_t *USBD_ManufacturerStrDescriptor(USBD_SpeedTypeDef speed, uint16_t *length)
{
 8024dc8:	b510      	push	{r4, lr}
  USBD_GetString((uint8_t *)USBD_MANUFACTURER_STRING, USBD_StrDesc, length);
 8024dca:	4c04      	ldr	r4, [pc, #16]	; (8024ddc <USBD_ManufacturerStrDescriptor+0x14>)
 8024dcc:	4804      	ldr	r0, [pc, #16]	; (8024de0 <USBD_ManufacturerStrDescriptor+0x18>)
{
 8024dce:	460a      	mov	r2, r1
  USBD_GetString((uint8_t *)USBD_MANUFACTURER_STRING, USBD_StrDesc, length);
 8024dd0:	4621      	mov	r1, r4
 8024dd2:	f7f8 fa73 	bl	801d2bc <USBD_GetString>
  return USBD_StrDesc;
}
 8024dd6:	4620      	mov	r0, r4
 8024dd8:	bd10      	pop	{r4, pc}
 8024dda:	bf00      	nop
 8024ddc:	20014a00 	.word	0x20014a00
 8024de0:	08044168 	.word	0x08044168

08024de4 <USBD_ConfigStrDescriptor>:
  * @param  speed: Current device speed
  * @param  length: Pointer to data length variable
  * @retval Pointer to descriptor buffer
  */
uint8_t *USBD_ConfigStrDescriptor(USBD_SpeedTypeDef speed, uint16_t *length)
{
 8024de4:	b510      	push	{r4, lr}
  USBD_GetString((uint8_t *)USBD_CONFIGURATION_FS_STRING, USBD_StrDesc, length);
 8024de6:	4c04      	ldr	r4, [pc, #16]	; (8024df8 <USBD_ConfigStrDescriptor+0x14>)
 8024de8:	4804      	ldr	r0, [pc, #16]	; (8024dfc <USBD_ConfigStrDescriptor+0x18>)
{
 8024dea:	460a      	mov	r2, r1
  USBD_GetString((uint8_t *)USBD_CONFIGURATION_FS_STRING, USBD_StrDesc, length);
 8024dec:	4621      	mov	r1, r4
 8024dee:	f7f8 fa65 	bl	801d2bc <USBD_GetString>
  return USBD_StrDesc;
}
 8024df2:	4620      	mov	r0, r4
 8024df4:	bd10      	pop	{r4, pc}
 8024df6:	bf00      	nop
 8024df8:	20014a00 	.word	0x20014a00
 8024dfc:	0804417c 	.word	0x0804417c

08024e00 <USBD_InterfaceStrDescriptor>:
  * @param  speed: Current device speed
  * @param  length: Pointer to data length variable
  * @retval Pointer to descriptor buffer
  */
uint8_t *USBD_InterfaceStrDescriptor(USBD_SpeedTypeDef speed, uint16_t *length)
{
 8024e00:	b510      	push	{r4, lr}
  USBD_GetString((uint8_t *)USBD_INTERFACE_FS_STRING, USBD_StrDesc, length);
 8024e02:	4c04      	ldr	r4, [pc, #16]	; (8024e14 <USBD_InterfaceStrDescriptor+0x14>)
 8024e04:	4804      	ldr	r0, [pc, #16]	; (8024e18 <USBD_InterfaceStrDescriptor+0x18>)
{
 8024e06:	460a      	mov	r2, r1
  USBD_GetString((uint8_t *)USBD_INTERFACE_FS_STRING, USBD_StrDesc, length);
 8024e08:	4621      	mov	r1, r4
 8024e0a:	f7f8 fa57 	bl	801d2bc <USBD_GetString>
  return USBD_StrDesc;
}
 8024e0e:	4620      	mov	r0, r4
 8024e10:	bd10      	pop	{r4, pc}
 8024e12:	bf00      	nop
 8024e14:	20014a00 	.word	0x20014a00
 8024e18:	08044188 	.word	0x08044188

08024e1c <USBD_SerialStrDescriptor>:
  */
static void Get_SerialNum(void)
{
  uint32_t deviceserial0, deviceserial1, deviceserial2;

  deviceserial0 = *(uint32_t*)DEVICE_ID1;
 8024e1c:	4820      	ldr	r0, [pc, #128]	; (8024ea0 <USBD_SerialStrDescriptor+0x84>)
 8024e1e:	f8d0 3a10 	ldr.w	r3, [r0, #2576]	; 0xa10
  deviceserial1 = *(uint32_t*)DEVICE_ID2;
  deviceserial2 = *(uint32_t*)DEVICE_ID3;

  deviceserial0 += deviceserial2;
 8024e22:	f8d0 2a18 	ldr.w	r2, [r0, #2584]	; 0xa18
{
 8024e26:	b530      	push	{r4, r5, lr}

  if (deviceserial0 != 0)
 8024e28:	189b      	adds	r3, r3, r2
  *length = USB_SIZ_STRING_SERIAL;
 8024e2a:	f04f 041a 	mov.w	r4, #26
 8024e2e:	800c      	strh	r4, [r1, #0]
  if (deviceserial0 != 0)
 8024e30:	d101      	bne.n	8024e36 <USBD_SerialStrDescriptor+0x1a>
}
 8024e32:	481c      	ldr	r0, [pc, #112]	; (8024ea4 <USBD_SerialStrDescriptor+0x88>)
 8024e34:	bd30      	pop	{r4, r5, pc}
 8024e36:	4a1b      	ldr	r2, [pc, #108]	; (8024ea4 <USBD_SerialStrDescriptor+0x88>)
  deviceserial1 = *(uint32_t*)DEVICE_ID2;
 8024e38:	f8d0 1a14 	ldr.w	r1, [r0, #2580]	; 0xa14
 8024e3c:	f04f 0e00 	mov.w	lr, #0
 8024e40:	4610      	mov	r0, r2
      pbuf[2* idx] = (value >> 28) + 'A' - 10;
    }

    value = value << 4;

    pbuf[ 2* idx + 1] = 0;
 8024e42:	4675      	mov	r5, lr
    if( ((value >> 28)) < 0xA )
 8024e44:	f1b3 4f20 	cmp.w	r3, #2684354560	; 0xa0000000
 8024e48:	ea4f 7c13 	mov.w	ip, r3, lsr #28
      pbuf[ 2* idx] = (value >> 28) + '0';
 8024e4c:	f10c 0430 	add.w	r4, ip, #48	; 0x30
  for( idx = 0 ; idx < len ; idx ++)
 8024e50:	f10e 0e02 	add.w	lr, lr, #2
      pbuf[2* idx] = (value >> 28) + 'A' - 10;
 8024e54:	bf2a      	itet	cs
 8024e56:	f10c 0c37 	addcs.w	ip, ip, #55	; 0x37
      pbuf[ 2* idx] = (value >> 28) + '0';
 8024e5a:	7084      	strbcc	r4, [r0, #2]
      pbuf[2* idx] = (value >> 28) + 'A' - 10;
 8024e5c:	f880 c002 	strbcs.w	ip, [r0, #2]
  for( idx = 0 ; idx < len ; idx ++)
 8024e60:	f1be 0f10 	cmp.w	lr, #16
    pbuf[ 2* idx + 1] = 0;
 8024e64:	70c5      	strb	r5, [r0, #3]
    value = value << 4;
 8024e66:	ea4f 1303 	mov.w	r3, r3, lsl #4
  for( idx = 0 ; idx < len ; idx ++)
 8024e6a:	f100 0002 	add.w	r0, r0, #2
 8024e6e:	d1e9      	bne.n	8024e44 <USBD_SerialStrDescriptor+0x28>
 8024e70:	2000      	movs	r0, #0
    pbuf[ 2* idx + 1] = 0;
 8024e72:	4604      	mov	r4, r0
    if( ((value >> 28)) < 0xA )
 8024e74:	f1b1 4f20 	cmp.w	r1, #2684354560	; 0xa0000000
 8024e78:	ea4f 7311 	mov.w	r3, r1, lsr #28
      pbuf[ 2* idx] = (value >> 28) + '0';
 8024e7c:	f103 0c30 	add.w	ip, r3, #48	; 0x30
  for( idx = 0 ; idx < len ; idx ++)
 8024e80:	f100 0002 	add.w	r0, r0, #2
      pbuf[2* idx] = (value >> 28) + 'A' - 10;
 8024e84:	bf2a      	itet	cs
 8024e86:	3337      	addcs	r3, #55	; 0x37
      pbuf[ 2* idx] = (value >> 28) + '0';
 8024e88:	f882 c012 	strbcc.w	ip, [r2, #18]
      pbuf[2* idx] = (value >> 28) + 'A' - 10;
 8024e8c:	7493      	strbcs	r3, [r2, #18]
  for( idx = 0 ; idx < len ; idx ++)
 8024e8e:	2808      	cmp	r0, #8
    pbuf[ 2* idx + 1] = 0;
 8024e90:	74d4      	strb	r4, [r2, #19]
    value = value << 4;
 8024e92:	ea4f 1101 	mov.w	r1, r1, lsl #4
  for( idx = 0 ; idx < len ; idx ++)
 8024e96:	f102 0202 	add.w	r2, r2, #2
 8024e9a:	d1eb      	bne.n	8024e74 <USBD_SerialStrDescriptor+0x58>
}
 8024e9c:	4801      	ldr	r0, [pc, #4]	; (8024ea4 <USBD_SerialStrDescriptor+0x88>)
 8024e9e:	bd30      	pop	{r4, r5, pc}
 8024ea0:	1fff7000 	.word	0x1fff7000
 8024ea4:	20000dd4 	.word	0x20000dd4

08024ea8 <STORAGE_GetCapacity_FS>:
 * @param  block_size: Block size
 * @retval USBD_OK if all operations are OK else USBD_FAIL
 */
int8_t STORAGE_GetCapacity_FS(uint8_t lun, uint32_t *block_num, uint16_t *block_size)
{
  *block_num  = STORAGE_BLK_NBR;
 8024ea8:	f240 70ff 	movw	r0, #2047	; 0x7ff
  *block_size = STORAGE_BLK_SIZ;
 8024eac:	f44f 5380 	mov.w	r3, #4096	; 0x1000
  *block_num  = STORAGE_BLK_NBR;
 8024eb0:	6008      	str	r0, [r1, #0]
  return (USBD_OK);
}
 8024eb2:	2000      	movs	r0, #0
  *block_size = STORAGE_BLK_SIZ;
 8024eb4:	8013      	strh	r3, [r2, #0]
}
 8024eb6:	4770      	bx	lr

08024eb8 <STORAGE_IsWriteProtected_FS>:
 */
int8_t STORAGE_IsWriteProtected_FS(uint8_t lun)
{
  return (USBD_OK); /* Write enabled */
  //return -1; /* Read-only */
}
 8024eb8:	2000      	movs	r0, #0
 8024eba:	4770      	bx	lr

08024ebc <STORAGE_GetMaxLun_FS>:
 * @retval Lun(s) number
 */
int8_t STORAGE_GetMaxLun_FS(void)
{
  return (STORAGE_LUN_NBR - 1);
}
 8024ebc:	2000      	movs	r0, #0
 8024ebe:	4770      	bx	lr

08024ec0 <STORAGE_Write_FS>:
{
 8024ec0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8024ec4:	461c      	mov	r4, r3
 8024ec6:	4613      	mov	r3, r2
  uint32_t write_addr = (STORAGE_BLK_SIZ * blk_addr);
 8024ec8:	0317      	lsls	r7, r2, #12
  USBD_UsrLog("[USB STORAGE] Erase sector %lu, blk_len = %u\r\n", blk_addr, blk_len);
 8024eca:	483a      	ldr	r0, [pc, #232]	; (8024fb4 <STORAGE_Write_FS+0xf4>)
 8024ecc:	4622      	mov	r2, r4
{
 8024ece:	460e      	mov	r6, r1
  USBD_UsrLog("[USB STORAGE] Erase sector %lu, blk_len = %u\r\n", blk_addr, blk_len);
 8024ed0:	4619      	mov	r1, r3
 8024ed2:	f003 f8a3 	bl	802801c <iprintf>
  uint32_t buffer_size = (STORAGE_BLK_SIZ * blk_len);
 8024ed6:	ea4f 3804 	mov.w	r8, r4, lsl #12
  USBD_UsrLog("[USB STORAGE] Erase sector %lu, blk_len = %u\r\n", blk_addr, blk_len);
 8024eda:	200a      	movs	r0, #10
 8024edc:	f003 f8b6 	bl	802804c <putchar>
  USBD_UsrLog("[USB STORAGE] Write %lu Bytes @ %#lx\r\n", buffer_size, write_addr);
 8024ee0:	463a      	mov	r2, r7
 8024ee2:	4641      	mov	r1, r8
 8024ee4:	4834      	ldr	r0, [pc, #208]	; (8024fb8 <STORAGE_Write_FS+0xf8>)
 8024ee6:	f003 f899 	bl	802801c <iprintf>
 8024eea:	200a      	movs	r0, #10
 8024eec:	f003 f8ae 	bl	802804c <putchar>
  if (blk_len != 1) {
 8024ef0:	2c01      	cmp	r4, #1
 8024ef2:	d006      	beq.n	8024f02 <STORAGE_Write_FS+0x42>
    USBD_UsrLog("[USB STORAGE] blk_len !=1 not supported\r\n");
 8024ef4:	4831      	ldr	r0, [pc, #196]	; (8024fbc <STORAGE_Write_FS+0xfc>)
 8024ef6:	f003 f92d 	bl	8028154 <puts>
 8024efa:	200a      	movs	r0, #10
 8024efc:	f003 f8a6 	bl	802804c <putchar>
    while(1);
 8024f00:	e7fe      	b.n	8024f00 <STORAGE_Write_FS+0x40>
  if (BSP_QSPI_Erase_Block(0, write_addr, BSP_QSPI_ERASE_4K) != BSP_ERROR_NONE)
 8024f02:	2200      	movs	r2, #0
 8024f04:	4639      	mov	r1, r7
 8024f06:	4610      	mov	r0, r2
 8024f08:	f7e7 feba 	bl	800cc80 <BSP_QSPI_Erase_Block>
 8024f0c:	bb88      	cbnz	r0, 8024f72 <STORAGE_Write_FS+0xb2>
  BSP_QSPIEx_WaitForEndOfOperation(0, 300);
 8024f0e:	f44f 7196 	mov.w	r1, #300	; 0x12c
 8024f12:	f7ff fd83 	bl	8024a1c <BSP_QSPIEx_WaitForEndOfOperation>
  while(BSP_QSPI_GetStatus(0) != BSP_ERROR_NONE)
 8024f16:	4d2a      	ldr	r5, [pc, #168]	; (8024fc0 <STORAGE_Write_FS+0x100>)
 8024f18:	e001      	b.n	8024f1e <STORAGE_Write_FS+0x5e>
    if (timeout-- == 0)
 8024f1a:	3d01      	subs	r5, #1
 8024f1c:	d039      	beq.n	8024f92 <STORAGE_Write_FS+0xd2>
  while(BSP_QSPI_GetStatus(0) != BSP_ERROR_NONE)
 8024f1e:	2000      	movs	r0, #0
 8024f20:	f7e7 feca 	bl	800ccb8 <BSP_QSPI_GetStatus>
 8024f24:	4604      	mov	r4, r0
 8024f26:	2800      	cmp	r0, #0
 8024f28:	d1f7      	bne.n	8024f1a <STORAGE_Write_FS+0x5a>
  USBD_UsrLog("[USB STORAGE] Erase Ok\r\n");
 8024f2a:	4826      	ldr	r0, [pc, #152]	; (8024fc4 <STORAGE_Write_FS+0x104>)
 8024f2c:	f003 f912 	bl	8028154 <puts>
 8024f30:	200a      	movs	r0, #10
 8024f32:	f003 f88b 	bl	802804c <putchar>
  if (BSP_QSPI_Write(0, buf, write_addr, buffer_size) != BSP_ERROR_NONE)
 8024f36:	4643      	mov	r3, r8
 8024f38:	463a      	mov	r2, r7
 8024f3a:	4631      	mov	r1, r6
 8024f3c:	4620      	mov	r0, r4
 8024f3e:	f7e7 fe59 	bl	800cbf4 <BSP_QSPI_Write>
 8024f42:	b9f0      	cbnz	r0, 8024f82 <STORAGE_Write_FS+0xc2>
  BSP_QSPIEx_WaitForEndOfOperation(0, 300);
 8024f44:	f44f 7196 	mov.w	r1, #300	; 0x12c
 8024f48:	f7ff fd68 	bl	8024a1c <BSP_QSPIEx_WaitForEndOfOperation>
  while(BSP_QSPI_GetStatus(0) != BSP_ERROR_NONE)
 8024f4c:	4d1c      	ldr	r5, [pc, #112]	; (8024fc0 <STORAGE_Write_FS+0x100>)
 8024f4e:	e001      	b.n	8024f54 <STORAGE_Write_FS+0x94>
    if (timeout-- == 0)
 8024f50:	3d01      	subs	r5, #1
 8024f52:	d026      	beq.n	8024fa2 <STORAGE_Write_FS+0xe2>
  while(BSP_QSPI_GetStatus(0) != BSP_ERROR_NONE)
 8024f54:	2000      	movs	r0, #0
 8024f56:	f7e7 feaf 	bl	800ccb8 <BSP_QSPI_GetStatus>
 8024f5a:	4604      	mov	r4, r0
 8024f5c:	2800      	cmp	r0, #0
 8024f5e:	d1f7      	bne.n	8024f50 <STORAGE_Write_FS+0x90>
  USBD_UsrLog("[USB STORAGE] Write Ok\r\n");
 8024f60:	4819      	ldr	r0, [pc, #100]	; (8024fc8 <STORAGE_Write_FS+0x108>)
 8024f62:	f003 f8f7 	bl	8028154 <puts>
 8024f66:	200a      	movs	r0, #10
 8024f68:	f003 f870 	bl	802804c <putchar>
  return (USBD_OK);
 8024f6c:	4620      	mov	r0, r4
}
 8024f6e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    USBD_UsrLog("[USB STORAGE] Erase Sector FAIL\r\n");
 8024f72:	4816      	ldr	r0, [pc, #88]	; (8024fcc <STORAGE_Write_FS+0x10c>)
 8024f74:	f003 f8ee 	bl	8028154 <puts>
 8024f78:	200a      	movs	r0, #10
 8024f7a:	f003 f867 	bl	802804c <putchar>
    return USBD_FAIL;
 8024f7e:	2002      	movs	r0, #2
 8024f80:	e7f5      	b.n	8024f6e <STORAGE_Write_FS+0xae>
    USBD_UsrLog("[USB STORAGE] Write FAIL\r\n");
 8024f82:	4813      	ldr	r0, [pc, #76]	; (8024fd0 <STORAGE_Write_FS+0x110>)
 8024f84:	f003 f8e6 	bl	8028154 <puts>
 8024f88:	200a      	movs	r0, #10
 8024f8a:	f003 f85f 	bl	802804c <putchar>
    return USBD_FAIL;
 8024f8e:	2002      	movs	r0, #2
 8024f90:	e7ed      	b.n	8024f6e <STORAGE_Write_FS+0xae>
      USBD_UsrLog("[USB STORAGE] Erase wait FAIL\r\n");
 8024f92:	4810      	ldr	r0, [pc, #64]	; (8024fd4 <STORAGE_Write_FS+0x114>)
 8024f94:	f003 f8de 	bl	8028154 <puts>
 8024f98:	200a      	movs	r0, #10
 8024f9a:	f003 f857 	bl	802804c <putchar>
      return USBD_FAIL;
 8024f9e:	2002      	movs	r0, #2
 8024fa0:	e7e5      	b.n	8024f6e <STORAGE_Write_FS+0xae>
      USBD_UsrLog("[USB STORAGE] Write wait FAIL\r\n");
 8024fa2:	480d      	ldr	r0, [pc, #52]	; (8024fd8 <STORAGE_Write_FS+0x118>)
 8024fa4:	f003 f8d6 	bl	8028154 <puts>
 8024fa8:	200a      	movs	r0, #10
 8024faa:	f003 f84f 	bl	802804c <putchar>
      return USBD_FAIL;
 8024fae:	2002      	movs	r0, #2
 8024fb0:	e7dd      	b.n	8024f6e <STORAGE_Write_FS+0xae>
 8024fb2:	bf00      	nop
 8024fb4:	08044198 	.word	0x08044198
 8024fb8:	080441c8 	.word	0x080441c8
 8024fbc:	080441f0 	.word	0x080441f0
 8024fc0:	000186a1 	.word	0x000186a1
 8024fc4:	08044260 	.word	0x08044260
 8024fc8:	080442b4 	.word	0x080442b4
 8024fcc:	0804421c 	.word	0x0804421c
 8024fd0:	08044278 	.word	0x08044278
 8024fd4:	08044240 	.word	0x08044240
 8024fd8:	08044294 	.word	0x08044294

08024fdc <STORAGE_Read_FS>:
{
 8024fdc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8024fde:	461c      	mov	r4, r3
 8024fe0:	4613      	mov	r3, r2
  uint32_t read_addr = (STORAGE_BLK_SIZ * blk_addr);
 8024fe2:	0316      	lsls	r6, r2, #12
  USBD_UsrLog("[USB STORAGE] Read sector %lu, blk_len = %u\r\n", blk_addr, blk_len);
 8024fe4:	481b      	ldr	r0, [pc, #108]	; (8025054 <STORAGE_Read_FS+0x78>)
 8024fe6:	4622      	mov	r2, r4
{
 8024fe8:	460d      	mov	r5, r1
  USBD_UsrLog("[USB STORAGE] Read sector %lu, blk_len = %u\r\n", blk_addr, blk_len);
 8024fea:	4619      	mov	r1, r3
 8024fec:	f003 f816 	bl	802801c <iprintf>
  uint32_t buffer_size = (STORAGE_BLK_SIZ * blk_len);
 8024ff0:	0327      	lsls	r7, r4, #12
  USBD_UsrLog("[USB STORAGE] Read sector %lu, blk_len = %u\r\n", blk_addr, blk_len);
 8024ff2:	200a      	movs	r0, #10
 8024ff4:	f003 f82a 	bl	802804c <putchar>
  USBD_UsrLog("[USB STORAGE] Read %lu Bytes @ %#lx\r\n", buffer_size, read_addr);
 8024ff8:	4817      	ldr	r0, [pc, #92]	; (8025058 <STORAGE_Read_FS+0x7c>)
 8024ffa:	4632      	mov	r2, r6
 8024ffc:	4639      	mov	r1, r7
 8024ffe:	f003 f80d 	bl	802801c <iprintf>
 8025002:	200a      	movs	r0, #10
 8025004:	f003 f822 	bl	802804c <putchar>
  if (blk_len == 0) return USBD_OK;
 8025008:	b90c      	cbnz	r4, 802500e <STORAGE_Read_FS+0x32>
 802500a:	4620      	mov	r0, r4
}
 802500c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  if (BSP_QSPI_Read(0, buf, read_addr, buffer_size) != BSP_ERROR_NONE)
 802500e:	463b      	mov	r3, r7
 8025010:	4632      	mov	r2, r6
 8025012:	4629      	mov	r1, r5
 8025014:	2000      	movs	r0, #0
 8025016:	f7e7 fdd5 	bl	800cbc4 <BSP_QSPI_Read>
 802501a:	b988      	cbnz	r0, 8025040 <STORAGE_Read_FS+0x64>
 802501c:	4d0f      	ldr	r5, [pc, #60]	; (802505c <STORAGE_Read_FS+0x80>)
 802501e:	e001      	b.n	8025024 <STORAGE_Read_FS+0x48>
    if (timeout-- == 0)
 8025020:	3d01      	subs	r5, #1
 8025022:	d00f      	beq.n	8025044 <STORAGE_Read_FS+0x68>
  while(BSP_QSPI_GetStatus(0) != BSP_ERROR_NONE)
 8025024:	2000      	movs	r0, #0
 8025026:	f7e7 fe47 	bl	800ccb8 <BSP_QSPI_GetStatus>
 802502a:	4604      	mov	r4, r0
 802502c:	2800      	cmp	r0, #0
 802502e:	d1f7      	bne.n	8025020 <STORAGE_Read_FS+0x44>
  USBD_UsrLog("[USB STORAGE] Read Ok\r\n");
 8025030:	480b      	ldr	r0, [pc, #44]	; (8025060 <STORAGE_Read_FS+0x84>)
 8025032:	f003 f88f 	bl	8028154 <puts>
 8025036:	200a      	movs	r0, #10
 8025038:	f003 f808 	bl	802804c <putchar>
  return (USBD_OK);
 802503c:	4620      	mov	r0, r4
}
 802503e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    return USBD_FAIL;
 8025040:	2002      	movs	r0, #2
}
 8025042:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      USBD_UsrLog("[USB STORAGE] Read FAIL\r\n");
 8025044:	4807      	ldr	r0, [pc, #28]	; (8025064 <STORAGE_Read_FS+0x88>)
 8025046:	f003 f885 	bl	8028154 <puts>
 802504a:	200a      	movs	r0, #10
 802504c:	f002 fffe 	bl	802804c <putchar>
      return USBD_FAIL;
 8025050:	2002      	movs	r0, #2
}
 8025052:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8025054:	080442cc 	.word	0x080442cc
 8025058:	080442fc 	.word	0x080442fc
 802505c:	000186a1 	.word	0x000186a1
 8025060:	08044340 	.word	0x08044340
 8025064:	08044324 	.word	0x08044324

08025068 <STORAGE_Init_FS>:
{
 8025068:	b510      	push	{r4, lr}
  QSPI_InitStruct.InterfaceMode = BSP_QSPI_QUAD_IO_MODE;
 802506a:	2304      	movs	r3, #4
{
 802506c:	b082      	sub	sp, #8
  status = BSP_QSPI_Init(0, &QSPI_InitStruct);
 802506e:	eb0d 0103 	add.w	r1, sp, r3
 8025072:	2000      	movs	r0, #0
  QSPI_InitStruct.InterfaceMode = BSP_QSPI_QUAD_IO_MODE;
 8025074:	f88d 3004 	strb.w	r3, [sp, #4]
  status = BSP_QSPI_Init(0, &QSPI_InitStruct);
 8025078:	f7e7 fec2 	bl	800ce00 <BSP_QSPI_Init>
  if (status != BSP_ERROR_NONE)
 802507c:	f010 04ff 	ands.w	r4, r0, #255	; 0xff
 8025080:	d00f      	beq.n	80250a2 <STORAGE_Init_FS+0x3a>
    USBD_UsrLog("[USB STORAGE] QSPI Init: FAILED, QSPI Test Aborted\r\n");
 8025082:	480b      	ldr	r0, [pc, #44]	; (80250b0 <STORAGE_Init_FS+0x48>)
 8025084:	f003 f866 	bl	8028154 <puts>
 8025088:	200a      	movs	r0, #10
 802508a:	f002 ffdf 	bl	802804c <putchar>
    status = USBD_FAIL;
 802508e:	2402      	movs	r4, #2
  USBD_UsrLog("[USB STORAGE] Init ---------------------------------------\r\n");
 8025090:	4808      	ldr	r0, [pc, #32]	; (80250b4 <STORAGE_Init_FS+0x4c>)
 8025092:	f003 f85f 	bl	8028154 <puts>
 8025096:	200a      	movs	r0, #10
 8025098:	f002 ffd8 	bl	802804c <putchar>
}
 802509c:	4620      	mov	r0, r4
 802509e:	b002      	add	sp, #8
 80250a0:	bd10      	pop	{r4, pc}
    USBD_UsrLog("[USB STORAGE] QSPI Init: OK\r\n");
 80250a2:	4805      	ldr	r0, [pc, #20]	; (80250b8 <STORAGE_Init_FS+0x50>)
 80250a4:	f003 f856 	bl	8028154 <puts>
 80250a8:	200a      	movs	r0, #10
 80250aa:	f002 ffcf 	bl	802804c <putchar>
    status = USBD_OK;
 80250ae:	e7ef      	b.n	8025090 <STORAGE_Init_FS+0x28>
 80250b0:	08044358 	.word	0x08044358
 80250b4:	080443ac 	.word	0x080443ac
 80250b8:	0804438c 	.word	0x0804438c

080250bc <STORAGE_IsReady_FS>:
{
 80250bc:	b510      	push	{r4, lr}
  if (BSP_QSPI_GetStatus(0) != BSP_ERROR_NONE) {
 80250be:	2000      	movs	r0, #0
 80250c0:	f7e7 fdfa 	bl	800ccb8 <BSP_QSPI_GetStatus>
 80250c4:	b138      	cbz	r0, 80250d6 <STORAGE_IsReady_FS+0x1a>
    USBD_UsrLog("[USB STORAGE] Busy\r\n");
 80250c6:	4808      	ldr	r0, [pc, #32]	; (80250e8 <STORAGE_IsReady_FS+0x2c>)
 80250c8:	f003 f844 	bl	8028154 <puts>
 80250cc:	200a      	movs	r0, #10
 80250ce:	f002 ffbd 	bl	802804c <putchar>
 80250d2:	2001      	movs	r0, #1
}
 80250d4:	bd10      	pop	{r4, pc}
 80250d6:	4604      	mov	r4, r0
    USBD_UsrLog("[USB STORAGE] IsReady\r\n");
 80250d8:	4804      	ldr	r0, [pc, #16]	; (80250ec <STORAGE_IsReady_FS+0x30>)
 80250da:	f003 f83b 	bl	8028154 <puts>
 80250de:	200a      	movs	r0, #10
 80250e0:	f002 ffb4 	bl	802804c <putchar>
    ret = USBD_OK;
 80250e4:	4620      	mov	r0, r4
}
 80250e6:	bd10      	pop	{r4, pc}
 80250e8:	080443e8 	.word	0x080443e8
 80250ec:	080443fc 	.word	0x080443fc

080250f0 <har_postProcInit>:
    }
  }
  return max_idx;
}
void har_postProcInit(HAR_algoIdx_t algo)
{
 80250f0:	b510      	push	{r4, lr}
 80250f2:	4604      	mov	r4, r0
  int i ;
  int size     = aiGetReport(algo)->outputs[0].channels;
 80250f4:	f7fb f9d6 	bl	80204a4 <aiGetReport>
 80250f8:	6b83      	ldr	r3, [r0, #56]	; 0x38
 80250fa:	68da      	ldr	r2, [r3, #12]

  for (i = 0; i < size; ++i) {
 80250fc:	2a00      	cmp	r2, #0
 80250fe:	dd08      	ble.n	8025112 <har_postProcInit+0x22>
    last_scores[algo][i] = 0.0F;
 8025100:	4b10      	ldr	r3, [pc, #64]	; (8025144 <har_postProcInit+0x54>)
 8025102:	eb04 0084 	add.w	r0, r4, r4, lsl #2
 8025106:	0092      	lsls	r2, r2, #2
 8025108:	2100      	movs	r1, #0
 802510a:	eb03 0080 	add.w	r0, r3, r0, lsl #2
 802510e:	f002 fa33 	bl	8027578 <memset>
  }

  if (HAR_IGN_IDX == algo ) 
 8025112:	2c01      	cmp	r4, #1
 8025114:	d00a      	beq.n	802512c <har_postProcInit+0x3c>
      raw_predictions_IGN [i] = 0.0F;
    }
    last_prediction_IGN = AR_ID_STATIONARY_IGN;
    index_IGN = 0; 
  }
  else if (HAR_GMP_IDX == algo ) 
 8025116:	b944      	cbnz	r4, 802512a <har_postProcInit+0x3a>
  {
    for (i = 0; i < TF_WINDOW; ++i) {
      raw_predictions_GMP [i] = 0.0F;
 8025118:	4b0a      	ldr	r3, [pc, #40]	; (8025144 <har_postProcInit+0x54>)
 802511a:	649c      	str	r4, [r3, #72]	; 0x48
    }
    last_prediction_GMP = AR_ID_STATIONARY_GMP;
 802511c:	f883 4052 	strb.w	r4, [r3, #82]	; 0x52
    index_GMP = 0; 
 8025120:	f883 4053 	strb.w	r4, [r3, #83]	; 0x53
      raw_predictions_GMP [i] = 0.0F;
 8025124:	64dc      	str	r4, [r3, #76]	; 0x4c
 8025126:	f8a3 4050 	strh.w	r4, [r3, #80]	; 0x50
  }
}
 802512a:	bd10      	pop	{r4, pc}
      raw_predictions_IGN [i] = 0.0F;
 802512c:	4a05      	ldr	r2, [pc, #20]	; (8025144 <har_postProcInit+0x54>)
    last_prediction_IGN = AR_ID_STATIONARY_IGN;
 802512e:	4806      	ldr	r0, [pc, #24]	; (8025148 <har_postProcInit+0x58>)
      raw_predictions_IGN [i] = 0.0F;
 8025130:	2300      	movs	r3, #0
 8025132:	e9c2 330f 	strd	r3, r3, [r2, #60]	; 0x3c
    last_prediction_IGN = AR_ID_STATIONARY_IGN;
 8025136:	2403      	movs	r4, #3
      raw_predictions_IGN [i] = 0.0F;
 8025138:	f8a2 3044 	strh.w	r3, [r2, #68]	; 0x44
    last_prediction_IGN = AR_ID_STATIONARY_IGN;
 802513c:	7004      	strb	r4, [r0, #0]
    index_IGN = 0; 
 802513e:	f882 3046 	strb.w	r3, [r2, #70]	; 0x46
}
 8025142:	bd10      	pop	{r4, pc}
 8025144:	20014b00 	.word	0x20014b00
 8025148:	20000e2c 	.word	0x20000e2c

0802514c <har_postProc>:

/* Exported Functions ---------------------------------------------*/
HAR_output_t har_postProc(float * scores,HAR_algoIdx_t algo)
{
 802514c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 802514e:	4604      	mov	r4, r0
  uint8_t predict, predictFilt;
  int size     = aiGetReport(algo)->outputs[0].channels ;
 8025150:	4608      	mov	r0, r1
{
 8025152:	460d      	mov	r5, r1
  int size     = aiGetReport(algo)->outputs[0].channels ;
 8025154:	f7fb f9a6 	bl	80204a4 <aiGetReport>
 8025158:	6b83      	ldr	r3, [r0, #56]	; 0x38
 802515a:	68de      	ldr	r6, [r3, #12]

//  SENSING1_PRINTF("\r\n");
  for (int i = 0; i < size; ++i) {
 802515c:	2e00      	cmp	r6, #0
 802515e:	f340 80be 	ble.w	80252de <har_postProc+0x192>
 8025162:	4b75      	ldr	r3, [pc, #468]	; (8025338 <har_postProc+0x1ec>)
    last_scores[algo][i] = (1.0f - FILT_ALPHA) * last_scores[algo][i] + FILT_ALPHA * scores[i];
 8025164:	ed9f 6a75 	vldr	s12, [pc, #468]	; 802533c <har_postProc+0x1f0>
 8025168:	eddf 6a75 	vldr	s13, [pc, #468]	; 8025340 <har_postProc+0x1f4>
 802516c:	4620      	mov	r0, r4
 802516e:	eb05 0485 	add.w	r4, r5, r5, lsl #2
 8025172:	eb03 0484 	add.w	r4, r3, r4, lsl #2
 8025176:	00a9      	lsls	r1, r5, #2
 8025178:	eb00 0286 	add.w	r2, r0, r6, lsl #2
  for (int i = 0; i < size; ++i) {
 802517c:	4623      	mov	r3, r4
    last_scores[algo][i] = (1.0f - FILT_ALPHA) * last_scores[algo][i] + FILT_ALPHA * scores[i];
 802517e:	ecb0 7a01 	vldmia	r0!, {s14}
 8025182:	edd3 7a00 	vldr	s15, [r3]
 8025186:	ee27 7a26 	vmul.f32	s14, s14, s13
 802518a:	ee67 7a86 	vmul.f32	s15, s15, s12
  for (int i = 0; i < size; ++i) {
 802518e:	4282      	cmp	r2, r0
    last_scores[algo][i] = (1.0f - FILT_ALPHA) * last_scores[algo][i] + FILT_ALPHA * scores[i];
 8025190:	ee77 7a87 	vadd.f32	s15, s15, s14
 8025194:	ece3 7a01 	vstmia	r3!, {s15}
  for (int i = 0; i < size; ++i) {
 8025198:	d1f1      	bne.n	802517e <har_postProc+0x32>
 802519a:	2200      	movs	r2, #0
 802519c:	ed9f 7a69 	vldr	s14, [pc, #420]	; 8025344 <har_postProc+0x1f8>
 80251a0:	4613      	mov	r3, r2
    if (array[i] > max) {
 80251a2:	ecf4 7a01 	vldmia	r4!, {s15}
 80251a6:	eef4 7ac7 	vcmpe.f32	s15, s14
 80251aa:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80251ae:	bfc8      	it	gt
 80251b0:	b2da      	uxtbgt	r2, r3
  for (int i = 0; i < size; ++i) {
 80251b2:	f103 0301 	add.w	r3, r3, #1
      max = array[i]; max_idx = i;
 80251b6:	bfc8      	it	gt
 80251b8:	eeb0 7a67 	vmovgt.f32	s14, s15
  for (int i = 0; i < size; ++i) {
 80251bc:	429e      	cmp	r6, r3
 80251be:	d1f0      	bne.n	80251a2 <har_postProc+0x56>
//    SENSING1_PRINTF("(%f)%f ", scores[i], last_scores[algo][i]);
  }

  predict = argmax(last_scores[algo],size);

  if (HAR_IGN_WSDM_IDX == algo ) 
 80251c0:	2d02      	cmp	r5, #2
 80251c2:	d01a      	beq.n	80251fa <har_postProc+0xae>
  {
    predictFilt = predict;
  }
  else if (HAR_IGN_IDX == algo ) 
 80251c4:	2d01      	cmp	r5, #1
  raw_predictions_IGN[index_IGN] = prediction;
 80251c6:	4b5c      	ldr	r3, [pc, #368]	; (8025338 <har_postProc+0x1ec>)
  else if (HAR_IGN_IDX == algo ) 
 80251c8:	d01c      	beq.n	8025204 <har_postProc+0xb8>
  raw_predictions_GMP[index_GMP] = prediction;
 80251ca:	f893 0053 	ldrb.w	r0, [r3, #83]	; 0x53
  index_GMP = (index_GMP + 1) % TF_WINDOW;
 80251ce:	4f5e      	ldr	r7, [pc, #376]	; (8025348 <har_postProc+0x1fc>)
 80251d0:	1c46      	adds	r6, r0, #1
  raw_predictions_GMP[index_GMP] = prediction;
 80251d2:	4418      	add	r0, r3
 80251d4:	f880 2048 	strb.w	r2, [r0, #72]	; 0x48
  index_GMP = (index_GMP + 1) % TF_WINDOW;
 80251d8:	fba7 0406 	umull	r0, r4, r7, r6
 80251dc:	08e4      	lsrs	r4, r4, #3
 80251de:	eb04 0484 	add.w	r4, r4, r4, lsl #2
 80251e2:	eba6 0444 	sub.w	r4, r6, r4, lsl #1
  if (prediction == AR_ID_BIKING_GMP || prediction == AR_ID_DRIVING_GMP) {
 80251e6:	1ed6      	subs	r6, r2, #3
  index_GMP = (index_GMP + 1) % TF_WINDOW;
 80251e8:	b2e0      	uxtb	r0, r4
  if (prediction == AR_ID_BIKING_GMP || prediction == AR_ID_DRIVING_GMP) {
 80251ea:	2e01      	cmp	r6, #1
  index_GMP = (index_GMP + 1) % TF_WINDOW;
 80251ec:	f883 0053 	strb.w	r0, [r3, #83]	; 0x53
  if (prediction == AR_ID_BIKING_GMP || prediction == AR_ID_DRIVING_GMP) {
 80251f0:	d965      	bls.n	80252be <har_postProc+0x172>
  if (prediction == AR_ID_WALKING_GMP) {
 80251f2:	2a01      	cmp	r2, #1
 80251f4:	d039      	beq.n	802526a <har_postProc+0x11e>
  if (update) last_prediction_GMP = prediction;
 80251f6:	f883 2052 	strb.w	r2, [r3, #82]	; 0x52
  }
  else
  {
    predictFilt = fmlp_temporal_filter_GMP(predict);
  }
  return AR_ID_MAPPER[algo][predictFilt];
 80251fa:	4b54      	ldr	r3, [pc, #336]	; (802534c <har_postProc+0x200>)
 80251fc:	4429      	add	r1, r5
 80251fe:	4419      	add	r1, r3
 8025200:	5c88      	ldrb	r0, [r1, r2]
}
 8025202:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  raw_predictions_IGN[index_IGN] = prediction;
 8025204:	f893 0046 	ldrb.w	r0, [r3, #70]	; 0x46
  index_IGN = (index_IGN + 1) % TF_WINDOW;
 8025208:	f8df c13c 	ldr.w	ip, [pc, #316]	; 8025348 <har_postProc+0x1fc>
 802520c:	1c44      	adds	r4, r0, #1
  raw_predictions_IGN[index_IGN] = prediction;
 802520e:	4418      	add	r0, r3
  if (prediction == AR_ID_BIKING_IGN || prediction == AR_ID_DRIVING_IGN) {
 8025210:	2a01      	cmp	r2, #1
  raw_predictions_IGN[index_IGN] = prediction;
 8025212:	f880 203c 	strb.w	r2, [r0, #60]	; 0x3c
  index_IGN = (index_IGN + 1) % TF_WINDOW;
 8025216:	fbac 6004 	umull	r6, r0, ip, r4
 802521a:	ea4f 00d0 	mov.w	r0, r0, lsr #3
 802521e:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 8025222:	eba4 0040 	sub.w	r0, r4, r0, lsl #1
 8025226:	b2c4      	uxtb	r4, r0
 8025228:	f883 4046 	strb.w	r4, [r3, #70]	; 0x46
  if (prediction == AR_ID_BIKING_IGN || prediction == AR_ID_DRIVING_IGN) {
 802522c:	d908      	bls.n	8025240 <har_postProc+0xf4>
  if (prediction == AR_ID_WALKING_IGN) {
 802522e:	2a04      	cmp	r2, #4
 8025230:	d058      	beq.n	80252e4 <har_postProc+0x198>
 8025232:	4b47      	ldr	r3, [pc, #284]	; (8025350 <har_postProc+0x204>)
  if (update) last_prediction_IGN = prediction;
 8025234:	701a      	strb	r2, [r3, #0]
  return AR_ID_MAPPER[algo][predictFilt];
 8025236:	4b45      	ldr	r3, [pc, #276]	; (802534c <har_postProc+0x200>)
 8025238:	4429      	add	r1, r5
 802523a:	4419      	add	r1, r3
 802523c:	5c88      	ldrb	r0, [r1, r2]
}
 802523e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8025240:	f103 043c 	add.w	r4, r3, #60	; 0x3c
  int16_t count = 0;
 8025244:	2000      	movs	r0, #0
 8025246:	3346      	adds	r3, #70	; 0x46
      count += (raw_predictions_IGN[i] == prediction);
 8025248:	f814 6b01 	ldrb.w	r6, [r4], #1
 802524c:	4296      	cmp	r6, r2
 802524e:	bf08      	it	eq
 8025250:	3001      	addeq	r0, #1
    for (uint8_t i = 0; i < TF_WINDOW; ++i) {
 8025252:	42a3      	cmp	r3, r4
      count += (raw_predictions_IGN[i] == prediction);
 8025254:	b200      	sxth	r0, r0
    for (uint8_t i = 0; i < TF_WINDOW; ++i) {
 8025256:	d1f7      	bne.n	8025248 <har_postProc+0xfc>
  if (update) last_prediction_IGN = prediction;
 8025258:	2807      	cmp	r0, #7
 802525a:	4b3d      	ldr	r3, [pc, #244]	; (8025350 <har_postProc+0x204>)
 802525c:	dcea      	bgt.n	8025234 <har_postProc+0xe8>
  return last_prediction_IGN;
 802525e:	781a      	ldrb	r2, [r3, #0]
  return AR_ID_MAPPER[algo][predictFilt];
 8025260:	4b3a      	ldr	r3, [pc, #232]	; (802534c <har_postProc+0x200>)
 8025262:	4429      	add	r1, r5
 8025264:	4419      	add	r1, r3
 8025266:	5c88      	ldrb	r0, [r1, r2]
}
 8025268:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    for (uint8_t i = index_GMP + TF_WINDOW - TF_WALK_WINDOW; i < index_GMP + TF_WINDOW; ++i) {
 802526a:	3003      	adds	r0, #3
 802526c:	b2c0      	uxtb	r0, r0
 802526e:	f104 0c09 	add.w	ip, r4, #9
 8025272:	4584      	cmp	ip, r0
 8025274:	f04f 0600 	mov.w	r6, #0
 8025278:	db12      	blt.n	80252a0 <har_postProc+0x154>
      count += (raw_predictions_GMP[i % TF_WINDOW] == prediction);
 802527a:	fba7 e400 	umull	lr, r4, r7, r0
 802527e:	08e4      	lsrs	r4, r4, #3
 8025280:	eb04 0484 	add.w	r4, r4, r4, lsl #2
 8025284:	eba0 0444 	sub.w	r4, r0, r4, lsl #1
 8025288:	fa53 f484 	uxtab	r4, r3, r4
    for (uint8_t i = index_GMP + TF_WINDOW - TF_WALK_WINDOW; i < index_GMP + TF_WINDOW; ++i) {
 802528c:	3001      	adds	r0, #1
      count += (raw_predictions_GMP[i % TF_WINDOW] == prediction);
 802528e:	f894 4048 	ldrb.w	r4, [r4, #72]	; 0x48
    for (uint8_t i = index_GMP + TF_WINDOW - TF_WALK_WINDOW; i < index_GMP + TF_WINDOW; ++i) {
 8025292:	b2c0      	uxtb	r0, r0
      count += (raw_predictions_GMP[i % TF_WINDOW] == prediction);
 8025294:	2c01      	cmp	r4, #1
 8025296:	bf08      	it	eq
 8025298:	3601      	addeq	r6, #1
    for (uint8_t i = index_GMP + TF_WINDOW - TF_WALK_WINDOW; i < index_GMP + TF_WINDOW; ++i) {
 802529a:	4560      	cmp	r0, ip
      count += (raw_predictions_GMP[i % TF_WINDOW] == prediction);
 802529c:	b236      	sxth	r6, r6
    for (uint8_t i = index_GMP + TF_WINDOW - TF_WALK_WINDOW; i < index_GMP + TF_WINDOW; ++i) {
 802529e:	ddec      	ble.n	802527a <har_postProc+0x12e>
    int16_t walk_threshold =
 80252a0:	f893 0052 	ldrb.w	r0, [r3, #82]	; 0x52
 80252a4:	2800      	cmp	r0, #0
 80252a6:	bf0c      	ite	eq
 80252a8:	2005      	moveq	r0, #5
 80252aa:	2002      	movne	r0, #2
  if (update) last_prediction_GMP = prediction;
 80252ac:	42b0      	cmp	r0, r6
 80252ae:	dba2      	blt.n	80251f6 <har_postProc+0xaa>
  return last_prediction_GMP;
 80252b0:	f893 2052 	ldrb.w	r2, [r3, #82]	; 0x52
  return AR_ID_MAPPER[algo][predictFilt];
 80252b4:	4b25      	ldr	r3, [pc, #148]	; (802534c <har_postProc+0x200>)
 80252b6:	4429      	add	r1, r5
 80252b8:	4419      	add	r1, r3
 80252ba:	5c88      	ldrb	r0, [r1, r2]
}
 80252bc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80252be:	f103 0448 	add.w	r4, r3, #72	; 0x48
 80252c2:	f103 0752 	add.w	r7, r3, #82	; 0x52
  int16_t count = 0;
 80252c6:	2000      	movs	r0, #0
      count += (raw_predictions_GMP[i] == prediction);
 80252c8:	f814 6b01 	ldrb.w	r6, [r4], #1
 80252cc:	4296      	cmp	r6, r2
 80252ce:	bf08      	it	eq
 80252d0:	3001      	addeq	r0, #1
    for (uint8_t i = 0; i < TF_WINDOW; ++i) {
 80252d2:	42a7      	cmp	r7, r4
      count += (raw_predictions_GMP[i] == prediction);
 80252d4:	b200      	sxth	r0, r0
    for (uint8_t i = 0; i < TF_WINDOW; ++i) {
 80252d6:	d1f7      	bne.n	80252c8 <har_postProc+0x17c>
  if (update) last_prediction_GMP = prediction;
 80252d8:	2807      	cmp	r0, #7
 80252da:	dde9      	ble.n	80252b0 <har_postProc+0x164>
 80252dc:	e78b      	b.n	80251f6 <har_postProc+0xaa>
  uint8_t max_idx = 0;
 80252de:	2200      	movs	r2, #0
 80252e0:	00a9      	lsls	r1, r5, #2
 80252e2:	e76d      	b.n	80251c0 <har_postProc+0x74>
    for (uint8_t i = index_IGN + TF_WINDOW - TF_WALK_WINDOW; i < index_IGN + TF_WINDOW; ++i) {
 80252e4:	3403      	adds	r4, #3
 80252e6:	b2e4      	uxtb	r4, r4
 80252e8:	f100 0709 	add.w	r7, r0, #9
 80252ec:	42a7      	cmp	r7, r4
 80252ee:	db1d      	blt.n	802532c <har_postProc+0x1e0>
 80252f0:	2600      	movs	r6, #0
      count += (raw_predictions_IGN[i % TF_WINDOW] == prediction);
 80252f2:	fbac e004 	umull	lr, r0, ip, r4
 80252f6:	08c0      	lsrs	r0, r0, #3
 80252f8:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 80252fc:	eba4 0040 	sub.w	r0, r4, r0, lsl #1
 8025300:	fa53 f080 	uxtab	r0, r3, r0
    for (uint8_t i = index_IGN + TF_WINDOW - TF_WALK_WINDOW; i < index_IGN + TF_WINDOW; ++i) {
 8025304:	3401      	adds	r4, #1
      count += (raw_predictions_IGN[i % TF_WINDOW] == prediction);
 8025306:	f890 003c 	ldrb.w	r0, [r0, #60]	; 0x3c
    for (uint8_t i = index_IGN + TF_WINDOW - TF_WALK_WINDOW; i < index_IGN + TF_WINDOW; ++i) {
 802530a:	b2e4      	uxtb	r4, r4
      count += (raw_predictions_IGN[i % TF_WINDOW] == prediction);
 802530c:	2804      	cmp	r0, #4
 802530e:	bf08      	it	eq
 8025310:	3601      	addeq	r6, #1
    for (uint8_t i = index_IGN + TF_WINDOW - TF_WALK_WINDOW; i < index_IGN + TF_WINDOW; ++i) {
 8025312:	42bc      	cmp	r4, r7
      count += (raw_predictions_IGN[i % TF_WINDOW] == prediction);
 8025314:	b236      	sxth	r6, r6
    for (uint8_t i = index_IGN + TF_WINDOW - TF_WALK_WINDOW; i < index_IGN + TF_WINDOW; ++i) {
 8025316:	ddec      	ble.n	80252f2 <har_postProc+0x1a6>
      (last_prediction_IGN == AR_ID_STATIONARY_IGN) ? TF_WALK_LONG_THR : TF_WALK_SHORT_THR;
 8025318:	4b0d      	ldr	r3, [pc, #52]	; (8025350 <har_postProc+0x204>)
    int16_t walk_threshold = 
 802531a:	7818      	ldrb	r0, [r3, #0]
 802531c:	2803      	cmp	r0, #3
 802531e:	bf14      	ite	ne
 8025320:	2002      	movne	r0, #2
 8025322:	2005      	moveq	r0, #5
  if (update) last_prediction_IGN = prediction;
 8025324:	4286      	cmp	r6, r0
 8025326:	dd9a      	ble.n	802525e <har_postProc+0x112>
 8025328:	701a      	strb	r2, [r3, #0]
  return last_prediction_IGN;
 802532a:	e784      	b.n	8025236 <har_postProc+0xea>
      (last_prediction_IGN == AR_ID_STATIONARY_IGN) ? TF_WALK_LONG_THR : TF_WALK_SHORT_THR;
 802532c:	4b08      	ldr	r3, [pc, #32]	; (8025350 <har_postProc+0x204>)
 802532e:	781a      	ldrb	r2, [r3, #0]
    int16_t walk_threshold = 
 8025330:	2a03      	cmp	r2, #3
 8025332:	d194      	bne.n	802525e <har_postProc+0x112>
 8025334:	e761      	b.n	80251fa <har_postProc+0xae>
 8025336:	bf00      	nop
 8025338:	20014b00 	.word	0x20014b00
 802533c:	3f4ccccd 	.word	0x3f4ccccd
 8025340:	3e4ccccd 	.word	0x3e4ccccd
 8025344:	ce6e6b28 	.word	0xce6e6b28
 8025348:	cccccccd 	.word	0xcccccccd
 802534c:	08039bf0 	.word	0x08039bf0
 8025350:	20000e2c 	.word	0x20000e2c

08025354 <iir_direct2_filter>:
  }
}


float iir_direct2_filter(IIRFilterDirect2 * filter, float x)
{
 8025354:	b430      	push	{r4, r5}
  float filtered = filter->b[0] * x + filter->z[0];
 8025356:	6945      	ldr	r5, [r0, #20]
 8025358:	edd0 7a00 	vldr	s15, [r0]

  for (int i = 1; i < FILT_ORDER; ++i) {
    filter->z[i-1] = filter->z[i] + filter->b[i] * x - filter->a[i]*filtered;
 802535c:	6904      	ldr	r4, [r0, #16]
  float filtered = filter->b[0] * x + filter->z[0];
 802535e:	462a      	mov	r2, r5
 8025360:	ecf2 6a01 	vldmia	r2!, {s13}
 8025364:	ee60 6a26 	vmul.f32	s13, s0, s13
 8025368:	4603      	mov	r3, r0
 802536a:	ee76 6aa7 	vadd.f32	s13, s13, s15
  for (int i = 1; i < FILT_ORDER; ++i) {
 802536e:	1d21      	adds	r1, r4, #4
 8025370:	f100 0c0c 	add.w	ip, r0, #12
    filter->z[i-1] = filter->z[i] + filter->b[i] * x - filter->a[i]*filtered;
 8025374:	ecf2 7a01 	vldmia	r2!, {s15}
 8025378:	ecb1 7a01 	vldmia	r1!, {s14}
 802537c:	ed93 6a01 	vldr	s12, [r3, #4]
 8025380:	ee67 7a80 	vmul.f32	s15, s15, s0
 8025384:	ee27 7a26 	vmul.f32	s14, s14, s13
 8025388:	ee77 7a86 	vadd.f32	s15, s15, s12
 802538c:	ee77 7ac7 	vsub.f32	s15, s15, s14
 8025390:	ece3 7a01 	vstmia	r3!, {s15}
  for (int i = 1; i < FILT_ORDER; ++i) {
 8025394:	459c      	cmp	ip, r3
 8025396:	d1ed      	bne.n	8025374 <iir_direct2_filter+0x20>
  }
  filter->z[FILT_ORDER-1] = filter->b[FILT_ORDER] * x -
 8025398:	edd5 7a04 	vldr	s15, [r5, #16]
                            filter->a[FILT_ORDER] * filtered;
 802539c:	ed94 7a04 	vldr	s14, [r4, #16]
  filter->z[FILT_ORDER-1] = filter->b[FILT_ORDER] * x -
 80253a0:	ee60 7a27 	vmul.f32	s15, s0, s15
                            filter->a[FILT_ORDER] * filtered;
 80253a4:	ee26 7a87 	vmul.f32	s14, s13, s14

  return filtered;
}
 80253a8:	eeb0 0a66 	vmov.f32	s0, s13
  filter->z[FILT_ORDER-1] = filter->b[FILT_ORDER] * x -
 80253ac:	ee77 7ac7 	vsub.f32	s15, s15, s14
}
 80253b0:	bc30      	pop	{r4, r5}
  filter->z[FILT_ORDER-1] = filter->b[FILT_ORDER] * x -
 80253b2:	edc0 7a03 	vstr	s15, [r0, #12]
}
 80253b6:	4770      	bx	lr

080253b8 <dynamic_acceleration>:
                          float * dyn_x, float * dyn_y, float * dyn_z)
{
  static IIRFilterDirect2 grav_x_filter, grav_y_filter, grav_z_filter;
  static int first_sample = 1;

  if (first_sample) {
 80253b8:	f8df c118 	ldr.w	ip, [pc, #280]	; 80254d4 <dynamic_acceleration+0x11c>
{
 80253bc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  if (first_sample) {
 80253be:	f8dc 3000 	ldr.w	r3, [ip]
{
 80253c2:	4607      	mov	r7, r0
 80253c4:	460e      	mov	r6, r1
 80253c6:	4615      	mov	r5, r2
  if (first_sample) {
 80253c8:	2b00      	cmp	r3, #0
 80253ca:	d05e      	beq.n	802548a <dynamic_acceleration+0xd2>
    float scale = (first == 0.0f) ? 1.0f : first;
 80253cc:	eeb5 0a40 	vcmp.f32	s0, #0.0
 80253d0:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
 80253d4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80253d8:	eef5 0a40 	vcmp.f32	s1, #0.0
 80253dc:	bf0c      	ite	eq
 80253de:	eef0 6a67 	vmoveq.f32	s13, s15
 80253e2:	eef0 6a40 	vmovne.f32	s13, s0
 80253e6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80253ea:	eeb5 1a40 	vcmp.f32	s2, #0.0
 80253ee:	bf0c      	ite	eq
 80253f0:	eeb0 7a67 	vmoveq.f32	s14, s15
 80253f4:	eeb0 7a60 	vmovne.f32	s14, s1
    for (int i = 0; i < FILT_ORDER; ++i) filter->z[i] = scale * z[i];
 80253f8:	ed9f 5a30 	vldr	s10, [pc, #192]	; 80254bc <dynamic_acceleration+0x104>
 80253fc:	eddf 5a30 	vldr	s11, [pc, #192]	; 80254c0 <dynamic_acceleration+0x108>
 8025400:	ed9f 6a30 	vldr	s12, [pc, #192]	; 80254c4 <dynamic_acceleration+0x10c>
 8025404:	eddf 4a30 	vldr	s9, [pc, #192]	; 80254c8 <dynamic_acceleration+0x110>
  filter->a = a;
 8025408:	4b30      	ldr	r3, [pc, #192]	; (80254cc <dynamic_acceleration+0x114>)
 802540a:	4c31      	ldr	r4, [pc, #196]	; (80254d0 <dynamic_acceleration+0x118>)
 802540c:	611c      	str	r4, [r3, #16]
    float scale = (first == 0.0f) ? 1.0f : first;
 802540e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8025412:	bf18      	it	ne
 8025414:	eef0 7a41 	vmovne.f32	s15, s2
    for (int i = 0; i < FILT_ORDER; ++i) filter->z[i] = scale * z[i];
 8025418:	ee66 1a85 	vmul.f32	s3, s13, s10
 802541c:	ee26 2aa5 	vmul.f32	s4, s13, s11
 8025420:	ee66 2a86 	vmul.f32	s5, s13, s12
 8025424:	ee27 3a05 	vmul.f32	s6, s14, s10
 8025428:	ee67 3a25 	vmul.f32	s7, s14, s11
 802542c:	ee27 4a06 	vmul.f32	s8, s14, s12
 8025430:	ee27 5a85 	vmul.f32	s10, s15, s10
 8025434:	ee67 5aa5 	vmul.f32	s11, s15, s11
 8025438:	ee27 6a86 	vmul.f32	s12, s15, s12
 802543c:	ee66 6aa4 	vmul.f32	s13, s13, s9
 8025440:	ee27 7a24 	vmul.f32	s14, s14, s9
 8025444:	ee67 7aa4 	vmul.f32	s15, s15, s9
  filter->a = a;
 8025448:	629c      	str	r4, [r3, #40]	; 0x28
 802544a:	641c      	str	r4, [r3, #64]	; 0x40
  filter->b = b;
 802544c:	3414      	adds	r4, #20
    for (int i = 0; i < FILT_ORDER; ++i) filter->z[i] = scale * z[i];
 802544e:	edc3 1a00 	vstr	s3, [r3]
 8025452:	ed83 2a01 	vstr	s4, [r3, #4]
 8025456:	edc3 2a02 	vstr	s5, [r3, #8]
 802545a:	edc3 6a03 	vstr	s13, [r3, #12]
 802545e:	ed83 3a06 	vstr	s6, [r3, #24]
 8025462:	edc3 3a07 	vstr	s7, [r3, #28]
 8025466:	ed83 4a08 	vstr	s8, [r3, #32]
 802546a:	ed83 7a09 	vstr	s14, [r3, #36]	; 0x24
 802546e:	ed83 5a0c 	vstr	s10, [r3, #48]	; 0x30
 8025472:	edc3 5a0d 	vstr	s11, [r3, #52]	; 0x34
 8025476:	ed83 6a0e 	vstr	s12, [r3, #56]	; 0x38
 802547a:	edc3 7a0f 	vstr	s15, [r3, #60]	; 0x3c
  filter->b = b;
 802547e:	615c      	str	r4, [r3, #20]
 8025480:	62dc      	str	r4, [r3, #44]	; 0x2c
 8025482:	645c      	str	r4, [r3, #68]	; 0x44
                     kGravityHighPassInit, acc_x);
    iir_direct2_init(&grav_y_filter, kGravityHighPassA, kGravityHighPassB,
                     kGravityHighPassInit, acc_y);
    iir_direct2_init(&grav_z_filter, kGravityHighPassA, kGravityHighPassB,
                     kGravityHighPassInit, acc_z);
    first_sample = 0;
 8025484:	2300      	movs	r3, #0
 8025486:	f8cc 3000 	str.w	r3, [ip]
  }

  *dyn_x = iir_direct2_filter(&grav_x_filter, acc_x);
 802548a:	4810      	ldr	r0, [pc, #64]	; (80254cc <dynamic_acceleration+0x114>)
 802548c:	f7ff ff62 	bl	8025354 <iir_direct2_filter>
 8025490:	eef0 7a40 	vmov.f32	s15, s0
  *dyn_y = iir_direct2_filter(&grav_y_filter, acc_y);
 8025494:	3018      	adds	r0, #24
  *dyn_x = iir_direct2_filter(&grav_x_filter, acc_x);
 8025496:	edc7 7a00 	vstr	s15, [r7]
  *dyn_y = iir_direct2_filter(&grav_y_filter, acc_y);
 802549a:	eeb0 0a60 	vmov.f32	s0, s1
 802549e:	f7ff ff59 	bl	8025354 <iir_direct2_filter>
 80254a2:	eef0 7a40 	vmov.f32	s15, s0
  *dyn_z = iir_direct2_filter(&grav_z_filter, acc_z);
 80254a6:	3018      	adds	r0, #24
 80254a8:	eeb0 0a41 	vmov.f32	s0, s2
  *dyn_y = iir_direct2_filter(&grav_y_filter, acc_y);
 80254ac:	edc6 7a00 	vstr	s15, [r6]
  *dyn_z = iir_direct2_filter(&grav_z_filter, acc_z);
 80254b0:	f7ff ff50 	bl	8025354 <iir_direct2_filter>
 80254b4:	ed85 0a00 	vstr	s0, [r5]
}
 80254b8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80254ba:	bf00      	nop
 80254bc:	bf6fc051 	.word	0xbf6fc051
 80254c0:	4033d005 	.word	0x4033d005
 80254c4:	c033cfd1 	.word	0xc033cfd1
 80254c8:	3f6fbf81 	.word	0x3f6fbf81
 80254cc:	20014b54 	.word	0x20014b54
 80254d0:	08039c00 	.word	0x08039c00
 80254d4:	20000e30 	.word	0x20000e30

080254d8 <gravity_suppress_rotate>:
* @brief  Remove gravity from acceleration raw data
* @param  HAR_input_t Acceleration value (x/y/z)
* @retval HAR_input_t Acceleration value filtered (x/y/z)
*/
HAR_input_t gravity_suppress_rotate(HAR_input_t * data)
{
 80254d8:	b510      	push	{r4, lr}
 80254da:	ed2d 8b02 	vpush	{d8}
 80254de:	b08c      	sub	sp, #48	; 0x30
 80254e0:	4604      	mov	r4, r0
  float dyn_x, dyn_y, dyn_z;
  dynamic_acceleration(data->AccX, data->AccY, data->AccZ, &dyn_x, &dyn_y, &dyn_z);
 80254e2:	ed90 1a02 	vldr	s2, [r0, #8]
 80254e6:	ed90 0a00 	vldr	s0, [r0]
 80254ea:	edd0 0a01 	vldr	s1, [r0, #4]
 80254ee:	aa08      	add	r2, sp, #32
 80254f0:	a907      	add	r1, sp, #28
 80254f2:	a806      	add	r0, sp, #24
 80254f4:	f7ff ff60 	bl	80253b8 <dynamic_acceleration>

  /* gravity versor */
  float grav_x = data->AccX - dyn_x;
 80254f8:	ed9d 7a06 	vldr	s14, [sp, #24]
  float grav_y = data->AccY - dyn_y;
 80254fc:	eddd 7a07 	vldr	s15, [sp, #28]
  float grav_x = data->AccX - dyn_x;
 8025500:	edd4 8a00 	vldr	s17, [r4]
  float grav_y = data->AccY - dyn_y;
 8025504:	ed94 8a01 	vldr	s16, [r4, #4]
  float grav_z = data->AccZ - dyn_z;
 8025508:	ed94 1a02 	vldr	s2, [r4, #8]
  float grav_x = data->AccX - dyn_x;
 802550c:	ee78 8ac7 	vsub.f32	s17, s17, s14
  float grav_y = data->AccY - dyn_y;
 8025510:	ee38 8a67 	vsub.f32	s16, s16, s15
  float grav_z = data->AccZ - dyn_z;
 8025514:	eddd 7a08 	vldr	s15, [sp, #32]

  float grav_m = grav_x * grav_x + grav_y * grav_y + grav_z * grav_z;
 8025518:	ee28 0aa8 	vmul.f32	s0, s17, s17
  float grav_z = data->AccZ - dyn_z;
 802551c:	ee31 1a67 	vsub.f32	s2, s2, s15
  float grav_m = grav_x * grav_x + grav_y * grav_y + grav_z * grav_z;
 8025520:	ee28 7a08 	vmul.f32	s14, s16, s16
 8025524:	ee61 7a01 	vmul.f32	s15, s2, s2
 8025528:	ee30 0a07 	vadd.f32	s0, s0, s14
 802552c:	ee30 0a27 	vadd.f32	s0, s0, s15
  float sqrt_grav_m = sqrtf(grav_m);
 8025530:	eeb5 0a40 	vcmp.f32	s0, #0.0
 8025534:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8025538:	d456      	bmi.n	80255e8 <gravity_suppress_rotate+0x110>
 802553a:	eeb1 7ac0 	vsqrt.f32	s14, s0
  grav_m = 1.0f / sqrt_grav_m;
 802553e:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
 8025542:	eec0 7a07 	vdiv.f32	s15, s0, s14
  grav_x *= grav_m, grav_y *= grav_m, grav_z *= grav_m;
 8025546:	ee21 1a27 	vmul.f32	s2, s2, s15
 802554a:	ee68 8aa7 	vmul.f32	s17, s17, s15

  float sqrt_for_sin = sqrtf(1.0f - grav_z*grav_z);
 802554e:	ee21 7a01 	vmul.f32	s14, s2, s2
  grav_x *= grav_m, grav_y *= grav_m, grav_z *= grav_m;
 8025552:	ee28 8a27 	vmul.f32	s16, s16, s15
  float sqrt_for_sin = sqrtf(1.0f - grav_z*grav_z);
 8025556:	ee30 0a47 	vsub.f32	s0, s0, s14
 802555a:	eeb5 0a40 	vcmp.f32	s0, #0.0
 802555e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8025562:	d44a      	bmi.n	80255fa <gravity_suppress_rotate+0x122>
 8025564:	eeb1 5ac0 	vsqrt.f32	s10, s0
  float sin_theta = sqrt_for_sin, cos_theta = -grav_z;

  /* rotation axis: v = [-grav_y, grav_x, 0] / sin */
  float v_x = -grav_y / sin_theta, v_y = grav_x / sin_theta;
 8025568:	eeb1 8a48 	vneg.f32	s16, s16
 802556c:	eec8 6a05 	vdiv.f32	s13, s16, s10
 8025570:	ee88 6a85 	vdiv.f32	s12, s17, s10
  float v_factor = (v_x * dyn_x + v_y * dyn_y) * (1 - cos_theta);
 8025574:	eddd 4a06 	vldr	s9, [sp, #24]
 8025578:	eddd 7a07 	vldr	s15, [sp, #28]
  /*
   * Rodrigues' formula for rotations (a is the dynamic acceleration dyn)
   * a' = a * cos + (v x a) * sin + v * (v . a) * (1 - cos)
   */
  HAR_input_t out;
  out.AccX = dyn_x * cos_theta + v_y * dyn_z * sin_theta + v_x * v_factor;
 802557c:	ed9d 7a08 	vldr	s14, [sp, #32]
  float v_factor = (v_x * dyn_x + v_y * dyn_y) * (1 - cos_theta);
 8025580:	eef7 5a00 	vmov.f32	s11, #112	; 0x3f800000  1.0
 8025584:	ee31 4a25 	vadd.f32	s8, s2, s11
 8025588:	ee27 3a86 	vmul.f32	s6, s15, s12
 802558c:	ee64 5aa6 	vmul.f32	s11, s9, s13
  out.AccX = dyn_x * cos_theta + v_y * dyn_z * sin_theta + v_x * v_factor;
 8025590:	ee61 3a64 	vnmul.f32	s7, s2, s9
  out.AccY = dyn_y * cos_theta - v_x * dyn_z * sin_theta + v_y * v_factor;
 8025594:	ee61 0a67 	vnmul.f32	s1, s2, s15
  out.AccX = dyn_x * cos_theta + v_y * dyn_z * sin_theta + v_x * v_factor;
 8025598:	ee27 0a06 	vmul.f32	s0, s14, s12
  out.AccZ = dyn_z * cos_theta + (v_x * dyn_y - v_y * dyn_x) * sin_theta;
 802559c:	ee64 4a86 	vmul.f32	s9, s9, s12
 80255a0:	ee21 1a47 	vnmul.f32	s2, s2, s14
  float v_factor = (v_x * dyn_x + v_y * dyn_y) * (1 - cos_theta);
 80255a4:	ee75 5a83 	vadd.f32	s11, s11, s6
  out.AccY = dyn_y * cos_theta - v_x * dyn_z * sin_theta + v_y * v_factor;
 80255a8:	ee27 7a26 	vmul.f32	s14, s14, s13
  out.AccZ = dyn_z * cos_theta + (v_x * dyn_y - v_y * dyn_x) * sin_theta;
 80255ac:	ee67 7aa6 	vmul.f32	s15, s15, s13
  float v_factor = (v_x * dyn_x + v_y * dyn_y) * (1 - cos_theta);
 80255b0:	ee65 5a84 	vmul.f32	s11, s11, s8
  out.AccX = dyn_x * cos_theta + v_y * dyn_z * sin_theta + v_x * v_factor;
 80255b4:	ee20 0a05 	vmul.f32	s0, s0, s10
  out.AccY = dyn_y * cos_theta - v_x * dyn_z * sin_theta + v_y * v_factor;
 80255b8:	ee27 7a05 	vmul.f32	s14, s14, s10
  out.AccZ = dyn_z * cos_theta + (v_x * dyn_y - v_y * dyn_x) * sin_theta;
 80255bc:	ee77 7ae4 	vsub.f32	s15, s15, s9
  out.AccX = dyn_x * cos_theta + v_y * dyn_z * sin_theta + v_x * v_factor;
 80255c0:	ee30 0a23 	vadd.f32	s0, s0, s7
 80255c4:	ee66 6aa5 	vmul.f32	s13, s13, s11
  out.AccY = dyn_y * cos_theta - v_x * dyn_z * sin_theta + v_y * v_factor;
 80255c8:	ee70 0ac7 	vsub.f32	s1, s1, s14
 80255cc:	ee26 6a25 	vmul.f32	s12, s12, s11
  out.AccZ = dyn_z * cos_theta + (v_x * dyn_y - v_y * dyn_x) * sin_theta;
 80255d0:	ee67 7a85 	vmul.f32	s15, s15, s10
  return out;
}
 80255d4:	ee70 0a86 	vadd.f32	s1, s1, s12
 80255d8:	ee37 1a81 	vadd.f32	s2, s15, s2
 80255dc:	ee30 0a26 	vadd.f32	s0, s0, s13
 80255e0:	b00c      	add	sp, #48	; 0x30
 80255e2:	ecbd 8b02 	vpop	{d8}
 80255e6:	bd10      	pop	{r4, pc}
 80255e8:	ed8d 1a01 	vstr	s2, [sp, #4]
  float sqrt_grav_m = sqrtf(grav_m);
 80255ec:	f005 fe7a 	bl	802b2e4 <sqrtf>
 80255f0:	ed9d 1a01 	vldr	s2, [sp, #4]
 80255f4:	eeb0 7a40 	vmov.f32	s14, s0
 80255f8:	e7a1      	b.n	802553e <gravity_suppress_rotate+0x66>
 80255fa:	ed8d 1a01 	vstr	s2, [sp, #4]
  float sqrt_for_sin = sqrtf(1.0f - grav_z*grav_z);
 80255fe:	f005 fe71 	bl	802b2e4 <sqrtf>
 8025602:	ed9d 1a01 	vldr	s2, [sp, #4]
 8025606:	eeb0 5a40 	vmov.f32	s10, s0
 802560a:	e7ad      	b.n	8025568 <gravity_suppress_rotate+0x90>

0802560c <gravity_rotate>:

HAR_input_t gravity_rotate(HAR_input_t * data)
{
 802560c:	b510      	push	{r4, lr}
 802560e:	ed2d 8b02 	vpush	{d8}
 8025612:	b08c      	sub	sp, #48	; 0x30
 8025614:	4604      	mov	r4, r0
  float dyn_x, dyn_y, dyn_z;
  dynamic_acceleration(data->AccX, data->AccY, data->AccZ, &dyn_x, &dyn_y, &dyn_z);
 8025616:	ed90 1a02 	vldr	s2, [r0, #8]
 802561a:	ed90 0a00 	vldr	s0, [r0]
 802561e:	edd0 0a01 	vldr	s1, [r0, #4]
 8025622:	aa08      	add	r2, sp, #32
 8025624:	a907      	add	r1, sp, #28
 8025626:	a806      	add	r0, sp, #24
 8025628:	f7ff fec6 	bl	80253b8 <dynamic_acceleration>

  /* gravity versor */
  float grav_x = data->AccX - dyn_x;
 802562c:	ed9d 7a06 	vldr	s14, [sp, #24]
  float grav_y = data->AccY - dyn_y;
 8025630:	eddd 7a07 	vldr	s15, [sp, #28]
  float grav_x = data->AccX - dyn_x;
 8025634:	edd4 8a00 	vldr	s17, [r4]
  float grav_y = data->AccY - dyn_y;
 8025638:	ed94 8a01 	vldr	s16, [r4, #4]
  float grav_z = data->AccZ - dyn_z;
 802563c:	ed94 1a02 	vldr	s2, [r4, #8]
  float grav_x = data->AccX - dyn_x;
 8025640:	ee78 8ac7 	vsub.f32	s17, s17, s14
  float grav_y = data->AccY - dyn_y;
 8025644:	ee38 8a67 	vsub.f32	s16, s16, s15
  float grav_z = data->AccZ - dyn_z;
 8025648:	eddd 7a08 	vldr	s15, [sp, #32]

  float grav_m = grav_x * grav_x + grav_y * grav_y + grav_z * grav_z;
 802564c:	ee28 0aa8 	vmul.f32	s0, s17, s17
  float grav_z = data->AccZ - dyn_z;
 8025650:	ee31 1a67 	vsub.f32	s2, s2, s15
  float grav_m = grav_x * grav_x + grav_y * grav_y + grav_z * grav_z;
 8025654:	ee28 7a08 	vmul.f32	s14, s16, s16
 8025658:	ee61 7a01 	vmul.f32	s15, s2, s2
 802565c:	ee30 0a07 	vadd.f32	s0, s0, s14
 8025660:	ee30 0a27 	vadd.f32	s0, s0, s15
  float sqrt_grav_m = sqrtf(grav_m);
 8025664:	eeb5 0a40 	vcmp.f32	s0, #0.0
 8025668:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802566c:	d45a      	bmi.n	8025724 <gravity_rotate+0x118>
 802566e:	eeb1 7ac0 	vsqrt.f32	s14, s0
  grav_m = 1.0f / sqrt_grav_m;
 8025672:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
 8025676:	eec0 7a07 	vdiv.f32	s15, s0, s14
  grav_x *= grav_m, grav_y *= grav_m, grav_z *= grav_m;
 802567a:	ee21 1a27 	vmul.f32	s2, s2, s15
 802567e:	ee68 8aa7 	vmul.f32	s17, s17, s15

  float sqrt_for_sin = sqrtf(1.0f - grav_z*grav_z);
 8025682:	ee21 7a01 	vmul.f32	s14, s2, s2
  grav_x *= grav_m, grav_y *= grav_m, grav_z *= grav_m;
 8025686:	ee28 8a27 	vmul.f32	s16, s16, s15
  float sqrt_for_sin = sqrtf(1.0f - grav_z*grav_z);
 802568a:	ee30 0a47 	vsub.f32	s0, s0, s14
 802568e:	eeb5 0a40 	vcmp.f32	s0, #0.0
 8025692:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8025696:	d44e      	bmi.n	8025736 <gravity_rotate+0x12a>
 8025698:	eeb1 5ac0 	vsqrt.f32	s10, s0
  float sin_theta = sqrt_for_sin, cos_theta = -grav_z;

  /* rotation axis: v = [-grav_y, grav_x, 0] / sin */
  float v_x = -grav_y / sin_theta, v_y = grav_x / sin_theta;
 802569c:	eeb1 8a48 	vneg.f32	s16, s16
 80256a0:	ee88 6a05 	vdiv.f32	s12, s16, s10
 80256a4:	eec8 5a85 	vdiv.f32	s11, s17, s10
  float v_factor = (v_x * dyn_x + v_y * dyn_y) * (1 - cos_theta);
 80256a8:	ed9d 7a06 	vldr	s14, [sp, #24]
 80256ac:	eddd 3a07 	vldr	s7, [sp, #28]
   * Rodrigues' formula for rotations (a is the dynamic acceleration dyn)
   * a' = a * cos + (v x a) * sin + v * (v . a) * (1 - cos)
   */
  HAR_input_t out;
  /* rodriguez only */
  out.AccX = data->AccX * cos_theta + v_y * data->AccZ * sin_theta + v_x * v_factor;
 80256b0:	edd4 6a02 	vldr	s13, [r4, #8]
 80256b4:	edd4 4a00 	vldr	s9, [r4]
  out.AccY = data->AccY * cos_theta - v_x * data->AccZ * sin_theta + v_y * v_factor;
 80256b8:	edd4 7a01 	vldr	s15, [r4, #4]
  float v_factor = (v_x * dyn_x + v_y * dyn_y) * (1 - cos_theta);
 80256bc:	ee26 7a07 	vmul.f32	s14, s12, s14
 80256c0:	ee65 3aa3 	vmul.f32	s7, s11, s7
 80256c4:	eeb7 4a00 	vmov.f32	s8, #112	; 0x3f800000  1.0
  out.AccX = data->AccX * cos_theta + v_y * data->AccZ * sin_theta + v_x * v_factor;
 80256c8:	ee21 3a64 	vnmul.f32	s6, s2, s9
  float v_factor = (v_x * dyn_x + v_y * dyn_y) * (1 - cos_theta);
 80256cc:	ee31 4a04 	vadd.f32	s8, s2, s8
  out.AccY = data->AccY * cos_theta - v_x * data->AccZ * sin_theta + v_y * v_factor;
 80256d0:	ee61 0a67 	vnmul.f32	s1, s2, s15
  out.AccX = data->AccX * cos_theta + v_y * data->AccZ * sin_theta + v_x * v_factor;
 80256d4:	ee26 0aa5 	vmul.f32	s0, s13, s11
  out.AccZ = data->AccZ * cos_theta + (v_x * data->AccY - v_y * data->AccX) * sin_theta;
 80256d8:	ee21 1a66 	vnmul.f32	s2, s2, s13
  float v_factor = (v_x * dyn_x + v_y * dyn_y) * (1 - cos_theta);
 80256dc:	ee37 7a23 	vadd.f32	s14, s14, s7
  out.AccY = data->AccY * cos_theta - v_x * data->AccZ * sin_theta + v_y * v_factor;
 80256e0:	ee66 6a86 	vmul.f32	s13, s13, s12
  out.AccZ = data->AccZ * cos_theta + (v_x * data->AccY - v_y * data->AccX) * sin_theta;
 80256e4:	ee67 7a86 	vmul.f32	s15, s15, s12
 80256e8:	ee64 4aa5 	vmul.f32	s9, s9, s11
  float v_factor = (v_x * dyn_x + v_y * dyn_y) * (1 - cos_theta);
 80256ec:	ee27 7a04 	vmul.f32	s14, s14, s8
  out.AccX = data->AccX * cos_theta + v_y * data->AccZ * sin_theta + v_x * v_factor;
 80256f0:	ee20 0a05 	vmul.f32	s0, s0, s10
  out.AccY = data->AccY * cos_theta - v_x * data->AccZ * sin_theta + v_y * v_factor;
 80256f4:	ee66 6a85 	vmul.f32	s13, s13, s10
  out.AccZ = data->AccZ * cos_theta + (v_x * data->AccY - v_y * data->AccX) * sin_theta;
 80256f8:	ee77 7ae4 	vsub.f32	s15, s15, s9
  out.AccX = data->AccX * cos_theta + v_y * data->AccZ * sin_theta + v_x * v_factor;
 80256fc:	ee26 6a07 	vmul.f32	s12, s12, s14
 8025700:	ee30 0a03 	vadd.f32	s0, s0, s6
  out.AccY = data->AccY * cos_theta - v_x * data->AccZ * sin_theta + v_y * v_factor;
 8025704:	ee70 0ae6 	vsub.f32	s1, s1, s13
 8025708:	ee25 7a87 	vmul.f32	s14, s11, s14
  out.AccZ = data->AccZ * cos_theta + (v_x * data->AccY - v_y * data->AccX) * sin_theta;
 802570c:	ee67 7a85 	vmul.f32	s15, s15, s10
  return out;
}
 8025710:	ee70 0a87 	vadd.f32	s1, s1, s14
 8025714:	ee37 1a81 	vadd.f32	s2, s15, s2
 8025718:	ee30 0a06 	vadd.f32	s0, s0, s12
 802571c:	b00c      	add	sp, #48	; 0x30
 802571e:	ecbd 8b02 	vpop	{d8}
 8025722:	bd10      	pop	{r4, pc}
 8025724:	ed8d 1a01 	vstr	s2, [sp, #4]
  float sqrt_grav_m = sqrtf(grav_m);
 8025728:	f005 fddc 	bl	802b2e4 <sqrtf>
 802572c:	ed9d 1a01 	vldr	s2, [sp, #4]
 8025730:	eeb0 7a40 	vmov.f32	s14, s0
 8025734:	e79d      	b.n	8025672 <gravity_rotate+0x66>
 8025736:	ed8d 1a01 	vstr	s2, [sp, #4]
  float sqrt_for_sin = sqrtf(1.0f - grav_z*grav_z);
 802573a:	f005 fdd3 	bl	802b2e4 <sqrtf>
 802573e:	ed9d 1a01 	vldr	s2, [sp, #4]
 8025742:	eeb0 5a40 	vmov.f32	s10, s0
 8025746:	e7a9      	b.n	802569c <gravity_rotate+0x90>

08025748 <HAR_run>:
  AI_HAR_IGN_MODEL_CTX,
  AI_HAR_IGN_WSDM_MODEL_CTX
};

HAR_output_t HAR_run(MOTION_SENSOR_AxesRaw_t ACC_Value_Raw, HAR_algoIdx_t algo)
{
 8025748:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 802574c:	ed2d 8b04 	vpush	{d8-d9}
 8025750:	b08b      	sub	sp, #44	; 0x2c
 8025752:	ab02      	add	r3, sp, #8
 8025754:	e883 0003 	stmia.w	r3, {r0, r1}
  HAR_input_t iDataIN;
  HAR_input_t iDataInPreProc;
  float factor = TargetBoardFeatures.AccSensiMultInG;
 8025758:	4b6c      	ldr	r3, [pc, #432]	; (802590c <HAR_run+0x1c4>)
 802575a:	f9bd 8008 	ldrsh.w	r8, [sp, #8]
 802575e:	ed93 8a0c 	vldr	s16, [r3, #48]	; 0x30
 8025762:	f9bd 700a 	ldrsh.w	r7, [sp, #10]
 8025766:	f9bd 600c 	ldrsh.w	r6, [sp, #12]

  int height   = aiGetReport(algo)->inputs[0].height;
 802576a:	4610      	mov	r0, r2
{
 802576c:	4614      	mov	r4, r2
  int height   = aiGetReport(algo)->inputs[0].height;
 802576e:	f7fa fe99 	bl	80204a4 <aiGetReport>
 8025772:	6b43      	ldr	r3, [r0, #52]	; 0x34
  int width    = aiGetReport(algo)->inputs[0].width;
 8025774:	4620      	mov	r0, r4
  int height   = aiGetReport(algo)->inputs[0].height;
 8025776:	f8b3 9006 	ldrh.w	r9, [r3, #6]
  int width    = aiGetReport(algo)->inputs[0].width;
 802577a:	f7fa fe93 	bl	80204a4 <aiGetReport>
 802577e:	6b43      	ldr	r3, [r0, #52]	; 0x34
 8025780:	891d      	ldrh	r5, [r3, #8]
  int size     = height * width ;

  if (HAR_IGN_WSDM_IDX == algo)
 8025782:	2c02      	cmp	r4, #2
  int size     = height * width ;
 8025784:	fb09 fa05 	mul.w	sl, r9, r5
  if (HAR_IGN_WSDM_IDX == algo)
 8025788:	d06b      	beq.n	8025862 <HAR_run+0x11a>
  {
    factor *= FROM_G_TO_MS_2 ;
  }

  iDataIN.AccX = (float)ACC_Value_Raw.x * factor;
 802578a:	ee07 8a90 	vmov	s15, r8
 802578e:	eef8 6ae7 	vcvt.f32.s32	s13, s15
  iDataIN.AccY = (float)ACC_Value_Raw.y * factor;
 8025792:	ee07 7a90 	vmov	s15, r7
 8025796:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
  iDataIN.AccZ = (float)ACC_Value_Raw.z * factor;
 802579a:	ee07 6a90 	vmov	s15, r6
 802579e:	eef8 7ae7 	vcvt.f32.s32	s15, s15
  iDataIN.AccX = (float)ACC_Value_Raw.x * factor;
 80257a2:	ee66 6a88 	vmul.f32	s13, s13, s16
  iDataIN.AccY = (float)ACC_Value_Raw.y * factor;
 80257a6:	ee27 7a08 	vmul.f32	s14, s14, s16
  iDataIN.AccZ = (float)ACC_Value_Raw.z * factor;
 80257aa:	ee67 7a88 	vmul.f32	s15, s15, s16
#endif
    iDataInPreProc = gravity_rotate(&iDataIN);
  }
  else
  {
    iDataInPreProc = gravity_suppress_rotate(&iDataIN);
 80257ae:	a804      	add	r0, sp, #16
  iDataIN.AccX = (float)ACC_Value_Raw.x * factor;
 80257b0:	edcd 6a04 	vstr	s13, [sp, #16]
  iDataIN.AccY = (float)ACC_Value_Raw.y * factor;
 80257b4:	ed8d 7a05 	vstr	s14, [sp, #20]
  iDataIN.AccZ = (float)ACC_Value_Raw.z * factor;
 80257b8:	edcd 7a06 	vstr	s15, [sp, #24]
    iDataInPreProc = gravity_suppress_rotate(&iDataIN);
 80257bc:	f7ff fe8c 	bl	80254d8 <gravity_suppress_rotate>
 80257c0:	eeb0 9a40 	vmov.f32	s18, s0
 80257c4:	eef0 8a60 	vmov.f32	s17, s1
 80257c8:	eeb0 8a41 	vmov.f32	s16, s2
  }

  if ( HAR_GMP_IDX == algo)
 80257cc:	2c00      	cmp	r4, #0
 80257ce:	d16a      	bne.n	80258a6 <HAR_run+0x15e>
  {

    /* add samples to each active window */
      ai_size n_window = n_sample / WINDOW_GMP_STEP, pos = n_sample % WINDOW_GMP_STEP;
 80257d0:	4f4f      	ldr	r7, [pc, #316]	; (8025910 <HAR_run+0x1c8>)
 80257d2:	46bb      	mov	fp, r7
 80257d4:	012a      	lsls	r2, r5, #4
 80257d6:	f85b 3b04 	ldr.w	r3, [fp], #4
 80257da:	9200      	str	r2, [sp, #0]
 80257dc:	f003 060f 	and.w	r6, r3, #15
 80257e0:	ea4f 1813 	mov.w	r8, r3, lsr #4
      for (ai_size i = 0; i < N_OVERLAPPING_GMP_WIN; ++i) {
 80257e4:	fb06 f505 	mul.w	r5, r6, r5
          window_buffer[j++] = iDataInPreProc.AccY;
          window_buffer[j]   = iDataInPreProc.AccZ;
        }
      /* if buffer is full, run the network */
      if (index == (height - 1)) {
        aiRun(aiHarAlgoNames[algo], aiHarAlgoCtx[algo],&window_buffer[win_offset],aiHarOut);
 80257e8:	f507 7311 	add.w	r3, r7, #580	; 0x244
        ai_int win_idx = (n_window - i) % N_OVERLAPPING_GMP_WIN;
 80257ec:	eba8 0204 	sub.w	r2, r8, r4
 80257f0:	f002 0201 	and.w	r2, r2, #1
        if (n_window < i) continue;
 80257f4:	45a0      	cmp	r8, r4
        ai_int win_offset = win_idx * size;
 80257f6:	fb0a f202 	mul.w	r2, sl, r2
        if (n_window < i) continue;
 80257fa:	d305      	bcc.n	8025808 <HAR_run+0xc0>
        if (index < height) {
 80257fc:	454e      	cmp	r6, r9
 80257fe:	db13      	blt.n	8025828 <HAR_run+0xe0>
      if (index == (height - 1)) {
 8025800:	f109 31ff 	add.w	r1, r9, #4294967295
 8025804:	42b1      	cmp	r1, r6
 8025806:	d01c      	beq.n	8025842 <HAR_run+0xfa>
      for (ai_size i = 0; i < N_OVERLAPPING_GMP_WIN; ++i) {
 8025808:	9a00      	ldr	r2, [sp, #0]
 802580a:	3610      	adds	r6, #16
 802580c:	4415      	add	r5, r2
 802580e:	b14c      	cbz	r4, 8025824 <HAR_run+0xdc>
        ActivityCode[algo] = har_postProc(aiHarOut,algo);
      }
    }
    ++n_sample;
 8025810:	683b      	ldr	r3, [r7, #0]
      aiRun(aiHarAlgoNames[algo], aiHarAlgoCtx[algo],window_buffer,aiHarOut);
      ActivityCode[algo] = har_postProc(aiHarOut,algo);
      n_sample = 0;
    }
  }
  return ActivityCode[algo];
 8025812:	f897 0258 	ldrb.w	r0, [r7, #600]	; 0x258
    ++n_sample;
 8025816:	3301      	adds	r3, #1
 8025818:	603b      	str	r3, [r7, #0]
}
 802581a:	b00b      	add	sp, #44	; 0x2c
 802581c:	ecbd 8b04 	vpop	{d8-d9}
 8025820:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8025824:	2401      	movs	r4, #1
 8025826:	e7e1      	b.n	80257ec <HAR_run+0xa4>
          ai_size j = win_offset + index * width ;
 8025828:	18a9      	adds	r1, r5, r2
          window_buffer[j++] = iDataInPreProc.AccX;
 802582a:	eb07 0081 	add.w	r0, r7, r1, lsl #2
      if (index == (height - 1)) {
 802582e:	f109 31ff 	add.w	r1, r9, #4294967295
 8025832:	42b1      	cmp	r1, r6
          window_buffer[j++] = iDataInPreProc.AccX;
 8025834:	ed80 9a01 	vstr	s18, [r0, #4]
          window_buffer[j++] = iDataInPreProc.AccY;
 8025838:	edc0 8a02 	vstr	s17, [r0, #8]
          window_buffer[j]   = iDataInPreProc.AccZ;
 802583c:	ed80 8a03 	vstr	s16, [r0, #12]
      if (index == (height - 1)) {
 8025840:	d1e2      	bne.n	8025808 <HAR_run+0xc0>
        aiRun(aiHarAlgoNames[algo], aiHarAlgoCtx[algo],&window_buffer[win_offset],aiHarOut);
 8025842:	eb0b 0282 	add.w	r2, fp, r2, lsl #2
 8025846:	2100      	movs	r1, #0
 8025848:	4832      	ldr	r0, [pc, #200]	; (8025914 <HAR_run+0x1cc>)
 802584a:	9301      	str	r3, [sp, #4]
 802584c:	f7fa fb70 	bl	801ff30 <aiRun>
        ActivityCode[algo] = har_postProc(aiHarOut,algo);
 8025850:	9b01      	ldr	r3, [sp, #4]
 8025852:	2100      	movs	r1, #0
 8025854:	4618      	mov	r0, r3
 8025856:	f7ff fc79 	bl	802514c <har_postProc>
 802585a:	9b01      	ldr	r3, [sp, #4]
 802585c:	f887 0258 	strb.w	r0, [r7, #600]	; 0x258
 8025860:	e7d2      	b.n	8025808 <HAR_run+0xc0>
    factor *= FROM_G_TO_MS_2 ;
 8025862:	eddf 7a2d 	vldr	s15, [pc, #180]	; 8025918 <HAR_run+0x1d0>
  iDataIN.AccX = (float)ACC_Value_Raw.x * factor;
 8025866:	ee07 8a10 	vmov	s14, r8
    factor *= FROM_G_TO_MS_2 ;
 802586a:	ee28 8a27 	vmul.f32	s16, s16, s15
  iDataIN.AccY = (float)ACC_Value_Raw.y * factor;
 802586e:	ee07 7a90 	vmov	s15, r7
  iDataIN.AccX = (float)ACC_Value_Raw.x * factor;
 8025872:	eef8 6ac7 	vcvt.f32.s32	s13, s14
  iDataIN.AccY = (float)ACC_Value_Raw.y * factor;
 8025876:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
  iDataIN.AccZ = (float)ACC_Value_Raw.z * factor;
 802587a:	ee07 6a90 	vmov	s15, r6
 802587e:	eef8 7ae7 	vcvt.f32.s32	s15, s15
  iDataIN.AccX = (float)ACC_Value_Raw.x * factor;
 8025882:	ee66 6a88 	vmul.f32	s13, s13, s16
  iDataIN.AccY = (float)ACC_Value_Raw.y * factor;
 8025886:	ee27 7a08 	vmul.f32	s14, s14, s16
  iDataIN.AccZ = (float)ACC_Value_Raw.z * factor;
 802588a:	ee67 7a88 	vmul.f32	s15, s15, s16
    HAR_GetTestSamples(&iDataIN);
 802588e:	a804      	add	r0, sp, #16
  iDataIN.AccX = (float)ACC_Value_Raw.x * factor;
 8025890:	edcd 6a04 	vstr	s13, [sp, #16]
  iDataIN.AccY = (float)ACC_Value_Raw.y * factor;
 8025894:	ed8d 7a05 	vstr	s14, [sp, #20]
  iDataIN.AccZ = (float)ACC_Value_Raw.z * factor;
 8025898:	edcd 7a06 	vstr	s15, [sp, #24]
    HAR_GetTestSamples(&iDataIN);
 802589c:	f000 f89e 	bl	80259dc <HAR_GetTestSamples>
    iDataInPreProc = gravity_rotate(&iDataIN);
 80258a0:	a804      	add	r0, sp, #16
 80258a2:	f7ff feb3 	bl	802560c <gravity_rotate>
    window_buffer[n_sample++] = iDataInPreProc.AccX;
 80258a6:	4d1a      	ldr	r5, [pc, #104]	; (8025910 <HAR_run+0x1c8>)
 80258a8:	682b      	ldr	r3, [r5, #0]
 80258aa:	eb05 0283 	add.w	r2, r5, r3, lsl #2
 80258ae:	ed82 0a01 	vstr	s0, [r2, #4]
    window_buffer[n_sample++] = iDataInPreProc.AccY;
 80258b2:	edc2 0a02 	vstr	s1, [r2, #8]
    window_buffer[n_sample++] = iDataInPreProc.AccZ;
 80258b6:	1cda      	adds	r2, r3, #3
    if  ( n_sample >=  size)
 80258b8:	4552      	cmp	r2, sl
    window_buffer[n_sample++] = iDataInPreProc.AccZ;
 80258ba:	eb05 0383 	add.w	r3, r5, r3, lsl #2
 80258be:	ed83 1a03 	vstr	s2, [r3, #12]
 80258c2:	602a      	str	r2, [r5, #0]
    if  ( n_sample >=  size)
 80258c4:	d207      	bcs.n	80258d6 <HAR_run+0x18e>
  return ActivityCode[algo];
 80258c6:	442c      	add	r4, r5
 80258c8:	f894 0258 	ldrb.w	r0, [r4, #600]	; 0x258
}
 80258cc:	b00b      	add	sp, #44	; 0x2c
 80258ce:	ecbd 8b04 	vpop	{d8-d9}
 80258d2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
      aiRun(aiHarAlgoNames[algo], aiHarAlgoCtx[algo],window_buffer,aiHarOut);
 80258d6:	4a11      	ldr	r2, [pc, #68]	; (802591c <HAR_run+0x1d4>)
 80258d8:	eb02 0084 	add.w	r0, r2, r4, lsl #2
 80258dc:	f852 1024 	ldr.w	r1, [r2, r4, lsl #2]
 80258e0:	68c0      	ldr	r0, [r0, #12]
 80258e2:	f505 7311 	add.w	r3, r5, #580	; 0x244
 80258e6:	1d2a      	adds	r2, r5, #4
 80258e8:	f7fa fb22 	bl	801ff30 <aiRun>
      ActivityCode[algo] = har_postProc(aiHarOut,algo);
 80258ec:	4621      	mov	r1, r4
 80258ee:	f505 7011 	add.w	r0, r5, #580	; 0x244
 80258f2:	f7ff fc2b 	bl	802514c <har_postProc>
 80258f6:	442c      	add	r4, r5
      n_sample = 0;
 80258f8:	2300      	movs	r3, #0
      ActivityCode[algo] = har_postProc(aiHarOut,algo);
 80258fa:	f884 0258 	strb.w	r0, [r4, #600]	; 0x258
      n_sample = 0;
 80258fe:	602b      	str	r3, [r5, #0]
}
 8025900:	b00b      	add	sp, #44	; 0x2c
 8025902:	ecbd 8b04 	vpop	{d8-d9}
 8025906:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 802590a:	bf00      	nop
 802590c:	200106a4 	.word	0x200106a4
 8025910:	20014b9c 	.word	0x20014b9c
 8025914:	08042c8c 	.word	0x08042c8c
 8025918:	411ccf7c 	.word	0x411ccf7c
 802591c:	08039c38 	.word	0x08039c38

08025920 <HAR_Initialize>:
* @retval 0 if initilazed OK, a negative value otherwise
*/

int8_t HAR_Initialize(HAR_algoIdx_t algo)
{
  ActivityCode[algo]    = HAR_NOACTIVITY;
 8025920:	4a15      	ldr	r2, [pc, #84]	; (8025978 <HAR_Initialize+0x58>)

  /* enabling CRC clock for using AI libraries (for checking if STM32
  microprocessor is used)*/
  __HAL_RCC_CRC_CLK_ENABLE();
 8025922:	4b16      	ldr	r3, [pc, #88]	; (802597c <HAR_Initialize+0x5c>)
  ActivityCode[algo]    = HAR_NOACTIVITY;
 8025924:	4402      	add	r2, r0
 8025926:	2100      	movs	r1, #0
{
 8025928:	b530      	push	{r4, r5, lr}
  ActivityCode[algo]    = HAR_NOACTIVITY;
 802592a:	f882 1258 	strb.w	r1, [r2, #600]	; 0x258
  __HAL_RCC_CRC_CLK_ENABLE();
 802592e:	6c9a      	ldr	r2, [r3, #72]	; 0x48
  if (aiInit(aiHarAlgoNames[algo], aiHarAlgoCtx[algo]))
 8025930:	4913      	ldr	r1, [pc, #76]	; (8025980 <HAR_Initialize+0x60>)
  __HAL_RCC_CRC_CLK_ENABLE();
 8025932:	f442 5280 	orr.w	r2, r2, #4096	; 0x1000
 8025936:	649a      	str	r2, [r3, #72]	; 0x48
 8025938:	6c9b      	ldr	r3, [r3, #72]	; 0x48
{
 802593a:	b083      	sub	sp, #12
  if (aiInit(aiHarAlgoNames[algo], aiHarAlgoCtx[algo]))
 802593c:	eb01 0280 	add.w	r2, r1, r0, lsl #2
  __HAL_RCC_CRC_CLK_ENABLE();
 8025940:	f403 5380 	and.w	r3, r3, #4096	; 0x1000
  if (aiInit(aiHarAlgoNames[algo], aiHarAlgoCtx[algo]))
 8025944:	f851 1020 	ldr.w	r1, [r1, r0, lsl #2]
  __HAL_RCC_CRC_CLK_ENABLE();
 8025948:	9301      	str	r3, [sp, #4]
{
 802594a:	4604      	mov	r4, r0
  if (aiInit(aiHarAlgoNames[algo], aiHarAlgoCtx[algo]))
 802594c:	68d0      	ldr	r0, [r2, #12]
  __HAL_RCC_CRC_CLK_ENABLE();
 802594e:	9b01      	ldr	r3, [sp, #4]
  if (aiInit(aiHarAlgoNames[algo], aiHarAlgoCtx[algo]))
 8025950:	f7fa fb66 	bl	8020020 <aiInit>
 8025954:	b968      	cbnz	r0, 8025972 <HAR_Initialize+0x52>
 8025956:	4605      	mov	r5, r0
    return -1 ;

  har_postProcInit(algo);
 8025958:	4620      	mov	r0, r4
 802595a:	f7ff fbc9 	bl	80250f0 <har_postProcInit>

#if (defined(TEST_IGN_WSDM))
  if (HAR_IGN_WSDM_IDX == algo)
 802595e:	2c02      	cmp	r4, #2
 8025960:	d002      	beq.n	8025968 <HAR_Initialize+0x48>
  {
    HAR_GetTestSamples_Init();
  }
#endif
  return 0;
 8025962:	4628      	mov	r0, r5
}
 8025964:	b003      	add	sp, #12
 8025966:	bd30      	pop	{r4, r5, pc}
    HAR_GetTestSamples_Init();
 8025968:	f000 f894 	bl	8025a94 <HAR_GetTestSamples_Init>
  return 0;
 802596c:	4628      	mov	r0, r5
}
 802596e:	b003      	add	sp, #12
 8025970:	bd30      	pop	{r4, r5, pc}
    return -1 ;
 8025972:	f04f 30ff 	mov.w	r0, #4294967295
 8025976:	e7f5      	b.n	8025964 <HAR_Initialize+0x44>
 8025978:	20014b9c 	.word	0x20014b9c
 802597c:	40021000 	.word	0x40021000
 8025980:	08039c38 	.word	0x08039c38

08025984 <HAR_DeInitialize>:

int8_t HAR_DeInitialize(HAR_algoIdx_t algo)
{
  if (algo == HAR_ALGO_IDX_NONE)
 8025984:	28ff      	cmp	r0, #255	; 0xff
 8025986:	d01a      	beq.n	80259be <HAR_DeInitialize+0x3a>
{
 8025988:	b538      	push	{r3, r4, r5, lr}
  {
    return -1;
  }

  if (aiDeInit(aiHarAlgoNames[algo], aiHarAlgoCtx[algo]))
 802598a:	4b0e      	ldr	r3, [pc, #56]	; (80259c4 <HAR_DeInitialize+0x40>)
 802598c:	eb03 0280 	add.w	r2, r3, r0, lsl #2
 8025990:	f853 1020 	ldr.w	r1, [r3, r0, lsl #2]
 8025994:	4604      	mov	r4, r0
 8025996:	68d0      	ldr	r0, [r2, #12]
 8025998:	f7fa fd48 	bl	802042c <aiDeInit>
 802599c:	4605      	mov	r5, r0
 802599e:	b958      	cbnz	r0, 80259b8 <HAR_DeInitialize+0x34>
    return -1 ;

  __HAL_RCC_CRC_CLK_DISABLE();
 80259a0:	4a09      	ldr	r2, [pc, #36]	; (80259c8 <HAR_DeInitialize+0x44>)
 80259a2:	6c93      	ldr	r3, [r2, #72]	; 0x48

#if (defined(TEST_IGN_WSDM))
  if (HAR_IGN_WSDM_IDX == algo)
 80259a4:	2c02      	cmp	r4, #2
  __HAL_RCC_CRC_CLK_DISABLE();
 80259a6:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
 80259aa:	6493      	str	r3, [r2, #72]	; 0x48
  if (HAR_IGN_WSDM_IDX == algo)
 80259ac:	d000      	beq.n	80259b0 <HAR_DeInitialize+0x2c>
  {
    HAR_GetTestSamples_DeInit();
  }
#endif
  return 0;
}
 80259ae:	bd38      	pop	{r3, r4, r5, pc}
    HAR_GetTestSamples_DeInit();
 80259b0:	f000 f878 	bl	8025aa4 <HAR_GetTestSamples_DeInit>
  return 0;
 80259b4:	4628      	mov	r0, r5
}
 80259b6:	bd38      	pop	{r3, r4, r5, pc}
    return -1;
 80259b8:	f04f 30ff 	mov.w	r0, #4294967295
}
 80259bc:	bd38      	pop	{r3, r4, r5, pc}
    return -1;
 80259be:	f04f 30ff 	mov.w	r0, #4294967295
}
 80259c2:	4770      	bx	lr
 80259c4:	08039c38 	.word	0x08039c38
 80259c8:	40021000 	.word	0x40021000

080259cc <HAR_get_Activity_Code>:
 * @param  None
 * @retval activity index
 */
HAR_output_t HAR_get_Activity_Code(HAR_algoIdx_t algo)
{
  return ActivityCode[algo];
 80259cc:	4b02      	ldr	r3, [pc, #8]	; (80259d8 <HAR_get_Activity_Code+0xc>)
 80259ce:	4418      	add	r0, r3
}
 80259d0:	f890 0258 	ldrb.w	r0, [r0, #600]	; 0x258
 80259d4:	4770      	bx	lr
 80259d6:	bf00      	nop
 80259d8:	20014b9c 	.word	0x20014b9c

080259dc <HAR_GetTestSamples>:
 * @retval None
 */
void HAR_GetTestSamples(HAR_input_t *iDataIN)
{
  const float *input;
  switch (seq_idx){
 80259dc:	4a26      	ldr	r2, [pc, #152]	; (8025a78 <HAR_GetTestSamples+0x9c>)
 80259de:	6813      	ldr	r3, [r2, #0]
 80259e0:	2b03      	cmp	r3, #3
 80259e2:	d823      	bhi.n	8025a2c <HAR_GetTestSamples+0x50>
{
 80259e4:	b510      	push	{r4, lr}
 80259e6:	4c25      	ldr	r4, [pc, #148]	; (8025a7c <HAR_GetTestSamples+0xa0>)
  default:
    while (1){};

  }

  iDataIN->AccX = input[in_idx++] ;
 80259e8:	6851      	ldr	r1, [r2, #4]
 80259ea:	f854 4023 	ldr.w	r4, [r4, r3, lsl #2]
 80259ee:	eb04 0c81 	add.w	ip, r4, r1, lsl #2
  iDataIN->AccY = input[in_idx++] ;
  iDataIN->AccZ = input[in_idx++] ;
 80259f2:	3103      	adds	r1, #3
  iDataIN->AccX = input[in_idx++] ;
 80259f4:	f8dc e000 	ldr.w	lr, [ip]
 80259f8:	f8c0 e000 	str.w	lr, [r0]
  iDataIN->AccY = input[in_idx++] ;
 80259fc:	f8dc e004 	ldr.w	lr, [ip, #4]
 8025a00:	f8c0 e004 	str.w	lr, [r0, #4]
  iDataIN->AccZ = input[in_idx++] ;
 8025a04:	f8dc c008 	ldr.w	ip, [ip, #8]
 8025a08:	6051      	str	r1, [r2, #4]

  if (in_idx >=  TEST_SEQ_LEN )
 8025a0a:	f5b1 7f61 	cmp.w	r1, #900	; 0x384
  iDataIN->AccZ = input[in_idx++] ;
 8025a0e:	f8c0 c008 	str.w	ip, [r0, #8]
  if (in_idx >=  TEST_SEQ_LEN )
 8025a12:	db10      	blt.n	8025a36 <HAR_GetTestSamples+0x5a>
  {
    in_idx = 0;
    if (++seq_idx == 4 ) seq_idx = 0;
 8025a14:	1c59      	adds	r1, r3, #1
    in_idx = 0;
 8025a16:	2000      	movs	r0, #0
    if (++seq_idx == 4 ) seq_idx = 0;
 8025a18:	2904      	cmp	r1, #4
 8025a1a:	e9c2 1000 	strd	r1, r0, [r2]
 8025a1e:	d006      	beq.n	8025a2e <HAR_GetTestSamples+0x52>
      switch (seq_idx){
 8025a20:	3b01      	subs	r3, #1
 8025a22:	2b01      	cmp	r3, #1
 8025a24:	d81f      	bhi.n	8025a66 <HAR_GetTestSamples+0x8a>
 8025a26:	e8df f003 	tbb	[pc, r3]
 8025a2a:	1007      	.short	0x1007
    while (1){};
 8025a2c:	e7fe      	b.n	8025a2c <HAR_GetTestSamples+0x50>
        case 0:
          SENSING1_PRINTF("standing for 15 s\r\n");
 8025a2e:	4b14      	ldr	r3, [pc, #80]	; (8025a80 <HAR_GetTestSamples+0xa4>)
    if (++seq_idx == 4 ) seq_idx = 0;
 8025a30:	6010      	str	r0, [r2, #0]
          SENSING1_PRINTF("standing for 15 s\r\n");
 8025a32:	781b      	ldrb	r3, [r3, #0]
 8025a34:	b993      	cbnz	r3, 8025a5c <HAR_GetTestSamples+0x80>
        case 3:
          SENSING1_PRINTF("stairs for 15 s\r\n");
          break;
        }
  }
}
 8025a36:	bd10      	pop	{r4, pc}
          SENSING1_PRINTF("walking for 15 s\r\n");
 8025a38:	4b11      	ldr	r3, [pc, #68]	; (8025a80 <HAR_GetTestSamples+0xa4>)
 8025a3a:	781b      	ldrb	r3, [r3, #0]
 8025a3c:	2b00      	cmp	r3, #0
 8025a3e:	d0fa      	beq.n	8025a36 <HAR_GetTestSamples+0x5a>
}
 8025a40:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
          SENSING1_PRINTF("walking for 15 s\r\n");
 8025a44:	480f      	ldr	r0, [pc, #60]	; (8025a84 <HAR_GetTestSamples+0xa8>)
 8025a46:	f002 bb85 	b.w	8028154 <puts>
          SENSING1_PRINTF("stairs for 15 s\r\n");
 8025a4a:	4b0d      	ldr	r3, [pc, #52]	; (8025a80 <HAR_GetTestSamples+0xa4>)
 8025a4c:	781b      	ldrb	r3, [r3, #0]
 8025a4e:	2b00      	cmp	r3, #0
 8025a50:	d0f1      	beq.n	8025a36 <HAR_GetTestSamples+0x5a>
}
 8025a52:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
          SENSING1_PRINTF("stairs for 15 s\r\n");
 8025a56:	480c      	ldr	r0, [pc, #48]	; (8025a88 <HAR_GetTestSamples+0xac>)
 8025a58:	f002 bb7c 	b.w	8028154 <puts>
}
 8025a5c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
          SENSING1_PRINTF("standing for 15 s\r\n");
 8025a60:	480a      	ldr	r0, [pc, #40]	; (8025a8c <HAR_GetTestSamples+0xb0>)
 8025a62:	f002 bb77 	b.w	8028154 <puts>
          SENSING1_PRINTF("jogging for 15 s\r\n");
 8025a66:	4b06      	ldr	r3, [pc, #24]	; (8025a80 <HAR_GetTestSamples+0xa4>)
 8025a68:	781b      	ldrb	r3, [r3, #0]
 8025a6a:	2b00      	cmp	r3, #0
 8025a6c:	d0e3      	beq.n	8025a36 <HAR_GetTestSamples+0x5a>
}
 8025a6e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
          SENSING1_PRINTF("jogging for 15 s\r\n");
 8025a72:	4807      	ldr	r0, [pc, #28]	; (8025a90 <HAR_GetTestSamples+0xb4>)
 8025a74:	f002 bb6e 	b.w	8028154 <puts>
 8025a78:	20014df8 	.word	0x20014df8
 8025a7c:	08039c50 	.word	0x08039c50
 8025a80:	20000d84 	.word	0x20000d84
 8025a84:	0804443c 	.word	0x0804443c
 8025a88:	08044450 	.word	0x08044450
 8025a8c:	08044414 	.word	0x08044414
 8025a90:	08044428 	.word	0x08044428

08025a94 <HAR_GetTestSamples_Init>:
 * @param  None
 * @retval None
 */
void HAR_GetTestSamples_Init(void)
{
	in_idx = 0;
 8025a94:	4b02      	ldr	r3, [pc, #8]	; (8025aa0 <HAR_GetTestSamples_Init+0xc>)
 8025a96:	2200      	movs	r2, #0
	seq_idx = 0 ;
 8025a98:	e9c3 2200 	strd	r2, r2, [r3]
}
 8025a9c:	4770      	bx	lr
 8025a9e:	bf00      	nop
 8025aa0:	20014df8 	.word	0x20014df8

08025aa4 <HAR_GetTestSamples_DeInit>:
 * @param  None
 * @retval None
 */
void HAR_GetTestSamples_DeInit(void)
{
}
 8025aa4:	4770      	bx	lr
 8025aa6:	bf00      	nop

08025aa8 <ai_har_gmp_get_info>:
/**  PUBLIC APIs SECTION  *****************************************************/

AI_API_ENTRY
ai_bool ai_har_gmp_get_info(
  ai_handle network, ai_network_report* report)
{
 8025aa8:	b530      	push	{r4, r5, lr}
 8025aaa:	460d      	mov	r5, r1
 8025aac:	b09f      	sub	sp, #124	; 0x7c
 8025aae:	4604      	mov	r4, r0
  ai_network* net_ctx = AI_NETWORK_ACQUIRE_CTX(network);
 8025ab0:	f7de fc67 	bl	8004382 <ai_platform_context_acquire>

  if ( report && net_ctx )
 8025ab4:	2d00      	cmp	r5, #0
 8025ab6:	d038      	beq.n	8025b2a <ai_har_gmp_get_info+0x82>
 8025ab8:	b398      	cbz	r0, 8025b22 <ai_har_gmp_get_info+0x7a>
  {
    ai_network_report r = {
 8025aba:	2264      	movs	r2, #100	; 0x64
 8025abc:	2100      	movs	r1, #0
 8025abe:	a805      	add	r0, sp, #20
 8025ac0:	f001 fd5a 	bl	8027578 <memset>
 8025ac4:	491b      	ldr	r1, [pc, #108]	; (8025b34 <ai_har_gmp_get_info+0x8c>)
 8025ac6:	4b1c      	ldr	r3, [pc, #112]	; (8025b38 <ai_har_gmp_get_info+0x90>)
 8025ac8:	4a1c      	ldr	r2, [pc, #112]	; (8025b3c <ai_har_gmp_get_info+0x94>)
 8025aca:	e9cd 1301 	strd	r1, r3, [sp, #4]
 8025ace:	4b1c      	ldr	r3, [pc, #112]	; (8025b40 <ai_har_gmp_get_info+0x98>)
 8025ad0:	e9cd 2303 	strd	r2, r3, [sp, #12]
      .model_signature   = AI_HAR_GMP_MODEL_SIGNATURE,
      .model_datetime    = AI_TOOLS_DATE_TIME,
      
      .compile_datetime  = AI_TOOLS_COMPILE_TIME,
      
      .runtime_revision  = ai_platform_runtime_get_revision(),
 8025ad4:	f7de fbef 	bl	80042b6 <ai_platform_runtime_get_revision>
    ai_network_report r = {
 8025ad8:	9005      	str	r0, [sp, #20]
      .runtime_version   = ai_platform_runtime_get_version(),
 8025ada:	f7de fc04 	bl	80042e6 <ai_platform_runtime_get_version>
    ai_network_report r = {
 8025ade:	4b19      	ldr	r3, [pc, #100]	; (8025b44 <ai_har_gmp_get_info+0x9c>)
 8025ae0:	f44f 7282 	mov.w	r2, #260	; 0x104
 8025ae4:	e9cd 0306 	strd	r0, r3, [sp, #24]
 8025ae8:	f240 3301 	movw	r3, #769	; 0x301
 8025aec:	f8ad 2020 	strh.w	r2, [sp, #32]
 8025af0:	f8ad 3024 	strh.w	r3, [sp, #36]	; 0x24
      .tool_version      = {AI_TOOLS_VERSION_MAJOR, AI_TOOLS_VERSION_MINOR,
                            AI_TOOLS_VERSION_MICRO, 0x0},
      .tool_api_version  = {AI_TOOLS_API_VERSION_MAJOR, AI_TOOLS_API_VERSION_MINOR,
                            AI_TOOLS_API_VERSION_MICRO, 0x0},

      .api_version            = ai_platform_api_get_version(),
 8025af4:	f7de fc11 	bl	800431a <ai_platform_api_get_version>
 8025af8:	900a      	str	r0, [sp, #40]	; 0x28
      .interface_api_version  = ai_platform_interface_api_get_version(),
 8025afa:	f7de fc28 	bl	800434e <ai_platform_interface_api_get_version>
    ai_network_report r = {
 8025afe:	4b12      	ldr	r3, [pc, #72]	; (8025b48 <ai_har_gmp_get_info+0xa0>)
      .interface_api_version  = ai_platform_interface_api_get_version(),
 8025b00:	4602      	mov	r2, r0
      .params            = AI_STRUCT_INIT,
      .n_nodes           = 0,
      .signature         = 0x0,
    };

    if ( !ai_platform_api_get_network_report(network, &r) ) return false;
 8025b02:	a901      	add	r1, sp, #4
 8025b04:	4620      	mov	r0, r4
    ai_network_report r = {
 8025b06:	e9cd 230b 	strd	r2, r3, [sp, #44]	; 0x2c
    if ( !ai_platform_api_get_network_report(network, &r) ) return false;
 8025b0a:	f7de fc88 	bl	800441e <ai_platform_api_get_network_report>
 8025b0e:	4604      	mov	r4, r0
 8025b10:	b140      	cbz	r0, 8025b24 <ai_har_gmp_get_info+0x7c>

    *report = r;
 8025b12:	2274      	movs	r2, #116	; 0x74
 8025b14:	a901      	add	r1, sp, #4
 8025b16:	4628      	mov	r0, r5
 8025b18:	f001 fd06 	bl	8027528 <memcpy>
    return true;
  }

  return false;
}
 8025b1c:	4620      	mov	r0, r4
 8025b1e:	b01f      	add	sp, #124	; 0x7c
 8025b20:	bd30      	pop	{r4, r5, pc}
  return false;
 8025b22:	4604      	mov	r4, r0
}
 8025b24:	4620      	mov	r0, r4
 8025b26:	b01f      	add	sp, #124	; 0x7c
 8025b28:	bd30      	pop	{r4, r5, pc}
  return false;
 8025b2a:	462c      	mov	r4, r5
}
 8025b2c:	4620      	mov	r0, r4
 8025b2e:	b01f      	add	sp, #124	; 0x7c
 8025b30:	bd30      	pop	{r4, r5, pc}
 8025b32:	bf00      	nop
 8025b34:	08042c8c 	.word	0x08042c8c
 8025b38:	08044464 	.word	0x08044464
 8025b3c:	08044488 	.word	0x08044488
 8025b40:	080444a4 	.word	0x080444a4
 8025b44:	08041bfc 	.word	0x08041bfc
 8025b48:	00010d3b 	.word	0x00010d3b

08025b4c <ai_har_gmp_get_error>:

AI_API_ENTRY
ai_error ai_har_gmp_get_error(ai_handle network)
{
  return ai_platform_network_get_error(network);
 8025b4c:	f7de bc3b 	b.w	80043c6 <ai_platform_network_get_error>

08025b50 <ai_har_gmp_create>:
}

AI_API_ENTRY
ai_error ai_har_gmp_create(
  ai_handle* network, const ai_buffer* network_config)
{
 8025b50:	b510      	push	{r4, lr}
  return ai_platform_network_create(
 8025b52:	2303      	movs	r3, #3
{
 8025b54:	b082      	sub	sp, #8
  return ai_platform_network_create(
 8025b56:	2400      	movs	r4, #0
 8025b58:	e9cd 3400 	strd	r3, r4, [sp]
 8025b5c:	4a02      	ldr	r2, [pc, #8]	; (8025b68 <ai_har_gmp_create+0x18>)
 8025b5e:	2301      	movs	r3, #1
 8025b60:	f7de fd1c 	bl	800459c <ai_platform_network_create>
    network, network_config, 
    &AI_NET_OBJ_INSTANCE,
    AI_TOOLS_API_VERSION_MAJOR, AI_TOOLS_API_VERSION_MINOR, AI_TOOLS_API_VERSION_MICRO);
}
 8025b64:	b002      	add	sp, #8
 8025b66:	bd10      	pop	{r4, pc}
 8025b68:	20000e34 	.word	0x20000e34

08025b6c <ai_har_gmp_destroy>:

AI_API_ENTRY
ai_handle ai_har_gmp_destroy(ai_handle network)
{
  return ai_platform_network_destroy(network);
 8025b6c:	f7de bd5b 	b.w	8004626 <ai_platform_network_destroy>

08025b70 <ai_har_gmp_init>:
}

AI_API_ENTRY
ai_bool ai_har_gmp_init(
  ai_handle network, const ai_network_params* params)
{
 8025b70:	b538      	push	{r3, r4, r5, lr}
 8025b72:	460c      	mov	r4, r1
  ai_network* net_ctx = ai_platform_network_init(network, params);
 8025b74:	f7de fd7a 	bl	800466c <ai_platform_network_init>
  if ( !net_ctx ) return false;
 8025b78:	2800      	cmp	r0, #0
 8025b7a:	d04b      	beq.n	8025c14 <ai_har_gmp_init+0xa4>
    dense_3_bias_array.format |= AI_FMT_FLAG_CONST;
 8025b7c:	4b26      	ldr	r3, [pc, #152]	; (8025c18 <ai_har_gmp_init+0xa8>)
 8025b7e:	6920      	ldr	r0, [r4, #16]
  ai_ptr activations = AI_PTR(AI_PTR_ALIGN(activation_buffer->data, 4));
 8025b80:	6aa2      	ldr	r2, [r4, #40]	; 0x28
    dense_3_bias_array.format |= AI_FMT_FLAG_CONST;
 8025b82:	6d99      	ldr	r1, [r3, #88]	; 0x58
    dense_3_weights_array.format |= AI_FMT_FLAG_CONST;
 8025b84:	6e9c      	ldr	r4, [r3, #104]	; 0x68
    dense_3_bias_array.format |= AI_FMT_FLAG_CONST;
 8025b86:	f041 4180 	orr.w	r1, r1, #1073741824	; 0x40000000
    dense_3_weights_array.format |= AI_FMT_FLAG_CONST;
 8025b8a:	f044 4480 	orr.w	r4, r4, #1073741824	; 0x40000000
 8025b8e:	669c      	str	r4, [r3, #104]	; 0x68
    dense_3_bias_array.format |= AI_FMT_FLAG_CONST;
 8025b90:	6599      	str	r1, [r3, #88]	; 0x58
    conv2d_1_bias_array.format |= AI_FMT_FLAG_CONST;
 8025b92:	6f9c      	ldr	r4, [r3, #120]	; 0x78
    conv2d_1_weights_array.format |= AI_FMT_FLAG_CONST;
 8025b94:	f8d3 1088 	ldr.w	r1, [r3, #136]	; 0x88
    conv2d_1_bias_array.format |= AI_FMT_FLAG_CONST;
 8025b98:	f044 4480 	orr.w	r4, r4, #1073741824	; 0x40000000
    conv2d_1_weights_array.format |= AI_FMT_FLAG_CONST;
 8025b9c:	f041 4180 	orr.w	r1, r1, #1073741824	; 0x40000000
    conv2d_1_bias_array.format |= AI_FMT_FLAG_CONST;
 8025ba0:	679c      	str	r4, [r3, #120]	; 0x78
    conv2d_1_weights_array.format |= AI_FMT_FLAG_CONST;
 8025ba2:	f8c3 1088 	str.w	r1, [r3, #136]	; 0x88
    conv2d_0_weights_array.format |= AI_FMT_FLAG_CONST;
 8025ba6:	f8d3 40a8 	ldr.w	r4, [r3, #168]	; 0xa8
    conv2d_1_weights_array.data = AI_PTR(weights + 384);
 8025baa:	f500 71c0 	add.w	r1, r0, #384	; 0x180
    conv2d_1_weights_array.data_start = AI_PTR(weights + 384);
 8025bae:	e9c3 1124 	strd	r1, r1, [r3, #144]	; 0x90
  ai_ptr activations = AI_PTR(AI_PTR_ALIGN(activation_buffer->data, 4));
 8025bb2:	3203      	adds	r2, #3
    conv2d_0_bias_array.format |= AI_FMT_FLAG_CONST;
 8025bb4:	f8d3 1098 	ldr.w	r1, [r3, #152]	; 0x98
  ai_ptr activations = AI_PTR(AI_PTR_ALIGN(activation_buffer->data, 4));
 8025bb8:	f022 0203 	bic.w	r2, r2, #3
    dense_3_bias_array.data = AI_PTR(weights + 5888);
 8025bbc:	f500 55b8 	add.w	r5, r0, #5888	; 0x1700
    conv2d_0_weights_array.format |= AI_FMT_FLAG_CONST;
 8025bc0:	f044 4480 	orr.w	r4, r4, #1073741824	; 0x40000000
    dense_3_bias_array.data_start = AI_PTR(weights + 5888);
 8025bc4:	e9c3 5518 	strd	r5, r5, [r3, #96]	; 0x60
    conv2d_0_bias_array.format |= AI_FMT_FLAG_CONST;
 8025bc8:	f041 4180 	orr.w	r1, r1, #1073741824	; 0x40000000
    dense_3_weights_array.data = AI_PTR(weights + 5568);
 8025bcc:	f500 55ae 	add.w	r5, r0, #5568	; 0x15c0
    conv2d_0_weights_array.format |= AI_FMT_FLAG_CONST;
 8025bd0:	f8c3 40a8 	str.w	r4, [r3, #168]	; 0xa8
    conv2d_1_scratch0_array.data = AI_PTR(activations + 3840);
 8025bd4:	f502 6470 	add.w	r4, r2, #3840	; 0xf00
    dense_3_weights_array.data_start = AI_PTR(weights + 5568);
 8025bd8:	e9c3 551c 	strd	r5, r5, [r3, #112]	; 0x70
    conv2d_0_weights_array.data_start = AI_PTR(weights + 0);
 8025bdc:	e9c3 002c 	strd	r0, r0, [r3, #176]	; 0xb0
    conv2d_1_scratch0_array.data_start = AI_PTR(activations + 3840);
 8025be0:	e9c3 4430 	strd	r4, r4, [r3, #192]	; 0xc0
    conv2d_0_bias_array.data = AI_PTR(weights + 320);
 8025be4:	f500 75a0 	add.w	r5, r0, #320	; 0x140
    conv2d_0_bias_array.format |= AI_FMT_FLAG_CONST;
 8025be8:	f8c3 1098 	str.w	r1, [r3, #152]	; 0x98
    conv2d_1_bias_array.data = AI_PTR(weights + 5504);
 8025bec:	f500 50ac 	add.w	r0, r0, #5504	; 0x1580
    input_0_output_array.data = AI_PTR(NULL);
 8025bf0:	2100      	movs	r1, #0
    conv2d_1_output_array.data = AI_PTR(activations + 6912);
 8025bf2:	f502 54d8 	add.w	r4, r2, #6912	; 0x1b00
    conv2d_1_bias_array.data_start = AI_PTR(weights + 5504);
 8025bf6:	e9c3 0020 	strd	r0, r0, [r3, #128]	; 0x80
    conv2d_0_bias_array.data_start = AI_PTR(weights + 320);
 8025bfa:	e9c3 5528 	strd	r5, r5, [r3, #160]	; 0xa0
    input_0_output_array.data_start = AI_PTR(NULL);
 8025bfe:	e9c3 1134 	strd	r1, r1, [r3, #208]	; 0xd0
    conv2d_0_output_array.data_start = AI_PTR(activations + 0);
 8025c02:	e9c3 2238 	strd	r2, r2, [r3, #224]	; 0xe0
    conv2d_1_output_array.data_start = AI_PTR(activations + 6912);
 8025c06:	e9c3 443c 	strd	r4, r4, [r3, #240]	; 0xf0
    dense_3_output_array.data_start = AI_PTR(activations + 0);
 8025c0a:	e9c3 2240 	strd	r2, r2, [r3, #256]	; 0x100
    nl_4_output_array.data_start = AI_PTR(NULL);
 8025c0e:	e9c3 1144 	strd	r1, r1, [r3, #272]	; 0x110

  ai_bool ok = true;
  ok &= har_gmp_configure_weights(net_ctx, &params->params);
  ok &= har_gmp_configure_activations(net_ctx, &params->activations);

  return ok;
 8025c12:	2001      	movs	r0, #1
}
 8025c14:	bd38      	pop	{r3, r4, r5, pc}
 8025c16:	bf00      	nop
 8025c18:	20000e34 	.word	0x20000e34

08025c1c <ai_har_gmp_run>:

AI_API_ENTRY
ai_i32 ai_har_gmp_run(
  ai_handle network, const ai_buffer* input, ai_buffer* output)
{
  return ai_platform_network_process(network, input, output);
 8025c1c:	f7de bd82 	b.w	8004724 <ai_platform_network_process>

08025c20 <ai_har_gmp_forward>:
}

AI_API_ENTRY
ai_i32 ai_har_gmp_forward(ai_handle network, const ai_buffer* input)
{
  return ai_platform_network_process(network, input, NULL);
 8025c20:	2200      	movs	r2, #0
 8025c22:	f7de bd7f 	b.w	8004724 <ai_platform_network_process>
 8025c26:	bf00      	nop

08025c28 <ai_har_gmp_data_weights_get>:
    0x96, 0x40, 0x0f, 0x1f, 0x10, 0xc0, 0xe6, 0x7e, 0x81,
    0xc0, 0x2a, 0x7a, 0x9e, 0xbe, 0xce, 0x64, 0xf5, 0x3f
  };

  return AI_HANDLE_PTR(s_har_gmp_weights);
}
 8025c28:	4800      	ldr	r0, [pc, #0]	; (8025c2c <ai_har_gmp_data_weights_get+0x4>)
 8025c2a:	4770      	bx	lr
 8025c2c:	0803d4c0 	.word	0x0803d4c0

08025c30 <ai_har_ign_get_info>:
/**  PUBLIC APIs SECTION  *****************************************************/

AI_API_ENTRY
ai_bool ai_har_ign_get_info(
  ai_handle network, ai_network_report* report)
{
 8025c30:	b530      	push	{r4, r5, lr}
 8025c32:	460d      	mov	r5, r1
 8025c34:	b09f      	sub	sp, #124	; 0x7c
 8025c36:	4604      	mov	r4, r0
  ai_network* net_ctx = AI_NETWORK_ACQUIRE_CTX(network);
 8025c38:	f7de fba3 	bl	8004382 <ai_platform_context_acquire>

  if ( report && net_ctx )
 8025c3c:	2d00      	cmp	r5, #0
 8025c3e:	d039      	beq.n	8025cb4 <ai_har_ign_get_info+0x84>
 8025c40:	b3a0      	cbz	r0, 8025cac <ai_har_ign_get_info+0x7c>
  {
    ai_network_report r = {
 8025c42:	2264      	movs	r2, #100	; 0x64
 8025c44:	2100      	movs	r1, #0
 8025c46:	a805      	add	r0, sp, #20
 8025c48:	f001 fc96 	bl	8027578 <memset>
 8025c4c:	491b      	ldr	r1, [pc, #108]	; (8025cbc <ai_har_ign_get_info+0x8c>)
 8025c4e:	4b1c      	ldr	r3, [pc, #112]	; (8025cc0 <ai_har_ign_get_info+0x90>)
 8025c50:	4a1c      	ldr	r2, [pc, #112]	; (8025cc4 <ai_har_ign_get_info+0x94>)
 8025c52:	e9cd 1301 	strd	r1, r3, [sp, #4]
 8025c56:	4b1c      	ldr	r3, [pc, #112]	; (8025cc8 <ai_har_ign_get_info+0x98>)
 8025c58:	e9cd 2303 	strd	r2, r3, [sp, #12]
      .model_signature   = AI_HAR_IGN_MODEL_SIGNATURE,
      .model_datetime    = AI_TOOLS_DATE_TIME,
      
      .compile_datetime  = AI_TOOLS_COMPILE_TIME,
      
      .runtime_revision  = ai_platform_runtime_get_revision(),
 8025c5c:	f7de fb2b 	bl	80042b6 <ai_platform_runtime_get_revision>
    ai_network_report r = {
 8025c60:	9005      	str	r0, [sp, #20]
      .runtime_version   = ai_platform_runtime_get_version(),
 8025c62:	f7de fb40 	bl	80042e6 <ai_platform_runtime_get_version>
    ai_network_report r = {
 8025c66:	4b19      	ldr	r3, [pc, #100]	; (8025ccc <ai_har_ign_get_info+0x9c>)
 8025c68:	f44f 7282 	mov.w	r2, #260	; 0x104
 8025c6c:	e9cd 0306 	strd	r0, r3, [sp, #24]
 8025c70:	f240 3301 	movw	r3, #769	; 0x301
 8025c74:	f8ad 2020 	strh.w	r2, [sp, #32]
 8025c78:	f8ad 3024 	strh.w	r3, [sp, #36]	; 0x24
      .tool_version      = {AI_TOOLS_VERSION_MAJOR, AI_TOOLS_VERSION_MINOR,
                            AI_TOOLS_VERSION_MICRO, 0x0},
      .tool_api_version  = {AI_TOOLS_API_VERSION_MAJOR, AI_TOOLS_API_VERSION_MINOR,
                            AI_TOOLS_API_VERSION_MICRO, 0x0},

      .api_version            = ai_platform_api_get_version(),
 8025c7c:	f7de fb4d 	bl	800431a <ai_platform_api_get_version>
 8025c80:	900a      	str	r0, [sp, #40]	; 0x28
      .interface_api_version  = ai_platform_interface_api_get_version(),
 8025c82:	f7de fb64 	bl	800434e <ai_platform_interface_api_get_version>
    ai_network_report r = {
 8025c86:	f643 034f 	movw	r3, #14415	; 0x384f
      .interface_api_version  = ai_platform_interface_api_get_version(),
 8025c8a:	4602      	mov	r2, r0
      .params            = AI_STRUCT_INIT,
      .n_nodes           = 0,
      .signature         = 0x0,
    };

    if ( !ai_platform_api_get_network_report(network, &r) ) return false;
 8025c8c:	a901      	add	r1, sp, #4
 8025c8e:	4620      	mov	r0, r4
    ai_network_report r = {
 8025c90:	e9cd 230b 	strd	r2, r3, [sp, #44]	; 0x2c
    if ( !ai_platform_api_get_network_report(network, &r) ) return false;
 8025c94:	f7de fbc3 	bl	800441e <ai_platform_api_get_network_report>
 8025c98:	4604      	mov	r4, r0
 8025c9a:	b140      	cbz	r0, 8025cae <ai_har_ign_get_info+0x7e>

    *report = r;
 8025c9c:	2274      	movs	r2, #116	; 0x74
 8025c9e:	a901      	add	r1, sp, #4
 8025ca0:	4628      	mov	r0, r5
 8025ca2:	f001 fc41 	bl	8027528 <memcpy>
    return true;
  }

  return false;
}
 8025ca6:	4620      	mov	r0, r4
 8025ca8:	b01f      	add	sp, #124	; 0x7c
 8025caa:	bd30      	pop	{r4, r5, pc}
  return false;
 8025cac:	4604      	mov	r4, r0
}
 8025cae:	4620      	mov	r0, r4
 8025cb0:	b01f      	add	sp, #124	; 0x7c
 8025cb2:	bd30      	pop	{r4, r5, pc}
  return false;
 8025cb4:	462c      	mov	r4, r5
}
 8025cb6:	4620      	mov	r0, r4
 8025cb8:	b01f      	add	sp, #124	; 0x7c
 8025cba:	bd30      	pop	{r4, r5, pc}
 8025cbc:	08042c94 	.word	0x08042c94
 8025cc0:	080444bc 	.word	0x080444bc
 8025cc4:	080444e0 	.word	0x080444e0
 8025cc8:	080444fc 	.word	0x080444fc
 8025ccc:	08041bfc 	.word	0x08041bfc

08025cd0 <ai_har_ign_get_error>:

AI_API_ENTRY
ai_error ai_har_ign_get_error(ai_handle network)
{
  return ai_platform_network_get_error(network);
 8025cd0:	f7de bb79 	b.w	80043c6 <ai_platform_network_get_error>

08025cd4 <ai_har_ign_create>:
}

AI_API_ENTRY
ai_error ai_har_ign_create(
  ai_handle* network, const ai_buffer* network_config)
{
 8025cd4:	b510      	push	{r4, lr}
  return ai_platform_network_create(
 8025cd6:	2303      	movs	r3, #3
{
 8025cd8:	b082      	sub	sp, #8
  return ai_platform_network_create(
 8025cda:	2400      	movs	r4, #0
 8025cdc:	e9cd 3400 	strd	r3, r4, [sp]
 8025ce0:	4a02      	ldr	r2, [pc, #8]	; (8025cec <ai_har_ign_create+0x18>)
 8025ce2:	2301      	movs	r3, #1
 8025ce4:	f7de fc5a 	bl	800459c <ai_platform_network_create>
    network, network_config, 
    &AI_NET_OBJ_INSTANCE,
    AI_TOOLS_API_VERSION_MAJOR, AI_TOOLS_API_VERSION_MINOR, AI_TOOLS_API_VERSION_MICRO);
}
 8025ce8:	b002      	add	sp, #8
 8025cea:	bd10      	pop	{r4, pc}
 8025cec:	20001420 	.word	0x20001420

08025cf0 <ai_har_ign_destroy>:

AI_API_ENTRY
ai_handle ai_har_ign_destroy(ai_handle network)
{
  return ai_platform_network_destroy(network);
 8025cf0:	f7de bc99 	b.w	8004626 <ai_platform_network_destroy>

08025cf4 <ai_har_ign_init>:
}

AI_API_ENTRY
ai_bool ai_har_ign_init(
  ai_handle network, const ai_network_params* params)
{
 8025cf4:	b570      	push	{r4, r5, r6, lr}
 8025cf6:	460c      	mov	r4, r1
  ai_network* net_ctx = ai_platform_network_init(network, params);
 8025cf8:	f7de fcb8 	bl	800466c <ai_platform_network_init>
  if ( !net_ctx ) return false;
 8025cfc:	2800      	cmp	r0, #0
 8025cfe:	d052      	beq.n	8025da6 <ai_har_ign_init+0xb2>
    dense_2_bias_array.format |= AI_FMT_FLAG_CONST;
 8025d00:	4b29      	ldr	r3, [pc, #164]	; (8025da8 <ai_har_ign_init+0xb4>)
 8025d02:	6922      	ldr	r2, [r4, #16]
  ai_ptr activations = AI_PTR(AI_PTR_ALIGN(activation_buffer->data, 4));
 8025d04:	6aa1      	ldr	r1, [r4, #40]	; 0x28
    dense_2_weights_array.format |= AI_FMT_FLAG_CONST;
 8025d06:	6e9c      	ldr	r4, [r3, #104]	; 0x68
    dense_2_bias_array.format |= AI_FMT_FLAG_CONST;
 8025d08:	6d98      	ldr	r0, [r3, #88]	; 0x58
    dense_2_weights_array.format |= AI_FMT_FLAG_CONST;
 8025d0a:	f044 4480 	orr.w	r4, r4, #1073741824	; 0x40000000
 8025d0e:	669c      	str	r4, [r3, #104]	; 0x68
    dense_1_weights_array.format |= AI_FMT_FLAG_CONST;
 8025d10:	f8d3 4088 	ldr.w	r4, [r3, #136]	; 0x88
    dense_2_bias_array.format |= AI_FMT_FLAG_CONST;
 8025d14:	f040 4080 	orr.w	r0, r0, #1073741824	; 0x40000000
    dense_2_bias_array.data = AI_PTR(weights + 5536);
 8025d18:	f502 55ad 	add.w	r5, r2, #5536	; 0x15a0
    dense_2_bias_array.format |= AI_FMT_FLAG_CONST;
 8025d1c:	6598      	str	r0, [r3, #88]	; 0x58
    dense_1_weights_array.format |= AI_FMT_FLAG_CONST;
 8025d1e:	f044 4480 	orr.w	r4, r4, #1073741824	; 0x40000000
    dense_2_weights_array.data = AI_PTR(weights + 5296);
 8025d22:	f502 50a5 	add.w	r0, r2, #5280	; 0x14a0
    dense_2_bias_array.data_start = AI_PTR(weights + 5536);
 8025d26:	e9c3 5518 	strd	r5, r5, [r3, #96]	; 0x60
    dense_2_weights_array.data = AI_PTR(weights + 5296);
 8025d2a:	3010      	adds	r0, #16
    dense_1_bias_array.format |= AI_FMT_FLAG_CONST;
 8025d2c:	6f9d      	ldr	r5, [r3, #120]	; 0x78
    dense_1_weights_array.format |= AI_FMT_FLAG_CONST;
 8025d2e:	f8c3 4088 	str.w	r4, [r3, #136]	; 0x88
    dense_1_weights_array.data = AI_PTR(weights + 2656);
 8025d32:	f502 6426 	add.w	r4, r2, #2656	; 0xa60
    dense_2_weights_array.data_start = AI_PTR(weights + 5296);
 8025d36:	e9c3 001c 	strd	r0, r0, [r3, #112]	; 0x70
    dense_1_weights_array.data = AI_PTR(weights + 2656);
 8025d3a:	f8c3 4090 	str.w	r4, [r3, #144]	; 0x90
    conv2d_1_weights_array.format |= AI_FMT_FLAG_CONST;
 8025d3e:	f8d3 00a8 	ldr.w	r0, [r3, #168]	; 0xa8
    conv2d_1_bias_array.format |= AI_FMT_FLAG_CONST;
 8025d42:	f8d3 4098 	ldr.w	r4, [r3, #152]	; 0x98
    dense_1_bias_array.format |= AI_FMT_FLAG_CONST;
 8025d46:	f045 4580 	orr.w	r5, r5, #1073741824	; 0x40000000
  ai_ptr activations = AI_PTR(AI_PTR_ALIGN(activation_buffer->data, 4));
 8025d4a:	3103      	adds	r1, #3
 8025d4c:	f021 0103 	bic.w	r1, r1, #3
    conv2d_1_weights_array.data_start = AI_PTR(weights + 0);
 8025d50:	e9c3 222c 	strd	r2, r2, [r3, #176]	; 0xb0
    dense_1_bias_array.format |= AI_FMT_FLAG_CONST;
 8025d54:	679d      	str	r5, [r3, #120]	; 0x78
    dense_1_weights_array.data_start = AI_PTR(weights + 1632);
 8025d56:	f502 66cc 	add.w	r6, r2, #1632	; 0x660
    conv2d_1_bias_array.data = AI_PTR(weights + 1536);
 8025d5a:	f502 65c0 	add.w	r5, r2, #1536	; 0x600
    conv2d_1_bias_array.format |= AI_FMT_FLAG_CONST;
 8025d5e:	f044 4480 	orr.w	r4, r4, #1073741824	; 0x40000000
    conv2d_1_weights_array.format |= AI_FMT_FLAG_CONST;
 8025d62:	f040 4080 	orr.w	r0, r0, #1073741824	; 0x40000000
    dense_1_bias_array.data = AI_PTR(weights + 5248);
 8025d66:	f502 52a4 	add.w	r2, r2, #5248	; 0x1480
    dense_1_bias_array.data_start = AI_PTR(weights + 5248);
 8025d6a:	e9c3 2220 	strd	r2, r2, [r3, #128]	; 0x80
    conv2d_1_bias_array.format |= AI_FMT_FLAG_CONST;
 8025d6e:	f8c3 4098 	str.w	r4, [r3, #152]	; 0x98
    conv2d_1_weights_array.format |= AI_FMT_FLAG_CONST;
 8025d72:	f8c3 00a8 	str.w	r0, [r3, #168]	; 0xa8
    input_0_output_array.data = AI_PTR(NULL);
 8025d76:	2400      	movs	r4, #0
    conv2d_1_output_array.data = AI_PTR(activations + 864);
 8025d78:	f501 7058 	add.w	r0, r1, #864	; 0x360
    dense_2_output_array.data = AI_PTR(activations + 48);
 8025d7c:	f101 0230 	add.w	r2, r1, #48	; 0x30
    conv2d_1_output_array.data_start = AI_PTR(activations + 864);
 8025d80:	e9c3 0038 	strd	r0, r0, [r3, #224]	; 0xe0
    conv2d_1_bias_array.data_start = AI_PTR(weights + 1536);
 8025d84:	e9c3 5528 	strd	r5, r5, [r3, #160]	; 0xa0
    conv2d_1_scratch0_array.data_start = AI_PTR(activations + 0);
 8025d88:	e9c3 1130 	strd	r1, r1, [r3, #192]	; 0xc0
    input_0_output_array.data_start = AI_PTR(NULL);
 8025d8c:	e9c3 4434 	strd	r4, r4, [r3, #208]	; 0xd0
    dense_1_weights_array.data_start = AI_PTR(weights + 1632);
 8025d90:	f8c3 6094 	str.w	r6, [r3, #148]	; 0x94
    dense_1_output_array.data = AI_PTR(activations + 0);
 8025d94:	f8c3 10f0 	str.w	r1, [r3, #240]	; 0xf0
    dense_2_output_array.data_start = AI_PTR(activations + 48);
 8025d98:	e9c3 2240 	strd	r2, r2, [r3, #256]	; 0x100
    dense_2_nl_output_array.data_start = AI_PTR(NULL);
 8025d9c:	e9c3 4444 	strd	r4, r4, [r3, #272]	; 0x110

  ai_bool ok = true;
  ok &= har_ign_configure_weights(net_ctx, &params->params);
  ok &= har_ign_configure_activations(net_ctx, &params->activations);

  return ok;
 8025da0:	2001      	movs	r0, #1
    dense_1_output_array.data_start = AI_PTR(activations + 0);
 8025da2:	f8c3 10f4 	str.w	r1, [r3, #244]	; 0xf4
}
 8025da6:	bd70      	pop	{r4, r5, r6, pc}
 8025da8:	20001420 	.word	0x20001420

08025dac <ai_har_ign_run>:

AI_API_ENTRY
ai_i32 ai_har_ign_run(
  ai_handle network, const ai_buffer* input, ai_buffer* output)
{
  return ai_platform_network_process(network, input, output);
 8025dac:	f7de bcba 	b.w	8004724 <ai_platform_network_process>

08025db0 <ai_har_ign_forward>:
}

AI_API_ENTRY
ai_i32 ai_har_ign_forward(ai_handle network, const ai_buffer* input)
{
  return ai_platform_network_process(network, input, NULL);
 8025db0:	2200      	movs	r2, #0
 8025db2:	f7de bcb7 	b.w	8004724 <ai_platform_network_process>
 8025db6:	bf00      	nop

08025db8 <ai_har_ign_data_weights_get>:
    0x40, 0x3e, 0x2a, 0x23, 0x53, 0x3f, 0xb3, 0xb9, 0xcf,
    0xbf, 0x48, 0x2b, 0xe5, 0x3e, 0xd6, 0xf2, 0x81, 0xbc
  };

  return AI_HANDLE_PTR(s_har_ign_weights);
}
 8025db8:	4800      	ldr	r0, [pc, #0]	; (8025dbc <ai_har_ign_data_weights_get+0x4>)
 8025dba:	4770      	bx	lr
 8025dbc:	0803ebf4 	.word	0x0803ebf4

08025dc0 <ai_har_ign_wsdm_get_info>:
/**  PUBLIC APIs SECTION  *****************************************************/

AI_API_ENTRY
ai_bool ai_har_ign_wsdm_get_info(
  ai_handle network, ai_network_report* report)
{
 8025dc0:	b530      	push	{r4, r5, lr}
 8025dc2:	460d      	mov	r5, r1
 8025dc4:	b09f      	sub	sp, #124	; 0x7c
 8025dc6:	4604      	mov	r4, r0
  ai_network* net_ctx = AI_NETWORK_ACQUIRE_CTX(network);
 8025dc8:	f7de fadb 	bl	8004382 <ai_platform_context_acquire>

  if ( report && net_ctx )
 8025dcc:	2d00      	cmp	r5, #0
 8025dce:	d039      	beq.n	8025e44 <ai_har_ign_wsdm_get_info+0x84>
 8025dd0:	b3a0      	cbz	r0, 8025e3c <ai_har_ign_wsdm_get_info+0x7c>
  {
    ai_network_report r = {
 8025dd2:	2264      	movs	r2, #100	; 0x64
 8025dd4:	2100      	movs	r1, #0
 8025dd6:	a805      	add	r0, sp, #20
 8025dd8:	f001 fbce 	bl	8027578 <memset>
 8025ddc:	491b      	ldr	r1, [pc, #108]	; (8025e4c <ai_har_ign_wsdm_get_info+0x8c>)
 8025dde:	4b1c      	ldr	r3, [pc, #112]	; (8025e50 <ai_har_ign_wsdm_get_info+0x90>)
 8025de0:	4a1c      	ldr	r2, [pc, #112]	; (8025e54 <ai_har_ign_wsdm_get_info+0x94>)
 8025de2:	e9cd 1301 	strd	r1, r3, [sp, #4]
 8025de6:	4b1c      	ldr	r3, [pc, #112]	; (8025e58 <ai_har_ign_wsdm_get_info+0x98>)
 8025de8:	e9cd 2303 	strd	r2, r3, [sp, #12]
      .model_signature   = AI_HAR_IGN_WSDM_MODEL_SIGNATURE,
      .model_datetime    = AI_TOOLS_DATE_TIME,
      
      .compile_datetime  = AI_TOOLS_COMPILE_TIME,
      
      .runtime_revision  = ai_platform_runtime_get_revision(),
 8025dec:	f7de fa63 	bl	80042b6 <ai_platform_runtime_get_revision>
    ai_network_report r = {
 8025df0:	9005      	str	r0, [sp, #20]
      .runtime_version   = ai_platform_runtime_get_version(),
 8025df2:	f7de fa78 	bl	80042e6 <ai_platform_runtime_get_version>
    ai_network_report r = {
 8025df6:	4b19      	ldr	r3, [pc, #100]	; (8025e5c <ai_har_ign_wsdm_get_info+0x9c>)
 8025df8:	f44f 7282 	mov.w	r2, #260	; 0x104
 8025dfc:	e9cd 0306 	strd	r0, r3, [sp, #24]
 8025e00:	f240 3301 	movw	r3, #769	; 0x301
 8025e04:	f8ad 2020 	strh.w	r2, [sp, #32]
 8025e08:	f8ad 3024 	strh.w	r3, [sp, #36]	; 0x24
      .tool_version      = {AI_TOOLS_VERSION_MAJOR, AI_TOOLS_VERSION_MINOR,
                            AI_TOOLS_VERSION_MICRO, 0x0},
      .tool_api_version  = {AI_TOOLS_API_VERSION_MAJOR, AI_TOOLS_API_VERSION_MINOR,
                            AI_TOOLS_API_VERSION_MICRO, 0x0},

      .api_version            = ai_platform_api_get_version(),
 8025e0c:	f7de fa85 	bl	800431a <ai_platform_api_get_version>
 8025e10:	900a      	str	r0, [sp, #40]	; 0x28
      .interface_api_version  = ai_platform_interface_api_get_version(),
 8025e12:	f7de fa9c 	bl	800434e <ai_platform_interface_api_get_version>
    ai_network_report r = {
 8025e16:	f643 0334 	movw	r3, #14388	; 0x3834
      .interface_api_version  = ai_platform_interface_api_get_version(),
 8025e1a:	4602      	mov	r2, r0
      .params            = AI_STRUCT_INIT,
      .n_nodes           = 0,
      .signature         = 0x0,
    };

    if ( !ai_platform_api_get_network_report(network, &r) ) return false;
 8025e1c:	a901      	add	r1, sp, #4
 8025e1e:	4620      	mov	r0, r4
    ai_network_report r = {
 8025e20:	e9cd 230b 	strd	r2, r3, [sp, #44]	; 0x2c
    if ( !ai_platform_api_get_network_report(network, &r) ) return false;
 8025e24:	f7de fafb 	bl	800441e <ai_platform_api_get_network_report>
 8025e28:	4604      	mov	r4, r0
 8025e2a:	b140      	cbz	r0, 8025e3e <ai_har_ign_wsdm_get_info+0x7e>

    *report = r;
 8025e2c:	2274      	movs	r2, #116	; 0x74
 8025e2e:	a901      	add	r1, sp, #4
 8025e30:	4628      	mov	r0, r5
 8025e32:	f001 fb79 	bl	8027528 <memcpy>
    return true;
  }

  return false;
}
 8025e36:	4620      	mov	r0, r4
 8025e38:	b01f      	add	sp, #124	; 0x7c
 8025e3a:	bd30      	pop	{r4, r5, pc}
  return false;
 8025e3c:	4604      	mov	r4, r0
}
 8025e3e:	4620      	mov	r0, r4
 8025e40:	b01f      	add	sp, #124	; 0x7c
 8025e42:	bd30      	pop	{r4, r5, pc}
  return false;
 8025e44:	462c      	mov	r4, r5
}
 8025e46:	4620      	mov	r0, r4
 8025e48:	b01f      	add	sp, #124	; 0x7c
 8025e4a:	bd30      	pop	{r4, r5, pc}
 8025e4c:	08042c9c 	.word	0x08042c9c
 8025e50:	08044514 	.word	0x08044514
 8025e54:	08044538 	.word	0x08044538
 8025e58:	08044554 	.word	0x08044554
 8025e5c:	08041bfc 	.word	0x08041bfc

08025e60 <ai_har_ign_wsdm_get_error>:

AI_API_ENTRY
ai_error ai_har_ign_wsdm_get_error(ai_handle network)
{
  return ai_platform_network_get_error(network);
 8025e60:	f7de bab1 	b.w	80043c6 <ai_platform_network_get_error>

08025e64 <ai_har_ign_wsdm_create>:
}

AI_API_ENTRY
ai_error ai_har_ign_wsdm_create(
  ai_handle* network, const ai_buffer* network_config)
{
 8025e64:	b510      	push	{r4, lr}
  return ai_platform_network_create(
 8025e66:	2303      	movs	r3, #3
{
 8025e68:	b082      	sub	sp, #8
  return ai_platform_network_create(
 8025e6a:	2400      	movs	r4, #0
 8025e6c:	e9cd 3400 	strd	r3, r4, [sp]
 8025e70:	4a02      	ldr	r2, [pc, #8]	; (8025e7c <ai_har_ign_wsdm_create+0x18>)
 8025e72:	2301      	movs	r3, #1
 8025e74:	f7de fb92 	bl	800459c <ai_platform_network_create>
    network, network_config, 
    &AI_NET_OBJ_INSTANCE,
    AI_TOOLS_API_VERSION_MAJOR, AI_TOOLS_API_VERSION_MINOR, AI_TOOLS_API_VERSION_MICRO);
}
 8025e78:	b002      	add	sp, #8
 8025e7a:	bd10      	pop	{r4, pc}
 8025e7c:	20001a20 	.word	0x20001a20

08025e80 <ai_har_ign_wsdm_destroy>:

AI_API_ENTRY
ai_handle ai_har_ign_wsdm_destroy(ai_handle network)
{
  return ai_platform_network_destroy(network);
 8025e80:	f7de bbd1 	b.w	8004626 <ai_platform_network_destroy>

08025e84 <ai_har_ign_wsdm_init>:
}

AI_API_ENTRY
ai_bool ai_har_ign_wsdm_init(
  ai_handle network, const ai_network_params* params)
{
 8025e84:	b570      	push	{r4, r5, r6, lr}
 8025e86:	460c      	mov	r4, r1
  ai_network* net_ctx = ai_platform_network_init(network, params);
 8025e88:	f7de fbf0 	bl	800466c <ai_platform_network_init>
  if ( !net_ctx ) return false;
 8025e8c:	2800      	cmp	r0, #0
 8025e8e:	d053      	beq.n	8025f38 <ai_har_ign_wsdm_init+0xb4>
    dense_2_bias_array.format |= AI_FMT_FLAG_CONST;
 8025e90:	4b2a      	ldr	r3, [pc, #168]	; (8025f3c <ai_har_ign_wsdm_init+0xb8>)
 8025e92:	6922      	ldr	r2, [r4, #16]
  ai_ptr activations = AI_PTR(AI_PTR_ALIGN(activation_buffer->data, 4));
 8025e94:	6aa1      	ldr	r1, [r4, #40]	; 0x28
    dense_2_bias_array.format |= AI_FMT_FLAG_CONST;
 8025e96:	6d9c      	ldr	r4, [r3, #88]	; 0x58
    dense_2_weights_array.format |= AI_FMT_FLAG_CONST;
 8025e98:	6e9d      	ldr	r5, [r3, #104]	; 0x68
    dense_2_bias_array.format |= AI_FMT_FLAG_CONST;
 8025e9a:	f044 4480 	orr.w	r4, r4, #1073741824	; 0x40000000
    dense_2_bias_array.data = AI_PTR(weights + 5488);
 8025e9e:	f502 50ab 	add.w	r0, r2, #5472	; 0x1560
    dense_2_bias_array.format |= AI_FMT_FLAG_CONST;
 8025ea2:	659c      	str	r4, [r3, #88]	; 0x58
    dense_1_weights_array.format |= AI_FMT_FLAG_CONST;
 8025ea4:	f8d3 4088 	ldr.w	r4, [r3, #136]	; 0x88
    dense_2_bias_array.data = AI_PTR(weights + 5488);
 8025ea8:	3010      	adds	r0, #16
    dense_2_bias_array.data_start = AI_PTR(weights + 5488);
 8025eaa:	e9c3 0018 	strd	r0, r0, [r3, #96]	; 0x60
    dense_2_weights_array.format |= AI_FMT_FLAG_CONST;
 8025eae:	f045 4580 	orr.w	r5, r5, #1073741824	; 0x40000000
    dense_2_weights_array.data = AI_PTR(weights + 5296);
 8025eb2:	f502 50a5 	add.w	r0, r2, #5280	; 0x14a0
    dense_1_weights_array.format |= AI_FMT_FLAG_CONST;
 8025eb6:	f044 4480 	orr.w	r4, r4, #1073741824	; 0x40000000
    dense_2_weights_array.format |= AI_FMT_FLAG_CONST;
 8025eba:	669d      	str	r5, [r3, #104]	; 0x68
    dense_2_weights_array.data = AI_PTR(weights + 5296);
 8025ebc:	3010      	adds	r0, #16
    dense_1_bias_array.format |= AI_FMT_FLAG_CONST;
 8025ebe:	6f9d      	ldr	r5, [r3, #120]	; 0x78
    dense_1_weights_array.format |= AI_FMT_FLAG_CONST;
 8025ec0:	f8c3 4088 	str.w	r4, [r3, #136]	; 0x88
    dense_1_weights_array.data = AI_PTR(weights + 2656);
 8025ec4:	f502 6426 	add.w	r4, r2, #2656	; 0xa60
    dense_2_weights_array.data_start = AI_PTR(weights + 5296);
 8025ec8:	e9c3 001c 	strd	r0, r0, [r3, #112]	; 0x70
    dense_1_weights_array.data = AI_PTR(weights + 2656);
 8025ecc:	f8c3 4090 	str.w	r4, [r3, #144]	; 0x90
    conv2d_1_weights_array.format |= AI_FMT_FLAG_CONST;
 8025ed0:	f8d3 00a8 	ldr.w	r0, [r3, #168]	; 0xa8
    conv2d_1_bias_array.format |= AI_FMT_FLAG_CONST;
 8025ed4:	f8d3 4098 	ldr.w	r4, [r3, #152]	; 0x98
    dense_1_bias_array.format |= AI_FMT_FLAG_CONST;
 8025ed8:	f045 4580 	orr.w	r5, r5, #1073741824	; 0x40000000
  ai_ptr activations = AI_PTR(AI_PTR_ALIGN(activation_buffer->data, 4));
 8025edc:	3103      	adds	r1, #3
 8025ede:	f021 0103 	bic.w	r1, r1, #3
    conv2d_1_weights_array.data_start = AI_PTR(weights + 0);
 8025ee2:	e9c3 222c 	strd	r2, r2, [r3, #176]	; 0xb0
    dense_1_bias_array.format |= AI_FMT_FLAG_CONST;
 8025ee6:	679d      	str	r5, [r3, #120]	; 0x78
    dense_1_weights_array.data_start = AI_PTR(weights + 1632);
 8025ee8:	f502 66cc 	add.w	r6, r2, #1632	; 0x660
    conv2d_1_bias_array.data = AI_PTR(weights + 1536);
 8025eec:	f502 65c0 	add.w	r5, r2, #1536	; 0x600
    conv2d_1_bias_array.format |= AI_FMT_FLAG_CONST;
 8025ef0:	f044 4480 	orr.w	r4, r4, #1073741824	; 0x40000000
    conv2d_1_weights_array.format |= AI_FMT_FLAG_CONST;
 8025ef4:	f040 4080 	orr.w	r0, r0, #1073741824	; 0x40000000
    dense_1_bias_array.data = AI_PTR(weights + 5248);
 8025ef8:	f502 52a4 	add.w	r2, r2, #5248	; 0x1480
    dense_1_bias_array.data_start = AI_PTR(weights + 5248);
 8025efc:	e9c3 2220 	strd	r2, r2, [r3, #128]	; 0x80
    conv2d_1_bias_array.format |= AI_FMT_FLAG_CONST;
 8025f00:	f8c3 4098 	str.w	r4, [r3, #152]	; 0x98
    conv2d_1_weights_array.format |= AI_FMT_FLAG_CONST;
 8025f04:	f8c3 00a8 	str.w	r0, [r3, #168]	; 0xa8
    input_0_output_array.data = AI_PTR(NULL);
 8025f08:	2400      	movs	r4, #0
    conv2d_1_output_array.data = AI_PTR(activations + 864);
 8025f0a:	f501 7058 	add.w	r0, r1, #864	; 0x360
    dense_2_output_array.data = AI_PTR(activations + 48);
 8025f0e:	f101 0230 	add.w	r2, r1, #48	; 0x30
    conv2d_1_output_array.data_start = AI_PTR(activations + 864);
 8025f12:	e9c3 0038 	strd	r0, r0, [r3, #224]	; 0xe0
    conv2d_1_bias_array.data_start = AI_PTR(weights + 1536);
 8025f16:	e9c3 5528 	strd	r5, r5, [r3, #160]	; 0xa0
    conv2d_1_scratch0_array.data_start = AI_PTR(activations + 0);
 8025f1a:	e9c3 1130 	strd	r1, r1, [r3, #192]	; 0xc0
    input_0_output_array.data_start = AI_PTR(NULL);
 8025f1e:	e9c3 4434 	strd	r4, r4, [r3, #208]	; 0xd0
    dense_1_weights_array.data_start = AI_PTR(weights + 1632);
 8025f22:	f8c3 6094 	str.w	r6, [r3, #148]	; 0x94
    dense_1_output_array.data = AI_PTR(activations + 0);
 8025f26:	f8c3 10f0 	str.w	r1, [r3, #240]	; 0xf0
    dense_2_output_array.data_start = AI_PTR(activations + 48);
 8025f2a:	e9c3 2240 	strd	r2, r2, [r3, #256]	; 0x100
    dense_2_nl_output_array.data_start = AI_PTR(NULL);
 8025f2e:	e9c3 4444 	strd	r4, r4, [r3, #272]	; 0x110

  ai_bool ok = true;
  ok &= har_ign_wsdm_configure_weights(net_ctx, &params->params);
  ok &= har_ign_wsdm_configure_activations(net_ctx, &params->activations);

  return ok;
 8025f32:	2001      	movs	r0, #1
    dense_1_output_array.data_start = AI_PTR(activations + 0);
 8025f34:	f8c3 10f4 	str.w	r1, [r3, #244]	; 0xf4
}
 8025f38:	bd70      	pop	{r4, r5, r6, pc}
 8025f3a:	bf00      	nop
 8025f3c:	20001a20 	.word	0x20001a20

08025f40 <ai_har_ign_wsdm_run>:

AI_API_ENTRY
ai_i32 ai_har_ign_wsdm_run(
  ai_handle network, const ai_buffer* input, ai_buffer* output)
{
  return ai_platform_network_process(network, input, output);
 8025f40:	f7de bbf0 	b.w	8004724 <ai_platform_network_process>

08025f44 <ai_har_ign_wsdm_forward>:
}

AI_API_ENTRY
ai_i32 ai_har_ign_wsdm_forward(ai_handle network, const ai_buffer* input)
{
  return ai_platform_network_process(network, input, NULL);
 8025f44:	2200      	movs	r2, #0
 8025f46:	f7de bbed 	b.w	8004724 <ai_platform_network_process>
 8025f4a:	bf00      	nop

08025f4c <ai_har_ign_wsdm_data_weights_get>:
    0x7d, 0xbf, 0x07, 0x68, 0x64, 0xbf, 0xda, 0x82, 0xb2,
    0xbf, 0xc5, 0x02, 0x0b, 0x3f, 0x94, 0x02, 0x26, 0x3f
  };

  return AI_HANDLE_PTR(s_har_ign_wsdm_weights);
}
 8025f4c:	4800      	ldr	r0, [pc, #0]	; (8025f50 <ai_har_ign_wsdm_data_weights_get+0x4>)
 8025f4e:	4770      	bx	lr
 8025f50:	080401c8 	.word	0x080401c8

08025f54 <arm_rfft_fast_init_f32>:
 8025f54:	084b      	lsrs	r3, r1, #1
 8025f56:	2b80      	cmp	r3, #128	; 0x80
 8025f58:	b410      	push	{r4}
 8025f5a:	8201      	strh	r1, [r0, #16]
 8025f5c:	8003      	strh	r3, [r0, #0]
 8025f5e:	d046      	beq.n	8025fee <arm_rfft_fast_init_f32+0x9a>
 8025f60:	d916      	bls.n	8025f90 <arm_rfft_fast_init_f32+0x3c>
 8025f62:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 8025f66:	d03c      	beq.n	8025fe2 <arm_rfft_fast_init_f32+0x8e>
 8025f68:	d928      	bls.n	8025fbc <arm_rfft_fast_init_f32+0x68>
 8025f6a:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 8025f6e:	d01f      	beq.n	8025fb0 <arm_rfft_fast_init_f32+0x5c>
 8025f70:	f5b3 6f00 	cmp.w	r3, #2048	; 0x800
 8025f74:	d112      	bne.n	8025f9c <arm_rfft_fast_init_f32+0x48>
 8025f76:	4920      	ldr	r1, [pc, #128]	; (8025ff8 <arm_rfft_fast_init_f32+0xa4>)
 8025f78:	4a20      	ldr	r2, [pc, #128]	; (8025ffc <arm_rfft_fast_init_f32+0xa8>)
 8025f7a:	4b21      	ldr	r3, [pc, #132]	; (8026000 <arm_rfft_fast_init_f32+0xac>)
 8025f7c:	f44f 646e 	mov.w	r4, #3808	; 0xee0
 8025f80:	8184      	strh	r4, [r0, #12]
 8025f82:	6081      	str	r1, [r0, #8]
 8025f84:	6042      	str	r2, [r0, #4]
 8025f86:	6143      	str	r3, [r0, #20]
 8025f88:	f85d 4b04 	ldr.w	r4, [sp], #4
 8025f8c:	2000      	movs	r0, #0
 8025f8e:	4770      	bx	lr
 8025f90:	2b20      	cmp	r3, #32
 8025f92:	d01c      	beq.n	8025fce <arm_rfft_fast_init_f32+0x7a>
 8025f94:	2b40      	cmp	r3, #64	; 0x40
 8025f96:	d006      	beq.n	8025fa6 <arm_rfft_fast_init_f32+0x52>
 8025f98:	2b10      	cmp	r3, #16
 8025f9a:	d01d      	beq.n	8025fd8 <arm_rfft_fast_init_f32+0x84>
 8025f9c:	f04f 30ff 	mov.w	r0, #4294967295
 8025fa0:	f85d 4b04 	ldr.w	r4, [sp], #4
 8025fa4:	4770      	bx	lr
 8025fa6:	2438      	movs	r4, #56	; 0x38
 8025fa8:	4916      	ldr	r1, [pc, #88]	; (8026004 <arm_rfft_fast_init_f32+0xb0>)
 8025faa:	4a17      	ldr	r2, [pc, #92]	; (8026008 <arm_rfft_fast_init_f32+0xb4>)
 8025fac:	4b17      	ldr	r3, [pc, #92]	; (802600c <arm_rfft_fast_init_f32+0xb8>)
 8025fae:	e7e7      	b.n	8025f80 <arm_rfft_fast_init_f32+0x2c>
 8025fb0:	f44f 64e1 	mov.w	r4, #1800	; 0x708
 8025fb4:	4916      	ldr	r1, [pc, #88]	; (8026010 <arm_rfft_fast_init_f32+0xbc>)
 8025fb6:	4a17      	ldr	r2, [pc, #92]	; (8026014 <arm_rfft_fast_init_f32+0xc0>)
 8025fb8:	4b17      	ldr	r3, [pc, #92]	; (8026018 <arm_rfft_fast_init_f32+0xc4>)
 8025fba:	e7e1      	b.n	8025f80 <arm_rfft_fast_init_f32+0x2c>
 8025fbc:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 8025fc0:	d1ec      	bne.n	8025f9c <arm_rfft_fast_init_f32+0x48>
 8025fc2:	f44f 74dc 	mov.w	r4, #440	; 0x1b8
 8025fc6:	4915      	ldr	r1, [pc, #84]	; (802601c <arm_rfft_fast_init_f32+0xc8>)
 8025fc8:	4a15      	ldr	r2, [pc, #84]	; (8026020 <arm_rfft_fast_init_f32+0xcc>)
 8025fca:	4b16      	ldr	r3, [pc, #88]	; (8026024 <arm_rfft_fast_init_f32+0xd0>)
 8025fcc:	e7d8      	b.n	8025f80 <arm_rfft_fast_init_f32+0x2c>
 8025fce:	2430      	movs	r4, #48	; 0x30
 8025fd0:	4915      	ldr	r1, [pc, #84]	; (8026028 <arm_rfft_fast_init_f32+0xd4>)
 8025fd2:	4a16      	ldr	r2, [pc, #88]	; (802602c <arm_rfft_fast_init_f32+0xd8>)
 8025fd4:	4b16      	ldr	r3, [pc, #88]	; (8026030 <arm_rfft_fast_init_f32+0xdc>)
 8025fd6:	e7d3      	b.n	8025f80 <arm_rfft_fast_init_f32+0x2c>
 8025fd8:	2414      	movs	r4, #20
 8025fda:	4916      	ldr	r1, [pc, #88]	; (8026034 <arm_rfft_fast_init_f32+0xe0>)
 8025fdc:	4a16      	ldr	r2, [pc, #88]	; (8026038 <arm_rfft_fast_init_f32+0xe4>)
 8025fde:	4b17      	ldr	r3, [pc, #92]	; (802603c <arm_rfft_fast_init_f32+0xe8>)
 8025fe0:	e7ce      	b.n	8025f80 <arm_rfft_fast_init_f32+0x2c>
 8025fe2:	f44f 74e0 	mov.w	r4, #448	; 0x1c0
 8025fe6:	4916      	ldr	r1, [pc, #88]	; (8026040 <arm_rfft_fast_init_f32+0xec>)
 8025fe8:	4a16      	ldr	r2, [pc, #88]	; (8026044 <arm_rfft_fast_init_f32+0xf0>)
 8025fea:	4b17      	ldr	r3, [pc, #92]	; (8026048 <arm_rfft_fast_init_f32+0xf4>)
 8025fec:	e7c8      	b.n	8025f80 <arm_rfft_fast_init_f32+0x2c>
 8025fee:	24d0      	movs	r4, #208	; 0xd0
 8025ff0:	4916      	ldr	r1, [pc, #88]	; (802604c <arm_rfft_fast_init_f32+0xf8>)
 8025ff2:	4a17      	ldr	r2, [pc, #92]	; (8026050 <arm_rfft_fast_init_f32+0xfc>)
 8025ff4:	4b17      	ldr	r3, [pc, #92]	; (8026054 <arm_rfft_fast_init_f32+0x100>)
 8025ff6:	e7c3      	b.n	8025f80 <arm_rfft_fast_init_f32+0x2c>
 8025ff8:	08053374 	.word	0x08053374
 8025ffc:	0804456c 	.word	0x0804456c
 8026000:	0804a6dc 	.word	0x0804a6dc
 8026004:	0804866c 	.word	0x0804866c
 8026008:	08055134 	.word	0x08055134
 802600c:	08057624 	.word	0x08057624
 8026010:	0805105c 	.word	0x0805105c
 8026014:	0804ef5c 	.word	0x0804ef5c
 8026018:	080486dc 	.word	0x080486dc
 802601c:	080572b4 	.word	0x080572b4
 8026020:	0804e6dc 	.word	0x0804e6dc
 8026024:	08055334 	.word	0x08055334
 8026028:	08051f14 	.word	0x08051f14
 802602c:	08050f5c 	.word	0x08050f5c
 8026030:	0804856c 	.word	0x0804856c
 8026034:	08051e6c 	.word	0x08051e6c
 8026038:	0804eedc 	.word	0x0804eedc
 802603c:	08051e94 	.word	0x08051e94
 8026040:	08055b34 	.word	0x08055b34
 8026044:	08052374 	.word	0x08052374
 8026048:	08055eb4 	.word	0x08055eb4
 802604c:	08057824 	.word	0x08057824
 8026050:	08051f74 	.word	0x08051f74
 8026054:	08056eb4 	.word	0x08056eb4

08026058 <arm_rfft_fast_f32>:
 8026058:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 802605c:	8a06      	ldrh	r6, [r0, #16]
 802605e:	0876      	lsrs	r6, r6, #1
 8026060:	4607      	mov	r7, r0
 8026062:	4615      	mov	r5, r2
 8026064:	8006      	strh	r6, [r0, #0]
 8026066:	460c      	mov	r4, r1
 8026068:	2b00      	cmp	r3, #0
 802606a:	d15c      	bne.n	8026126 <arm_rfft_fast_f32+0xce>
 802606c:	461a      	mov	r2, r3
 802606e:	2301      	movs	r3, #1
 8026070:	f000 fbe4 	bl	802683c <arm_cfft_f32>
 8026074:	edd4 7a00 	vldr	s15, [r4]
 8026078:	ed94 7a01 	vldr	s14, [r4, #4]
 802607c:	883e      	ldrh	r6, [r7, #0]
 802607e:	6978      	ldr	r0, [r7, #20]
 8026080:	ee37 7a07 	vadd.f32	s14, s14, s14
 8026084:	ee77 7aa7 	vadd.f32	s15, s15, s15
 8026088:	eeb6 3a00 	vmov.f32	s6, #96	; 0x3f000000  0.5
 802608c:	ee77 6a87 	vadd.f32	s13, s15, s14
 8026090:	ee77 7ac7 	vsub.f32	s15, s15, s14
 8026094:	3e01      	subs	r6, #1
 8026096:	ee26 7a83 	vmul.f32	s14, s13, s6
 802609a:	ee67 7a83 	vmul.f32	s15, s15, s6
 802609e:	eb04 03c6 	add.w	r3, r4, r6, lsl #3
 80260a2:	ed85 7a00 	vstr	s14, [r5]
 80260a6:	edc5 7a01 	vstr	s15, [r5, #4]
 80260aa:	3010      	adds	r0, #16
 80260ac:	f105 0210 	add.w	r2, r5, #16
 80260b0:	3b08      	subs	r3, #8
 80260b2:	f104 0110 	add.w	r1, r4, #16
 80260b6:	ed93 7a02 	vldr	s14, [r3, #8]
 80260ba:	ed51 6a02 	vldr	s13, [r1, #-8]
 80260be:	ed10 6a02 	vldr	s12, [r0, #-8]
 80260c2:	edd3 3a03 	vldr	s7, [r3, #12]
 80260c6:	ed11 5a01 	vldr	s10, [r1, #-4]
 80260ca:	ed50 5a01 	vldr	s11, [r0, #-4]
 80260ce:	ee77 7a66 	vsub.f32	s15, s14, s13
 80260d2:	ee77 4a26 	vadd.f32	s9, s14, s13
 80260d6:	ee33 4a85 	vadd.f32	s8, s7, s10
 80260da:	ee66 6a27 	vmul.f32	s13, s12, s15
 80260de:	ee25 7aa7 	vmul.f32	s14, s11, s15
 80260e2:	ee35 5a63 	vsub.f32	s10, s10, s7
 80260e6:	ee76 6aa4 	vadd.f32	s13, s13, s9
 80260ea:	ee77 7a05 	vadd.f32	s15, s14, s10
 80260ee:	ee26 6a04 	vmul.f32	s12, s12, s8
 80260f2:	ee65 5a84 	vmul.f32	s11, s11, s8
 80260f6:	ee77 7ac6 	vsub.f32	s15, s15, s12
 80260fa:	ee36 7aa5 	vadd.f32	s14, s13, s11
 80260fe:	ee67 7a83 	vmul.f32	s15, s15, s6
 8026102:	ee27 7a03 	vmul.f32	s14, s14, s6
 8026106:	3e01      	subs	r6, #1
 8026108:	ed02 7a02 	vstr	s14, [r2, #-8]
 802610c:	ed42 7a01 	vstr	s15, [r2, #-4]
 8026110:	f1a3 0308 	sub.w	r3, r3, #8
 8026114:	f101 0108 	add.w	r1, r1, #8
 8026118:	f100 0008 	add.w	r0, r0, #8
 802611c:	f102 0208 	add.w	r2, r2, #8
 8026120:	d1c9      	bne.n	80260b6 <arm_rfft_fast_f32+0x5e>
 8026122:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8026126:	edd1 7a00 	vldr	s15, [r1]
 802612a:	edd1 6a01 	vldr	s13, [r1, #4]
 802612e:	6941      	ldr	r1, [r0, #20]
 8026130:	ee37 7aa6 	vadd.f32	s14, s15, s13
 8026134:	ee77 7ae6 	vsub.f32	s15, s15, s13
 8026138:	eef6 3a00 	vmov.f32	s7, #96	; 0x3f000000  0.5
 802613c:	ee27 7a23 	vmul.f32	s14, s14, s7
 8026140:	ee67 7aa3 	vmul.f32	s15, s15, s7
 8026144:	3e01      	subs	r6, #1
 8026146:	ed82 7a00 	vstr	s14, [r2]
 802614a:	edc2 7a01 	vstr	s15, [r2, #4]
 802614e:	00f0      	lsls	r0, r6, #3
 8026150:	b3ee      	cbz	r6, 80261ce <arm_rfft_fast_f32+0x176>
 8026152:	3808      	subs	r0, #8
 8026154:	f101 0e10 	add.w	lr, r1, #16
 8026158:	4420      	add	r0, r4
 802615a:	f104 0110 	add.w	r1, r4, #16
 802615e:	f102 0c10 	add.w	ip, r2, #16
 8026162:	ed90 7a02 	vldr	s14, [r0, #8]
 8026166:	ed51 6a02 	vldr	s13, [r1, #-8]
 802616a:	ed1e 6a02 	vldr	s12, [lr, #-8]
 802616e:	ed90 4a03 	vldr	s8, [r0, #12]
 8026172:	ed11 5a01 	vldr	s10, [r1, #-4]
 8026176:	ed5e 5a01 	vldr	s11, [lr, #-4]
 802617a:	ee76 7ac7 	vsub.f32	s15, s13, s14
 802617e:	ee74 4a05 	vadd.f32	s9, s8, s10
 8026182:	ee26 3a27 	vmul.f32	s6, s12, s15
 8026186:	ee77 6a26 	vadd.f32	s13, s14, s13
 802618a:	ee35 5a44 	vsub.f32	s10, s10, s8
 802618e:	ee25 7aa7 	vmul.f32	s14, s11, s15
 8026192:	ee76 6ac3 	vsub.f32	s13, s13, s6
 8026196:	ee77 7a05 	vadd.f32	s15, s14, s10
 802619a:	ee26 6a24 	vmul.f32	s12, s12, s9
 802619e:	ee65 5aa4 	vmul.f32	s11, s11, s9
 80261a2:	ee77 7ac6 	vsub.f32	s15, s15, s12
 80261a6:	ee36 7ae5 	vsub.f32	s14, s13, s11
 80261aa:	ee67 7aa3 	vmul.f32	s15, s15, s7
 80261ae:	ee27 7a23 	vmul.f32	s14, s14, s7
 80261b2:	3e01      	subs	r6, #1
 80261b4:	ed0c 7a02 	vstr	s14, [ip, #-8]
 80261b8:	ed4c 7a01 	vstr	s15, [ip, #-4]
 80261bc:	f1a0 0008 	sub.w	r0, r0, #8
 80261c0:	f101 0108 	add.w	r1, r1, #8
 80261c4:	f10e 0e08 	add.w	lr, lr, #8
 80261c8:	f10c 0c08 	add.w	ip, ip, #8
 80261cc:	d1c9      	bne.n	8026162 <arm_rfft_fast_f32+0x10a>
 80261ce:	461a      	mov	r2, r3
 80261d0:	4629      	mov	r1, r5
 80261d2:	4638      	mov	r0, r7
 80261d4:	2301      	movs	r3, #1
 80261d6:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
 80261da:	f000 bb2f 	b.w	802683c <arm_cfft_f32>
 80261de:	bf00      	nop

080261e0 <arm_cfft_radix8by2_f32>:
 80261e0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80261e4:	ed2d 8b08 	vpush	{d8-d11}
 80261e8:	4607      	mov	r7, r0
 80261ea:	4608      	mov	r0, r1
 80261ec:	f8b7 e000 	ldrh.w	lr, [r7]
 80261f0:	687a      	ldr	r2, [r7, #4]
 80261f2:	ea4f 015e 	mov.w	r1, lr, lsr #1
 80261f6:	eb00 088e 	add.w	r8, r0, lr, lsl #2
 80261fa:	ea5f 0ede 	movs.w	lr, lr, lsr #3
 80261fe:	f000 80b0 	beq.w	8026362 <arm_cfft_radix8by2_f32+0x182>
 8026202:	008b      	lsls	r3, r1, #2
 8026204:	3310      	adds	r3, #16
 8026206:	18c6      	adds	r6, r0, r3
 8026208:	3210      	adds	r2, #16
 802620a:	4443      	add	r3, r8
 802620c:	f100 0510 	add.w	r5, r0, #16
 8026210:	f108 0410 	add.w	r4, r8, #16
 8026214:	ed54 1a04 	vldr	s3, [r4, #-16]
 8026218:	ed54 6a03 	vldr	s13, [r4, #-12]
 802621c:	ed13 4a04 	vldr	s8, [r3, #-16]
 8026220:	ed53 3a03 	vldr	s7, [r3, #-12]
 8026224:	ed53 5a02 	vldr	s11, [r3, #-8]
 8026228:	ed13 5a01 	vldr	s10, [r3, #-4]
 802622c:	ed14 0a02 	vldr	s0, [r4, #-8]
 8026230:	ed54 7a01 	vldr	s15, [r4, #-4]
 8026234:	ed16 2a04 	vldr	s4, [r6, #-16]
 8026238:	ed56 2a03 	vldr	s5, [r6, #-12]
 802623c:	ed15 6a03 	vldr	s12, [r5, #-12]
 8026240:	ed15 7a01 	vldr	s14, [r5, #-4]
 8026244:	ed15 3a04 	vldr	s6, [r5, #-16]
 8026248:	ed56 0a02 	vldr	s1, [r6, #-8]
 802624c:	ed16 1a01 	vldr	s2, [r6, #-4]
 8026250:	ed55 4a02 	vldr	s9, [r5, #-8]
 8026254:	ee73 ba21 	vadd.f32	s23, s6, s3
 8026258:	ee36 ba26 	vadd.f32	s22, s12, s13
 802625c:	ee37 aa27 	vadd.f32	s20, s14, s15
 8026260:	ee72 9a04 	vadd.f32	s19, s4, s8
 8026264:	ee32 9aa3 	vadd.f32	s18, s5, s7
 8026268:	ee31 8a05 	vadd.f32	s16, s2, s10
 802626c:	ee74 aa80 	vadd.f32	s21, s9, s0
 8026270:	ee70 8aa5 	vadd.f32	s17, s1, s11
 8026274:	ed45 ba04 	vstr	s23, [r5, #-16]
 8026278:	ed05 ba03 	vstr	s22, [r5, #-12]
 802627c:	ed45 aa02 	vstr	s21, [r5, #-8]
 8026280:	ed05 aa01 	vstr	s20, [r5, #-4]
 8026284:	ed06 8a01 	vstr	s16, [r6, #-4]
 8026288:	ed46 9a04 	vstr	s19, [r6, #-16]
 802628c:	ed06 9a03 	vstr	s18, [r6, #-12]
 8026290:	ed46 8a02 	vstr	s17, [r6, #-8]
 8026294:	ee76 6a66 	vsub.f32	s13, s12, s13
 8026298:	ee73 3ae2 	vsub.f32	s7, s7, s5
 802629c:	ed12 6a03 	vldr	s12, [r2, #-12]
 80262a0:	ed52 2a04 	vldr	s5, [r2, #-16]
 80262a4:	ee33 3a61 	vsub.f32	s6, s6, s3
 80262a8:	ee34 4a42 	vsub.f32	s8, s8, s4
 80262ac:	ee26 8a86 	vmul.f32	s16, s13, s12
 80262b0:	ee24 2a06 	vmul.f32	s4, s8, s12
 80262b4:	ee63 1a22 	vmul.f32	s3, s6, s5
 80262b8:	ee24 4a22 	vmul.f32	s8, s8, s5
 80262bc:	ee23 3a06 	vmul.f32	s6, s6, s12
 80262c0:	ee66 6aa2 	vmul.f32	s13, s13, s5
 80262c4:	ee23 6a86 	vmul.f32	s12, s7, s12
 80262c8:	ee63 3aa2 	vmul.f32	s7, s7, s5
 80262cc:	ee36 6a04 	vadd.f32	s12, s12, s8
 80262d0:	ee76 6ac3 	vsub.f32	s13, s13, s6
 80262d4:	ee72 3a63 	vsub.f32	s7, s4, s7
 80262d8:	ee71 2a88 	vadd.f32	s5, s3, s16
 80262dc:	ed44 6a03 	vstr	s13, [r4, #-12]
 80262e0:	ed44 2a04 	vstr	s5, [r4, #-16]
 80262e4:	ed43 3a04 	vstr	s7, [r3, #-16]
 80262e8:	ed03 6a03 	vstr	s12, [r3, #-12]
 80262ec:	ee77 7a67 	vsub.f32	s15, s14, s15
 80262f0:	ee75 6ae0 	vsub.f32	s13, s11, s1
 80262f4:	ed12 7a01 	vldr	s14, [r2, #-4]
 80262f8:	ed52 5a02 	vldr	s11, [r2, #-8]
 80262fc:	ee35 6a41 	vsub.f32	s12, s10, s2
 8026300:	ee74 4ac0 	vsub.f32	s9, s9, s0
 8026304:	ee67 3a87 	vmul.f32	s7, s15, s14
 8026308:	ee26 5a87 	vmul.f32	s10, s13, s14
 802630c:	ee24 4aa5 	vmul.f32	s8, s9, s11
 8026310:	ee67 7aa5 	vmul.f32	s15, s15, s11
 8026314:	ee64 4a87 	vmul.f32	s9, s9, s14
 8026318:	ee66 6aa5 	vmul.f32	s13, s13, s11
 802631c:	ee26 7a07 	vmul.f32	s14, s12, s14
 8026320:	ee26 6a25 	vmul.f32	s12, s12, s11
 8026324:	ee77 7ae4 	vsub.f32	s15, s15, s9
 8026328:	ee74 5a23 	vadd.f32	s11, s8, s7
 802632c:	ee35 6a46 	vsub.f32	s12, s10, s12
 8026330:	ee37 7a26 	vadd.f32	s14, s14, s13
 8026334:	f1be 0e01 	subs.w	lr, lr, #1
 8026338:	ed44 5a02 	vstr	s11, [r4, #-8]
 802633c:	f105 0510 	add.w	r5, r5, #16
 8026340:	ed44 7a01 	vstr	s15, [r4, #-4]
 8026344:	f106 0610 	add.w	r6, r6, #16
 8026348:	ed03 6a02 	vstr	s12, [r3, #-8]
 802634c:	ed03 7a01 	vstr	s14, [r3, #-4]
 8026350:	f102 0210 	add.w	r2, r2, #16
 8026354:	f104 0410 	add.w	r4, r4, #16
 8026358:	f103 0310 	add.w	r3, r3, #16
 802635c:	f47f af5a 	bne.w	8026214 <arm_cfft_radix8by2_f32+0x34>
 8026360:	687a      	ldr	r2, [r7, #4]
 8026362:	b28c      	uxth	r4, r1
 8026364:	4621      	mov	r1, r4
 8026366:	2302      	movs	r3, #2
 8026368:	f000 fbca 	bl	8026b00 <arm_radix8_butterfly_f32>
 802636c:	ecbd 8b08 	vpop	{d8-d11}
 8026370:	4621      	mov	r1, r4
 8026372:	687a      	ldr	r2, [r7, #4]
 8026374:	4640      	mov	r0, r8
 8026376:	2302      	movs	r3, #2
 8026378:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
 802637c:	f000 bbc0 	b.w	8026b00 <arm_radix8_butterfly_f32>

08026380 <arm_cfft_radix8by4_f32>:
 8026380:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8026384:	ed2d 8b0a 	vpush	{d8-d12}
 8026388:	8802      	ldrh	r2, [r0, #0]
 802638a:	ed91 6a00 	vldr	s12, [r1]
 802638e:	b08f      	sub	sp, #60	; 0x3c
 8026390:	460f      	mov	r7, r1
 8026392:	0852      	lsrs	r2, r2, #1
 8026394:	6841      	ldr	r1, [r0, #4]
 8026396:	900c      	str	r0, [sp, #48]	; 0x30
 8026398:	0093      	lsls	r3, r2, #2
 802639a:	4638      	mov	r0, r7
 802639c:	4418      	add	r0, r3
 802639e:	4606      	mov	r6, r0
 80263a0:	9009      	str	r0, [sp, #36]	; 0x24
 80263a2:	4418      	add	r0, r3
 80263a4:	edd0 6a00 	vldr	s13, [r0]
 80263a8:	ed96 4a00 	vldr	s8, [r6]
 80263ac:	edd6 2a01 	vldr	s5, [r6, #4]
 80263b0:	edd0 7a01 	vldr	s15, [r0, #4]
 80263b4:	900a      	str	r0, [sp, #40]	; 0x28
 80263b6:	ee76 5a26 	vadd.f32	s11, s12, s13
 80263ba:	4604      	mov	r4, r0
 80263bc:	4625      	mov	r5, r4
 80263be:	441c      	add	r4, r3
 80263c0:	edd4 4a00 	vldr	s9, [r4]
 80263c4:	ed97 7a01 	vldr	s14, [r7, #4]
 80263c8:	ed94 3a01 	vldr	s6, [r4, #4]
 80263cc:	9401      	str	r4, [sp, #4]
 80263ce:	ee35 5a84 	vadd.f32	s10, s11, s8
 80263d2:	4630      	mov	r0, r6
 80263d4:	ee35 5a24 	vadd.f32	s10, s10, s9
 80263d8:	463e      	mov	r6, r7
 80263da:	ee15 ea10 	vmov	lr, s10
 80263de:	ee76 6a66 	vsub.f32	s13, s12, s13
 80263e2:	f846 eb08 	str.w	lr, [r6], #8
 80263e6:	ee37 6a27 	vadd.f32	s12, s14, s15
 80263ea:	ed90 5a01 	vldr	s10, [r0, #4]
 80263ee:	9605      	str	r6, [sp, #20]
 80263f0:	ee77 7a67 	vsub.f32	s15, s14, s15
 80263f4:	9e01      	ldr	r6, [sp, #4]
 80263f6:	9707      	str	r7, [sp, #28]
 80263f8:	ee76 3aa2 	vadd.f32	s7, s13, s5
 80263fc:	ed96 2a01 	vldr	s4, [r6, #4]
 8026400:	ee36 7a05 	vadd.f32	s14, s12, s10
 8026404:	ee75 5ac4 	vsub.f32	s11, s11, s8
 8026408:	ee37 5ac4 	vsub.f32	s10, s15, s8
 802640c:	ee77 7a84 	vadd.f32	s15, s15, s8
 8026410:	ee33 4ac3 	vsub.f32	s8, s7, s6
 8026414:	4604      	mov	r4, r0
 8026416:	46a3      	mov	fp, r4
 8026418:	ee37 7a02 	vadd.f32	s14, s14, s4
 802641c:	ee35 5a24 	vadd.f32	s10, s10, s9
 8026420:	ee14 8a10 	vmov	r8, s8
 8026424:	46a4      	mov	ip, r4
 8026426:	ee75 5ae4 	vsub.f32	s11, s11, s9
 802642a:	ed87 7a01 	vstr	s14, [r7, #4]
 802642e:	f84b 8b08 	str.w	r8, [fp], #8
 8026432:	f1ac 0704 	sub.w	r7, ip, #4
 8026436:	ed8c 5a01 	vstr	s10, [ip, #4]
 802643a:	f101 0c08 	add.w	ip, r1, #8
 802643e:	462c      	mov	r4, r5
 8026440:	f8cd c010 	str.w	ip, [sp, #16]
 8026444:	ee15 ca90 	vmov	ip, s11
 8026448:	ee36 6a62 	vsub.f32	s12, s12, s5
 802644c:	f844 cb08 	str.w	ip, [r4], #8
 8026450:	ee76 6ae2 	vsub.f32	s13, s13, s5
 8026454:	ee36 6a43 	vsub.f32	s12, s12, s6
 8026458:	9406      	str	r4, [sp, #24]
 802645a:	ee76 6a83 	vadd.f32	s13, s13, s6
 802645e:	f101 0410 	add.w	r4, r1, #16
 8026462:	0852      	lsrs	r2, r2, #1
 8026464:	9402      	str	r4, [sp, #8]
 8026466:	ed85 6a01 	vstr	s12, [r5, #4]
 802646a:	462c      	mov	r4, r5
 802646c:	f101 0518 	add.w	r5, r1, #24
 8026470:	920b      	str	r2, [sp, #44]	; 0x2c
 8026472:	46b2      	mov	sl, r6
 8026474:	9503      	str	r5, [sp, #12]
 8026476:	ee77 7ae4 	vsub.f32	s15, s15, s9
 802647a:	3a02      	subs	r2, #2
 802647c:	ee16 5a90 	vmov	r5, s13
 8026480:	46b6      	mov	lr, r6
 8026482:	4630      	mov	r0, r6
 8026484:	0852      	lsrs	r2, r2, #1
 8026486:	f84a 5b08 	str.w	r5, [sl], #8
 802648a:	f1a0 0604 	sub.w	r6, r0, #4
 802648e:	edce 7a01 	vstr	s15, [lr, #4]
 8026492:	9208      	str	r2, [sp, #32]
 8026494:	f000 8130 	beq.w	80266f8 <arm_cfft_radix8by4_f32+0x378>
 8026498:	4691      	mov	r9, r2
 802649a:	9a07      	ldr	r2, [sp, #28]
 802649c:	f8dd 8008 	ldr.w	r8, [sp, #8]
 80264a0:	f8cd a034 	str.w	sl, [sp, #52]	; 0x34
 80264a4:	3b08      	subs	r3, #8
 80264a6:	f102 0510 	add.w	r5, r2, #16
 80264aa:	f101 0c20 	add.w	ip, r1, #32
 80264ae:	f1a4 020c 	sub.w	r2, r4, #12
 80264b2:	f101 0e30 	add.w	lr, r1, #48	; 0x30
 80264b6:	4433      	add	r3, r6
 80264b8:	3410      	adds	r4, #16
 80264ba:	4650      	mov	r0, sl
 80264bc:	4659      	mov	r1, fp
 80264be:	ed55 3a02 	vldr	s7, [r5, #-8]
 80264c2:	ed14 5a02 	vldr	s10, [r4, #-8]
 80264c6:	ed91 7a00 	vldr	s14, [r1]
 80264ca:	edd0 7a00 	vldr	s15, [r0]
 80264ce:	ed54 5a01 	vldr	s11, [r4, #-4]
 80264d2:	ed15 4a01 	vldr	s8, [r5, #-4]
 80264d6:	edd0 6a01 	vldr	s13, [r0, #4]
 80264da:	ed91 6a01 	vldr	s12, [r1, #4]
 80264de:	ee33 8a85 	vadd.f32	s16, s7, s10
 80264e2:	ee34 0a25 	vadd.f32	s0, s8, s11
 80264e6:	ee78 4a07 	vadd.f32	s9, s16, s14
 80264ea:	ee74 5a65 	vsub.f32	s11, s8, s11
 80264ee:	ee74 4aa7 	vadd.f32	s9, s9, s15
 80264f2:	ee33 5ac5 	vsub.f32	s10, s7, s10
 80264f6:	ed45 4a02 	vstr	s9, [r5, #-8]
 80264fa:	edd1 4a01 	vldr	s9, [r1, #4]
 80264fe:	ed90 4a01 	vldr	s8, [r0, #4]
 8026502:	ee70 4a24 	vadd.f32	s9, s0, s9
 8026506:	ee75 aa06 	vadd.f32	s21, s10, s12
 802650a:	ee74 4a84 	vadd.f32	s9, s9, s8
 802650e:	ee35 aac7 	vsub.f32	s20, s11, s14
 8026512:	ed45 4a01 	vstr	s9, [r5, #-4]
 8026516:	edd6 1a00 	vldr	s3, [r6]
 802651a:	edd7 0a00 	vldr	s1, [r7]
 802651e:	ed92 4a02 	vldr	s8, [r2, #8]
 8026522:	edd3 3a02 	vldr	s7, [r3, #8]
 8026526:	ed93 2a01 	vldr	s4, [r3, #4]
 802652a:	ed16 1a01 	vldr	s2, [r6, #-4]
 802652e:	edd2 2a01 	vldr	s5, [r2, #4]
 8026532:	ed57 9a01 	vldr	s19, [r7, #-4]
 8026536:	ee70 4aa1 	vadd.f32	s9, s1, s3
 802653a:	ee39 3a81 	vadd.f32	s6, s19, s2
 802653e:	ee74 8a84 	vadd.f32	s17, s9, s8
 8026542:	ee70 1ae1 	vsub.f32	s3, s1, s3
 8026546:	ee78 8aa3 	vadd.f32	s17, s17, s7
 802654a:	ee7a aae6 	vsub.f32	s21, s21, s13
 802654e:	ee18 aa90 	vmov	sl, s17
 8026552:	f847 a908 	str.w	sl, [r7], #-8
 8026556:	edd2 8a01 	vldr	s17, [r2, #4]
 802655a:	ed93 9a01 	vldr	s18, [r3, #4]
 802655e:	ee73 8a28 	vadd.f32	s17, s6, s17
 8026562:	ee3a aa27 	vadd.f32	s20, s20, s15
 8026566:	ee78 8a89 	vadd.f32	s17, s17, s18
 802656a:	ee74 0a63 	vsub.f32	s1, s8, s7
 802656e:	edc7 8a01 	vstr	s17, [r7, #4]
 8026572:	ed18 ba02 	vldr	s22, [r8, #-8]
 8026576:	ed58 8a01 	vldr	s17, [r8, #-4]
 802657a:	ee39 1ac1 	vsub.f32	s2, s19, s2
 802657e:	ee6a ba28 	vmul.f32	s23, s20, s17
 8026582:	ee2a ca8b 	vmul.f32	s24, s21, s22
 8026586:	ee71 9ae2 	vsub.f32	s19, s3, s5
 802658a:	ee31 9a20 	vadd.f32	s18, s2, s1
 802658e:	ee79 9a82 	vadd.f32	s19, s19, s4
 8026592:	ee3c ca2b 	vadd.f32	s24, s24, s23
 8026596:	ee6a aaa8 	vmul.f32	s21, s21, s17
 802659a:	ee69 baa8 	vmul.f32	s23, s19, s17
 802659e:	ee2a aa0b 	vmul.f32	s20, s20, s22
 80265a2:	ee69 9a8b 	vmul.f32	s19, s19, s22
 80265a6:	ee69 8a28 	vmul.f32	s17, s18, s17
 80265aa:	ee29 ba0b 	vmul.f32	s22, s18, s22
 80265ae:	ee1c aa10 	vmov	sl, s24
 80265b2:	ee78 8aa9 	vadd.f32	s17, s17, s19
 80265b6:	f841 ab08 	str.w	sl, [r1], #8
 80265ba:	ee3a aa6a 	vsub.f32	s20, s20, s21
 80265be:	ee3b bacb 	vsub.f32	s22, s23, s22
 80265c2:	ee34 4ac4 	vsub.f32	s8, s9, s8
 80265c6:	ee33 3a62 	vsub.f32	s6, s6, s5
 80265ca:	ed01 aa01 	vstr	s20, [r1, #-4]
 80265ce:	edc2 8a01 	vstr	s17, [r2, #4]
 80265d2:	ed82 ba02 	vstr	s22, [r2, #8]
 80265d6:	ed5c 4a04 	vldr	s9, [ip, #-16]
 80265da:	ee74 3a63 	vsub.f32	s7, s8, s7
 80265de:	ee38 8a47 	vsub.f32	s16, s16, s14
 80265e2:	ed1c 4a03 	vldr	s8, [ip, #-12]
 80265e6:	ee30 0a46 	vsub.f32	s0, s0, s12
 80265ea:	ee33 3a42 	vsub.f32	s6, s6, s4
 80265ee:	ee38 8a67 	vsub.f32	s16, s16, s15
 80265f2:	ee30 0a66 	vsub.f32	s0, s0, s13
 80265f6:	ee23 9ae4 	vnmul.f32	s18, s7, s9
 80265fa:	ee63 8a04 	vmul.f32	s17, s6, s8
 80265fe:	ee28 aa24 	vmul.f32	s20, s16, s9
 8026602:	ee60 9a04 	vmul.f32	s19, s0, s8
 8026606:	ee28 8a04 	vmul.f32	s16, s16, s8
 802660a:	ee20 0a24 	vmul.f32	s0, s0, s9
 802660e:	ee63 3a84 	vmul.f32	s7, s7, s8
 8026612:	ee39 4a68 	vsub.f32	s8, s18, s17
 8026616:	ee7a 9a29 	vadd.f32	s19, s20, s19
 802661a:	ee14 aa10 	vmov	sl, s8
 802661e:	ee30 0a48 	vsub.f32	s0, s0, s16
 8026622:	ee63 4a24 	vmul.f32	s9, s6, s9
 8026626:	ed44 9a02 	vstr	s19, [r4, #-8]
 802662a:	ee73 3ae4 	vsub.f32	s7, s7, s9
 802662e:	ed04 0a01 	vstr	s0, [r4, #-4]
 8026632:	f846 a908 	str.w	sl, [r6], #-8
 8026636:	ee35 6a46 	vsub.f32	s12, s10, s12
 802663a:	ee35 7a87 	vadd.f32	s14, s11, s14
 802663e:	edc6 3a01 	vstr	s7, [r6, #4]
 8026642:	ee76 6a26 	vadd.f32	s13, s12, s13
 8026646:	ee77 7a67 	vsub.f32	s15, s14, s15
 802664a:	ed1e 6a05 	vldr	s12, [lr, #-20]	; 0xffffffec
 802664e:	ed1e 7a06 	vldr	s14, [lr, #-24]	; 0xffffffe8
 8026652:	ee67 5a86 	vmul.f32	s11, s15, s12
 8026656:	ee26 5a87 	vmul.f32	s10, s13, s14
 802665a:	ee72 2a62 	vsub.f32	s5, s4, s5
 802665e:	ee30 1ac1 	vsub.f32	s2, s1, s2
 8026662:	ee72 2ae1 	vsub.f32	s5, s5, s3
 8026666:	ee75 5a25 	vadd.f32	s11, s10, s11
 802666a:	ee62 0a86 	vmul.f32	s1, s5, s12
 802666e:	ee66 6a86 	vmul.f32	s13, s13, s12
 8026672:	ee67 7a87 	vmul.f32	s15, s15, s14
 8026676:	ee21 6a06 	vmul.f32	s12, s2, s12
 802667a:	ee62 2a87 	vmul.f32	s5, s5, s14
 802667e:	ee21 1a07 	vmul.f32	s2, s2, s14
 8026682:	ee15 aa90 	vmov	sl, s11
 8026686:	ee77 7ae6 	vsub.f32	s15, s15, s13
 802668a:	f840 ab08 	str.w	sl, [r0], #8
 802668e:	ee30 1ac1 	vsub.f32	s2, s1, s2
 8026692:	ee76 2a22 	vadd.f32	s5, s12, s5
 8026696:	f1b9 0901 	subs.w	r9, r9, #1
 802669a:	ed40 7a01 	vstr	s15, [r0, #-4]
 802669e:	f105 0508 	add.w	r5, r5, #8
 80266a2:	ed83 1a02 	vstr	s2, [r3, #8]
 80266a6:	edc3 2a01 	vstr	s5, [r3, #4]
 80266aa:	f108 0808 	add.w	r8, r8, #8
 80266ae:	f1a2 0208 	sub.w	r2, r2, #8
 80266b2:	f10c 0c10 	add.w	ip, ip, #16
 80266b6:	f104 0408 	add.w	r4, r4, #8
 80266ba:	f10e 0e18 	add.w	lr, lr, #24
 80266be:	f1a3 0308 	sub.w	r3, r3, #8
 80266c2:	f47f aefc 	bne.w	80264be <arm_cfft_radix8by4_f32+0x13e>
 80266c6:	9908      	ldr	r1, [sp, #32]
 80266c8:	9802      	ldr	r0, [sp, #8]
 80266ca:	f8dd a034 	ldr.w	sl, [sp, #52]	; 0x34
 80266ce:	00cb      	lsls	r3, r1, #3
 80266d0:	eb01 0241 	add.w	r2, r1, r1, lsl #1
 80266d4:	eb00 1101 	add.w	r1, r0, r1, lsl #4
 80266d8:	9102      	str	r1, [sp, #8]
 80266da:	9905      	ldr	r1, [sp, #20]
 80266dc:	4419      	add	r1, r3
 80266de:	9105      	str	r1, [sp, #20]
 80266e0:	9904      	ldr	r1, [sp, #16]
 80266e2:	4419      	add	r1, r3
 80266e4:	9104      	str	r1, [sp, #16]
 80266e6:	9906      	ldr	r1, [sp, #24]
 80266e8:	449b      	add	fp, r3
 80266ea:	4419      	add	r1, r3
 80266ec:	449a      	add	sl, r3
 80266ee:	9b03      	ldr	r3, [sp, #12]
 80266f0:	9106      	str	r1, [sp, #24]
 80266f2:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
 80266f6:	9303      	str	r3, [sp, #12]
 80266f8:	9a05      	ldr	r2, [sp, #20]
 80266fa:	9806      	ldr	r0, [sp, #24]
 80266fc:	ed92 4a00 	vldr	s8, [r2]
 8026700:	ed90 7a00 	vldr	s14, [r0]
 8026704:	ed9b 3a00 	vldr	s6, [fp]
 8026708:	edda 3a00 	vldr	s7, [sl]
 802670c:	edd2 4a01 	vldr	s9, [r2, #4]
 8026710:	edd0 6a01 	vldr	s13, [r0, #4]
 8026714:	ed9a 2a01 	vldr	s4, [sl, #4]
 8026718:	eddb 7a01 	vldr	s15, [fp, #4]
 802671c:	f8bd 402c 	ldrh.w	r4, [sp, #44]	; 0x2c
 8026720:	9e0c      	ldr	r6, [sp, #48]	; 0x30
 8026722:	ee34 6a07 	vadd.f32	s12, s8, s14
 8026726:	ee74 5aa6 	vadd.f32	s11, s9, s13
 802672a:	ee36 5a03 	vadd.f32	s10, s12, s6
 802672e:	ee74 6ae6 	vsub.f32	s13, s9, s13
 8026732:	ee35 5a23 	vadd.f32	s10, s10, s7
 8026736:	ee34 7a47 	vsub.f32	s14, s8, s14
 802673a:	ed82 5a00 	vstr	s10, [r2]
 802673e:	ed9b 5a01 	vldr	s10, [fp, #4]
 8026742:	edda 4a01 	vldr	s9, [sl, #4]
 8026746:	ee35 5a85 	vadd.f32	s10, s11, s10
 802674a:	ee37 4a27 	vadd.f32	s8, s14, s15
 802674e:	ee35 5a24 	vadd.f32	s10, s10, s9
 8026752:	ee76 4ac3 	vsub.f32	s9, s13, s6
 8026756:	ed82 5a01 	vstr	s10, [r2, #4]
 802675a:	9a04      	ldr	r2, [sp, #16]
 802675c:	ee34 5aa3 	vadd.f32	s10, s9, s7
 8026760:	edd2 1a00 	vldr	s3, [r2]
 8026764:	edd2 2a01 	vldr	s5, [r2, #4]
 8026768:	9a02      	ldr	r2, [sp, #8]
 802676a:	ee34 4a42 	vsub.f32	s8, s8, s4
 802676e:	ee36 6a43 	vsub.f32	s12, s12, s6
 8026772:	ee64 4a21 	vmul.f32	s9, s8, s3
 8026776:	ee24 4a22 	vmul.f32	s8, s8, s5
 802677a:	ee65 2a22 	vmul.f32	s5, s10, s5
 802677e:	ee25 5a21 	vmul.f32	s10, s10, s3
 8026782:	ee74 2aa2 	vadd.f32	s5, s9, s5
 8026786:	ee35 5a44 	vsub.f32	s10, s10, s8
 802678a:	ee75 5ae7 	vsub.f32	s11, s11, s15
 802678e:	edcb 2a00 	vstr	s5, [fp]
 8026792:	ed8b 5a01 	vstr	s10, [fp, #4]
 8026796:	ed92 4a01 	vldr	s8, [r2, #4]
 802679a:	ed92 5a00 	vldr	s10, [r2]
 802679e:	9a03      	ldr	r2, [sp, #12]
 80267a0:	ee36 6a63 	vsub.f32	s12, s12, s7
 80267a4:	ee75 5ac2 	vsub.f32	s11, s11, s4
 80267a8:	ee66 4a05 	vmul.f32	s9, s12, s10
 80267ac:	ee25 5a85 	vmul.f32	s10, s11, s10
 80267b0:	ee26 6a04 	vmul.f32	s12, s12, s8
 80267b4:	ee65 5a84 	vmul.f32	s11, s11, s8
 80267b8:	ee35 6a46 	vsub.f32	s12, s10, s12
 80267bc:	ee74 5aa5 	vadd.f32	s11, s9, s11
 80267c0:	ee76 6a83 	vadd.f32	s13, s13, s6
 80267c4:	ee37 7a67 	vsub.f32	s14, s14, s15
 80267c8:	ed80 6a01 	vstr	s12, [r0, #4]
 80267cc:	edc0 5a00 	vstr	s11, [r0]
 80267d0:	edd2 5a01 	vldr	s11, [r2, #4]
 80267d4:	9807      	ldr	r0, [sp, #28]
 80267d6:	ee77 7a02 	vadd.f32	s15, s14, s4
 80267da:	ee36 7ae3 	vsub.f32	s14, s13, s7
 80267de:	edd2 6a00 	vldr	s13, [r2]
 80267e2:	ee27 6aa6 	vmul.f32	s12, s15, s13
 80267e6:	ee67 6a26 	vmul.f32	s13, s14, s13
 80267ea:	ee67 7aa5 	vmul.f32	s15, s15, s11
 80267ee:	ee27 7a25 	vmul.f32	s14, s14, s11
 80267f2:	ee76 7ae7 	vsub.f32	s15, s13, s15
 80267f6:	ee36 7a07 	vadd.f32	s14, s12, s14
 80267fa:	edca 7a01 	vstr	s15, [sl, #4]
 80267fe:	ed8a 7a00 	vstr	s14, [sl]
 8026802:	6872      	ldr	r2, [r6, #4]
 8026804:	4621      	mov	r1, r4
 8026806:	2304      	movs	r3, #4
 8026808:	f000 f97a 	bl	8026b00 <arm_radix8_butterfly_f32>
 802680c:	9809      	ldr	r0, [sp, #36]	; 0x24
 802680e:	6872      	ldr	r2, [r6, #4]
 8026810:	4621      	mov	r1, r4
 8026812:	2304      	movs	r3, #4
 8026814:	f000 f974 	bl	8026b00 <arm_radix8_butterfly_f32>
 8026818:	980a      	ldr	r0, [sp, #40]	; 0x28
 802681a:	6872      	ldr	r2, [r6, #4]
 802681c:	4621      	mov	r1, r4
 802681e:	2304      	movs	r3, #4
 8026820:	f000 f96e 	bl	8026b00 <arm_radix8_butterfly_f32>
 8026824:	6872      	ldr	r2, [r6, #4]
 8026826:	9801      	ldr	r0, [sp, #4]
 8026828:	4621      	mov	r1, r4
 802682a:	2304      	movs	r3, #4
 802682c:	b00f      	add	sp, #60	; 0x3c
 802682e:	ecbd 8b0a 	vpop	{d8-d12}
 8026832:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8026836:	f000 b963 	b.w	8026b00 <arm_radix8_butterfly_f32>
 802683a:	bf00      	nop

0802683c <arm_cfft_f32>:
 802683c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8026840:	2a01      	cmp	r2, #1
 8026842:	4606      	mov	r6, r0
 8026844:	4617      	mov	r7, r2
 8026846:	460c      	mov	r4, r1
 8026848:	4698      	mov	r8, r3
 802684a:	8805      	ldrh	r5, [r0, #0]
 802684c:	d054      	beq.n	80268f8 <arm_cfft_f32+0xbc>
 802684e:	f5b5 7f80 	cmp.w	r5, #256	; 0x100
 8026852:	d04c      	beq.n	80268ee <arm_cfft_f32+0xb2>
 8026854:	d916      	bls.n	8026884 <arm_cfft_f32+0x48>
 8026856:	f5b5 6f80 	cmp.w	r5, #1024	; 0x400
 802685a:	d01a      	beq.n	8026892 <arm_cfft_f32+0x56>
 802685c:	d95c      	bls.n	8026918 <arm_cfft_f32+0xdc>
 802685e:	f5b5 6f00 	cmp.w	r5, #2048	; 0x800
 8026862:	d044      	beq.n	80268ee <arm_cfft_f32+0xb2>
 8026864:	f5b5 5f80 	cmp.w	r5, #4096	; 0x1000
 8026868:	d105      	bne.n	8026876 <arm_cfft_f32+0x3a>
 802686a:	2301      	movs	r3, #1
 802686c:	6872      	ldr	r2, [r6, #4]
 802686e:	4629      	mov	r1, r5
 8026870:	4620      	mov	r0, r4
 8026872:	f000 f945 	bl	8026b00 <arm_radix8_butterfly_f32>
 8026876:	f1b8 0f00 	cmp.w	r8, #0
 802687a:	d111      	bne.n	80268a0 <arm_cfft_f32+0x64>
 802687c:	2f01      	cmp	r7, #1
 802687e:	d016      	beq.n	80268ae <arm_cfft_f32+0x72>
 8026880:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8026884:	2d20      	cmp	r5, #32
 8026886:	d032      	beq.n	80268ee <arm_cfft_f32+0xb2>
 8026888:	d94a      	bls.n	8026920 <arm_cfft_f32+0xe4>
 802688a:	2d40      	cmp	r5, #64	; 0x40
 802688c:	d0ed      	beq.n	802686a <arm_cfft_f32+0x2e>
 802688e:	2d80      	cmp	r5, #128	; 0x80
 8026890:	d1f1      	bne.n	8026876 <arm_cfft_f32+0x3a>
 8026892:	4621      	mov	r1, r4
 8026894:	4630      	mov	r0, r6
 8026896:	f7ff fca3 	bl	80261e0 <arm_cfft_radix8by2_f32>
 802689a:	f1b8 0f00 	cmp.w	r8, #0
 802689e:	d0ed      	beq.n	802687c <arm_cfft_f32+0x40>
 80268a0:	68b2      	ldr	r2, [r6, #8]
 80268a2:	89b1      	ldrh	r1, [r6, #12]
 80268a4:	4620      	mov	r0, r4
 80268a6:	f7e3 fd2d 	bl	800a304 <arm_bitreversal_32>
 80268aa:	2f01      	cmp	r7, #1
 80268ac:	d1e8      	bne.n	8026880 <arm_cfft_f32+0x44>
 80268ae:	ee07 5a90 	vmov	s15, r5
 80268b2:	eef8 7a67 	vcvt.f32.u32	s15, s15
 80268b6:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
 80268ba:	eec7 6a27 	vdiv.f32	s13, s14, s15
 80268be:	2d00      	cmp	r5, #0
 80268c0:	d0de      	beq.n	8026880 <arm_cfft_f32+0x44>
 80268c2:	f104 0108 	add.w	r1, r4, #8
 80268c6:	2300      	movs	r3, #0
 80268c8:	3301      	adds	r3, #1
 80268ca:	429d      	cmp	r5, r3
 80268cc:	f101 0108 	add.w	r1, r1, #8
 80268d0:	ed11 7a04 	vldr	s14, [r1, #-16]
 80268d4:	ed51 7a03 	vldr	s15, [r1, #-12]
 80268d8:	ee27 7a26 	vmul.f32	s14, s14, s13
 80268dc:	ee67 7ae6 	vnmul.f32	s15, s15, s13
 80268e0:	ed01 7a04 	vstr	s14, [r1, #-16]
 80268e4:	ed41 7a03 	vstr	s15, [r1, #-12]
 80268e8:	d1ee      	bne.n	80268c8 <arm_cfft_f32+0x8c>
 80268ea:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 80268ee:	4621      	mov	r1, r4
 80268f0:	4630      	mov	r0, r6
 80268f2:	f7ff fd45 	bl	8026380 <arm_cfft_radix8by4_f32>
 80268f6:	e7be      	b.n	8026876 <arm_cfft_f32+0x3a>
 80268f8:	b1ad      	cbz	r5, 8026926 <arm_cfft_f32+0xea>
 80268fa:	f101 030c 	add.w	r3, r1, #12
 80268fe:	2200      	movs	r2, #0
 8026900:	ed53 7a02 	vldr	s15, [r3, #-8]
 8026904:	3201      	adds	r2, #1
 8026906:	eef1 7a67 	vneg.f32	s15, s15
 802690a:	4295      	cmp	r5, r2
 802690c:	ed43 7a02 	vstr	s15, [r3, #-8]
 8026910:	f103 0308 	add.w	r3, r3, #8
 8026914:	d1f4      	bne.n	8026900 <arm_cfft_f32+0xc4>
 8026916:	e79a      	b.n	802684e <arm_cfft_f32+0x12>
 8026918:	f5b5 7f00 	cmp.w	r5, #512	; 0x200
 802691c:	d0a5      	beq.n	802686a <arm_cfft_f32+0x2e>
 802691e:	e7aa      	b.n	8026876 <arm_cfft_f32+0x3a>
 8026920:	2d10      	cmp	r5, #16
 8026922:	d0b6      	beq.n	8026892 <arm_cfft_f32+0x56>
 8026924:	e7a7      	b.n	8026876 <arm_cfft_f32+0x3a>
 8026926:	f5b5 7f80 	cmp.w	r5, #256	; 0x100
 802692a:	d894      	bhi.n	8026856 <arm_cfft_f32+0x1a>
 802692c:	e7aa      	b.n	8026884 <arm_cfft_f32+0x48>
 802692e:	bf00      	nop

08026930 <arm_mat_init_f32>:
 8026930:	8001      	strh	r1, [r0, #0]
 8026932:	8042      	strh	r2, [r0, #2]
 8026934:	6043      	str	r3, [r0, #4]
 8026936:	4770      	bx	lr

08026938 <arm_cmplx_mag_squared_f32>:
 8026938:	b470      	push	{r4, r5, r6}
 802693a:	0896      	lsrs	r6, r2, #2
 802693c:	d03e      	beq.n	80269bc <arm_cmplx_mag_squared_f32+0x84>
 802693e:	f100 0320 	add.w	r3, r0, #32
 8026942:	f101 0410 	add.w	r4, r1, #16
 8026946:	4635      	mov	r5, r6
 8026948:	ed13 6a08 	vldr	s12, [r3, #-32]	; 0xffffffe0
 802694c:	ed13 4a07 	vldr	s8, [r3, #-28]	; 0xffffffe4
 8026950:	ed53 6a06 	vldr	s13, [r3, #-24]	; 0xffffffe8
 8026954:	ed53 4a05 	vldr	s9, [r3, #-20]	; 0xffffffec
 8026958:	ed13 7a04 	vldr	s14, [r3, #-16]
 802695c:	ed13 5a03 	vldr	s10, [r3, #-12]
 8026960:	ed53 7a02 	vldr	s15, [r3, #-8]
 8026964:	ed53 5a01 	vldr	s11, [r3, #-4]
 8026968:	ee26 6a06 	vmul.f32	s12, s12, s12
 802696c:	ee24 4a04 	vmul.f32	s8, s8, s8
 8026970:	ee66 6aa6 	vmul.f32	s13, s13, s13
 8026974:	ee64 4aa4 	vmul.f32	s9, s9, s9
 8026978:	ee27 7a07 	vmul.f32	s14, s14, s14
 802697c:	ee25 5a05 	vmul.f32	s10, s10, s10
 8026980:	ee67 7aa7 	vmul.f32	s15, s15, s15
 8026984:	ee65 5aa5 	vmul.f32	s11, s11, s11
 8026988:	ee36 6a04 	vadd.f32	s12, s12, s8
 802698c:	ee76 6aa4 	vadd.f32	s13, s13, s9
 8026990:	ee37 7a05 	vadd.f32	s14, s14, s10
 8026994:	ee77 7aa5 	vadd.f32	s15, s15, s11
 8026998:	3d01      	subs	r5, #1
 802699a:	ed04 6a04 	vstr	s12, [r4, #-16]
 802699e:	ed44 6a03 	vstr	s13, [r4, #-12]
 80269a2:	ed04 7a02 	vstr	s14, [r4, #-8]
 80269a6:	ed44 7a01 	vstr	s15, [r4, #-4]
 80269aa:	f103 0320 	add.w	r3, r3, #32
 80269ae:	f104 0410 	add.w	r4, r4, #16
 80269b2:	d1c9      	bne.n	8026948 <arm_cmplx_mag_squared_f32+0x10>
 80269b4:	eb00 1046 	add.w	r0, r0, r6, lsl #5
 80269b8:	eb01 1106 	add.w	r1, r1, r6, lsl #4
 80269bc:	f012 0203 	ands.w	r2, r2, #3
 80269c0:	d010      	beq.n	80269e4 <arm_cmplx_mag_squared_f32+0xac>
 80269c2:	3008      	adds	r0, #8
 80269c4:	ed50 7a02 	vldr	s15, [r0, #-8]
 80269c8:	ed10 7a01 	vldr	s14, [r0, #-4]
 80269cc:	ee67 7aa7 	vmul.f32	s15, s15, s15
 80269d0:	ee27 7a07 	vmul.f32	s14, s14, s14
 80269d4:	3a01      	subs	r2, #1
 80269d6:	ee77 7a87 	vadd.f32	s15, s15, s14
 80269da:	f100 0008 	add.w	r0, r0, #8
 80269de:	ece1 7a01 	vstmia	r1!, {s15}
 80269e2:	d1ef      	bne.n	80269c4 <arm_cmplx_mag_squared_f32+0x8c>
 80269e4:	bc70      	pop	{r4, r5, r6}
 80269e6:	4770      	bx	lr

080269e8 <arm_mult_f32>:
 80269e8:	b5f0      	push	{r4, r5, r6, r7, lr}
 80269ea:	ea5f 0e93 	movs.w	lr, r3, lsr #2
 80269ee:	d033      	beq.n	8026a58 <arm_mult_f32+0x70>
 80269f0:	f100 0610 	add.w	r6, r0, #16
 80269f4:	f101 0510 	add.w	r5, r1, #16
 80269f8:	f102 0410 	add.w	r4, r2, #16
 80269fc:	4677      	mov	r7, lr
 80269fe:	ed16 6a04 	vldr	s12, [r6, #-16]
 8026a02:	ed55 4a04 	vldr	s9, [r5, #-16]
 8026a06:	ed56 6a02 	vldr	s13, [r6, #-8]
 8026a0a:	ed15 5a02 	vldr	s10, [r5, #-8]
 8026a0e:	ed16 7a03 	vldr	s14, [r6, #-12]
 8026a12:	ed55 5a03 	vldr	s11, [r5, #-12]
 8026a16:	ed56 7a01 	vldr	s15, [r6, #-4]
 8026a1a:	ee26 6a24 	vmul.f32	s12, s12, s9
 8026a1e:	ee66 6a85 	vmul.f32	s13, s13, s10
 8026a22:	ed04 6a04 	vstr	s12, [r4, #-16]
 8026a26:	ed15 6a01 	vldr	s12, [r5, #-4]
 8026a2a:	ed44 6a02 	vstr	s13, [r4, #-8]
 8026a2e:	ee27 7a25 	vmul.f32	s14, s14, s11
 8026a32:	ee67 7a86 	vmul.f32	s15, s15, s12
 8026a36:	3f01      	subs	r7, #1
 8026a38:	ed04 7a03 	vstr	s14, [r4, #-12]
 8026a3c:	ed44 7a01 	vstr	s15, [r4, #-4]
 8026a40:	f106 0610 	add.w	r6, r6, #16
 8026a44:	f105 0510 	add.w	r5, r5, #16
 8026a48:	f104 0410 	add.w	r4, r4, #16
 8026a4c:	d1d7      	bne.n	80269fe <arm_mult_f32+0x16>
 8026a4e:	ea4f 140e 	mov.w	r4, lr, lsl #4
 8026a52:	4420      	add	r0, r4
 8026a54:	4421      	add	r1, r4
 8026a56:	4422      	add	r2, r4
 8026a58:	f013 0303 	ands.w	r3, r3, #3
 8026a5c:	d009      	beq.n	8026a72 <arm_mult_f32+0x8a>
 8026a5e:	ecf0 7a01 	vldmia	r0!, {s15}
 8026a62:	ecb1 7a01 	vldmia	r1!, {s14}
 8026a66:	ee67 7a87 	vmul.f32	s15, s15, s14
 8026a6a:	3b01      	subs	r3, #1
 8026a6c:	ece2 7a01 	vstmia	r2!, {s15}
 8026a70:	d1f5      	bne.n	8026a5e <arm_mult_f32+0x76>
 8026a72:	bdf0      	pop	{r4, r5, r6, r7, pc}

08026a74 <arm_dot_prod_f32>:
 8026a74:	b4f0      	push	{r4, r5, r6, r7}
 8026a76:	0897      	lsrs	r7, r2, #2
 8026a78:	eddf 5a20 	vldr	s11, [pc, #128]	; 8026afc <arm_dot_prod_f32+0x88>
 8026a7c:	d02d      	beq.n	8026ada <arm_dot_prod_f32+0x66>
 8026a7e:	f100 0510 	add.w	r5, r0, #16
 8026a82:	f101 0410 	add.w	r4, r1, #16
 8026a86:	463e      	mov	r6, r7
 8026a88:	ed54 7a04 	vldr	s15, [r4, #-16]
 8026a8c:	ed15 6a04 	vldr	s12, [r5, #-16]
 8026a90:	ed55 6a03 	vldr	s13, [r5, #-12]
 8026a94:	ed54 3a03 	vldr	s7, [r4, #-12]
 8026a98:	ed15 7a02 	vldr	s14, [r5, #-8]
 8026a9c:	ed14 4a02 	vldr	s8, [r4, #-8]
 8026aa0:	ed15 5a01 	vldr	s10, [r5, #-4]
 8026aa4:	ed54 4a01 	vldr	s9, [r4, #-4]
 8026aa8:	ee26 6a27 	vmul.f32	s12, s12, s15
 8026aac:	ee66 6aa3 	vmul.f32	s13, s13, s7
 8026ab0:	ee76 7a25 	vadd.f32	s15, s12, s11
 8026ab4:	ee27 7a04 	vmul.f32	s14, s14, s8
 8026ab8:	ee76 7aa7 	vadd.f32	s15, s13, s15
 8026abc:	ee65 5a24 	vmul.f32	s11, s10, s9
 8026ac0:	ee77 7a27 	vadd.f32	s15, s14, s15
 8026ac4:	3e01      	subs	r6, #1
 8026ac6:	f105 0510 	add.w	r5, r5, #16
 8026aca:	ee75 5aa7 	vadd.f32	s11, s11, s15
 8026ace:	f104 0410 	add.w	r4, r4, #16
 8026ad2:	d1d9      	bne.n	8026a88 <arm_dot_prod_f32+0x14>
 8026ad4:	013f      	lsls	r7, r7, #4
 8026ad6:	4438      	add	r0, r7
 8026ad8:	4439      	add	r1, r7
 8026ada:	f012 0203 	ands.w	r2, r2, #3
 8026ade:	d009      	beq.n	8026af4 <arm_dot_prod_f32+0x80>
 8026ae0:	ecf0 7a01 	vldmia	r0!, {s15}
 8026ae4:	ecb1 7a01 	vldmia	r1!, {s14}
 8026ae8:	ee67 7a87 	vmul.f32	s15, s15, s14
 8026aec:	3a01      	subs	r2, #1
 8026aee:	ee75 5aa7 	vadd.f32	s11, s11, s15
 8026af2:	d1f5      	bne.n	8026ae0 <arm_dot_prod_f32+0x6c>
 8026af4:	edc3 5a00 	vstr	s11, [r3]
 8026af8:	bcf0      	pop	{r4, r5, r6, r7}
 8026afa:	4770      	bx	lr
 8026afc:	00000000 	.word	0x00000000

08026b00 <arm_radix8_butterfly_f32>:
 8026b00:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8026b04:	ed2d 8b10 	vpush	{d8-d15}
 8026b08:	461c      	mov	r4, r3
 8026b0a:	b09d      	sub	sp, #116	; 0x74
 8026b0c:	4603      	mov	r3, r0
 8026b0e:	3304      	adds	r3, #4
 8026b10:	ed9f bac4 	vldr	s22, [pc, #784]	; 8026e24 <arm_radix8_butterfly_f32+0x324>
 8026b14:	9019      	str	r0, [sp, #100]	; 0x64
 8026b16:	921a      	str	r2, [sp, #104]	; 0x68
 8026b18:	468b      	mov	fp, r1
 8026b1a:	931b      	str	r3, [sp, #108]	; 0x6c
 8026b1c:	468a      	mov	sl, r1
 8026b1e:	46a1      	mov	r9, r4
 8026b20:	4607      	mov	r7, r0
 8026b22:	ea4f 03db 	mov.w	r3, fp, lsr #3
 8026b26:	ea4f 0843 	mov.w	r8, r3, lsl #1
 8026b2a:	eb03 0508 	add.w	r5, r3, r8
 8026b2e:	195c      	adds	r4, r3, r5
 8026b30:	00de      	lsls	r6, r3, #3
 8026b32:	191a      	adds	r2, r3, r4
 8026b34:	9600      	str	r6, [sp, #0]
 8026b36:	1898      	adds	r0, r3, r2
 8026b38:	4619      	mov	r1, r3
 8026b3a:	9e00      	ldr	r6, [sp, #0]
 8026b3c:	9311      	str	r3, [sp, #68]	; 0x44
 8026b3e:	4401      	add	r1, r0
 8026b40:	eb07 02c2 	add.w	r2, r7, r2, lsl #3
 8026b44:	eb07 01c1 	add.w	r1, r7, r1, lsl #3
 8026b48:	19be      	adds	r6, r7, r6
 8026b4a:	eb07 05c5 	add.w	r5, r7, r5, lsl #3
 8026b4e:	eb07 04c4 	add.w	r4, r7, r4, lsl #3
 8026b52:	eb07 00c0 	add.w	r0, r7, r0, lsl #3
 8026b56:	9f00      	ldr	r7, [sp, #0]
 8026b58:	011b      	lsls	r3, r3, #4
 8026b5a:	eb06 0e07 	add.w	lr, r6, r7
 8026b5e:	9f1b      	ldr	r7, [sp, #108]	; 0x6c
 8026b60:	9302      	str	r3, [sp, #8]
 8026b62:	3204      	adds	r2, #4
 8026b64:	3104      	adds	r1, #4
 8026b66:	ea4f 03cb 	mov.w	r3, fp, lsl #3
 8026b6a:	f04f 0c00 	mov.w	ip, #0
 8026b6e:	edde 7a00 	vldr	s15, [lr]
 8026b72:	edd6 6a00 	vldr	s13, [r6]
 8026b76:	ed95 2a00 	vldr	s4, [r5]
 8026b7a:	ed17 aa01 	vldr	s20, [r7, #-4]
 8026b7e:	edd4 4a00 	vldr	s9, [r4]
 8026b82:	ed90 5a00 	vldr	s10, [r0]
 8026b86:	ed12 7a01 	vldr	s14, [r2, #-4]
 8026b8a:	ed51 0a01 	vldr	s1, [r1, #-4]
 8026b8e:	ee77 8a85 	vadd.f32	s17, s15, s10
 8026b92:	ee76 3a87 	vadd.f32	s7, s13, s14
 8026b96:	ee32 4a20 	vadd.f32	s8, s4, s1
 8026b9a:	ee3a 3a24 	vadd.f32	s6, s20, s9
 8026b9e:	ee33 6a84 	vadd.f32	s12, s7, s8
 8026ba2:	ee73 5a28 	vadd.f32	s11, s6, s17
 8026ba6:	ee36 7ac7 	vsub.f32	s14, s13, s14
 8026baa:	ee75 6a86 	vadd.f32	s13, s11, s12
 8026bae:	ee75 5ac6 	vsub.f32	s11, s11, s12
 8026bb2:	ed47 6a01 	vstr	s13, [r7, #-4]
 8026bb6:	edc4 5a00 	vstr	s11, [r4]
 8026bba:	ed92 9a00 	vldr	s18, [r2]
 8026bbe:	ed95 1a01 	vldr	s2, [r5, #4]
 8026bc2:	edd6 5a01 	vldr	s11, [r6, #4]
 8026bc6:	ed91 6a00 	vldr	s12, [r1]
 8026bca:	edd7 2a00 	vldr	s5, [r7]
 8026bce:	edd4 1a01 	vldr	s3, [r4, #4]
 8026bd2:	edde 6a01 	vldr	s13, [lr, #4]
 8026bd6:	edd0 9a01 	vldr	s19, [r0, #4]
 8026bda:	ee72 0a60 	vsub.f32	s1, s4, s1
 8026bde:	ee71 aa46 	vsub.f32	s21, s2, s12
 8026be2:	ee35 2ac9 	vsub.f32	s4, s11, s18
 8026be6:	ee37 0a60 	vsub.f32	s0, s14, s1
 8026bea:	ee32 8a2a 	vadd.f32	s16, s4, s21
 8026bee:	ee37 7a20 	vadd.f32	s14, s14, s1
 8026bf2:	ee32 2a6a 	vsub.f32	s4, s4, s21
 8026bf6:	ee37 5ac5 	vsub.f32	s10, s15, s10
 8026bfa:	ee75 5a89 	vadd.f32	s11, s11, s18
 8026bfe:	ee60 0a0b 	vmul.f32	s1, s0, s22
 8026c02:	ee7a 4a64 	vsub.f32	s9, s20, s9
 8026c06:	ee31 6a06 	vadd.f32	s12, s2, s12
 8026c0a:	ee36 9aa9 	vadd.f32	s18, s13, s19
 8026c0e:	ee32 1aa1 	vadd.f32	s2, s5, s3
 8026c12:	ee76 6ae9 	vsub.f32	s13, s13, s19
 8026c16:	ee72 1ae1 	vsub.f32	s3, s5, s3
 8026c1a:	ee28 8a0b 	vmul.f32	s16, s16, s22
 8026c1e:	ee62 2a0b 	vmul.f32	s5, s4, s22
 8026c22:	ee67 7a0b 	vmul.f32	s15, s14, s22
 8026c26:	ee33 3a68 	vsub.f32	s6, s6, s17
 8026c2a:	ee36 0a88 	vadd.f32	s0, s13, s16
 8026c2e:	ee75 8a86 	vadd.f32	s17, s11, s12
 8026c32:	ee36 7ac8 	vsub.f32	s14, s13, s16
 8026c36:	ee33 4ac4 	vsub.f32	s8, s7, s8
 8026c3a:	ee74 6ae0 	vsub.f32	s13, s9, s1
 8026c3e:	ee74 3aa0 	vadd.f32	s7, s9, s1
 8026c42:	ee35 6ac6 	vsub.f32	s12, s11, s12
 8026c46:	ee75 4a27 	vadd.f32	s9, s10, s15
 8026c4a:	ee71 5a49 	vsub.f32	s11, s2, s18
 8026c4e:	ee31 2a09 	vadd.f32	s4, s2, s18
 8026c52:	ee75 7a67 	vsub.f32	s15, s10, s15
 8026c56:	ee31 1aa2 	vadd.f32	s2, s3, s5
 8026c5a:	ee71 2ae2 	vsub.f32	s5, s3, s5
 8026c5e:	ee73 0a06 	vadd.f32	s1, s6, s12
 8026c62:	ee75 1ac4 	vsub.f32	s3, s11, s8
 8026c66:	ee36 5a87 	vadd.f32	s10, s13, s14
 8026c6a:	ee32 8a28 	vadd.f32	s16, s4, s17
 8026c6e:	ee33 6a46 	vsub.f32	s12, s6, s12
 8026c72:	ee34 4a25 	vadd.f32	s8, s8, s11
 8026c76:	ee33 3a80 	vadd.f32	s6, s7, s0
 8026c7a:	ee36 7ac7 	vsub.f32	s14, s13, s14
 8026c7e:	ee71 5a64 	vsub.f32	s11, s2, s9
 8026c82:	ee72 6ae7 	vsub.f32	s13, s5, s15
 8026c86:	ee32 2a68 	vsub.f32	s4, s4, s17
 8026c8a:	ee73 3ac0 	vsub.f32	s7, s7, s0
 8026c8e:	ee74 4a81 	vadd.f32	s9, s9, s2
 8026c92:	ee77 7aa2 	vadd.f32	s15, s15, s5
 8026c96:	44dc      	add	ip, fp
 8026c98:	45e2      	cmp	sl, ip
 8026c9a:	ed87 8a00 	vstr	s16, [r7]
 8026c9e:	ed84 2a01 	vstr	s4, [r4, #4]
 8026ca2:	441f      	add	r7, r3
 8026ca4:	edce 0a00 	vstr	s1, [lr]
 8026ca8:	441c      	add	r4, r3
 8026caa:	ed80 6a00 	vstr	s12, [r0]
 8026cae:	edce 1a01 	vstr	s3, [lr, #4]
 8026cb2:	ed80 4a01 	vstr	s8, [r0, #4]
 8026cb6:	449e      	add	lr, r3
 8026cb8:	ed86 3a00 	vstr	s6, [r6]
 8026cbc:	4418      	add	r0, r3
 8026cbe:	ed41 3a01 	vstr	s7, [r1, #-4]
 8026cc2:	ed02 5a01 	vstr	s10, [r2, #-4]
 8026cc6:	ed85 7a00 	vstr	s14, [r5]
 8026cca:	edc6 5a01 	vstr	s11, [r6, #4]
 8026cce:	edc1 4a00 	vstr	s9, [r1]
 8026cd2:	441e      	add	r6, r3
 8026cd4:	edc2 6a00 	vstr	s13, [r2]
 8026cd8:	4419      	add	r1, r3
 8026cda:	edc5 7a01 	vstr	s15, [r5, #4]
 8026cde:	441a      	add	r2, r3
 8026ce0:	441d      	add	r5, r3
 8026ce2:	f63f af44 	bhi.w	8026b6e <arm_radix8_butterfly_f32+0x6e>
 8026ce6:	9a11      	ldr	r2, [sp, #68]	; 0x44
 8026ce8:	2a07      	cmp	r2, #7
 8026cea:	f240 81f5 	bls.w	80270d8 <arm_radix8_butterfly_f32+0x5d8>
 8026cee:	f108 0101 	add.w	r1, r8, #1
 8026cf2:	188f      	adds	r7, r1, r2
 8026cf4:	eb09 0849 	add.w	r8, r9, r9, lsl #1
 8026cf8:	19d6      	adds	r6, r2, r7
 8026cfa:	eb08 0c09 	add.w	ip, r8, r9
 8026cfe:	1994      	adds	r4, r2, r6
 8026d00:	eb0c 0e09 	add.w	lr, ip, r9
 8026d04:	4610      	mov	r0, r2
 8026d06:	9701      	str	r7, [sp, #4]
 8026d08:	4420      	add	r0, r4
 8026d0a:	eb0e 0709 	add.w	r7, lr, r9
 8026d0e:	1815      	adds	r5, r2, r0
 8026d10:	eb07 0209 	add.w	r2, r7, r9
 8026d14:	9203      	str	r2, [sp, #12]
 8026d16:	9a1a      	ldr	r2, [sp, #104]	; 0x68
 8026d18:	ea4f 01c9 	mov.w	r1, r9, lsl #3
 8026d1c:	9117      	str	r1, [sp, #92]	; 0x5c
 8026d1e:	440a      	add	r2, r1
 8026d20:	9900      	ldr	r1, [sp, #0]
 8026d22:	3108      	adds	r1, #8
 8026d24:	9100      	str	r1, [sp, #0]
 8026d26:	9902      	ldr	r1, [sp, #8]
 8026d28:	3108      	adds	r1, #8
 8026d2a:	9102      	str	r1, [sp, #8]
 8026d2c:	9919      	ldr	r1, [sp, #100]	; 0x64
 8026d2e:	00ff      	lsls	r7, r7, #3
 8026d30:	9715      	str	r7, [sp, #84]	; 0x54
 8026d32:	eb01 04c4 	add.w	r4, r1, r4, lsl #3
 8026d36:	eb01 05c5 	add.w	r5, r1, r5, lsl #3
 8026d3a:	eb01 00c0 	add.w	r0, r1, r0, lsl #3
 8026d3e:	9f17      	ldr	r7, [sp, #92]	; 0x5c
 8026d40:	9903      	ldr	r1, [sp, #12]
 8026d42:	19d7      	adds	r7, r2, r7
 8026d44:	00c9      	lsls	r1, r1, #3
 8026d46:	9114      	str	r1, [sp, #80]	; 0x50
 8026d48:	9710      	str	r7, [sp, #64]	; 0x40
 8026d4a:	9919      	ldr	r1, [sp, #100]	; 0x64
 8026d4c:	9f00      	ldr	r7, [sp, #0]
 8026d4e:	19cf      	adds	r7, r1, r7
 8026d50:	970d      	str	r7, [sp, #52]	; 0x34
 8026d52:	9f02      	ldr	r7, [sp, #8]
 8026d54:	19cf      	adds	r7, r1, r7
 8026d56:	ea4f 0ece 	mov.w	lr, lr, lsl #3
 8026d5a:	970c      	str	r7, [sp, #48]	; 0x30
 8026d5c:	9f01      	ldr	r7, [sp, #4]
 8026d5e:	f8cd e058 	str.w	lr, [sp, #88]	; 0x58
 8026d62:	3504      	adds	r5, #4
 8026d64:	3004      	adds	r0, #4
 8026d66:	eb01 0ec7 	add.w	lr, r1, r7, lsl #3
 8026d6a:	9508      	str	r5, [sp, #32]
 8026d6c:	9009      	str	r0, [sp, #36]	; 0x24
 8026d6e:	9d16      	ldr	r5, [sp, #88]	; 0x58
 8026d70:	981a      	ldr	r0, [sp, #104]	; 0x68
 8026d72:	f8cd e02c 	str.w	lr, [sp, #44]	; 0x2c
 8026d76:	ea4f 08c8 	mov.w	r8, r8, lsl #3
 8026d7a:	eb01 0ec6 	add.w	lr, r1, r6, lsl #3
 8026d7e:	9e14      	ldr	r6, [sp, #80]	; 0x50
 8026d80:	f8cd e038 	str.w	lr, [sp, #56]	; 0x38
 8026d84:	1945      	adds	r5, r0, r5
 8026d86:	ea4f 0ccc 	mov.w	ip, ip, lsl #3
 8026d8a:	460f      	mov	r7, r1
 8026d8c:	3404      	adds	r4, #4
 8026d8e:	4641      	mov	r1, r8
 8026d90:	1841      	adds	r1, r0, r1
 8026d92:	f8cd c048 	str.w	ip, [sp, #72]	; 0x48
 8026d96:	940a      	str	r4, [sp, #40]	; 0x28
 8026d98:	eb00 0c06 	add.w	ip, r0, r6
 8026d9c:	f8cd 804c 	str.w	r8, [sp, #76]	; 0x4c
 8026da0:	9e15      	ldr	r6, [sp, #84]	; 0x54
 8026da2:	9506      	str	r5, [sp, #24]
 8026da4:	9c12      	ldr	r4, [sp, #72]	; 0x48
 8026da6:	9105      	str	r1, [sp, #20]
 8026da8:	4639      	mov	r1, r7
 8026daa:	1905      	adds	r5, r0, r4
 8026dac:	3108      	adds	r1, #8
 8026dae:	9c10      	ldr	r4, [sp, #64]	; 0x40
 8026db0:	9507      	str	r5, [sp, #28]
 8026db2:	910f      	str	r1, [sp, #60]	; 0x3c
 8026db4:	ea4f 1509 	mov.w	r5, r9, lsl #4
 8026db8:	2101      	movs	r1, #1
 8026dba:	eb00 0e06 	add.w	lr, r0, r6
 8026dbe:	9518      	str	r5, [sp, #96]	; 0x60
 8026dc0:	9404      	str	r4, [sp, #16]
 8026dc2:	9103      	str	r1, [sp, #12]
 8026dc4:	4620      	mov	r0, r4
 8026dc6:	4689      	mov	r9, r1
 8026dc8:	9e06      	ldr	r6, [sp, #24]
 8026dca:	ed90 fa00 	vldr	s30, [r0]
 8026dce:	edd6 7a01 	vldr	s15, [r6, #4]
 8026dd2:	edd0 ba01 	vldr	s23, [r0, #4]
 8026dd6:	edcd 7a00 	vstr	s15, [sp]
 8026dda:	a80d      	add	r0, sp, #52	; 0x34
 8026ddc:	edde 7a01 	vldr	s15, [lr, #4]
 8026de0:	9c05      	ldr	r4, [sp, #20]
 8026de2:	9d07      	ldr	r5, [sp, #28]
 8026de4:	edd2 fa00 	vldr	s31, [r2]
 8026de8:	ed92 ca01 	vldr	s24, [r2, #4]
 8026dec:	edcd 7a01 	vstr	s15, [sp, #4]
 8026df0:	c807      	ldmia	r0, {r0, r1, r2}
 8026df2:	eddc 7a01 	vldr	s15, [ip, #4]
 8026df6:	edd4 ea00 	vldr	s29, [r4]
 8026dfa:	ed95 ea00 	vldr	s28, [r5]
 8026dfe:	edd6 da00 	vldr	s27, [r6]
 8026e02:	edd4 aa01 	vldr	s21, [r4, #4]
 8026e06:	ed95 aa01 	vldr	s20, [r5, #4]
 8026e0a:	ed9e da00 	vldr	s26, [lr]
 8026e0e:	eddc ca00 	vldr	s25, [ip]
 8026e12:	f8dd 8020 	ldr.w	r8, [sp, #32]
 8026e16:	9f09      	ldr	r7, [sp, #36]	; 0x24
 8026e18:	9e0a      	ldr	r6, [sp, #40]	; 0x28
 8026e1a:	9d0b      	ldr	r5, [sp, #44]	; 0x2c
 8026e1c:	9c0c      	ldr	r4, [sp, #48]	; 0x30
 8026e1e:	edcd 7a02 	vstr	s15, [sp, #8]
 8026e22:	e001      	b.n	8026e28 <arm_radix8_butterfly_f32+0x328>
 8026e24:	3f3504f3 	.word	0x3f3504f3
 8026e28:	ed16 6a01 	vldr	s12, [r6, #-4]
 8026e2c:	ed91 5a00 	vldr	s10, [r1]
 8026e30:	ed57 9a01 	vldr	s19, [r7, #-4]
 8026e34:	edd5 7a00 	vldr	s15, [r5]
 8026e38:	ed18 7a01 	vldr	s14, [r8, #-4]
 8026e3c:	edd2 3a00 	vldr	s7, [r2]
 8026e40:	ed94 3a00 	vldr	s6, [r4]
 8026e44:	ed90 2a00 	vldr	s4, [r0]
 8026e48:	ed92 0a01 	vldr	s0, [r2, #4]
 8026e4c:	ee33 8a85 	vadd.f32	s16, s7, s10
 8026e50:	ee32 1a06 	vadd.f32	s2, s4, s12
 8026e54:	ee33 4a29 	vadd.f32	s8, s6, s19
 8026e58:	ee77 4a87 	vadd.f32	s9, s15, s14
 8026e5c:	ee78 1a04 	vadd.f32	s3, s16, s8
 8026e60:	ee71 6a24 	vadd.f32	s13, s2, s9
 8026e64:	ee32 2a46 	vsub.f32	s4, s4, s12
 8026e68:	ee31 6aa6 	vadd.f32	s12, s3, s13
 8026e6c:	ee77 7ac7 	vsub.f32	s15, s15, s14
 8026e70:	ed82 6a00 	vstr	s12, [r2]
 8026e74:	edd5 8a01 	vldr	s17, [r5, #4]
 8026e78:	ed90 9a01 	vldr	s18, [r0, #4]
 8026e7c:	edd6 2a00 	vldr	s5, [r6]
 8026e80:	ed98 7a00 	vldr	s14, [r8]
 8026e84:	edd4 0a01 	vldr	s1, [r4, #4]
 8026e88:	ed91 6a01 	vldr	s12, [r1, #4]
 8026e8c:	edd7 5a00 	vldr	s11, [r7]
 8026e90:	ee73 3ac5 	vsub.f32	s7, s7, s10
 8026e94:	ee33 3a69 	vsub.f32	s6, s6, s19
 8026e98:	ee39 5a62 	vsub.f32	s10, s18, s5
 8026e9c:	ee78 9ac7 	vsub.f32	s19, s17, s14
 8026ea0:	ee38 4a44 	vsub.f32	s8, s16, s8
 8026ea4:	ee38 7a87 	vadd.f32	s14, s17, s14
 8026ea8:	ee30 8aa5 	vadd.f32	s16, s1, s11
 8026eac:	ee79 2a22 	vadd.f32	s5, s18, s5
 8026eb0:	ee75 8a69 	vsub.f32	s17, s10, s19
 8026eb4:	ee32 9a27 	vadd.f32	s18, s4, s15
 8026eb8:	ee35 5a29 	vadd.f32	s10, s10, s19
 8026ebc:	ee72 7a67 	vsub.f32	s15, s4, s15
 8026ec0:	ee30 2a06 	vadd.f32	s4, s0, s12
 8026ec4:	ee69 9a0b 	vmul.f32	s19, s18, s22
 8026ec8:	ee70 5ae5 	vsub.f32	s11, s1, s11
 8026ecc:	ee32 9a08 	vadd.f32	s18, s4, s16
 8026ed0:	ee68 8a8b 	vmul.f32	s17, s17, s22
 8026ed4:	ee32 2a48 	vsub.f32	s4, s4, s16
 8026ed8:	ee71 4a64 	vsub.f32	s9, s2, s9
 8026edc:	ee25 5a0b 	vmul.f32	s10, s10, s22
 8026ee0:	ee32 1a87 	vadd.f32	s2, s5, s14
 8026ee4:	ee67 7a8b 	vmul.f32	s15, s15, s22
 8026ee8:	ee72 2ac7 	vsub.f32	s5, s5, s14
 8026eec:	ee30 6a46 	vsub.f32	s12, s0, s12
 8026ef0:	ee73 0a29 	vadd.f32	s1, s6, s19
 8026ef4:	ee36 0a28 	vadd.f32	s0, s12, s17
 8026ef8:	ee33 3a69 	vsub.f32	s6, s6, s19
 8026efc:	ee32 7a64 	vsub.f32	s14, s4, s9
 8026f00:	ee73 9aa7 	vadd.f32	s19, s7, s15
 8026f04:	ee36 6a68 	vsub.f32	s12, s12, s17
 8026f08:	ee73 7ae7 	vsub.f32	s15, s7, s15
 8026f0c:	ee75 8a85 	vadd.f32	s17, s11, s10
 8026f10:	ee74 3a22 	vadd.f32	s7, s8, s5
 8026f14:	ee35 5ac5 	vsub.f32	s10, s11, s10
 8026f18:	ee71 6ae6 	vsub.f32	s13, s3, s13
 8026f1c:	ee79 1a41 	vsub.f32	s3, s18, s2
 8026f20:	ee39 8aa8 	vadd.f32	s16, s19, s17
 8026f24:	ee76 5a43 	vsub.f32	s11, s12, s6
 8026f28:	ee74 2a62 	vsub.f32	s5, s8, s5
 8026f2c:	ee74 4a82 	vadd.f32	s9, s9, s4
 8026f30:	ee30 4a60 	vsub.f32	s8, s0, s1
 8026f34:	ee79 8ae8 	vsub.f32	s17, s19, s17
 8026f38:	ee30 0a80 	vadd.f32	s0, s1, s0
 8026f3c:	ee77 9a85 	vadd.f32	s19, s15, s10
 8026f40:	ee33 6a06 	vadd.f32	s12, s6, s12
 8026f44:	ee77 7ac5 	vsub.f32	s15, s15, s10
 8026f48:	ee2e 2a21 	vmul.f32	s4, s28, s3
 8026f4c:	ee2e 5a26 	vmul.f32	s10, s28, s13
 8026f50:	ee6f 0a23 	vmul.f32	s1, s30, s7
 8026f54:	ee2a 3a21 	vmul.f32	s6, s20, s3
 8026f58:	ee39 1a01 	vadd.f32	s2, s18, s2
 8026f5c:	ee6a 6a26 	vmul.f32	s13, s20, s13
 8026f60:	ee2b 9a87 	vmul.f32	s18, s23, s14
 8026f64:	ee6b 3aa3 	vmul.f32	s7, s23, s7
 8026f68:	ee2f 7a07 	vmul.f32	s14, s30, s14
 8026f6c:	ee6f 1a84 	vmul.f32	s3, s31, s8
 8026f70:	ee35 3a03 	vadd.f32	s6, s10, s6
 8026f74:	ee72 6a66 	vsub.f32	s13, s4, s13
 8026f78:	ee2c 5a04 	vmul.f32	s10, s24, s8
 8026f7c:	ee2f 2a88 	vmul.f32	s4, s31, s16
 8026f80:	ed9d 4a02 	vldr	s8, [sp, #8]
 8026f84:	ed82 1a01 	vstr	s2, [r2, #4]
 8026f88:	ee77 3a63 	vsub.f32	s7, s14, s7
 8026f8c:	ee2c 8a08 	vmul.f32	s16, s24, s16
 8026f90:	ed9d 7a01 	vldr	s14, [sp, #4]
 8026f94:	ed81 3a00 	vstr	s6, [r1]
 8026f98:	ee30 9a89 	vadd.f32	s18, s1, s18
 8026f9c:	ee32 2a05 	vadd.f32	s4, s4, s10
 8026fa0:	ee6d 0a22 	vmul.f32	s1, s26, s5
 8026fa4:	ee31 8ac8 	vsub.f32	s16, s3, s16
 8026fa8:	ee67 2a22 	vmul.f32	s5, s14, s5
 8026fac:	ee64 1a00 	vmul.f32	s3, s8, s0
 8026fb0:	ee27 7a24 	vmul.f32	s14, s14, s9
 8026fb4:	ee2c 5aa8 	vmul.f32	s10, s25, s17
 8026fb8:	ee6d 4a24 	vmul.f32	s9, s26, s9
 8026fbc:	ee64 8a28 	vmul.f32	s17, s8, s17
 8026fc0:	ed9d 4a00 	vldr	s8, [sp]
 8026fc4:	edc1 6a01 	vstr	s13, [r1, #4]
 8026fc8:	ee74 2ae2 	vsub.f32	s5, s9, s5
 8026fcc:	ee6d 4aa9 	vmul.f32	s9, s27, s19
 8026fd0:	ee64 9a29 	vmul.f32	s19, s8, s19
 8026fd4:	ee24 4a25 	vmul.f32	s8, s8, s11
 8026fd8:	ee30 7a87 	vadd.f32	s14, s1, s14
 8026fdc:	ee74 4a84 	vadd.f32	s9, s9, s8
 8026fe0:	ee6e 0aa7 	vmul.f32	s1, s29, s15
 8026fe4:	ee2a 4a86 	vmul.f32	s8, s21, s12
 8026fe8:	ee2c 0a80 	vmul.f32	s0, s25, s0
 8026fec:	ee6d 5aa5 	vmul.f32	s11, s27, s11
 8026ff0:	ee6a 7aa7 	vmul.f32	s15, s21, s15
 8026ff4:	ee2e 6a86 	vmul.f32	s12, s29, s12
 8026ff8:	ee75 1a21 	vadd.f32	s3, s10, s3
 8026ffc:	ee30 0a68 	vsub.f32	s0, s0, s17
 8027000:	ee75 9ae9 	vsub.f32	s19, s11, s19
 8027004:	ee70 0a84 	vadd.f32	s1, s1, s8
 8027008:	ee36 6a67 	vsub.f32	s12, s12, s15
 802700c:	44d9      	add	r9, fp
 802700e:	45ca      	cmp	sl, r9
 8027010:	ed84 9a00 	vstr	s18, [r4]
 8027014:	edc4 3a01 	vstr	s7, [r4, #4]
 8027018:	441a      	add	r2, r3
 802701a:	ed07 7a01 	vstr	s14, [r7, #-4]
 802701e:	edc7 2a00 	vstr	s5, [r7]
 8027022:	4419      	add	r1, r3
 8027024:	ed80 2a00 	vstr	s4, [r0]
 8027028:	ed80 8a01 	vstr	s16, [r0, #4]
 802702c:	441c      	add	r4, r3
 802702e:	ed48 1a01 	vstr	s3, [r8, #-4]
 8027032:	ed88 0a00 	vstr	s0, [r8]
 8027036:	441f      	add	r7, r3
 8027038:	ed46 4a01 	vstr	s9, [r6, #-4]
 802703c:	4418      	add	r0, r3
 802703e:	edc6 9a00 	vstr	s19, [r6]
 8027042:	4498      	add	r8, r3
 8027044:	edc5 0a00 	vstr	s1, [r5]
 8027048:	ed85 6a01 	vstr	s12, [r5, #4]
 802704c:	441e      	add	r6, r3
 802704e:	441d      	add	r5, r3
 8027050:	f63f aeea 	bhi.w	8026e28 <arm_radix8_butterfly_f32+0x328>
 8027054:	9a03      	ldr	r2, [sp, #12]
 8027056:	9818      	ldr	r0, [sp, #96]	; 0x60
 8027058:	3201      	adds	r2, #1
 802705a:	4611      	mov	r1, r2
 802705c:	9203      	str	r2, [sp, #12]
 802705e:	9a04      	ldr	r2, [sp, #16]
 8027060:	4402      	add	r2, r0
 8027062:	9204      	str	r2, [sp, #16]
 8027064:	9813      	ldr	r0, [sp, #76]	; 0x4c
 8027066:	9a05      	ldr	r2, [sp, #20]
 8027068:	4402      	add	r2, r0
 802706a:	9205      	str	r2, [sp, #20]
 802706c:	9812      	ldr	r0, [sp, #72]	; 0x48
 802706e:	9a07      	ldr	r2, [sp, #28]
 8027070:	4402      	add	r2, r0
 8027072:	9207      	str	r2, [sp, #28]
 8027074:	9816      	ldr	r0, [sp, #88]	; 0x58
 8027076:	9a06      	ldr	r2, [sp, #24]
 8027078:	4402      	add	r2, r0
 802707a:	9206      	str	r2, [sp, #24]
 802707c:	9a15      	ldr	r2, [sp, #84]	; 0x54
 802707e:	4496      	add	lr, r2
 8027080:	9a14      	ldr	r2, [sp, #80]	; 0x50
 8027082:	4494      	add	ip, r2
 8027084:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
 8027086:	3208      	adds	r2, #8
 8027088:	920f      	str	r2, [sp, #60]	; 0x3c
 802708a:	9a0e      	ldr	r2, [sp, #56]	; 0x38
 802708c:	3208      	adds	r2, #8
 802708e:	920e      	str	r2, [sp, #56]	; 0x38
 8027090:	9a0d      	ldr	r2, [sp, #52]	; 0x34
 8027092:	3208      	adds	r2, #8
 8027094:	920d      	str	r2, [sp, #52]	; 0x34
 8027096:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 8027098:	3208      	adds	r2, #8
 802709a:	920c      	str	r2, [sp, #48]	; 0x30
 802709c:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 802709e:	3208      	adds	r2, #8
 80270a0:	920b      	str	r2, [sp, #44]	; 0x2c
 80270a2:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 80270a4:	3208      	adds	r2, #8
 80270a6:	920a      	str	r2, [sp, #40]	; 0x28
 80270a8:	9a09      	ldr	r2, [sp, #36]	; 0x24
 80270aa:	3208      	adds	r2, #8
 80270ac:	9209      	str	r2, [sp, #36]	; 0x24
 80270ae:	9a08      	ldr	r2, [sp, #32]
 80270b0:	3208      	adds	r2, #8
 80270b2:	9208      	str	r2, [sp, #32]
 80270b4:	9c10      	ldr	r4, [sp, #64]	; 0x40
 80270b6:	9811      	ldr	r0, [sp, #68]	; 0x44
 80270b8:	4288      	cmp	r0, r1
 80270ba:	4622      	mov	r2, r4
 80270bc:	d007      	beq.n	80270ce <arm_radix8_butterfly_f32+0x5ce>
 80270be:	9817      	ldr	r0, [sp, #92]	; 0x5c
 80270c0:	f8dd 900c 	ldr.w	r9, [sp, #12]
 80270c4:	4621      	mov	r1, r4
 80270c6:	4401      	add	r1, r0
 80270c8:	9110      	str	r1, [sp, #64]	; 0x40
 80270ca:	9804      	ldr	r0, [sp, #16]
 80270cc:	e67c      	b.n	8026dc8 <arm_radix8_butterfly_f32+0x2c8>
 80270ce:	4683      	mov	fp, r0
 80270d0:	f8bd 905c 	ldrh.w	r9, [sp, #92]	; 0x5c
 80270d4:	9f19      	ldr	r7, [sp, #100]	; 0x64
 80270d6:	e524      	b.n	8026b22 <arm_radix8_butterfly_f32+0x22>
 80270d8:	b01d      	add	sp, #116	; 0x74
 80270da:	ecbd 8b10 	vpop	{d8-d15}
 80270de:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80270e2:	bf00      	nop

080270e4 <__aeabi_memclr>:
 80270e4:	2200      	movs	r2, #0
 80270e6:	f7e3 b96d 	b.w	800a3c4 <__aeabi_memset>

080270ea <__aeabi_memcpy>:
 80270ea:	f000 ba1d 	b.w	8027528 <memcpy>

080270ee <atoi>:
 80270ee:	220a      	movs	r2, #10
 80270f0:	2100      	movs	r1, #0
 80270f2:	f001 b953 	b.w	802839c <strtol>
	...

080270f8 <__errno>:
 80270f8:	4b01      	ldr	r3, [pc, #4]	; (8027100 <__errno+0x8>)
 80270fa:	6818      	ldr	r0, [r3, #0]
 80270fc:	4770      	bx	lr
 80270fe:	bf00      	nop
 8027100:	20002020 	.word	0x20002020

08027104 <__sflush_r>:
 8027104:	898a      	ldrh	r2, [r1, #12]
 8027106:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 802710a:	4605      	mov	r5, r0
 802710c:	0710      	lsls	r0, r2, #28
 802710e:	460c      	mov	r4, r1
 8027110:	d458      	bmi.n	80271c4 <__sflush_r+0xc0>
 8027112:	684b      	ldr	r3, [r1, #4]
 8027114:	2b00      	cmp	r3, #0
 8027116:	dc05      	bgt.n	8027124 <__sflush_r+0x20>
 8027118:	6c0b      	ldr	r3, [r1, #64]	; 0x40
 802711a:	2b00      	cmp	r3, #0
 802711c:	dc02      	bgt.n	8027124 <__sflush_r+0x20>
 802711e:	2000      	movs	r0, #0
 8027120:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8027124:	6ae6      	ldr	r6, [r4, #44]	; 0x2c
 8027126:	2e00      	cmp	r6, #0
 8027128:	d0f9      	beq.n	802711e <__sflush_r+0x1a>
 802712a:	2300      	movs	r3, #0
 802712c:	f412 5280 	ands.w	r2, r2, #4096	; 0x1000
 8027130:	682f      	ldr	r7, [r5, #0]
 8027132:	602b      	str	r3, [r5, #0]
 8027134:	d032      	beq.n	802719c <__sflush_r+0x98>
 8027136:	6d60      	ldr	r0, [r4, #84]	; 0x54
 8027138:	89a3      	ldrh	r3, [r4, #12]
 802713a:	075a      	lsls	r2, r3, #29
 802713c:	d505      	bpl.n	802714a <__sflush_r+0x46>
 802713e:	6863      	ldr	r3, [r4, #4]
 8027140:	1ac0      	subs	r0, r0, r3
 8027142:	6b63      	ldr	r3, [r4, #52]	; 0x34
 8027144:	b10b      	cbz	r3, 802714a <__sflush_r+0x46>
 8027146:	6c23      	ldr	r3, [r4, #64]	; 0x40
 8027148:	1ac0      	subs	r0, r0, r3
 802714a:	2300      	movs	r3, #0
 802714c:	4602      	mov	r2, r0
 802714e:	6ae6      	ldr	r6, [r4, #44]	; 0x2c
 8027150:	6a21      	ldr	r1, [r4, #32]
 8027152:	4628      	mov	r0, r5
 8027154:	47b0      	blx	r6
 8027156:	1c43      	adds	r3, r0, #1
 8027158:	89a3      	ldrh	r3, [r4, #12]
 802715a:	d106      	bne.n	802716a <__sflush_r+0x66>
 802715c:	6829      	ldr	r1, [r5, #0]
 802715e:	291d      	cmp	r1, #29
 8027160:	d82c      	bhi.n	80271bc <__sflush_r+0xb8>
 8027162:	4a2a      	ldr	r2, [pc, #168]	; (802720c <__sflush_r+0x108>)
 8027164:	40ca      	lsrs	r2, r1
 8027166:	07d6      	lsls	r6, r2, #31
 8027168:	d528      	bpl.n	80271bc <__sflush_r+0xb8>
 802716a:	2200      	movs	r2, #0
 802716c:	6062      	str	r2, [r4, #4]
 802716e:	04d9      	lsls	r1, r3, #19
 8027170:	6922      	ldr	r2, [r4, #16]
 8027172:	6022      	str	r2, [r4, #0]
 8027174:	d504      	bpl.n	8027180 <__sflush_r+0x7c>
 8027176:	1c42      	adds	r2, r0, #1
 8027178:	d101      	bne.n	802717e <__sflush_r+0x7a>
 802717a:	682b      	ldr	r3, [r5, #0]
 802717c:	b903      	cbnz	r3, 8027180 <__sflush_r+0x7c>
 802717e:	6560      	str	r0, [r4, #84]	; 0x54
 8027180:	6b61      	ldr	r1, [r4, #52]	; 0x34
 8027182:	602f      	str	r7, [r5, #0]
 8027184:	2900      	cmp	r1, #0
 8027186:	d0ca      	beq.n	802711e <__sflush_r+0x1a>
 8027188:	f104 0344 	add.w	r3, r4, #68	; 0x44
 802718c:	4299      	cmp	r1, r3
 802718e:	d002      	beq.n	8027196 <__sflush_r+0x92>
 8027190:	4628      	mov	r0, r5
 8027192:	f000 f9f9 	bl	8027588 <_free_r>
 8027196:	2000      	movs	r0, #0
 8027198:	6360      	str	r0, [r4, #52]	; 0x34
 802719a:	e7c1      	b.n	8027120 <__sflush_r+0x1c>
 802719c:	6a21      	ldr	r1, [r4, #32]
 802719e:	2301      	movs	r3, #1
 80271a0:	4628      	mov	r0, r5
 80271a2:	47b0      	blx	r6
 80271a4:	1c41      	adds	r1, r0, #1
 80271a6:	d1c7      	bne.n	8027138 <__sflush_r+0x34>
 80271a8:	682b      	ldr	r3, [r5, #0]
 80271aa:	2b00      	cmp	r3, #0
 80271ac:	d0c4      	beq.n	8027138 <__sflush_r+0x34>
 80271ae:	2b1d      	cmp	r3, #29
 80271b0:	d001      	beq.n	80271b6 <__sflush_r+0xb2>
 80271b2:	2b16      	cmp	r3, #22
 80271b4:	d101      	bne.n	80271ba <__sflush_r+0xb6>
 80271b6:	602f      	str	r7, [r5, #0]
 80271b8:	e7b1      	b.n	802711e <__sflush_r+0x1a>
 80271ba:	89a3      	ldrh	r3, [r4, #12]
 80271bc:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 80271c0:	81a3      	strh	r3, [r4, #12]
 80271c2:	e7ad      	b.n	8027120 <__sflush_r+0x1c>
 80271c4:	690f      	ldr	r7, [r1, #16]
 80271c6:	2f00      	cmp	r7, #0
 80271c8:	d0a9      	beq.n	802711e <__sflush_r+0x1a>
 80271ca:	0793      	lsls	r3, r2, #30
 80271cc:	680e      	ldr	r6, [r1, #0]
 80271ce:	bf08      	it	eq
 80271d0:	694b      	ldreq	r3, [r1, #20]
 80271d2:	600f      	str	r7, [r1, #0]
 80271d4:	bf18      	it	ne
 80271d6:	2300      	movne	r3, #0
 80271d8:	eba6 0807 	sub.w	r8, r6, r7
 80271dc:	608b      	str	r3, [r1, #8]
 80271de:	f1b8 0f00 	cmp.w	r8, #0
 80271e2:	dd9c      	ble.n	802711e <__sflush_r+0x1a>
 80271e4:	6a21      	ldr	r1, [r4, #32]
 80271e6:	6aa6      	ldr	r6, [r4, #40]	; 0x28
 80271e8:	4643      	mov	r3, r8
 80271ea:	463a      	mov	r2, r7
 80271ec:	4628      	mov	r0, r5
 80271ee:	47b0      	blx	r6
 80271f0:	2800      	cmp	r0, #0
 80271f2:	dc06      	bgt.n	8027202 <__sflush_r+0xfe>
 80271f4:	89a3      	ldrh	r3, [r4, #12]
 80271f6:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 80271fa:	81a3      	strh	r3, [r4, #12]
 80271fc:	f04f 30ff 	mov.w	r0, #4294967295
 8027200:	e78e      	b.n	8027120 <__sflush_r+0x1c>
 8027202:	4407      	add	r7, r0
 8027204:	eba8 0800 	sub.w	r8, r8, r0
 8027208:	e7e9      	b.n	80271de <__sflush_r+0xda>
 802720a:	bf00      	nop
 802720c:	20400001 	.word	0x20400001

08027210 <_fflush_r>:
 8027210:	b538      	push	{r3, r4, r5, lr}
 8027212:	690b      	ldr	r3, [r1, #16]
 8027214:	4605      	mov	r5, r0
 8027216:	460c      	mov	r4, r1
 8027218:	b913      	cbnz	r3, 8027220 <_fflush_r+0x10>
 802721a:	2500      	movs	r5, #0
 802721c:	4628      	mov	r0, r5
 802721e:	bd38      	pop	{r3, r4, r5, pc}
 8027220:	b118      	cbz	r0, 802722a <_fflush_r+0x1a>
 8027222:	6983      	ldr	r3, [r0, #24]
 8027224:	b90b      	cbnz	r3, 802722a <_fflush_r+0x1a>
 8027226:	f000 f899 	bl	802735c <__sinit>
 802722a:	4b14      	ldr	r3, [pc, #80]	; (802727c <_fflush_r+0x6c>)
 802722c:	429c      	cmp	r4, r3
 802722e:	d11b      	bne.n	8027268 <_fflush_r+0x58>
 8027230:	686c      	ldr	r4, [r5, #4]
 8027232:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 8027236:	2b00      	cmp	r3, #0
 8027238:	d0ef      	beq.n	802721a <_fflush_r+0xa>
 802723a:	6e62      	ldr	r2, [r4, #100]	; 0x64
 802723c:	07d0      	lsls	r0, r2, #31
 802723e:	d404      	bmi.n	802724a <_fflush_r+0x3a>
 8027240:	0599      	lsls	r1, r3, #22
 8027242:	d402      	bmi.n	802724a <_fflush_r+0x3a>
 8027244:	6da0      	ldr	r0, [r4, #88]	; 0x58
 8027246:	f000 f94c 	bl	80274e2 <__retarget_lock_acquire_recursive>
 802724a:	4628      	mov	r0, r5
 802724c:	4621      	mov	r1, r4
 802724e:	f7ff ff59 	bl	8027104 <__sflush_r>
 8027252:	6e63      	ldr	r3, [r4, #100]	; 0x64
 8027254:	07da      	lsls	r2, r3, #31
 8027256:	4605      	mov	r5, r0
 8027258:	d4e0      	bmi.n	802721c <_fflush_r+0xc>
 802725a:	89a3      	ldrh	r3, [r4, #12]
 802725c:	059b      	lsls	r3, r3, #22
 802725e:	d4dd      	bmi.n	802721c <_fflush_r+0xc>
 8027260:	6da0      	ldr	r0, [r4, #88]	; 0x58
 8027262:	f000 f93f 	bl	80274e4 <__retarget_lock_release_recursive>
 8027266:	e7d9      	b.n	802721c <_fflush_r+0xc>
 8027268:	4b05      	ldr	r3, [pc, #20]	; (8027280 <_fflush_r+0x70>)
 802726a:	429c      	cmp	r4, r3
 802726c:	d101      	bne.n	8027272 <_fflush_r+0x62>
 802726e:	68ac      	ldr	r4, [r5, #8]
 8027270:	e7df      	b.n	8027232 <_fflush_r+0x22>
 8027272:	4b04      	ldr	r3, [pc, #16]	; (8027284 <_fflush_r+0x74>)
 8027274:	429c      	cmp	r4, r3
 8027276:	bf08      	it	eq
 8027278:	68ec      	ldreq	r4, [r5, #12]
 802727a:	e7da      	b.n	8027232 <_fflush_r+0x22>
 802727c:	080579e4 	.word	0x080579e4
 8027280:	08057a04 	.word	0x08057a04
 8027284:	080579c4 	.word	0x080579c4

08027288 <fflush>:
 8027288:	4601      	mov	r1, r0
 802728a:	b920      	cbnz	r0, 8027296 <fflush+0xe>
 802728c:	4b04      	ldr	r3, [pc, #16]	; (80272a0 <fflush+0x18>)
 802728e:	4905      	ldr	r1, [pc, #20]	; (80272a4 <fflush+0x1c>)
 8027290:	6818      	ldr	r0, [r3, #0]
 8027292:	f000 b8e1 	b.w	8027458 <_fwalk_reent>
 8027296:	4b04      	ldr	r3, [pc, #16]	; (80272a8 <fflush+0x20>)
 8027298:	6818      	ldr	r0, [r3, #0]
 802729a:	f7ff bfb9 	b.w	8027210 <_fflush_r>
 802729e:	bf00      	nop
 80272a0:	08057a24 	.word	0x08057a24
 80272a4:	08027211 	.word	0x08027211
 80272a8:	20002020 	.word	0x20002020

080272ac <std>:
 80272ac:	2300      	movs	r3, #0
 80272ae:	b510      	push	{r4, lr}
 80272b0:	4604      	mov	r4, r0
 80272b2:	e9c0 3300 	strd	r3, r3, [r0]
 80272b6:	e9c0 3304 	strd	r3, r3, [r0, #16]
 80272ba:	6083      	str	r3, [r0, #8]
 80272bc:	8181      	strh	r1, [r0, #12]
 80272be:	6643      	str	r3, [r0, #100]	; 0x64
 80272c0:	81c2      	strh	r2, [r0, #14]
 80272c2:	6183      	str	r3, [r0, #24]
 80272c4:	4619      	mov	r1, r3
 80272c6:	2208      	movs	r2, #8
 80272c8:	305c      	adds	r0, #92	; 0x5c
 80272ca:	f000 f955 	bl	8027578 <memset>
 80272ce:	4b05      	ldr	r3, [pc, #20]	; (80272e4 <std+0x38>)
 80272d0:	6263      	str	r3, [r4, #36]	; 0x24
 80272d2:	4b05      	ldr	r3, [pc, #20]	; (80272e8 <std+0x3c>)
 80272d4:	62a3      	str	r3, [r4, #40]	; 0x28
 80272d6:	4b05      	ldr	r3, [pc, #20]	; (80272ec <std+0x40>)
 80272d8:	62e3      	str	r3, [r4, #44]	; 0x2c
 80272da:	4b05      	ldr	r3, [pc, #20]	; (80272f0 <std+0x44>)
 80272dc:	6224      	str	r4, [r4, #32]
 80272de:	6323      	str	r3, [r4, #48]	; 0x30
 80272e0:	bd10      	pop	{r4, pc}
 80272e2:	bf00      	nop
 80272e4:	080281c5 	.word	0x080281c5
 80272e8:	080281e7 	.word	0x080281e7
 80272ec:	0802821f 	.word	0x0802821f
 80272f0:	08028243 	.word	0x08028243

080272f4 <_cleanup_r>:
 80272f4:	4901      	ldr	r1, [pc, #4]	; (80272fc <_cleanup_r+0x8>)
 80272f6:	f000 b8af 	b.w	8027458 <_fwalk_reent>
 80272fa:	bf00      	nop
 80272fc:	08027211 	.word	0x08027211

08027300 <__sfmoreglue>:
 8027300:	b570      	push	{r4, r5, r6, lr}
 8027302:	2268      	movs	r2, #104	; 0x68
 8027304:	1e4d      	subs	r5, r1, #1
 8027306:	4355      	muls	r5, r2
 8027308:	460e      	mov	r6, r1
 802730a:	f105 0174 	add.w	r1, r5, #116	; 0x74
 802730e:	f000 f9a7 	bl	8027660 <_malloc_r>
 8027312:	4604      	mov	r4, r0
 8027314:	b140      	cbz	r0, 8027328 <__sfmoreglue+0x28>
 8027316:	2100      	movs	r1, #0
 8027318:	e9c0 1600 	strd	r1, r6, [r0]
 802731c:	300c      	adds	r0, #12
 802731e:	60a0      	str	r0, [r4, #8]
 8027320:	f105 0268 	add.w	r2, r5, #104	; 0x68
 8027324:	f000 f928 	bl	8027578 <memset>
 8027328:	4620      	mov	r0, r4
 802732a:	bd70      	pop	{r4, r5, r6, pc}

0802732c <__sfp_lock_acquire>:
 802732c:	4801      	ldr	r0, [pc, #4]	; (8027334 <__sfp_lock_acquire+0x8>)
 802732e:	f000 b8d8 	b.w	80274e2 <__retarget_lock_acquire_recursive>
 8027332:	bf00      	nop
 8027334:	20014fc1 	.word	0x20014fc1

08027338 <__sfp_lock_release>:
 8027338:	4801      	ldr	r0, [pc, #4]	; (8027340 <__sfp_lock_release+0x8>)
 802733a:	f000 b8d3 	b.w	80274e4 <__retarget_lock_release_recursive>
 802733e:	bf00      	nop
 8027340:	20014fc1 	.word	0x20014fc1

08027344 <__sinit_lock_acquire>:
 8027344:	4801      	ldr	r0, [pc, #4]	; (802734c <__sinit_lock_acquire+0x8>)
 8027346:	f000 b8cc 	b.w	80274e2 <__retarget_lock_acquire_recursive>
 802734a:	bf00      	nop
 802734c:	20014fc2 	.word	0x20014fc2

08027350 <__sinit_lock_release>:
 8027350:	4801      	ldr	r0, [pc, #4]	; (8027358 <__sinit_lock_release+0x8>)
 8027352:	f000 b8c7 	b.w	80274e4 <__retarget_lock_release_recursive>
 8027356:	bf00      	nop
 8027358:	20014fc2 	.word	0x20014fc2

0802735c <__sinit>:
 802735c:	b510      	push	{r4, lr}
 802735e:	4604      	mov	r4, r0
 8027360:	f7ff fff0 	bl	8027344 <__sinit_lock_acquire>
 8027364:	69a3      	ldr	r3, [r4, #24]
 8027366:	b11b      	cbz	r3, 8027370 <__sinit+0x14>
 8027368:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 802736c:	f7ff bff0 	b.w	8027350 <__sinit_lock_release>
 8027370:	e9c4 3312 	strd	r3, r3, [r4, #72]	; 0x48
 8027374:	6523      	str	r3, [r4, #80]	; 0x50
 8027376:	4b13      	ldr	r3, [pc, #76]	; (80273c4 <__sinit+0x68>)
 8027378:	4a13      	ldr	r2, [pc, #76]	; (80273c8 <__sinit+0x6c>)
 802737a:	681b      	ldr	r3, [r3, #0]
 802737c:	62a2      	str	r2, [r4, #40]	; 0x28
 802737e:	42a3      	cmp	r3, r4
 8027380:	bf04      	itt	eq
 8027382:	2301      	moveq	r3, #1
 8027384:	61a3      	streq	r3, [r4, #24]
 8027386:	4620      	mov	r0, r4
 8027388:	f000 f820 	bl	80273cc <__sfp>
 802738c:	6060      	str	r0, [r4, #4]
 802738e:	4620      	mov	r0, r4
 8027390:	f000 f81c 	bl	80273cc <__sfp>
 8027394:	60a0      	str	r0, [r4, #8]
 8027396:	4620      	mov	r0, r4
 8027398:	f000 f818 	bl	80273cc <__sfp>
 802739c:	2200      	movs	r2, #0
 802739e:	60e0      	str	r0, [r4, #12]
 80273a0:	2104      	movs	r1, #4
 80273a2:	6860      	ldr	r0, [r4, #4]
 80273a4:	f7ff ff82 	bl	80272ac <std>
 80273a8:	68a0      	ldr	r0, [r4, #8]
 80273aa:	2201      	movs	r2, #1
 80273ac:	2109      	movs	r1, #9
 80273ae:	f7ff ff7d 	bl	80272ac <std>
 80273b2:	68e0      	ldr	r0, [r4, #12]
 80273b4:	2202      	movs	r2, #2
 80273b6:	2112      	movs	r1, #18
 80273b8:	f7ff ff78 	bl	80272ac <std>
 80273bc:	2301      	movs	r3, #1
 80273be:	61a3      	str	r3, [r4, #24]
 80273c0:	e7d2      	b.n	8027368 <__sinit+0xc>
 80273c2:	bf00      	nop
 80273c4:	08057a24 	.word	0x08057a24
 80273c8:	080272f5 	.word	0x080272f5

080273cc <__sfp>:
 80273cc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80273ce:	4607      	mov	r7, r0
 80273d0:	f7ff ffac 	bl	802732c <__sfp_lock_acquire>
 80273d4:	4b1e      	ldr	r3, [pc, #120]	; (8027450 <__sfp+0x84>)
 80273d6:	681e      	ldr	r6, [r3, #0]
 80273d8:	69b3      	ldr	r3, [r6, #24]
 80273da:	b913      	cbnz	r3, 80273e2 <__sfp+0x16>
 80273dc:	4630      	mov	r0, r6
 80273de:	f7ff ffbd 	bl	802735c <__sinit>
 80273e2:	3648      	adds	r6, #72	; 0x48
 80273e4:	e9d6 3401 	ldrd	r3, r4, [r6, #4]
 80273e8:	3b01      	subs	r3, #1
 80273ea:	d503      	bpl.n	80273f4 <__sfp+0x28>
 80273ec:	6833      	ldr	r3, [r6, #0]
 80273ee:	b30b      	cbz	r3, 8027434 <__sfp+0x68>
 80273f0:	6836      	ldr	r6, [r6, #0]
 80273f2:	e7f7      	b.n	80273e4 <__sfp+0x18>
 80273f4:	f9b4 500c 	ldrsh.w	r5, [r4, #12]
 80273f8:	b9d5      	cbnz	r5, 8027430 <__sfp+0x64>
 80273fa:	4b16      	ldr	r3, [pc, #88]	; (8027454 <__sfp+0x88>)
 80273fc:	60e3      	str	r3, [r4, #12]
 80273fe:	f104 0058 	add.w	r0, r4, #88	; 0x58
 8027402:	6665      	str	r5, [r4, #100]	; 0x64
 8027404:	f000 f86c 	bl	80274e0 <__retarget_lock_init_recursive>
 8027408:	f7ff ff96 	bl	8027338 <__sfp_lock_release>
 802740c:	e9c4 5501 	strd	r5, r5, [r4, #4]
 8027410:	e9c4 5504 	strd	r5, r5, [r4, #16]
 8027414:	6025      	str	r5, [r4, #0]
 8027416:	61a5      	str	r5, [r4, #24]
 8027418:	2208      	movs	r2, #8
 802741a:	4629      	mov	r1, r5
 802741c:	f104 005c 	add.w	r0, r4, #92	; 0x5c
 8027420:	f000 f8aa 	bl	8027578 <memset>
 8027424:	e9c4 550d 	strd	r5, r5, [r4, #52]	; 0x34
 8027428:	e9c4 5512 	strd	r5, r5, [r4, #72]	; 0x48
 802742c:	4620      	mov	r0, r4
 802742e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8027430:	3468      	adds	r4, #104	; 0x68
 8027432:	e7d9      	b.n	80273e8 <__sfp+0x1c>
 8027434:	2104      	movs	r1, #4
 8027436:	4638      	mov	r0, r7
 8027438:	f7ff ff62 	bl	8027300 <__sfmoreglue>
 802743c:	4604      	mov	r4, r0
 802743e:	6030      	str	r0, [r6, #0]
 8027440:	2800      	cmp	r0, #0
 8027442:	d1d5      	bne.n	80273f0 <__sfp+0x24>
 8027444:	f7ff ff78 	bl	8027338 <__sfp_lock_release>
 8027448:	230c      	movs	r3, #12
 802744a:	603b      	str	r3, [r7, #0]
 802744c:	e7ee      	b.n	802742c <__sfp+0x60>
 802744e:	bf00      	nop
 8027450:	08057a24 	.word	0x08057a24
 8027454:	ffff0001 	.word	0xffff0001

08027458 <_fwalk_reent>:
 8027458:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 802745c:	4606      	mov	r6, r0
 802745e:	4688      	mov	r8, r1
 8027460:	f100 0448 	add.w	r4, r0, #72	; 0x48
 8027464:	2700      	movs	r7, #0
 8027466:	e9d4 9501 	ldrd	r9, r5, [r4, #4]
 802746a:	f1b9 0901 	subs.w	r9, r9, #1
 802746e:	d505      	bpl.n	802747c <_fwalk_reent+0x24>
 8027470:	6824      	ldr	r4, [r4, #0]
 8027472:	2c00      	cmp	r4, #0
 8027474:	d1f7      	bne.n	8027466 <_fwalk_reent+0xe>
 8027476:	4638      	mov	r0, r7
 8027478:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 802747c:	89ab      	ldrh	r3, [r5, #12]
 802747e:	2b01      	cmp	r3, #1
 8027480:	d907      	bls.n	8027492 <_fwalk_reent+0x3a>
 8027482:	f9b5 300e 	ldrsh.w	r3, [r5, #14]
 8027486:	3301      	adds	r3, #1
 8027488:	d003      	beq.n	8027492 <_fwalk_reent+0x3a>
 802748a:	4629      	mov	r1, r5
 802748c:	4630      	mov	r0, r6
 802748e:	47c0      	blx	r8
 8027490:	4307      	orrs	r7, r0
 8027492:	3568      	adds	r5, #104	; 0x68
 8027494:	e7e9      	b.n	802746a <_fwalk_reent+0x12>
	...

08027498 <__libc_init_array>:
 8027498:	b570      	push	{r4, r5, r6, lr}
 802749a:	4d0d      	ldr	r5, [pc, #52]	; (80274d0 <__libc_init_array+0x38>)
 802749c:	4c0d      	ldr	r4, [pc, #52]	; (80274d4 <__libc_init_array+0x3c>)
 802749e:	1b64      	subs	r4, r4, r5
 80274a0:	10a4      	asrs	r4, r4, #2
 80274a2:	2600      	movs	r6, #0
 80274a4:	42a6      	cmp	r6, r4
 80274a6:	d109      	bne.n	80274bc <__libc_init_array+0x24>
 80274a8:	4d0b      	ldr	r5, [pc, #44]	; (80274d8 <__libc_init_array+0x40>)
 80274aa:	4c0c      	ldr	r4, [pc, #48]	; (80274dc <__libc_init_array+0x44>)
 80274ac:	f005 ff0a 	bl	802d2c4 <_init>
 80274b0:	1b64      	subs	r4, r4, r5
 80274b2:	10a4      	asrs	r4, r4, #2
 80274b4:	2600      	movs	r6, #0
 80274b6:	42a6      	cmp	r6, r4
 80274b8:	d105      	bne.n	80274c6 <__libc_init_array+0x2e>
 80274ba:	bd70      	pop	{r4, r5, r6, pc}
 80274bc:	f855 3b04 	ldr.w	r3, [r5], #4
 80274c0:	4798      	blx	r3
 80274c2:	3601      	adds	r6, #1
 80274c4:	e7ee      	b.n	80274a4 <__libc_init_array+0xc>
 80274c6:	f855 3b04 	ldr.w	r3, [r5], #4
 80274ca:	4798      	blx	r3
 80274cc:	3601      	adds	r6, #1
 80274ce:	e7f2      	b.n	80274b6 <__libc_init_array+0x1e>
 80274d0:	080581d8 	.word	0x080581d8
 80274d4:	080581d8 	.word	0x080581d8
 80274d8:	080581d8 	.word	0x080581d8
 80274dc:	080581dc 	.word	0x080581dc

080274e0 <__retarget_lock_init_recursive>:
 80274e0:	4770      	bx	lr

080274e2 <__retarget_lock_acquire_recursive>:
 80274e2:	4770      	bx	lr

080274e4 <__retarget_lock_release_recursive>:
 80274e4:	4770      	bx	lr
	...

080274e8 <malloc>:
 80274e8:	4b02      	ldr	r3, [pc, #8]	; (80274f4 <malloc+0xc>)
 80274ea:	4601      	mov	r1, r0
 80274ec:	6818      	ldr	r0, [r3, #0]
 80274ee:	f000 b8b7 	b.w	8027660 <_malloc_r>
 80274f2:	bf00      	nop
 80274f4:	20002020 	.word	0x20002020

080274f8 <free>:
 80274f8:	4b02      	ldr	r3, [pc, #8]	; (8027504 <free+0xc>)
 80274fa:	4601      	mov	r1, r0
 80274fc:	6818      	ldr	r0, [r3, #0]
 80274fe:	f000 b843 	b.w	8027588 <_free_r>
 8027502:	bf00      	nop
 8027504:	20002020 	.word	0x20002020

08027508 <memcmp>:
 8027508:	b510      	push	{r4, lr}
 802750a:	3901      	subs	r1, #1
 802750c:	4402      	add	r2, r0
 802750e:	4290      	cmp	r0, r2
 8027510:	d101      	bne.n	8027516 <memcmp+0xe>
 8027512:	2000      	movs	r0, #0
 8027514:	e005      	b.n	8027522 <memcmp+0x1a>
 8027516:	7803      	ldrb	r3, [r0, #0]
 8027518:	f811 4f01 	ldrb.w	r4, [r1, #1]!
 802751c:	42a3      	cmp	r3, r4
 802751e:	d001      	beq.n	8027524 <memcmp+0x1c>
 8027520:	1b18      	subs	r0, r3, r4
 8027522:	bd10      	pop	{r4, pc}
 8027524:	3001      	adds	r0, #1
 8027526:	e7f2      	b.n	802750e <memcmp+0x6>

08027528 <memcpy>:
 8027528:	440a      	add	r2, r1
 802752a:	4291      	cmp	r1, r2
 802752c:	f100 33ff 	add.w	r3, r0, #4294967295
 8027530:	d100      	bne.n	8027534 <memcpy+0xc>
 8027532:	4770      	bx	lr
 8027534:	b510      	push	{r4, lr}
 8027536:	f811 4b01 	ldrb.w	r4, [r1], #1
 802753a:	f803 4f01 	strb.w	r4, [r3, #1]!
 802753e:	4291      	cmp	r1, r2
 8027540:	d1f9      	bne.n	8027536 <memcpy+0xe>
 8027542:	bd10      	pop	{r4, pc}

08027544 <memmove>:
 8027544:	4288      	cmp	r0, r1
 8027546:	b510      	push	{r4, lr}
 8027548:	eb01 0402 	add.w	r4, r1, r2
 802754c:	d902      	bls.n	8027554 <memmove+0x10>
 802754e:	4284      	cmp	r4, r0
 8027550:	4623      	mov	r3, r4
 8027552:	d807      	bhi.n	8027564 <memmove+0x20>
 8027554:	1e43      	subs	r3, r0, #1
 8027556:	42a1      	cmp	r1, r4
 8027558:	d008      	beq.n	802756c <memmove+0x28>
 802755a:	f811 2b01 	ldrb.w	r2, [r1], #1
 802755e:	f803 2f01 	strb.w	r2, [r3, #1]!
 8027562:	e7f8      	b.n	8027556 <memmove+0x12>
 8027564:	4402      	add	r2, r0
 8027566:	4601      	mov	r1, r0
 8027568:	428a      	cmp	r2, r1
 802756a:	d100      	bne.n	802756e <memmove+0x2a>
 802756c:	bd10      	pop	{r4, pc}
 802756e:	f813 4d01 	ldrb.w	r4, [r3, #-1]!
 8027572:	f802 4d01 	strb.w	r4, [r2, #-1]!
 8027576:	e7f7      	b.n	8027568 <memmove+0x24>

08027578 <memset>:
 8027578:	4402      	add	r2, r0
 802757a:	4603      	mov	r3, r0
 802757c:	4293      	cmp	r3, r2
 802757e:	d100      	bne.n	8027582 <memset+0xa>
 8027580:	4770      	bx	lr
 8027582:	f803 1b01 	strb.w	r1, [r3], #1
 8027586:	e7f9      	b.n	802757c <memset+0x4>

08027588 <_free_r>:
 8027588:	b537      	push	{r0, r1, r2, r4, r5, lr}
 802758a:	2900      	cmp	r1, #0
 802758c:	d044      	beq.n	8027618 <_free_r+0x90>
 802758e:	f851 3c04 	ldr.w	r3, [r1, #-4]
 8027592:	9001      	str	r0, [sp, #4]
 8027594:	2b00      	cmp	r3, #0
 8027596:	f1a1 0404 	sub.w	r4, r1, #4
 802759a:	bfb8      	it	lt
 802759c:	18e4      	addlt	r4, r4, r3
 802759e:	f001 fee1 	bl	8029364 <__malloc_lock>
 80275a2:	4a1e      	ldr	r2, [pc, #120]	; (802761c <_free_r+0x94>)
 80275a4:	9801      	ldr	r0, [sp, #4]
 80275a6:	6813      	ldr	r3, [r2, #0]
 80275a8:	b933      	cbnz	r3, 80275b8 <_free_r+0x30>
 80275aa:	6063      	str	r3, [r4, #4]
 80275ac:	6014      	str	r4, [r2, #0]
 80275ae:	b003      	add	sp, #12
 80275b0:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
 80275b4:	f001 bedc 	b.w	8029370 <__malloc_unlock>
 80275b8:	42a3      	cmp	r3, r4
 80275ba:	d908      	bls.n	80275ce <_free_r+0x46>
 80275bc:	6825      	ldr	r5, [r4, #0]
 80275be:	1961      	adds	r1, r4, r5
 80275c0:	428b      	cmp	r3, r1
 80275c2:	bf01      	itttt	eq
 80275c4:	6819      	ldreq	r1, [r3, #0]
 80275c6:	685b      	ldreq	r3, [r3, #4]
 80275c8:	1949      	addeq	r1, r1, r5
 80275ca:	6021      	streq	r1, [r4, #0]
 80275cc:	e7ed      	b.n	80275aa <_free_r+0x22>
 80275ce:	461a      	mov	r2, r3
 80275d0:	685b      	ldr	r3, [r3, #4]
 80275d2:	b10b      	cbz	r3, 80275d8 <_free_r+0x50>
 80275d4:	42a3      	cmp	r3, r4
 80275d6:	d9fa      	bls.n	80275ce <_free_r+0x46>
 80275d8:	6811      	ldr	r1, [r2, #0]
 80275da:	1855      	adds	r5, r2, r1
 80275dc:	42a5      	cmp	r5, r4
 80275de:	d10b      	bne.n	80275f8 <_free_r+0x70>
 80275e0:	6824      	ldr	r4, [r4, #0]
 80275e2:	4421      	add	r1, r4
 80275e4:	1854      	adds	r4, r2, r1
 80275e6:	42a3      	cmp	r3, r4
 80275e8:	6011      	str	r1, [r2, #0]
 80275ea:	d1e0      	bne.n	80275ae <_free_r+0x26>
 80275ec:	681c      	ldr	r4, [r3, #0]
 80275ee:	685b      	ldr	r3, [r3, #4]
 80275f0:	6053      	str	r3, [r2, #4]
 80275f2:	4421      	add	r1, r4
 80275f4:	6011      	str	r1, [r2, #0]
 80275f6:	e7da      	b.n	80275ae <_free_r+0x26>
 80275f8:	d902      	bls.n	8027600 <_free_r+0x78>
 80275fa:	230c      	movs	r3, #12
 80275fc:	6003      	str	r3, [r0, #0]
 80275fe:	e7d6      	b.n	80275ae <_free_r+0x26>
 8027600:	6825      	ldr	r5, [r4, #0]
 8027602:	1961      	adds	r1, r4, r5
 8027604:	428b      	cmp	r3, r1
 8027606:	bf04      	itt	eq
 8027608:	6819      	ldreq	r1, [r3, #0]
 802760a:	685b      	ldreq	r3, [r3, #4]
 802760c:	6063      	str	r3, [r4, #4]
 802760e:	bf04      	itt	eq
 8027610:	1949      	addeq	r1, r1, r5
 8027612:	6021      	streq	r1, [r4, #0]
 8027614:	6054      	str	r4, [r2, #4]
 8027616:	e7ca      	b.n	80275ae <_free_r+0x26>
 8027618:	b003      	add	sp, #12
 802761a:	bd30      	pop	{r4, r5, pc}
 802761c:	20014fc4 	.word	0x20014fc4

08027620 <sbrk_aligned>:
 8027620:	b570      	push	{r4, r5, r6, lr}
 8027622:	4e0e      	ldr	r6, [pc, #56]	; (802765c <sbrk_aligned+0x3c>)
 8027624:	460c      	mov	r4, r1
 8027626:	6831      	ldr	r1, [r6, #0]
 8027628:	4605      	mov	r5, r0
 802762a:	b911      	cbnz	r1, 8027632 <sbrk_aligned+0x12>
 802762c:	f000 fd9a 	bl	8028164 <_sbrk_r>
 8027630:	6030      	str	r0, [r6, #0]
 8027632:	4621      	mov	r1, r4
 8027634:	4628      	mov	r0, r5
 8027636:	f000 fd95 	bl	8028164 <_sbrk_r>
 802763a:	1c43      	adds	r3, r0, #1
 802763c:	d00a      	beq.n	8027654 <sbrk_aligned+0x34>
 802763e:	1cc4      	adds	r4, r0, #3
 8027640:	f024 0403 	bic.w	r4, r4, #3
 8027644:	42a0      	cmp	r0, r4
 8027646:	d007      	beq.n	8027658 <sbrk_aligned+0x38>
 8027648:	1a21      	subs	r1, r4, r0
 802764a:	4628      	mov	r0, r5
 802764c:	f000 fd8a 	bl	8028164 <_sbrk_r>
 8027650:	3001      	adds	r0, #1
 8027652:	d101      	bne.n	8027658 <sbrk_aligned+0x38>
 8027654:	f04f 34ff 	mov.w	r4, #4294967295
 8027658:	4620      	mov	r0, r4
 802765a:	bd70      	pop	{r4, r5, r6, pc}
 802765c:	20014fc8 	.word	0x20014fc8

08027660 <_malloc_r>:
 8027660:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8027664:	1ccd      	adds	r5, r1, #3
 8027666:	f025 0503 	bic.w	r5, r5, #3
 802766a:	3508      	adds	r5, #8
 802766c:	2d0c      	cmp	r5, #12
 802766e:	bf38      	it	cc
 8027670:	250c      	movcc	r5, #12
 8027672:	2d00      	cmp	r5, #0
 8027674:	4607      	mov	r7, r0
 8027676:	db01      	blt.n	802767c <_malloc_r+0x1c>
 8027678:	42a9      	cmp	r1, r5
 802767a:	d905      	bls.n	8027688 <_malloc_r+0x28>
 802767c:	230c      	movs	r3, #12
 802767e:	603b      	str	r3, [r7, #0]
 8027680:	2600      	movs	r6, #0
 8027682:	4630      	mov	r0, r6
 8027684:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8027688:	4e2e      	ldr	r6, [pc, #184]	; (8027744 <_malloc_r+0xe4>)
 802768a:	f001 fe6b 	bl	8029364 <__malloc_lock>
 802768e:	6833      	ldr	r3, [r6, #0]
 8027690:	461c      	mov	r4, r3
 8027692:	bb34      	cbnz	r4, 80276e2 <_malloc_r+0x82>
 8027694:	4629      	mov	r1, r5
 8027696:	4638      	mov	r0, r7
 8027698:	f7ff ffc2 	bl	8027620 <sbrk_aligned>
 802769c:	1c43      	adds	r3, r0, #1
 802769e:	4604      	mov	r4, r0
 80276a0:	d14d      	bne.n	802773e <_malloc_r+0xde>
 80276a2:	6834      	ldr	r4, [r6, #0]
 80276a4:	4626      	mov	r6, r4
 80276a6:	2e00      	cmp	r6, #0
 80276a8:	d140      	bne.n	802772c <_malloc_r+0xcc>
 80276aa:	6823      	ldr	r3, [r4, #0]
 80276ac:	4631      	mov	r1, r6
 80276ae:	4638      	mov	r0, r7
 80276b0:	eb04 0803 	add.w	r8, r4, r3
 80276b4:	f000 fd56 	bl	8028164 <_sbrk_r>
 80276b8:	4580      	cmp	r8, r0
 80276ba:	d13a      	bne.n	8027732 <_malloc_r+0xd2>
 80276bc:	6821      	ldr	r1, [r4, #0]
 80276be:	3503      	adds	r5, #3
 80276c0:	1a6d      	subs	r5, r5, r1
 80276c2:	f025 0503 	bic.w	r5, r5, #3
 80276c6:	3508      	adds	r5, #8
 80276c8:	2d0c      	cmp	r5, #12
 80276ca:	bf38      	it	cc
 80276cc:	250c      	movcc	r5, #12
 80276ce:	4629      	mov	r1, r5
 80276d0:	4638      	mov	r0, r7
 80276d2:	f7ff ffa5 	bl	8027620 <sbrk_aligned>
 80276d6:	3001      	adds	r0, #1
 80276d8:	d02b      	beq.n	8027732 <_malloc_r+0xd2>
 80276da:	6823      	ldr	r3, [r4, #0]
 80276dc:	442b      	add	r3, r5
 80276de:	6023      	str	r3, [r4, #0]
 80276e0:	e00e      	b.n	8027700 <_malloc_r+0xa0>
 80276e2:	6822      	ldr	r2, [r4, #0]
 80276e4:	1b52      	subs	r2, r2, r5
 80276e6:	d41e      	bmi.n	8027726 <_malloc_r+0xc6>
 80276e8:	2a0b      	cmp	r2, #11
 80276ea:	d916      	bls.n	802771a <_malloc_r+0xba>
 80276ec:	1961      	adds	r1, r4, r5
 80276ee:	42a3      	cmp	r3, r4
 80276f0:	6025      	str	r5, [r4, #0]
 80276f2:	bf18      	it	ne
 80276f4:	6059      	strne	r1, [r3, #4]
 80276f6:	6863      	ldr	r3, [r4, #4]
 80276f8:	bf08      	it	eq
 80276fa:	6031      	streq	r1, [r6, #0]
 80276fc:	5162      	str	r2, [r4, r5]
 80276fe:	604b      	str	r3, [r1, #4]
 8027700:	4638      	mov	r0, r7
 8027702:	f104 060b 	add.w	r6, r4, #11
 8027706:	f001 fe33 	bl	8029370 <__malloc_unlock>
 802770a:	f026 0607 	bic.w	r6, r6, #7
 802770e:	1d23      	adds	r3, r4, #4
 8027710:	1af2      	subs	r2, r6, r3
 8027712:	d0b6      	beq.n	8027682 <_malloc_r+0x22>
 8027714:	1b9b      	subs	r3, r3, r6
 8027716:	50a3      	str	r3, [r4, r2]
 8027718:	e7b3      	b.n	8027682 <_malloc_r+0x22>
 802771a:	6862      	ldr	r2, [r4, #4]
 802771c:	42a3      	cmp	r3, r4
 802771e:	bf0c      	ite	eq
 8027720:	6032      	streq	r2, [r6, #0]
 8027722:	605a      	strne	r2, [r3, #4]
 8027724:	e7ec      	b.n	8027700 <_malloc_r+0xa0>
 8027726:	4623      	mov	r3, r4
 8027728:	6864      	ldr	r4, [r4, #4]
 802772a:	e7b2      	b.n	8027692 <_malloc_r+0x32>
 802772c:	4634      	mov	r4, r6
 802772e:	6876      	ldr	r6, [r6, #4]
 8027730:	e7b9      	b.n	80276a6 <_malloc_r+0x46>
 8027732:	230c      	movs	r3, #12
 8027734:	603b      	str	r3, [r7, #0]
 8027736:	4638      	mov	r0, r7
 8027738:	f001 fe1a 	bl	8029370 <__malloc_unlock>
 802773c:	e7a1      	b.n	8027682 <_malloc_r+0x22>
 802773e:	6025      	str	r5, [r4, #0]
 8027740:	e7de      	b.n	8027700 <_malloc_r+0xa0>
 8027742:	bf00      	nop
 8027744:	20014fc4 	.word	0x20014fc4

08027748 <__cvt>:
 8027748:	e92d 47ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, lr}
 802774c:	ec55 4b10 	vmov	r4, r5, d0
 8027750:	2d00      	cmp	r5, #0
 8027752:	460e      	mov	r6, r1
 8027754:	4619      	mov	r1, r3
 8027756:	462b      	mov	r3, r5
 8027758:	bfbb      	ittet	lt
 802775a:	f105 4300 	addlt.w	r3, r5, #2147483648	; 0x80000000
 802775e:	461d      	movlt	r5, r3
 8027760:	2300      	movge	r3, #0
 8027762:	232d      	movlt	r3, #45	; 0x2d
 8027764:	700b      	strb	r3, [r1, #0]
 8027766:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8027768:	f8dd a030 	ldr.w	sl, [sp, #48]	; 0x30
 802776c:	4691      	mov	r9, r2
 802776e:	f023 0820 	bic.w	r8, r3, #32
 8027772:	bfbc      	itt	lt
 8027774:	4622      	movlt	r2, r4
 8027776:	4614      	movlt	r4, r2
 8027778:	f1b8 0f46 	cmp.w	r8, #70	; 0x46
 802777c:	d005      	beq.n	802778a <__cvt+0x42>
 802777e:	f1b8 0f45 	cmp.w	r8, #69	; 0x45
 8027782:	d100      	bne.n	8027786 <__cvt+0x3e>
 8027784:	3601      	adds	r6, #1
 8027786:	2102      	movs	r1, #2
 8027788:	e000      	b.n	802778c <__cvt+0x44>
 802778a:	2103      	movs	r1, #3
 802778c:	ab03      	add	r3, sp, #12
 802778e:	9301      	str	r3, [sp, #4]
 8027790:	ab02      	add	r3, sp, #8
 8027792:	9300      	str	r3, [sp, #0]
 8027794:	ec45 4b10 	vmov	d0, r4, r5
 8027798:	4653      	mov	r3, sl
 802779a:	4632      	mov	r2, r6
 802779c:	f000 ff78 	bl	8028690 <_dtoa_r>
 80277a0:	f1b8 0f47 	cmp.w	r8, #71	; 0x47
 80277a4:	4607      	mov	r7, r0
 80277a6:	d102      	bne.n	80277ae <__cvt+0x66>
 80277a8:	f019 0f01 	tst.w	r9, #1
 80277ac:	d022      	beq.n	80277f4 <__cvt+0xac>
 80277ae:	f1b8 0f46 	cmp.w	r8, #70	; 0x46
 80277b2:	eb07 0906 	add.w	r9, r7, r6
 80277b6:	d110      	bne.n	80277da <__cvt+0x92>
 80277b8:	783b      	ldrb	r3, [r7, #0]
 80277ba:	2b30      	cmp	r3, #48	; 0x30
 80277bc:	d10a      	bne.n	80277d4 <__cvt+0x8c>
 80277be:	2200      	movs	r2, #0
 80277c0:	2300      	movs	r3, #0
 80277c2:	4620      	mov	r0, r4
 80277c4:	4629      	mov	r1, r5
 80277c6:	f7e3 fad7 	bl	800ad78 <__aeabi_dcmpeq>
 80277ca:	b918      	cbnz	r0, 80277d4 <__cvt+0x8c>
 80277cc:	f1c6 0601 	rsb	r6, r6, #1
 80277d0:	f8ca 6000 	str.w	r6, [sl]
 80277d4:	f8da 3000 	ldr.w	r3, [sl]
 80277d8:	4499      	add	r9, r3
 80277da:	2200      	movs	r2, #0
 80277dc:	2300      	movs	r3, #0
 80277de:	4620      	mov	r0, r4
 80277e0:	4629      	mov	r1, r5
 80277e2:	f7e3 fac9 	bl	800ad78 <__aeabi_dcmpeq>
 80277e6:	b108      	cbz	r0, 80277ec <__cvt+0xa4>
 80277e8:	f8cd 900c 	str.w	r9, [sp, #12]
 80277ec:	2230      	movs	r2, #48	; 0x30
 80277ee:	9b03      	ldr	r3, [sp, #12]
 80277f0:	454b      	cmp	r3, r9
 80277f2:	d307      	bcc.n	8027804 <__cvt+0xbc>
 80277f4:	9b03      	ldr	r3, [sp, #12]
 80277f6:	9a0e      	ldr	r2, [sp, #56]	; 0x38
 80277f8:	1bdb      	subs	r3, r3, r7
 80277fa:	4638      	mov	r0, r7
 80277fc:	6013      	str	r3, [r2, #0]
 80277fe:	b004      	add	sp, #16
 8027800:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8027804:	1c59      	adds	r1, r3, #1
 8027806:	9103      	str	r1, [sp, #12]
 8027808:	701a      	strb	r2, [r3, #0]
 802780a:	e7f0      	b.n	80277ee <__cvt+0xa6>

0802780c <__exponent>:
 802780c:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 802780e:	4603      	mov	r3, r0
 8027810:	2900      	cmp	r1, #0
 8027812:	bfb8      	it	lt
 8027814:	4249      	neglt	r1, r1
 8027816:	f803 2b02 	strb.w	r2, [r3], #2
 802781a:	bfb4      	ite	lt
 802781c:	222d      	movlt	r2, #45	; 0x2d
 802781e:	222b      	movge	r2, #43	; 0x2b
 8027820:	2909      	cmp	r1, #9
 8027822:	7042      	strb	r2, [r0, #1]
 8027824:	dd2a      	ble.n	802787c <__exponent+0x70>
 8027826:	f10d 0407 	add.w	r4, sp, #7
 802782a:	46a4      	mov	ip, r4
 802782c:	270a      	movs	r7, #10
 802782e:	46a6      	mov	lr, r4
 8027830:	460a      	mov	r2, r1
 8027832:	fb91 f6f7 	sdiv	r6, r1, r7
 8027836:	fb07 1516 	mls	r5, r7, r6, r1
 802783a:	3530      	adds	r5, #48	; 0x30
 802783c:	2a63      	cmp	r2, #99	; 0x63
 802783e:	f104 34ff 	add.w	r4, r4, #4294967295
 8027842:	f80e 5c01 	strb.w	r5, [lr, #-1]
 8027846:	4631      	mov	r1, r6
 8027848:	dcf1      	bgt.n	802782e <__exponent+0x22>
 802784a:	3130      	adds	r1, #48	; 0x30
 802784c:	f1ae 0502 	sub.w	r5, lr, #2
 8027850:	f804 1c01 	strb.w	r1, [r4, #-1]
 8027854:	1c44      	adds	r4, r0, #1
 8027856:	4629      	mov	r1, r5
 8027858:	4561      	cmp	r1, ip
 802785a:	d30a      	bcc.n	8027872 <__exponent+0x66>
 802785c:	f10d 0209 	add.w	r2, sp, #9
 8027860:	eba2 020e 	sub.w	r2, r2, lr
 8027864:	4565      	cmp	r5, ip
 8027866:	bf88      	it	hi
 8027868:	2200      	movhi	r2, #0
 802786a:	4413      	add	r3, r2
 802786c:	1a18      	subs	r0, r3, r0
 802786e:	b003      	add	sp, #12
 8027870:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8027872:	f811 2b01 	ldrb.w	r2, [r1], #1
 8027876:	f804 2f01 	strb.w	r2, [r4, #1]!
 802787a:	e7ed      	b.n	8027858 <__exponent+0x4c>
 802787c:	2330      	movs	r3, #48	; 0x30
 802787e:	3130      	adds	r1, #48	; 0x30
 8027880:	7083      	strb	r3, [r0, #2]
 8027882:	70c1      	strb	r1, [r0, #3]
 8027884:	1d03      	adds	r3, r0, #4
 8027886:	e7f1      	b.n	802786c <__exponent+0x60>

08027888 <_printf_float>:
 8027888:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 802788c:	ed2d 8b02 	vpush	{d8}
 8027890:	b08d      	sub	sp, #52	; 0x34
 8027892:	460c      	mov	r4, r1
 8027894:	f8dd 8060 	ldr.w	r8, [sp, #96]	; 0x60
 8027898:	4616      	mov	r6, r2
 802789a:	461f      	mov	r7, r3
 802789c:	4605      	mov	r5, r0
 802789e:	f001 fce5 	bl	802926c <_localeconv_r>
 80278a2:	f8d0 a000 	ldr.w	sl, [r0]
 80278a6:	4650      	mov	r0, sl
 80278a8:	f7e2 fde3 	bl	800a472 <strlen>
 80278ac:	2300      	movs	r3, #0
 80278ae:	930a      	str	r3, [sp, #40]	; 0x28
 80278b0:	6823      	ldr	r3, [r4, #0]
 80278b2:	9305      	str	r3, [sp, #20]
 80278b4:	f8d8 3000 	ldr.w	r3, [r8]
 80278b8:	f894 b018 	ldrb.w	fp, [r4, #24]
 80278bc:	3307      	adds	r3, #7
 80278be:	f023 0307 	bic.w	r3, r3, #7
 80278c2:	f103 0208 	add.w	r2, r3, #8
 80278c6:	f8c8 2000 	str.w	r2, [r8]
 80278ca:	e9d3 2300 	ldrd	r2, r3, [r3]
 80278ce:	e9c4 2312 	strd	r2, r3, [r4, #72]	; 0x48
 80278d2:	e9d4 8912 	ldrd	r8, r9, [r4, #72]	; 0x48
 80278d6:	f029 4300 	bic.w	r3, r9, #2147483648	; 0x80000000
 80278da:	9307      	str	r3, [sp, #28]
 80278dc:	f8cd 8018 	str.w	r8, [sp, #24]
 80278e0:	ee08 0a10 	vmov	s16, r0
 80278e4:	4b9f      	ldr	r3, [pc, #636]	; (8027b64 <_printf_float+0x2dc>)
 80278e6:	e9dd 0106 	ldrd	r0, r1, [sp, #24]
 80278ea:	f04f 32ff 	mov.w	r2, #4294967295
 80278ee:	f7e3 fa75 	bl	800addc <__aeabi_dcmpun>
 80278f2:	bb88      	cbnz	r0, 8027958 <_printf_float+0xd0>
 80278f4:	e9dd 0106 	ldrd	r0, r1, [sp, #24]
 80278f8:	4b9a      	ldr	r3, [pc, #616]	; (8027b64 <_printf_float+0x2dc>)
 80278fa:	f04f 32ff 	mov.w	r2, #4294967295
 80278fe:	f7e3 fa4f 	bl	800ada0 <__aeabi_dcmple>
 8027902:	bb48      	cbnz	r0, 8027958 <_printf_float+0xd0>
 8027904:	2200      	movs	r2, #0
 8027906:	2300      	movs	r3, #0
 8027908:	4640      	mov	r0, r8
 802790a:	4649      	mov	r1, r9
 802790c:	f7e3 fa3e 	bl	800ad8c <__aeabi_dcmplt>
 8027910:	b110      	cbz	r0, 8027918 <_printf_float+0x90>
 8027912:	232d      	movs	r3, #45	; 0x2d
 8027914:	f884 3043 	strb.w	r3, [r4, #67]	; 0x43
 8027918:	4b93      	ldr	r3, [pc, #588]	; (8027b68 <_printf_float+0x2e0>)
 802791a:	4894      	ldr	r0, [pc, #592]	; (8027b6c <_printf_float+0x2e4>)
 802791c:	f1bb 0f47 	cmp.w	fp, #71	; 0x47
 8027920:	bf94      	ite	ls
 8027922:	4698      	movls	r8, r3
 8027924:	4680      	movhi	r8, r0
 8027926:	2303      	movs	r3, #3
 8027928:	6123      	str	r3, [r4, #16]
 802792a:	9b05      	ldr	r3, [sp, #20]
 802792c:	f023 0204 	bic.w	r2, r3, #4
 8027930:	6022      	str	r2, [r4, #0]
 8027932:	f04f 0900 	mov.w	r9, #0
 8027936:	9700      	str	r7, [sp, #0]
 8027938:	4633      	mov	r3, r6
 802793a:	aa0b      	add	r2, sp, #44	; 0x2c
 802793c:	4621      	mov	r1, r4
 802793e:	4628      	mov	r0, r5
 8027940:	f000 f9d8 	bl	8027cf4 <_printf_common>
 8027944:	3001      	adds	r0, #1
 8027946:	f040 8090 	bne.w	8027a6a <_printf_float+0x1e2>
 802794a:	f04f 30ff 	mov.w	r0, #4294967295
 802794e:	b00d      	add	sp, #52	; 0x34
 8027950:	ecbd 8b02 	vpop	{d8}
 8027954:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8027958:	4642      	mov	r2, r8
 802795a:	464b      	mov	r3, r9
 802795c:	4640      	mov	r0, r8
 802795e:	4649      	mov	r1, r9
 8027960:	f7e3 fa3c 	bl	800addc <__aeabi_dcmpun>
 8027964:	b140      	cbz	r0, 8027978 <_printf_float+0xf0>
 8027966:	464b      	mov	r3, r9
 8027968:	2b00      	cmp	r3, #0
 802796a:	bfbc      	itt	lt
 802796c:	232d      	movlt	r3, #45	; 0x2d
 802796e:	f884 3043 	strblt.w	r3, [r4, #67]	; 0x43
 8027972:	487f      	ldr	r0, [pc, #508]	; (8027b70 <_printf_float+0x2e8>)
 8027974:	4b7f      	ldr	r3, [pc, #508]	; (8027b74 <_printf_float+0x2ec>)
 8027976:	e7d1      	b.n	802791c <_printf_float+0x94>
 8027978:	6863      	ldr	r3, [r4, #4]
 802797a:	f00b 02df 	and.w	r2, fp, #223	; 0xdf
 802797e:	9206      	str	r2, [sp, #24]
 8027980:	1c5a      	adds	r2, r3, #1
 8027982:	d13f      	bne.n	8027a04 <_printf_float+0x17c>
 8027984:	2306      	movs	r3, #6
 8027986:	6063      	str	r3, [r4, #4]
 8027988:	9b05      	ldr	r3, [sp, #20]
 802798a:	6861      	ldr	r1, [r4, #4]
 802798c:	f443 6280 	orr.w	r2, r3, #1024	; 0x400
 8027990:	2300      	movs	r3, #0
 8027992:	9303      	str	r3, [sp, #12]
 8027994:	ab0a      	add	r3, sp, #40	; 0x28
 8027996:	e9cd b301 	strd	fp, r3, [sp, #4]
 802799a:	ab09      	add	r3, sp, #36	; 0x24
 802799c:	ec49 8b10 	vmov	d0, r8, r9
 80279a0:	9300      	str	r3, [sp, #0]
 80279a2:	6022      	str	r2, [r4, #0]
 80279a4:	f10d 0323 	add.w	r3, sp, #35	; 0x23
 80279a8:	4628      	mov	r0, r5
 80279aa:	f7ff fecd 	bl	8027748 <__cvt>
 80279ae:	9b06      	ldr	r3, [sp, #24]
 80279b0:	9909      	ldr	r1, [sp, #36]	; 0x24
 80279b2:	2b47      	cmp	r3, #71	; 0x47
 80279b4:	4680      	mov	r8, r0
 80279b6:	d108      	bne.n	80279ca <_printf_float+0x142>
 80279b8:	1cc8      	adds	r0, r1, #3
 80279ba:	db02      	blt.n	80279c2 <_printf_float+0x13a>
 80279bc:	6863      	ldr	r3, [r4, #4]
 80279be:	4299      	cmp	r1, r3
 80279c0:	dd41      	ble.n	8027a46 <_printf_float+0x1be>
 80279c2:	f1ab 0b02 	sub.w	fp, fp, #2
 80279c6:	fa5f fb8b 	uxtb.w	fp, fp
 80279ca:	f1bb 0f65 	cmp.w	fp, #101	; 0x65
 80279ce:	d820      	bhi.n	8027a12 <_printf_float+0x18a>
 80279d0:	3901      	subs	r1, #1
 80279d2:	465a      	mov	r2, fp
 80279d4:	f104 0050 	add.w	r0, r4, #80	; 0x50
 80279d8:	9109      	str	r1, [sp, #36]	; 0x24
 80279da:	f7ff ff17 	bl	802780c <__exponent>
 80279de:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 80279e0:	1813      	adds	r3, r2, r0
 80279e2:	2a01      	cmp	r2, #1
 80279e4:	4681      	mov	r9, r0
 80279e6:	6123      	str	r3, [r4, #16]
 80279e8:	dc02      	bgt.n	80279f0 <_printf_float+0x168>
 80279ea:	6822      	ldr	r2, [r4, #0]
 80279ec:	07d2      	lsls	r2, r2, #31
 80279ee:	d501      	bpl.n	80279f4 <_printf_float+0x16c>
 80279f0:	3301      	adds	r3, #1
 80279f2:	6123      	str	r3, [r4, #16]
 80279f4:	f89d 3023 	ldrb.w	r3, [sp, #35]	; 0x23
 80279f8:	2b00      	cmp	r3, #0
 80279fa:	d09c      	beq.n	8027936 <_printf_float+0xae>
 80279fc:	232d      	movs	r3, #45	; 0x2d
 80279fe:	f884 3043 	strb.w	r3, [r4, #67]	; 0x43
 8027a02:	e798      	b.n	8027936 <_printf_float+0xae>
 8027a04:	9a06      	ldr	r2, [sp, #24]
 8027a06:	2a47      	cmp	r2, #71	; 0x47
 8027a08:	d1be      	bne.n	8027988 <_printf_float+0x100>
 8027a0a:	2b00      	cmp	r3, #0
 8027a0c:	d1bc      	bne.n	8027988 <_printf_float+0x100>
 8027a0e:	2301      	movs	r3, #1
 8027a10:	e7b9      	b.n	8027986 <_printf_float+0xfe>
 8027a12:	f1bb 0f66 	cmp.w	fp, #102	; 0x66
 8027a16:	d118      	bne.n	8027a4a <_printf_float+0x1c2>
 8027a18:	2900      	cmp	r1, #0
 8027a1a:	6863      	ldr	r3, [r4, #4]
 8027a1c:	dd0b      	ble.n	8027a36 <_printf_float+0x1ae>
 8027a1e:	6121      	str	r1, [r4, #16]
 8027a20:	b913      	cbnz	r3, 8027a28 <_printf_float+0x1a0>
 8027a22:	6822      	ldr	r2, [r4, #0]
 8027a24:	07d0      	lsls	r0, r2, #31
 8027a26:	d502      	bpl.n	8027a2e <_printf_float+0x1a6>
 8027a28:	3301      	adds	r3, #1
 8027a2a:	440b      	add	r3, r1
 8027a2c:	6123      	str	r3, [r4, #16]
 8027a2e:	65a1      	str	r1, [r4, #88]	; 0x58
 8027a30:	f04f 0900 	mov.w	r9, #0
 8027a34:	e7de      	b.n	80279f4 <_printf_float+0x16c>
 8027a36:	b913      	cbnz	r3, 8027a3e <_printf_float+0x1b6>
 8027a38:	6822      	ldr	r2, [r4, #0]
 8027a3a:	07d2      	lsls	r2, r2, #31
 8027a3c:	d501      	bpl.n	8027a42 <_printf_float+0x1ba>
 8027a3e:	3302      	adds	r3, #2
 8027a40:	e7f4      	b.n	8027a2c <_printf_float+0x1a4>
 8027a42:	2301      	movs	r3, #1
 8027a44:	e7f2      	b.n	8027a2c <_printf_float+0x1a4>
 8027a46:	f04f 0b67 	mov.w	fp, #103	; 0x67
 8027a4a:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8027a4c:	4299      	cmp	r1, r3
 8027a4e:	db05      	blt.n	8027a5c <_printf_float+0x1d4>
 8027a50:	6823      	ldr	r3, [r4, #0]
 8027a52:	6121      	str	r1, [r4, #16]
 8027a54:	07d8      	lsls	r0, r3, #31
 8027a56:	d5ea      	bpl.n	8027a2e <_printf_float+0x1a6>
 8027a58:	1c4b      	adds	r3, r1, #1
 8027a5a:	e7e7      	b.n	8027a2c <_printf_float+0x1a4>
 8027a5c:	2900      	cmp	r1, #0
 8027a5e:	bfd4      	ite	le
 8027a60:	f1c1 0202 	rsble	r2, r1, #2
 8027a64:	2201      	movgt	r2, #1
 8027a66:	4413      	add	r3, r2
 8027a68:	e7e0      	b.n	8027a2c <_printf_float+0x1a4>
 8027a6a:	6823      	ldr	r3, [r4, #0]
 8027a6c:	055a      	lsls	r2, r3, #21
 8027a6e:	d407      	bmi.n	8027a80 <_printf_float+0x1f8>
 8027a70:	6923      	ldr	r3, [r4, #16]
 8027a72:	4642      	mov	r2, r8
 8027a74:	4631      	mov	r1, r6
 8027a76:	4628      	mov	r0, r5
 8027a78:	47b8      	blx	r7
 8027a7a:	3001      	adds	r0, #1
 8027a7c:	d12c      	bne.n	8027ad8 <_printf_float+0x250>
 8027a7e:	e764      	b.n	802794a <_printf_float+0xc2>
 8027a80:	f1bb 0f65 	cmp.w	fp, #101	; 0x65
 8027a84:	f240 80e0 	bls.w	8027c48 <_printf_float+0x3c0>
 8027a88:	e9d4 0112 	ldrd	r0, r1, [r4, #72]	; 0x48
 8027a8c:	2200      	movs	r2, #0
 8027a8e:	2300      	movs	r3, #0
 8027a90:	f7e3 f972 	bl	800ad78 <__aeabi_dcmpeq>
 8027a94:	2800      	cmp	r0, #0
 8027a96:	d034      	beq.n	8027b02 <_printf_float+0x27a>
 8027a98:	4a37      	ldr	r2, [pc, #220]	; (8027b78 <_printf_float+0x2f0>)
 8027a9a:	2301      	movs	r3, #1
 8027a9c:	4631      	mov	r1, r6
 8027a9e:	4628      	mov	r0, r5
 8027aa0:	47b8      	blx	r7
 8027aa2:	3001      	adds	r0, #1
 8027aa4:	f43f af51 	beq.w	802794a <_printf_float+0xc2>
 8027aa8:	e9dd 2309 	ldrd	r2, r3, [sp, #36]	; 0x24
 8027aac:	429a      	cmp	r2, r3
 8027aae:	db02      	blt.n	8027ab6 <_printf_float+0x22e>
 8027ab0:	6823      	ldr	r3, [r4, #0]
 8027ab2:	07d8      	lsls	r0, r3, #31
 8027ab4:	d510      	bpl.n	8027ad8 <_printf_float+0x250>
 8027ab6:	ee18 3a10 	vmov	r3, s16
 8027aba:	4652      	mov	r2, sl
 8027abc:	4631      	mov	r1, r6
 8027abe:	4628      	mov	r0, r5
 8027ac0:	47b8      	blx	r7
 8027ac2:	3001      	adds	r0, #1
 8027ac4:	f43f af41 	beq.w	802794a <_printf_float+0xc2>
 8027ac8:	f04f 0800 	mov.w	r8, #0
 8027acc:	f104 091a 	add.w	r9, r4, #26
 8027ad0:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8027ad2:	3b01      	subs	r3, #1
 8027ad4:	4543      	cmp	r3, r8
 8027ad6:	dc09      	bgt.n	8027aec <_printf_float+0x264>
 8027ad8:	6823      	ldr	r3, [r4, #0]
 8027ada:	079b      	lsls	r3, r3, #30
 8027adc:	f100 8105 	bmi.w	8027cea <_printf_float+0x462>
 8027ae0:	68e0      	ldr	r0, [r4, #12]
 8027ae2:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8027ae4:	4298      	cmp	r0, r3
 8027ae6:	bfb8      	it	lt
 8027ae8:	4618      	movlt	r0, r3
 8027aea:	e730      	b.n	802794e <_printf_float+0xc6>
 8027aec:	2301      	movs	r3, #1
 8027aee:	464a      	mov	r2, r9
 8027af0:	4631      	mov	r1, r6
 8027af2:	4628      	mov	r0, r5
 8027af4:	47b8      	blx	r7
 8027af6:	3001      	adds	r0, #1
 8027af8:	f43f af27 	beq.w	802794a <_printf_float+0xc2>
 8027afc:	f108 0801 	add.w	r8, r8, #1
 8027b00:	e7e6      	b.n	8027ad0 <_printf_float+0x248>
 8027b02:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8027b04:	2b00      	cmp	r3, #0
 8027b06:	dc39      	bgt.n	8027b7c <_printf_float+0x2f4>
 8027b08:	4a1b      	ldr	r2, [pc, #108]	; (8027b78 <_printf_float+0x2f0>)
 8027b0a:	2301      	movs	r3, #1
 8027b0c:	4631      	mov	r1, r6
 8027b0e:	4628      	mov	r0, r5
 8027b10:	47b8      	blx	r7
 8027b12:	3001      	adds	r0, #1
 8027b14:	f43f af19 	beq.w	802794a <_printf_float+0xc2>
 8027b18:	e9dd 2309 	ldrd	r2, r3, [sp, #36]	; 0x24
 8027b1c:	4313      	orrs	r3, r2
 8027b1e:	d102      	bne.n	8027b26 <_printf_float+0x29e>
 8027b20:	6823      	ldr	r3, [r4, #0]
 8027b22:	07d9      	lsls	r1, r3, #31
 8027b24:	d5d8      	bpl.n	8027ad8 <_printf_float+0x250>
 8027b26:	ee18 3a10 	vmov	r3, s16
 8027b2a:	4652      	mov	r2, sl
 8027b2c:	4631      	mov	r1, r6
 8027b2e:	4628      	mov	r0, r5
 8027b30:	47b8      	blx	r7
 8027b32:	3001      	adds	r0, #1
 8027b34:	f43f af09 	beq.w	802794a <_printf_float+0xc2>
 8027b38:	f04f 0900 	mov.w	r9, #0
 8027b3c:	f104 0a1a 	add.w	sl, r4, #26
 8027b40:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8027b42:	425b      	negs	r3, r3
 8027b44:	454b      	cmp	r3, r9
 8027b46:	dc01      	bgt.n	8027b4c <_printf_float+0x2c4>
 8027b48:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8027b4a:	e792      	b.n	8027a72 <_printf_float+0x1ea>
 8027b4c:	2301      	movs	r3, #1
 8027b4e:	4652      	mov	r2, sl
 8027b50:	4631      	mov	r1, r6
 8027b52:	4628      	mov	r0, r5
 8027b54:	47b8      	blx	r7
 8027b56:	3001      	adds	r0, #1
 8027b58:	f43f aef7 	beq.w	802794a <_printf_float+0xc2>
 8027b5c:	f109 0901 	add.w	r9, r9, #1
 8027b60:	e7ee      	b.n	8027b40 <_printf_float+0x2b8>
 8027b62:	bf00      	nop
 8027b64:	7fefffff 	.word	0x7fefffff
 8027b68:	08057a28 	.word	0x08057a28
 8027b6c:	08057a2c 	.word	0x08057a2c
 8027b70:	08057a34 	.word	0x08057a34
 8027b74:	08057a30 	.word	0x08057a30
 8027b78:	08057a38 	.word	0x08057a38
 8027b7c:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 8027b7e:	6da3      	ldr	r3, [r4, #88]	; 0x58
 8027b80:	429a      	cmp	r2, r3
 8027b82:	bfa8      	it	ge
 8027b84:	461a      	movge	r2, r3
 8027b86:	2a00      	cmp	r2, #0
 8027b88:	4691      	mov	r9, r2
 8027b8a:	dc37      	bgt.n	8027bfc <_printf_float+0x374>
 8027b8c:	f04f 0b00 	mov.w	fp, #0
 8027b90:	ea29 79e9 	bic.w	r9, r9, r9, asr #31
 8027b94:	f104 021a 	add.w	r2, r4, #26
 8027b98:	6da3      	ldr	r3, [r4, #88]	; 0x58
 8027b9a:	9305      	str	r3, [sp, #20]
 8027b9c:	eba3 0309 	sub.w	r3, r3, r9
 8027ba0:	455b      	cmp	r3, fp
 8027ba2:	dc33      	bgt.n	8027c0c <_printf_float+0x384>
 8027ba4:	e9dd 2309 	ldrd	r2, r3, [sp, #36]	; 0x24
 8027ba8:	429a      	cmp	r2, r3
 8027baa:	db3b      	blt.n	8027c24 <_printf_float+0x39c>
 8027bac:	6823      	ldr	r3, [r4, #0]
 8027bae:	07da      	lsls	r2, r3, #31
 8027bb0:	d438      	bmi.n	8027c24 <_printf_float+0x39c>
 8027bb2:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8027bb4:	9a05      	ldr	r2, [sp, #20]
 8027bb6:	9909      	ldr	r1, [sp, #36]	; 0x24
 8027bb8:	1a9a      	subs	r2, r3, r2
 8027bba:	eba3 0901 	sub.w	r9, r3, r1
 8027bbe:	4591      	cmp	r9, r2
 8027bc0:	bfa8      	it	ge
 8027bc2:	4691      	movge	r9, r2
 8027bc4:	f1b9 0f00 	cmp.w	r9, #0
 8027bc8:	dc35      	bgt.n	8027c36 <_printf_float+0x3ae>
 8027bca:	f04f 0800 	mov.w	r8, #0
 8027bce:	ea29 79e9 	bic.w	r9, r9, r9, asr #31
 8027bd2:	f104 0a1a 	add.w	sl, r4, #26
 8027bd6:	e9dd 2309 	ldrd	r2, r3, [sp, #36]	; 0x24
 8027bda:	1a9b      	subs	r3, r3, r2
 8027bdc:	eba3 0309 	sub.w	r3, r3, r9
 8027be0:	4543      	cmp	r3, r8
 8027be2:	f77f af79 	ble.w	8027ad8 <_printf_float+0x250>
 8027be6:	2301      	movs	r3, #1
 8027be8:	4652      	mov	r2, sl
 8027bea:	4631      	mov	r1, r6
 8027bec:	4628      	mov	r0, r5
 8027bee:	47b8      	blx	r7
 8027bf0:	3001      	adds	r0, #1
 8027bf2:	f43f aeaa 	beq.w	802794a <_printf_float+0xc2>
 8027bf6:	f108 0801 	add.w	r8, r8, #1
 8027bfa:	e7ec      	b.n	8027bd6 <_printf_float+0x34e>
 8027bfc:	4613      	mov	r3, r2
 8027bfe:	4631      	mov	r1, r6
 8027c00:	4642      	mov	r2, r8
 8027c02:	4628      	mov	r0, r5
 8027c04:	47b8      	blx	r7
 8027c06:	3001      	adds	r0, #1
 8027c08:	d1c0      	bne.n	8027b8c <_printf_float+0x304>
 8027c0a:	e69e      	b.n	802794a <_printf_float+0xc2>
 8027c0c:	2301      	movs	r3, #1
 8027c0e:	4631      	mov	r1, r6
 8027c10:	4628      	mov	r0, r5
 8027c12:	9205      	str	r2, [sp, #20]
 8027c14:	47b8      	blx	r7
 8027c16:	3001      	adds	r0, #1
 8027c18:	f43f ae97 	beq.w	802794a <_printf_float+0xc2>
 8027c1c:	9a05      	ldr	r2, [sp, #20]
 8027c1e:	f10b 0b01 	add.w	fp, fp, #1
 8027c22:	e7b9      	b.n	8027b98 <_printf_float+0x310>
 8027c24:	ee18 3a10 	vmov	r3, s16
 8027c28:	4652      	mov	r2, sl
 8027c2a:	4631      	mov	r1, r6
 8027c2c:	4628      	mov	r0, r5
 8027c2e:	47b8      	blx	r7
 8027c30:	3001      	adds	r0, #1
 8027c32:	d1be      	bne.n	8027bb2 <_printf_float+0x32a>
 8027c34:	e689      	b.n	802794a <_printf_float+0xc2>
 8027c36:	9a05      	ldr	r2, [sp, #20]
 8027c38:	464b      	mov	r3, r9
 8027c3a:	4442      	add	r2, r8
 8027c3c:	4631      	mov	r1, r6
 8027c3e:	4628      	mov	r0, r5
 8027c40:	47b8      	blx	r7
 8027c42:	3001      	adds	r0, #1
 8027c44:	d1c1      	bne.n	8027bca <_printf_float+0x342>
 8027c46:	e680      	b.n	802794a <_printf_float+0xc2>
 8027c48:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 8027c4a:	2a01      	cmp	r2, #1
 8027c4c:	dc01      	bgt.n	8027c52 <_printf_float+0x3ca>
 8027c4e:	07db      	lsls	r3, r3, #31
 8027c50:	d538      	bpl.n	8027cc4 <_printf_float+0x43c>
 8027c52:	2301      	movs	r3, #1
 8027c54:	4642      	mov	r2, r8
 8027c56:	4631      	mov	r1, r6
 8027c58:	4628      	mov	r0, r5
 8027c5a:	47b8      	blx	r7
 8027c5c:	3001      	adds	r0, #1
 8027c5e:	f43f ae74 	beq.w	802794a <_printf_float+0xc2>
 8027c62:	ee18 3a10 	vmov	r3, s16
 8027c66:	4652      	mov	r2, sl
 8027c68:	4631      	mov	r1, r6
 8027c6a:	4628      	mov	r0, r5
 8027c6c:	47b8      	blx	r7
 8027c6e:	3001      	adds	r0, #1
 8027c70:	f43f ae6b 	beq.w	802794a <_printf_float+0xc2>
 8027c74:	e9d4 0112 	ldrd	r0, r1, [r4, #72]	; 0x48
 8027c78:	2200      	movs	r2, #0
 8027c7a:	2300      	movs	r3, #0
 8027c7c:	f7e3 f87c 	bl	800ad78 <__aeabi_dcmpeq>
 8027c80:	b9d8      	cbnz	r0, 8027cba <_printf_float+0x432>
 8027c82:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8027c84:	f108 0201 	add.w	r2, r8, #1
 8027c88:	3b01      	subs	r3, #1
 8027c8a:	4631      	mov	r1, r6
 8027c8c:	4628      	mov	r0, r5
 8027c8e:	47b8      	blx	r7
 8027c90:	3001      	adds	r0, #1
 8027c92:	d10e      	bne.n	8027cb2 <_printf_float+0x42a>
 8027c94:	e659      	b.n	802794a <_printf_float+0xc2>
 8027c96:	2301      	movs	r3, #1
 8027c98:	4652      	mov	r2, sl
 8027c9a:	4631      	mov	r1, r6
 8027c9c:	4628      	mov	r0, r5
 8027c9e:	47b8      	blx	r7
 8027ca0:	3001      	adds	r0, #1
 8027ca2:	f43f ae52 	beq.w	802794a <_printf_float+0xc2>
 8027ca6:	f108 0801 	add.w	r8, r8, #1
 8027caa:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8027cac:	3b01      	subs	r3, #1
 8027cae:	4543      	cmp	r3, r8
 8027cb0:	dcf1      	bgt.n	8027c96 <_printf_float+0x40e>
 8027cb2:	464b      	mov	r3, r9
 8027cb4:	f104 0250 	add.w	r2, r4, #80	; 0x50
 8027cb8:	e6dc      	b.n	8027a74 <_printf_float+0x1ec>
 8027cba:	f04f 0800 	mov.w	r8, #0
 8027cbe:	f104 0a1a 	add.w	sl, r4, #26
 8027cc2:	e7f2      	b.n	8027caa <_printf_float+0x422>
 8027cc4:	2301      	movs	r3, #1
 8027cc6:	4642      	mov	r2, r8
 8027cc8:	e7df      	b.n	8027c8a <_printf_float+0x402>
 8027cca:	2301      	movs	r3, #1
 8027ccc:	464a      	mov	r2, r9
 8027cce:	4631      	mov	r1, r6
 8027cd0:	4628      	mov	r0, r5
 8027cd2:	47b8      	blx	r7
 8027cd4:	3001      	adds	r0, #1
 8027cd6:	f43f ae38 	beq.w	802794a <_printf_float+0xc2>
 8027cda:	f108 0801 	add.w	r8, r8, #1
 8027cde:	68e3      	ldr	r3, [r4, #12]
 8027ce0:	990b      	ldr	r1, [sp, #44]	; 0x2c
 8027ce2:	1a5b      	subs	r3, r3, r1
 8027ce4:	4543      	cmp	r3, r8
 8027ce6:	dcf0      	bgt.n	8027cca <_printf_float+0x442>
 8027ce8:	e6fa      	b.n	8027ae0 <_printf_float+0x258>
 8027cea:	f04f 0800 	mov.w	r8, #0
 8027cee:	f104 0919 	add.w	r9, r4, #25
 8027cf2:	e7f4      	b.n	8027cde <_printf_float+0x456>

08027cf4 <_printf_common>:
 8027cf4:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8027cf8:	4616      	mov	r6, r2
 8027cfa:	4699      	mov	r9, r3
 8027cfc:	688a      	ldr	r2, [r1, #8]
 8027cfe:	690b      	ldr	r3, [r1, #16]
 8027d00:	f8dd 8020 	ldr.w	r8, [sp, #32]
 8027d04:	4293      	cmp	r3, r2
 8027d06:	bfb8      	it	lt
 8027d08:	4613      	movlt	r3, r2
 8027d0a:	6033      	str	r3, [r6, #0]
 8027d0c:	f891 2043 	ldrb.w	r2, [r1, #67]	; 0x43
 8027d10:	4607      	mov	r7, r0
 8027d12:	460c      	mov	r4, r1
 8027d14:	b10a      	cbz	r2, 8027d1a <_printf_common+0x26>
 8027d16:	3301      	adds	r3, #1
 8027d18:	6033      	str	r3, [r6, #0]
 8027d1a:	6823      	ldr	r3, [r4, #0]
 8027d1c:	0699      	lsls	r1, r3, #26
 8027d1e:	bf42      	ittt	mi
 8027d20:	6833      	ldrmi	r3, [r6, #0]
 8027d22:	3302      	addmi	r3, #2
 8027d24:	6033      	strmi	r3, [r6, #0]
 8027d26:	6825      	ldr	r5, [r4, #0]
 8027d28:	f015 0506 	ands.w	r5, r5, #6
 8027d2c:	d106      	bne.n	8027d3c <_printf_common+0x48>
 8027d2e:	f104 0a19 	add.w	sl, r4, #25
 8027d32:	68e3      	ldr	r3, [r4, #12]
 8027d34:	6832      	ldr	r2, [r6, #0]
 8027d36:	1a9b      	subs	r3, r3, r2
 8027d38:	42ab      	cmp	r3, r5
 8027d3a:	dc26      	bgt.n	8027d8a <_printf_common+0x96>
 8027d3c:	f894 2043 	ldrb.w	r2, [r4, #67]	; 0x43
 8027d40:	1e13      	subs	r3, r2, #0
 8027d42:	6822      	ldr	r2, [r4, #0]
 8027d44:	bf18      	it	ne
 8027d46:	2301      	movne	r3, #1
 8027d48:	0692      	lsls	r2, r2, #26
 8027d4a:	d42b      	bmi.n	8027da4 <_printf_common+0xb0>
 8027d4c:	f104 0243 	add.w	r2, r4, #67	; 0x43
 8027d50:	4649      	mov	r1, r9
 8027d52:	4638      	mov	r0, r7
 8027d54:	47c0      	blx	r8
 8027d56:	3001      	adds	r0, #1
 8027d58:	d01e      	beq.n	8027d98 <_printf_common+0xa4>
 8027d5a:	6823      	ldr	r3, [r4, #0]
 8027d5c:	68e5      	ldr	r5, [r4, #12]
 8027d5e:	6832      	ldr	r2, [r6, #0]
 8027d60:	f003 0306 	and.w	r3, r3, #6
 8027d64:	2b04      	cmp	r3, #4
 8027d66:	bf08      	it	eq
 8027d68:	1aad      	subeq	r5, r5, r2
 8027d6a:	68a3      	ldr	r3, [r4, #8]
 8027d6c:	6922      	ldr	r2, [r4, #16]
 8027d6e:	bf0c      	ite	eq
 8027d70:	ea25 75e5 	biceq.w	r5, r5, r5, asr #31
 8027d74:	2500      	movne	r5, #0
 8027d76:	4293      	cmp	r3, r2
 8027d78:	bfc4      	itt	gt
 8027d7a:	1a9b      	subgt	r3, r3, r2
 8027d7c:	18ed      	addgt	r5, r5, r3
 8027d7e:	2600      	movs	r6, #0
 8027d80:	341a      	adds	r4, #26
 8027d82:	42b5      	cmp	r5, r6
 8027d84:	d11a      	bne.n	8027dbc <_printf_common+0xc8>
 8027d86:	2000      	movs	r0, #0
 8027d88:	e008      	b.n	8027d9c <_printf_common+0xa8>
 8027d8a:	2301      	movs	r3, #1
 8027d8c:	4652      	mov	r2, sl
 8027d8e:	4649      	mov	r1, r9
 8027d90:	4638      	mov	r0, r7
 8027d92:	47c0      	blx	r8
 8027d94:	3001      	adds	r0, #1
 8027d96:	d103      	bne.n	8027da0 <_printf_common+0xac>
 8027d98:	f04f 30ff 	mov.w	r0, #4294967295
 8027d9c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8027da0:	3501      	adds	r5, #1
 8027da2:	e7c6      	b.n	8027d32 <_printf_common+0x3e>
 8027da4:	18e1      	adds	r1, r4, r3
 8027da6:	1c5a      	adds	r2, r3, #1
 8027da8:	2030      	movs	r0, #48	; 0x30
 8027daa:	f881 0043 	strb.w	r0, [r1, #67]	; 0x43
 8027dae:	4422      	add	r2, r4
 8027db0:	f894 1045 	ldrb.w	r1, [r4, #69]	; 0x45
 8027db4:	f882 1043 	strb.w	r1, [r2, #67]	; 0x43
 8027db8:	3302      	adds	r3, #2
 8027dba:	e7c7      	b.n	8027d4c <_printf_common+0x58>
 8027dbc:	2301      	movs	r3, #1
 8027dbe:	4622      	mov	r2, r4
 8027dc0:	4649      	mov	r1, r9
 8027dc2:	4638      	mov	r0, r7
 8027dc4:	47c0      	blx	r8
 8027dc6:	3001      	adds	r0, #1
 8027dc8:	d0e6      	beq.n	8027d98 <_printf_common+0xa4>
 8027dca:	3601      	adds	r6, #1
 8027dcc:	e7d9      	b.n	8027d82 <_printf_common+0x8e>
	...

08027dd0 <_printf_i>:
 8027dd0:	e92d 47ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, lr}
 8027dd4:	7e0f      	ldrb	r7, [r1, #24]
 8027dd6:	9d0c      	ldr	r5, [sp, #48]	; 0x30
 8027dd8:	2f78      	cmp	r7, #120	; 0x78
 8027dda:	4691      	mov	r9, r2
 8027ddc:	4680      	mov	r8, r0
 8027dde:	460c      	mov	r4, r1
 8027de0:	469a      	mov	sl, r3
 8027de2:	f101 0243 	add.w	r2, r1, #67	; 0x43
 8027de6:	d807      	bhi.n	8027df8 <_printf_i+0x28>
 8027de8:	2f62      	cmp	r7, #98	; 0x62
 8027dea:	d80a      	bhi.n	8027e02 <_printf_i+0x32>
 8027dec:	2f00      	cmp	r7, #0
 8027dee:	f000 80d8 	beq.w	8027fa2 <_printf_i+0x1d2>
 8027df2:	2f58      	cmp	r7, #88	; 0x58
 8027df4:	f000 80a3 	beq.w	8027f3e <_printf_i+0x16e>
 8027df8:	f104 0542 	add.w	r5, r4, #66	; 0x42
 8027dfc:	f884 7042 	strb.w	r7, [r4, #66]	; 0x42
 8027e00:	e03a      	b.n	8027e78 <_printf_i+0xa8>
 8027e02:	f1a7 0363 	sub.w	r3, r7, #99	; 0x63
 8027e06:	2b15      	cmp	r3, #21
 8027e08:	d8f6      	bhi.n	8027df8 <_printf_i+0x28>
 8027e0a:	a101      	add	r1, pc, #4	; (adr r1, 8027e10 <_printf_i+0x40>)
 8027e0c:	f851 f023 	ldr.w	pc, [r1, r3, lsl #2]
 8027e10:	08027e69 	.word	0x08027e69
 8027e14:	08027e7d 	.word	0x08027e7d
 8027e18:	08027df9 	.word	0x08027df9
 8027e1c:	08027df9 	.word	0x08027df9
 8027e20:	08027df9 	.word	0x08027df9
 8027e24:	08027df9 	.word	0x08027df9
 8027e28:	08027e7d 	.word	0x08027e7d
 8027e2c:	08027df9 	.word	0x08027df9
 8027e30:	08027df9 	.word	0x08027df9
 8027e34:	08027df9 	.word	0x08027df9
 8027e38:	08027df9 	.word	0x08027df9
 8027e3c:	08027f89 	.word	0x08027f89
 8027e40:	08027ead 	.word	0x08027ead
 8027e44:	08027f6b 	.word	0x08027f6b
 8027e48:	08027df9 	.word	0x08027df9
 8027e4c:	08027df9 	.word	0x08027df9
 8027e50:	08027fab 	.word	0x08027fab
 8027e54:	08027df9 	.word	0x08027df9
 8027e58:	08027ead 	.word	0x08027ead
 8027e5c:	08027df9 	.word	0x08027df9
 8027e60:	08027df9 	.word	0x08027df9
 8027e64:	08027f73 	.word	0x08027f73
 8027e68:	682b      	ldr	r3, [r5, #0]
 8027e6a:	1d1a      	adds	r2, r3, #4
 8027e6c:	681b      	ldr	r3, [r3, #0]
 8027e6e:	602a      	str	r2, [r5, #0]
 8027e70:	f104 0542 	add.w	r5, r4, #66	; 0x42
 8027e74:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
 8027e78:	2301      	movs	r3, #1
 8027e7a:	e0a3      	b.n	8027fc4 <_printf_i+0x1f4>
 8027e7c:	6820      	ldr	r0, [r4, #0]
 8027e7e:	6829      	ldr	r1, [r5, #0]
 8027e80:	0606      	lsls	r6, r0, #24
 8027e82:	f101 0304 	add.w	r3, r1, #4
 8027e86:	d50a      	bpl.n	8027e9e <_printf_i+0xce>
 8027e88:	680e      	ldr	r6, [r1, #0]
 8027e8a:	602b      	str	r3, [r5, #0]
 8027e8c:	2e00      	cmp	r6, #0
 8027e8e:	da03      	bge.n	8027e98 <_printf_i+0xc8>
 8027e90:	232d      	movs	r3, #45	; 0x2d
 8027e92:	4276      	negs	r6, r6
 8027e94:	f884 3043 	strb.w	r3, [r4, #67]	; 0x43
 8027e98:	485e      	ldr	r0, [pc, #376]	; (8028014 <_printf_i+0x244>)
 8027e9a:	230a      	movs	r3, #10
 8027e9c:	e019      	b.n	8027ed2 <_printf_i+0x102>
 8027e9e:	680e      	ldr	r6, [r1, #0]
 8027ea0:	602b      	str	r3, [r5, #0]
 8027ea2:	f010 0f40 	tst.w	r0, #64	; 0x40
 8027ea6:	bf18      	it	ne
 8027ea8:	b236      	sxthne	r6, r6
 8027eaa:	e7ef      	b.n	8027e8c <_printf_i+0xbc>
 8027eac:	682b      	ldr	r3, [r5, #0]
 8027eae:	6820      	ldr	r0, [r4, #0]
 8027eb0:	1d19      	adds	r1, r3, #4
 8027eb2:	6029      	str	r1, [r5, #0]
 8027eb4:	0601      	lsls	r1, r0, #24
 8027eb6:	d501      	bpl.n	8027ebc <_printf_i+0xec>
 8027eb8:	681e      	ldr	r6, [r3, #0]
 8027eba:	e002      	b.n	8027ec2 <_printf_i+0xf2>
 8027ebc:	0646      	lsls	r6, r0, #25
 8027ebe:	d5fb      	bpl.n	8027eb8 <_printf_i+0xe8>
 8027ec0:	881e      	ldrh	r6, [r3, #0]
 8027ec2:	4854      	ldr	r0, [pc, #336]	; (8028014 <_printf_i+0x244>)
 8027ec4:	2f6f      	cmp	r7, #111	; 0x6f
 8027ec6:	bf0c      	ite	eq
 8027ec8:	2308      	moveq	r3, #8
 8027eca:	230a      	movne	r3, #10
 8027ecc:	2100      	movs	r1, #0
 8027ece:	f884 1043 	strb.w	r1, [r4, #67]	; 0x43
 8027ed2:	6865      	ldr	r5, [r4, #4]
 8027ed4:	60a5      	str	r5, [r4, #8]
 8027ed6:	2d00      	cmp	r5, #0
 8027ed8:	bfa2      	ittt	ge
 8027eda:	6821      	ldrge	r1, [r4, #0]
 8027edc:	f021 0104 	bicge.w	r1, r1, #4
 8027ee0:	6021      	strge	r1, [r4, #0]
 8027ee2:	b90e      	cbnz	r6, 8027ee8 <_printf_i+0x118>
 8027ee4:	2d00      	cmp	r5, #0
 8027ee6:	d04d      	beq.n	8027f84 <_printf_i+0x1b4>
 8027ee8:	4615      	mov	r5, r2
 8027eea:	fbb6 f1f3 	udiv	r1, r6, r3
 8027eee:	fb03 6711 	mls	r7, r3, r1, r6
 8027ef2:	5dc7      	ldrb	r7, [r0, r7]
 8027ef4:	f805 7d01 	strb.w	r7, [r5, #-1]!
 8027ef8:	4637      	mov	r7, r6
 8027efa:	42bb      	cmp	r3, r7
 8027efc:	460e      	mov	r6, r1
 8027efe:	d9f4      	bls.n	8027eea <_printf_i+0x11a>
 8027f00:	2b08      	cmp	r3, #8
 8027f02:	d10b      	bne.n	8027f1c <_printf_i+0x14c>
 8027f04:	6823      	ldr	r3, [r4, #0]
 8027f06:	07de      	lsls	r6, r3, #31
 8027f08:	d508      	bpl.n	8027f1c <_printf_i+0x14c>
 8027f0a:	6923      	ldr	r3, [r4, #16]
 8027f0c:	6861      	ldr	r1, [r4, #4]
 8027f0e:	4299      	cmp	r1, r3
 8027f10:	bfde      	ittt	le
 8027f12:	2330      	movle	r3, #48	; 0x30
 8027f14:	f805 3c01 	strble.w	r3, [r5, #-1]
 8027f18:	f105 35ff 	addle.w	r5, r5, #4294967295
 8027f1c:	1b52      	subs	r2, r2, r5
 8027f1e:	6122      	str	r2, [r4, #16]
 8027f20:	f8cd a000 	str.w	sl, [sp]
 8027f24:	464b      	mov	r3, r9
 8027f26:	aa03      	add	r2, sp, #12
 8027f28:	4621      	mov	r1, r4
 8027f2a:	4640      	mov	r0, r8
 8027f2c:	f7ff fee2 	bl	8027cf4 <_printf_common>
 8027f30:	3001      	adds	r0, #1
 8027f32:	d14c      	bne.n	8027fce <_printf_i+0x1fe>
 8027f34:	f04f 30ff 	mov.w	r0, #4294967295
 8027f38:	b004      	add	sp, #16
 8027f3a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8027f3e:	4835      	ldr	r0, [pc, #212]	; (8028014 <_printf_i+0x244>)
 8027f40:	f881 7045 	strb.w	r7, [r1, #69]	; 0x45
 8027f44:	6829      	ldr	r1, [r5, #0]
 8027f46:	6823      	ldr	r3, [r4, #0]
 8027f48:	f851 6b04 	ldr.w	r6, [r1], #4
 8027f4c:	6029      	str	r1, [r5, #0]
 8027f4e:	061d      	lsls	r5, r3, #24
 8027f50:	d514      	bpl.n	8027f7c <_printf_i+0x1ac>
 8027f52:	07df      	lsls	r7, r3, #31
 8027f54:	bf44      	itt	mi
 8027f56:	f043 0320 	orrmi.w	r3, r3, #32
 8027f5a:	6023      	strmi	r3, [r4, #0]
 8027f5c:	b91e      	cbnz	r6, 8027f66 <_printf_i+0x196>
 8027f5e:	6823      	ldr	r3, [r4, #0]
 8027f60:	f023 0320 	bic.w	r3, r3, #32
 8027f64:	6023      	str	r3, [r4, #0]
 8027f66:	2310      	movs	r3, #16
 8027f68:	e7b0      	b.n	8027ecc <_printf_i+0xfc>
 8027f6a:	6823      	ldr	r3, [r4, #0]
 8027f6c:	f043 0320 	orr.w	r3, r3, #32
 8027f70:	6023      	str	r3, [r4, #0]
 8027f72:	2378      	movs	r3, #120	; 0x78
 8027f74:	4828      	ldr	r0, [pc, #160]	; (8028018 <_printf_i+0x248>)
 8027f76:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
 8027f7a:	e7e3      	b.n	8027f44 <_printf_i+0x174>
 8027f7c:	0659      	lsls	r1, r3, #25
 8027f7e:	bf48      	it	mi
 8027f80:	b2b6      	uxthmi	r6, r6
 8027f82:	e7e6      	b.n	8027f52 <_printf_i+0x182>
 8027f84:	4615      	mov	r5, r2
 8027f86:	e7bb      	b.n	8027f00 <_printf_i+0x130>
 8027f88:	682b      	ldr	r3, [r5, #0]
 8027f8a:	6826      	ldr	r6, [r4, #0]
 8027f8c:	6961      	ldr	r1, [r4, #20]
 8027f8e:	1d18      	adds	r0, r3, #4
 8027f90:	6028      	str	r0, [r5, #0]
 8027f92:	0635      	lsls	r5, r6, #24
 8027f94:	681b      	ldr	r3, [r3, #0]
 8027f96:	d501      	bpl.n	8027f9c <_printf_i+0x1cc>
 8027f98:	6019      	str	r1, [r3, #0]
 8027f9a:	e002      	b.n	8027fa2 <_printf_i+0x1d2>
 8027f9c:	0670      	lsls	r0, r6, #25
 8027f9e:	d5fb      	bpl.n	8027f98 <_printf_i+0x1c8>
 8027fa0:	8019      	strh	r1, [r3, #0]
 8027fa2:	2300      	movs	r3, #0
 8027fa4:	6123      	str	r3, [r4, #16]
 8027fa6:	4615      	mov	r5, r2
 8027fa8:	e7ba      	b.n	8027f20 <_printf_i+0x150>
 8027faa:	682b      	ldr	r3, [r5, #0]
 8027fac:	1d1a      	adds	r2, r3, #4
 8027fae:	602a      	str	r2, [r5, #0]
 8027fb0:	681d      	ldr	r5, [r3, #0]
 8027fb2:	6862      	ldr	r2, [r4, #4]
 8027fb4:	2100      	movs	r1, #0
 8027fb6:	4628      	mov	r0, r5
 8027fb8:	f7e2 fa6a 	bl	800a490 <memchr>
 8027fbc:	b108      	cbz	r0, 8027fc2 <_printf_i+0x1f2>
 8027fbe:	1b40      	subs	r0, r0, r5
 8027fc0:	6060      	str	r0, [r4, #4]
 8027fc2:	6863      	ldr	r3, [r4, #4]
 8027fc4:	6123      	str	r3, [r4, #16]
 8027fc6:	2300      	movs	r3, #0
 8027fc8:	f884 3043 	strb.w	r3, [r4, #67]	; 0x43
 8027fcc:	e7a8      	b.n	8027f20 <_printf_i+0x150>
 8027fce:	6923      	ldr	r3, [r4, #16]
 8027fd0:	462a      	mov	r2, r5
 8027fd2:	4649      	mov	r1, r9
 8027fd4:	4640      	mov	r0, r8
 8027fd6:	47d0      	blx	sl
 8027fd8:	3001      	adds	r0, #1
 8027fda:	d0ab      	beq.n	8027f34 <_printf_i+0x164>
 8027fdc:	6823      	ldr	r3, [r4, #0]
 8027fde:	079b      	lsls	r3, r3, #30
 8027fe0:	d413      	bmi.n	802800a <_printf_i+0x23a>
 8027fe2:	68e0      	ldr	r0, [r4, #12]
 8027fe4:	9b03      	ldr	r3, [sp, #12]
 8027fe6:	4298      	cmp	r0, r3
 8027fe8:	bfb8      	it	lt
 8027fea:	4618      	movlt	r0, r3
 8027fec:	e7a4      	b.n	8027f38 <_printf_i+0x168>
 8027fee:	2301      	movs	r3, #1
 8027ff0:	4632      	mov	r2, r6
 8027ff2:	4649      	mov	r1, r9
 8027ff4:	4640      	mov	r0, r8
 8027ff6:	47d0      	blx	sl
 8027ff8:	3001      	adds	r0, #1
 8027ffa:	d09b      	beq.n	8027f34 <_printf_i+0x164>
 8027ffc:	3501      	adds	r5, #1
 8027ffe:	68e3      	ldr	r3, [r4, #12]
 8028000:	9903      	ldr	r1, [sp, #12]
 8028002:	1a5b      	subs	r3, r3, r1
 8028004:	42ab      	cmp	r3, r5
 8028006:	dcf2      	bgt.n	8027fee <_printf_i+0x21e>
 8028008:	e7eb      	b.n	8027fe2 <_printf_i+0x212>
 802800a:	2500      	movs	r5, #0
 802800c:	f104 0619 	add.w	r6, r4, #25
 8028010:	e7f5      	b.n	8027ffe <_printf_i+0x22e>
 8028012:	bf00      	nop
 8028014:	08057a3a 	.word	0x08057a3a
 8028018:	08057a4b 	.word	0x08057a4b

0802801c <iprintf>:
 802801c:	b40f      	push	{r0, r1, r2, r3}
 802801e:	4b0a      	ldr	r3, [pc, #40]	; (8028048 <iprintf+0x2c>)
 8028020:	b513      	push	{r0, r1, r4, lr}
 8028022:	681c      	ldr	r4, [r3, #0]
 8028024:	b124      	cbz	r4, 8028030 <iprintf+0x14>
 8028026:	69a3      	ldr	r3, [r4, #24]
 8028028:	b913      	cbnz	r3, 8028030 <iprintf+0x14>
 802802a:	4620      	mov	r0, r4
 802802c:	f7ff f996 	bl	802735c <__sinit>
 8028030:	ab05      	add	r3, sp, #20
 8028032:	9a04      	ldr	r2, [sp, #16]
 8028034:	68a1      	ldr	r1, [r4, #8]
 8028036:	9301      	str	r3, [sp, #4]
 8028038:	4620      	mov	r0, r4
 802803a:	f001 febf 	bl	8029dbc <_vfiprintf_r>
 802803e:	b002      	add	sp, #8
 8028040:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 8028044:	b004      	add	sp, #16
 8028046:	4770      	bx	lr
 8028048:	20002020 	.word	0x20002020

0802804c <putchar>:
 802804c:	4b09      	ldr	r3, [pc, #36]	; (8028074 <putchar+0x28>)
 802804e:	b513      	push	{r0, r1, r4, lr}
 8028050:	681c      	ldr	r4, [r3, #0]
 8028052:	4601      	mov	r1, r0
 8028054:	b134      	cbz	r4, 8028064 <putchar+0x18>
 8028056:	69a3      	ldr	r3, [r4, #24]
 8028058:	b923      	cbnz	r3, 8028064 <putchar+0x18>
 802805a:	9001      	str	r0, [sp, #4]
 802805c:	4620      	mov	r0, r4
 802805e:	f7ff f97d 	bl	802735c <__sinit>
 8028062:	9901      	ldr	r1, [sp, #4]
 8028064:	68a2      	ldr	r2, [r4, #8]
 8028066:	4620      	mov	r0, r4
 8028068:	b002      	add	sp, #8
 802806a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 802806e:	f001 bfd5 	b.w	802a01c <_putc_r>
 8028072:	bf00      	nop
 8028074:	20002020 	.word	0x20002020

08028078 <_puts_r>:
 8028078:	b570      	push	{r4, r5, r6, lr}
 802807a:	460e      	mov	r6, r1
 802807c:	4605      	mov	r5, r0
 802807e:	b118      	cbz	r0, 8028088 <_puts_r+0x10>
 8028080:	6983      	ldr	r3, [r0, #24]
 8028082:	b90b      	cbnz	r3, 8028088 <_puts_r+0x10>
 8028084:	f7ff f96a 	bl	802735c <__sinit>
 8028088:	69ab      	ldr	r3, [r5, #24]
 802808a:	68ac      	ldr	r4, [r5, #8]
 802808c:	b913      	cbnz	r3, 8028094 <_puts_r+0x1c>
 802808e:	4628      	mov	r0, r5
 8028090:	f7ff f964 	bl	802735c <__sinit>
 8028094:	4b2c      	ldr	r3, [pc, #176]	; (8028148 <_puts_r+0xd0>)
 8028096:	429c      	cmp	r4, r3
 8028098:	d120      	bne.n	80280dc <_puts_r+0x64>
 802809a:	686c      	ldr	r4, [r5, #4]
 802809c:	6e63      	ldr	r3, [r4, #100]	; 0x64
 802809e:	07db      	lsls	r3, r3, #31
 80280a0:	d405      	bmi.n	80280ae <_puts_r+0x36>
 80280a2:	89a3      	ldrh	r3, [r4, #12]
 80280a4:	0598      	lsls	r0, r3, #22
 80280a6:	d402      	bmi.n	80280ae <_puts_r+0x36>
 80280a8:	6da0      	ldr	r0, [r4, #88]	; 0x58
 80280aa:	f7ff fa1a 	bl	80274e2 <__retarget_lock_acquire_recursive>
 80280ae:	89a3      	ldrh	r3, [r4, #12]
 80280b0:	0719      	lsls	r1, r3, #28
 80280b2:	d51d      	bpl.n	80280f0 <_puts_r+0x78>
 80280b4:	6923      	ldr	r3, [r4, #16]
 80280b6:	b1db      	cbz	r3, 80280f0 <_puts_r+0x78>
 80280b8:	3e01      	subs	r6, #1
 80280ba:	68a3      	ldr	r3, [r4, #8]
 80280bc:	f816 1f01 	ldrb.w	r1, [r6, #1]!
 80280c0:	3b01      	subs	r3, #1
 80280c2:	60a3      	str	r3, [r4, #8]
 80280c4:	bb39      	cbnz	r1, 8028116 <_puts_r+0x9e>
 80280c6:	2b00      	cmp	r3, #0
 80280c8:	da38      	bge.n	802813c <_puts_r+0xc4>
 80280ca:	4622      	mov	r2, r4
 80280cc:	210a      	movs	r1, #10
 80280ce:	4628      	mov	r0, r5
 80280d0:	f000 f96e 	bl	80283b0 <__swbuf_r>
 80280d4:	3001      	adds	r0, #1
 80280d6:	d011      	beq.n	80280fc <_puts_r+0x84>
 80280d8:	250a      	movs	r5, #10
 80280da:	e011      	b.n	8028100 <_puts_r+0x88>
 80280dc:	4b1b      	ldr	r3, [pc, #108]	; (802814c <_puts_r+0xd4>)
 80280de:	429c      	cmp	r4, r3
 80280e0:	d101      	bne.n	80280e6 <_puts_r+0x6e>
 80280e2:	68ac      	ldr	r4, [r5, #8]
 80280e4:	e7da      	b.n	802809c <_puts_r+0x24>
 80280e6:	4b1a      	ldr	r3, [pc, #104]	; (8028150 <_puts_r+0xd8>)
 80280e8:	429c      	cmp	r4, r3
 80280ea:	bf08      	it	eq
 80280ec:	68ec      	ldreq	r4, [r5, #12]
 80280ee:	e7d5      	b.n	802809c <_puts_r+0x24>
 80280f0:	4621      	mov	r1, r4
 80280f2:	4628      	mov	r0, r5
 80280f4:	f000 f9c0 	bl	8028478 <__swsetup_r>
 80280f8:	2800      	cmp	r0, #0
 80280fa:	d0dd      	beq.n	80280b8 <_puts_r+0x40>
 80280fc:	f04f 35ff 	mov.w	r5, #4294967295
 8028100:	6e63      	ldr	r3, [r4, #100]	; 0x64
 8028102:	07da      	lsls	r2, r3, #31
 8028104:	d405      	bmi.n	8028112 <_puts_r+0x9a>
 8028106:	89a3      	ldrh	r3, [r4, #12]
 8028108:	059b      	lsls	r3, r3, #22
 802810a:	d402      	bmi.n	8028112 <_puts_r+0x9a>
 802810c:	6da0      	ldr	r0, [r4, #88]	; 0x58
 802810e:	f7ff f9e9 	bl	80274e4 <__retarget_lock_release_recursive>
 8028112:	4628      	mov	r0, r5
 8028114:	bd70      	pop	{r4, r5, r6, pc}
 8028116:	2b00      	cmp	r3, #0
 8028118:	da04      	bge.n	8028124 <_puts_r+0xac>
 802811a:	69a2      	ldr	r2, [r4, #24]
 802811c:	429a      	cmp	r2, r3
 802811e:	dc06      	bgt.n	802812e <_puts_r+0xb6>
 8028120:	290a      	cmp	r1, #10
 8028122:	d004      	beq.n	802812e <_puts_r+0xb6>
 8028124:	6823      	ldr	r3, [r4, #0]
 8028126:	1c5a      	adds	r2, r3, #1
 8028128:	6022      	str	r2, [r4, #0]
 802812a:	7019      	strb	r1, [r3, #0]
 802812c:	e7c5      	b.n	80280ba <_puts_r+0x42>
 802812e:	4622      	mov	r2, r4
 8028130:	4628      	mov	r0, r5
 8028132:	f000 f93d 	bl	80283b0 <__swbuf_r>
 8028136:	3001      	adds	r0, #1
 8028138:	d1bf      	bne.n	80280ba <_puts_r+0x42>
 802813a:	e7df      	b.n	80280fc <_puts_r+0x84>
 802813c:	6823      	ldr	r3, [r4, #0]
 802813e:	250a      	movs	r5, #10
 8028140:	1c5a      	adds	r2, r3, #1
 8028142:	6022      	str	r2, [r4, #0]
 8028144:	701d      	strb	r5, [r3, #0]
 8028146:	e7db      	b.n	8028100 <_puts_r+0x88>
 8028148:	080579e4 	.word	0x080579e4
 802814c:	08057a04 	.word	0x08057a04
 8028150:	080579c4 	.word	0x080579c4

08028154 <puts>:
 8028154:	4b02      	ldr	r3, [pc, #8]	; (8028160 <puts+0xc>)
 8028156:	4601      	mov	r1, r0
 8028158:	6818      	ldr	r0, [r3, #0]
 802815a:	f7ff bf8d 	b.w	8028078 <_puts_r>
 802815e:	bf00      	nop
 8028160:	20002020 	.word	0x20002020

08028164 <_sbrk_r>:
 8028164:	b538      	push	{r3, r4, r5, lr}
 8028166:	4d06      	ldr	r5, [pc, #24]	; (8028180 <_sbrk_r+0x1c>)
 8028168:	2300      	movs	r3, #0
 802816a:	4604      	mov	r4, r0
 802816c:	4608      	mov	r0, r1
 802816e:	602b      	str	r3, [r5, #0]
 8028170:	f7f5 f92e 	bl	801d3d0 <_sbrk>
 8028174:	1c43      	adds	r3, r0, #1
 8028176:	d102      	bne.n	802817e <_sbrk_r+0x1a>
 8028178:	682b      	ldr	r3, [r5, #0]
 802817a:	b103      	cbz	r3, 802817e <_sbrk_r+0x1a>
 802817c:	6023      	str	r3, [r4, #0]
 802817e:	bd38      	pop	{r3, r4, r5, pc}
 8028180:	20014fcc 	.word	0x20014fcc

08028184 <siprintf>:
 8028184:	b40e      	push	{r1, r2, r3}
 8028186:	b500      	push	{lr}
 8028188:	b09c      	sub	sp, #112	; 0x70
 802818a:	ab1d      	add	r3, sp, #116	; 0x74
 802818c:	9002      	str	r0, [sp, #8]
 802818e:	9006      	str	r0, [sp, #24]
 8028190:	f06f 4100 	mvn.w	r1, #2147483648	; 0x80000000
 8028194:	4809      	ldr	r0, [pc, #36]	; (80281bc <siprintf+0x38>)
 8028196:	9107      	str	r1, [sp, #28]
 8028198:	9104      	str	r1, [sp, #16]
 802819a:	4909      	ldr	r1, [pc, #36]	; (80281c0 <siprintf+0x3c>)
 802819c:	f853 2b04 	ldr.w	r2, [r3], #4
 80281a0:	9105      	str	r1, [sp, #20]
 80281a2:	6800      	ldr	r0, [r0, #0]
 80281a4:	9301      	str	r3, [sp, #4]
 80281a6:	a902      	add	r1, sp, #8
 80281a8:	f001 fcde 	bl	8029b68 <_svfiprintf_r>
 80281ac:	9b02      	ldr	r3, [sp, #8]
 80281ae:	2200      	movs	r2, #0
 80281b0:	701a      	strb	r2, [r3, #0]
 80281b2:	b01c      	add	sp, #112	; 0x70
 80281b4:	f85d eb04 	ldr.w	lr, [sp], #4
 80281b8:	b003      	add	sp, #12
 80281ba:	4770      	bx	lr
 80281bc:	20002020 	.word	0x20002020
 80281c0:	ffff0208 	.word	0xffff0208

080281c4 <__sread>:
 80281c4:	b510      	push	{r4, lr}
 80281c6:	460c      	mov	r4, r1
 80281c8:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 80281cc:	f001 ff6e 	bl	802a0ac <_read_r>
 80281d0:	2800      	cmp	r0, #0
 80281d2:	bfab      	itete	ge
 80281d4:	6d63      	ldrge	r3, [r4, #84]	; 0x54
 80281d6:	89a3      	ldrhlt	r3, [r4, #12]
 80281d8:	181b      	addge	r3, r3, r0
 80281da:	f423 5380 	biclt.w	r3, r3, #4096	; 0x1000
 80281de:	bfac      	ite	ge
 80281e0:	6563      	strge	r3, [r4, #84]	; 0x54
 80281e2:	81a3      	strhlt	r3, [r4, #12]
 80281e4:	bd10      	pop	{r4, pc}

080281e6 <__swrite>:
 80281e6:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80281ea:	461f      	mov	r7, r3
 80281ec:	898b      	ldrh	r3, [r1, #12]
 80281ee:	05db      	lsls	r3, r3, #23
 80281f0:	4605      	mov	r5, r0
 80281f2:	460c      	mov	r4, r1
 80281f4:	4616      	mov	r6, r2
 80281f6:	d505      	bpl.n	8028204 <__swrite+0x1e>
 80281f8:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 80281fc:	2302      	movs	r3, #2
 80281fe:	2200      	movs	r2, #0
 8028200:	f001 f838 	bl	8029274 <_lseek_r>
 8028204:	89a3      	ldrh	r3, [r4, #12]
 8028206:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
 802820a:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
 802820e:	81a3      	strh	r3, [r4, #12]
 8028210:	4632      	mov	r2, r6
 8028212:	463b      	mov	r3, r7
 8028214:	4628      	mov	r0, r5
 8028216:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
 802821a:	f000 b91b 	b.w	8028454 <_write_r>

0802821e <__sseek>:
 802821e:	b510      	push	{r4, lr}
 8028220:	460c      	mov	r4, r1
 8028222:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 8028226:	f001 f825 	bl	8029274 <_lseek_r>
 802822a:	1c43      	adds	r3, r0, #1
 802822c:	89a3      	ldrh	r3, [r4, #12]
 802822e:	bf15      	itete	ne
 8028230:	6560      	strne	r0, [r4, #84]	; 0x54
 8028232:	f423 5380 	biceq.w	r3, r3, #4096	; 0x1000
 8028236:	f443 5380 	orrne.w	r3, r3, #4096	; 0x1000
 802823a:	81a3      	strheq	r3, [r4, #12]
 802823c:	bf18      	it	ne
 802823e:	81a3      	strhne	r3, [r4, #12]
 8028240:	bd10      	pop	{r4, pc}

08028242 <__sclose>:
 8028242:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 8028246:	f000 b985 	b.w	8028554 <_close_r>

0802824a <strncmp>:
 802824a:	b510      	push	{r4, lr}
 802824c:	b17a      	cbz	r2, 802826e <strncmp+0x24>
 802824e:	4603      	mov	r3, r0
 8028250:	3901      	subs	r1, #1
 8028252:	1884      	adds	r4, r0, r2
 8028254:	f813 0b01 	ldrb.w	r0, [r3], #1
 8028258:	f811 2f01 	ldrb.w	r2, [r1, #1]!
 802825c:	4290      	cmp	r0, r2
 802825e:	d101      	bne.n	8028264 <strncmp+0x1a>
 8028260:	42a3      	cmp	r3, r4
 8028262:	d101      	bne.n	8028268 <strncmp+0x1e>
 8028264:	1a80      	subs	r0, r0, r2
 8028266:	bd10      	pop	{r4, pc}
 8028268:	2800      	cmp	r0, #0
 802826a:	d1f3      	bne.n	8028254 <strncmp+0xa>
 802826c:	e7fa      	b.n	8028264 <strncmp+0x1a>
 802826e:	4610      	mov	r0, r2
 8028270:	e7f9      	b.n	8028266 <strncmp+0x1c>

08028272 <strncpy>:
 8028272:	b510      	push	{r4, lr}
 8028274:	3901      	subs	r1, #1
 8028276:	4603      	mov	r3, r0
 8028278:	b132      	cbz	r2, 8028288 <strncpy+0x16>
 802827a:	f811 4f01 	ldrb.w	r4, [r1, #1]!
 802827e:	f803 4b01 	strb.w	r4, [r3], #1
 8028282:	3a01      	subs	r2, #1
 8028284:	2c00      	cmp	r4, #0
 8028286:	d1f7      	bne.n	8028278 <strncpy+0x6>
 8028288:	441a      	add	r2, r3
 802828a:	2100      	movs	r1, #0
 802828c:	4293      	cmp	r3, r2
 802828e:	d100      	bne.n	8028292 <strncpy+0x20>
 8028290:	bd10      	pop	{r4, pc}
 8028292:	f803 1b01 	strb.w	r1, [r3], #1
 8028296:	e7f9      	b.n	802828c <strncpy+0x1a>

08028298 <_strtol_l.constprop.0>:
 8028298:	2b01      	cmp	r3, #1
 802829a:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 802829e:	d001      	beq.n	80282a4 <_strtol_l.constprop.0+0xc>
 80282a0:	2b24      	cmp	r3, #36	; 0x24
 80282a2:	d906      	bls.n	80282b2 <_strtol_l.constprop.0+0x1a>
 80282a4:	f7fe ff28 	bl	80270f8 <__errno>
 80282a8:	2316      	movs	r3, #22
 80282aa:	6003      	str	r3, [r0, #0]
 80282ac:	2000      	movs	r0, #0
 80282ae:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 80282b2:	f8df c0e4 	ldr.w	ip, [pc, #228]	; 8028398 <_strtol_l.constprop.0+0x100>
 80282b6:	460d      	mov	r5, r1
 80282b8:	462e      	mov	r6, r5
 80282ba:	f815 4b01 	ldrb.w	r4, [r5], #1
 80282be:	f814 700c 	ldrb.w	r7, [r4, ip]
 80282c2:	f017 0708 	ands.w	r7, r7, #8
 80282c6:	d1f7      	bne.n	80282b8 <_strtol_l.constprop.0+0x20>
 80282c8:	2c2d      	cmp	r4, #45	; 0x2d
 80282ca:	d132      	bne.n	8028332 <_strtol_l.constprop.0+0x9a>
 80282cc:	782c      	ldrb	r4, [r5, #0]
 80282ce:	2701      	movs	r7, #1
 80282d0:	1cb5      	adds	r5, r6, #2
 80282d2:	2b00      	cmp	r3, #0
 80282d4:	d05b      	beq.n	802838e <_strtol_l.constprop.0+0xf6>
 80282d6:	2b10      	cmp	r3, #16
 80282d8:	d109      	bne.n	80282ee <_strtol_l.constprop.0+0x56>
 80282da:	2c30      	cmp	r4, #48	; 0x30
 80282dc:	d107      	bne.n	80282ee <_strtol_l.constprop.0+0x56>
 80282de:	782c      	ldrb	r4, [r5, #0]
 80282e0:	f004 04df 	and.w	r4, r4, #223	; 0xdf
 80282e4:	2c58      	cmp	r4, #88	; 0x58
 80282e6:	d14d      	bne.n	8028384 <_strtol_l.constprop.0+0xec>
 80282e8:	786c      	ldrb	r4, [r5, #1]
 80282ea:	2310      	movs	r3, #16
 80282ec:	3502      	adds	r5, #2
 80282ee:	f107 4800 	add.w	r8, r7, #2147483648	; 0x80000000
 80282f2:	f108 38ff 	add.w	r8, r8, #4294967295
 80282f6:	f04f 0c00 	mov.w	ip, #0
 80282fa:	fbb8 f9f3 	udiv	r9, r8, r3
 80282fe:	4666      	mov	r6, ip
 8028300:	fb03 8a19 	mls	sl, r3, r9, r8
 8028304:	f1a4 0e30 	sub.w	lr, r4, #48	; 0x30
 8028308:	f1be 0f09 	cmp.w	lr, #9
 802830c:	d816      	bhi.n	802833c <_strtol_l.constprop.0+0xa4>
 802830e:	4674      	mov	r4, lr
 8028310:	42a3      	cmp	r3, r4
 8028312:	dd24      	ble.n	802835e <_strtol_l.constprop.0+0xc6>
 8028314:	f1bc 0f00 	cmp.w	ip, #0
 8028318:	db1e      	blt.n	8028358 <_strtol_l.constprop.0+0xc0>
 802831a:	45b1      	cmp	r9, r6
 802831c:	d31c      	bcc.n	8028358 <_strtol_l.constprop.0+0xc0>
 802831e:	d101      	bne.n	8028324 <_strtol_l.constprop.0+0x8c>
 8028320:	45a2      	cmp	sl, r4
 8028322:	db19      	blt.n	8028358 <_strtol_l.constprop.0+0xc0>
 8028324:	fb06 4603 	mla	r6, r6, r3, r4
 8028328:	f04f 0c01 	mov.w	ip, #1
 802832c:	f815 4b01 	ldrb.w	r4, [r5], #1
 8028330:	e7e8      	b.n	8028304 <_strtol_l.constprop.0+0x6c>
 8028332:	2c2b      	cmp	r4, #43	; 0x2b
 8028334:	bf04      	itt	eq
 8028336:	782c      	ldrbeq	r4, [r5, #0]
 8028338:	1cb5      	addeq	r5, r6, #2
 802833a:	e7ca      	b.n	80282d2 <_strtol_l.constprop.0+0x3a>
 802833c:	f1a4 0e41 	sub.w	lr, r4, #65	; 0x41
 8028340:	f1be 0f19 	cmp.w	lr, #25
 8028344:	d801      	bhi.n	802834a <_strtol_l.constprop.0+0xb2>
 8028346:	3c37      	subs	r4, #55	; 0x37
 8028348:	e7e2      	b.n	8028310 <_strtol_l.constprop.0+0x78>
 802834a:	f1a4 0e61 	sub.w	lr, r4, #97	; 0x61
 802834e:	f1be 0f19 	cmp.w	lr, #25
 8028352:	d804      	bhi.n	802835e <_strtol_l.constprop.0+0xc6>
 8028354:	3c57      	subs	r4, #87	; 0x57
 8028356:	e7db      	b.n	8028310 <_strtol_l.constprop.0+0x78>
 8028358:	f04f 3cff 	mov.w	ip, #4294967295
 802835c:	e7e6      	b.n	802832c <_strtol_l.constprop.0+0x94>
 802835e:	f1bc 0f00 	cmp.w	ip, #0
 8028362:	da05      	bge.n	8028370 <_strtol_l.constprop.0+0xd8>
 8028364:	2322      	movs	r3, #34	; 0x22
 8028366:	6003      	str	r3, [r0, #0]
 8028368:	4646      	mov	r6, r8
 802836a:	b942      	cbnz	r2, 802837e <_strtol_l.constprop.0+0xe6>
 802836c:	4630      	mov	r0, r6
 802836e:	e79e      	b.n	80282ae <_strtol_l.constprop.0+0x16>
 8028370:	b107      	cbz	r7, 8028374 <_strtol_l.constprop.0+0xdc>
 8028372:	4276      	negs	r6, r6
 8028374:	2a00      	cmp	r2, #0
 8028376:	d0f9      	beq.n	802836c <_strtol_l.constprop.0+0xd4>
 8028378:	f1bc 0f00 	cmp.w	ip, #0
 802837c:	d000      	beq.n	8028380 <_strtol_l.constprop.0+0xe8>
 802837e:	1e69      	subs	r1, r5, #1
 8028380:	6011      	str	r1, [r2, #0]
 8028382:	e7f3      	b.n	802836c <_strtol_l.constprop.0+0xd4>
 8028384:	2430      	movs	r4, #48	; 0x30
 8028386:	2b00      	cmp	r3, #0
 8028388:	d1b1      	bne.n	80282ee <_strtol_l.constprop.0+0x56>
 802838a:	2308      	movs	r3, #8
 802838c:	e7af      	b.n	80282ee <_strtol_l.constprop.0+0x56>
 802838e:	2c30      	cmp	r4, #48	; 0x30
 8028390:	d0a5      	beq.n	80282de <_strtol_l.constprop.0+0x46>
 8028392:	230a      	movs	r3, #10
 8028394:	e7ab      	b.n	80282ee <_strtol_l.constprop.0+0x56>
 8028396:	bf00      	nop
 8028398:	08057a5d 	.word	0x08057a5d

0802839c <strtol>:
 802839c:	4613      	mov	r3, r2
 802839e:	460a      	mov	r2, r1
 80283a0:	4601      	mov	r1, r0
 80283a2:	4802      	ldr	r0, [pc, #8]	; (80283ac <strtol+0x10>)
 80283a4:	6800      	ldr	r0, [r0, #0]
 80283a6:	f7ff bf77 	b.w	8028298 <_strtol_l.constprop.0>
 80283aa:	bf00      	nop
 80283ac:	20002020 	.word	0x20002020

080283b0 <__swbuf_r>:
 80283b0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80283b2:	460e      	mov	r6, r1
 80283b4:	4614      	mov	r4, r2
 80283b6:	4605      	mov	r5, r0
 80283b8:	b118      	cbz	r0, 80283c2 <__swbuf_r+0x12>
 80283ba:	6983      	ldr	r3, [r0, #24]
 80283bc:	b90b      	cbnz	r3, 80283c2 <__swbuf_r+0x12>
 80283be:	f7fe ffcd 	bl	802735c <__sinit>
 80283c2:	4b21      	ldr	r3, [pc, #132]	; (8028448 <__swbuf_r+0x98>)
 80283c4:	429c      	cmp	r4, r3
 80283c6:	d12b      	bne.n	8028420 <__swbuf_r+0x70>
 80283c8:	686c      	ldr	r4, [r5, #4]
 80283ca:	69a3      	ldr	r3, [r4, #24]
 80283cc:	60a3      	str	r3, [r4, #8]
 80283ce:	89a3      	ldrh	r3, [r4, #12]
 80283d0:	071a      	lsls	r2, r3, #28
 80283d2:	d52f      	bpl.n	8028434 <__swbuf_r+0x84>
 80283d4:	6923      	ldr	r3, [r4, #16]
 80283d6:	b36b      	cbz	r3, 8028434 <__swbuf_r+0x84>
 80283d8:	6923      	ldr	r3, [r4, #16]
 80283da:	6820      	ldr	r0, [r4, #0]
 80283dc:	1ac0      	subs	r0, r0, r3
 80283de:	6963      	ldr	r3, [r4, #20]
 80283e0:	b2f6      	uxtb	r6, r6
 80283e2:	4283      	cmp	r3, r0
 80283e4:	4637      	mov	r7, r6
 80283e6:	dc04      	bgt.n	80283f2 <__swbuf_r+0x42>
 80283e8:	4621      	mov	r1, r4
 80283ea:	4628      	mov	r0, r5
 80283ec:	f7fe ff10 	bl	8027210 <_fflush_r>
 80283f0:	bb30      	cbnz	r0, 8028440 <__swbuf_r+0x90>
 80283f2:	68a3      	ldr	r3, [r4, #8]
 80283f4:	3b01      	subs	r3, #1
 80283f6:	60a3      	str	r3, [r4, #8]
 80283f8:	6823      	ldr	r3, [r4, #0]
 80283fa:	1c5a      	adds	r2, r3, #1
 80283fc:	6022      	str	r2, [r4, #0]
 80283fe:	701e      	strb	r6, [r3, #0]
 8028400:	6963      	ldr	r3, [r4, #20]
 8028402:	3001      	adds	r0, #1
 8028404:	4283      	cmp	r3, r0
 8028406:	d004      	beq.n	8028412 <__swbuf_r+0x62>
 8028408:	89a3      	ldrh	r3, [r4, #12]
 802840a:	07db      	lsls	r3, r3, #31
 802840c:	d506      	bpl.n	802841c <__swbuf_r+0x6c>
 802840e:	2e0a      	cmp	r6, #10
 8028410:	d104      	bne.n	802841c <__swbuf_r+0x6c>
 8028412:	4621      	mov	r1, r4
 8028414:	4628      	mov	r0, r5
 8028416:	f7fe fefb 	bl	8027210 <_fflush_r>
 802841a:	b988      	cbnz	r0, 8028440 <__swbuf_r+0x90>
 802841c:	4638      	mov	r0, r7
 802841e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8028420:	4b0a      	ldr	r3, [pc, #40]	; (802844c <__swbuf_r+0x9c>)
 8028422:	429c      	cmp	r4, r3
 8028424:	d101      	bne.n	802842a <__swbuf_r+0x7a>
 8028426:	68ac      	ldr	r4, [r5, #8]
 8028428:	e7cf      	b.n	80283ca <__swbuf_r+0x1a>
 802842a:	4b09      	ldr	r3, [pc, #36]	; (8028450 <__swbuf_r+0xa0>)
 802842c:	429c      	cmp	r4, r3
 802842e:	bf08      	it	eq
 8028430:	68ec      	ldreq	r4, [r5, #12]
 8028432:	e7ca      	b.n	80283ca <__swbuf_r+0x1a>
 8028434:	4621      	mov	r1, r4
 8028436:	4628      	mov	r0, r5
 8028438:	f000 f81e 	bl	8028478 <__swsetup_r>
 802843c:	2800      	cmp	r0, #0
 802843e:	d0cb      	beq.n	80283d8 <__swbuf_r+0x28>
 8028440:	f04f 37ff 	mov.w	r7, #4294967295
 8028444:	e7ea      	b.n	802841c <__swbuf_r+0x6c>
 8028446:	bf00      	nop
 8028448:	080579e4 	.word	0x080579e4
 802844c:	08057a04 	.word	0x08057a04
 8028450:	080579c4 	.word	0x080579c4

08028454 <_write_r>:
 8028454:	b538      	push	{r3, r4, r5, lr}
 8028456:	4d07      	ldr	r5, [pc, #28]	; (8028474 <_write_r+0x20>)
 8028458:	4604      	mov	r4, r0
 802845a:	4608      	mov	r0, r1
 802845c:	4611      	mov	r1, r2
 802845e:	2200      	movs	r2, #0
 8028460:	602a      	str	r2, [r5, #0]
 8028462:	461a      	mov	r2, r3
 8028464:	f7f4 ffe4 	bl	801d430 <_write>
 8028468:	1c43      	adds	r3, r0, #1
 802846a:	d102      	bne.n	8028472 <_write_r+0x1e>
 802846c:	682b      	ldr	r3, [r5, #0]
 802846e:	b103      	cbz	r3, 8028472 <_write_r+0x1e>
 8028470:	6023      	str	r3, [r4, #0]
 8028472:	bd38      	pop	{r3, r4, r5, pc}
 8028474:	20014fcc 	.word	0x20014fcc

08028478 <__swsetup_r>:
 8028478:	4b32      	ldr	r3, [pc, #200]	; (8028544 <__swsetup_r+0xcc>)
 802847a:	b570      	push	{r4, r5, r6, lr}
 802847c:	681d      	ldr	r5, [r3, #0]
 802847e:	4606      	mov	r6, r0
 8028480:	460c      	mov	r4, r1
 8028482:	b125      	cbz	r5, 802848e <__swsetup_r+0x16>
 8028484:	69ab      	ldr	r3, [r5, #24]
 8028486:	b913      	cbnz	r3, 802848e <__swsetup_r+0x16>
 8028488:	4628      	mov	r0, r5
 802848a:	f7fe ff67 	bl	802735c <__sinit>
 802848e:	4b2e      	ldr	r3, [pc, #184]	; (8028548 <__swsetup_r+0xd0>)
 8028490:	429c      	cmp	r4, r3
 8028492:	d10f      	bne.n	80284b4 <__swsetup_r+0x3c>
 8028494:	686c      	ldr	r4, [r5, #4]
 8028496:	89a3      	ldrh	r3, [r4, #12]
 8028498:	f9b4 200c 	ldrsh.w	r2, [r4, #12]
 802849c:	0719      	lsls	r1, r3, #28
 802849e:	d42c      	bmi.n	80284fa <__swsetup_r+0x82>
 80284a0:	06dd      	lsls	r5, r3, #27
 80284a2:	d411      	bmi.n	80284c8 <__swsetup_r+0x50>
 80284a4:	2309      	movs	r3, #9
 80284a6:	6033      	str	r3, [r6, #0]
 80284a8:	f042 0340 	orr.w	r3, r2, #64	; 0x40
 80284ac:	81a3      	strh	r3, [r4, #12]
 80284ae:	f04f 30ff 	mov.w	r0, #4294967295
 80284b2:	e03e      	b.n	8028532 <__swsetup_r+0xba>
 80284b4:	4b25      	ldr	r3, [pc, #148]	; (802854c <__swsetup_r+0xd4>)
 80284b6:	429c      	cmp	r4, r3
 80284b8:	d101      	bne.n	80284be <__swsetup_r+0x46>
 80284ba:	68ac      	ldr	r4, [r5, #8]
 80284bc:	e7eb      	b.n	8028496 <__swsetup_r+0x1e>
 80284be:	4b24      	ldr	r3, [pc, #144]	; (8028550 <__swsetup_r+0xd8>)
 80284c0:	429c      	cmp	r4, r3
 80284c2:	bf08      	it	eq
 80284c4:	68ec      	ldreq	r4, [r5, #12]
 80284c6:	e7e6      	b.n	8028496 <__swsetup_r+0x1e>
 80284c8:	0758      	lsls	r0, r3, #29
 80284ca:	d512      	bpl.n	80284f2 <__swsetup_r+0x7a>
 80284cc:	6b61      	ldr	r1, [r4, #52]	; 0x34
 80284ce:	b141      	cbz	r1, 80284e2 <__swsetup_r+0x6a>
 80284d0:	f104 0344 	add.w	r3, r4, #68	; 0x44
 80284d4:	4299      	cmp	r1, r3
 80284d6:	d002      	beq.n	80284de <__swsetup_r+0x66>
 80284d8:	4630      	mov	r0, r6
 80284da:	f7ff f855 	bl	8027588 <_free_r>
 80284de:	2300      	movs	r3, #0
 80284e0:	6363      	str	r3, [r4, #52]	; 0x34
 80284e2:	89a3      	ldrh	r3, [r4, #12]
 80284e4:	f023 0324 	bic.w	r3, r3, #36	; 0x24
 80284e8:	81a3      	strh	r3, [r4, #12]
 80284ea:	2300      	movs	r3, #0
 80284ec:	6063      	str	r3, [r4, #4]
 80284ee:	6923      	ldr	r3, [r4, #16]
 80284f0:	6023      	str	r3, [r4, #0]
 80284f2:	89a3      	ldrh	r3, [r4, #12]
 80284f4:	f043 0308 	orr.w	r3, r3, #8
 80284f8:	81a3      	strh	r3, [r4, #12]
 80284fa:	6923      	ldr	r3, [r4, #16]
 80284fc:	b94b      	cbnz	r3, 8028512 <__swsetup_r+0x9a>
 80284fe:	89a3      	ldrh	r3, [r4, #12]
 8028500:	f403 7320 	and.w	r3, r3, #640	; 0x280
 8028504:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 8028508:	d003      	beq.n	8028512 <__swsetup_r+0x9a>
 802850a:	4621      	mov	r1, r4
 802850c:	4630      	mov	r0, r6
 802850e:	f000 fee9 	bl	80292e4 <__smakebuf_r>
 8028512:	89a0      	ldrh	r0, [r4, #12]
 8028514:	f9b4 200c 	ldrsh.w	r2, [r4, #12]
 8028518:	f010 0301 	ands.w	r3, r0, #1
 802851c:	d00a      	beq.n	8028534 <__swsetup_r+0xbc>
 802851e:	2300      	movs	r3, #0
 8028520:	60a3      	str	r3, [r4, #8]
 8028522:	6963      	ldr	r3, [r4, #20]
 8028524:	425b      	negs	r3, r3
 8028526:	61a3      	str	r3, [r4, #24]
 8028528:	6923      	ldr	r3, [r4, #16]
 802852a:	b943      	cbnz	r3, 802853e <__swsetup_r+0xc6>
 802852c:	f010 0080 	ands.w	r0, r0, #128	; 0x80
 8028530:	d1ba      	bne.n	80284a8 <__swsetup_r+0x30>
 8028532:	bd70      	pop	{r4, r5, r6, pc}
 8028534:	0781      	lsls	r1, r0, #30
 8028536:	bf58      	it	pl
 8028538:	6963      	ldrpl	r3, [r4, #20]
 802853a:	60a3      	str	r3, [r4, #8]
 802853c:	e7f4      	b.n	8028528 <__swsetup_r+0xb0>
 802853e:	2000      	movs	r0, #0
 8028540:	e7f7      	b.n	8028532 <__swsetup_r+0xba>
 8028542:	bf00      	nop
 8028544:	20002020 	.word	0x20002020
 8028548:	080579e4 	.word	0x080579e4
 802854c:	08057a04 	.word	0x08057a04
 8028550:	080579c4 	.word	0x080579c4

08028554 <_close_r>:
 8028554:	b538      	push	{r3, r4, r5, lr}
 8028556:	4d06      	ldr	r5, [pc, #24]	; (8028570 <_close_r+0x1c>)
 8028558:	2300      	movs	r3, #0
 802855a:	4604      	mov	r4, r0
 802855c:	4608      	mov	r0, r1
 802855e:	602b      	str	r3, [r5, #0]
 8028560:	f7f4 ff74 	bl	801d44c <_close>
 8028564:	1c43      	adds	r3, r0, #1
 8028566:	d102      	bne.n	802856e <_close_r+0x1a>
 8028568:	682b      	ldr	r3, [r5, #0]
 802856a:	b103      	cbz	r3, 802856e <_close_r+0x1a>
 802856c:	6023      	str	r3, [r4, #0]
 802856e:	bd38      	pop	{r3, r4, r5, pc}
 8028570:	20014fcc 	.word	0x20014fcc

08028574 <quorem>:
 8028574:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8028578:	6903      	ldr	r3, [r0, #16]
 802857a:	690c      	ldr	r4, [r1, #16]
 802857c:	42a3      	cmp	r3, r4
 802857e:	4607      	mov	r7, r0
 8028580:	f2c0 8081 	blt.w	8028686 <quorem+0x112>
 8028584:	3c01      	subs	r4, #1
 8028586:	f101 0814 	add.w	r8, r1, #20
 802858a:	f100 0514 	add.w	r5, r0, #20
 802858e:	eb05 0384 	add.w	r3, r5, r4, lsl #2
 8028592:	9301      	str	r3, [sp, #4]
 8028594:	f858 3024 	ldr.w	r3, [r8, r4, lsl #2]
 8028598:	f855 2024 	ldr.w	r2, [r5, r4, lsl #2]
 802859c:	3301      	adds	r3, #1
 802859e:	429a      	cmp	r2, r3
 80285a0:	ea4f 0b84 	mov.w	fp, r4, lsl #2
 80285a4:	eb08 0984 	add.w	r9, r8, r4, lsl #2
 80285a8:	fbb2 f6f3 	udiv	r6, r2, r3
 80285ac:	d331      	bcc.n	8028612 <quorem+0x9e>
 80285ae:	f04f 0e00 	mov.w	lr, #0
 80285b2:	4640      	mov	r0, r8
 80285b4:	46ac      	mov	ip, r5
 80285b6:	46f2      	mov	sl, lr
 80285b8:	f850 2b04 	ldr.w	r2, [r0], #4
 80285bc:	b293      	uxth	r3, r2
 80285be:	fb06 e303 	mla	r3, r6, r3, lr
 80285c2:	ea4f 4e13 	mov.w	lr, r3, lsr #16
 80285c6:	b29b      	uxth	r3, r3
 80285c8:	ebaa 0303 	sub.w	r3, sl, r3
 80285cc:	f8dc a000 	ldr.w	sl, [ip]
 80285d0:	0c12      	lsrs	r2, r2, #16
 80285d2:	fa13 f38a 	uxtah	r3, r3, sl
 80285d6:	fb06 e202 	mla	r2, r6, r2, lr
 80285da:	9300      	str	r3, [sp, #0]
 80285dc:	9b00      	ldr	r3, [sp, #0]
 80285de:	ea4f 4e12 	mov.w	lr, r2, lsr #16
 80285e2:	b292      	uxth	r2, r2
 80285e4:	ebc2 421a 	rsb	r2, r2, sl, lsr #16
 80285e8:	eb02 4223 	add.w	r2, r2, r3, asr #16
 80285ec:	f8bd 3000 	ldrh.w	r3, [sp]
 80285f0:	4581      	cmp	r9, r0
 80285f2:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
 80285f6:	f84c 3b04 	str.w	r3, [ip], #4
 80285fa:	ea4f 4a22 	mov.w	sl, r2, asr #16
 80285fe:	d2db      	bcs.n	80285b8 <quorem+0x44>
 8028600:	f855 300b 	ldr.w	r3, [r5, fp]
 8028604:	b92b      	cbnz	r3, 8028612 <quorem+0x9e>
 8028606:	9b01      	ldr	r3, [sp, #4]
 8028608:	3b04      	subs	r3, #4
 802860a:	429d      	cmp	r5, r3
 802860c:	461a      	mov	r2, r3
 802860e:	d32e      	bcc.n	802866e <quorem+0xfa>
 8028610:	613c      	str	r4, [r7, #16]
 8028612:	4638      	mov	r0, r7
 8028614:	f001 f934 	bl	8029880 <__mcmp>
 8028618:	2800      	cmp	r0, #0
 802861a:	db24      	blt.n	8028666 <quorem+0xf2>
 802861c:	3601      	adds	r6, #1
 802861e:	4628      	mov	r0, r5
 8028620:	f04f 0c00 	mov.w	ip, #0
 8028624:	f858 2b04 	ldr.w	r2, [r8], #4
 8028628:	f8d0 e000 	ldr.w	lr, [r0]
 802862c:	b293      	uxth	r3, r2
 802862e:	ebac 0303 	sub.w	r3, ip, r3
 8028632:	0c12      	lsrs	r2, r2, #16
 8028634:	fa13 f38e 	uxtah	r3, r3, lr
 8028638:	ebc2 421e 	rsb	r2, r2, lr, lsr #16
 802863c:	eb02 4223 	add.w	r2, r2, r3, asr #16
 8028640:	b29b      	uxth	r3, r3
 8028642:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
 8028646:	45c1      	cmp	r9, r8
 8028648:	f840 3b04 	str.w	r3, [r0], #4
 802864c:	ea4f 4c22 	mov.w	ip, r2, asr #16
 8028650:	d2e8      	bcs.n	8028624 <quorem+0xb0>
 8028652:	f855 2024 	ldr.w	r2, [r5, r4, lsl #2]
 8028656:	eb05 0384 	add.w	r3, r5, r4, lsl #2
 802865a:	b922      	cbnz	r2, 8028666 <quorem+0xf2>
 802865c:	3b04      	subs	r3, #4
 802865e:	429d      	cmp	r5, r3
 8028660:	461a      	mov	r2, r3
 8028662:	d30a      	bcc.n	802867a <quorem+0x106>
 8028664:	613c      	str	r4, [r7, #16]
 8028666:	4630      	mov	r0, r6
 8028668:	b003      	add	sp, #12
 802866a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 802866e:	6812      	ldr	r2, [r2, #0]
 8028670:	3b04      	subs	r3, #4
 8028672:	2a00      	cmp	r2, #0
 8028674:	d1cc      	bne.n	8028610 <quorem+0x9c>
 8028676:	3c01      	subs	r4, #1
 8028678:	e7c7      	b.n	802860a <quorem+0x96>
 802867a:	6812      	ldr	r2, [r2, #0]
 802867c:	3b04      	subs	r3, #4
 802867e:	2a00      	cmp	r2, #0
 8028680:	d1f0      	bne.n	8028664 <quorem+0xf0>
 8028682:	3c01      	subs	r4, #1
 8028684:	e7eb      	b.n	802865e <quorem+0xea>
 8028686:	2000      	movs	r0, #0
 8028688:	e7ee      	b.n	8028668 <quorem+0xf4>
 802868a:	0000      	movs	r0, r0
 802868c:	0000      	movs	r0, r0
	...

08028690 <_dtoa_r>:
 8028690:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8028694:	ed2d 8b04 	vpush	{d8-d9}
 8028698:	ec57 6b10 	vmov	r6, r7, d0
 802869c:	b093      	sub	sp, #76	; 0x4c
 802869e:	6a45      	ldr	r5, [r0, #36]	; 0x24
 80286a0:	f8dd 8080 	ldr.w	r8, [sp, #128]	; 0x80
 80286a4:	9106      	str	r1, [sp, #24]
 80286a6:	ee10 aa10 	vmov	sl, s0
 80286aa:	4604      	mov	r4, r0
 80286ac:	9209      	str	r2, [sp, #36]	; 0x24
 80286ae:	930c      	str	r3, [sp, #48]	; 0x30
 80286b0:	46bb      	mov	fp, r7
 80286b2:	b975      	cbnz	r5, 80286d2 <_dtoa_r+0x42>
 80286b4:	2010      	movs	r0, #16
 80286b6:	f7fe ff17 	bl	80274e8 <malloc>
 80286ba:	4602      	mov	r2, r0
 80286bc:	6260      	str	r0, [r4, #36]	; 0x24
 80286be:	b920      	cbnz	r0, 80286ca <_dtoa_r+0x3a>
 80286c0:	4ba7      	ldr	r3, [pc, #668]	; (8028960 <_dtoa_r+0x2d0>)
 80286c2:	21ea      	movs	r1, #234	; 0xea
 80286c4:	48a7      	ldr	r0, [pc, #668]	; (8028964 <_dtoa_r+0x2d4>)
 80286c6:	f001 fd03 	bl	802a0d0 <__assert_func>
 80286ca:	e9c0 5501 	strd	r5, r5, [r0, #4]
 80286ce:	6005      	str	r5, [r0, #0]
 80286d0:	60c5      	str	r5, [r0, #12]
 80286d2:	6a63      	ldr	r3, [r4, #36]	; 0x24
 80286d4:	6819      	ldr	r1, [r3, #0]
 80286d6:	b151      	cbz	r1, 80286ee <_dtoa_r+0x5e>
 80286d8:	685a      	ldr	r2, [r3, #4]
 80286da:	604a      	str	r2, [r1, #4]
 80286dc:	2301      	movs	r3, #1
 80286de:	4093      	lsls	r3, r2
 80286e0:	608b      	str	r3, [r1, #8]
 80286e2:	4620      	mov	r0, r4
 80286e4:	f000 fe8a 	bl	80293fc <_Bfree>
 80286e8:	6a63      	ldr	r3, [r4, #36]	; 0x24
 80286ea:	2200      	movs	r2, #0
 80286ec:	601a      	str	r2, [r3, #0]
 80286ee:	1e3b      	subs	r3, r7, #0
 80286f0:	bfaa      	itet	ge
 80286f2:	2300      	movge	r3, #0
 80286f4:	f023 4b00 	biclt.w	fp, r3, #2147483648	; 0x80000000
 80286f8:	f8c8 3000 	strge.w	r3, [r8]
 80286fc:	4b9a      	ldr	r3, [pc, #616]	; (8028968 <_dtoa_r+0x2d8>)
 80286fe:	bfbc      	itt	lt
 8028700:	2201      	movlt	r2, #1
 8028702:	f8c8 2000 	strlt.w	r2, [r8]
 8028706:	ea33 030b 	bics.w	r3, r3, fp
 802870a:	d11b      	bne.n	8028744 <_dtoa_r+0xb4>
 802870c:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 802870e:	f242 730f 	movw	r3, #9999	; 0x270f
 8028712:	6013      	str	r3, [r2, #0]
 8028714:	f3cb 0313 	ubfx	r3, fp, #0, #20
 8028718:	4333      	orrs	r3, r6
 802871a:	f000 8592 	beq.w	8029242 <_dtoa_r+0xbb2>
 802871e:	9b21      	ldr	r3, [sp, #132]	; 0x84
 8028720:	b963      	cbnz	r3, 802873c <_dtoa_r+0xac>
 8028722:	4b92      	ldr	r3, [pc, #584]	; (802896c <_dtoa_r+0x2dc>)
 8028724:	e022      	b.n	802876c <_dtoa_r+0xdc>
 8028726:	4b92      	ldr	r3, [pc, #584]	; (8028970 <_dtoa_r+0x2e0>)
 8028728:	9301      	str	r3, [sp, #4]
 802872a:	3308      	adds	r3, #8
 802872c:	9a21      	ldr	r2, [sp, #132]	; 0x84
 802872e:	6013      	str	r3, [r2, #0]
 8028730:	9801      	ldr	r0, [sp, #4]
 8028732:	b013      	add	sp, #76	; 0x4c
 8028734:	ecbd 8b04 	vpop	{d8-d9}
 8028738:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 802873c:	4b8b      	ldr	r3, [pc, #556]	; (802896c <_dtoa_r+0x2dc>)
 802873e:	9301      	str	r3, [sp, #4]
 8028740:	3303      	adds	r3, #3
 8028742:	e7f3      	b.n	802872c <_dtoa_r+0x9c>
 8028744:	2200      	movs	r2, #0
 8028746:	2300      	movs	r3, #0
 8028748:	4650      	mov	r0, sl
 802874a:	4659      	mov	r1, fp
 802874c:	f7e2 fb14 	bl	800ad78 <__aeabi_dcmpeq>
 8028750:	ec4b ab19 	vmov	d9, sl, fp
 8028754:	4680      	mov	r8, r0
 8028756:	b158      	cbz	r0, 8028770 <_dtoa_r+0xe0>
 8028758:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 802875a:	2301      	movs	r3, #1
 802875c:	6013      	str	r3, [r2, #0]
 802875e:	9b21      	ldr	r3, [sp, #132]	; 0x84
 8028760:	2b00      	cmp	r3, #0
 8028762:	f000 856b 	beq.w	802923c <_dtoa_r+0xbac>
 8028766:	4883      	ldr	r0, [pc, #524]	; (8028974 <_dtoa_r+0x2e4>)
 8028768:	6018      	str	r0, [r3, #0]
 802876a:	1e43      	subs	r3, r0, #1
 802876c:	9301      	str	r3, [sp, #4]
 802876e:	e7df      	b.n	8028730 <_dtoa_r+0xa0>
 8028770:	ec4b ab10 	vmov	d0, sl, fp
 8028774:	aa10      	add	r2, sp, #64	; 0x40
 8028776:	a911      	add	r1, sp, #68	; 0x44
 8028778:	4620      	mov	r0, r4
 802877a:	f001 f927 	bl	80299cc <__d2b>
 802877e:	f3cb 550a 	ubfx	r5, fp, #20, #11
 8028782:	ee08 0a10 	vmov	s16, r0
 8028786:	2d00      	cmp	r5, #0
 8028788:	f000 8084 	beq.w	8028894 <_dtoa_r+0x204>
 802878c:	ee19 3a90 	vmov	r3, s19
 8028790:	f3c3 0313 	ubfx	r3, r3, #0, #20
 8028794:	f043 577f 	orr.w	r7, r3, #1069547520	; 0x3fc00000
 8028798:	4656      	mov	r6, sl
 802879a:	f447 1740 	orr.w	r7, r7, #3145728	; 0x300000
 802879e:	f2a5 35ff 	subw	r5, r5, #1023	; 0x3ff
 80287a2:	f8cd 8038 	str.w	r8, [sp, #56]	; 0x38
 80287a6:	4b74      	ldr	r3, [pc, #464]	; (8028978 <_dtoa_r+0x2e8>)
 80287a8:	2200      	movs	r2, #0
 80287aa:	4630      	mov	r0, r6
 80287ac:	4639      	mov	r1, r7
 80287ae:	f7e1 fec3 	bl	800a538 <__aeabi_dsub>
 80287b2:	a365      	add	r3, pc, #404	; (adr r3, 8028948 <_dtoa_r+0x2b8>)
 80287b4:	e9d3 2300 	ldrd	r2, r3, [r3]
 80287b8:	f7e2 f876 	bl	800a8a8 <__aeabi_dmul>
 80287bc:	a364      	add	r3, pc, #400	; (adr r3, 8028950 <_dtoa_r+0x2c0>)
 80287be:	e9d3 2300 	ldrd	r2, r3, [r3]
 80287c2:	f7e1 febb 	bl	800a53c <__adddf3>
 80287c6:	4606      	mov	r6, r0
 80287c8:	4628      	mov	r0, r5
 80287ca:	460f      	mov	r7, r1
 80287cc:	f7e2 f802 	bl	800a7d4 <__aeabi_i2d>
 80287d0:	a361      	add	r3, pc, #388	; (adr r3, 8028958 <_dtoa_r+0x2c8>)
 80287d2:	e9d3 2300 	ldrd	r2, r3, [r3]
 80287d6:	f7e2 f867 	bl	800a8a8 <__aeabi_dmul>
 80287da:	4602      	mov	r2, r0
 80287dc:	460b      	mov	r3, r1
 80287de:	4630      	mov	r0, r6
 80287e0:	4639      	mov	r1, r7
 80287e2:	f7e1 feab 	bl	800a53c <__adddf3>
 80287e6:	4606      	mov	r6, r0
 80287e8:	460f      	mov	r7, r1
 80287ea:	f7e2 fb0d 	bl	800ae08 <__aeabi_d2iz>
 80287ee:	2200      	movs	r2, #0
 80287f0:	9000      	str	r0, [sp, #0]
 80287f2:	2300      	movs	r3, #0
 80287f4:	4630      	mov	r0, r6
 80287f6:	4639      	mov	r1, r7
 80287f8:	f7e2 fac8 	bl	800ad8c <__aeabi_dcmplt>
 80287fc:	b150      	cbz	r0, 8028814 <_dtoa_r+0x184>
 80287fe:	9800      	ldr	r0, [sp, #0]
 8028800:	f7e1 ffe8 	bl	800a7d4 <__aeabi_i2d>
 8028804:	4632      	mov	r2, r6
 8028806:	463b      	mov	r3, r7
 8028808:	f7e2 fab6 	bl	800ad78 <__aeabi_dcmpeq>
 802880c:	b910      	cbnz	r0, 8028814 <_dtoa_r+0x184>
 802880e:	9b00      	ldr	r3, [sp, #0]
 8028810:	3b01      	subs	r3, #1
 8028812:	9300      	str	r3, [sp, #0]
 8028814:	9b00      	ldr	r3, [sp, #0]
 8028816:	2b16      	cmp	r3, #22
 8028818:	d85a      	bhi.n	80288d0 <_dtoa_r+0x240>
 802881a:	9a00      	ldr	r2, [sp, #0]
 802881c:	4b57      	ldr	r3, [pc, #348]	; (802897c <_dtoa_r+0x2ec>)
 802881e:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
 8028822:	e9d3 2300 	ldrd	r2, r3, [r3]
 8028826:	ec51 0b19 	vmov	r0, r1, d9
 802882a:	f7e2 faaf 	bl	800ad8c <__aeabi_dcmplt>
 802882e:	2800      	cmp	r0, #0
 8028830:	d050      	beq.n	80288d4 <_dtoa_r+0x244>
 8028832:	9b00      	ldr	r3, [sp, #0]
 8028834:	3b01      	subs	r3, #1
 8028836:	9300      	str	r3, [sp, #0]
 8028838:	2300      	movs	r3, #0
 802883a:	930b      	str	r3, [sp, #44]	; 0x2c
 802883c:	9b10      	ldr	r3, [sp, #64]	; 0x40
 802883e:	1b5d      	subs	r5, r3, r5
 8028840:	1e6b      	subs	r3, r5, #1
 8028842:	9305      	str	r3, [sp, #20]
 8028844:	bf45      	ittet	mi
 8028846:	f1c5 0301 	rsbmi	r3, r5, #1
 802884a:	9304      	strmi	r3, [sp, #16]
 802884c:	2300      	movpl	r3, #0
 802884e:	2300      	movmi	r3, #0
 8028850:	bf4c      	ite	mi
 8028852:	9305      	strmi	r3, [sp, #20]
 8028854:	9304      	strpl	r3, [sp, #16]
 8028856:	9b00      	ldr	r3, [sp, #0]
 8028858:	2b00      	cmp	r3, #0
 802885a:	db3d      	blt.n	80288d8 <_dtoa_r+0x248>
 802885c:	9b05      	ldr	r3, [sp, #20]
 802885e:	9a00      	ldr	r2, [sp, #0]
 8028860:	920a      	str	r2, [sp, #40]	; 0x28
 8028862:	4413      	add	r3, r2
 8028864:	9305      	str	r3, [sp, #20]
 8028866:	2300      	movs	r3, #0
 8028868:	9307      	str	r3, [sp, #28]
 802886a:	9b06      	ldr	r3, [sp, #24]
 802886c:	2b09      	cmp	r3, #9
 802886e:	f200 8089 	bhi.w	8028984 <_dtoa_r+0x2f4>
 8028872:	2b05      	cmp	r3, #5
 8028874:	bfc4      	itt	gt
 8028876:	3b04      	subgt	r3, #4
 8028878:	9306      	strgt	r3, [sp, #24]
 802887a:	9b06      	ldr	r3, [sp, #24]
 802887c:	f1a3 0302 	sub.w	r3, r3, #2
 8028880:	bfcc      	ite	gt
 8028882:	2500      	movgt	r5, #0
 8028884:	2501      	movle	r5, #1
 8028886:	2b03      	cmp	r3, #3
 8028888:	f200 8087 	bhi.w	802899a <_dtoa_r+0x30a>
 802888c:	e8df f003 	tbb	[pc, r3]
 8028890:	59383a2d 	.word	0x59383a2d
 8028894:	e9dd 5310 	ldrd	r5, r3, [sp, #64]	; 0x40
 8028898:	441d      	add	r5, r3
 802889a:	f205 4332 	addw	r3, r5, #1074	; 0x432
 802889e:	2b20      	cmp	r3, #32
 80288a0:	bfc1      	itttt	gt
 80288a2:	f1c3 0340 	rsbgt	r3, r3, #64	; 0x40
 80288a6:	f205 4012 	addwgt	r0, r5, #1042	; 0x412
 80288aa:	fa0b f303 	lslgt.w	r3, fp, r3
 80288ae:	fa26 f000 	lsrgt.w	r0, r6, r0
 80288b2:	bfda      	itte	le
 80288b4:	f1c3 0320 	rsble	r3, r3, #32
 80288b8:	fa06 f003 	lslle.w	r0, r6, r3
 80288bc:	4318      	orrgt	r0, r3
 80288be:	f7e1 ff79 	bl	800a7b4 <__aeabi_ui2d>
 80288c2:	2301      	movs	r3, #1
 80288c4:	4606      	mov	r6, r0
 80288c6:	f1a1 77f8 	sub.w	r7, r1, #32505856	; 0x1f00000
 80288ca:	3d01      	subs	r5, #1
 80288cc:	930e      	str	r3, [sp, #56]	; 0x38
 80288ce:	e76a      	b.n	80287a6 <_dtoa_r+0x116>
 80288d0:	2301      	movs	r3, #1
 80288d2:	e7b2      	b.n	802883a <_dtoa_r+0x1aa>
 80288d4:	900b      	str	r0, [sp, #44]	; 0x2c
 80288d6:	e7b1      	b.n	802883c <_dtoa_r+0x1ac>
 80288d8:	9b04      	ldr	r3, [sp, #16]
 80288da:	9a00      	ldr	r2, [sp, #0]
 80288dc:	1a9b      	subs	r3, r3, r2
 80288de:	9304      	str	r3, [sp, #16]
 80288e0:	4253      	negs	r3, r2
 80288e2:	9307      	str	r3, [sp, #28]
 80288e4:	2300      	movs	r3, #0
 80288e6:	930a      	str	r3, [sp, #40]	; 0x28
 80288e8:	e7bf      	b.n	802886a <_dtoa_r+0x1da>
 80288ea:	2300      	movs	r3, #0
 80288ec:	9308      	str	r3, [sp, #32]
 80288ee:	9b09      	ldr	r3, [sp, #36]	; 0x24
 80288f0:	2b00      	cmp	r3, #0
 80288f2:	dc55      	bgt.n	80289a0 <_dtoa_r+0x310>
 80288f4:	2301      	movs	r3, #1
 80288f6:	e9cd 3302 	strd	r3, r3, [sp, #8]
 80288fa:	461a      	mov	r2, r3
 80288fc:	9209      	str	r2, [sp, #36]	; 0x24
 80288fe:	e00c      	b.n	802891a <_dtoa_r+0x28a>
 8028900:	2301      	movs	r3, #1
 8028902:	e7f3      	b.n	80288ec <_dtoa_r+0x25c>
 8028904:	2300      	movs	r3, #0
 8028906:	9a09      	ldr	r2, [sp, #36]	; 0x24
 8028908:	9308      	str	r3, [sp, #32]
 802890a:	9b00      	ldr	r3, [sp, #0]
 802890c:	4413      	add	r3, r2
 802890e:	9302      	str	r3, [sp, #8]
 8028910:	3301      	adds	r3, #1
 8028912:	2b01      	cmp	r3, #1
 8028914:	9303      	str	r3, [sp, #12]
 8028916:	bfb8      	it	lt
 8028918:	2301      	movlt	r3, #1
 802891a:	6a60      	ldr	r0, [r4, #36]	; 0x24
 802891c:	2200      	movs	r2, #0
 802891e:	6042      	str	r2, [r0, #4]
 8028920:	2204      	movs	r2, #4
 8028922:	f102 0614 	add.w	r6, r2, #20
 8028926:	429e      	cmp	r6, r3
 8028928:	6841      	ldr	r1, [r0, #4]
 802892a:	d93d      	bls.n	80289a8 <_dtoa_r+0x318>
 802892c:	4620      	mov	r0, r4
 802892e:	f000 fd25 	bl	802937c <_Balloc>
 8028932:	9001      	str	r0, [sp, #4]
 8028934:	2800      	cmp	r0, #0
 8028936:	d13b      	bne.n	80289b0 <_dtoa_r+0x320>
 8028938:	4b11      	ldr	r3, [pc, #68]	; (8028980 <_dtoa_r+0x2f0>)
 802893a:	4602      	mov	r2, r0
 802893c:	f44f 71d5 	mov.w	r1, #426	; 0x1aa
 8028940:	e6c0      	b.n	80286c4 <_dtoa_r+0x34>
 8028942:	2301      	movs	r3, #1
 8028944:	e7df      	b.n	8028906 <_dtoa_r+0x276>
 8028946:	bf00      	nop
 8028948:	636f4361 	.word	0x636f4361
 802894c:	3fd287a7 	.word	0x3fd287a7
 8028950:	8b60c8b3 	.word	0x8b60c8b3
 8028954:	3fc68a28 	.word	0x3fc68a28
 8028958:	509f79fb 	.word	0x509f79fb
 802895c:	3fd34413 	.word	0x3fd34413
 8028960:	08057b6a 	.word	0x08057b6a
 8028964:	08057b81 	.word	0x08057b81
 8028968:	7ff00000 	.word	0x7ff00000
 802896c:	08057b66 	.word	0x08057b66
 8028970:	08057b5d 	.word	0x08057b5d
 8028974:	08057a39 	.word	0x08057a39
 8028978:	3ff80000 	.word	0x3ff80000
 802897c:	08057c78 	.word	0x08057c78
 8028980:	08057bdc 	.word	0x08057bdc
 8028984:	2501      	movs	r5, #1
 8028986:	2300      	movs	r3, #0
 8028988:	9306      	str	r3, [sp, #24]
 802898a:	9508      	str	r5, [sp, #32]
 802898c:	f04f 33ff 	mov.w	r3, #4294967295
 8028990:	e9cd 3302 	strd	r3, r3, [sp, #8]
 8028994:	2200      	movs	r2, #0
 8028996:	2312      	movs	r3, #18
 8028998:	e7b0      	b.n	80288fc <_dtoa_r+0x26c>
 802899a:	2301      	movs	r3, #1
 802899c:	9308      	str	r3, [sp, #32]
 802899e:	e7f5      	b.n	802898c <_dtoa_r+0x2fc>
 80289a0:	9b09      	ldr	r3, [sp, #36]	; 0x24
 80289a2:	e9cd 3302 	strd	r3, r3, [sp, #8]
 80289a6:	e7b8      	b.n	802891a <_dtoa_r+0x28a>
 80289a8:	3101      	adds	r1, #1
 80289aa:	6041      	str	r1, [r0, #4]
 80289ac:	0052      	lsls	r2, r2, #1
 80289ae:	e7b8      	b.n	8028922 <_dtoa_r+0x292>
 80289b0:	6a63      	ldr	r3, [r4, #36]	; 0x24
 80289b2:	9a01      	ldr	r2, [sp, #4]
 80289b4:	601a      	str	r2, [r3, #0]
 80289b6:	9b03      	ldr	r3, [sp, #12]
 80289b8:	2b0e      	cmp	r3, #14
 80289ba:	f200 809d 	bhi.w	8028af8 <_dtoa_r+0x468>
 80289be:	2d00      	cmp	r5, #0
 80289c0:	f000 809a 	beq.w	8028af8 <_dtoa_r+0x468>
 80289c4:	9b00      	ldr	r3, [sp, #0]
 80289c6:	2b00      	cmp	r3, #0
 80289c8:	dd32      	ble.n	8028a30 <_dtoa_r+0x3a0>
 80289ca:	4ab7      	ldr	r2, [pc, #732]	; (8028ca8 <_dtoa_r+0x618>)
 80289cc:	f003 030f 	and.w	r3, r3, #15
 80289d0:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
 80289d4:	e9d3 8900 	ldrd	r8, r9, [r3]
 80289d8:	9b00      	ldr	r3, [sp, #0]
 80289da:	05d8      	lsls	r0, r3, #23
 80289dc:	ea4f 1723 	mov.w	r7, r3, asr #4
 80289e0:	d516      	bpl.n	8028a10 <_dtoa_r+0x380>
 80289e2:	4bb2      	ldr	r3, [pc, #712]	; (8028cac <_dtoa_r+0x61c>)
 80289e4:	ec51 0b19 	vmov	r0, r1, d9
 80289e8:	e9d3 2308 	ldrd	r2, r3, [r3, #32]
 80289ec:	f7e2 f886 	bl	800aafc <__aeabi_ddiv>
 80289f0:	f007 070f 	and.w	r7, r7, #15
 80289f4:	4682      	mov	sl, r0
 80289f6:	468b      	mov	fp, r1
 80289f8:	2503      	movs	r5, #3
 80289fa:	4eac      	ldr	r6, [pc, #688]	; (8028cac <_dtoa_r+0x61c>)
 80289fc:	b957      	cbnz	r7, 8028a14 <_dtoa_r+0x384>
 80289fe:	4642      	mov	r2, r8
 8028a00:	464b      	mov	r3, r9
 8028a02:	4650      	mov	r0, sl
 8028a04:	4659      	mov	r1, fp
 8028a06:	f7e2 f879 	bl	800aafc <__aeabi_ddiv>
 8028a0a:	4682      	mov	sl, r0
 8028a0c:	468b      	mov	fp, r1
 8028a0e:	e028      	b.n	8028a62 <_dtoa_r+0x3d2>
 8028a10:	2502      	movs	r5, #2
 8028a12:	e7f2      	b.n	80289fa <_dtoa_r+0x36a>
 8028a14:	07f9      	lsls	r1, r7, #31
 8028a16:	d508      	bpl.n	8028a2a <_dtoa_r+0x39a>
 8028a18:	4640      	mov	r0, r8
 8028a1a:	4649      	mov	r1, r9
 8028a1c:	e9d6 2300 	ldrd	r2, r3, [r6]
 8028a20:	f7e1 ff42 	bl	800a8a8 <__aeabi_dmul>
 8028a24:	3501      	adds	r5, #1
 8028a26:	4680      	mov	r8, r0
 8028a28:	4689      	mov	r9, r1
 8028a2a:	107f      	asrs	r7, r7, #1
 8028a2c:	3608      	adds	r6, #8
 8028a2e:	e7e5      	b.n	80289fc <_dtoa_r+0x36c>
 8028a30:	f000 809b 	beq.w	8028b6a <_dtoa_r+0x4da>
 8028a34:	9b00      	ldr	r3, [sp, #0]
 8028a36:	4f9d      	ldr	r7, [pc, #628]	; (8028cac <_dtoa_r+0x61c>)
 8028a38:	425e      	negs	r6, r3
 8028a3a:	4b9b      	ldr	r3, [pc, #620]	; (8028ca8 <_dtoa_r+0x618>)
 8028a3c:	f006 020f 	and.w	r2, r6, #15
 8028a40:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
 8028a44:	e9d3 2300 	ldrd	r2, r3, [r3]
 8028a48:	ec51 0b19 	vmov	r0, r1, d9
 8028a4c:	f7e1 ff2c 	bl	800a8a8 <__aeabi_dmul>
 8028a50:	1136      	asrs	r6, r6, #4
 8028a52:	4682      	mov	sl, r0
 8028a54:	468b      	mov	fp, r1
 8028a56:	2300      	movs	r3, #0
 8028a58:	2502      	movs	r5, #2
 8028a5a:	2e00      	cmp	r6, #0
 8028a5c:	d17a      	bne.n	8028b54 <_dtoa_r+0x4c4>
 8028a5e:	2b00      	cmp	r3, #0
 8028a60:	d1d3      	bne.n	8028a0a <_dtoa_r+0x37a>
 8028a62:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8028a64:	2b00      	cmp	r3, #0
 8028a66:	f000 8082 	beq.w	8028b6e <_dtoa_r+0x4de>
 8028a6a:	4b91      	ldr	r3, [pc, #580]	; (8028cb0 <_dtoa_r+0x620>)
 8028a6c:	2200      	movs	r2, #0
 8028a6e:	4650      	mov	r0, sl
 8028a70:	4659      	mov	r1, fp
 8028a72:	f7e2 f98b 	bl	800ad8c <__aeabi_dcmplt>
 8028a76:	2800      	cmp	r0, #0
 8028a78:	d079      	beq.n	8028b6e <_dtoa_r+0x4de>
 8028a7a:	9b03      	ldr	r3, [sp, #12]
 8028a7c:	2b00      	cmp	r3, #0
 8028a7e:	d076      	beq.n	8028b6e <_dtoa_r+0x4de>
 8028a80:	9b02      	ldr	r3, [sp, #8]
 8028a82:	2b00      	cmp	r3, #0
 8028a84:	dd36      	ble.n	8028af4 <_dtoa_r+0x464>
 8028a86:	9b00      	ldr	r3, [sp, #0]
 8028a88:	4650      	mov	r0, sl
 8028a8a:	4659      	mov	r1, fp
 8028a8c:	1e5f      	subs	r7, r3, #1
 8028a8e:	2200      	movs	r2, #0
 8028a90:	4b88      	ldr	r3, [pc, #544]	; (8028cb4 <_dtoa_r+0x624>)
 8028a92:	f7e1 ff09 	bl	800a8a8 <__aeabi_dmul>
 8028a96:	9e02      	ldr	r6, [sp, #8]
 8028a98:	4682      	mov	sl, r0
 8028a9a:	468b      	mov	fp, r1
 8028a9c:	3501      	adds	r5, #1
 8028a9e:	4628      	mov	r0, r5
 8028aa0:	f7e1 fe98 	bl	800a7d4 <__aeabi_i2d>
 8028aa4:	4652      	mov	r2, sl
 8028aa6:	465b      	mov	r3, fp
 8028aa8:	f7e1 fefe 	bl	800a8a8 <__aeabi_dmul>
 8028aac:	4b82      	ldr	r3, [pc, #520]	; (8028cb8 <_dtoa_r+0x628>)
 8028aae:	2200      	movs	r2, #0
 8028ab0:	f7e1 fd44 	bl	800a53c <__adddf3>
 8028ab4:	46d0      	mov	r8, sl
 8028ab6:	46d9      	mov	r9, fp
 8028ab8:	4682      	mov	sl, r0
 8028aba:	f1a1 7b50 	sub.w	fp, r1, #54525952	; 0x3400000
 8028abe:	2e00      	cmp	r6, #0
 8028ac0:	d158      	bne.n	8028b74 <_dtoa_r+0x4e4>
 8028ac2:	4b7e      	ldr	r3, [pc, #504]	; (8028cbc <_dtoa_r+0x62c>)
 8028ac4:	2200      	movs	r2, #0
 8028ac6:	4640      	mov	r0, r8
 8028ac8:	4649      	mov	r1, r9
 8028aca:	f7e1 fd35 	bl	800a538 <__aeabi_dsub>
 8028ace:	4652      	mov	r2, sl
 8028ad0:	465b      	mov	r3, fp
 8028ad2:	4680      	mov	r8, r0
 8028ad4:	4689      	mov	r9, r1
 8028ad6:	f7e2 f977 	bl	800adc8 <__aeabi_dcmpgt>
 8028ada:	2800      	cmp	r0, #0
 8028adc:	f040 8295 	bne.w	802900a <_dtoa_r+0x97a>
 8028ae0:	4652      	mov	r2, sl
 8028ae2:	f10b 4300 	add.w	r3, fp, #2147483648	; 0x80000000
 8028ae6:	4640      	mov	r0, r8
 8028ae8:	4649      	mov	r1, r9
 8028aea:	f7e2 f94f 	bl	800ad8c <__aeabi_dcmplt>
 8028aee:	2800      	cmp	r0, #0
 8028af0:	f040 8289 	bne.w	8029006 <_dtoa_r+0x976>
 8028af4:	ec5b ab19 	vmov	sl, fp, d9
 8028af8:	9b11      	ldr	r3, [sp, #68]	; 0x44
 8028afa:	2b00      	cmp	r3, #0
 8028afc:	f2c0 8148 	blt.w	8028d90 <_dtoa_r+0x700>
 8028b00:	9a00      	ldr	r2, [sp, #0]
 8028b02:	2a0e      	cmp	r2, #14
 8028b04:	f300 8144 	bgt.w	8028d90 <_dtoa_r+0x700>
 8028b08:	4b67      	ldr	r3, [pc, #412]	; (8028ca8 <_dtoa_r+0x618>)
 8028b0a:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
 8028b0e:	e9d3 8900 	ldrd	r8, r9, [r3]
 8028b12:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8028b14:	2b00      	cmp	r3, #0
 8028b16:	f280 80d5 	bge.w	8028cc4 <_dtoa_r+0x634>
 8028b1a:	9b03      	ldr	r3, [sp, #12]
 8028b1c:	2b00      	cmp	r3, #0
 8028b1e:	f300 80d1 	bgt.w	8028cc4 <_dtoa_r+0x634>
 8028b22:	f040 826f 	bne.w	8029004 <_dtoa_r+0x974>
 8028b26:	4b65      	ldr	r3, [pc, #404]	; (8028cbc <_dtoa_r+0x62c>)
 8028b28:	2200      	movs	r2, #0
 8028b2a:	4640      	mov	r0, r8
 8028b2c:	4649      	mov	r1, r9
 8028b2e:	f7e1 febb 	bl	800a8a8 <__aeabi_dmul>
 8028b32:	4652      	mov	r2, sl
 8028b34:	465b      	mov	r3, fp
 8028b36:	f7e2 f93d 	bl	800adb4 <__aeabi_dcmpge>
 8028b3a:	9e03      	ldr	r6, [sp, #12]
 8028b3c:	4637      	mov	r7, r6
 8028b3e:	2800      	cmp	r0, #0
 8028b40:	f040 8245 	bne.w	8028fce <_dtoa_r+0x93e>
 8028b44:	9d01      	ldr	r5, [sp, #4]
 8028b46:	2331      	movs	r3, #49	; 0x31
 8028b48:	f805 3b01 	strb.w	r3, [r5], #1
 8028b4c:	9b00      	ldr	r3, [sp, #0]
 8028b4e:	3301      	adds	r3, #1
 8028b50:	9300      	str	r3, [sp, #0]
 8028b52:	e240      	b.n	8028fd6 <_dtoa_r+0x946>
 8028b54:	07f2      	lsls	r2, r6, #31
 8028b56:	d505      	bpl.n	8028b64 <_dtoa_r+0x4d4>
 8028b58:	e9d7 2300 	ldrd	r2, r3, [r7]
 8028b5c:	f7e1 fea4 	bl	800a8a8 <__aeabi_dmul>
 8028b60:	3501      	adds	r5, #1
 8028b62:	2301      	movs	r3, #1
 8028b64:	1076      	asrs	r6, r6, #1
 8028b66:	3708      	adds	r7, #8
 8028b68:	e777      	b.n	8028a5a <_dtoa_r+0x3ca>
 8028b6a:	2502      	movs	r5, #2
 8028b6c:	e779      	b.n	8028a62 <_dtoa_r+0x3d2>
 8028b6e:	9f00      	ldr	r7, [sp, #0]
 8028b70:	9e03      	ldr	r6, [sp, #12]
 8028b72:	e794      	b.n	8028a9e <_dtoa_r+0x40e>
 8028b74:	9901      	ldr	r1, [sp, #4]
 8028b76:	4b4c      	ldr	r3, [pc, #304]	; (8028ca8 <_dtoa_r+0x618>)
 8028b78:	4431      	add	r1, r6
 8028b7a:	910d      	str	r1, [sp, #52]	; 0x34
 8028b7c:	9908      	ldr	r1, [sp, #32]
 8028b7e:	eb03 03c6 	add.w	r3, r3, r6, lsl #3
 8028b82:	e953 2302 	ldrd	r2, r3, [r3, #-8]
 8028b86:	2900      	cmp	r1, #0
 8028b88:	d043      	beq.n	8028c12 <_dtoa_r+0x582>
 8028b8a:	494d      	ldr	r1, [pc, #308]	; (8028cc0 <_dtoa_r+0x630>)
 8028b8c:	2000      	movs	r0, #0
 8028b8e:	f7e1 ffb5 	bl	800aafc <__aeabi_ddiv>
 8028b92:	4652      	mov	r2, sl
 8028b94:	465b      	mov	r3, fp
 8028b96:	f7e1 fccf 	bl	800a538 <__aeabi_dsub>
 8028b9a:	9d01      	ldr	r5, [sp, #4]
 8028b9c:	4682      	mov	sl, r0
 8028b9e:	468b      	mov	fp, r1
 8028ba0:	4649      	mov	r1, r9
 8028ba2:	4640      	mov	r0, r8
 8028ba4:	f7e2 f930 	bl	800ae08 <__aeabi_d2iz>
 8028ba8:	4606      	mov	r6, r0
 8028baa:	f7e1 fe13 	bl	800a7d4 <__aeabi_i2d>
 8028bae:	4602      	mov	r2, r0
 8028bb0:	460b      	mov	r3, r1
 8028bb2:	4640      	mov	r0, r8
 8028bb4:	4649      	mov	r1, r9
 8028bb6:	f7e1 fcbf 	bl	800a538 <__aeabi_dsub>
 8028bba:	3630      	adds	r6, #48	; 0x30
 8028bbc:	f805 6b01 	strb.w	r6, [r5], #1
 8028bc0:	4652      	mov	r2, sl
 8028bc2:	465b      	mov	r3, fp
 8028bc4:	4680      	mov	r8, r0
 8028bc6:	4689      	mov	r9, r1
 8028bc8:	f7e2 f8e0 	bl	800ad8c <__aeabi_dcmplt>
 8028bcc:	2800      	cmp	r0, #0
 8028bce:	d163      	bne.n	8028c98 <_dtoa_r+0x608>
 8028bd0:	4642      	mov	r2, r8
 8028bd2:	464b      	mov	r3, r9
 8028bd4:	4936      	ldr	r1, [pc, #216]	; (8028cb0 <_dtoa_r+0x620>)
 8028bd6:	2000      	movs	r0, #0
 8028bd8:	f7e1 fcae 	bl	800a538 <__aeabi_dsub>
 8028bdc:	4652      	mov	r2, sl
 8028bde:	465b      	mov	r3, fp
 8028be0:	f7e2 f8d4 	bl	800ad8c <__aeabi_dcmplt>
 8028be4:	2800      	cmp	r0, #0
 8028be6:	f040 80b5 	bne.w	8028d54 <_dtoa_r+0x6c4>
 8028bea:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8028bec:	429d      	cmp	r5, r3
 8028bee:	d081      	beq.n	8028af4 <_dtoa_r+0x464>
 8028bf0:	4b30      	ldr	r3, [pc, #192]	; (8028cb4 <_dtoa_r+0x624>)
 8028bf2:	2200      	movs	r2, #0
 8028bf4:	4650      	mov	r0, sl
 8028bf6:	4659      	mov	r1, fp
 8028bf8:	f7e1 fe56 	bl	800a8a8 <__aeabi_dmul>
 8028bfc:	4b2d      	ldr	r3, [pc, #180]	; (8028cb4 <_dtoa_r+0x624>)
 8028bfe:	4682      	mov	sl, r0
 8028c00:	468b      	mov	fp, r1
 8028c02:	4640      	mov	r0, r8
 8028c04:	4649      	mov	r1, r9
 8028c06:	2200      	movs	r2, #0
 8028c08:	f7e1 fe4e 	bl	800a8a8 <__aeabi_dmul>
 8028c0c:	4680      	mov	r8, r0
 8028c0e:	4689      	mov	r9, r1
 8028c10:	e7c6      	b.n	8028ba0 <_dtoa_r+0x510>
 8028c12:	4650      	mov	r0, sl
 8028c14:	4659      	mov	r1, fp
 8028c16:	f7e1 fe47 	bl	800a8a8 <__aeabi_dmul>
 8028c1a:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8028c1c:	9d01      	ldr	r5, [sp, #4]
 8028c1e:	930f      	str	r3, [sp, #60]	; 0x3c
 8028c20:	4682      	mov	sl, r0
 8028c22:	468b      	mov	fp, r1
 8028c24:	4649      	mov	r1, r9
 8028c26:	4640      	mov	r0, r8
 8028c28:	f7e2 f8ee 	bl	800ae08 <__aeabi_d2iz>
 8028c2c:	4606      	mov	r6, r0
 8028c2e:	f7e1 fdd1 	bl	800a7d4 <__aeabi_i2d>
 8028c32:	3630      	adds	r6, #48	; 0x30
 8028c34:	4602      	mov	r2, r0
 8028c36:	460b      	mov	r3, r1
 8028c38:	4640      	mov	r0, r8
 8028c3a:	4649      	mov	r1, r9
 8028c3c:	f7e1 fc7c 	bl	800a538 <__aeabi_dsub>
 8028c40:	f805 6b01 	strb.w	r6, [r5], #1
 8028c44:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8028c46:	429d      	cmp	r5, r3
 8028c48:	4680      	mov	r8, r0
 8028c4a:	4689      	mov	r9, r1
 8028c4c:	f04f 0200 	mov.w	r2, #0
 8028c50:	d124      	bne.n	8028c9c <_dtoa_r+0x60c>
 8028c52:	4b1b      	ldr	r3, [pc, #108]	; (8028cc0 <_dtoa_r+0x630>)
 8028c54:	4650      	mov	r0, sl
 8028c56:	4659      	mov	r1, fp
 8028c58:	f7e1 fc70 	bl	800a53c <__adddf3>
 8028c5c:	4602      	mov	r2, r0
 8028c5e:	460b      	mov	r3, r1
 8028c60:	4640      	mov	r0, r8
 8028c62:	4649      	mov	r1, r9
 8028c64:	f7e2 f8b0 	bl	800adc8 <__aeabi_dcmpgt>
 8028c68:	2800      	cmp	r0, #0
 8028c6a:	d173      	bne.n	8028d54 <_dtoa_r+0x6c4>
 8028c6c:	4652      	mov	r2, sl
 8028c6e:	465b      	mov	r3, fp
 8028c70:	4913      	ldr	r1, [pc, #76]	; (8028cc0 <_dtoa_r+0x630>)
 8028c72:	2000      	movs	r0, #0
 8028c74:	f7e1 fc60 	bl	800a538 <__aeabi_dsub>
 8028c78:	4602      	mov	r2, r0
 8028c7a:	460b      	mov	r3, r1
 8028c7c:	4640      	mov	r0, r8
 8028c7e:	4649      	mov	r1, r9
 8028c80:	f7e2 f884 	bl	800ad8c <__aeabi_dcmplt>
 8028c84:	2800      	cmp	r0, #0
 8028c86:	f43f af35 	beq.w	8028af4 <_dtoa_r+0x464>
 8028c8a:	9d0f      	ldr	r5, [sp, #60]	; 0x3c
 8028c8c:	1e6b      	subs	r3, r5, #1
 8028c8e:	930f      	str	r3, [sp, #60]	; 0x3c
 8028c90:	f815 3c01 	ldrb.w	r3, [r5, #-1]
 8028c94:	2b30      	cmp	r3, #48	; 0x30
 8028c96:	d0f8      	beq.n	8028c8a <_dtoa_r+0x5fa>
 8028c98:	9700      	str	r7, [sp, #0]
 8028c9a:	e049      	b.n	8028d30 <_dtoa_r+0x6a0>
 8028c9c:	4b05      	ldr	r3, [pc, #20]	; (8028cb4 <_dtoa_r+0x624>)
 8028c9e:	f7e1 fe03 	bl	800a8a8 <__aeabi_dmul>
 8028ca2:	4680      	mov	r8, r0
 8028ca4:	4689      	mov	r9, r1
 8028ca6:	e7bd      	b.n	8028c24 <_dtoa_r+0x594>
 8028ca8:	08057c78 	.word	0x08057c78
 8028cac:	08057c50 	.word	0x08057c50
 8028cb0:	3ff00000 	.word	0x3ff00000
 8028cb4:	40240000 	.word	0x40240000
 8028cb8:	401c0000 	.word	0x401c0000
 8028cbc:	40140000 	.word	0x40140000
 8028cc0:	3fe00000 	.word	0x3fe00000
 8028cc4:	9d01      	ldr	r5, [sp, #4]
 8028cc6:	4656      	mov	r6, sl
 8028cc8:	465f      	mov	r7, fp
 8028cca:	4642      	mov	r2, r8
 8028ccc:	464b      	mov	r3, r9
 8028cce:	4630      	mov	r0, r6
 8028cd0:	4639      	mov	r1, r7
 8028cd2:	f7e1 ff13 	bl	800aafc <__aeabi_ddiv>
 8028cd6:	f7e2 f897 	bl	800ae08 <__aeabi_d2iz>
 8028cda:	4682      	mov	sl, r0
 8028cdc:	f7e1 fd7a 	bl	800a7d4 <__aeabi_i2d>
 8028ce0:	4642      	mov	r2, r8
 8028ce2:	464b      	mov	r3, r9
 8028ce4:	f7e1 fde0 	bl	800a8a8 <__aeabi_dmul>
 8028ce8:	4602      	mov	r2, r0
 8028cea:	460b      	mov	r3, r1
 8028cec:	4630      	mov	r0, r6
 8028cee:	4639      	mov	r1, r7
 8028cf0:	f10a 0630 	add.w	r6, sl, #48	; 0x30
 8028cf4:	f7e1 fc20 	bl	800a538 <__aeabi_dsub>
 8028cf8:	f805 6b01 	strb.w	r6, [r5], #1
 8028cfc:	9e01      	ldr	r6, [sp, #4]
 8028cfe:	9f03      	ldr	r7, [sp, #12]
 8028d00:	1bae      	subs	r6, r5, r6
 8028d02:	42b7      	cmp	r7, r6
 8028d04:	4602      	mov	r2, r0
 8028d06:	460b      	mov	r3, r1
 8028d08:	d135      	bne.n	8028d76 <_dtoa_r+0x6e6>
 8028d0a:	f7e1 fc17 	bl	800a53c <__adddf3>
 8028d0e:	4642      	mov	r2, r8
 8028d10:	464b      	mov	r3, r9
 8028d12:	4606      	mov	r6, r0
 8028d14:	460f      	mov	r7, r1
 8028d16:	f7e2 f857 	bl	800adc8 <__aeabi_dcmpgt>
 8028d1a:	b9d0      	cbnz	r0, 8028d52 <_dtoa_r+0x6c2>
 8028d1c:	4642      	mov	r2, r8
 8028d1e:	464b      	mov	r3, r9
 8028d20:	4630      	mov	r0, r6
 8028d22:	4639      	mov	r1, r7
 8028d24:	f7e2 f828 	bl	800ad78 <__aeabi_dcmpeq>
 8028d28:	b110      	cbz	r0, 8028d30 <_dtoa_r+0x6a0>
 8028d2a:	f01a 0f01 	tst.w	sl, #1
 8028d2e:	d110      	bne.n	8028d52 <_dtoa_r+0x6c2>
 8028d30:	4620      	mov	r0, r4
 8028d32:	ee18 1a10 	vmov	r1, s16
 8028d36:	f000 fb61 	bl	80293fc <_Bfree>
 8028d3a:	2300      	movs	r3, #0
 8028d3c:	9800      	ldr	r0, [sp, #0]
 8028d3e:	702b      	strb	r3, [r5, #0]
 8028d40:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8028d42:	3001      	adds	r0, #1
 8028d44:	6018      	str	r0, [r3, #0]
 8028d46:	9b21      	ldr	r3, [sp, #132]	; 0x84
 8028d48:	2b00      	cmp	r3, #0
 8028d4a:	f43f acf1 	beq.w	8028730 <_dtoa_r+0xa0>
 8028d4e:	601d      	str	r5, [r3, #0]
 8028d50:	e4ee      	b.n	8028730 <_dtoa_r+0xa0>
 8028d52:	9f00      	ldr	r7, [sp, #0]
 8028d54:	462b      	mov	r3, r5
 8028d56:	461d      	mov	r5, r3
 8028d58:	f813 2d01 	ldrb.w	r2, [r3, #-1]!
 8028d5c:	2a39      	cmp	r2, #57	; 0x39
 8028d5e:	d106      	bne.n	8028d6e <_dtoa_r+0x6de>
 8028d60:	9a01      	ldr	r2, [sp, #4]
 8028d62:	429a      	cmp	r2, r3
 8028d64:	d1f7      	bne.n	8028d56 <_dtoa_r+0x6c6>
 8028d66:	9901      	ldr	r1, [sp, #4]
 8028d68:	2230      	movs	r2, #48	; 0x30
 8028d6a:	3701      	adds	r7, #1
 8028d6c:	700a      	strb	r2, [r1, #0]
 8028d6e:	781a      	ldrb	r2, [r3, #0]
 8028d70:	3201      	adds	r2, #1
 8028d72:	701a      	strb	r2, [r3, #0]
 8028d74:	e790      	b.n	8028c98 <_dtoa_r+0x608>
 8028d76:	4ba6      	ldr	r3, [pc, #664]	; (8029010 <_dtoa_r+0x980>)
 8028d78:	2200      	movs	r2, #0
 8028d7a:	f7e1 fd95 	bl	800a8a8 <__aeabi_dmul>
 8028d7e:	2200      	movs	r2, #0
 8028d80:	2300      	movs	r3, #0
 8028d82:	4606      	mov	r6, r0
 8028d84:	460f      	mov	r7, r1
 8028d86:	f7e1 fff7 	bl	800ad78 <__aeabi_dcmpeq>
 8028d8a:	2800      	cmp	r0, #0
 8028d8c:	d09d      	beq.n	8028cca <_dtoa_r+0x63a>
 8028d8e:	e7cf      	b.n	8028d30 <_dtoa_r+0x6a0>
 8028d90:	9a08      	ldr	r2, [sp, #32]
 8028d92:	2a00      	cmp	r2, #0
 8028d94:	f000 80d7 	beq.w	8028f46 <_dtoa_r+0x8b6>
 8028d98:	9a06      	ldr	r2, [sp, #24]
 8028d9a:	2a01      	cmp	r2, #1
 8028d9c:	f300 80ba 	bgt.w	8028f14 <_dtoa_r+0x884>
 8028da0:	9a0e      	ldr	r2, [sp, #56]	; 0x38
 8028da2:	2a00      	cmp	r2, #0
 8028da4:	f000 80b2 	beq.w	8028f0c <_dtoa_r+0x87c>
 8028da8:	f203 4333 	addw	r3, r3, #1075	; 0x433
 8028dac:	9e07      	ldr	r6, [sp, #28]
 8028dae:	9d04      	ldr	r5, [sp, #16]
 8028db0:	9a04      	ldr	r2, [sp, #16]
 8028db2:	441a      	add	r2, r3
 8028db4:	9204      	str	r2, [sp, #16]
 8028db6:	9a05      	ldr	r2, [sp, #20]
 8028db8:	2101      	movs	r1, #1
 8028dba:	441a      	add	r2, r3
 8028dbc:	4620      	mov	r0, r4
 8028dbe:	9205      	str	r2, [sp, #20]
 8028dc0:	f000 fbd4 	bl	802956c <__i2b>
 8028dc4:	4607      	mov	r7, r0
 8028dc6:	2d00      	cmp	r5, #0
 8028dc8:	dd0c      	ble.n	8028de4 <_dtoa_r+0x754>
 8028dca:	9b05      	ldr	r3, [sp, #20]
 8028dcc:	2b00      	cmp	r3, #0
 8028dce:	dd09      	ble.n	8028de4 <_dtoa_r+0x754>
 8028dd0:	42ab      	cmp	r3, r5
 8028dd2:	9a04      	ldr	r2, [sp, #16]
 8028dd4:	bfa8      	it	ge
 8028dd6:	462b      	movge	r3, r5
 8028dd8:	1ad2      	subs	r2, r2, r3
 8028dda:	9204      	str	r2, [sp, #16]
 8028ddc:	9a05      	ldr	r2, [sp, #20]
 8028dde:	1aed      	subs	r5, r5, r3
 8028de0:	1ad3      	subs	r3, r2, r3
 8028de2:	9305      	str	r3, [sp, #20]
 8028de4:	9b07      	ldr	r3, [sp, #28]
 8028de6:	b31b      	cbz	r3, 8028e30 <_dtoa_r+0x7a0>
 8028de8:	9b08      	ldr	r3, [sp, #32]
 8028dea:	2b00      	cmp	r3, #0
 8028dec:	f000 80af 	beq.w	8028f4e <_dtoa_r+0x8be>
 8028df0:	2e00      	cmp	r6, #0
 8028df2:	dd13      	ble.n	8028e1c <_dtoa_r+0x78c>
 8028df4:	4639      	mov	r1, r7
 8028df6:	4632      	mov	r2, r6
 8028df8:	4620      	mov	r0, r4
 8028dfa:	f000 fc77 	bl	80296ec <__pow5mult>
 8028dfe:	ee18 2a10 	vmov	r2, s16
 8028e02:	4601      	mov	r1, r0
 8028e04:	4607      	mov	r7, r0
 8028e06:	4620      	mov	r0, r4
 8028e08:	f000 fbc6 	bl	8029598 <__multiply>
 8028e0c:	ee18 1a10 	vmov	r1, s16
 8028e10:	4680      	mov	r8, r0
 8028e12:	4620      	mov	r0, r4
 8028e14:	f000 faf2 	bl	80293fc <_Bfree>
 8028e18:	ee08 8a10 	vmov	s16, r8
 8028e1c:	9b07      	ldr	r3, [sp, #28]
 8028e1e:	1b9a      	subs	r2, r3, r6
 8028e20:	d006      	beq.n	8028e30 <_dtoa_r+0x7a0>
 8028e22:	ee18 1a10 	vmov	r1, s16
 8028e26:	4620      	mov	r0, r4
 8028e28:	f000 fc60 	bl	80296ec <__pow5mult>
 8028e2c:	ee08 0a10 	vmov	s16, r0
 8028e30:	2101      	movs	r1, #1
 8028e32:	4620      	mov	r0, r4
 8028e34:	f000 fb9a 	bl	802956c <__i2b>
 8028e38:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8028e3a:	2b00      	cmp	r3, #0
 8028e3c:	4606      	mov	r6, r0
 8028e3e:	f340 8088 	ble.w	8028f52 <_dtoa_r+0x8c2>
 8028e42:	461a      	mov	r2, r3
 8028e44:	4601      	mov	r1, r0
 8028e46:	4620      	mov	r0, r4
 8028e48:	f000 fc50 	bl	80296ec <__pow5mult>
 8028e4c:	9b06      	ldr	r3, [sp, #24]
 8028e4e:	2b01      	cmp	r3, #1
 8028e50:	4606      	mov	r6, r0
 8028e52:	f340 8081 	ble.w	8028f58 <_dtoa_r+0x8c8>
 8028e56:	f04f 0800 	mov.w	r8, #0
 8028e5a:	6933      	ldr	r3, [r6, #16]
 8028e5c:	eb06 0383 	add.w	r3, r6, r3, lsl #2
 8028e60:	6918      	ldr	r0, [r3, #16]
 8028e62:	f000 fb33 	bl	80294cc <__hi0bits>
 8028e66:	f1c0 0020 	rsb	r0, r0, #32
 8028e6a:	9b05      	ldr	r3, [sp, #20]
 8028e6c:	4418      	add	r0, r3
 8028e6e:	f010 001f 	ands.w	r0, r0, #31
 8028e72:	f000 8092 	beq.w	8028f9a <_dtoa_r+0x90a>
 8028e76:	f1c0 0320 	rsb	r3, r0, #32
 8028e7a:	2b04      	cmp	r3, #4
 8028e7c:	f340 808a 	ble.w	8028f94 <_dtoa_r+0x904>
 8028e80:	f1c0 001c 	rsb	r0, r0, #28
 8028e84:	9b04      	ldr	r3, [sp, #16]
 8028e86:	4403      	add	r3, r0
 8028e88:	9304      	str	r3, [sp, #16]
 8028e8a:	9b05      	ldr	r3, [sp, #20]
 8028e8c:	4403      	add	r3, r0
 8028e8e:	4405      	add	r5, r0
 8028e90:	9305      	str	r3, [sp, #20]
 8028e92:	9b04      	ldr	r3, [sp, #16]
 8028e94:	2b00      	cmp	r3, #0
 8028e96:	dd07      	ble.n	8028ea8 <_dtoa_r+0x818>
 8028e98:	ee18 1a10 	vmov	r1, s16
 8028e9c:	461a      	mov	r2, r3
 8028e9e:	4620      	mov	r0, r4
 8028ea0:	f000 fc7e 	bl	80297a0 <__lshift>
 8028ea4:	ee08 0a10 	vmov	s16, r0
 8028ea8:	9b05      	ldr	r3, [sp, #20]
 8028eaa:	2b00      	cmp	r3, #0
 8028eac:	dd05      	ble.n	8028eba <_dtoa_r+0x82a>
 8028eae:	4631      	mov	r1, r6
 8028eb0:	461a      	mov	r2, r3
 8028eb2:	4620      	mov	r0, r4
 8028eb4:	f000 fc74 	bl	80297a0 <__lshift>
 8028eb8:	4606      	mov	r6, r0
 8028eba:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8028ebc:	2b00      	cmp	r3, #0
 8028ebe:	d06e      	beq.n	8028f9e <_dtoa_r+0x90e>
 8028ec0:	ee18 0a10 	vmov	r0, s16
 8028ec4:	4631      	mov	r1, r6
 8028ec6:	f000 fcdb 	bl	8029880 <__mcmp>
 8028eca:	2800      	cmp	r0, #0
 8028ecc:	da67      	bge.n	8028f9e <_dtoa_r+0x90e>
 8028ece:	9b00      	ldr	r3, [sp, #0]
 8028ed0:	3b01      	subs	r3, #1
 8028ed2:	ee18 1a10 	vmov	r1, s16
 8028ed6:	9300      	str	r3, [sp, #0]
 8028ed8:	220a      	movs	r2, #10
 8028eda:	2300      	movs	r3, #0
 8028edc:	4620      	mov	r0, r4
 8028ede:	f000 faaf 	bl	8029440 <__multadd>
 8028ee2:	9b08      	ldr	r3, [sp, #32]
 8028ee4:	ee08 0a10 	vmov	s16, r0
 8028ee8:	2b00      	cmp	r3, #0
 8028eea:	f000 81b1 	beq.w	8029250 <_dtoa_r+0xbc0>
 8028eee:	2300      	movs	r3, #0
 8028ef0:	4639      	mov	r1, r7
 8028ef2:	220a      	movs	r2, #10
 8028ef4:	4620      	mov	r0, r4
 8028ef6:	f000 faa3 	bl	8029440 <__multadd>
 8028efa:	9b02      	ldr	r3, [sp, #8]
 8028efc:	2b00      	cmp	r3, #0
 8028efe:	4607      	mov	r7, r0
 8028f00:	f300 808e 	bgt.w	8029020 <_dtoa_r+0x990>
 8028f04:	9b06      	ldr	r3, [sp, #24]
 8028f06:	2b02      	cmp	r3, #2
 8028f08:	dc51      	bgt.n	8028fae <_dtoa_r+0x91e>
 8028f0a:	e089      	b.n	8029020 <_dtoa_r+0x990>
 8028f0c:	9b10      	ldr	r3, [sp, #64]	; 0x40
 8028f0e:	f1c3 0336 	rsb	r3, r3, #54	; 0x36
 8028f12:	e74b      	b.n	8028dac <_dtoa_r+0x71c>
 8028f14:	9b03      	ldr	r3, [sp, #12]
 8028f16:	1e5e      	subs	r6, r3, #1
 8028f18:	9b07      	ldr	r3, [sp, #28]
 8028f1a:	42b3      	cmp	r3, r6
 8028f1c:	bfbf      	itttt	lt
 8028f1e:	9b07      	ldrlt	r3, [sp, #28]
 8028f20:	9607      	strlt	r6, [sp, #28]
 8028f22:	1af2      	sublt	r2, r6, r3
 8028f24:	9b0a      	ldrlt	r3, [sp, #40]	; 0x28
 8028f26:	bfb6      	itet	lt
 8028f28:	189b      	addlt	r3, r3, r2
 8028f2a:	1b9e      	subge	r6, r3, r6
 8028f2c:	930a      	strlt	r3, [sp, #40]	; 0x28
 8028f2e:	9b03      	ldr	r3, [sp, #12]
 8028f30:	bfb8      	it	lt
 8028f32:	2600      	movlt	r6, #0
 8028f34:	2b00      	cmp	r3, #0
 8028f36:	bfb7      	itett	lt
 8028f38:	e9dd 2303 	ldrdlt	r2, r3, [sp, #12]
 8028f3c:	e9dd 3503 	ldrdge	r3, r5, [sp, #12]
 8028f40:	1a9d      	sublt	r5, r3, r2
 8028f42:	2300      	movlt	r3, #0
 8028f44:	e734      	b.n	8028db0 <_dtoa_r+0x720>
 8028f46:	9e07      	ldr	r6, [sp, #28]
 8028f48:	9d04      	ldr	r5, [sp, #16]
 8028f4a:	9f08      	ldr	r7, [sp, #32]
 8028f4c:	e73b      	b.n	8028dc6 <_dtoa_r+0x736>
 8028f4e:	9a07      	ldr	r2, [sp, #28]
 8028f50:	e767      	b.n	8028e22 <_dtoa_r+0x792>
 8028f52:	9b06      	ldr	r3, [sp, #24]
 8028f54:	2b01      	cmp	r3, #1
 8028f56:	dc18      	bgt.n	8028f8a <_dtoa_r+0x8fa>
 8028f58:	f1ba 0f00 	cmp.w	sl, #0
 8028f5c:	d115      	bne.n	8028f8a <_dtoa_r+0x8fa>
 8028f5e:	f3cb 0313 	ubfx	r3, fp, #0, #20
 8028f62:	b993      	cbnz	r3, 8028f8a <_dtoa_r+0x8fa>
 8028f64:	f02b 4300 	bic.w	r3, fp, #2147483648	; 0x80000000
 8028f68:	0d1b      	lsrs	r3, r3, #20
 8028f6a:	051b      	lsls	r3, r3, #20
 8028f6c:	b183      	cbz	r3, 8028f90 <_dtoa_r+0x900>
 8028f6e:	9b04      	ldr	r3, [sp, #16]
 8028f70:	3301      	adds	r3, #1
 8028f72:	9304      	str	r3, [sp, #16]
 8028f74:	9b05      	ldr	r3, [sp, #20]
 8028f76:	3301      	adds	r3, #1
 8028f78:	9305      	str	r3, [sp, #20]
 8028f7a:	f04f 0801 	mov.w	r8, #1
 8028f7e:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8028f80:	2b00      	cmp	r3, #0
 8028f82:	f47f af6a 	bne.w	8028e5a <_dtoa_r+0x7ca>
 8028f86:	2001      	movs	r0, #1
 8028f88:	e76f      	b.n	8028e6a <_dtoa_r+0x7da>
 8028f8a:	f04f 0800 	mov.w	r8, #0
 8028f8e:	e7f6      	b.n	8028f7e <_dtoa_r+0x8ee>
 8028f90:	4698      	mov	r8, r3
 8028f92:	e7f4      	b.n	8028f7e <_dtoa_r+0x8ee>
 8028f94:	f43f af7d 	beq.w	8028e92 <_dtoa_r+0x802>
 8028f98:	4618      	mov	r0, r3
 8028f9a:	301c      	adds	r0, #28
 8028f9c:	e772      	b.n	8028e84 <_dtoa_r+0x7f4>
 8028f9e:	9b03      	ldr	r3, [sp, #12]
 8028fa0:	2b00      	cmp	r3, #0
 8028fa2:	dc37      	bgt.n	8029014 <_dtoa_r+0x984>
 8028fa4:	9b06      	ldr	r3, [sp, #24]
 8028fa6:	2b02      	cmp	r3, #2
 8028fa8:	dd34      	ble.n	8029014 <_dtoa_r+0x984>
 8028faa:	9b03      	ldr	r3, [sp, #12]
 8028fac:	9302      	str	r3, [sp, #8]
 8028fae:	9b02      	ldr	r3, [sp, #8]
 8028fb0:	b96b      	cbnz	r3, 8028fce <_dtoa_r+0x93e>
 8028fb2:	4631      	mov	r1, r6
 8028fb4:	2205      	movs	r2, #5
 8028fb6:	4620      	mov	r0, r4
 8028fb8:	f000 fa42 	bl	8029440 <__multadd>
 8028fbc:	4601      	mov	r1, r0
 8028fbe:	4606      	mov	r6, r0
 8028fc0:	ee18 0a10 	vmov	r0, s16
 8028fc4:	f000 fc5c 	bl	8029880 <__mcmp>
 8028fc8:	2800      	cmp	r0, #0
 8028fca:	f73f adbb 	bgt.w	8028b44 <_dtoa_r+0x4b4>
 8028fce:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8028fd0:	9d01      	ldr	r5, [sp, #4]
 8028fd2:	43db      	mvns	r3, r3
 8028fd4:	9300      	str	r3, [sp, #0]
 8028fd6:	f04f 0800 	mov.w	r8, #0
 8028fda:	4631      	mov	r1, r6
 8028fdc:	4620      	mov	r0, r4
 8028fde:	f000 fa0d 	bl	80293fc <_Bfree>
 8028fe2:	2f00      	cmp	r7, #0
 8028fe4:	f43f aea4 	beq.w	8028d30 <_dtoa_r+0x6a0>
 8028fe8:	f1b8 0f00 	cmp.w	r8, #0
 8028fec:	d005      	beq.n	8028ffa <_dtoa_r+0x96a>
 8028fee:	45b8      	cmp	r8, r7
 8028ff0:	d003      	beq.n	8028ffa <_dtoa_r+0x96a>
 8028ff2:	4641      	mov	r1, r8
 8028ff4:	4620      	mov	r0, r4
 8028ff6:	f000 fa01 	bl	80293fc <_Bfree>
 8028ffa:	4639      	mov	r1, r7
 8028ffc:	4620      	mov	r0, r4
 8028ffe:	f000 f9fd 	bl	80293fc <_Bfree>
 8029002:	e695      	b.n	8028d30 <_dtoa_r+0x6a0>
 8029004:	2600      	movs	r6, #0
 8029006:	4637      	mov	r7, r6
 8029008:	e7e1      	b.n	8028fce <_dtoa_r+0x93e>
 802900a:	9700      	str	r7, [sp, #0]
 802900c:	4637      	mov	r7, r6
 802900e:	e599      	b.n	8028b44 <_dtoa_r+0x4b4>
 8029010:	40240000 	.word	0x40240000
 8029014:	9b08      	ldr	r3, [sp, #32]
 8029016:	2b00      	cmp	r3, #0
 8029018:	f000 80ca 	beq.w	80291b0 <_dtoa_r+0xb20>
 802901c:	9b03      	ldr	r3, [sp, #12]
 802901e:	9302      	str	r3, [sp, #8]
 8029020:	2d00      	cmp	r5, #0
 8029022:	dd05      	ble.n	8029030 <_dtoa_r+0x9a0>
 8029024:	4639      	mov	r1, r7
 8029026:	462a      	mov	r2, r5
 8029028:	4620      	mov	r0, r4
 802902a:	f000 fbb9 	bl	80297a0 <__lshift>
 802902e:	4607      	mov	r7, r0
 8029030:	f1b8 0f00 	cmp.w	r8, #0
 8029034:	d05b      	beq.n	80290ee <_dtoa_r+0xa5e>
 8029036:	6879      	ldr	r1, [r7, #4]
 8029038:	4620      	mov	r0, r4
 802903a:	f000 f99f 	bl	802937c <_Balloc>
 802903e:	4605      	mov	r5, r0
 8029040:	b928      	cbnz	r0, 802904e <_dtoa_r+0x9be>
 8029042:	4b87      	ldr	r3, [pc, #540]	; (8029260 <_dtoa_r+0xbd0>)
 8029044:	4602      	mov	r2, r0
 8029046:	f240 21ea 	movw	r1, #746	; 0x2ea
 802904a:	f7ff bb3b 	b.w	80286c4 <_dtoa_r+0x34>
 802904e:	693a      	ldr	r2, [r7, #16]
 8029050:	3202      	adds	r2, #2
 8029052:	0092      	lsls	r2, r2, #2
 8029054:	f107 010c 	add.w	r1, r7, #12
 8029058:	300c      	adds	r0, #12
 802905a:	f7fe fa65 	bl	8027528 <memcpy>
 802905e:	2201      	movs	r2, #1
 8029060:	4629      	mov	r1, r5
 8029062:	4620      	mov	r0, r4
 8029064:	f000 fb9c 	bl	80297a0 <__lshift>
 8029068:	9b01      	ldr	r3, [sp, #4]
 802906a:	f103 0901 	add.w	r9, r3, #1
 802906e:	e9dd 2301 	ldrd	r2, r3, [sp, #4]
 8029072:	4413      	add	r3, r2
 8029074:	9305      	str	r3, [sp, #20]
 8029076:	f00a 0301 	and.w	r3, sl, #1
 802907a:	46b8      	mov	r8, r7
 802907c:	9304      	str	r3, [sp, #16]
 802907e:	4607      	mov	r7, r0
 8029080:	4631      	mov	r1, r6
 8029082:	ee18 0a10 	vmov	r0, s16
 8029086:	f7ff fa75 	bl	8028574 <quorem>
 802908a:	4641      	mov	r1, r8
 802908c:	9002      	str	r0, [sp, #8]
 802908e:	f100 0a30 	add.w	sl, r0, #48	; 0x30
 8029092:	ee18 0a10 	vmov	r0, s16
 8029096:	f000 fbf3 	bl	8029880 <__mcmp>
 802909a:	463a      	mov	r2, r7
 802909c:	9003      	str	r0, [sp, #12]
 802909e:	4631      	mov	r1, r6
 80290a0:	4620      	mov	r0, r4
 80290a2:	f000 fc09 	bl	80298b8 <__mdiff>
 80290a6:	68c2      	ldr	r2, [r0, #12]
 80290a8:	f109 3bff 	add.w	fp, r9, #4294967295
 80290ac:	4605      	mov	r5, r0
 80290ae:	bb02      	cbnz	r2, 80290f2 <_dtoa_r+0xa62>
 80290b0:	4601      	mov	r1, r0
 80290b2:	ee18 0a10 	vmov	r0, s16
 80290b6:	f000 fbe3 	bl	8029880 <__mcmp>
 80290ba:	4602      	mov	r2, r0
 80290bc:	4629      	mov	r1, r5
 80290be:	4620      	mov	r0, r4
 80290c0:	9207      	str	r2, [sp, #28]
 80290c2:	f000 f99b 	bl	80293fc <_Bfree>
 80290c6:	e9dd 3206 	ldrd	r3, r2, [sp, #24]
 80290ca:	ea43 0102 	orr.w	r1, r3, r2
 80290ce:	9b04      	ldr	r3, [sp, #16]
 80290d0:	430b      	orrs	r3, r1
 80290d2:	464d      	mov	r5, r9
 80290d4:	d10f      	bne.n	80290f6 <_dtoa_r+0xa66>
 80290d6:	f1ba 0f39 	cmp.w	sl, #57	; 0x39
 80290da:	d02a      	beq.n	8029132 <_dtoa_r+0xaa2>
 80290dc:	9b03      	ldr	r3, [sp, #12]
 80290de:	2b00      	cmp	r3, #0
 80290e0:	dd02      	ble.n	80290e8 <_dtoa_r+0xa58>
 80290e2:	9b02      	ldr	r3, [sp, #8]
 80290e4:	f103 0a31 	add.w	sl, r3, #49	; 0x31
 80290e8:	f88b a000 	strb.w	sl, [fp]
 80290ec:	e775      	b.n	8028fda <_dtoa_r+0x94a>
 80290ee:	4638      	mov	r0, r7
 80290f0:	e7ba      	b.n	8029068 <_dtoa_r+0x9d8>
 80290f2:	2201      	movs	r2, #1
 80290f4:	e7e2      	b.n	80290bc <_dtoa_r+0xa2c>
 80290f6:	9b03      	ldr	r3, [sp, #12]
 80290f8:	2b00      	cmp	r3, #0
 80290fa:	db04      	blt.n	8029106 <_dtoa_r+0xa76>
 80290fc:	9906      	ldr	r1, [sp, #24]
 80290fe:	430b      	orrs	r3, r1
 8029100:	9904      	ldr	r1, [sp, #16]
 8029102:	430b      	orrs	r3, r1
 8029104:	d122      	bne.n	802914c <_dtoa_r+0xabc>
 8029106:	2a00      	cmp	r2, #0
 8029108:	ddee      	ble.n	80290e8 <_dtoa_r+0xa58>
 802910a:	ee18 1a10 	vmov	r1, s16
 802910e:	2201      	movs	r2, #1
 8029110:	4620      	mov	r0, r4
 8029112:	f000 fb45 	bl	80297a0 <__lshift>
 8029116:	4631      	mov	r1, r6
 8029118:	ee08 0a10 	vmov	s16, r0
 802911c:	f000 fbb0 	bl	8029880 <__mcmp>
 8029120:	2800      	cmp	r0, #0
 8029122:	dc03      	bgt.n	802912c <_dtoa_r+0xa9c>
 8029124:	d1e0      	bne.n	80290e8 <_dtoa_r+0xa58>
 8029126:	f01a 0f01 	tst.w	sl, #1
 802912a:	d0dd      	beq.n	80290e8 <_dtoa_r+0xa58>
 802912c:	f1ba 0f39 	cmp.w	sl, #57	; 0x39
 8029130:	d1d7      	bne.n	80290e2 <_dtoa_r+0xa52>
 8029132:	2339      	movs	r3, #57	; 0x39
 8029134:	f88b 3000 	strb.w	r3, [fp]
 8029138:	462b      	mov	r3, r5
 802913a:	461d      	mov	r5, r3
 802913c:	3b01      	subs	r3, #1
 802913e:	f815 2c01 	ldrb.w	r2, [r5, #-1]
 8029142:	2a39      	cmp	r2, #57	; 0x39
 8029144:	d071      	beq.n	802922a <_dtoa_r+0xb9a>
 8029146:	3201      	adds	r2, #1
 8029148:	701a      	strb	r2, [r3, #0]
 802914a:	e746      	b.n	8028fda <_dtoa_r+0x94a>
 802914c:	2a00      	cmp	r2, #0
 802914e:	dd07      	ble.n	8029160 <_dtoa_r+0xad0>
 8029150:	f1ba 0f39 	cmp.w	sl, #57	; 0x39
 8029154:	d0ed      	beq.n	8029132 <_dtoa_r+0xaa2>
 8029156:	f10a 0301 	add.w	r3, sl, #1
 802915a:	f88b 3000 	strb.w	r3, [fp]
 802915e:	e73c      	b.n	8028fda <_dtoa_r+0x94a>
 8029160:	9b05      	ldr	r3, [sp, #20]
 8029162:	f809 ac01 	strb.w	sl, [r9, #-1]
 8029166:	4599      	cmp	r9, r3
 8029168:	d047      	beq.n	80291fa <_dtoa_r+0xb6a>
 802916a:	ee18 1a10 	vmov	r1, s16
 802916e:	2300      	movs	r3, #0
 8029170:	220a      	movs	r2, #10
 8029172:	4620      	mov	r0, r4
 8029174:	f000 f964 	bl	8029440 <__multadd>
 8029178:	45b8      	cmp	r8, r7
 802917a:	ee08 0a10 	vmov	s16, r0
 802917e:	f04f 0300 	mov.w	r3, #0
 8029182:	f04f 020a 	mov.w	r2, #10
 8029186:	4641      	mov	r1, r8
 8029188:	4620      	mov	r0, r4
 802918a:	d106      	bne.n	802919a <_dtoa_r+0xb0a>
 802918c:	f000 f958 	bl	8029440 <__multadd>
 8029190:	4680      	mov	r8, r0
 8029192:	4607      	mov	r7, r0
 8029194:	f109 0901 	add.w	r9, r9, #1
 8029198:	e772      	b.n	8029080 <_dtoa_r+0x9f0>
 802919a:	f000 f951 	bl	8029440 <__multadd>
 802919e:	4639      	mov	r1, r7
 80291a0:	4680      	mov	r8, r0
 80291a2:	2300      	movs	r3, #0
 80291a4:	220a      	movs	r2, #10
 80291a6:	4620      	mov	r0, r4
 80291a8:	f000 f94a 	bl	8029440 <__multadd>
 80291ac:	4607      	mov	r7, r0
 80291ae:	e7f1      	b.n	8029194 <_dtoa_r+0xb04>
 80291b0:	9b03      	ldr	r3, [sp, #12]
 80291b2:	9302      	str	r3, [sp, #8]
 80291b4:	9d01      	ldr	r5, [sp, #4]
 80291b6:	ee18 0a10 	vmov	r0, s16
 80291ba:	4631      	mov	r1, r6
 80291bc:	f7ff f9da 	bl	8028574 <quorem>
 80291c0:	f100 0a30 	add.w	sl, r0, #48	; 0x30
 80291c4:	9b01      	ldr	r3, [sp, #4]
 80291c6:	f805 ab01 	strb.w	sl, [r5], #1
 80291ca:	1aea      	subs	r2, r5, r3
 80291cc:	9b02      	ldr	r3, [sp, #8]
 80291ce:	4293      	cmp	r3, r2
 80291d0:	dd09      	ble.n	80291e6 <_dtoa_r+0xb56>
 80291d2:	ee18 1a10 	vmov	r1, s16
 80291d6:	2300      	movs	r3, #0
 80291d8:	220a      	movs	r2, #10
 80291da:	4620      	mov	r0, r4
 80291dc:	f000 f930 	bl	8029440 <__multadd>
 80291e0:	ee08 0a10 	vmov	s16, r0
 80291e4:	e7e7      	b.n	80291b6 <_dtoa_r+0xb26>
 80291e6:	9b02      	ldr	r3, [sp, #8]
 80291e8:	2b00      	cmp	r3, #0
 80291ea:	bfc8      	it	gt
 80291ec:	461d      	movgt	r5, r3
 80291ee:	9b01      	ldr	r3, [sp, #4]
 80291f0:	bfd8      	it	le
 80291f2:	2501      	movle	r5, #1
 80291f4:	441d      	add	r5, r3
 80291f6:	f04f 0800 	mov.w	r8, #0
 80291fa:	ee18 1a10 	vmov	r1, s16
 80291fe:	2201      	movs	r2, #1
 8029200:	4620      	mov	r0, r4
 8029202:	f000 facd 	bl	80297a0 <__lshift>
 8029206:	4631      	mov	r1, r6
 8029208:	ee08 0a10 	vmov	s16, r0
 802920c:	f000 fb38 	bl	8029880 <__mcmp>
 8029210:	2800      	cmp	r0, #0
 8029212:	dc91      	bgt.n	8029138 <_dtoa_r+0xaa8>
 8029214:	d102      	bne.n	802921c <_dtoa_r+0xb8c>
 8029216:	f01a 0f01 	tst.w	sl, #1
 802921a:	d18d      	bne.n	8029138 <_dtoa_r+0xaa8>
 802921c:	462b      	mov	r3, r5
 802921e:	461d      	mov	r5, r3
 8029220:	f813 2d01 	ldrb.w	r2, [r3, #-1]!
 8029224:	2a30      	cmp	r2, #48	; 0x30
 8029226:	d0fa      	beq.n	802921e <_dtoa_r+0xb8e>
 8029228:	e6d7      	b.n	8028fda <_dtoa_r+0x94a>
 802922a:	9a01      	ldr	r2, [sp, #4]
 802922c:	429a      	cmp	r2, r3
 802922e:	d184      	bne.n	802913a <_dtoa_r+0xaaa>
 8029230:	9b00      	ldr	r3, [sp, #0]
 8029232:	3301      	adds	r3, #1
 8029234:	9300      	str	r3, [sp, #0]
 8029236:	2331      	movs	r3, #49	; 0x31
 8029238:	7013      	strb	r3, [r2, #0]
 802923a:	e6ce      	b.n	8028fda <_dtoa_r+0x94a>
 802923c:	4b09      	ldr	r3, [pc, #36]	; (8029264 <_dtoa_r+0xbd4>)
 802923e:	f7ff ba95 	b.w	802876c <_dtoa_r+0xdc>
 8029242:	9b21      	ldr	r3, [sp, #132]	; 0x84
 8029244:	2b00      	cmp	r3, #0
 8029246:	f47f aa6e 	bne.w	8028726 <_dtoa_r+0x96>
 802924a:	4b07      	ldr	r3, [pc, #28]	; (8029268 <_dtoa_r+0xbd8>)
 802924c:	f7ff ba8e 	b.w	802876c <_dtoa_r+0xdc>
 8029250:	9b02      	ldr	r3, [sp, #8]
 8029252:	2b00      	cmp	r3, #0
 8029254:	dcae      	bgt.n	80291b4 <_dtoa_r+0xb24>
 8029256:	9b06      	ldr	r3, [sp, #24]
 8029258:	2b02      	cmp	r3, #2
 802925a:	f73f aea8 	bgt.w	8028fae <_dtoa_r+0x91e>
 802925e:	e7a9      	b.n	80291b4 <_dtoa_r+0xb24>
 8029260:	08057bdc 	.word	0x08057bdc
 8029264:	08057a38 	.word	0x08057a38
 8029268:	08057b5d 	.word	0x08057b5d

0802926c <_localeconv_r>:
 802926c:	4800      	ldr	r0, [pc, #0]	; (8029270 <_localeconv_r+0x4>)
 802926e:	4770      	bx	lr
 8029270:	20002174 	.word	0x20002174

08029274 <_lseek_r>:
 8029274:	b538      	push	{r3, r4, r5, lr}
 8029276:	4d07      	ldr	r5, [pc, #28]	; (8029294 <_lseek_r+0x20>)
 8029278:	4604      	mov	r4, r0
 802927a:	4608      	mov	r0, r1
 802927c:	4611      	mov	r1, r2
 802927e:	2200      	movs	r2, #0
 8029280:	602a      	str	r2, [r5, #0]
 8029282:	461a      	mov	r2, r3
 8029284:	f7f4 f8ee 	bl	801d464 <_lseek>
 8029288:	1c43      	adds	r3, r0, #1
 802928a:	d102      	bne.n	8029292 <_lseek_r+0x1e>
 802928c:	682b      	ldr	r3, [r5, #0]
 802928e:	b103      	cbz	r3, 8029292 <_lseek_r+0x1e>
 8029290:	6023      	str	r3, [r4, #0]
 8029292:	bd38      	pop	{r3, r4, r5, pc}
 8029294:	20014fcc 	.word	0x20014fcc

08029298 <__swhatbuf_r>:
 8029298:	b570      	push	{r4, r5, r6, lr}
 802929a:	460e      	mov	r6, r1
 802929c:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 80292a0:	2900      	cmp	r1, #0
 80292a2:	b096      	sub	sp, #88	; 0x58
 80292a4:	4614      	mov	r4, r2
 80292a6:	461d      	mov	r5, r3
 80292a8:	da08      	bge.n	80292bc <__swhatbuf_r+0x24>
 80292aa:	f9b6 300c 	ldrsh.w	r3, [r6, #12]
 80292ae:	2200      	movs	r2, #0
 80292b0:	602a      	str	r2, [r5, #0]
 80292b2:	061a      	lsls	r2, r3, #24
 80292b4:	d410      	bmi.n	80292d8 <__swhatbuf_r+0x40>
 80292b6:	f44f 6380 	mov.w	r3, #1024	; 0x400
 80292ba:	e00e      	b.n	80292da <__swhatbuf_r+0x42>
 80292bc:	466a      	mov	r2, sp
 80292be:	f000 ff37 	bl	802a130 <_fstat_r>
 80292c2:	2800      	cmp	r0, #0
 80292c4:	dbf1      	blt.n	80292aa <__swhatbuf_r+0x12>
 80292c6:	9a01      	ldr	r2, [sp, #4]
 80292c8:	f402 4270 	and.w	r2, r2, #61440	; 0xf000
 80292cc:	f5a2 5300 	sub.w	r3, r2, #8192	; 0x2000
 80292d0:	425a      	negs	r2, r3
 80292d2:	415a      	adcs	r2, r3
 80292d4:	602a      	str	r2, [r5, #0]
 80292d6:	e7ee      	b.n	80292b6 <__swhatbuf_r+0x1e>
 80292d8:	2340      	movs	r3, #64	; 0x40
 80292da:	2000      	movs	r0, #0
 80292dc:	6023      	str	r3, [r4, #0]
 80292de:	b016      	add	sp, #88	; 0x58
 80292e0:	bd70      	pop	{r4, r5, r6, pc}
	...

080292e4 <__smakebuf_r>:
 80292e4:	898b      	ldrh	r3, [r1, #12]
 80292e6:	b573      	push	{r0, r1, r4, r5, r6, lr}
 80292e8:	079d      	lsls	r5, r3, #30
 80292ea:	4606      	mov	r6, r0
 80292ec:	460c      	mov	r4, r1
 80292ee:	d507      	bpl.n	8029300 <__smakebuf_r+0x1c>
 80292f0:	f104 0347 	add.w	r3, r4, #71	; 0x47
 80292f4:	6023      	str	r3, [r4, #0]
 80292f6:	6123      	str	r3, [r4, #16]
 80292f8:	2301      	movs	r3, #1
 80292fa:	6163      	str	r3, [r4, #20]
 80292fc:	b002      	add	sp, #8
 80292fe:	bd70      	pop	{r4, r5, r6, pc}
 8029300:	ab01      	add	r3, sp, #4
 8029302:	466a      	mov	r2, sp
 8029304:	f7ff ffc8 	bl	8029298 <__swhatbuf_r>
 8029308:	9900      	ldr	r1, [sp, #0]
 802930a:	4605      	mov	r5, r0
 802930c:	4630      	mov	r0, r6
 802930e:	f7fe f9a7 	bl	8027660 <_malloc_r>
 8029312:	b948      	cbnz	r0, 8029328 <__smakebuf_r+0x44>
 8029314:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 8029318:	059a      	lsls	r2, r3, #22
 802931a:	d4ef      	bmi.n	80292fc <__smakebuf_r+0x18>
 802931c:	f023 0303 	bic.w	r3, r3, #3
 8029320:	f043 0302 	orr.w	r3, r3, #2
 8029324:	81a3      	strh	r3, [r4, #12]
 8029326:	e7e3      	b.n	80292f0 <__smakebuf_r+0xc>
 8029328:	4b0d      	ldr	r3, [pc, #52]	; (8029360 <__smakebuf_r+0x7c>)
 802932a:	62b3      	str	r3, [r6, #40]	; 0x28
 802932c:	89a3      	ldrh	r3, [r4, #12]
 802932e:	6020      	str	r0, [r4, #0]
 8029330:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8029334:	81a3      	strh	r3, [r4, #12]
 8029336:	9b00      	ldr	r3, [sp, #0]
 8029338:	6163      	str	r3, [r4, #20]
 802933a:	9b01      	ldr	r3, [sp, #4]
 802933c:	6120      	str	r0, [r4, #16]
 802933e:	b15b      	cbz	r3, 8029358 <__smakebuf_r+0x74>
 8029340:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
 8029344:	4630      	mov	r0, r6
 8029346:	f000 ff05 	bl	802a154 <_isatty_r>
 802934a:	b128      	cbz	r0, 8029358 <__smakebuf_r+0x74>
 802934c:	89a3      	ldrh	r3, [r4, #12]
 802934e:	f023 0303 	bic.w	r3, r3, #3
 8029352:	f043 0301 	orr.w	r3, r3, #1
 8029356:	81a3      	strh	r3, [r4, #12]
 8029358:	89a0      	ldrh	r0, [r4, #12]
 802935a:	4305      	orrs	r5, r0
 802935c:	81a5      	strh	r5, [r4, #12]
 802935e:	e7cd      	b.n	80292fc <__smakebuf_r+0x18>
 8029360:	080272f5 	.word	0x080272f5

08029364 <__malloc_lock>:
 8029364:	4801      	ldr	r0, [pc, #4]	; (802936c <__malloc_lock+0x8>)
 8029366:	f7fe b8bc 	b.w	80274e2 <__retarget_lock_acquire_recursive>
 802936a:	bf00      	nop
 802936c:	20014fc0 	.word	0x20014fc0

08029370 <__malloc_unlock>:
 8029370:	4801      	ldr	r0, [pc, #4]	; (8029378 <__malloc_unlock+0x8>)
 8029372:	f7fe b8b7 	b.w	80274e4 <__retarget_lock_release_recursive>
 8029376:	bf00      	nop
 8029378:	20014fc0 	.word	0x20014fc0

0802937c <_Balloc>:
 802937c:	b570      	push	{r4, r5, r6, lr}
 802937e:	6a46      	ldr	r6, [r0, #36]	; 0x24
 8029380:	4604      	mov	r4, r0
 8029382:	460d      	mov	r5, r1
 8029384:	b976      	cbnz	r6, 80293a4 <_Balloc+0x28>
 8029386:	2010      	movs	r0, #16
 8029388:	f7fe f8ae 	bl	80274e8 <malloc>
 802938c:	4602      	mov	r2, r0
 802938e:	6260      	str	r0, [r4, #36]	; 0x24
 8029390:	b920      	cbnz	r0, 802939c <_Balloc+0x20>
 8029392:	4b18      	ldr	r3, [pc, #96]	; (80293f4 <_Balloc+0x78>)
 8029394:	4818      	ldr	r0, [pc, #96]	; (80293f8 <_Balloc+0x7c>)
 8029396:	2166      	movs	r1, #102	; 0x66
 8029398:	f000 fe9a 	bl	802a0d0 <__assert_func>
 802939c:	e9c0 6601 	strd	r6, r6, [r0, #4]
 80293a0:	6006      	str	r6, [r0, #0]
 80293a2:	60c6      	str	r6, [r0, #12]
 80293a4:	6a66      	ldr	r6, [r4, #36]	; 0x24
 80293a6:	68f3      	ldr	r3, [r6, #12]
 80293a8:	b183      	cbz	r3, 80293cc <_Balloc+0x50>
 80293aa:	6a63      	ldr	r3, [r4, #36]	; 0x24
 80293ac:	68db      	ldr	r3, [r3, #12]
 80293ae:	f853 0025 	ldr.w	r0, [r3, r5, lsl #2]
 80293b2:	b9b8      	cbnz	r0, 80293e4 <_Balloc+0x68>
 80293b4:	2101      	movs	r1, #1
 80293b6:	fa01 f605 	lsl.w	r6, r1, r5
 80293ba:	1d72      	adds	r2, r6, #5
 80293bc:	0092      	lsls	r2, r2, #2
 80293be:	4620      	mov	r0, r4
 80293c0:	f000 fb60 	bl	8029a84 <_calloc_r>
 80293c4:	b160      	cbz	r0, 80293e0 <_Balloc+0x64>
 80293c6:	e9c0 5601 	strd	r5, r6, [r0, #4]
 80293ca:	e00e      	b.n	80293ea <_Balloc+0x6e>
 80293cc:	2221      	movs	r2, #33	; 0x21
 80293ce:	2104      	movs	r1, #4
 80293d0:	4620      	mov	r0, r4
 80293d2:	f000 fb57 	bl	8029a84 <_calloc_r>
 80293d6:	6a63      	ldr	r3, [r4, #36]	; 0x24
 80293d8:	60f0      	str	r0, [r6, #12]
 80293da:	68db      	ldr	r3, [r3, #12]
 80293dc:	2b00      	cmp	r3, #0
 80293de:	d1e4      	bne.n	80293aa <_Balloc+0x2e>
 80293e0:	2000      	movs	r0, #0
 80293e2:	bd70      	pop	{r4, r5, r6, pc}
 80293e4:	6802      	ldr	r2, [r0, #0]
 80293e6:	f843 2025 	str.w	r2, [r3, r5, lsl #2]
 80293ea:	2300      	movs	r3, #0
 80293ec:	e9c0 3303 	strd	r3, r3, [r0, #12]
 80293f0:	e7f7      	b.n	80293e2 <_Balloc+0x66>
 80293f2:	bf00      	nop
 80293f4:	08057b6a 	.word	0x08057b6a
 80293f8:	08057bed 	.word	0x08057bed

080293fc <_Bfree>:
 80293fc:	b570      	push	{r4, r5, r6, lr}
 80293fe:	6a46      	ldr	r6, [r0, #36]	; 0x24
 8029400:	4605      	mov	r5, r0
 8029402:	460c      	mov	r4, r1
 8029404:	b976      	cbnz	r6, 8029424 <_Bfree+0x28>
 8029406:	2010      	movs	r0, #16
 8029408:	f7fe f86e 	bl	80274e8 <malloc>
 802940c:	4602      	mov	r2, r0
 802940e:	6268      	str	r0, [r5, #36]	; 0x24
 8029410:	b920      	cbnz	r0, 802941c <_Bfree+0x20>
 8029412:	4b09      	ldr	r3, [pc, #36]	; (8029438 <_Bfree+0x3c>)
 8029414:	4809      	ldr	r0, [pc, #36]	; (802943c <_Bfree+0x40>)
 8029416:	218a      	movs	r1, #138	; 0x8a
 8029418:	f000 fe5a 	bl	802a0d0 <__assert_func>
 802941c:	e9c0 6601 	strd	r6, r6, [r0, #4]
 8029420:	6006      	str	r6, [r0, #0]
 8029422:	60c6      	str	r6, [r0, #12]
 8029424:	b13c      	cbz	r4, 8029436 <_Bfree+0x3a>
 8029426:	6a6b      	ldr	r3, [r5, #36]	; 0x24
 8029428:	6862      	ldr	r2, [r4, #4]
 802942a:	68db      	ldr	r3, [r3, #12]
 802942c:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
 8029430:	6021      	str	r1, [r4, #0]
 8029432:	f843 4022 	str.w	r4, [r3, r2, lsl #2]
 8029436:	bd70      	pop	{r4, r5, r6, pc}
 8029438:	08057b6a 	.word	0x08057b6a
 802943c:	08057bed 	.word	0x08057bed

08029440 <__multadd>:
 8029440:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8029444:	690d      	ldr	r5, [r1, #16]
 8029446:	4607      	mov	r7, r0
 8029448:	460c      	mov	r4, r1
 802944a:	461e      	mov	r6, r3
 802944c:	f101 0c14 	add.w	ip, r1, #20
 8029450:	2000      	movs	r0, #0
 8029452:	f8dc 3000 	ldr.w	r3, [ip]
 8029456:	b299      	uxth	r1, r3
 8029458:	fb02 6101 	mla	r1, r2, r1, r6
 802945c:	0c1e      	lsrs	r6, r3, #16
 802945e:	0c0b      	lsrs	r3, r1, #16
 8029460:	fb02 3306 	mla	r3, r2, r6, r3
 8029464:	b289      	uxth	r1, r1
 8029466:	3001      	adds	r0, #1
 8029468:	eb01 4103 	add.w	r1, r1, r3, lsl #16
 802946c:	4285      	cmp	r5, r0
 802946e:	f84c 1b04 	str.w	r1, [ip], #4
 8029472:	ea4f 4613 	mov.w	r6, r3, lsr #16
 8029476:	dcec      	bgt.n	8029452 <__multadd+0x12>
 8029478:	b30e      	cbz	r6, 80294be <__multadd+0x7e>
 802947a:	68a3      	ldr	r3, [r4, #8]
 802947c:	42ab      	cmp	r3, r5
 802947e:	dc19      	bgt.n	80294b4 <__multadd+0x74>
 8029480:	6861      	ldr	r1, [r4, #4]
 8029482:	4638      	mov	r0, r7
 8029484:	3101      	adds	r1, #1
 8029486:	f7ff ff79 	bl	802937c <_Balloc>
 802948a:	4680      	mov	r8, r0
 802948c:	b928      	cbnz	r0, 802949a <__multadd+0x5a>
 802948e:	4602      	mov	r2, r0
 8029490:	4b0c      	ldr	r3, [pc, #48]	; (80294c4 <__multadd+0x84>)
 8029492:	480d      	ldr	r0, [pc, #52]	; (80294c8 <__multadd+0x88>)
 8029494:	21b5      	movs	r1, #181	; 0xb5
 8029496:	f000 fe1b 	bl	802a0d0 <__assert_func>
 802949a:	6922      	ldr	r2, [r4, #16]
 802949c:	3202      	adds	r2, #2
 802949e:	f104 010c 	add.w	r1, r4, #12
 80294a2:	0092      	lsls	r2, r2, #2
 80294a4:	300c      	adds	r0, #12
 80294a6:	f7fe f83f 	bl	8027528 <memcpy>
 80294aa:	4621      	mov	r1, r4
 80294ac:	4638      	mov	r0, r7
 80294ae:	f7ff ffa5 	bl	80293fc <_Bfree>
 80294b2:	4644      	mov	r4, r8
 80294b4:	eb04 0385 	add.w	r3, r4, r5, lsl #2
 80294b8:	3501      	adds	r5, #1
 80294ba:	615e      	str	r6, [r3, #20]
 80294bc:	6125      	str	r5, [r4, #16]
 80294be:	4620      	mov	r0, r4
 80294c0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 80294c4:	08057bdc 	.word	0x08057bdc
 80294c8:	08057bed 	.word	0x08057bed

080294cc <__hi0bits>:
 80294cc:	0c03      	lsrs	r3, r0, #16
 80294ce:	041b      	lsls	r3, r3, #16
 80294d0:	b9d3      	cbnz	r3, 8029508 <__hi0bits+0x3c>
 80294d2:	0400      	lsls	r0, r0, #16
 80294d4:	2310      	movs	r3, #16
 80294d6:	f010 4f7f 	tst.w	r0, #4278190080	; 0xff000000
 80294da:	bf04      	itt	eq
 80294dc:	0200      	lsleq	r0, r0, #8
 80294de:	3308      	addeq	r3, #8
 80294e0:	f010 4f70 	tst.w	r0, #4026531840	; 0xf0000000
 80294e4:	bf04      	itt	eq
 80294e6:	0100      	lsleq	r0, r0, #4
 80294e8:	3304      	addeq	r3, #4
 80294ea:	f010 4f40 	tst.w	r0, #3221225472	; 0xc0000000
 80294ee:	bf04      	itt	eq
 80294f0:	0080      	lsleq	r0, r0, #2
 80294f2:	3302      	addeq	r3, #2
 80294f4:	2800      	cmp	r0, #0
 80294f6:	db05      	blt.n	8029504 <__hi0bits+0x38>
 80294f8:	f010 4f80 	tst.w	r0, #1073741824	; 0x40000000
 80294fc:	f103 0301 	add.w	r3, r3, #1
 8029500:	bf08      	it	eq
 8029502:	2320      	moveq	r3, #32
 8029504:	4618      	mov	r0, r3
 8029506:	4770      	bx	lr
 8029508:	2300      	movs	r3, #0
 802950a:	e7e4      	b.n	80294d6 <__hi0bits+0xa>

0802950c <__lo0bits>:
 802950c:	6803      	ldr	r3, [r0, #0]
 802950e:	f013 0207 	ands.w	r2, r3, #7
 8029512:	4601      	mov	r1, r0
 8029514:	d00b      	beq.n	802952e <__lo0bits+0x22>
 8029516:	07da      	lsls	r2, r3, #31
 8029518:	d423      	bmi.n	8029562 <__lo0bits+0x56>
 802951a:	0798      	lsls	r0, r3, #30
 802951c:	bf49      	itett	mi
 802951e:	085b      	lsrmi	r3, r3, #1
 8029520:	089b      	lsrpl	r3, r3, #2
 8029522:	2001      	movmi	r0, #1
 8029524:	600b      	strmi	r3, [r1, #0]
 8029526:	bf5c      	itt	pl
 8029528:	600b      	strpl	r3, [r1, #0]
 802952a:	2002      	movpl	r0, #2
 802952c:	4770      	bx	lr
 802952e:	b298      	uxth	r0, r3
 8029530:	b9a8      	cbnz	r0, 802955e <__lo0bits+0x52>
 8029532:	0c1b      	lsrs	r3, r3, #16
 8029534:	2010      	movs	r0, #16
 8029536:	b2da      	uxtb	r2, r3
 8029538:	b90a      	cbnz	r2, 802953e <__lo0bits+0x32>
 802953a:	3008      	adds	r0, #8
 802953c:	0a1b      	lsrs	r3, r3, #8
 802953e:	071a      	lsls	r2, r3, #28
 8029540:	bf04      	itt	eq
 8029542:	091b      	lsreq	r3, r3, #4
 8029544:	3004      	addeq	r0, #4
 8029546:	079a      	lsls	r2, r3, #30
 8029548:	bf04      	itt	eq
 802954a:	089b      	lsreq	r3, r3, #2
 802954c:	3002      	addeq	r0, #2
 802954e:	07da      	lsls	r2, r3, #31
 8029550:	d403      	bmi.n	802955a <__lo0bits+0x4e>
 8029552:	085b      	lsrs	r3, r3, #1
 8029554:	f100 0001 	add.w	r0, r0, #1
 8029558:	d005      	beq.n	8029566 <__lo0bits+0x5a>
 802955a:	600b      	str	r3, [r1, #0]
 802955c:	4770      	bx	lr
 802955e:	4610      	mov	r0, r2
 8029560:	e7e9      	b.n	8029536 <__lo0bits+0x2a>
 8029562:	2000      	movs	r0, #0
 8029564:	4770      	bx	lr
 8029566:	2020      	movs	r0, #32
 8029568:	4770      	bx	lr
	...

0802956c <__i2b>:
 802956c:	b510      	push	{r4, lr}
 802956e:	460c      	mov	r4, r1
 8029570:	2101      	movs	r1, #1
 8029572:	f7ff ff03 	bl	802937c <_Balloc>
 8029576:	4602      	mov	r2, r0
 8029578:	b928      	cbnz	r0, 8029586 <__i2b+0x1a>
 802957a:	4b05      	ldr	r3, [pc, #20]	; (8029590 <__i2b+0x24>)
 802957c:	4805      	ldr	r0, [pc, #20]	; (8029594 <__i2b+0x28>)
 802957e:	f44f 71a0 	mov.w	r1, #320	; 0x140
 8029582:	f000 fda5 	bl	802a0d0 <__assert_func>
 8029586:	2301      	movs	r3, #1
 8029588:	6144      	str	r4, [r0, #20]
 802958a:	6103      	str	r3, [r0, #16]
 802958c:	bd10      	pop	{r4, pc}
 802958e:	bf00      	nop
 8029590:	08057bdc 	.word	0x08057bdc
 8029594:	08057bed 	.word	0x08057bed

08029598 <__multiply>:
 8029598:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 802959c:	4691      	mov	r9, r2
 802959e:	690a      	ldr	r2, [r1, #16]
 80295a0:	f8d9 3010 	ldr.w	r3, [r9, #16]
 80295a4:	429a      	cmp	r2, r3
 80295a6:	bfb8      	it	lt
 80295a8:	460b      	movlt	r3, r1
 80295aa:	460c      	mov	r4, r1
 80295ac:	bfbc      	itt	lt
 80295ae:	464c      	movlt	r4, r9
 80295b0:	4699      	movlt	r9, r3
 80295b2:	6927      	ldr	r7, [r4, #16]
 80295b4:	f8d9 a010 	ldr.w	sl, [r9, #16]
 80295b8:	68a3      	ldr	r3, [r4, #8]
 80295ba:	6861      	ldr	r1, [r4, #4]
 80295bc:	eb07 060a 	add.w	r6, r7, sl
 80295c0:	42b3      	cmp	r3, r6
 80295c2:	b085      	sub	sp, #20
 80295c4:	bfb8      	it	lt
 80295c6:	3101      	addlt	r1, #1
 80295c8:	f7ff fed8 	bl	802937c <_Balloc>
 80295cc:	b930      	cbnz	r0, 80295dc <__multiply+0x44>
 80295ce:	4602      	mov	r2, r0
 80295d0:	4b44      	ldr	r3, [pc, #272]	; (80296e4 <__multiply+0x14c>)
 80295d2:	4845      	ldr	r0, [pc, #276]	; (80296e8 <__multiply+0x150>)
 80295d4:	f240 115d 	movw	r1, #349	; 0x15d
 80295d8:	f000 fd7a 	bl	802a0d0 <__assert_func>
 80295dc:	f100 0514 	add.w	r5, r0, #20
 80295e0:	eb05 0886 	add.w	r8, r5, r6, lsl #2
 80295e4:	462b      	mov	r3, r5
 80295e6:	2200      	movs	r2, #0
 80295e8:	4543      	cmp	r3, r8
 80295ea:	d321      	bcc.n	8029630 <__multiply+0x98>
 80295ec:	f104 0314 	add.w	r3, r4, #20
 80295f0:	eb03 0787 	add.w	r7, r3, r7, lsl #2
 80295f4:	f109 0314 	add.w	r3, r9, #20
 80295f8:	eb03 028a 	add.w	r2, r3, sl, lsl #2
 80295fc:	9202      	str	r2, [sp, #8]
 80295fe:	1b3a      	subs	r2, r7, r4
 8029600:	3a15      	subs	r2, #21
 8029602:	f022 0203 	bic.w	r2, r2, #3
 8029606:	3204      	adds	r2, #4
 8029608:	f104 0115 	add.w	r1, r4, #21
 802960c:	428f      	cmp	r7, r1
 802960e:	bf38      	it	cc
 8029610:	2204      	movcc	r2, #4
 8029612:	9201      	str	r2, [sp, #4]
 8029614:	9a02      	ldr	r2, [sp, #8]
 8029616:	9303      	str	r3, [sp, #12]
 8029618:	429a      	cmp	r2, r3
 802961a:	d80c      	bhi.n	8029636 <__multiply+0x9e>
 802961c:	2e00      	cmp	r6, #0
 802961e:	dd03      	ble.n	8029628 <__multiply+0x90>
 8029620:	f858 3d04 	ldr.w	r3, [r8, #-4]!
 8029624:	2b00      	cmp	r3, #0
 8029626:	d05a      	beq.n	80296de <__multiply+0x146>
 8029628:	6106      	str	r6, [r0, #16]
 802962a:	b005      	add	sp, #20
 802962c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8029630:	f843 2b04 	str.w	r2, [r3], #4
 8029634:	e7d8      	b.n	80295e8 <__multiply+0x50>
 8029636:	f8b3 a000 	ldrh.w	sl, [r3]
 802963a:	f1ba 0f00 	cmp.w	sl, #0
 802963e:	d024      	beq.n	802968a <__multiply+0xf2>
 8029640:	f104 0e14 	add.w	lr, r4, #20
 8029644:	46a9      	mov	r9, r5
 8029646:	f04f 0c00 	mov.w	ip, #0
 802964a:	f85e 2b04 	ldr.w	r2, [lr], #4
 802964e:	f8d9 1000 	ldr.w	r1, [r9]
 8029652:	fa1f fb82 	uxth.w	fp, r2
 8029656:	b289      	uxth	r1, r1
 8029658:	fb0a 110b 	mla	r1, sl, fp, r1
 802965c:	ea4f 4b12 	mov.w	fp, r2, lsr #16
 8029660:	f8d9 2000 	ldr.w	r2, [r9]
 8029664:	4461      	add	r1, ip
 8029666:	ea4f 4c12 	mov.w	ip, r2, lsr #16
 802966a:	fb0a c20b 	mla	r2, sl, fp, ip
 802966e:	eb02 4211 	add.w	r2, r2, r1, lsr #16
 8029672:	b289      	uxth	r1, r1
 8029674:	ea41 4102 	orr.w	r1, r1, r2, lsl #16
 8029678:	4577      	cmp	r7, lr
 802967a:	f849 1b04 	str.w	r1, [r9], #4
 802967e:	ea4f 4c12 	mov.w	ip, r2, lsr #16
 8029682:	d8e2      	bhi.n	802964a <__multiply+0xb2>
 8029684:	9a01      	ldr	r2, [sp, #4]
 8029686:	f845 c002 	str.w	ip, [r5, r2]
 802968a:	9a03      	ldr	r2, [sp, #12]
 802968c:	f8b2 9002 	ldrh.w	r9, [r2, #2]
 8029690:	3304      	adds	r3, #4
 8029692:	f1b9 0f00 	cmp.w	r9, #0
 8029696:	d020      	beq.n	80296da <__multiply+0x142>
 8029698:	6829      	ldr	r1, [r5, #0]
 802969a:	f104 0c14 	add.w	ip, r4, #20
 802969e:	46ae      	mov	lr, r5
 80296a0:	f04f 0a00 	mov.w	sl, #0
 80296a4:	f8bc b000 	ldrh.w	fp, [ip]
 80296a8:	f8be 2002 	ldrh.w	r2, [lr, #2]
 80296ac:	fb09 220b 	mla	r2, r9, fp, r2
 80296b0:	4492      	add	sl, r2
 80296b2:	b289      	uxth	r1, r1
 80296b4:	ea41 410a 	orr.w	r1, r1, sl, lsl #16
 80296b8:	f84e 1b04 	str.w	r1, [lr], #4
 80296bc:	f85c 2b04 	ldr.w	r2, [ip], #4
 80296c0:	f8be 1000 	ldrh.w	r1, [lr]
 80296c4:	0c12      	lsrs	r2, r2, #16
 80296c6:	fb09 1102 	mla	r1, r9, r2, r1
 80296ca:	eb01 411a 	add.w	r1, r1, sl, lsr #16
 80296ce:	4567      	cmp	r7, ip
 80296d0:	ea4f 4a11 	mov.w	sl, r1, lsr #16
 80296d4:	d8e6      	bhi.n	80296a4 <__multiply+0x10c>
 80296d6:	9a01      	ldr	r2, [sp, #4]
 80296d8:	50a9      	str	r1, [r5, r2]
 80296da:	3504      	adds	r5, #4
 80296dc:	e79a      	b.n	8029614 <__multiply+0x7c>
 80296de:	3e01      	subs	r6, #1
 80296e0:	e79c      	b.n	802961c <__multiply+0x84>
 80296e2:	bf00      	nop
 80296e4:	08057bdc 	.word	0x08057bdc
 80296e8:	08057bed 	.word	0x08057bed

080296ec <__pow5mult>:
 80296ec:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 80296f0:	4615      	mov	r5, r2
 80296f2:	f012 0203 	ands.w	r2, r2, #3
 80296f6:	4606      	mov	r6, r0
 80296f8:	460f      	mov	r7, r1
 80296fa:	d007      	beq.n	802970c <__pow5mult+0x20>
 80296fc:	4c25      	ldr	r4, [pc, #148]	; (8029794 <__pow5mult+0xa8>)
 80296fe:	3a01      	subs	r2, #1
 8029700:	2300      	movs	r3, #0
 8029702:	f854 2022 	ldr.w	r2, [r4, r2, lsl #2]
 8029706:	f7ff fe9b 	bl	8029440 <__multadd>
 802970a:	4607      	mov	r7, r0
 802970c:	10ad      	asrs	r5, r5, #2
 802970e:	d03d      	beq.n	802978c <__pow5mult+0xa0>
 8029710:	6a74      	ldr	r4, [r6, #36]	; 0x24
 8029712:	b97c      	cbnz	r4, 8029734 <__pow5mult+0x48>
 8029714:	2010      	movs	r0, #16
 8029716:	f7fd fee7 	bl	80274e8 <malloc>
 802971a:	4602      	mov	r2, r0
 802971c:	6270      	str	r0, [r6, #36]	; 0x24
 802971e:	b928      	cbnz	r0, 802972c <__pow5mult+0x40>
 8029720:	4b1d      	ldr	r3, [pc, #116]	; (8029798 <__pow5mult+0xac>)
 8029722:	481e      	ldr	r0, [pc, #120]	; (802979c <__pow5mult+0xb0>)
 8029724:	f44f 71d7 	mov.w	r1, #430	; 0x1ae
 8029728:	f000 fcd2 	bl	802a0d0 <__assert_func>
 802972c:	e9c0 4401 	strd	r4, r4, [r0, #4]
 8029730:	6004      	str	r4, [r0, #0]
 8029732:	60c4      	str	r4, [r0, #12]
 8029734:	f8d6 8024 	ldr.w	r8, [r6, #36]	; 0x24
 8029738:	f8d8 4008 	ldr.w	r4, [r8, #8]
 802973c:	b94c      	cbnz	r4, 8029752 <__pow5mult+0x66>
 802973e:	f240 2171 	movw	r1, #625	; 0x271
 8029742:	4630      	mov	r0, r6
 8029744:	f7ff ff12 	bl	802956c <__i2b>
 8029748:	2300      	movs	r3, #0
 802974a:	f8c8 0008 	str.w	r0, [r8, #8]
 802974e:	4604      	mov	r4, r0
 8029750:	6003      	str	r3, [r0, #0]
 8029752:	f04f 0900 	mov.w	r9, #0
 8029756:	07eb      	lsls	r3, r5, #31
 8029758:	d50a      	bpl.n	8029770 <__pow5mult+0x84>
 802975a:	4639      	mov	r1, r7
 802975c:	4622      	mov	r2, r4
 802975e:	4630      	mov	r0, r6
 8029760:	f7ff ff1a 	bl	8029598 <__multiply>
 8029764:	4639      	mov	r1, r7
 8029766:	4680      	mov	r8, r0
 8029768:	4630      	mov	r0, r6
 802976a:	f7ff fe47 	bl	80293fc <_Bfree>
 802976e:	4647      	mov	r7, r8
 8029770:	106d      	asrs	r5, r5, #1
 8029772:	d00b      	beq.n	802978c <__pow5mult+0xa0>
 8029774:	6820      	ldr	r0, [r4, #0]
 8029776:	b938      	cbnz	r0, 8029788 <__pow5mult+0x9c>
 8029778:	4622      	mov	r2, r4
 802977a:	4621      	mov	r1, r4
 802977c:	4630      	mov	r0, r6
 802977e:	f7ff ff0b 	bl	8029598 <__multiply>
 8029782:	6020      	str	r0, [r4, #0]
 8029784:	f8c0 9000 	str.w	r9, [r0]
 8029788:	4604      	mov	r4, r0
 802978a:	e7e4      	b.n	8029756 <__pow5mult+0x6a>
 802978c:	4638      	mov	r0, r7
 802978e:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 8029792:	bf00      	nop
 8029794:	08057d40 	.word	0x08057d40
 8029798:	08057b6a 	.word	0x08057b6a
 802979c:	08057bed 	.word	0x08057bed

080297a0 <__lshift>:
 80297a0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 80297a4:	460c      	mov	r4, r1
 80297a6:	6849      	ldr	r1, [r1, #4]
 80297a8:	6923      	ldr	r3, [r4, #16]
 80297aa:	eb03 1862 	add.w	r8, r3, r2, asr #5
 80297ae:	68a3      	ldr	r3, [r4, #8]
 80297b0:	4607      	mov	r7, r0
 80297b2:	4691      	mov	r9, r2
 80297b4:	ea4f 1a62 	mov.w	sl, r2, asr #5
 80297b8:	f108 0601 	add.w	r6, r8, #1
 80297bc:	42b3      	cmp	r3, r6
 80297be:	db0b      	blt.n	80297d8 <__lshift+0x38>
 80297c0:	4638      	mov	r0, r7
 80297c2:	f7ff fddb 	bl	802937c <_Balloc>
 80297c6:	4605      	mov	r5, r0
 80297c8:	b948      	cbnz	r0, 80297de <__lshift+0x3e>
 80297ca:	4602      	mov	r2, r0
 80297cc:	4b2a      	ldr	r3, [pc, #168]	; (8029878 <__lshift+0xd8>)
 80297ce:	482b      	ldr	r0, [pc, #172]	; (802987c <__lshift+0xdc>)
 80297d0:	f240 11d9 	movw	r1, #473	; 0x1d9
 80297d4:	f000 fc7c 	bl	802a0d0 <__assert_func>
 80297d8:	3101      	adds	r1, #1
 80297da:	005b      	lsls	r3, r3, #1
 80297dc:	e7ee      	b.n	80297bc <__lshift+0x1c>
 80297de:	2300      	movs	r3, #0
 80297e0:	f100 0114 	add.w	r1, r0, #20
 80297e4:	f100 0210 	add.w	r2, r0, #16
 80297e8:	4618      	mov	r0, r3
 80297ea:	4553      	cmp	r3, sl
 80297ec:	db37      	blt.n	802985e <__lshift+0xbe>
 80297ee:	6920      	ldr	r0, [r4, #16]
 80297f0:	ea2a 7aea 	bic.w	sl, sl, sl, asr #31
 80297f4:	f104 0314 	add.w	r3, r4, #20
 80297f8:	f019 091f 	ands.w	r9, r9, #31
 80297fc:	eb01 018a 	add.w	r1, r1, sl, lsl #2
 8029800:	eb03 0080 	add.w	r0, r3, r0, lsl #2
 8029804:	d02f      	beq.n	8029866 <__lshift+0xc6>
 8029806:	f1c9 0e20 	rsb	lr, r9, #32
 802980a:	468a      	mov	sl, r1
 802980c:	f04f 0c00 	mov.w	ip, #0
 8029810:	681a      	ldr	r2, [r3, #0]
 8029812:	fa02 f209 	lsl.w	r2, r2, r9
 8029816:	ea42 020c 	orr.w	r2, r2, ip
 802981a:	f84a 2b04 	str.w	r2, [sl], #4
 802981e:	f853 2b04 	ldr.w	r2, [r3], #4
 8029822:	4298      	cmp	r0, r3
 8029824:	fa22 fc0e 	lsr.w	ip, r2, lr
 8029828:	d8f2      	bhi.n	8029810 <__lshift+0x70>
 802982a:	1b03      	subs	r3, r0, r4
 802982c:	3b15      	subs	r3, #21
 802982e:	f023 0303 	bic.w	r3, r3, #3
 8029832:	3304      	adds	r3, #4
 8029834:	f104 0215 	add.w	r2, r4, #21
 8029838:	4290      	cmp	r0, r2
 802983a:	bf38      	it	cc
 802983c:	2304      	movcc	r3, #4
 802983e:	f841 c003 	str.w	ip, [r1, r3]
 8029842:	f1bc 0f00 	cmp.w	ip, #0
 8029846:	d001      	beq.n	802984c <__lshift+0xac>
 8029848:	f108 0602 	add.w	r6, r8, #2
 802984c:	3e01      	subs	r6, #1
 802984e:	4638      	mov	r0, r7
 8029850:	612e      	str	r6, [r5, #16]
 8029852:	4621      	mov	r1, r4
 8029854:	f7ff fdd2 	bl	80293fc <_Bfree>
 8029858:	4628      	mov	r0, r5
 802985a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 802985e:	f842 0f04 	str.w	r0, [r2, #4]!
 8029862:	3301      	adds	r3, #1
 8029864:	e7c1      	b.n	80297ea <__lshift+0x4a>
 8029866:	3904      	subs	r1, #4
 8029868:	f853 2b04 	ldr.w	r2, [r3], #4
 802986c:	f841 2f04 	str.w	r2, [r1, #4]!
 8029870:	4298      	cmp	r0, r3
 8029872:	d8f9      	bhi.n	8029868 <__lshift+0xc8>
 8029874:	e7ea      	b.n	802984c <__lshift+0xac>
 8029876:	bf00      	nop
 8029878:	08057bdc 	.word	0x08057bdc
 802987c:	08057bed 	.word	0x08057bed

08029880 <__mcmp>:
 8029880:	b530      	push	{r4, r5, lr}
 8029882:	6902      	ldr	r2, [r0, #16]
 8029884:	690c      	ldr	r4, [r1, #16]
 8029886:	1b12      	subs	r2, r2, r4
 8029888:	d10e      	bne.n	80298a8 <__mcmp+0x28>
 802988a:	f100 0314 	add.w	r3, r0, #20
 802988e:	3114      	adds	r1, #20
 8029890:	eb03 0084 	add.w	r0, r3, r4, lsl #2
 8029894:	eb01 0184 	add.w	r1, r1, r4, lsl #2
 8029898:	f850 5d04 	ldr.w	r5, [r0, #-4]!
 802989c:	f851 4d04 	ldr.w	r4, [r1, #-4]!
 80298a0:	42a5      	cmp	r5, r4
 80298a2:	d003      	beq.n	80298ac <__mcmp+0x2c>
 80298a4:	d305      	bcc.n	80298b2 <__mcmp+0x32>
 80298a6:	2201      	movs	r2, #1
 80298a8:	4610      	mov	r0, r2
 80298aa:	bd30      	pop	{r4, r5, pc}
 80298ac:	4283      	cmp	r3, r0
 80298ae:	d3f3      	bcc.n	8029898 <__mcmp+0x18>
 80298b0:	e7fa      	b.n	80298a8 <__mcmp+0x28>
 80298b2:	f04f 32ff 	mov.w	r2, #4294967295
 80298b6:	e7f7      	b.n	80298a8 <__mcmp+0x28>

080298b8 <__mdiff>:
 80298b8:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80298bc:	460c      	mov	r4, r1
 80298be:	4606      	mov	r6, r0
 80298c0:	4611      	mov	r1, r2
 80298c2:	4620      	mov	r0, r4
 80298c4:	4690      	mov	r8, r2
 80298c6:	f7ff ffdb 	bl	8029880 <__mcmp>
 80298ca:	1e05      	subs	r5, r0, #0
 80298cc:	d110      	bne.n	80298f0 <__mdiff+0x38>
 80298ce:	4629      	mov	r1, r5
 80298d0:	4630      	mov	r0, r6
 80298d2:	f7ff fd53 	bl	802937c <_Balloc>
 80298d6:	b930      	cbnz	r0, 80298e6 <__mdiff+0x2e>
 80298d8:	4b3a      	ldr	r3, [pc, #232]	; (80299c4 <__mdiff+0x10c>)
 80298da:	4602      	mov	r2, r0
 80298dc:	f240 2132 	movw	r1, #562	; 0x232
 80298e0:	4839      	ldr	r0, [pc, #228]	; (80299c8 <__mdiff+0x110>)
 80298e2:	f000 fbf5 	bl	802a0d0 <__assert_func>
 80298e6:	2301      	movs	r3, #1
 80298e8:	e9c0 3504 	strd	r3, r5, [r0, #16]
 80298ec:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80298f0:	bfa4      	itt	ge
 80298f2:	4643      	movge	r3, r8
 80298f4:	46a0      	movge	r8, r4
 80298f6:	4630      	mov	r0, r6
 80298f8:	f8d8 1004 	ldr.w	r1, [r8, #4]
 80298fc:	bfa6      	itte	ge
 80298fe:	461c      	movge	r4, r3
 8029900:	2500      	movge	r5, #0
 8029902:	2501      	movlt	r5, #1
 8029904:	f7ff fd3a 	bl	802937c <_Balloc>
 8029908:	b920      	cbnz	r0, 8029914 <__mdiff+0x5c>
 802990a:	4b2e      	ldr	r3, [pc, #184]	; (80299c4 <__mdiff+0x10c>)
 802990c:	4602      	mov	r2, r0
 802990e:	f44f 7110 	mov.w	r1, #576	; 0x240
 8029912:	e7e5      	b.n	80298e0 <__mdiff+0x28>
 8029914:	f8d8 7010 	ldr.w	r7, [r8, #16]
 8029918:	6926      	ldr	r6, [r4, #16]
 802991a:	60c5      	str	r5, [r0, #12]
 802991c:	f104 0914 	add.w	r9, r4, #20
 8029920:	f108 0514 	add.w	r5, r8, #20
 8029924:	f100 0e14 	add.w	lr, r0, #20
 8029928:	eb05 0c87 	add.w	ip, r5, r7, lsl #2
 802992c:	eb09 0686 	add.w	r6, r9, r6, lsl #2
 8029930:	f108 0210 	add.w	r2, r8, #16
 8029934:	46f2      	mov	sl, lr
 8029936:	2100      	movs	r1, #0
 8029938:	f859 3b04 	ldr.w	r3, [r9], #4
 802993c:	f852 bf04 	ldr.w	fp, [r2, #4]!
 8029940:	fa1f f883 	uxth.w	r8, r3
 8029944:	fa11 f18b 	uxtah	r1, r1, fp
 8029948:	0c1b      	lsrs	r3, r3, #16
 802994a:	eba1 0808 	sub.w	r8, r1, r8
 802994e:	ebc3 431b 	rsb	r3, r3, fp, lsr #16
 8029952:	eb03 4328 	add.w	r3, r3, r8, asr #16
 8029956:	fa1f f888 	uxth.w	r8, r8
 802995a:	1419      	asrs	r1, r3, #16
 802995c:	454e      	cmp	r6, r9
 802995e:	ea48 4303 	orr.w	r3, r8, r3, lsl #16
 8029962:	f84a 3b04 	str.w	r3, [sl], #4
 8029966:	d8e7      	bhi.n	8029938 <__mdiff+0x80>
 8029968:	1b33      	subs	r3, r6, r4
 802996a:	3b15      	subs	r3, #21
 802996c:	f023 0303 	bic.w	r3, r3, #3
 8029970:	3304      	adds	r3, #4
 8029972:	3415      	adds	r4, #21
 8029974:	42a6      	cmp	r6, r4
 8029976:	bf38      	it	cc
 8029978:	2304      	movcc	r3, #4
 802997a:	441d      	add	r5, r3
 802997c:	4473      	add	r3, lr
 802997e:	469e      	mov	lr, r3
 8029980:	462e      	mov	r6, r5
 8029982:	4566      	cmp	r6, ip
 8029984:	d30e      	bcc.n	80299a4 <__mdiff+0xec>
 8029986:	f10c 0203 	add.w	r2, ip, #3
 802998a:	1b52      	subs	r2, r2, r5
 802998c:	f022 0203 	bic.w	r2, r2, #3
 8029990:	3d03      	subs	r5, #3
 8029992:	45ac      	cmp	ip, r5
 8029994:	bf38      	it	cc
 8029996:	2200      	movcc	r2, #0
 8029998:	441a      	add	r2, r3
 802999a:	f852 3d04 	ldr.w	r3, [r2, #-4]!
 802999e:	b17b      	cbz	r3, 80299c0 <__mdiff+0x108>
 80299a0:	6107      	str	r7, [r0, #16]
 80299a2:	e7a3      	b.n	80298ec <__mdiff+0x34>
 80299a4:	f856 8b04 	ldr.w	r8, [r6], #4
 80299a8:	fa11 f288 	uxtah	r2, r1, r8
 80299ac:	1414      	asrs	r4, r2, #16
 80299ae:	eb04 4418 	add.w	r4, r4, r8, lsr #16
 80299b2:	b292      	uxth	r2, r2
 80299b4:	ea42 4204 	orr.w	r2, r2, r4, lsl #16
 80299b8:	f84e 2b04 	str.w	r2, [lr], #4
 80299bc:	1421      	asrs	r1, r4, #16
 80299be:	e7e0      	b.n	8029982 <__mdiff+0xca>
 80299c0:	3f01      	subs	r7, #1
 80299c2:	e7ea      	b.n	802999a <__mdiff+0xe2>
 80299c4:	08057bdc 	.word	0x08057bdc
 80299c8:	08057bed 	.word	0x08057bed

080299cc <__d2b>:
 80299cc:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
 80299d0:	4689      	mov	r9, r1
 80299d2:	2101      	movs	r1, #1
 80299d4:	ec57 6b10 	vmov	r6, r7, d0
 80299d8:	4690      	mov	r8, r2
 80299da:	f7ff fccf 	bl	802937c <_Balloc>
 80299de:	4604      	mov	r4, r0
 80299e0:	b930      	cbnz	r0, 80299f0 <__d2b+0x24>
 80299e2:	4602      	mov	r2, r0
 80299e4:	4b25      	ldr	r3, [pc, #148]	; (8029a7c <__d2b+0xb0>)
 80299e6:	4826      	ldr	r0, [pc, #152]	; (8029a80 <__d2b+0xb4>)
 80299e8:	f240 310a 	movw	r1, #778	; 0x30a
 80299ec:	f000 fb70 	bl	802a0d0 <__assert_func>
 80299f0:	f3c7 550a 	ubfx	r5, r7, #20, #11
 80299f4:	f3c7 0313 	ubfx	r3, r7, #0, #20
 80299f8:	bb35      	cbnz	r5, 8029a48 <__d2b+0x7c>
 80299fa:	2e00      	cmp	r6, #0
 80299fc:	9301      	str	r3, [sp, #4]
 80299fe:	d028      	beq.n	8029a52 <__d2b+0x86>
 8029a00:	4668      	mov	r0, sp
 8029a02:	9600      	str	r6, [sp, #0]
 8029a04:	f7ff fd82 	bl	802950c <__lo0bits>
 8029a08:	9900      	ldr	r1, [sp, #0]
 8029a0a:	b300      	cbz	r0, 8029a4e <__d2b+0x82>
 8029a0c:	9a01      	ldr	r2, [sp, #4]
 8029a0e:	f1c0 0320 	rsb	r3, r0, #32
 8029a12:	fa02 f303 	lsl.w	r3, r2, r3
 8029a16:	430b      	orrs	r3, r1
 8029a18:	40c2      	lsrs	r2, r0
 8029a1a:	6163      	str	r3, [r4, #20]
 8029a1c:	9201      	str	r2, [sp, #4]
 8029a1e:	9b01      	ldr	r3, [sp, #4]
 8029a20:	61a3      	str	r3, [r4, #24]
 8029a22:	2b00      	cmp	r3, #0
 8029a24:	bf14      	ite	ne
 8029a26:	2202      	movne	r2, #2
 8029a28:	2201      	moveq	r2, #1
 8029a2a:	6122      	str	r2, [r4, #16]
 8029a2c:	b1d5      	cbz	r5, 8029a64 <__d2b+0x98>
 8029a2e:	f2a5 4533 	subw	r5, r5, #1075	; 0x433
 8029a32:	4405      	add	r5, r0
 8029a34:	f8c9 5000 	str.w	r5, [r9]
 8029a38:	f1c0 0035 	rsb	r0, r0, #53	; 0x35
 8029a3c:	f8c8 0000 	str.w	r0, [r8]
 8029a40:	4620      	mov	r0, r4
 8029a42:	b003      	add	sp, #12
 8029a44:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 8029a48:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
 8029a4c:	e7d5      	b.n	80299fa <__d2b+0x2e>
 8029a4e:	6161      	str	r1, [r4, #20]
 8029a50:	e7e5      	b.n	8029a1e <__d2b+0x52>
 8029a52:	a801      	add	r0, sp, #4
 8029a54:	f7ff fd5a 	bl	802950c <__lo0bits>
 8029a58:	9b01      	ldr	r3, [sp, #4]
 8029a5a:	6163      	str	r3, [r4, #20]
 8029a5c:	2201      	movs	r2, #1
 8029a5e:	6122      	str	r2, [r4, #16]
 8029a60:	3020      	adds	r0, #32
 8029a62:	e7e3      	b.n	8029a2c <__d2b+0x60>
 8029a64:	eb04 0382 	add.w	r3, r4, r2, lsl #2
 8029a68:	f2a0 4032 	subw	r0, r0, #1074	; 0x432
 8029a6c:	f8c9 0000 	str.w	r0, [r9]
 8029a70:	6918      	ldr	r0, [r3, #16]
 8029a72:	f7ff fd2b 	bl	80294cc <__hi0bits>
 8029a76:	ebc0 1042 	rsb	r0, r0, r2, lsl #5
 8029a7a:	e7df      	b.n	8029a3c <__d2b+0x70>
 8029a7c:	08057bdc 	.word	0x08057bdc
 8029a80:	08057bed 	.word	0x08057bed

08029a84 <_calloc_r>:
 8029a84:	b537      	push	{r0, r1, r2, r4, r5, lr}
 8029a86:	fba1 2402 	umull	r2, r4, r1, r2
 8029a8a:	b94c      	cbnz	r4, 8029aa0 <_calloc_r+0x1c>
 8029a8c:	4611      	mov	r1, r2
 8029a8e:	9201      	str	r2, [sp, #4]
 8029a90:	f7fd fde6 	bl	8027660 <_malloc_r>
 8029a94:	9a01      	ldr	r2, [sp, #4]
 8029a96:	4605      	mov	r5, r0
 8029a98:	b930      	cbnz	r0, 8029aa8 <_calloc_r+0x24>
 8029a9a:	4628      	mov	r0, r5
 8029a9c:	b003      	add	sp, #12
 8029a9e:	bd30      	pop	{r4, r5, pc}
 8029aa0:	220c      	movs	r2, #12
 8029aa2:	6002      	str	r2, [r0, #0]
 8029aa4:	2500      	movs	r5, #0
 8029aa6:	e7f8      	b.n	8029a9a <_calloc_r+0x16>
 8029aa8:	4621      	mov	r1, r4
 8029aaa:	f7fd fd65 	bl	8027578 <memset>
 8029aae:	e7f4      	b.n	8029a9a <_calloc_r+0x16>

08029ab0 <__ssputs_r>:
 8029ab0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8029ab4:	688e      	ldr	r6, [r1, #8]
 8029ab6:	429e      	cmp	r6, r3
 8029ab8:	4682      	mov	sl, r0
 8029aba:	460c      	mov	r4, r1
 8029abc:	4690      	mov	r8, r2
 8029abe:	461f      	mov	r7, r3
 8029ac0:	d838      	bhi.n	8029b34 <__ssputs_r+0x84>
 8029ac2:	898a      	ldrh	r2, [r1, #12]
 8029ac4:	f412 6f90 	tst.w	r2, #1152	; 0x480
 8029ac8:	d032      	beq.n	8029b30 <__ssputs_r+0x80>
 8029aca:	6825      	ldr	r5, [r4, #0]
 8029acc:	6909      	ldr	r1, [r1, #16]
 8029ace:	eba5 0901 	sub.w	r9, r5, r1
 8029ad2:	6965      	ldr	r5, [r4, #20]
 8029ad4:	eb05 0545 	add.w	r5, r5, r5, lsl #1
 8029ad8:	eb05 75d5 	add.w	r5, r5, r5, lsr #31
 8029adc:	3301      	adds	r3, #1
 8029ade:	444b      	add	r3, r9
 8029ae0:	106d      	asrs	r5, r5, #1
 8029ae2:	429d      	cmp	r5, r3
 8029ae4:	bf38      	it	cc
 8029ae6:	461d      	movcc	r5, r3
 8029ae8:	0553      	lsls	r3, r2, #21
 8029aea:	d531      	bpl.n	8029b50 <__ssputs_r+0xa0>
 8029aec:	4629      	mov	r1, r5
 8029aee:	f7fd fdb7 	bl	8027660 <_malloc_r>
 8029af2:	4606      	mov	r6, r0
 8029af4:	b950      	cbnz	r0, 8029b0c <__ssputs_r+0x5c>
 8029af6:	230c      	movs	r3, #12
 8029af8:	f8ca 3000 	str.w	r3, [sl]
 8029afc:	89a3      	ldrh	r3, [r4, #12]
 8029afe:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8029b02:	81a3      	strh	r3, [r4, #12]
 8029b04:	f04f 30ff 	mov.w	r0, #4294967295
 8029b08:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8029b0c:	6921      	ldr	r1, [r4, #16]
 8029b0e:	464a      	mov	r2, r9
 8029b10:	f7fd fd0a 	bl	8027528 <memcpy>
 8029b14:	89a3      	ldrh	r3, [r4, #12]
 8029b16:	f423 6390 	bic.w	r3, r3, #1152	; 0x480
 8029b1a:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8029b1e:	81a3      	strh	r3, [r4, #12]
 8029b20:	6126      	str	r6, [r4, #16]
 8029b22:	6165      	str	r5, [r4, #20]
 8029b24:	444e      	add	r6, r9
 8029b26:	eba5 0509 	sub.w	r5, r5, r9
 8029b2a:	6026      	str	r6, [r4, #0]
 8029b2c:	60a5      	str	r5, [r4, #8]
 8029b2e:	463e      	mov	r6, r7
 8029b30:	42be      	cmp	r6, r7
 8029b32:	d900      	bls.n	8029b36 <__ssputs_r+0x86>
 8029b34:	463e      	mov	r6, r7
 8029b36:	6820      	ldr	r0, [r4, #0]
 8029b38:	4632      	mov	r2, r6
 8029b3a:	4641      	mov	r1, r8
 8029b3c:	f7fd fd02 	bl	8027544 <memmove>
 8029b40:	68a3      	ldr	r3, [r4, #8]
 8029b42:	1b9b      	subs	r3, r3, r6
 8029b44:	60a3      	str	r3, [r4, #8]
 8029b46:	6823      	ldr	r3, [r4, #0]
 8029b48:	4433      	add	r3, r6
 8029b4a:	6023      	str	r3, [r4, #0]
 8029b4c:	2000      	movs	r0, #0
 8029b4e:	e7db      	b.n	8029b08 <__ssputs_r+0x58>
 8029b50:	462a      	mov	r2, r5
 8029b52:	f000 fb21 	bl	802a198 <_realloc_r>
 8029b56:	4606      	mov	r6, r0
 8029b58:	2800      	cmp	r0, #0
 8029b5a:	d1e1      	bne.n	8029b20 <__ssputs_r+0x70>
 8029b5c:	6921      	ldr	r1, [r4, #16]
 8029b5e:	4650      	mov	r0, sl
 8029b60:	f7fd fd12 	bl	8027588 <_free_r>
 8029b64:	e7c7      	b.n	8029af6 <__ssputs_r+0x46>
	...

08029b68 <_svfiprintf_r>:
 8029b68:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8029b6c:	4698      	mov	r8, r3
 8029b6e:	898b      	ldrh	r3, [r1, #12]
 8029b70:	061b      	lsls	r3, r3, #24
 8029b72:	b09d      	sub	sp, #116	; 0x74
 8029b74:	4607      	mov	r7, r0
 8029b76:	460d      	mov	r5, r1
 8029b78:	4614      	mov	r4, r2
 8029b7a:	d50e      	bpl.n	8029b9a <_svfiprintf_r+0x32>
 8029b7c:	690b      	ldr	r3, [r1, #16]
 8029b7e:	b963      	cbnz	r3, 8029b9a <_svfiprintf_r+0x32>
 8029b80:	2140      	movs	r1, #64	; 0x40
 8029b82:	f7fd fd6d 	bl	8027660 <_malloc_r>
 8029b86:	6028      	str	r0, [r5, #0]
 8029b88:	6128      	str	r0, [r5, #16]
 8029b8a:	b920      	cbnz	r0, 8029b96 <_svfiprintf_r+0x2e>
 8029b8c:	230c      	movs	r3, #12
 8029b8e:	603b      	str	r3, [r7, #0]
 8029b90:	f04f 30ff 	mov.w	r0, #4294967295
 8029b94:	e0d1      	b.n	8029d3a <_svfiprintf_r+0x1d2>
 8029b96:	2340      	movs	r3, #64	; 0x40
 8029b98:	616b      	str	r3, [r5, #20]
 8029b9a:	2300      	movs	r3, #0
 8029b9c:	9309      	str	r3, [sp, #36]	; 0x24
 8029b9e:	2320      	movs	r3, #32
 8029ba0:	f88d 3029 	strb.w	r3, [sp, #41]	; 0x29
 8029ba4:	f8cd 800c 	str.w	r8, [sp, #12]
 8029ba8:	2330      	movs	r3, #48	; 0x30
 8029baa:	f8df 81a8 	ldr.w	r8, [pc, #424]	; 8029d54 <_svfiprintf_r+0x1ec>
 8029bae:	f88d 302a 	strb.w	r3, [sp, #42]	; 0x2a
 8029bb2:	f04f 0901 	mov.w	r9, #1
 8029bb6:	4623      	mov	r3, r4
 8029bb8:	469a      	mov	sl, r3
 8029bba:	f813 2b01 	ldrb.w	r2, [r3], #1
 8029bbe:	b10a      	cbz	r2, 8029bc4 <_svfiprintf_r+0x5c>
 8029bc0:	2a25      	cmp	r2, #37	; 0x25
 8029bc2:	d1f9      	bne.n	8029bb8 <_svfiprintf_r+0x50>
 8029bc4:	ebba 0b04 	subs.w	fp, sl, r4
 8029bc8:	d00b      	beq.n	8029be2 <_svfiprintf_r+0x7a>
 8029bca:	465b      	mov	r3, fp
 8029bcc:	4622      	mov	r2, r4
 8029bce:	4629      	mov	r1, r5
 8029bd0:	4638      	mov	r0, r7
 8029bd2:	f7ff ff6d 	bl	8029ab0 <__ssputs_r>
 8029bd6:	3001      	adds	r0, #1
 8029bd8:	f000 80aa 	beq.w	8029d30 <_svfiprintf_r+0x1c8>
 8029bdc:	9a09      	ldr	r2, [sp, #36]	; 0x24
 8029bde:	445a      	add	r2, fp
 8029be0:	9209      	str	r2, [sp, #36]	; 0x24
 8029be2:	f89a 3000 	ldrb.w	r3, [sl]
 8029be6:	2b00      	cmp	r3, #0
 8029be8:	f000 80a2 	beq.w	8029d30 <_svfiprintf_r+0x1c8>
 8029bec:	2300      	movs	r3, #0
 8029bee:	f04f 32ff 	mov.w	r2, #4294967295
 8029bf2:	e9cd 2305 	strd	r2, r3, [sp, #20]
 8029bf6:	f10a 0a01 	add.w	sl, sl, #1
 8029bfa:	9304      	str	r3, [sp, #16]
 8029bfc:	9307      	str	r3, [sp, #28]
 8029bfe:	f88d 3053 	strb.w	r3, [sp, #83]	; 0x53
 8029c02:	931a      	str	r3, [sp, #104]	; 0x68
 8029c04:	4654      	mov	r4, sl
 8029c06:	2205      	movs	r2, #5
 8029c08:	f814 1b01 	ldrb.w	r1, [r4], #1
 8029c0c:	4851      	ldr	r0, [pc, #324]	; (8029d54 <_svfiprintf_r+0x1ec>)
 8029c0e:	f7e0 fc3f 	bl	800a490 <memchr>
 8029c12:	9a04      	ldr	r2, [sp, #16]
 8029c14:	b9d8      	cbnz	r0, 8029c4e <_svfiprintf_r+0xe6>
 8029c16:	06d0      	lsls	r0, r2, #27
 8029c18:	bf44      	itt	mi
 8029c1a:	2320      	movmi	r3, #32
 8029c1c:	f88d 3053 	strbmi.w	r3, [sp, #83]	; 0x53
 8029c20:	0711      	lsls	r1, r2, #28
 8029c22:	bf44      	itt	mi
 8029c24:	232b      	movmi	r3, #43	; 0x2b
 8029c26:	f88d 3053 	strbmi.w	r3, [sp, #83]	; 0x53
 8029c2a:	f89a 3000 	ldrb.w	r3, [sl]
 8029c2e:	2b2a      	cmp	r3, #42	; 0x2a
 8029c30:	d015      	beq.n	8029c5e <_svfiprintf_r+0xf6>
 8029c32:	9a07      	ldr	r2, [sp, #28]
 8029c34:	4654      	mov	r4, sl
 8029c36:	2000      	movs	r0, #0
 8029c38:	f04f 0c0a 	mov.w	ip, #10
 8029c3c:	4621      	mov	r1, r4
 8029c3e:	f811 3b01 	ldrb.w	r3, [r1], #1
 8029c42:	3b30      	subs	r3, #48	; 0x30
 8029c44:	2b09      	cmp	r3, #9
 8029c46:	d94e      	bls.n	8029ce6 <_svfiprintf_r+0x17e>
 8029c48:	b1b0      	cbz	r0, 8029c78 <_svfiprintf_r+0x110>
 8029c4a:	9207      	str	r2, [sp, #28]
 8029c4c:	e014      	b.n	8029c78 <_svfiprintf_r+0x110>
 8029c4e:	eba0 0308 	sub.w	r3, r0, r8
 8029c52:	fa09 f303 	lsl.w	r3, r9, r3
 8029c56:	4313      	orrs	r3, r2
 8029c58:	9304      	str	r3, [sp, #16]
 8029c5a:	46a2      	mov	sl, r4
 8029c5c:	e7d2      	b.n	8029c04 <_svfiprintf_r+0x9c>
 8029c5e:	9b03      	ldr	r3, [sp, #12]
 8029c60:	1d19      	adds	r1, r3, #4
 8029c62:	681b      	ldr	r3, [r3, #0]
 8029c64:	9103      	str	r1, [sp, #12]
 8029c66:	2b00      	cmp	r3, #0
 8029c68:	bfbb      	ittet	lt
 8029c6a:	425b      	neglt	r3, r3
 8029c6c:	f042 0202 	orrlt.w	r2, r2, #2
 8029c70:	9307      	strge	r3, [sp, #28]
 8029c72:	9307      	strlt	r3, [sp, #28]
 8029c74:	bfb8      	it	lt
 8029c76:	9204      	strlt	r2, [sp, #16]
 8029c78:	7823      	ldrb	r3, [r4, #0]
 8029c7a:	2b2e      	cmp	r3, #46	; 0x2e
 8029c7c:	d10c      	bne.n	8029c98 <_svfiprintf_r+0x130>
 8029c7e:	7863      	ldrb	r3, [r4, #1]
 8029c80:	2b2a      	cmp	r3, #42	; 0x2a
 8029c82:	d135      	bne.n	8029cf0 <_svfiprintf_r+0x188>
 8029c84:	9b03      	ldr	r3, [sp, #12]
 8029c86:	1d1a      	adds	r2, r3, #4
 8029c88:	681b      	ldr	r3, [r3, #0]
 8029c8a:	9203      	str	r2, [sp, #12]
 8029c8c:	2b00      	cmp	r3, #0
 8029c8e:	bfb8      	it	lt
 8029c90:	f04f 33ff 	movlt.w	r3, #4294967295
 8029c94:	3402      	adds	r4, #2
 8029c96:	9305      	str	r3, [sp, #20]
 8029c98:	f8df a0c8 	ldr.w	sl, [pc, #200]	; 8029d64 <_svfiprintf_r+0x1fc>
 8029c9c:	7821      	ldrb	r1, [r4, #0]
 8029c9e:	2203      	movs	r2, #3
 8029ca0:	4650      	mov	r0, sl
 8029ca2:	f7e0 fbf5 	bl	800a490 <memchr>
 8029ca6:	b140      	cbz	r0, 8029cba <_svfiprintf_r+0x152>
 8029ca8:	2340      	movs	r3, #64	; 0x40
 8029caa:	eba0 000a 	sub.w	r0, r0, sl
 8029cae:	fa03 f000 	lsl.w	r0, r3, r0
 8029cb2:	9b04      	ldr	r3, [sp, #16]
 8029cb4:	4303      	orrs	r3, r0
 8029cb6:	3401      	adds	r4, #1
 8029cb8:	9304      	str	r3, [sp, #16]
 8029cba:	f814 1b01 	ldrb.w	r1, [r4], #1
 8029cbe:	4826      	ldr	r0, [pc, #152]	; (8029d58 <_svfiprintf_r+0x1f0>)
 8029cc0:	f88d 1028 	strb.w	r1, [sp, #40]	; 0x28
 8029cc4:	2206      	movs	r2, #6
 8029cc6:	f7e0 fbe3 	bl	800a490 <memchr>
 8029cca:	2800      	cmp	r0, #0
 8029ccc:	d038      	beq.n	8029d40 <_svfiprintf_r+0x1d8>
 8029cce:	4b23      	ldr	r3, [pc, #140]	; (8029d5c <_svfiprintf_r+0x1f4>)
 8029cd0:	bb1b      	cbnz	r3, 8029d1a <_svfiprintf_r+0x1b2>
 8029cd2:	9b03      	ldr	r3, [sp, #12]
 8029cd4:	3307      	adds	r3, #7
 8029cd6:	f023 0307 	bic.w	r3, r3, #7
 8029cda:	3308      	adds	r3, #8
 8029cdc:	9303      	str	r3, [sp, #12]
 8029cde:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8029ce0:	4433      	add	r3, r6
 8029ce2:	9309      	str	r3, [sp, #36]	; 0x24
 8029ce4:	e767      	b.n	8029bb6 <_svfiprintf_r+0x4e>
 8029ce6:	fb0c 3202 	mla	r2, ip, r2, r3
 8029cea:	460c      	mov	r4, r1
 8029cec:	2001      	movs	r0, #1
 8029cee:	e7a5      	b.n	8029c3c <_svfiprintf_r+0xd4>
 8029cf0:	2300      	movs	r3, #0
 8029cf2:	3401      	adds	r4, #1
 8029cf4:	9305      	str	r3, [sp, #20]
 8029cf6:	4619      	mov	r1, r3
 8029cf8:	f04f 0c0a 	mov.w	ip, #10
 8029cfc:	4620      	mov	r0, r4
 8029cfe:	f810 2b01 	ldrb.w	r2, [r0], #1
 8029d02:	3a30      	subs	r2, #48	; 0x30
 8029d04:	2a09      	cmp	r2, #9
 8029d06:	d903      	bls.n	8029d10 <_svfiprintf_r+0x1a8>
 8029d08:	2b00      	cmp	r3, #0
 8029d0a:	d0c5      	beq.n	8029c98 <_svfiprintf_r+0x130>
 8029d0c:	9105      	str	r1, [sp, #20]
 8029d0e:	e7c3      	b.n	8029c98 <_svfiprintf_r+0x130>
 8029d10:	fb0c 2101 	mla	r1, ip, r1, r2
 8029d14:	4604      	mov	r4, r0
 8029d16:	2301      	movs	r3, #1
 8029d18:	e7f0      	b.n	8029cfc <_svfiprintf_r+0x194>
 8029d1a:	ab03      	add	r3, sp, #12
 8029d1c:	9300      	str	r3, [sp, #0]
 8029d1e:	462a      	mov	r2, r5
 8029d20:	4b0f      	ldr	r3, [pc, #60]	; (8029d60 <_svfiprintf_r+0x1f8>)
 8029d22:	a904      	add	r1, sp, #16
 8029d24:	4638      	mov	r0, r7
 8029d26:	f7fd fdaf 	bl	8027888 <_printf_float>
 8029d2a:	1c42      	adds	r2, r0, #1
 8029d2c:	4606      	mov	r6, r0
 8029d2e:	d1d6      	bne.n	8029cde <_svfiprintf_r+0x176>
 8029d30:	89ab      	ldrh	r3, [r5, #12]
 8029d32:	065b      	lsls	r3, r3, #25
 8029d34:	f53f af2c 	bmi.w	8029b90 <_svfiprintf_r+0x28>
 8029d38:	9809      	ldr	r0, [sp, #36]	; 0x24
 8029d3a:	b01d      	add	sp, #116	; 0x74
 8029d3c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8029d40:	ab03      	add	r3, sp, #12
 8029d42:	9300      	str	r3, [sp, #0]
 8029d44:	462a      	mov	r2, r5
 8029d46:	4b06      	ldr	r3, [pc, #24]	; (8029d60 <_svfiprintf_r+0x1f8>)
 8029d48:	a904      	add	r1, sp, #16
 8029d4a:	4638      	mov	r0, r7
 8029d4c:	f7fe f840 	bl	8027dd0 <_printf_i>
 8029d50:	e7eb      	b.n	8029d2a <_svfiprintf_r+0x1c2>
 8029d52:	bf00      	nop
 8029d54:	08057d4c 	.word	0x08057d4c
 8029d58:	08057d56 	.word	0x08057d56
 8029d5c:	08027889 	.word	0x08027889
 8029d60:	08029ab1 	.word	0x08029ab1
 8029d64:	08057d52 	.word	0x08057d52

08029d68 <__sfputc_r>:
 8029d68:	6893      	ldr	r3, [r2, #8]
 8029d6a:	3b01      	subs	r3, #1
 8029d6c:	2b00      	cmp	r3, #0
 8029d6e:	b410      	push	{r4}
 8029d70:	6093      	str	r3, [r2, #8]
 8029d72:	da08      	bge.n	8029d86 <__sfputc_r+0x1e>
 8029d74:	6994      	ldr	r4, [r2, #24]
 8029d76:	42a3      	cmp	r3, r4
 8029d78:	db01      	blt.n	8029d7e <__sfputc_r+0x16>
 8029d7a:	290a      	cmp	r1, #10
 8029d7c:	d103      	bne.n	8029d86 <__sfputc_r+0x1e>
 8029d7e:	f85d 4b04 	ldr.w	r4, [sp], #4
 8029d82:	f7fe bb15 	b.w	80283b0 <__swbuf_r>
 8029d86:	6813      	ldr	r3, [r2, #0]
 8029d88:	1c58      	adds	r0, r3, #1
 8029d8a:	6010      	str	r0, [r2, #0]
 8029d8c:	7019      	strb	r1, [r3, #0]
 8029d8e:	4608      	mov	r0, r1
 8029d90:	f85d 4b04 	ldr.w	r4, [sp], #4
 8029d94:	4770      	bx	lr

08029d96 <__sfputs_r>:
 8029d96:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8029d98:	4606      	mov	r6, r0
 8029d9a:	460f      	mov	r7, r1
 8029d9c:	4614      	mov	r4, r2
 8029d9e:	18d5      	adds	r5, r2, r3
 8029da0:	42ac      	cmp	r4, r5
 8029da2:	d101      	bne.n	8029da8 <__sfputs_r+0x12>
 8029da4:	2000      	movs	r0, #0
 8029da6:	e007      	b.n	8029db8 <__sfputs_r+0x22>
 8029da8:	f814 1b01 	ldrb.w	r1, [r4], #1
 8029dac:	463a      	mov	r2, r7
 8029dae:	4630      	mov	r0, r6
 8029db0:	f7ff ffda 	bl	8029d68 <__sfputc_r>
 8029db4:	1c43      	adds	r3, r0, #1
 8029db6:	d1f3      	bne.n	8029da0 <__sfputs_r+0xa>
 8029db8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	...

08029dbc <_vfiprintf_r>:
 8029dbc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8029dc0:	460d      	mov	r5, r1
 8029dc2:	b09d      	sub	sp, #116	; 0x74
 8029dc4:	4614      	mov	r4, r2
 8029dc6:	4698      	mov	r8, r3
 8029dc8:	4606      	mov	r6, r0
 8029dca:	b118      	cbz	r0, 8029dd4 <_vfiprintf_r+0x18>
 8029dcc:	6983      	ldr	r3, [r0, #24]
 8029dce:	b90b      	cbnz	r3, 8029dd4 <_vfiprintf_r+0x18>
 8029dd0:	f7fd fac4 	bl	802735c <__sinit>
 8029dd4:	4b89      	ldr	r3, [pc, #548]	; (8029ffc <_vfiprintf_r+0x240>)
 8029dd6:	429d      	cmp	r5, r3
 8029dd8:	d11b      	bne.n	8029e12 <_vfiprintf_r+0x56>
 8029dda:	6875      	ldr	r5, [r6, #4]
 8029ddc:	6e6b      	ldr	r3, [r5, #100]	; 0x64
 8029dde:	07d9      	lsls	r1, r3, #31
 8029de0:	d405      	bmi.n	8029dee <_vfiprintf_r+0x32>
 8029de2:	89ab      	ldrh	r3, [r5, #12]
 8029de4:	059a      	lsls	r2, r3, #22
 8029de6:	d402      	bmi.n	8029dee <_vfiprintf_r+0x32>
 8029de8:	6da8      	ldr	r0, [r5, #88]	; 0x58
 8029dea:	f7fd fb7a 	bl	80274e2 <__retarget_lock_acquire_recursive>
 8029dee:	89ab      	ldrh	r3, [r5, #12]
 8029df0:	071b      	lsls	r3, r3, #28
 8029df2:	d501      	bpl.n	8029df8 <_vfiprintf_r+0x3c>
 8029df4:	692b      	ldr	r3, [r5, #16]
 8029df6:	b9eb      	cbnz	r3, 8029e34 <_vfiprintf_r+0x78>
 8029df8:	4629      	mov	r1, r5
 8029dfa:	4630      	mov	r0, r6
 8029dfc:	f7fe fb3c 	bl	8028478 <__swsetup_r>
 8029e00:	b1c0      	cbz	r0, 8029e34 <_vfiprintf_r+0x78>
 8029e02:	6e6b      	ldr	r3, [r5, #100]	; 0x64
 8029e04:	07dc      	lsls	r4, r3, #31
 8029e06:	d50e      	bpl.n	8029e26 <_vfiprintf_r+0x6a>
 8029e08:	f04f 30ff 	mov.w	r0, #4294967295
 8029e0c:	b01d      	add	sp, #116	; 0x74
 8029e0e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8029e12:	4b7b      	ldr	r3, [pc, #492]	; (802a000 <_vfiprintf_r+0x244>)
 8029e14:	429d      	cmp	r5, r3
 8029e16:	d101      	bne.n	8029e1c <_vfiprintf_r+0x60>
 8029e18:	68b5      	ldr	r5, [r6, #8]
 8029e1a:	e7df      	b.n	8029ddc <_vfiprintf_r+0x20>
 8029e1c:	4b79      	ldr	r3, [pc, #484]	; (802a004 <_vfiprintf_r+0x248>)
 8029e1e:	429d      	cmp	r5, r3
 8029e20:	bf08      	it	eq
 8029e22:	68f5      	ldreq	r5, [r6, #12]
 8029e24:	e7da      	b.n	8029ddc <_vfiprintf_r+0x20>
 8029e26:	89ab      	ldrh	r3, [r5, #12]
 8029e28:	0598      	lsls	r0, r3, #22
 8029e2a:	d4ed      	bmi.n	8029e08 <_vfiprintf_r+0x4c>
 8029e2c:	6da8      	ldr	r0, [r5, #88]	; 0x58
 8029e2e:	f7fd fb59 	bl	80274e4 <__retarget_lock_release_recursive>
 8029e32:	e7e9      	b.n	8029e08 <_vfiprintf_r+0x4c>
 8029e34:	2300      	movs	r3, #0
 8029e36:	9309      	str	r3, [sp, #36]	; 0x24
 8029e38:	2320      	movs	r3, #32
 8029e3a:	f88d 3029 	strb.w	r3, [sp, #41]	; 0x29
 8029e3e:	f8cd 800c 	str.w	r8, [sp, #12]
 8029e42:	2330      	movs	r3, #48	; 0x30
 8029e44:	f8df 81c0 	ldr.w	r8, [pc, #448]	; 802a008 <_vfiprintf_r+0x24c>
 8029e48:	f88d 302a 	strb.w	r3, [sp, #42]	; 0x2a
 8029e4c:	f04f 0901 	mov.w	r9, #1
 8029e50:	4623      	mov	r3, r4
 8029e52:	469a      	mov	sl, r3
 8029e54:	f813 2b01 	ldrb.w	r2, [r3], #1
 8029e58:	b10a      	cbz	r2, 8029e5e <_vfiprintf_r+0xa2>
 8029e5a:	2a25      	cmp	r2, #37	; 0x25
 8029e5c:	d1f9      	bne.n	8029e52 <_vfiprintf_r+0x96>
 8029e5e:	ebba 0b04 	subs.w	fp, sl, r4
 8029e62:	d00b      	beq.n	8029e7c <_vfiprintf_r+0xc0>
 8029e64:	465b      	mov	r3, fp
 8029e66:	4622      	mov	r2, r4
 8029e68:	4629      	mov	r1, r5
 8029e6a:	4630      	mov	r0, r6
 8029e6c:	f7ff ff93 	bl	8029d96 <__sfputs_r>
 8029e70:	3001      	adds	r0, #1
 8029e72:	f000 80aa 	beq.w	8029fca <_vfiprintf_r+0x20e>
 8029e76:	9a09      	ldr	r2, [sp, #36]	; 0x24
 8029e78:	445a      	add	r2, fp
 8029e7a:	9209      	str	r2, [sp, #36]	; 0x24
 8029e7c:	f89a 3000 	ldrb.w	r3, [sl]
 8029e80:	2b00      	cmp	r3, #0
 8029e82:	f000 80a2 	beq.w	8029fca <_vfiprintf_r+0x20e>
 8029e86:	2300      	movs	r3, #0
 8029e88:	f04f 32ff 	mov.w	r2, #4294967295
 8029e8c:	e9cd 2305 	strd	r2, r3, [sp, #20]
 8029e90:	f10a 0a01 	add.w	sl, sl, #1
 8029e94:	9304      	str	r3, [sp, #16]
 8029e96:	9307      	str	r3, [sp, #28]
 8029e98:	f88d 3053 	strb.w	r3, [sp, #83]	; 0x53
 8029e9c:	931a      	str	r3, [sp, #104]	; 0x68
 8029e9e:	4654      	mov	r4, sl
 8029ea0:	2205      	movs	r2, #5
 8029ea2:	f814 1b01 	ldrb.w	r1, [r4], #1
 8029ea6:	4858      	ldr	r0, [pc, #352]	; (802a008 <_vfiprintf_r+0x24c>)
 8029ea8:	f7e0 faf2 	bl	800a490 <memchr>
 8029eac:	9a04      	ldr	r2, [sp, #16]
 8029eae:	b9d8      	cbnz	r0, 8029ee8 <_vfiprintf_r+0x12c>
 8029eb0:	06d1      	lsls	r1, r2, #27
 8029eb2:	bf44      	itt	mi
 8029eb4:	2320      	movmi	r3, #32
 8029eb6:	f88d 3053 	strbmi.w	r3, [sp, #83]	; 0x53
 8029eba:	0713      	lsls	r3, r2, #28
 8029ebc:	bf44      	itt	mi
 8029ebe:	232b      	movmi	r3, #43	; 0x2b
 8029ec0:	f88d 3053 	strbmi.w	r3, [sp, #83]	; 0x53
 8029ec4:	f89a 3000 	ldrb.w	r3, [sl]
 8029ec8:	2b2a      	cmp	r3, #42	; 0x2a
 8029eca:	d015      	beq.n	8029ef8 <_vfiprintf_r+0x13c>
 8029ecc:	9a07      	ldr	r2, [sp, #28]
 8029ece:	4654      	mov	r4, sl
 8029ed0:	2000      	movs	r0, #0
 8029ed2:	f04f 0c0a 	mov.w	ip, #10
 8029ed6:	4621      	mov	r1, r4
 8029ed8:	f811 3b01 	ldrb.w	r3, [r1], #1
 8029edc:	3b30      	subs	r3, #48	; 0x30
 8029ede:	2b09      	cmp	r3, #9
 8029ee0:	d94e      	bls.n	8029f80 <_vfiprintf_r+0x1c4>
 8029ee2:	b1b0      	cbz	r0, 8029f12 <_vfiprintf_r+0x156>
 8029ee4:	9207      	str	r2, [sp, #28]
 8029ee6:	e014      	b.n	8029f12 <_vfiprintf_r+0x156>
 8029ee8:	eba0 0308 	sub.w	r3, r0, r8
 8029eec:	fa09 f303 	lsl.w	r3, r9, r3
 8029ef0:	4313      	orrs	r3, r2
 8029ef2:	9304      	str	r3, [sp, #16]
 8029ef4:	46a2      	mov	sl, r4
 8029ef6:	e7d2      	b.n	8029e9e <_vfiprintf_r+0xe2>
 8029ef8:	9b03      	ldr	r3, [sp, #12]
 8029efa:	1d19      	adds	r1, r3, #4
 8029efc:	681b      	ldr	r3, [r3, #0]
 8029efe:	9103      	str	r1, [sp, #12]
 8029f00:	2b00      	cmp	r3, #0
 8029f02:	bfbb      	ittet	lt
 8029f04:	425b      	neglt	r3, r3
 8029f06:	f042 0202 	orrlt.w	r2, r2, #2
 8029f0a:	9307      	strge	r3, [sp, #28]
 8029f0c:	9307      	strlt	r3, [sp, #28]
 8029f0e:	bfb8      	it	lt
 8029f10:	9204      	strlt	r2, [sp, #16]
 8029f12:	7823      	ldrb	r3, [r4, #0]
 8029f14:	2b2e      	cmp	r3, #46	; 0x2e
 8029f16:	d10c      	bne.n	8029f32 <_vfiprintf_r+0x176>
 8029f18:	7863      	ldrb	r3, [r4, #1]
 8029f1a:	2b2a      	cmp	r3, #42	; 0x2a
 8029f1c:	d135      	bne.n	8029f8a <_vfiprintf_r+0x1ce>
 8029f1e:	9b03      	ldr	r3, [sp, #12]
 8029f20:	1d1a      	adds	r2, r3, #4
 8029f22:	681b      	ldr	r3, [r3, #0]
 8029f24:	9203      	str	r2, [sp, #12]
 8029f26:	2b00      	cmp	r3, #0
 8029f28:	bfb8      	it	lt
 8029f2a:	f04f 33ff 	movlt.w	r3, #4294967295
 8029f2e:	3402      	adds	r4, #2
 8029f30:	9305      	str	r3, [sp, #20]
 8029f32:	f8df a0e4 	ldr.w	sl, [pc, #228]	; 802a018 <_vfiprintf_r+0x25c>
 8029f36:	7821      	ldrb	r1, [r4, #0]
 8029f38:	2203      	movs	r2, #3
 8029f3a:	4650      	mov	r0, sl
 8029f3c:	f7e0 faa8 	bl	800a490 <memchr>
 8029f40:	b140      	cbz	r0, 8029f54 <_vfiprintf_r+0x198>
 8029f42:	2340      	movs	r3, #64	; 0x40
 8029f44:	eba0 000a 	sub.w	r0, r0, sl
 8029f48:	fa03 f000 	lsl.w	r0, r3, r0
 8029f4c:	9b04      	ldr	r3, [sp, #16]
 8029f4e:	4303      	orrs	r3, r0
 8029f50:	3401      	adds	r4, #1
 8029f52:	9304      	str	r3, [sp, #16]
 8029f54:	f814 1b01 	ldrb.w	r1, [r4], #1
 8029f58:	482c      	ldr	r0, [pc, #176]	; (802a00c <_vfiprintf_r+0x250>)
 8029f5a:	f88d 1028 	strb.w	r1, [sp, #40]	; 0x28
 8029f5e:	2206      	movs	r2, #6
 8029f60:	f7e0 fa96 	bl	800a490 <memchr>
 8029f64:	2800      	cmp	r0, #0
 8029f66:	d03f      	beq.n	8029fe8 <_vfiprintf_r+0x22c>
 8029f68:	4b29      	ldr	r3, [pc, #164]	; (802a010 <_vfiprintf_r+0x254>)
 8029f6a:	bb1b      	cbnz	r3, 8029fb4 <_vfiprintf_r+0x1f8>
 8029f6c:	9b03      	ldr	r3, [sp, #12]
 8029f6e:	3307      	adds	r3, #7
 8029f70:	f023 0307 	bic.w	r3, r3, #7
 8029f74:	3308      	adds	r3, #8
 8029f76:	9303      	str	r3, [sp, #12]
 8029f78:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8029f7a:	443b      	add	r3, r7
 8029f7c:	9309      	str	r3, [sp, #36]	; 0x24
 8029f7e:	e767      	b.n	8029e50 <_vfiprintf_r+0x94>
 8029f80:	fb0c 3202 	mla	r2, ip, r2, r3
 8029f84:	460c      	mov	r4, r1
 8029f86:	2001      	movs	r0, #1
 8029f88:	e7a5      	b.n	8029ed6 <_vfiprintf_r+0x11a>
 8029f8a:	2300      	movs	r3, #0
 8029f8c:	3401      	adds	r4, #1
 8029f8e:	9305      	str	r3, [sp, #20]
 8029f90:	4619      	mov	r1, r3
 8029f92:	f04f 0c0a 	mov.w	ip, #10
 8029f96:	4620      	mov	r0, r4
 8029f98:	f810 2b01 	ldrb.w	r2, [r0], #1
 8029f9c:	3a30      	subs	r2, #48	; 0x30
 8029f9e:	2a09      	cmp	r2, #9
 8029fa0:	d903      	bls.n	8029faa <_vfiprintf_r+0x1ee>
 8029fa2:	2b00      	cmp	r3, #0
 8029fa4:	d0c5      	beq.n	8029f32 <_vfiprintf_r+0x176>
 8029fa6:	9105      	str	r1, [sp, #20]
 8029fa8:	e7c3      	b.n	8029f32 <_vfiprintf_r+0x176>
 8029faa:	fb0c 2101 	mla	r1, ip, r1, r2
 8029fae:	4604      	mov	r4, r0
 8029fb0:	2301      	movs	r3, #1
 8029fb2:	e7f0      	b.n	8029f96 <_vfiprintf_r+0x1da>
 8029fb4:	ab03      	add	r3, sp, #12
 8029fb6:	9300      	str	r3, [sp, #0]
 8029fb8:	462a      	mov	r2, r5
 8029fba:	4b16      	ldr	r3, [pc, #88]	; (802a014 <_vfiprintf_r+0x258>)
 8029fbc:	a904      	add	r1, sp, #16
 8029fbe:	4630      	mov	r0, r6
 8029fc0:	f7fd fc62 	bl	8027888 <_printf_float>
 8029fc4:	4607      	mov	r7, r0
 8029fc6:	1c78      	adds	r0, r7, #1
 8029fc8:	d1d6      	bne.n	8029f78 <_vfiprintf_r+0x1bc>
 8029fca:	6e6b      	ldr	r3, [r5, #100]	; 0x64
 8029fcc:	07d9      	lsls	r1, r3, #31
 8029fce:	d405      	bmi.n	8029fdc <_vfiprintf_r+0x220>
 8029fd0:	89ab      	ldrh	r3, [r5, #12]
 8029fd2:	059a      	lsls	r2, r3, #22
 8029fd4:	d402      	bmi.n	8029fdc <_vfiprintf_r+0x220>
 8029fd6:	6da8      	ldr	r0, [r5, #88]	; 0x58
 8029fd8:	f7fd fa84 	bl	80274e4 <__retarget_lock_release_recursive>
 8029fdc:	89ab      	ldrh	r3, [r5, #12]
 8029fde:	065b      	lsls	r3, r3, #25
 8029fe0:	f53f af12 	bmi.w	8029e08 <_vfiprintf_r+0x4c>
 8029fe4:	9809      	ldr	r0, [sp, #36]	; 0x24
 8029fe6:	e711      	b.n	8029e0c <_vfiprintf_r+0x50>
 8029fe8:	ab03      	add	r3, sp, #12
 8029fea:	9300      	str	r3, [sp, #0]
 8029fec:	462a      	mov	r2, r5
 8029fee:	4b09      	ldr	r3, [pc, #36]	; (802a014 <_vfiprintf_r+0x258>)
 8029ff0:	a904      	add	r1, sp, #16
 8029ff2:	4630      	mov	r0, r6
 8029ff4:	f7fd feec 	bl	8027dd0 <_printf_i>
 8029ff8:	e7e4      	b.n	8029fc4 <_vfiprintf_r+0x208>
 8029ffa:	bf00      	nop
 8029ffc:	080579e4 	.word	0x080579e4
 802a000:	08057a04 	.word	0x08057a04
 802a004:	080579c4 	.word	0x080579c4
 802a008:	08057d4c 	.word	0x08057d4c
 802a00c:	08057d56 	.word	0x08057d56
 802a010:	08027889 	.word	0x08027889
 802a014:	08029d97 	.word	0x08029d97
 802a018:	08057d52 	.word	0x08057d52

0802a01c <_putc_r>:
 802a01c:	b570      	push	{r4, r5, r6, lr}
 802a01e:	460d      	mov	r5, r1
 802a020:	4614      	mov	r4, r2
 802a022:	4606      	mov	r6, r0
 802a024:	b118      	cbz	r0, 802a02e <_putc_r+0x12>
 802a026:	6983      	ldr	r3, [r0, #24]
 802a028:	b90b      	cbnz	r3, 802a02e <_putc_r+0x12>
 802a02a:	f7fd f997 	bl	802735c <__sinit>
 802a02e:	4b1c      	ldr	r3, [pc, #112]	; (802a0a0 <_putc_r+0x84>)
 802a030:	429c      	cmp	r4, r3
 802a032:	d124      	bne.n	802a07e <_putc_r+0x62>
 802a034:	6874      	ldr	r4, [r6, #4]
 802a036:	6e63      	ldr	r3, [r4, #100]	; 0x64
 802a038:	07d8      	lsls	r0, r3, #31
 802a03a:	d405      	bmi.n	802a048 <_putc_r+0x2c>
 802a03c:	89a3      	ldrh	r3, [r4, #12]
 802a03e:	0599      	lsls	r1, r3, #22
 802a040:	d402      	bmi.n	802a048 <_putc_r+0x2c>
 802a042:	6da0      	ldr	r0, [r4, #88]	; 0x58
 802a044:	f7fd fa4d 	bl	80274e2 <__retarget_lock_acquire_recursive>
 802a048:	68a3      	ldr	r3, [r4, #8]
 802a04a:	3b01      	subs	r3, #1
 802a04c:	2b00      	cmp	r3, #0
 802a04e:	60a3      	str	r3, [r4, #8]
 802a050:	da05      	bge.n	802a05e <_putc_r+0x42>
 802a052:	69a2      	ldr	r2, [r4, #24]
 802a054:	4293      	cmp	r3, r2
 802a056:	db1c      	blt.n	802a092 <_putc_r+0x76>
 802a058:	b2eb      	uxtb	r3, r5
 802a05a:	2b0a      	cmp	r3, #10
 802a05c:	d019      	beq.n	802a092 <_putc_r+0x76>
 802a05e:	6823      	ldr	r3, [r4, #0]
 802a060:	1c5a      	adds	r2, r3, #1
 802a062:	6022      	str	r2, [r4, #0]
 802a064:	701d      	strb	r5, [r3, #0]
 802a066:	b2ed      	uxtb	r5, r5
 802a068:	6e63      	ldr	r3, [r4, #100]	; 0x64
 802a06a:	07da      	lsls	r2, r3, #31
 802a06c:	d405      	bmi.n	802a07a <_putc_r+0x5e>
 802a06e:	89a3      	ldrh	r3, [r4, #12]
 802a070:	059b      	lsls	r3, r3, #22
 802a072:	d402      	bmi.n	802a07a <_putc_r+0x5e>
 802a074:	6da0      	ldr	r0, [r4, #88]	; 0x58
 802a076:	f7fd fa35 	bl	80274e4 <__retarget_lock_release_recursive>
 802a07a:	4628      	mov	r0, r5
 802a07c:	bd70      	pop	{r4, r5, r6, pc}
 802a07e:	4b09      	ldr	r3, [pc, #36]	; (802a0a4 <_putc_r+0x88>)
 802a080:	429c      	cmp	r4, r3
 802a082:	d101      	bne.n	802a088 <_putc_r+0x6c>
 802a084:	68b4      	ldr	r4, [r6, #8]
 802a086:	e7d6      	b.n	802a036 <_putc_r+0x1a>
 802a088:	4b07      	ldr	r3, [pc, #28]	; (802a0a8 <_putc_r+0x8c>)
 802a08a:	429c      	cmp	r4, r3
 802a08c:	bf08      	it	eq
 802a08e:	68f4      	ldreq	r4, [r6, #12]
 802a090:	e7d1      	b.n	802a036 <_putc_r+0x1a>
 802a092:	4629      	mov	r1, r5
 802a094:	4622      	mov	r2, r4
 802a096:	4630      	mov	r0, r6
 802a098:	f7fe f98a 	bl	80283b0 <__swbuf_r>
 802a09c:	4605      	mov	r5, r0
 802a09e:	e7e3      	b.n	802a068 <_putc_r+0x4c>
 802a0a0:	080579e4 	.word	0x080579e4
 802a0a4:	08057a04 	.word	0x08057a04
 802a0a8:	080579c4 	.word	0x080579c4

0802a0ac <_read_r>:
 802a0ac:	b538      	push	{r3, r4, r5, lr}
 802a0ae:	4d07      	ldr	r5, [pc, #28]	; (802a0cc <_read_r+0x20>)
 802a0b0:	4604      	mov	r4, r0
 802a0b2:	4608      	mov	r0, r1
 802a0b4:	4611      	mov	r1, r2
 802a0b6:	2200      	movs	r2, #0
 802a0b8:	602a      	str	r2, [r5, #0]
 802a0ba:	461a      	mov	r2, r3
 802a0bc:	f7f3 f9d4 	bl	801d468 <_read>
 802a0c0:	1c43      	adds	r3, r0, #1
 802a0c2:	d102      	bne.n	802a0ca <_read_r+0x1e>
 802a0c4:	682b      	ldr	r3, [r5, #0]
 802a0c6:	b103      	cbz	r3, 802a0ca <_read_r+0x1e>
 802a0c8:	6023      	str	r3, [r4, #0]
 802a0ca:	bd38      	pop	{r3, r4, r5, pc}
 802a0cc:	20014fcc 	.word	0x20014fcc

0802a0d0 <__assert_func>:
 802a0d0:	b51f      	push	{r0, r1, r2, r3, r4, lr}
 802a0d2:	4614      	mov	r4, r2
 802a0d4:	461a      	mov	r2, r3
 802a0d6:	4b09      	ldr	r3, [pc, #36]	; (802a0fc <__assert_func+0x2c>)
 802a0d8:	681b      	ldr	r3, [r3, #0]
 802a0da:	4605      	mov	r5, r0
 802a0dc:	68d8      	ldr	r0, [r3, #12]
 802a0de:	b14c      	cbz	r4, 802a0f4 <__assert_func+0x24>
 802a0e0:	4b07      	ldr	r3, [pc, #28]	; (802a100 <__assert_func+0x30>)
 802a0e2:	9100      	str	r1, [sp, #0]
 802a0e4:	e9cd 3401 	strd	r3, r4, [sp, #4]
 802a0e8:	4906      	ldr	r1, [pc, #24]	; (802a104 <__assert_func+0x34>)
 802a0ea:	462b      	mov	r3, r5
 802a0ec:	f000 f80e 	bl	802a10c <fiprintf>
 802a0f0:	f000 f88e 	bl	802a210 <abort>
 802a0f4:	4b04      	ldr	r3, [pc, #16]	; (802a108 <__assert_func+0x38>)
 802a0f6:	461c      	mov	r4, r3
 802a0f8:	e7f3      	b.n	802a0e2 <__assert_func+0x12>
 802a0fa:	bf00      	nop
 802a0fc:	20002020 	.word	0x20002020
 802a100:	08057d5d 	.word	0x08057d5d
 802a104:	08057d6a 	.word	0x08057d6a
 802a108:	08057d98 	.word	0x08057d98

0802a10c <fiprintf>:
 802a10c:	b40e      	push	{r1, r2, r3}
 802a10e:	b503      	push	{r0, r1, lr}
 802a110:	4601      	mov	r1, r0
 802a112:	ab03      	add	r3, sp, #12
 802a114:	4805      	ldr	r0, [pc, #20]	; (802a12c <fiprintf+0x20>)
 802a116:	f853 2b04 	ldr.w	r2, [r3], #4
 802a11a:	6800      	ldr	r0, [r0, #0]
 802a11c:	9301      	str	r3, [sp, #4]
 802a11e:	f7ff fe4d 	bl	8029dbc <_vfiprintf_r>
 802a122:	b002      	add	sp, #8
 802a124:	f85d eb04 	ldr.w	lr, [sp], #4
 802a128:	b003      	add	sp, #12
 802a12a:	4770      	bx	lr
 802a12c:	20002020 	.word	0x20002020

0802a130 <_fstat_r>:
 802a130:	b538      	push	{r3, r4, r5, lr}
 802a132:	4d07      	ldr	r5, [pc, #28]	; (802a150 <_fstat_r+0x20>)
 802a134:	2300      	movs	r3, #0
 802a136:	4604      	mov	r4, r0
 802a138:	4608      	mov	r0, r1
 802a13a:	4611      	mov	r1, r2
 802a13c:	602b      	str	r3, [r5, #0]
 802a13e:	f7f3 f989 	bl	801d454 <_fstat>
 802a142:	1c43      	adds	r3, r0, #1
 802a144:	d102      	bne.n	802a14c <_fstat_r+0x1c>
 802a146:	682b      	ldr	r3, [r5, #0]
 802a148:	b103      	cbz	r3, 802a14c <_fstat_r+0x1c>
 802a14a:	6023      	str	r3, [r4, #0]
 802a14c:	bd38      	pop	{r3, r4, r5, pc}
 802a14e:	bf00      	nop
 802a150:	20014fcc 	.word	0x20014fcc

0802a154 <_isatty_r>:
 802a154:	b538      	push	{r3, r4, r5, lr}
 802a156:	4d06      	ldr	r5, [pc, #24]	; (802a170 <_isatty_r+0x1c>)
 802a158:	2300      	movs	r3, #0
 802a15a:	4604      	mov	r4, r0
 802a15c:	4608      	mov	r0, r1
 802a15e:	602b      	str	r3, [r5, #0]
 802a160:	f7f3 f97e 	bl	801d460 <_isatty>
 802a164:	1c43      	adds	r3, r0, #1
 802a166:	d102      	bne.n	802a16e <_isatty_r+0x1a>
 802a168:	682b      	ldr	r3, [r5, #0]
 802a16a:	b103      	cbz	r3, 802a16e <_isatty_r+0x1a>
 802a16c:	6023      	str	r3, [r4, #0]
 802a16e:	bd38      	pop	{r3, r4, r5, pc}
 802a170:	20014fcc 	.word	0x20014fcc

0802a174 <__ascii_mbtowc>:
 802a174:	b082      	sub	sp, #8
 802a176:	b901      	cbnz	r1, 802a17a <__ascii_mbtowc+0x6>
 802a178:	a901      	add	r1, sp, #4
 802a17a:	b142      	cbz	r2, 802a18e <__ascii_mbtowc+0x1a>
 802a17c:	b14b      	cbz	r3, 802a192 <__ascii_mbtowc+0x1e>
 802a17e:	7813      	ldrb	r3, [r2, #0]
 802a180:	600b      	str	r3, [r1, #0]
 802a182:	7812      	ldrb	r2, [r2, #0]
 802a184:	1e10      	subs	r0, r2, #0
 802a186:	bf18      	it	ne
 802a188:	2001      	movne	r0, #1
 802a18a:	b002      	add	sp, #8
 802a18c:	4770      	bx	lr
 802a18e:	4610      	mov	r0, r2
 802a190:	e7fb      	b.n	802a18a <__ascii_mbtowc+0x16>
 802a192:	f06f 0001 	mvn.w	r0, #1
 802a196:	e7f8      	b.n	802a18a <__ascii_mbtowc+0x16>

0802a198 <_realloc_r>:
 802a198:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 802a19c:	4680      	mov	r8, r0
 802a19e:	4614      	mov	r4, r2
 802a1a0:	460e      	mov	r6, r1
 802a1a2:	b921      	cbnz	r1, 802a1ae <_realloc_r+0x16>
 802a1a4:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
 802a1a8:	4611      	mov	r1, r2
 802a1aa:	f7fd ba59 	b.w	8027660 <_malloc_r>
 802a1ae:	b92a      	cbnz	r2, 802a1bc <_realloc_r+0x24>
 802a1b0:	f7fd f9ea 	bl	8027588 <_free_r>
 802a1b4:	4625      	mov	r5, r4
 802a1b6:	4628      	mov	r0, r5
 802a1b8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 802a1bc:	f000 f82f 	bl	802a21e <_malloc_usable_size_r>
 802a1c0:	4284      	cmp	r4, r0
 802a1c2:	4607      	mov	r7, r0
 802a1c4:	d802      	bhi.n	802a1cc <_realloc_r+0x34>
 802a1c6:	ebb4 0f50 	cmp.w	r4, r0, lsr #1
 802a1ca:	d812      	bhi.n	802a1f2 <_realloc_r+0x5a>
 802a1cc:	4621      	mov	r1, r4
 802a1ce:	4640      	mov	r0, r8
 802a1d0:	f7fd fa46 	bl	8027660 <_malloc_r>
 802a1d4:	4605      	mov	r5, r0
 802a1d6:	2800      	cmp	r0, #0
 802a1d8:	d0ed      	beq.n	802a1b6 <_realloc_r+0x1e>
 802a1da:	42bc      	cmp	r4, r7
 802a1dc:	4622      	mov	r2, r4
 802a1de:	4631      	mov	r1, r6
 802a1e0:	bf28      	it	cs
 802a1e2:	463a      	movcs	r2, r7
 802a1e4:	f7fd f9a0 	bl	8027528 <memcpy>
 802a1e8:	4631      	mov	r1, r6
 802a1ea:	4640      	mov	r0, r8
 802a1ec:	f7fd f9cc 	bl	8027588 <_free_r>
 802a1f0:	e7e1      	b.n	802a1b6 <_realloc_r+0x1e>
 802a1f2:	4635      	mov	r5, r6
 802a1f4:	e7df      	b.n	802a1b6 <_realloc_r+0x1e>

0802a1f6 <__ascii_wctomb>:
 802a1f6:	b149      	cbz	r1, 802a20c <__ascii_wctomb+0x16>
 802a1f8:	2aff      	cmp	r2, #255	; 0xff
 802a1fa:	bf85      	ittet	hi
 802a1fc:	238a      	movhi	r3, #138	; 0x8a
 802a1fe:	6003      	strhi	r3, [r0, #0]
 802a200:	700a      	strbls	r2, [r1, #0]
 802a202:	f04f 30ff 	movhi.w	r0, #4294967295
 802a206:	bf98      	it	ls
 802a208:	2001      	movls	r0, #1
 802a20a:	4770      	bx	lr
 802a20c:	4608      	mov	r0, r1
 802a20e:	4770      	bx	lr

0802a210 <abort>:
 802a210:	b508      	push	{r3, lr}
 802a212:	2006      	movs	r0, #6
 802a214:	f000 f834 	bl	802a280 <raise>
 802a218:	2001      	movs	r0, #1
 802a21a:	f7f3 f903 	bl	801d424 <_exit>

0802a21e <_malloc_usable_size_r>:
 802a21e:	f851 3c04 	ldr.w	r3, [r1, #-4]
 802a222:	1f18      	subs	r0, r3, #4
 802a224:	2b00      	cmp	r3, #0
 802a226:	bfbc      	itt	lt
 802a228:	580b      	ldrlt	r3, [r1, r0]
 802a22a:	18c0      	addlt	r0, r0, r3
 802a22c:	4770      	bx	lr

0802a22e <_raise_r>:
 802a22e:	291f      	cmp	r1, #31
 802a230:	b538      	push	{r3, r4, r5, lr}
 802a232:	4604      	mov	r4, r0
 802a234:	460d      	mov	r5, r1
 802a236:	d904      	bls.n	802a242 <_raise_r+0x14>
 802a238:	2316      	movs	r3, #22
 802a23a:	6003      	str	r3, [r0, #0]
 802a23c:	f04f 30ff 	mov.w	r0, #4294967295
 802a240:	bd38      	pop	{r3, r4, r5, pc}
 802a242:	6c42      	ldr	r2, [r0, #68]	; 0x44
 802a244:	b112      	cbz	r2, 802a24c <_raise_r+0x1e>
 802a246:	f852 3021 	ldr.w	r3, [r2, r1, lsl #2]
 802a24a:	b94b      	cbnz	r3, 802a260 <_raise_r+0x32>
 802a24c:	4620      	mov	r0, r4
 802a24e:	f000 f831 	bl	802a2b4 <_getpid_r>
 802a252:	462a      	mov	r2, r5
 802a254:	4601      	mov	r1, r0
 802a256:	4620      	mov	r0, r4
 802a258:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
 802a25c:	f000 b818 	b.w	802a290 <_kill_r>
 802a260:	2b01      	cmp	r3, #1
 802a262:	d00a      	beq.n	802a27a <_raise_r+0x4c>
 802a264:	1c59      	adds	r1, r3, #1
 802a266:	d103      	bne.n	802a270 <_raise_r+0x42>
 802a268:	2316      	movs	r3, #22
 802a26a:	6003      	str	r3, [r0, #0]
 802a26c:	2001      	movs	r0, #1
 802a26e:	e7e7      	b.n	802a240 <_raise_r+0x12>
 802a270:	2400      	movs	r4, #0
 802a272:	f842 4025 	str.w	r4, [r2, r5, lsl #2]
 802a276:	4628      	mov	r0, r5
 802a278:	4798      	blx	r3
 802a27a:	2000      	movs	r0, #0
 802a27c:	e7e0      	b.n	802a240 <_raise_r+0x12>
	...

0802a280 <raise>:
 802a280:	4b02      	ldr	r3, [pc, #8]	; (802a28c <raise+0xc>)
 802a282:	4601      	mov	r1, r0
 802a284:	6818      	ldr	r0, [r3, #0]
 802a286:	f7ff bfd2 	b.w	802a22e <_raise_r>
 802a28a:	bf00      	nop
 802a28c:	20002020 	.word	0x20002020

0802a290 <_kill_r>:
 802a290:	b538      	push	{r3, r4, r5, lr}
 802a292:	4d07      	ldr	r5, [pc, #28]	; (802a2b0 <_kill_r+0x20>)
 802a294:	2300      	movs	r3, #0
 802a296:	4604      	mov	r4, r0
 802a298:	4608      	mov	r0, r1
 802a29a:	4611      	mov	r1, r2
 802a29c:	602b      	str	r3, [r5, #0]
 802a29e:	f7f3 f8b9 	bl	801d414 <_kill>
 802a2a2:	1c43      	adds	r3, r0, #1
 802a2a4:	d102      	bne.n	802a2ac <_kill_r+0x1c>
 802a2a6:	682b      	ldr	r3, [r5, #0]
 802a2a8:	b103      	cbz	r3, 802a2ac <_kill_r+0x1c>
 802a2aa:	6023      	str	r3, [r4, #0]
 802a2ac:	bd38      	pop	{r3, r4, r5, pc}
 802a2ae:	bf00      	nop
 802a2b0:	20014fcc 	.word	0x20014fcc

0802a2b4 <_getpid_r>:
 802a2b4:	f7f3 b8ac 	b.w	801d410 <_getpid>

0802a2b8 <round>:
 802a2b8:	ec51 0b10 	vmov	r0, r1, d0
 802a2bc:	b570      	push	{r4, r5, r6, lr}
 802a2be:	f3c1 550a 	ubfx	r5, r1, #20, #11
 802a2c2:	f2a5 34ff 	subw	r4, r5, #1023	; 0x3ff
 802a2c6:	2c13      	cmp	r4, #19
 802a2c8:	ee10 2a10 	vmov	r2, s0
 802a2cc:	460b      	mov	r3, r1
 802a2ce:	dc19      	bgt.n	802a304 <round+0x4c>
 802a2d0:	2c00      	cmp	r4, #0
 802a2d2:	da09      	bge.n	802a2e8 <round+0x30>
 802a2d4:	3401      	adds	r4, #1
 802a2d6:	f001 4300 	and.w	r3, r1, #2147483648	; 0x80000000
 802a2da:	d103      	bne.n	802a2e4 <round+0x2c>
 802a2dc:	f043 537f 	orr.w	r3, r3, #1069547520	; 0x3fc00000
 802a2e0:	f443 1340 	orr.w	r3, r3, #3145728	; 0x300000
 802a2e4:	2200      	movs	r2, #0
 802a2e6:	e028      	b.n	802a33a <round+0x82>
 802a2e8:	4d15      	ldr	r5, [pc, #84]	; (802a340 <round+0x88>)
 802a2ea:	4125      	asrs	r5, r4
 802a2ec:	ea01 0605 	and.w	r6, r1, r5
 802a2f0:	4332      	orrs	r2, r6
 802a2f2:	d00e      	beq.n	802a312 <round+0x5a>
 802a2f4:	f44f 2200 	mov.w	r2, #524288	; 0x80000
 802a2f8:	fa42 f404 	asr.w	r4, r2, r4
 802a2fc:	4423      	add	r3, r4
 802a2fe:	ea23 0305 	bic.w	r3, r3, r5
 802a302:	e7ef      	b.n	802a2e4 <round+0x2c>
 802a304:	2c33      	cmp	r4, #51	; 0x33
 802a306:	dd07      	ble.n	802a318 <round+0x60>
 802a308:	f5b4 6f80 	cmp.w	r4, #1024	; 0x400
 802a30c:	d101      	bne.n	802a312 <round+0x5a>
 802a30e:	f7e0 f915 	bl	800a53c <__adddf3>
 802a312:	ec41 0b10 	vmov	d0, r0, r1
 802a316:	bd70      	pop	{r4, r5, r6, pc}
 802a318:	f2a5 4613 	subw	r6, r5, #1043	; 0x413
 802a31c:	f04f 35ff 	mov.w	r5, #4294967295
 802a320:	40f5      	lsrs	r5, r6
 802a322:	4228      	tst	r0, r5
 802a324:	d0f5      	beq.n	802a312 <round+0x5a>
 802a326:	2101      	movs	r1, #1
 802a328:	f1c4 0433 	rsb	r4, r4, #51	; 0x33
 802a32c:	fa01 f404 	lsl.w	r4, r1, r4
 802a330:	1912      	adds	r2, r2, r4
 802a332:	bf28      	it	cs
 802a334:	185b      	addcs	r3, r3, r1
 802a336:	ea22 0205 	bic.w	r2, r2, r5
 802a33a:	4619      	mov	r1, r3
 802a33c:	4610      	mov	r0, r2
 802a33e:	e7e8      	b.n	802a312 <round+0x5a>
 802a340:	000fffff 	.word	0x000fffff

0802a344 <asinhf>:
 802a344:	b510      	push	{r4, lr}
 802a346:	ee10 4a10 	vmov	r4, s0
 802a34a:	f024 4300 	bic.w	r3, r4, #2147483648	; 0x80000000
 802a34e:	f1b3 4fff 	cmp.w	r3, #2139095040	; 0x7f800000
 802a352:	ed2d 8b04 	vpush	{d8-d9}
 802a356:	eeb0 8a40 	vmov.f32	s16, s0
 802a35a:	db06      	blt.n	802a36a <asinhf+0x26>
 802a35c:	ee30 8a00 	vadd.f32	s16, s0, s0
 802a360:	eeb0 0a48 	vmov.f32	s0, s16
 802a364:	ecbd 8b04 	vpop	{d8-d9}
 802a368:	bd10      	pop	{r4, pc}
 802a36a:	f1b3 5f46 	cmp.w	r3, #830472192	; 0x31800000
 802a36e:	da21      	bge.n	802a3b4 <asinhf+0x70>
 802a370:	eddf 7a26 	vldr	s15, [pc, #152]	; 802a40c <asinhf+0xc8>
 802a374:	ee70 7a27 	vadd.f32	s15, s0, s15
 802a378:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
 802a37c:	eef4 7ac7 	vcmpe.f32	s15, s14
 802a380:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802a384:	dcec      	bgt.n	802a360 <asinhf+0x1c>
 802a386:	eeb0 0a48 	vmov.f32	s0, s16
 802a38a:	f000 fb77 	bl	802aa7c <fabsf>
 802a38e:	ee68 8a08 	vmul.f32	s17, s16, s16
 802a392:	eeb7 9a00 	vmov.f32	s18, #112	; 0x3f800000  1.0
 802a396:	eeb0 8a40 	vmov.f32	s16, s0
 802a39a:	ee38 0a89 	vadd.f32	s0, s17, s18
 802a39e:	f002 f9a9 	bl	802c6f4 <__ieee754_sqrtf>
 802a3a2:	ee30 0a09 	vadd.f32	s0, s0, s18
 802a3a6:	eec8 7a80 	vdiv.f32	s15, s17, s0
 802a3aa:	ee37 0a88 	vadd.f32	s0, s15, s16
 802a3ae:	f000 fbaf 	bl	802ab10 <log1pf>
 802a3b2:	e028      	b.n	802a406 <asinhf+0xc2>
 802a3b4:	f1b3 4f9b 	cmp.w	r3, #1300234240	; 0x4d800000
 802a3b8:	dd0c      	ble.n	802a3d4 <asinhf+0x90>
 802a3ba:	f000 fb5f 	bl	802aa7c <fabsf>
 802a3be:	f001 fbd7 	bl	802bb70 <__ieee754_logf>
 802a3c2:	ed9f 8a13 	vldr	s16, [pc, #76]	; 802a410 <asinhf+0xcc>
 802a3c6:	ee30 8a08 	vadd.f32	s16, s0, s16
 802a3ca:	2c00      	cmp	r4, #0
 802a3cc:	bfd8      	it	le
 802a3ce:	eeb1 8a48 	vnegle.f32	s16, s16
 802a3d2:	e7c5      	b.n	802a360 <asinhf+0x1c>
 802a3d4:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
 802a3d8:	ddd5      	ble.n	802a386 <asinhf+0x42>
 802a3da:	f000 fb4f 	bl	802aa7c <fabsf>
 802a3de:	eeb7 9a00 	vmov.f32	s18, #112	; 0x3f800000  1.0
 802a3e2:	eef0 8a40 	vmov.f32	s17, s0
 802a3e6:	eeb0 0a49 	vmov.f32	s0, s18
 802a3ea:	eea8 0a08 	vfma.f32	s0, s16, s16
 802a3ee:	f002 f981 	bl	802c6f4 <__ieee754_sqrtf>
 802a3f2:	ee70 7a28 	vadd.f32	s15, s0, s17
 802a3f6:	ee89 0a27 	vdiv.f32	s0, s18, s15
 802a3fa:	eef0 7a00 	vmov.f32	s15, #0	; 0x40000000  2.0
 802a3fe:	eea8 0aa7 	vfma.f32	s0, s17, s15
 802a402:	f001 fbb5 	bl	802bb70 <__ieee754_logf>
 802a406:	eeb0 8a40 	vmov.f32	s16, s0
 802a40a:	e7de      	b.n	802a3ca <asinhf+0x86>
 802a40c:	7149f2ca 	.word	0x7149f2ca
 802a410:	3f317218 	.word	0x3f317218

0802a414 <atanf>:
 802a414:	b538      	push	{r3, r4, r5, lr}
 802a416:	ee10 5a10 	vmov	r5, s0
 802a41a:	f025 4400 	bic.w	r4, r5, #2147483648	; 0x80000000
 802a41e:	f1b4 4fa1 	cmp.w	r4, #1350565888	; 0x50800000
 802a422:	eef0 7a40 	vmov.f32	s15, s0
 802a426:	db10      	blt.n	802a44a <atanf+0x36>
 802a428:	f1b4 4fff 	cmp.w	r4, #2139095040	; 0x7f800000
 802a42c:	dd04      	ble.n	802a438 <atanf+0x24>
 802a42e:	ee70 7a00 	vadd.f32	s15, s0, s0
 802a432:	eeb0 0a67 	vmov.f32	s0, s15
 802a436:	bd38      	pop	{r3, r4, r5, pc}
 802a438:	eddf 7a4d 	vldr	s15, [pc, #308]	; 802a570 <atanf+0x15c>
 802a43c:	ed9f 0a4d 	vldr	s0, [pc, #308]	; 802a574 <atanf+0x160>
 802a440:	2d00      	cmp	r5, #0
 802a442:	bfd8      	it	le
 802a444:	eef0 7a40 	vmovle.f32	s15, s0
 802a448:	e7f3      	b.n	802a432 <atanf+0x1e>
 802a44a:	4b4b      	ldr	r3, [pc, #300]	; (802a578 <atanf+0x164>)
 802a44c:	429c      	cmp	r4, r3
 802a44e:	dc10      	bgt.n	802a472 <atanf+0x5e>
 802a450:	f1b4 5f44 	cmp.w	r4, #822083584	; 0x31000000
 802a454:	da0a      	bge.n	802a46c <atanf+0x58>
 802a456:	ed9f 7a49 	vldr	s14, [pc, #292]	; 802a57c <atanf+0x168>
 802a45a:	ee30 7a07 	vadd.f32	s14, s0, s14
 802a45e:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
 802a462:	eeb4 7ae6 	vcmpe.f32	s14, s13
 802a466:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802a46a:	dce2      	bgt.n	802a432 <atanf+0x1e>
 802a46c:	f04f 33ff 	mov.w	r3, #4294967295
 802a470:	e013      	b.n	802a49a <atanf+0x86>
 802a472:	f000 fb03 	bl	802aa7c <fabsf>
 802a476:	4b42      	ldr	r3, [pc, #264]	; (802a580 <atanf+0x16c>)
 802a478:	429c      	cmp	r4, r3
 802a47a:	dc4f      	bgt.n	802a51c <atanf+0x108>
 802a47c:	f5a3 03d0 	sub.w	r3, r3, #6815744	; 0x680000
 802a480:	429c      	cmp	r4, r3
 802a482:	dc41      	bgt.n	802a508 <atanf+0xf4>
 802a484:	eef0 7a00 	vmov.f32	s15, #0	; 0x40000000  2.0
 802a488:	eebf 7a00 	vmov.f32	s14, #240	; 0xbf800000 -1.0
 802a48c:	eea0 7a27 	vfma.f32	s14, s0, s15
 802a490:	2300      	movs	r3, #0
 802a492:	ee30 0a27 	vadd.f32	s0, s0, s15
 802a496:	eec7 7a00 	vdiv.f32	s15, s14, s0
 802a49a:	1c5a      	adds	r2, r3, #1
 802a49c:	ee27 6aa7 	vmul.f32	s12, s15, s15
 802a4a0:	ed9f 7a38 	vldr	s14, [pc, #224]	; 802a584 <atanf+0x170>
 802a4a4:	eddf 5a38 	vldr	s11, [pc, #224]	; 802a588 <atanf+0x174>
 802a4a8:	ed9f 5a38 	vldr	s10, [pc, #224]	; 802a58c <atanf+0x178>
 802a4ac:	ee66 6a06 	vmul.f32	s13, s12, s12
 802a4b0:	eee6 5a87 	vfma.f32	s11, s13, s14
 802a4b4:	ed9f 7a36 	vldr	s14, [pc, #216]	; 802a590 <atanf+0x17c>
 802a4b8:	eea5 7aa6 	vfma.f32	s14, s11, s13
 802a4bc:	eddf 5a35 	vldr	s11, [pc, #212]	; 802a594 <atanf+0x180>
 802a4c0:	eee7 5a26 	vfma.f32	s11, s14, s13
 802a4c4:	ed9f 7a34 	vldr	s14, [pc, #208]	; 802a598 <atanf+0x184>
 802a4c8:	eea5 7aa6 	vfma.f32	s14, s11, s13
 802a4cc:	eddf 5a33 	vldr	s11, [pc, #204]	; 802a59c <atanf+0x188>
 802a4d0:	eee7 5a26 	vfma.f32	s11, s14, s13
 802a4d4:	ed9f 7a32 	vldr	s14, [pc, #200]	; 802a5a0 <atanf+0x18c>
 802a4d8:	eea6 5a87 	vfma.f32	s10, s13, s14
 802a4dc:	ed9f 7a31 	vldr	s14, [pc, #196]	; 802a5a4 <atanf+0x190>
 802a4e0:	eea5 7a26 	vfma.f32	s14, s10, s13
 802a4e4:	ed9f 5a30 	vldr	s10, [pc, #192]	; 802a5a8 <atanf+0x194>
 802a4e8:	eea7 5a26 	vfma.f32	s10, s14, s13
 802a4ec:	ed9f 7a2f 	vldr	s14, [pc, #188]	; 802a5ac <atanf+0x198>
 802a4f0:	eea5 7a26 	vfma.f32	s14, s10, s13
 802a4f4:	ee27 7a26 	vmul.f32	s14, s14, s13
 802a4f8:	eea5 7a86 	vfma.f32	s14, s11, s12
 802a4fc:	ee27 7a87 	vmul.f32	s14, s15, s14
 802a500:	d121      	bne.n	802a546 <atanf+0x132>
 802a502:	ee77 7ac7 	vsub.f32	s15, s15, s14
 802a506:	e794      	b.n	802a432 <atanf+0x1e>
 802a508:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
 802a50c:	ee30 7a67 	vsub.f32	s14, s0, s15
 802a510:	ee30 0a27 	vadd.f32	s0, s0, s15
 802a514:	2301      	movs	r3, #1
 802a516:	eec7 7a00 	vdiv.f32	s15, s14, s0
 802a51a:	e7be      	b.n	802a49a <atanf+0x86>
 802a51c:	4b24      	ldr	r3, [pc, #144]	; (802a5b0 <atanf+0x19c>)
 802a51e:	429c      	cmp	r4, r3
 802a520:	dc0b      	bgt.n	802a53a <atanf+0x126>
 802a522:	eef7 7a08 	vmov.f32	s15, #120	; 0x3fc00000  1.5
 802a526:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
 802a52a:	eea0 7a27 	vfma.f32	s14, s0, s15
 802a52e:	2302      	movs	r3, #2
 802a530:	ee70 6a67 	vsub.f32	s13, s0, s15
 802a534:	eec6 7a87 	vdiv.f32	s15, s13, s14
 802a538:	e7af      	b.n	802a49a <atanf+0x86>
 802a53a:	eebf 7a00 	vmov.f32	s14, #240	; 0xbf800000 -1.0
 802a53e:	eec7 7a00 	vdiv.f32	s15, s14, s0
 802a542:	2303      	movs	r3, #3
 802a544:	e7a9      	b.n	802a49a <atanf+0x86>
 802a546:	4a1b      	ldr	r2, [pc, #108]	; (802a5b4 <atanf+0x1a0>)
 802a548:	491b      	ldr	r1, [pc, #108]	; (802a5b8 <atanf+0x1a4>)
 802a54a:	eb02 0283 	add.w	r2, r2, r3, lsl #2
 802a54e:	eb01 0383 	add.w	r3, r1, r3, lsl #2
 802a552:	ed93 0a00 	vldr	s0, [r3]
 802a556:	ee37 7a40 	vsub.f32	s14, s14, s0
 802a55a:	ed92 0a00 	vldr	s0, [r2]
 802a55e:	ee77 7a67 	vsub.f32	s15, s14, s15
 802a562:	2d00      	cmp	r5, #0
 802a564:	ee70 7a67 	vsub.f32	s15, s0, s15
 802a568:	bfb8      	it	lt
 802a56a:	eef1 7a67 	vneglt.f32	s15, s15
 802a56e:	e760      	b.n	802a432 <atanf+0x1e>
 802a570:	3fc90fdb 	.word	0x3fc90fdb
 802a574:	bfc90fdb 	.word	0xbfc90fdb
 802a578:	3edfffff 	.word	0x3edfffff
 802a57c:	7149f2ca 	.word	0x7149f2ca
 802a580:	3f97ffff 	.word	0x3f97ffff
 802a584:	3c8569d7 	.word	0x3c8569d7
 802a588:	3d4bda59 	.word	0x3d4bda59
 802a58c:	bd6ef16b 	.word	0xbd6ef16b
 802a590:	3d886b35 	.word	0x3d886b35
 802a594:	3dba2e6e 	.word	0x3dba2e6e
 802a598:	3e124925 	.word	0x3e124925
 802a59c:	3eaaaaab 	.word	0x3eaaaaab
 802a5a0:	bd15a221 	.word	0xbd15a221
 802a5a4:	bd9d8795 	.word	0xbd9d8795
 802a5a8:	bde38e38 	.word	0xbde38e38
 802a5ac:	be4ccccd 	.word	0xbe4ccccd
 802a5b0:	401bffff 	.word	0x401bffff
 802a5b4:	08057da4 	.word	0x08057da4
 802a5b8:	08057db4 	.word	0x08057db4

0802a5bc <ceilf>:
 802a5bc:	ee10 3a10 	vmov	r3, s0
 802a5c0:	f3c3 52c7 	ubfx	r2, r3, #23, #8
 802a5c4:	3a7f      	subs	r2, #127	; 0x7f
 802a5c6:	2a16      	cmp	r2, #22
 802a5c8:	f023 4100 	bic.w	r1, r3, #2147483648	; 0x80000000
 802a5cc:	dc2a      	bgt.n	802a624 <ceilf+0x68>
 802a5ce:	2a00      	cmp	r2, #0
 802a5d0:	da11      	bge.n	802a5f6 <ceilf+0x3a>
 802a5d2:	eddf 7a19 	vldr	s15, [pc, #100]	; 802a638 <ceilf+0x7c>
 802a5d6:	ee30 0a27 	vadd.f32	s0, s0, s15
 802a5da:	eeb5 0ac0 	vcmpe.f32	s0, #0.0
 802a5de:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802a5e2:	dd05      	ble.n	802a5f0 <ceilf+0x34>
 802a5e4:	2b00      	cmp	r3, #0
 802a5e6:	db23      	blt.n	802a630 <ceilf+0x74>
 802a5e8:	2900      	cmp	r1, #0
 802a5ea:	bf18      	it	ne
 802a5ec:	f04f 537e 	movne.w	r3, #1065353216	; 0x3f800000
 802a5f0:	ee00 3a10 	vmov	s0, r3
 802a5f4:	4770      	bx	lr
 802a5f6:	4911      	ldr	r1, [pc, #68]	; (802a63c <ceilf+0x80>)
 802a5f8:	4111      	asrs	r1, r2
 802a5fa:	420b      	tst	r3, r1
 802a5fc:	d0fa      	beq.n	802a5f4 <ceilf+0x38>
 802a5fe:	eddf 7a0e 	vldr	s15, [pc, #56]	; 802a638 <ceilf+0x7c>
 802a602:	ee30 0a27 	vadd.f32	s0, s0, s15
 802a606:	eeb5 0ac0 	vcmpe.f32	s0, #0.0
 802a60a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802a60e:	ddef      	ble.n	802a5f0 <ceilf+0x34>
 802a610:	2b00      	cmp	r3, #0
 802a612:	bfc2      	ittt	gt
 802a614:	f44f 0000 	movgt.w	r0, #8388608	; 0x800000
 802a618:	fa40 f202 	asrgt.w	r2, r0, r2
 802a61c:	189b      	addgt	r3, r3, r2
 802a61e:	ea23 0301 	bic.w	r3, r3, r1
 802a622:	e7e5      	b.n	802a5f0 <ceilf+0x34>
 802a624:	f1b1 4fff 	cmp.w	r1, #2139095040	; 0x7f800000
 802a628:	d3e4      	bcc.n	802a5f4 <ceilf+0x38>
 802a62a:	ee30 0a00 	vadd.f32	s0, s0, s0
 802a62e:	4770      	bx	lr
 802a630:	f04f 4300 	mov.w	r3, #2147483648	; 0x80000000
 802a634:	e7dc      	b.n	802a5f0 <ceilf+0x34>
 802a636:	bf00      	nop
 802a638:	7149f2ca 	.word	0x7149f2ca
 802a63c:	007fffff 	.word	0x007fffff

0802a640 <cosf>:
 802a640:	ee10 3a10 	vmov	r3, s0
 802a644:	b507      	push	{r0, r1, r2, lr}
 802a646:	4a1e      	ldr	r2, [pc, #120]	; (802a6c0 <cosf+0x80>)
 802a648:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
 802a64c:	4293      	cmp	r3, r2
 802a64e:	dc06      	bgt.n	802a65e <cosf+0x1e>
 802a650:	eddf 0a1c 	vldr	s1, [pc, #112]	; 802a6c4 <cosf+0x84>
 802a654:	b003      	add	sp, #12
 802a656:	f85d eb04 	ldr.w	lr, [sp], #4
 802a65a:	f002 b84f 	b.w	802c6fc <__kernel_cosf>
 802a65e:	f1b3 4fff 	cmp.w	r3, #2139095040	; 0x7f800000
 802a662:	db04      	blt.n	802a66e <cosf+0x2e>
 802a664:	ee30 0a40 	vsub.f32	s0, s0, s0
 802a668:	b003      	add	sp, #12
 802a66a:	f85d fb04 	ldr.w	pc, [sp], #4
 802a66e:	4668      	mov	r0, sp
 802a670:	f001 fe94 	bl	802c39c <__ieee754_rem_pio2f>
 802a674:	f000 0003 	and.w	r0, r0, #3
 802a678:	2801      	cmp	r0, #1
 802a67a:	d009      	beq.n	802a690 <cosf+0x50>
 802a67c:	2802      	cmp	r0, #2
 802a67e:	d010      	beq.n	802a6a2 <cosf+0x62>
 802a680:	b9b0      	cbnz	r0, 802a6b0 <cosf+0x70>
 802a682:	eddd 0a01 	vldr	s1, [sp, #4]
 802a686:	ed9d 0a00 	vldr	s0, [sp]
 802a68a:	f002 f837 	bl	802c6fc <__kernel_cosf>
 802a68e:	e7eb      	b.n	802a668 <cosf+0x28>
 802a690:	eddd 0a01 	vldr	s1, [sp, #4]
 802a694:	ed9d 0a00 	vldr	s0, [sp]
 802a698:	f002 fb06 	bl	802cca8 <__kernel_sinf>
 802a69c:	eeb1 0a40 	vneg.f32	s0, s0
 802a6a0:	e7e2      	b.n	802a668 <cosf+0x28>
 802a6a2:	eddd 0a01 	vldr	s1, [sp, #4]
 802a6a6:	ed9d 0a00 	vldr	s0, [sp]
 802a6aa:	f002 f827 	bl	802c6fc <__kernel_cosf>
 802a6ae:	e7f5      	b.n	802a69c <cosf+0x5c>
 802a6b0:	eddd 0a01 	vldr	s1, [sp, #4]
 802a6b4:	ed9d 0a00 	vldr	s0, [sp]
 802a6b8:	2001      	movs	r0, #1
 802a6ba:	f002 faf5 	bl	802cca8 <__kernel_sinf>
 802a6be:	e7d3      	b.n	802a668 <cosf+0x28>
 802a6c0:	3f490fd8 	.word	0x3f490fd8
 802a6c4:	00000000 	.word	0x00000000

0802a6c8 <erff>:
 802a6c8:	b538      	push	{r3, r4, r5, lr}
 802a6ca:	ee10 4a10 	vmov	r4, s0
 802a6ce:	f024 4500 	bic.w	r5, r4, #2147483648	; 0x80000000
 802a6d2:	f1b5 4fff 	cmp.w	r5, #2139095040	; 0x7f800000
 802a6d6:	ed2d 8b06 	vpush	{d8-d10}
 802a6da:	eef0 7a40 	vmov.f32	s15, s0
 802a6de:	db10      	blt.n	802a702 <erff+0x3a>
 802a6e0:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
 802a6e4:	ee86 7aa7 	vdiv.f32	s14, s13, s15
 802a6e8:	0fe4      	lsrs	r4, r4, #31
 802a6ea:	0064      	lsls	r4, r4, #1
 802a6ec:	f1c4 0301 	rsb	r3, r4, #1
 802a6f0:	ee00 3a10 	vmov	s0, r3
 802a6f4:	eeb8 0ac0 	vcvt.f32.s32	s0, s0
 802a6f8:	ee30 0a07 	vadd.f32	s0, s0, s14
 802a6fc:	ecbd 8b06 	vpop	{d8-d10}
 802a700:	bd38      	pop	{r3, r4, r5, pc}
 802a702:	4ba2      	ldr	r3, [pc, #648]	; (802a98c <erff+0x2c4>)
 802a704:	429d      	cmp	r5, r3
 802a706:	dc48      	bgt.n	802a79a <erff+0xd2>
 802a708:	f1b5 5f46 	cmp.w	r5, #830472192	; 0x31800000
 802a70c:	da18      	bge.n	802a740 <erff+0x78>
 802a70e:	f014 4ff8 	tst.w	r4, #2080374784	; 0x7c000000
 802a712:	d10e      	bne.n	802a732 <erff+0x6a>
 802a714:	ed9f 0a9e 	vldr	s0, [pc, #632]	; 802a990 <erff+0x2c8>
 802a718:	ee27 0a80 	vmul.f32	s0, s15, s0
 802a71c:	eef2 6a00 	vmov.f32	s13, #32	; 0x41000000  8.0
 802a720:	eeb0 7a40 	vmov.f32	s14, s0
 802a724:	eea7 7aa6 	vfma.f32	s14, s15, s13
 802a728:	eeb4 0a00 	vmov.f32	s0, #64	; 0x3e000000  0.125
 802a72c:	ee27 0a00 	vmul.f32	s0, s14, s0
 802a730:	e7e4      	b.n	802a6fc <erff+0x34>
 802a732:	ed9f 7a98 	vldr	s14, [pc, #608]	; 802a994 <erff+0x2cc>
 802a736:	eee7 7a87 	vfma.f32	s15, s15, s14
 802a73a:	eeb0 0a67 	vmov.f32	s0, s15
 802a73e:	e7dd      	b.n	802a6fc <erff+0x34>
 802a740:	ee20 7a00 	vmul.f32	s14, s0, s0
 802a744:	ed9f 6a94 	vldr	s12, [pc, #592]	; 802a998 <erff+0x2d0>
 802a748:	eddf 6a94 	vldr	s13, [pc, #592]	; 802a99c <erff+0x2d4>
 802a74c:	eddf 5a94 	vldr	s11, [pc, #592]	; 802a9a0 <erff+0x2d8>
 802a750:	eee7 6a06 	vfma.f32	s13, s14, s12
 802a754:	ed9f 6a93 	vldr	s12, [pc, #588]	; 802a9a4 <erff+0x2dc>
 802a758:	eea6 6a87 	vfma.f32	s12, s13, s14
 802a75c:	eddf 6a92 	vldr	s13, [pc, #584]	; 802a9a8 <erff+0x2e0>
 802a760:	eee6 6a07 	vfma.f32	s13, s12, s14
 802a764:	ed9f 6a8b 	vldr	s12, [pc, #556]	; 802a994 <erff+0x2cc>
 802a768:	eea6 6a87 	vfma.f32	s12, s13, s14
 802a76c:	eddf 6a8f 	vldr	s13, [pc, #572]	; 802a9ac <erff+0x2e4>
 802a770:	eee7 6a25 	vfma.f32	s13, s14, s11
 802a774:	eddf 5a8e 	vldr	s11, [pc, #568]	; 802a9b0 <erff+0x2e8>
 802a778:	eee6 5a87 	vfma.f32	s11, s13, s14
 802a77c:	eddf 6a8d 	vldr	s13, [pc, #564]	; 802a9b4 <erff+0x2ec>
 802a780:	eee5 6a87 	vfma.f32	s13, s11, s14
 802a784:	eddf 5a8c 	vldr	s11, [pc, #560]	; 802a9b8 <erff+0x2f0>
 802a788:	eee6 5a87 	vfma.f32	s11, s13, s14
 802a78c:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
 802a790:	eee5 6a87 	vfma.f32	s13, s11, s14
 802a794:	ee86 7a26 	vdiv.f32	s14, s12, s13
 802a798:	e7cd      	b.n	802a736 <erff+0x6e>
 802a79a:	4b88      	ldr	r3, [pc, #544]	; (802a9bc <erff+0x2f4>)
 802a79c:	429d      	cmp	r5, r3
 802a79e:	dc44      	bgt.n	802a82a <erff+0x162>
 802a7a0:	f000 f96c 	bl	802aa7c <fabsf>
 802a7a4:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
 802a7a8:	ee30 0a67 	vsub.f32	s0, s0, s15
 802a7ac:	ed9f 7a84 	vldr	s14, [pc, #528]	; 802a9c0 <erff+0x2f8>
 802a7b0:	eddf 6a84 	vldr	s13, [pc, #528]	; 802a9c4 <erff+0x2fc>
 802a7b4:	ed9f 6a84 	vldr	s12, [pc, #528]	; 802a9c8 <erff+0x300>
 802a7b8:	eee0 6a07 	vfma.f32	s13, s0, s14
 802a7bc:	2c00      	cmp	r4, #0
 802a7be:	ed9f 7a83 	vldr	s14, [pc, #524]	; 802a9cc <erff+0x304>
 802a7c2:	eea6 7a80 	vfma.f32	s14, s13, s0
 802a7c6:	eddf 6a82 	vldr	s13, [pc, #520]	; 802a9d0 <erff+0x308>
 802a7ca:	eee7 6a00 	vfma.f32	s13, s14, s0
 802a7ce:	ed9f 7a81 	vldr	s14, [pc, #516]	; 802a9d4 <erff+0x30c>
 802a7d2:	eea6 7a80 	vfma.f32	s14, s13, s0
 802a7d6:	eddf 6a80 	vldr	s13, [pc, #512]	; 802a9d8 <erff+0x310>
 802a7da:	eee7 6a00 	vfma.f32	s13, s14, s0
 802a7de:	ed9f 7a7f 	vldr	s14, [pc, #508]	; 802a9dc <erff+0x314>
 802a7e2:	eea6 7a80 	vfma.f32	s14, s13, s0
 802a7e6:	eddf 6a7e 	vldr	s13, [pc, #504]	; 802a9e0 <erff+0x318>
 802a7ea:	eee0 6a06 	vfma.f32	s13, s0, s12
 802a7ee:	ed9f 6a7d 	vldr	s12, [pc, #500]	; 802a9e4 <erff+0x31c>
 802a7f2:	eea6 6a80 	vfma.f32	s12, s13, s0
 802a7f6:	eddf 6a7c 	vldr	s13, [pc, #496]	; 802a9e8 <erff+0x320>
 802a7fa:	eee6 6a00 	vfma.f32	s13, s12, s0
 802a7fe:	ed9f 6a7b 	vldr	s12, [pc, #492]	; 802a9ec <erff+0x324>
 802a802:	eea6 6a80 	vfma.f32	s12, s13, s0
 802a806:	eddf 6a7a 	vldr	s13, [pc, #488]	; 802a9f0 <erff+0x328>
 802a80a:	eee6 6a00 	vfma.f32	s13, s12, s0
 802a80e:	eee6 7a80 	vfma.f32	s15, s13, s0
 802a812:	ee87 0a27 	vdiv.f32	s0, s14, s15
 802a816:	bfab      	itete	ge
 802a818:	eddf 7a76 	vldrge	s15, [pc, #472]	; 802a9f4 <erff+0x32c>
 802a81c:	eddf 7a76 	vldrlt	s15, [pc, #472]	; 802a9f8 <erff+0x330>
 802a820:	ee30 0a27 	vaddge.f32	s0, s0, s15
 802a824:	ee37 0ac0 	vsublt.f32	s0, s15, s0
 802a828:	e768      	b.n	802a6fc <erff+0x34>
 802a82a:	4b74      	ldr	r3, [pc, #464]	; (802a9fc <erff+0x334>)
 802a82c:	429d      	cmp	r5, r3
 802a82e:	dd08      	ble.n	802a842 <erff+0x17a>
 802a830:	2c00      	cmp	r4, #0
 802a832:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
 802a836:	eeff 7a00 	vmov.f32	s15, #240	; 0xbf800000 -1.0
 802a83a:	bfb8      	it	lt
 802a83c:	eeb0 0a67 	vmovlt.f32	s0, s15
 802a840:	e75c      	b.n	802a6fc <erff+0x34>
 802a842:	f000 f91b 	bl	802aa7c <fabsf>
 802a846:	4b6e      	ldr	r3, [pc, #440]	; (802aa00 <erff+0x338>)
 802a848:	ee60 7a00 	vmul.f32	s15, s0, s0
 802a84c:	eef7 9a00 	vmov.f32	s19, #112	; 0x3f800000  1.0
 802a850:	429d      	cmp	r5, r3
 802a852:	ee89 7aa7 	vdiv.f32	s14, s19, s15
 802a856:	eeb0 8a40 	vmov.f32	s16, s0
 802a85a:	dc64      	bgt.n	802a926 <erff+0x25e>
 802a85c:	eddf 7a69 	vldr	s15, [pc, #420]	; 802aa04 <erff+0x33c>
 802a860:	eddf 6a69 	vldr	s13, [pc, #420]	; 802aa08 <erff+0x340>
 802a864:	ed9f 9a69 	vldr	s18, [pc, #420]	; 802aa0c <erff+0x344>
 802a868:	eee7 6a27 	vfma.f32	s13, s14, s15
 802a86c:	eddf 7a68 	vldr	s15, [pc, #416]	; 802aa10 <erff+0x348>
 802a870:	eee6 7a87 	vfma.f32	s15, s13, s14
 802a874:	eddf 6a67 	vldr	s13, [pc, #412]	; 802aa14 <erff+0x34c>
 802a878:	eee7 6a87 	vfma.f32	s13, s15, s14
 802a87c:	eddf 7a66 	vldr	s15, [pc, #408]	; 802aa18 <erff+0x350>
 802a880:	eee6 7a87 	vfma.f32	s15, s13, s14
 802a884:	eddf 6a65 	vldr	s13, [pc, #404]	; 802aa1c <erff+0x354>
 802a888:	eee7 6a87 	vfma.f32	s13, s15, s14
 802a88c:	eddf 7a64 	vldr	s15, [pc, #400]	; 802aa20 <erff+0x358>
 802a890:	eee6 7a87 	vfma.f32	s15, s13, s14
 802a894:	eddf 6a63 	vldr	s13, [pc, #396]	; 802aa24 <erff+0x35c>
 802a898:	eea7 9a87 	vfma.f32	s18, s15, s14
 802a89c:	eddf 7a62 	vldr	s15, [pc, #392]	; 802aa28 <erff+0x360>
 802a8a0:	eee7 7a26 	vfma.f32	s15, s14, s13
 802a8a4:	eddf 6a61 	vldr	s13, [pc, #388]	; 802aa2c <erff+0x364>
 802a8a8:	eee7 6a87 	vfma.f32	s13, s15, s14
 802a8ac:	eddf 7a60 	vldr	s15, [pc, #384]	; 802aa30 <erff+0x368>
 802a8b0:	eee6 7a87 	vfma.f32	s15, s13, s14
 802a8b4:	eddf 6a5f 	vldr	s13, [pc, #380]	; 802aa34 <erff+0x36c>
 802a8b8:	eee7 6a87 	vfma.f32	s13, s15, s14
 802a8bc:	eddf 7a5e 	vldr	s15, [pc, #376]	; 802aa38 <erff+0x370>
 802a8c0:	eee6 7a87 	vfma.f32	s15, s13, s14
 802a8c4:	eddf 6a5d 	vldr	s13, [pc, #372]	; 802aa3c <erff+0x374>
 802a8c8:	eee7 6a87 	vfma.f32	s13, s15, s14
 802a8cc:	eddf 7a5c 	vldr	s15, [pc, #368]	; 802aa40 <erff+0x378>
 802a8d0:	ee18 3a10 	vmov	r3, s16
 802a8d4:	eee6 7a87 	vfma.f32	s15, s13, s14
 802a8d8:	f423 637f 	bic.w	r3, r3, #4080	; 0xff0
 802a8dc:	f023 030f 	bic.w	r3, r3, #15
 802a8e0:	ee08 3a90 	vmov	s17, r3
 802a8e4:	eef0 aa69 	vmov.f32	s21, s19
 802a8e8:	eebe 0a02 	vmov.f32	s0, #226	; 0xbf100000 -0.5625000
 802a8ec:	eee7 aa87 	vfma.f32	s21, s15, s14
 802a8f0:	eea8 0ae8 	vfms.f32	s0, s17, s17
 802a8f4:	f000 ffec 	bl	802b8d0 <__ieee754_expf>
 802a8f8:	eeb0 aa40 	vmov.f32	s20, s0
 802a8fc:	ee89 0a2a 	vdiv.f32	s0, s18, s21
 802a900:	ee78 7ac8 	vsub.f32	s15, s17, s16
 802a904:	ee78 8a28 	vadd.f32	s17, s16, s17
 802a908:	eea7 0aa8 	vfma.f32	s0, s15, s17
 802a90c:	f000 ffe0 	bl	802b8d0 <__ieee754_expf>
 802a910:	ee2a 0a00 	vmul.f32	s0, s20, s0
 802a914:	2c00      	cmp	r4, #0
 802a916:	eec0 7a08 	vdiv.f32	s15, s0, s16
 802a91a:	bfac      	ite	ge
 802a91c:	ee39 0ae7 	vsubge.f32	s0, s19, s15
 802a920:	ee37 0ae9 	vsublt.f32	s0, s15, s19
 802a924:	e6ea      	b.n	802a6fc <erff+0x34>
 802a926:	eddf 6a47 	vldr	s13, [pc, #284]	; 802aa44 <erff+0x37c>
 802a92a:	eddf 7a47 	vldr	s15, [pc, #284]	; 802aa48 <erff+0x380>
 802a92e:	ed9f 9a47 	vldr	s18, [pc, #284]	; 802aa4c <erff+0x384>
 802a932:	eee7 7a26 	vfma.f32	s15, s14, s13
 802a936:	eddf 6a46 	vldr	s13, [pc, #280]	; 802aa50 <erff+0x388>
 802a93a:	eee7 6a87 	vfma.f32	s13, s15, s14
 802a93e:	eddf 7a45 	vldr	s15, [pc, #276]	; 802aa54 <erff+0x38c>
 802a942:	eee6 7a87 	vfma.f32	s15, s13, s14
 802a946:	eddf 6a44 	vldr	s13, [pc, #272]	; 802aa58 <erff+0x390>
 802a94a:	eee7 6a87 	vfma.f32	s13, s15, s14
 802a94e:	eddf 7a43 	vldr	s15, [pc, #268]	; 802aa5c <erff+0x394>
 802a952:	eee6 7a87 	vfma.f32	s15, s13, s14
 802a956:	eddf 6a42 	vldr	s13, [pc, #264]	; 802aa60 <erff+0x398>
 802a95a:	eea7 9a87 	vfma.f32	s18, s15, s14
 802a95e:	eddf 7a41 	vldr	s15, [pc, #260]	; 802aa64 <erff+0x39c>
 802a962:	eee7 6a27 	vfma.f32	s13, s14, s15
 802a966:	eddf 7a40 	vldr	s15, [pc, #256]	; 802aa68 <erff+0x3a0>
 802a96a:	eee6 7a87 	vfma.f32	s15, s13, s14
 802a96e:	eddf 6a3f 	vldr	s13, [pc, #252]	; 802aa6c <erff+0x3a4>
 802a972:	eee7 6a87 	vfma.f32	s13, s15, s14
 802a976:	eddf 7a3e 	vldr	s15, [pc, #248]	; 802aa70 <erff+0x3a8>
 802a97a:	eee6 7a87 	vfma.f32	s15, s13, s14
 802a97e:	eddf 6a3d 	vldr	s13, [pc, #244]	; 802aa74 <erff+0x3ac>
 802a982:	eee7 6a87 	vfma.f32	s13, s15, s14
 802a986:	eddf 7a3c 	vldr	s15, [pc, #240]	; 802aa78 <erff+0x3b0>
 802a98a:	e7a1      	b.n	802a8d0 <erff+0x208>
 802a98c:	3f57ffff 	.word	0x3f57ffff
 802a990:	3f8375d4 	.word	0x3f8375d4
 802a994:	3e0375d4 	.word	0x3e0375d4
 802a998:	b7c756b1 	.word	0xb7c756b1
 802a99c:	bbbd1489 	.word	0xbbbd1489
 802a9a0:	b684e21a 	.word	0xb684e21a
 802a9a4:	bce9528f 	.word	0xbce9528f
 802a9a8:	bea66beb 	.word	0xbea66beb
 802a9ac:	390aee49 	.word	0x390aee49
 802a9b0:	3ba68116 	.word	0x3ba68116
 802a9b4:	3d852a63 	.word	0x3d852a63
 802a9b8:	3ecbbbce 	.word	0x3ecbbbce
 802a9bc:	3f9fffff 	.word	0x3f9fffff
 802a9c0:	bb0df9c0 	.word	0xbb0df9c0
 802a9c4:	3d1151b3 	.word	0x3d1151b3
 802a9c8:	3c445aa3 	.word	0x3c445aa3
 802a9cc:	bde31cc2 	.word	0xbde31cc2
 802a9d0:	3ea2fe54 	.word	0x3ea2fe54
 802a9d4:	bebe9208 	.word	0xbebe9208
 802a9d8:	3ed46805 	.word	0x3ed46805
 802a9dc:	bb1acdc6 	.word	0xbb1acdc6
 802a9e0:	3c5f6e13 	.word	0x3c5f6e13
 802a9e4:	3e013307 	.word	0x3e013307
 802a9e8:	3d931ae7 	.word	0x3d931ae7
 802a9ec:	3f0a5785 	.word	0x3f0a5785
 802a9f0:	3dd9f331 	.word	0x3dd9f331
 802a9f4:	3f58560b 	.word	0x3f58560b
 802a9f8:	bf58560b 	.word	0xbf58560b
 802a9fc:	40bfffff 	.word	0x40bfffff
 802aa00:	4036db6d 	.word	0x4036db6d
 802aa04:	c11d077e 	.word	0xc11d077e
 802aa08:	c2a2932b 	.word	0xc2a2932b
 802aa0c:	bc21a093 	.word	0xbc21a093
 802aa10:	c3389ae7 	.word	0xc3389ae7
 802aa14:	c322658c 	.word	0xc322658c
 802aa18:	c2798057 	.word	0xc2798057
 802aa1c:	c128f022 	.word	0xc128f022
 802aa20:	bf31a0b7 	.word	0xbf31a0b7
 802aa24:	bd777f97 	.word	0xbd777f97
 802aa28:	40d23f7c 	.word	0x40d23f7c
 802aa2c:	42d9451f 	.word	0x42d9451f
 802aa30:	43d6810b 	.word	0x43d6810b
 802aa34:	442158c9 	.word	0x442158c9
 802aa38:	43d9486f 	.word	0x43d9486f
 802aa3c:	4309a863 	.word	0x4309a863
 802aa40:	419d35ce 	.word	0x419d35ce
 802aa44:	c3f1c275 	.word	0xc3f1c275
 802aa48:	c480230b 	.word	0xc480230b
 802aa4c:	bc21a092 	.word	0xbc21a092
 802aa50:	c41f6441 	.word	0xc41f6441
 802aa54:	c320a2ea 	.word	0xc320a2ea
 802aa58:	c18e104b 	.word	0xc18e104b
 802aa5c:	bf4c9dd4 	.word	0xbf4c9dd4
 802aa60:	43ed43a7 	.word	0x43ed43a7
 802aa64:	c1b38712 	.word	0xc1b38712
 802aa68:	451f90ce 	.word	0x451f90ce
 802aa6c:	4547fdbb 	.word	0x4547fdbb
 802aa70:	44c01759 	.word	0x44c01759
 802aa74:	43a2e571 	.word	0x43a2e571
 802aa78:	41f2b459 	.word	0x41f2b459

0802aa7c <fabsf>:
 802aa7c:	ee10 3a10 	vmov	r3, s0
 802aa80:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
 802aa84:	ee00 3a10 	vmov	s0, r3
 802aa88:	4770      	bx	lr
	...

0802aa8c <floorf>:
 802aa8c:	ee10 3a10 	vmov	r3, s0
 802aa90:	f3c3 52c7 	ubfx	r2, r3, #23, #8
 802aa94:	3a7f      	subs	r2, #127	; 0x7f
 802aa96:	2a16      	cmp	r2, #22
 802aa98:	f023 4100 	bic.w	r1, r3, #2147483648	; 0x80000000
 802aa9c:	dc2a      	bgt.n	802aaf4 <floorf+0x68>
 802aa9e:	2a00      	cmp	r2, #0
 802aaa0:	da11      	bge.n	802aac6 <floorf+0x3a>
 802aaa2:	eddf 7a18 	vldr	s15, [pc, #96]	; 802ab04 <floorf+0x78>
 802aaa6:	ee30 0a27 	vadd.f32	s0, s0, s15
 802aaaa:	eeb5 0ac0 	vcmpe.f32	s0, #0.0
 802aaae:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802aab2:	dd05      	ble.n	802aac0 <floorf+0x34>
 802aab4:	2b00      	cmp	r3, #0
 802aab6:	da23      	bge.n	802ab00 <floorf+0x74>
 802aab8:	4a13      	ldr	r2, [pc, #76]	; (802ab08 <floorf+0x7c>)
 802aaba:	2900      	cmp	r1, #0
 802aabc:	bf18      	it	ne
 802aabe:	4613      	movne	r3, r2
 802aac0:	ee00 3a10 	vmov	s0, r3
 802aac4:	4770      	bx	lr
 802aac6:	4911      	ldr	r1, [pc, #68]	; (802ab0c <floorf+0x80>)
 802aac8:	4111      	asrs	r1, r2
 802aaca:	420b      	tst	r3, r1
 802aacc:	d0fa      	beq.n	802aac4 <floorf+0x38>
 802aace:	eddf 7a0d 	vldr	s15, [pc, #52]	; 802ab04 <floorf+0x78>
 802aad2:	ee30 0a27 	vadd.f32	s0, s0, s15
 802aad6:	eeb5 0ac0 	vcmpe.f32	s0, #0.0
 802aada:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802aade:	ddef      	ble.n	802aac0 <floorf+0x34>
 802aae0:	2b00      	cmp	r3, #0
 802aae2:	bfbe      	ittt	lt
 802aae4:	f44f 0000 	movlt.w	r0, #8388608	; 0x800000
 802aae8:	fa40 f202 	asrlt.w	r2, r0, r2
 802aaec:	189b      	addlt	r3, r3, r2
 802aaee:	ea23 0301 	bic.w	r3, r3, r1
 802aaf2:	e7e5      	b.n	802aac0 <floorf+0x34>
 802aaf4:	f1b1 4fff 	cmp.w	r1, #2139095040	; 0x7f800000
 802aaf8:	d3e4      	bcc.n	802aac4 <floorf+0x38>
 802aafa:	ee30 0a00 	vadd.f32	s0, s0, s0
 802aafe:	4770      	bx	lr
 802ab00:	2300      	movs	r3, #0
 802ab02:	e7dd      	b.n	802aac0 <floorf+0x34>
 802ab04:	7149f2ca 	.word	0x7149f2ca
 802ab08:	bf800000 	.word	0xbf800000
 802ab0c:	007fffff 	.word	0x007fffff

0802ab10 <log1pf>:
 802ab10:	ee10 2a10 	vmov	r2, s0
 802ab14:	f1b2 4fff 	cmp.w	r2, #2139095040	; 0x7f800000
 802ab18:	eef0 7a40 	vmov.f32	s15, s0
 802ab1c:	db04      	blt.n	802ab28 <log1pf+0x18>
 802ab1e:	ee70 7a00 	vadd.f32	s15, s0, s0
 802ab22:	eeb0 0a67 	vmov.f32	s0, s15
 802ab26:	4770      	bx	lr
 802ab28:	4b6a      	ldr	r3, [pc, #424]	; (802acd4 <log1pf+0x1c4>)
 802ab2a:	429a      	cmp	r2, r3
 802ab2c:	dc6f      	bgt.n	802ac0e <log1pf+0xfe>
 802ab2e:	f022 4300 	bic.w	r3, r2, #2147483648	; 0x80000000
 802ab32:	f1b3 5f7e 	cmp.w	r3, #1065353216	; 0x3f800000
 802ab36:	db0b      	blt.n	802ab50 <log1pf+0x40>
 802ab38:	eebf 7a00 	vmov.f32	s14, #240	; 0xbf800000 -1.0
 802ab3c:	eeb4 0a47 	vcmp.f32	s0, s14
 802ab40:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802ab44:	d102      	bne.n	802ab4c <log1pf+0x3c>
 802ab46:	2001      	movs	r0, #1
 802ab48:	f002 b9f8 	b.w	802cf3c <__math_divzerof>
 802ab4c:	f002 ba08 	b.w	802cf60 <__math_invalidf>
 802ab50:	f1b3 5f44 	cmp.w	r3, #822083584	; 0x31000000
 802ab54:	da12      	bge.n	802ab7c <log1pf+0x6c>
 802ab56:	ed9f 7a60 	vldr	s14, [pc, #384]	; 802acd8 <log1pf+0x1c8>
 802ab5a:	ee30 7a07 	vadd.f32	s14, s0, s14
 802ab5e:	eeb5 7ac0 	vcmpe.f32	s14, #0.0
 802ab62:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802ab66:	dd02      	ble.n	802ab6e <log1pf+0x5e>
 802ab68:	f1b3 5f12 	cmp.w	r3, #612368384	; 0x24800000
 802ab6c:	dbd9      	blt.n	802ab22 <log1pf+0x12>
 802ab6e:	ee67 6ae7 	vnmul.f32	s13, s15, s15
 802ab72:	eeb6 7a00 	vmov.f32	s14, #96	; 0x3f000000  0.5
 802ab76:	eee6 7a87 	vfma.f32	s15, s13, s14
 802ab7a:	e7d2      	b.n	802ab22 <log1pf+0x12>
 802ab7c:	4b57      	ldr	r3, [pc, #348]	; (802acdc <log1pf+0x1cc>)
 802ab7e:	441a      	add	r2, r3
 802ab80:	429a      	cmp	r2, r3
 802ab82:	d84c      	bhi.n	802ac1e <log1pf+0x10e>
 802ab84:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
 802ab88:	ee77 6a87 	vadd.f32	s13, s15, s14
 802ab8c:	ee16 2a90 	vmov	r2, s13
 802ab90:	15d3      	asrs	r3, r2, #23
 802ab92:	3b7f      	subs	r3, #127	; 0x7f
 802ab94:	2b00      	cmp	r3, #0
 802ab96:	bfcb      	itete	gt
 802ab98:	ee76 7ae7 	vsubgt.f32	s15, s13, s15
 802ab9c:	ee36 7ac7 	vsuble.f32	s14, s13, s14
 802aba0:	ee77 7a67 	vsubgt.f32	s15, s14, s15
 802aba4:	ee77 7ac7 	vsuble.f32	s15, s15, s14
 802aba8:	ee87 6aa6 	vdiv.f32	s12, s15, s13
 802abac:	494c      	ldr	r1, [pc, #304]	; (802ace0 <log1pf+0x1d0>)
 802abae:	f3c2 0216 	ubfx	r2, r2, #0, #23
 802abb2:	428a      	cmp	r2, r1
 802abb4:	bfc9      	itett	gt
 802abb6:	f042 517c 	orrgt.w	r1, r2, #1056964608	; 0x3f000000
 802abba:	f042 517e 	orrle.w	r1, r2, #1065353216	; 0x3f800000
 802abbe:	f5c2 0200 	rsbgt	r2, r2, #8388608	; 0x800000
 802abc2:	3301      	addgt	r3, #1
 802abc4:	bfc8      	it	gt
 802abc6:	1092      	asrgt	r2, r2, #2
 802abc8:	ee07 1a10 	vmov	s14, r1
 802abcc:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
 802abd0:	ee77 7a67 	vsub.f32	s15, s14, s15
 802abd4:	eef6 6a00 	vmov.f32	s13, #96	; 0x3f000000  0.5
 802abd8:	ee67 6aa6 	vmul.f32	s13, s15, s13
 802abdc:	ee66 6aa7 	vmul.f32	s13, s13, s15
 802abe0:	bbea      	cbnz	r2, 802ac5e <log1pf+0x14e>
 802abe2:	eef5 7a40 	vcmp.f32	s15, #0.0
 802abe6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802abea:	d11b      	bne.n	802ac24 <log1pf+0x114>
 802abec:	2b00      	cmp	r3, #0
 802abee:	d06d      	beq.n	802accc <log1pf+0x1bc>
 802abf0:	ee07 3a90 	vmov	s15, r3
 802abf4:	eddf 6a3b 	vldr	s13, [pc, #236]	; 802ace4 <log1pf+0x1d4>
 802abf8:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
 802abfc:	eef0 7a46 	vmov.f32	s15, s12
 802ac00:	eee7 7a26 	vfma.f32	s15, s14, s13
 802ac04:	eddf 6a38 	vldr	s13, [pc, #224]	; 802ace8 <log1pf+0x1d8>
 802ac08:	eee7 7a26 	vfma.f32	s15, s14, s13
 802ac0c:	e789      	b.n	802ab22 <log1pf+0x12>
 802ac0e:	f1b2 4fb4 	cmp.w	r2, #1509949440	; 0x5a000000
 802ac12:	dbb7      	blt.n	802ab84 <log1pf+0x74>
 802ac14:	15d3      	asrs	r3, r2, #23
 802ac16:	ed9f 6a35 	vldr	s12, [pc, #212]	; 802acec <log1pf+0x1dc>
 802ac1a:	3b7f      	subs	r3, #127	; 0x7f
 802ac1c:	e7c6      	b.n	802abac <log1pf+0x9c>
 802ac1e:	2201      	movs	r2, #1
 802ac20:	2300      	movs	r3, #0
 802ac22:	e7d7      	b.n	802abd4 <log1pf+0xc4>
 802ac24:	eddf 5a32 	vldr	s11, [pc, #200]	; 802acf0 <log1pf+0x1e0>
 802ac28:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
 802ac2c:	eea7 7ae5 	vfms.f32	s14, s15, s11
 802ac30:	ee67 6a26 	vmul.f32	s13, s14, s13
 802ac34:	b913      	cbnz	r3, 802ac3c <log1pf+0x12c>
 802ac36:	ee77 7ae6 	vsub.f32	s15, s15, s13
 802ac3a:	e772      	b.n	802ab22 <log1pf+0x12>
 802ac3c:	ee07 3a10 	vmov	s14, r3
 802ac40:	eddf 5a28 	vldr	s11, [pc, #160]	; 802ace4 <log1pf+0x1d4>
 802ac44:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
 802ac48:	eea7 6a25 	vfma.f32	s12, s14, s11
 802ac4c:	ee76 6ac6 	vsub.f32	s13, s13, s12
 802ac50:	ee76 7ae7 	vsub.f32	s15, s13, s15
 802ac54:	eddf 6a24 	vldr	s13, [pc, #144]	; 802ace8 <log1pf+0x1d8>
 802ac58:	eed7 7a26 	vfnms.f32	s15, s14, s13
 802ac5c:	e761      	b.n	802ab22 <log1pf+0x12>
 802ac5e:	eeb0 7a00 	vmov.f32	s14, #0	; 0x40000000  2.0
 802ac62:	ee37 7a87 	vadd.f32	s14, s15, s14
 802ac66:	ed9f 5a23 	vldr	s10, [pc, #140]	; 802acf4 <log1pf+0x1e4>
 802ac6a:	eddf 4a23 	vldr	s9, [pc, #140]	; 802acf8 <log1pf+0x1e8>
 802ac6e:	eec7 5a87 	vdiv.f32	s11, s15, s14
 802ac72:	ee25 7aa5 	vmul.f32	s14, s11, s11
 802ac76:	eee7 4a05 	vfma.f32	s9, s14, s10
 802ac7a:	ed9f 5a20 	vldr	s10, [pc, #128]	; 802acfc <log1pf+0x1ec>
 802ac7e:	eea4 5a87 	vfma.f32	s10, s9, s14
 802ac82:	eddf 4a1f 	vldr	s9, [pc, #124]	; 802ad00 <log1pf+0x1f0>
 802ac86:	eee5 4a07 	vfma.f32	s9, s10, s14
 802ac8a:	ed9f 5a1e 	vldr	s10, [pc, #120]	; 802ad04 <log1pf+0x1f4>
 802ac8e:	eea4 5a87 	vfma.f32	s10, s9, s14
 802ac92:	eddf 4a1d 	vldr	s9, [pc, #116]	; 802ad08 <log1pf+0x1f8>
 802ac96:	eee5 4a07 	vfma.f32	s9, s10, s14
 802ac9a:	ed9f 5a15 	vldr	s10, [pc, #84]	; 802acf0 <log1pf+0x1e0>
 802ac9e:	eea4 5a87 	vfma.f32	s10, s9, s14
 802aca2:	eef0 4a66 	vmov.f32	s9, s13
 802aca6:	eee5 4a07 	vfma.f32	s9, s10, s14
 802acaa:	ee65 5aa4 	vmul.f32	s11, s11, s9
 802acae:	b913      	cbnz	r3, 802acb6 <log1pf+0x1a6>
 802acb0:	ee76 6ae5 	vsub.f32	s13, s13, s11
 802acb4:	e7bf      	b.n	802ac36 <log1pf+0x126>
 802acb6:	ee07 3a10 	vmov	s14, r3
 802acba:	ed9f 5a0a 	vldr	s10, [pc, #40]	; 802ace4 <log1pf+0x1d4>
 802acbe:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
 802acc2:	eea7 6a05 	vfma.f32	s12, s14, s10
 802acc6:	ee36 6a25 	vadd.f32	s12, s12, s11
 802acca:	e7bf      	b.n	802ac4c <log1pf+0x13c>
 802accc:	eddf 7a07 	vldr	s15, [pc, #28]	; 802acec <log1pf+0x1dc>
 802acd0:	e727      	b.n	802ab22 <log1pf+0x12>
 802acd2:	bf00      	nop
 802acd4:	3ed413d6 	.word	0x3ed413d6
 802acd8:	4c000000 	.word	0x4c000000
 802acdc:	416a09e0 	.word	0x416a09e0
 802ace0:	003504f6 	.word	0x003504f6
 802ace4:	3717f7d1 	.word	0x3717f7d1
 802ace8:	3f317180 	.word	0x3f317180
 802acec:	00000000 	.word	0x00000000
 802acf0:	3f2aaaab 	.word	0x3f2aaaab
 802acf4:	3e178897 	.word	0x3e178897
 802acf8:	3e1cd04f 	.word	0x3e1cd04f
 802acfc:	3e3a3325 	.word	0x3e3a3325
 802ad00:	3e638e29 	.word	0x3e638e29
 802ad04:	3e924925 	.word	0x3e924925
 802ad08:	3ecccccd 	.word	0x3ecccccd

0802ad0c <roundf>:
 802ad0c:	ee10 0a10 	vmov	r0, s0
 802ad10:	f3c0 52c7 	ubfx	r2, r0, #23, #8
 802ad14:	3a7f      	subs	r2, #127	; 0x7f
 802ad16:	2a16      	cmp	r2, #22
 802ad18:	dc15      	bgt.n	802ad46 <roundf+0x3a>
 802ad1a:	2a00      	cmp	r2, #0
 802ad1c:	da08      	bge.n	802ad30 <roundf+0x24>
 802ad1e:	3201      	adds	r2, #1
 802ad20:	f000 4300 	and.w	r3, r0, #2147483648	; 0x80000000
 802ad24:	d101      	bne.n	802ad2a <roundf+0x1e>
 802ad26:	f043 537e 	orr.w	r3, r3, #1065353216	; 0x3f800000
 802ad2a:	ee00 3a10 	vmov	s0, r3
 802ad2e:	4770      	bx	lr
 802ad30:	4907      	ldr	r1, [pc, #28]	; (802ad50 <roundf+0x44>)
 802ad32:	4111      	asrs	r1, r2
 802ad34:	4208      	tst	r0, r1
 802ad36:	d0fa      	beq.n	802ad2e <roundf+0x22>
 802ad38:	f44f 0380 	mov.w	r3, #4194304	; 0x400000
 802ad3c:	4113      	asrs	r3, r2
 802ad3e:	4403      	add	r3, r0
 802ad40:	ea23 0301 	bic.w	r3, r3, r1
 802ad44:	e7f1      	b.n	802ad2a <roundf+0x1e>
 802ad46:	2a80      	cmp	r2, #128	; 0x80
 802ad48:	d1f1      	bne.n	802ad2e <roundf+0x22>
 802ad4a:	ee30 0a00 	vadd.f32	s0, s0, s0
 802ad4e:	4770      	bx	lr
 802ad50:	007fffff 	.word	0x007fffff

0802ad54 <sinf>:
 802ad54:	ee10 3a10 	vmov	r3, s0
 802ad58:	b507      	push	{r0, r1, r2, lr}
 802ad5a:	4a1f      	ldr	r2, [pc, #124]	; (802add8 <sinf+0x84>)
 802ad5c:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
 802ad60:	4293      	cmp	r3, r2
 802ad62:	dc07      	bgt.n	802ad74 <sinf+0x20>
 802ad64:	eddf 0a1d 	vldr	s1, [pc, #116]	; 802addc <sinf+0x88>
 802ad68:	2000      	movs	r0, #0
 802ad6a:	b003      	add	sp, #12
 802ad6c:	f85d eb04 	ldr.w	lr, [sp], #4
 802ad70:	f001 bf9a 	b.w	802cca8 <__kernel_sinf>
 802ad74:	f1b3 4fff 	cmp.w	r3, #2139095040	; 0x7f800000
 802ad78:	db04      	blt.n	802ad84 <sinf+0x30>
 802ad7a:	ee30 0a40 	vsub.f32	s0, s0, s0
 802ad7e:	b003      	add	sp, #12
 802ad80:	f85d fb04 	ldr.w	pc, [sp], #4
 802ad84:	4668      	mov	r0, sp
 802ad86:	f001 fb09 	bl	802c39c <__ieee754_rem_pio2f>
 802ad8a:	f000 0003 	and.w	r0, r0, #3
 802ad8e:	2801      	cmp	r0, #1
 802ad90:	d00a      	beq.n	802ada8 <sinf+0x54>
 802ad92:	2802      	cmp	r0, #2
 802ad94:	d00f      	beq.n	802adb6 <sinf+0x62>
 802ad96:	b9c0      	cbnz	r0, 802adca <sinf+0x76>
 802ad98:	eddd 0a01 	vldr	s1, [sp, #4]
 802ad9c:	ed9d 0a00 	vldr	s0, [sp]
 802ada0:	2001      	movs	r0, #1
 802ada2:	f001 ff81 	bl	802cca8 <__kernel_sinf>
 802ada6:	e7ea      	b.n	802ad7e <sinf+0x2a>
 802ada8:	eddd 0a01 	vldr	s1, [sp, #4]
 802adac:	ed9d 0a00 	vldr	s0, [sp]
 802adb0:	f001 fca4 	bl	802c6fc <__kernel_cosf>
 802adb4:	e7e3      	b.n	802ad7e <sinf+0x2a>
 802adb6:	eddd 0a01 	vldr	s1, [sp, #4]
 802adba:	ed9d 0a00 	vldr	s0, [sp]
 802adbe:	2001      	movs	r0, #1
 802adc0:	f001 ff72 	bl	802cca8 <__kernel_sinf>
 802adc4:	eeb1 0a40 	vneg.f32	s0, s0
 802adc8:	e7d9      	b.n	802ad7e <sinf+0x2a>
 802adca:	eddd 0a01 	vldr	s1, [sp, #4]
 802adce:	ed9d 0a00 	vldr	s0, [sp]
 802add2:	f001 fc93 	bl	802c6fc <__kernel_cosf>
 802add6:	e7f5      	b.n	802adc4 <sinf+0x70>
 802add8:	3f490fd8 	.word	0x3f490fd8
 802addc:	00000000 	.word	0x00000000

0802ade0 <tanf>:
 802ade0:	ee10 3a10 	vmov	r3, s0
 802ade4:	b507      	push	{r0, r1, r2, lr}
 802ade6:	4a12      	ldr	r2, [pc, #72]	; (802ae30 <tanf+0x50>)
 802ade8:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
 802adec:	4293      	cmp	r3, r2
 802adee:	dc07      	bgt.n	802ae00 <tanf+0x20>
 802adf0:	eddf 0a10 	vldr	s1, [pc, #64]	; 802ae34 <tanf+0x54>
 802adf4:	2001      	movs	r0, #1
 802adf6:	b003      	add	sp, #12
 802adf8:	f85d eb04 	ldr.w	lr, [sp], #4
 802adfc:	f001 bf9c 	b.w	802cd38 <__kernel_tanf>
 802ae00:	f1b3 4fff 	cmp.w	r3, #2139095040	; 0x7f800000
 802ae04:	db04      	blt.n	802ae10 <tanf+0x30>
 802ae06:	ee30 0a40 	vsub.f32	s0, s0, s0
 802ae0a:	b003      	add	sp, #12
 802ae0c:	f85d fb04 	ldr.w	pc, [sp], #4
 802ae10:	4668      	mov	r0, sp
 802ae12:	f001 fac3 	bl	802c39c <__ieee754_rem_pio2f>
 802ae16:	0040      	lsls	r0, r0, #1
 802ae18:	f000 0002 	and.w	r0, r0, #2
 802ae1c:	eddd 0a01 	vldr	s1, [sp, #4]
 802ae20:	ed9d 0a00 	vldr	s0, [sp]
 802ae24:	f1c0 0001 	rsb	r0, r0, #1
 802ae28:	f001 ff86 	bl	802cd38 <__kernel_tanf>
 802ae2c:	e7ed      	b.n	802ae0a <tanf+0x2a>
 802ae2e:	bf00      	nop
 802ae30:	3f490fda 	.word	0x3f490fda
 802ae34:	00000000 	.word	0x00000000

0802ae38 <tanhf>:
 802ae38:	b510      	push	{r4, lr}
 802ae3a:	ee10 4a10 	vmov	r4, s0
 802ae3e:	f024 4300 	bic.w	r3, r4, #2147483648	; 0x80000000
 802ae42:	f1b3 4fff 	cmp.w	r3, #2139095040	; 0x7f800000
 802ae46:	ed2d 8b02 	vpush	{d8}
 802ae4a:	eeb0 7a40 	vmov.f32	s14, s0
 802ae4e:	db0c      	blt.n	802ae6a <tanhf+0x32>
 802ae50:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
 802ae54:	eec0 7a07 	vdiv.f32	s15, s0, s14
 802ae58:	2c00      	cmp	r4, #0
 802ae5a:	bfac      	ite	ge
 802ae5c:	ee37 0a80 	vaddge.f32	s0, s15, s0
 802ae60:	ee37 0ac0 	vsublt.f32	s0, s15, s0
 802ae64:	ecbd 8b02 	vpop	{d8}
 802ae68:	bd10      	pop	{r4, pc}
 802ae6a:	4a1b      	ldr	r2, [pc, #108]	; (802aed8 <tanhf+0xa0>)
 802ae6c:	4293      	cmp	r3, r2
 802ae6e:	dc30      	bgt.n	802aed2 <tanhf+0x9a>
 802ae70:	f1b3 5f10 	cmp.w	r3, #603979776	; 0x24000000
 802ae74:	da06      	bge.n	802ae84 <tanhf+0x4c>
 802ae76:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
 802ae7a:	ee70 7a27 	vadd.f32	s15, s0, s15
 802ae7e:	ee27 0a80 	vmul.f32	s0, s15, s0
 802ae82:	e7ef      	b.n	802ae64 <tanhf+0x2c>
 802ae84:	f1b3 5f7e 	cmp.w	r3, #1065353216	; 0x3f800000
 802ae88:	eeb0 8a00 	vmov.f32	s16, #0	; 0x40000000  2.0
 802ae8c:	db12      	blt.n	802aeb4 <tanhf+0x7c>
 802ae8e:	f7ff fdf5 	bl	802aa7c <fabsf>
 802ae92:	ee30 0a00 	vadd.f32	s0, s0, s0
 802ae96:	f002 f873 	bl	802cf80 <expm1f>
 802ae9a:	ee30 0a08 	vadd.f32	s0, s0, s16
 802ae9e:	eec8 7a00 	vdiv.f32	s15, s16, s0
 802aea2:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
 802aea6:	ee30 0a67 	vsub.f32	s0, s0, s15
 802aeaa:	2c00      	cmp	r4, #0
 802aeac:	bfb8      	it	lt
 802aeae:	eeb1 0a40 	vneglt.f32	s0, s0
 802aeb2:	e7d7      	b.n	802ae64 <tanhf+0x2c>
 802aeb4:	f7ff fde2 	bl	802aa7c <fabsf>
 802aeb8:	eef8 7a00 	vmov.f32	s15, #128	; 0xc0000000 -2.0
 802aebc:	ee20 0a27 	vmul.f32	s0, s0, s15
 802aec0:	f002 f85e 	bl	802cf80 <expm1f>
 802aec4:	ee70 7a08 	vadd.f32	s15, s0, s16
 802aec8:	eeb1 7a40 	vneg.f32	s14, s0
 802aecc:	ee87 0a27 	vdiv.f32	s0, s14, s15
 802aed0:	e7eb      	b.n	802aeaa <tanhf+0x72>
 802aed2:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
 802aed6:	e7e8      	b.n	802aeaa <tanhf+0x72>
 802aed8:	41afffff 	.word	0x41afffff

0802aedc <acosf>:
 802aedc:	b508      	push	{r3, lr}
 802aede:	ed2d 8b02 	vpush	{d8}
 802aee2:	eeb0 8a40 	vmov.f32	s16, s0
 802aee6:	f000 fa1b 	bl	802b320 <__ieee754_acosf>
 802aeea:	eeb4 8a48 	vcmp.f32	s16, s16
 802aeee:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802aef2:	eef0 8a40 	vmov.f32	s17, s0
 802aef6:	d615      	bvs.n	802af24 <acosf+0x48>
 802aef8:	eeb0 0a48 	vmov.f32	s0, s16
 802aefc:	f7ff fdbe 	bl	802aa7c <fabsf>
 802af00:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
 802af04:	eeb4 0ae7 	vcmpe.f32	s0, s15
 802af08:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802af0c:	dd0a      	ble.n	802af24 <acosf+0x48>
 802af0e:	f7fc f8f3 	bl	80270f8 <__errno>
 802af12:	ecbd 8b02 	vpop	{d8}
 802af16:	2321      	movs	r3, #33	; 0x21
 802af18:	6003      	str	r3, [r0, #0]
 802af1a:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
 802af1e:	4804      	ldr	r0, [pc, #16]	; (802af30 <acosf+0x54>)
 802af20:	f002 b958 	b.w	802d1d4 <nanf>
 802af24:	eeb0 0a68 	vmov.f32	s0, s17
 802af28:	ecbd 8b02 	vpop	{d8}
 802af2c:	bd08      	pop	{r3, pc}
 802af2e:	bf00      	nop
 802af30:	08057d98 	.word	0x08057d98

0802af34 <acoshf>:
 802af34:	b508      	push	{r3, lr}
 802af36:	ed2d 8b02 	vpush	{d8}
 802af3a:	eeb0 8a40 	vmov.f32	s16, s0
 802af3e:	f000 fae7 	bl	802b510 <__ieee754_acoshf>
 802af42:	eeb4 8a48 	vcmp.f32	s16, s16
 802af46:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802af4a:	d60e      	bvs.n	802af6a <acoshf+0x36>
 802af4c:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
 802af50:	eeb4 8ae7 	vcmpe.f32	s16, s15
 802af54:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802af58:	d507      	bpl.n	802af6a <acoshf+0x36>
 802af5a:	f7fc f8cd 	bl	80270f8 <__errno>
 802af5e:	eddf 7a04 	vldr	s15, [pc, #16]	; 802af70 <acoshf+0x3c>
 802af62:	ee87 0aa7 	vdiv.f32	s0, s15, s15
 802af66:	2321      	movs	r3, #33	; 0x21
 802af68:	6003      	str	r3, [r0, #0]
 802af6a:	ecbd 8b02 	vpop	{d8}
 802af6e:	bd08      	pop	{r3, pc}
 802af70:	00000000 	.word	0x00000000

0802af74 <asinf>:
 802af74:	b508      	push	{r3, lr}
 802af76:	ed2d 8b02 	vpush	{d8}
 802af7a:	eeb0 8a40 	vmov.f32	s16, s0
 802af7e:	f000 fb1b 	bl	802b5b8 <__ieee754_asinf>
 802af82:	eeb4 8a48 	vcmp.f32	s16, s16
 802af86:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802af8a:	eef0 8a40 	vmov.f32	s17, s0
 802af8e:	d615      	bvs.n	802afbc <asinf+0x48>
 802af90:	eeb0 0a48 	vmov.f32	s0, s16
 802af94:	f7ff fd72 	bl	802aa7c <fabsf>
 802af98:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
 802af9c:	eeb4 0ae7 	vcmpe.f32	s0, s15
 802afa0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802afa4:	dd0a      	ble.n	802afbc <asinf+0x48>
 802afa6:	f7fc f8a7 	bl	80270f8 <__errno>
 802afaa:	ecbd 8b02 	vpop	{d8}
 802afae:	2321      	movs	r3, #33	; 0x21
 802afb0:	6003      	str	r3, [r0, #0]
 802afb2:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
 802afb6:	4804      	ldr	r0, [pc, #16]	; (802afc8 <asinf+0x54>)
 802afb8:	f002 b90c 	b.w	802d1d4 <nanf>
 802afbc:	eeb0 0a68 	vmov.f32	s0, s17
 802afc0:	ecbd 8b02 	vpop	{d8}
 802afc4:	bd08      	pop	{r3, pc}
 802afc6:	bf00      	nop
 802afc8:	08057d98 	.word	0x08057d98

0802afcc <atanhf>:
 802afcc:	b510      	push	{r4, lr}
 802afce:	ed2d 8b04 	vpush	{d8-d9}
 802afd2:	eeb0 8a40 	vmov.f32	s16, s0
 802afd6:	f000 fbd5 	bl	802b784 <__ieee754_atanhf>
 802afda:	eeb4 8a48 	vcmp.f32	s16, s16
 802afde:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802afe2:	eef0 8a40 	vmov.f32	s17, s0
 802afe6:	d614      	bvs.n	802b012 <atanhf+0x46>
 802afe8:	eeb0 0a48 	vmov.f32	s0, s16
 802afec:	f7ff fd46 	bl	802aa7c <fabsf>
 802aff0:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
 802aff4:	eeb4 0ae7 	vcmpe.f32	s0, s15
 802aff8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802affc:	db09      	blt.n	802b012 <atanhf+0x46>
 802affe:	ed9f 9a0a 	vldr	s18, [pc, #40]	; 802b028 <atanhf+0x5c>
 802b002:	f04f 0421 	mov.w	r4, #33	; 0x21
 802b006:	dd09      	ble.n	802b01c <atanhf+0x50>
 802b008:	f7fc f876 	bl	80270f8 <__errno>
 802b00c:	eec9 8a09 	vdiv.f32	s17, s18, s18
 802b010:	6004      	str	r4, [r0, #0]
 802b012:	eeb0 0a68 	vmov.f32	s0, s17
 802b016:	ecbd 8b04 	vpop	{d8-d9}
 802b01a:	bd10      	pop	{r4, pc}
 802b01c:	f7fc f86c 	bl	80270f8 <__errno>
 802b020:	eec8 8a09 	vdiv.f32	s17, s16, s18
 802b024:	6004      	str	r4, [r0, #0]
 802b026:	e7f4      	b.n	802b012 <atanhf+0x46>
 802b028:	00000000 	.word	0x00000000

0802b02c <coshf>:
 802b02c:	b508      	push	{r3, lr}
 802b02e:	ed2d 8b02 	vpush	{d8}
 802b032:	eeb0 8a40 	vmov.f32	s16, s0
 802b036:	f000 fbeb 	bl	802b810 <__ieee754_coshf>
 802b03a:	eeb4 8a48 	vcmp.f32	s16, s16
 802b03e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802b042:	eef0 8a40 	vmov.f32	s17, s0
 802b046:	d610      	bvs.n	802b06a <coshf+0x3e>
 802b048:	eeb0 0a48 	vmov.f32	s0, s16
 802b04c:	f7ff fd16 	bl	802aa7c <fabsf>
 802b050:	eddf 7a08 	vldr	s15, [pc, #32]	; 802b074 <coshf+0x48>
 802b054:	eeb4 0ae7 	vcmpe.f32	s0, s15
 802b058:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802b05c:	dd05      	ble.n	802b06a <coshf+0x3e>
 802b05e:	f7fc f84b 	bl	80270f8 <__errno>
 802b062:	eddf 8a05 	vldr	s17, [pc, #20]	; 802b078 <coshf+0x4c>
 802b066:	2322      	movs	r3, #34	; 0x22
 802b068:	6003      	str	r3, [r0, #0]
 802b06a:	eeb0 0a68 	vmov.f32	s0, s17
 802b06e:	ecbd 8b02 	vpop	{d8}
 802b072:	bd08      	pop	{r3, pc}
 802b074:	42b2d4fc 	.word	0x42b2d4fc
 802b078:	7f800000 	.word	0x7f800000

0802b07c <expf>:
 802b07c:	b508      	push	{r3, lr}
 802b07e:	ed2d 8b02 	vpush	{d8}
 802b082:	eef0 8a40 	vmov.f32	s17, s0
 802b086:	f000 fc23 	bl	802b8d0 <__ieee754_expf>
 802b08a:	eeb0 8a40 	vmov.f32	s16, s0
 802b08e:	eeb0 0a68 	vmov.f32	s0, s17
 802b092:	f002 f891 	bl	802d1b8 <finitef>
 802b096:	b160      	cbz	r0, 802b0b2 <expf+0x36>
 802b098:	eddf 7a0f 	vldr	s15, [pc, #60]	; 802b0d8 <expf+0x5c>
 802b09c:	eef4 8ae7 	vcmpe.f32	s17, s15
 802b0a0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802b0a4:	dd0a      	ble.n	802b0bc <expf+0x40>
 802b0a6:	f7fc f827 	bl	80270f8 <__errno>
 802b0aa:	ed9f 8a0c 	vldr	s16, [pc, #48]	; 802b0dc <expf+0x60>
 802b0ae:	2322      	movs	r3, #34	; 0x22
 802b0b0:	6003      	str	r3, [r0, #0]
 802b0b2:	eeb0 0a48 	vmov.f32	s0, s16
 802b0b6:	ecbd 8b02 	vpop	{d8}
 802b0ba:	bd08      	pop	{r3, pc}
 802b0bc:	eddf 7a08 	vldr	s15, [pc, #32]	; 802b0e0 <expf+0x64>
 802b0c0:	eef4 8ae7 	vcmpe.f32	s17, s15
 802b0c4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802b0c8:	d5f3      	bpl.n	802b0b2 <expf+0x36>
 802b0ca:	f7fc f815 	bl	80270f8 <__errno>
 802b0ce:	2322      	movs	r3, #34	; 0x22
 802b0d0:	ed9f 8a04 	vldr	s16, [pc, #16]	; 802b0e4 <expf+0x68>
 802b0d4:	6003      	str	r3, [r0, #0]
 802b0d6:	e7ec      	b.n	802b0b2 <expf+0x36>
 802b0d8:	42b17180 	.word	0x42b17180
 802b0dc:	7f800000 	.word	0x7f800000
 802b0e0:	c2cff1b5 	.word	0xc2cff1b5
 802b0e4:	00000000 	.word	0x00000000

0802b0e8 <fmodf>:
 802b0e8:	b508      	push	{r3, lr}
 802b0ea:	ed2d 8b02 	vpush	{d8}
 802b0ee:	eef0 8a40 	vmov.f32	s17, s0
 802b0f2:	eeb0 8a60 	vmov.f32	s16, s1
 802b0f6:	f000 fcb9 	bl	802ba6c <__ieee754_fmodf>
 802b0fa:	eef4 8a48 	vcmp.f32	s17, s16
 802b0fe:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802b102:	d60c      	bvs.n	802b11e <fmodf+0x36>
 802b104:	eddf 8a07 	vldr	s17, [pc, #28]	; 802b124 <fmodf+0x3c>
 802b108:	eeb4 8a68 	vcmp.f32	s16, s17
 802b10c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802b110:	d105      	bne.n	802b11e <fmodf+0x36>
 802b112:	f7fb fff1 	bl	80270f8 <__errno>
 802b116:	ee88 0aa8 	vdiv.f32	s0, s17, s17
 802b11a:	2321      	movs	r3, #33	; 0x21
 802b11c:	6003      	str	r3, [r0, #0]
 802b11e:	ecbd 8b02 	vpop	{d8}
 802b122:	bd08      	pop	{r3, pc}
 802b124:	00000000 	.word	0x00000000

0802b128 <logf>:
 802b128:	b508      	push	{r3, lr}
 802b12a:	ed2d 8b02 	vpush	{d8}
 802b12e:	eeb0 8a40 	vmov.f32	s16, s0
 802b132:	f000 fd1d 	bl	802bb70 <__ieee754_logf>
 802b136:	eeb4 8a48 	vcmp.f32	s16, s16
 802b13a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802b13e:	d60f      	bvs.n	802b160 <logf+0x38>
 802b140:	eeb5 8ac0 	vcmpe.f32	s16, #0.0
 802b144:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802b148:	dc0a      	bgt.n	802b160 <logf+0x38>
 802b14a:	eeb5 8a40 	vcmp.f32	s16, #0.0
 802b14e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802b152:	d108      	bne.n	802b166 <logf+0x3e>
 802b154:	f7fb ffd0 	bl	80270f8 <__errno>
 802b158:	2322      	movs	r3, #34	; 0x22
 802b15a:	ed9f 0a08 	vldr	s0, [pc, #32]	; 802b17c <logf+0x54>
 802b15e:	6003      	str	r3, [r0, #0]
 802b160:	ecbd 8b02 	vpop	{d8}
 802b164:	bd08      	pop	{r3, pc}
 802b166:	f7fb ffc7 	bl	80270f8 <__errno>
 802b16a:	ecbd 8b02 	vpop	{d8}
 802b16e:	2321      	movs	r3, #33	; 0x21
 802b170:	6003      	str	r3, [r0, #0]
 802b172:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
 802b176:	4802      	ldr	r0, [pc, #8]	; (802b180 <logf+0x58>)
 802b178:	f002 b82c 	b.w	802d1d4 <nanf>
 802b17c:	ff800000 	.word	0xff800000
 802b180:	08057d98 	.word	0x08057d98

0802b184 <log10f>:
 802b184:	b508      	push	{r3, lr}
 802b186:	ed2d 8b02 	vpush	{d8}
 802b18a:	eeb0 8a40 	vmov.f32	s16, s0
 802b18e:	f000 fddf 	bl	802bd50 <__ieee754_log10f>
 802b192:	eeb4 8a48 	vcmp.f32	s16, s16
 802b196:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802b19a:	d60f      	bvs.n	802b1bc <log10f+0x38>
 802b19c:	eeb5 8ac0 	vcmpe.f32	s16, #0.0
 802b1a0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802b1a4:	d80a      	bhi.n	802b1bc <log10f+0x38>
 802b1a6:	eeb5 8a40 	vcmp.f32	s16, #0.0
 802b1aa:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802b1ae:	d108      	bne.n	802b1c2 <log10f+0x3e>
 802b1b0:	f7fb ffa2 	bl	80270f8 <__errno>
 802b1b4:	2322      	movs	r3, #34	; 0x22
 802b1b6:	ed9f 0a08 	vldr	s0, [pc, #32]	; 802b1d8 <log10f+0x54>
 802b1ba:	6003      	str	r3, [r0, #0]
 802b1bc:	ecbd 8b02 	vpop	{d8}
 802b1c0:	bd08      	pop	{r3, pc}
 802b1c2:	f7fb ff99 	bl	80270f8 <__errno>
 802b1c6:	ecbd 8b02 	vpop	{d8}
 802b1ca:	2321      	movs	r3, #33	; 0x21
 802b1cc:	6003      	str	r3, [r0, #0]
 802b1ce:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
 802b1d2:	4802      	ldr	r0, [pc, #8]	; (802b1dc <log10f+0x58>)
 802b1d4:	f001 bffe 	b.w	802d1d4 <nanf>
 802b1d8:	ff800000 	.word	0xff800000
 802b1dc:	08057d98 	.word	0x08057d98

0802b1e0 <powf>:
 802b1e0:	b508      	push	{r3, lr}
 802b1e2:	ed2d 8b04 	vpush	{d8-d9}
 802b1e6:	eeb0 8a60 	vmov.f32	s16, s1
 802b1ea:	eeb0 9a40 	vmov.f32	s18, s0
 802b1ee:	f000 fe07 	bl	802be00 <__ieee754_powf>
 802b1f2:	eeb4 8a48 	vcmp.f32	s16, s16
 802b1f6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802b1fa:	eef0 8a40 	vmov.f32	s17, s0
 802b1fe:	d63e      	bvs.n	802b27e <powf+0x9e>
 802b200:	eeb5 9a40 	vcmp.f32	s18, #0.0
 802b204:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802b208:	d112      	bne.n	802b230 <powf+0x50>
 802b20a:	eeb5 8a40 	vcmp.f32	s16, #0.0
 802b20e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802b212:	d039      	beq.n	802b288 <powf+0xa8>
 802b214:	eeb0 0a48 	vmov.f32	s0, s16
 802b218:	f001 ffce 	bl	802d1b8 <finitef>
 802b21c:	b378      	cbz	r0, 802b27e <powf+0x9e>
 802b21e:	eeb5 8ac0 	vcmpe.f32	s16, #0.0
 802b222:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802b226:	d52a      	bpl.n	802b27e <powf+0x9e>
 802b228:	f7fb ff66 	bl	80270f8 <__errno>
 802b22c:	2322      	movs	r3, #34	; 0x22
 802b22e:	e014      	b.n	802b25a <powf+0x7a>
 802b230:	f001 ffc2 	bl	802d1b8 <finitef>
 802b234:	b998      	cbnz	r0, 802b25e <powf+0x7e>
 802b236:	eeb0 0a49 	vmov.f32	s0, s18
 802b23a:	f001 ffbd 	bl	802d1b8 <finitef>
 802b23e:	b170      	cbz	r0, 802b25e <powf+0x7e>
 802b240:	eeb0 0a48 	vmov.f32	s0, s16
 802b244:	f001 ffb8 	bl	802d1b8 <finitef>
 802b248:	b148      	cbz	r0, 802b25e <powf+0x7e>
 802b24a:	eef4 8a68 	vcmp.f32	s17, s17
 802b24e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802b252:	d7e9      	bvc.n	802b228 <powf+0x48>
 802b254:	f7fb ff50 	bl	80270f8 <__errno>
 802b258:	2321      	movs	r3, #33	; 0x21
 802b25a:	6003      	str	r3, [r0, #0]
 802b25c:	e00f      	b.n	802b27e <powf+0x9e>
 802b25e:	eef5 8a40 	vcmp.f32	s17, #0.0
 802b262:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802b266:	d10a      	bne.n	802b27e <powf+0x9e>
 802b268:	eeb0 0a49 	vmov.f32	s0, s18
 802b26c:	f001 ffa4 	bl	802d1b8 <finitef>
 802b270:	b128      	cbz	r0, 802b27e <powf+0x9e>
 802b272:	eeb0 0a48 	vmov.f32	s0, s16
 802b276:	f001 ff9f 	bl	802d1b8 <finitef>
 802b27a:	2800      	cmp	r0, #0
 802b27c:	d1d4      	bne.n	802b228 <powf+0x48>
 802b27e:	eeb0 0a68 	vmov.f32	s0, s17
 802b282:	ecbd 8b04 	vpop	{d8-d9}
 802b286:	bd08      	pop	{r3, pc}
 802b288:	eef7 8a00 	vmov.f32	s17, #112	; 0x3f800000  1.0
 802b28c:	e7f7      	b.n	802b27e <powf+0x9e>
	...

0802b290 <sinhf>:
 802b290:	b508      	push	{r3, lr}
 802b292:	ed2d 8b02 	vpush	{d8}
 802b296:	eef0 8a40 	vmov.f32	s17, s0
 802b29a:	f001 f9bb 	bl	802c614 <__ieee754_sinhf>
 802b29e:	eeb0 8a40 	vmov.f32	s16, s0
 802b2a2:	f001 ff89 	bl	802d1b8 <finitef>
 802b2a6:	b998      	cbnz	r0, 802b2d0 <sinhf+0x40>
 802b2a8:	eeb0 0a68 	vmov.f32	s0, s17
 802b2ac:	f001 ff84 	bl	802d1b8 <finitef>
 802b2b0:	b170      	cbz	r0, 802b2d0 <sinhf+0x40>
 802b2b2:	f7fb ff21 	bl	80270f8 <__errno>
 802b2b6:	ed9f 8a09 	vldr	s16, [pc, #36]	; 802b2dc <sinhf+0x4c>
 802b2ba:	ed9f 0a09 	vldr	s0, [pc, #36]	; 802b2e0 <sinhf+0x50>
 802b2be:	eef5 8ac0 	vcmpe.f32	s17, #0.0
 802b2c2:	2322      	movs	r3, #34	; 0x22
 802b2c4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802b2c8:	6003      	str	r3, [r0, #0]
 802b2ca:	bfd8      	it	le
 802b2cc:	eeb0 8a40 	vmovle.f32	s16, s0
 802b2d0:	eeb0 0a48 	vmov.f32	s0, s16
 802b2d4:	ecbd 8b02 	vpop	{d8}
 802b2d8:	bd08      	pop	{r3, pc}
 802b2da:	bf00      	nop
 802b2dc:	7f800000 	.word	0x7f800000
 802b2e0:	ff800000 	.word	0xff800000

0802b2e4 <sqrtf>:
 802b2e4:	b508      	push	{r3, lr}
 802b2e6:	ed2d 8b02 	vpush	{d8}
 802b2ea:	eeb0 8a40 	vmov.f32	s16, s0
 802b2ee:	f001 fa01 	bl	802c6f4 <__ieee754_sqrtf>
 802b2f2:	eeb4 8a48 	vcmp.f32	s16, s16
 802b2f6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802b2fa:	d60c      	bvs.n	802b316 <sqrtf+0x32>
 802b2fc:	eddf 8a07 	vldr	s17, [pc, #28]	; 802b31c <sqrtf+0x38>
 802b300:	eeb4 8ae8 	vcmpe.f32	s16, s17
 802b304:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802b308:	d505      	bpl.n	802b316 <sqrtf+0x32>
 802b30a:	f7fb fef5 	bl	80270f8 <__errno>
 802b30e:	ee88 0aa8 	vdiv.f32	s0, s17, s17
 802b312:	2321      	movs	r3, #33	; 0x21
 802b314:	6003      	str	r3, [r0, #0]
 802b316:	ecbd 8b02 	vpop	{d8}
 802b31a:	bd08      	pop	{r3, pc}
 802b31c:	00000000 	.word	0x00000000

0802b320 <__ieee754_acosf>:
 802b320:	b508      	push	{r3, lr}
 802b322:	ee10 3a10 	vmov	r3, s0
 802b326:	f023 4200 	bic.w	r2, r3, #2147483648	; 0x80000000
 802b32a:	f1b2 5f7e 	cmp.w	r2, #1065353216	; 0x3f800000
 802b32e:	ed2d 8b0c 	vpush	{d8-d13}
 802b332:	d10a      	bne.n	802b34a <__ieee754_acosf+0x2a>
 802b334:	ed9f 0a65 	vldr	s0, [pc, #404]	; 802b4cc <__ieee754_acosf+0x1ac>
 802b338:	ed9f 8a65 	vldr	s16, [pc, #404]	; 802b4d0 <__ieee754_acosf+0x1b0>
 802b33c:	2b00      	cmp	r3, #0
 802b33e:	bfd8      	it	le
 802b340:	eeb0 0a48 	vmovle.f32	s0, s16
 802b344:	ecbd 8b0c 	vpop	{d8-d13}
 802b348:	bd08      	pop	{r3, pc}
 802b34a:	dd04      	ble.n	802b356 <__ieee754_acosf+0x36>
 802b34c:	ee30 8a40 	vsub.f32	s16, s0, s0
 802b350:	ee88 0a08 	vdiv.f32	s0, s16, s16
 802b354:	e7f6      	b.n	802b344 <__ieee754_acosf+0x24>
 802b356:	f1b2 5f7c 	cmp.w	r2, #1056964608	; 0x3f000000
 802b35a:	da3c      	bge.n	802b3d6 <__ieee754_acosf+0xb6>
 802b35c:	f1b2 5f0c 	cmp.w	r2, #587202560	; 0x23000000
 802b360:	f340 80b1 	ble.w	802b4c6 <__ieee754_acosf+0x1a6>
 802b364:	ee60 7a00 	vmul.f32	s15, s0, s0
 802b368:	eddf 6a5a 	vldr	s13, [pc, #360]	; 802b4d4 <__ieee754_acosf+0x1b4>
 802b36c:	ed9f 7a5a 	vldr	s14, [pc, #360]	; 802b4d8 <__ieee754_acosf+0x1b8>
 802b370:	ed9f 6a5a 	vldr	s12, [pc, #360]	; 802b4dc <__ieee754_acosf+0x1bc>
 802b374:	ed9f 8a5a 	vldr	s16, [pc, #360]	; 802b4e0 <__ieee754_acosf+0x1c0>
 802b378:	eea7 7aa6 	vfma.f32	s14, s15, s13
 802b37c:	eddf 6a59 	vldr	s13, [pc, #356]	; 802b4e4 <__ieee754_acosf+0x1c4>
 802b380:	eee7 6a27 	vfma.f32	s13, s14, s15
 802b384:	ed9f 7a58 	vldr	s14, [pc, #352]	; 802b4e8 <__ieee754_acosf+0x1c8>
 802b388:	eea6 7aa7 	vfma.f32	s14, s13, s15
 802b38c:	eddf 6a57 	vldr	s13, [pc, #348]	; 802b4ec <__ieee754_acosf+0x1cc>
 802b390:	eee7 6a27 	vfma.f32	s13, s14, s15
 802b394:	ed9f 7a56 	vldr	s14, [pc, #344]	; 802b4f0 <__ieee754_acosf+0x1d0>
 802b398:	eea6 7aa7 	vfma.f32	s14, s13, s15
 802b39c:	eddf 6a55 	vldr	s13, [pc, #340]	; 802b4f4 <__ieee754_acosf+0x1d4>
 802b3a0:	eea7 6aa6 	vfma.f32	s12, s15, s13
 802b3a4:	eddf 6a54 	vldr	s13, [pc, #336]	; 802b4f8 <__ieee754_acosf+0x1d8>
 802b3a8:	eee6 6a27 	vfma.f32	s13, s12, s15
 802b3ac:	ed9f 6a53 	vldr	s12, [pc, #332]	; 802b4fc <__ieee754_acosf+0x1dc>
 802b3b0:	eea6 6aa7 	vfma.f32	s12, s13, s15
 802b3b4:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
 802b3b8:	eee6 6a27 	vfma.f32	s13, s12, s15
 802b3bc:	ee27 7a27 	vmul.f32	s14, s14, s15
 802b3c0:	eec7 7a26 	vdiv.f32	s15, s14, s13
 802b3c4:	eea0 8a67 	vfms.f32	s16, s0, s15
 802b3c8:	eddf 7a4d 	vldr	s15, [pc, #308]	; 802b500 <__ieee754_acosf+0x1e0>
 802b3cc:	ee30 0a48 	vsub.f32	s0, s0, s16
 802b3d0:	ee37 0ac0 	vsub.f32	s0, s15, s0
 802b3d4:	e7b6      	b.n	802b344 <__ieee754_acosf+0x24>
 802b3d6:	2b00      	cmp	r3, #0
 802b3d8:	eddf da3e 	vldr	s27, [pc, #248]	; 802b4d4 <__ieee754_acosf+0x1b4>
 802b3dc:	eddf ca3e 	vldr	s25, [pc, #248]	; 802b4d8 <__ieee754_acosf+0x1b8>
 802b3e0:	ed9f ca40 	vldr	s24, [pc, #256]	; 802b4e4 <__ieee754_acosf+0x1c4>
 802b3e4:	eddf ba40 	vldr	s23, [pc, #256]	; 802b4e8 <__ieee754_acosf+0x1c8>
 802b3e8:	ed9f ba40 	vldr	s22, [pc, #256]	; 802b4ec <__ieee754_acosf+0x1cc>
 802b3ec:	eddf 8a40 	vldr	s17, [pc, #256]	; 802b4f0 <__ieee754_acosf+0x1d0>
 802b3f0:	ed9f da40 	vldr	s26, [pc, #256]	; 802b4f4 <__ieee754_acosf+0x1d4>
 802b3f4:	eddf aa39 	vldr	s21, [pc, #228]	; 802b4dc <__ieee754_acosf+0x1bc>
 802b3f8:	ed9f aa3f 	vldr	s20, [pc, #252]	; 802b4f8 <__ieee754_acosf+0x1d8>
 802b3fc:	eddf 9a3f 	vldr	s19, [pc, #252]	; 802b4fc <__ieee754_acosf+0x1dc>
 802b400:	eeb7 9a00 	vmov.f32	s18, #112	; 0x3f800000  1.0
 802b404:	eef6 7a00 	vmov.f32	s15, #96	; 0x3f000000  0.5
 802b408:	da28      	bge.n	802b45c <__ieee754_acosf+0x13c>
 802b40a:	ee30 0a09 	vadd.f32	s0, s0, s18
 802b40e:	ee20 0a27 	vmul.f32	s0, s0, s15
 802b412:	eee0 ca2d 	vfma.f32	s25, s0, s27
 802b416:	eee0 aa0d 	vfma.f32	s21, s0, s26
 802b41a:	eeac ca80 	vfma.f32	s24, s25, s0
 802b41e:	eeaa aa80 	vfma.f32	s20, s21, s0
 802b422:	eeec ba00 	vfma.f32	s23, s24, s0
 802b426:	eeea 9a00 	vfma.f32	s19, s20, s0
 802b42a:	eeab ba80 	vfma.f32	s22, s23, s0
 802b42e:	eea9 9a80 	vfma.f32	s18, s19, s0
 802b432:	eeeb 8a00 	vfma.f32	s17, s22, s0
 802b436:	ee68 8a80 	vmul.f32	s17, s17, s0
 802b43a:	f001 f95b 	bl	802c6f4 <__ieee754_sqrtf>
 802b43e:	ee88 7a89 	vdiv.f32	s14, s17, s18
 802b442:	eddf 7a30 	vldr	s15, [pc, #192]	; 802b504 <__ieee754_acosf+0x1e4>
 802b446:	eee0 7a07 	vfma.f32	s15, s0, s14
 802b44a:	eeb0 7a00 	vmov.f32	s14, #0	; 0x40000000  2.0
 802b44e:	ee77 7a80 	vadd.f32	s15, s15, s0
 802b452:	ed9f 0a2d 	vldr	s0, [pc, #180]	; 802b508 <__ieee754_acosf+0x1e8>
 802b456:	eea7 0ac7 	vfms.f32	s0, s15, s14
 802b45a:	e773      	b.n	802b344 <__ieee754_acosf+0x24>
 802b45c:	ee39 8a40 	vsub.f32	s16, s18, s0
 802b460:	ee28 8a27 	vmul.f32	s16, s16, s15
 802b464:	eeb0 0a48 	vmov.f32	s0, s16
 802b468:	f001 f944 	bl	802c6f4 <__ieee754_sqrtf>
 802b46c:	eee8 ca2d 	vfma.f32	s25, s16, s27
 802b470:	eee8 aa0d 	vfma.f32	s21, s16, s26
 802b474:	eeac ca88 	vfma.f32	s24, s25, s16
 802b478:	eeaa aa88 	vfma.f32	s20, s21, s16
 802b47c:	eeec ba08 	vfma.f32	s23, s24, s16
 802b480:	ee10 3a10 	vmov	r3, s0
 802b484:	eeab ba88 	vfma.f32	s22, s23, s16
 802b488:	f423 637f 	bic.w	r3, r3, #4080	; 0xff0
 802b48c:	f023 030f 	bic.w	r3, r3, #15
 802b490:	eeea 9a08 	vfma.f32	s19, s20, s16
 802b494:	ee07 3a90 	vmov	s15, r3
 802b498:	eeeb 8a08 	vfma.f32	s17, s22, s16
 802b49c:	eeb0 6a48 	vmov.f32	s12, s16
 802b4a0:	eea7 6ae7 	vfms.f32	s12, s15, s15
 802b4a4:	eea9 9a88 	vfma.f32	s18, s19, s16
 802b4a8:	ee70 6a27 	vadd.f32	s13, s0, s15
 802b4ac:	ee68 8a88 	vmul.f32	s17, s17, s16
 802b4b0:	ee86 7a26 	vdiv.f32	s14, s12, s13
 802b4b4:	eec8 6a89 	vdiv.f32	s13, s17, s18
 802b4b8:	eea0 7a26 	vfma.f32	s14, s0, s13
 802b4bc:	ee37 0a87 	vadd.f32	s0, s15, s14
 802b4c0:	ee30 0a00 	vadd.f32	s0, s0, s0
 802b4c4:	e73e      	b.n	802b344 <__ieee754_acosf+0x24>
 802b4c6:	ed9f 0a11 	vldr	s0, [pc, #68]	; 802b50c <__ieee754_acosf+0x1ec>
 802b4ca:	e73b      	b.n	802b344 <__ieee754_acosf+0x24>
 802b4cc:	00000000 	.word	0x00000000
 802b4d0:	40490fdb 	.word	0x40490fdb
 802b4d4:	3811ef08 	.word	0x3811ef08
 802b4d8:	3a4f7f04 	.word	0x3a4f7f04
 802b4dc:	bf303361 	.word	0xbf303361
 802b4e0:	33a22168 	.word	0x33a22168
 802b4e4:	bd241146 	.word	0xbd241146
 802b4e8:	3e4e0aa8 	.word	0x3e4e0aa8
 802b4ec:	bea6b090 	.word	0xbea6b090
 802b4f0:	3e2aaaab 	.word	0x3e2aaaab
 802b4f4:	3d9dc62e 	.word	0x3d9dc62e
 802b4f8:	4001572d 	.word	0x4001572d
 802b4fc:	c019d139 	.word	0xc019d139
 802b500:	3fc90fda 	.word	0x3fc90fda
 802b504:	b3a22168 	.word	0xb3a22168
 802b508:	40490fda 	.word	0x40490fda
 802b50c:	3fc90fdb 	.word	0x3fc90fdb

0802b510 <__ieee754_acoshf>:
 802b510:	b508      	push	{r3, lr}
 802b512:	ee10 3a10 	vmov	r3, s0
 802b516:	f1b3 5f7e 	cmp.w	r3, #1065353216	; 0x3f800000
 802b51a:	ed2d 8b04 	vpush	{d8-d9}
 802b51e:	eeb0 8a40 	vmov.f32	s16, s0
 802b522:	da06      	bge.n	802b532 <__ieee754_acoshf+0x22>
 802b524:	ee30 8a40 	vsub.f32	s16, s0, s0
 802b528:	ee88 0a08 	vdiv.f32	s0, s16, s16
 802b52c:	ecbd 8b04 	vpop	{d8-d9}
 802b530:	bd08      	pop	{r3, pc}
 802b532:	f1b3 4f9b 	cmp.w	r3, #1300234240	; 0x4d800000
 802b536:	db0c      	blt.n	802b552 <__ieee754_acoshf+0x42>
 802b538:	f1b3 4fff 	cmp.w	r3, #2139095040	; 0x7f800000
 802b53c:	db02      	blt.n	802b544 <__ieee754_acoshf+0x34>
 802b53e:	ee30 0a00 	vadd.f32	s0, s0, s0
 802b542:	e7f3      	b.n	802b52c <__ieee754_acoshf+0x1c>
 802b544:	f000 fb14 	bl	802bb70 <__ieee754_logf>
 802b548:	ed9f 8a19 	vldr	s16, [pc, #100]	; 802b5b0 <__ieee754_acoshf+0xa0>
 802b54c:	ee30 0a08 	vadd.f32	s0, s0, s16
 802b550:	e7ec      	b.n	802b52c <__ieee754_acoshf+0x1c>
 802b552:	f1b3 5f7e 	cmp.w	r3, #1065353216	; 0x3f800000
 802b556:	d028      	beq.n	802b5aa <__ieee754_acoshf+0x9a>
 802b558:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
 802b55c:	eeb7 9a00 	vmov.f32	s18, #112	; 0x3f800000  1.0
 802b560:	eef0 8a00 	vmov.f32	s17, #0	; 0x40000000  2.0
 802b564:	dd11      	ble.n	802b58a <__ieee754_acoshf+0x7a>
 802b566:	eebf 0a00 	vmov.f32	s0, #240	; 0xbf800000 -1.0
 802b56a:	eea8 0a08 	vfma.f32	s0, s16, s16
 802b56e:	f001 f8c1 	bl	802c6f4 <__ieee754_sqrtf>
 802b572:	ee70 7a08 	vadd.f32	s15, s0, s16
 802b576:	ee89 0a27 	vdiv.f32	s0, s18, s15
 802b57a:	ee98 0a28 	vfnms.f32	s0, s16, s17
 802b57e:	ecbd 8b04 	vpop	{d8-d9}
 802b582:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
 802b586:	f000 baf3 	b.w	802bb70 <__ieee754_logf>
 802b58a:	ee30 8a49 	vsub.f32	s16, s0, s18
 802b58e:	ee28 0a08 	vmul.f32	s0, s16, s16
 802b592:	eea8 0a28 	vfma.f32	s0, s16, s17
 802b596:	f001 f8ad 	bl	802c6f4 <__ieee754_sqrtf>
 802b59a:	ee30 0a08 	vadd.f32	s0, s0, s16
 802b59e:	ecbd 8b04 	vpop	{d8-d9}
 802b5a2:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
 802b5a6:	f7ff bab3 	b.w	802ab10 <log1pf>
 802b5aa:	ed9f 0a02 	vldr	s0, [pc, #8]	; 802b5b4 <__ieee754_acoshf+0xa4>
 802b5ae:	e7bd      	b.n	802b52c <__ieee754_acoshf+0x1c>
 802b5b0:	3f317218 	.word	0x3f317218
 802b5b4:	00000000 	.word	0x00000000

0802b5b8 <__ieee754_asinf>:
 802b5b8:	b538      	push	{r3, r4, r5, lr}
 802b5ba:	ee10 5a10 	vmov	r5, s0
 802b5be:	f025 4400 	bic.w	r4, r5, #2147483648	; 0x80000000
 802b5c2:	f1b4 5f7e 	cmp.w	r4, #1065353216	; 0x3f800000
 802b5c6:	ed2d 8b04 	vpush	{d8-d9}
 802b5ca:	d10c      	bne.n	802b5e6 <__ieee754_asinf+0x2e>
 802b5cc:	eddf 7a5d 	vldr	s15, [pc, #372]	; 802b744 <__ieee754_asinf+0x18c>
 802b5d0:	ed9f 7a5d 	vldr	s14, [pc, #372]	; 802b748 <__ieee754_asinf+0x190>
 802b5d4:	ee60 7a27 	vmul.f32	s15, s0, s15
 802b5d8:	eee0 7a07 	vfma.f32	s15, s0, s14
 802b5dc:	eeb0 0a67 	vmov.f32	s0, s15
 802b5e0:	ecbd 8b04 	vpop	{d8-d9}
 802b5e4:	bd38      	pop	{r3, r4, r5, pc}
 802b5e6:	dd04      	ble.n	802b5f2 <__ieee754_asinf+0x3a>
 802b5e8:	ee70 7a40 	vsub.f32	s15, s0, s0
 802b5ec:	ee87 0aa7 	vdiv.f32	s0, s15, s15
 802b5f0:	e7f6      	b.n	802b5e0 <__ieee754_asinf+0x28>
 802b5f2:	f1b4 5f7c 	cmp.w	r4, #1056964608	; 0x3f000000
 802b5f6:	eef7 8a00 	vmov.f32	s17, #112	; 0x3f800000  1.0
 802b5fa:	da0b      	bge.n	802b614 <__ieee754_asinf+0x5c>
 802b5fc:	f1b4 5f48 	cmp.w	r4, #838860800	; 0x32000000
 802b600:	da52      	bge.n	802b6a8 <__ieee754_asinf+0xf0>
 802b602:	eddf 7a52 	vldr	s15, [pc, #328]	; 802b74c <__ieee754_asinf+0x194>
 802b606:	ee70 7a27 	vadd.f32	s15, s0, s15
 802b60a:	eef4 7ae8 	vcmpe.f32	s15, s17
 802b60e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802b612:	dce5      	bgt.n	802b5e0 <__ieee754_asinf+0x28>
 802b614:	f7ff fa32 	bl	802aa7c <fabsf>
 802b618:	ee38 0ac0 	vsub.f32	s0, s17, s0
 802b61c:	eeb6 8a00 	vmov.f32	s16, #96	; 0x3f000000  0.5
 802b620:	ee20 8a08 	vmul.f32	s16, s0, s16
 802b624:	eddf 7a4a 	vldr	s15, [pc, #296]	; 802b750 <__ieee754_asinf+0x198>
 802b628:	ed9f 7a4a 	vldr	s14, [pc, #296]	; 802b754 <__ieee754_asinf+0x19c>
 802b62c:	ed9f 9a4a 	vldr	s18, [pc, #296]	; 802b758 <__ieee754_asinf+0x1a0>
 802b630:	eea8 7a27 	vfma.f32	s14, s16, s15
 802b634:	eddf 7a49 	vldr	s15, [pc, #292]	; 802b75c <__ieee754_asinf+0x1a4>
 802b638:	eee7 7a08 	vfma.f32	s15, s14, s16
 802b63c:	ed9f 7a48 	vldr	s14, [pc, #288]	; 802b760 <__ieee754_asinf+0x1a8>
 802b640:	eea7 7a88 	vfma.f32	s14, s15, s16
 802b644:	eddf 7a47 	vldr	s15, [pc, #284]	; 802b764 <__ieee754_asinf+0x1ac>
 802b648:	eee7 7a08 	vfma.f32	s15, s14, s16
 802b64c:	ed9f 7a46 	vldr	s14, [pc, #280]	; 802b768 <__ieee754_asinf+0x1b0>
 802b650:	eea7 9a88 	vfma.f32	s18, s15, s16
 802b654:	eddf 7a45 	vldr	s15, [pc, #276]	; 802b76c <__ieee754_asinf+0x1b4>
 802b658:	eee8 7a07 	vfma.f32	s15, s16, s14
 802b65c:	ed9f 7a44 	vldr	s14, [pc, #272]	; 802b770 <__ieee754_asinf+0x1b8>
 802b660:	eea7 7a88 	vfma.f32	s14, s15, s16
 802b664:	eddf 7a43 	vldr	s15, [pc, #268]	; 802b774 <__ieee754_asinf+0x1bc>
 802b668:	eee7 7a08 	vfma.f32	s15, s14, s16
 802b66c:	eeb0 0a48 	vmov.f32	s0, s16
 802b670:	eee7 8a88 	vfma.f32	s17, s15, s16
 802b674:	f001 f83e 	bl	802c6f4 <__ieee754_sqrtf>
 802b678:	4b3f      	ldr	r3, [pc, #252]	; (802b778 <__ieee754_asinf+0x1c0>)
 802b67a:	ee29 9a08 	vmul.f32	s18, s18, s16
 802b67e:	429c      	cmp	r4, r3
 802b680:	ee89 6a28 	vdiv.f32	s12, s18, s17
 802b684:	eef0 6a00 	vmov.f32	s13, #0	; 0x40000000  2.0
 802b688:	dd3d      	ble.n	802b706 <__ieee754_asinf+0x14e>
 802b68a:	eea0 0a06 	vfma.f32	s0, s0, s12
 802b68e:	eddf 7a3b 	vldr	s15, [pc, #236]	; 802b77c <__ieee754_asinf+0x1c4>
 802b692:	eee0 7a26 	vfma.f32	s15, s0, s13
 802b696:	ed9f 0a2c 	vldr	s0, [pc, #176]	; 802b748 <__ieee754_asinf+0x190>
 802b69a:	ee30 0a67 	vsub.f32	s0, s0, s15
 802b69e:	2d00      	cmp	r5, #0
 802b6a0:	bfd8      	it	le
 802b6a2:	eeb1 0a40 	vnegle.f32	s0, s0
 802b6a6:	e79b      	b.n	802b5e0 <__ieee754_asinf+0x28>
 802b6a8:	ee60 7a00 	vmul.f32	s15, s0, s0
 802b6ac:	eddf 6a28 	vldr	s13, [pc, #160]	; 802b750 <__ieee754_asinf+0x198>
 802b6b0:	ed9f 7a28 	vldr	s14, [pc, #160]	; 802b754 <__ieee754_asinf+0x19c>
 802b6b4:	ed9f 6a2c 	vldr	s12, [pc, #176]	; 802b768 <__ieee754_asinf+0x1b0>
 802b6b8:	eea7 7aa6 	vfma.f32	s14, s15, s13
 802b6bc:	eddf 6a27 	vldr	s13, [pc, #156]	; 802b75c <__ieee754_asinf+0x1a4>
 802b6c0:	eee7 6a27 	vfma.f32	s13, s14, s15
 802b6c4:	ed9f 7a26 	vldr	s14, [pc, #152]	; 802b760 <__ieee754_asinf+0x1a8>
 802b6c8:	eea6 7aa7 	vfma.f32	s14, s13, s15
 802b6cc:	eddf 6a25 	vldr	s13, [pc, #148]	; 802b764 <__ieee754_asinf+0x1ac>
 802b6d0:	eee7 6a27 	vfma.f32	s13, s14, s15
 802b6d4:	ed9f 7a20 	vldr	s14, [pc, #128]	; 802b758 <__ieee754_asinf+0x1a0>
 802b6d8:	eea6 7aa7 	vfma.f32	s14, s13, s15
 802b6dc:	eddf 6a23 	vldr	s13, [pc, #140]	; 802b76c <__ieee754_asinf+0x1b4>
 802b6e0:	eee7 6a86 	vfma.f32	s13, s15, s12
 802b6e4:	ed9f 6a22 	vldr	s12, [pc, #136]	; 802b770 <__ieee754_asinf+0x1b8>
 802b6e8:	eea6 6aa7 	vfma.f32	s12, s13, s15
 802b6ec:	eddf 6a21 	vldr	s13, [pc, #132]	; 802b774 <__ieee754_asinf+0x1bc>
 802b6f0:	eee6 6a27 	vfma.f32	s13, s12, s15
 802b6f4:	ee27 7a27 	vmul.f32	s14, s14, s15
 802b6f8:	eee6 8aa7 	vfma.f32	s17, s13, s15
 802b6fc:	eec7 7a28 	vdiv.f32	s15, s14, s17
 802b700:	eea0 0a27 	vfma.f32	s0, s0, s15
 802b704:	e76c      	b.n	802b5e0 <__ieee754_asinf+0x28>
 802b706:	ee10 3a10 	vmov	r3, s0
 802b70a:	f423 637f 	bic.w	r3, r3, #4080	; 0xff0
 802b70e:	f023 030f 	bic.w	r3, r3, #15
 802b712:	ee07 3a10 	vmov	s14, r3
 802b716:	eea7 8a47 	vfms.f32	s16, s14, s14
 802b71a:	ee70 7a07 	vadd.f32	s15, s0, s14
 802b71e:	ee30 0a00 	vadd.f32	s0, s0, s0
 802b722:	eec8 5a27 	vdiv.f32	s11, s16, s15
 802b726:	eddf 7a07 	vldr	s15, [pc, #28]	; 802b744 <__ieee754_asinf+0x18c>
 802b72a:	eee5 7ae6 	vfms.f32	s15, s11, s13
 802b72e:	eed0 7a06 	vfnms.f32	s15, s0, s12
 802b732:	ed9f 0a13 	vldr	s0, [pc, #76]	; 802b780 <__ieee754_asinf+0x1c8>
 802b736:	eeb0 6a40 	vmov.f32	s12, s0
 802b73a:	eea7 6a66 	vfms.f32	s12, s14, s13
 802b73e:	ee77 7ac6 	vsub.f32	s15, s15, s12
 802b742:	e7aa      	b.n	802b69a <__ieee754_asinf+0xe2>
 802b744:	b33bbd2e 	.word	0xb33bbd2e
 802b748:	3fc90fdb 	.word	0x3fc90fdb
 802b74c:	7149f2ca 	.word	0x7149f2ca
 802b750:	3811ef08 	.word	0x3811ef08
 802b754:	3a4f7f04 	.word	0x3a4f7f04
 802b758:	3e2aaaab 	.word	0x3e2aaaab
 802b75c:	bd241146 	.word	0xbd241146
 802b760:	3e4e0aa8 	.word	0x3e4e0aa8
 802b764:	bea6b090 	.word	0xbea6b090
 802b768:	3d9dc62e 	.word	0x3d9dc62e
 802b76c:	bf303361 	.word	0xbf303361
 802b770:	4001572d 	.word	0x4001572d
 802b774:	c019d139 	.word	0xc019d139
 802b778:	3f799999 	.word	0x3f799999
 802b77c:	333bbd2e 	.word	0x333bbd2e
 802b780:	3f490fdb 	.word	0x3f490fdb

0802b784 <__ieee754_atanhf>:
 802b784:	b510      	push	{r4, lr}
 802b786:	ee10 4a10 	vmov	r4, s0
 802b78a:	f024 4300 	bic.w	r3, r4, #2147483648	; 0x80000000
 802b78e:	f1b3 5f7e 	cmp.w	r3, #1065353216	; 0x3f800000
 802b792:	ed2d 8b02 	vpush	{d8}
 802b796:	dd06      	ble.n	802b7a6 <__ieee754_atanhf+0x22>
 802b798:	ee70 7a40 	vsub.f32	s15, s0, s0
 802b79c:	ee87 0aa7 	vdiv.f32	s0, s15, s15
 802b7a0:	ecbd 8b02 	vpop	{d8}
 802b7a4:	bd10      	pop	{r4, pc}
 802b7a6:	d104      	bne.n	802b7b2 <__ieee754_atanhf+0x2e>
 802b7a8:	eddf 7a17 	vldr	s15, [pc, #92]	; 802b808 <__ieee754_atanhf+0x84>
 802b7ac:	ee80 0a27 	vdiv.f32	s0, s0, s15
 802b7b0:	e7f6      	b.n	802b7a0 <__ieee754_atanhf+0x1c>
 802b7b2:	f1b3 5f46 	cmp.w	r3, #830472192	; 0x31800000
 802b7b6:	da08      	bge.n	802b7ca <__ieee754_atanhf+0x46>
 802b7b8:	eddf 7a14 	vldr	s15, [pc, #80]	; 802b80c <__ieee754_atanhf+0x88>
 802b7bc:	ee70 7a27 	vadd.f32	s15, s0, s15
 802b7c0:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 802b7c4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802b7c8:	dcea      	bgt.n	802b7a0 <__ieee754_atanhf+0x1c>
 802b7ca:	ee07 3a90 	vmov	s15, r3
 802b7ce:	ee37 0aa7 	vadd.f32	s0, s15, s15
 802b7d2:	f1b3 5f7c 	cmp.w	r3, #1056964608	; 0x3f000000
 802b7d6:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
 802b7da:	ee37 7a67 	vsub.f32	s14, s14, s15
 802b7de:	bfb6      	itet	lt
 802b7e0:	ee67 7a80 	vmullt.f32	s15, s15, s0
 802b7e4:	ee80 0a07 	vdivge.f32	s0, s0, s14
 802b7e8:	eec7 6a87 	vdivlt.f32	s13, s15, s14
 802b7ec:	eeb6 8a00 	vmov.f32	s16, #96	; 0x3f000000  0.5
 802b7f0:	bfb8      	it	lt
 802b7f2:	ee36 0a80 	vaddlt.f32	s0, s13, s0
 802b7f6:	f7ff f98b 	bl	802ab10 <log1pf>
 802b7fa:	ee20 0a08 	vmul.f32	s0, s0, s16
 802b7fe:	2c00      	cmp	r4, #0
 802b800:	bfb8      	it	lt
 802b802:	eeb1 0a40 	vneglt.f32	s0, s0
 802b806:	e7cb      	b.n	802b7a0 <__ieee754_atanhf+0x1c>
 802b808:	00000000 	.word	0x00000000
 802b80c:	7149f2ca 	.word	0x7149f2ca

0802b810 <__ieee754_coshf>:
 802b810:	b510      	push	{r4, lr}
 802b812:	ee10 4a10 	vmov	r4, s0
 802b816:	f024 4400 	bic.w	r4, r4, #2147483648	; 0x80000000
 802b81a:	f1b4 4fff 	cmp.w	r4, #2139095040	; 0x7f800000
 802b81e:	ed2d 8b02 	vpush	{d8}
 802b822:	db06      	blt.n	802b832 <__ieee754_coshf+0x22>
 802b824:	ee60 7a00 	vmul.f32	s15, s0, s0
 802b828:	ecbd 8b02 	vpop	{d8}
 802b82c:	eeb0 0a67 	vmov.f32	s0, s15
 802b830:	bd10      	pop	{r4, pc}
 802b832:	4b23      	ldr	r3, [pc, #140]	; (802b8c0 <__ieee754_coshf+0xb0>)
 802b834:	429c      	cmp	r4, r3
 802b836:	dc13      	bgt.n	802b860 <__ieee754_coshf+0x50>
 802b838:	f7ff f920 	bl	802aa7c <fabsf>
 802b83c:	f001 fba0 	bl	802cf80 <expm1f>
 802b840:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
 802b844:	f1b4 5f10 	cmp.w	r4, #603979776	; 0x24000000
 802b848:	ee70 7a26 	vadd.f32	s15, s0, s13
 802b84c:	dbec      	blt.n	802b828 <__ieee754_coshf+0x18>
 802b84e:	ee20 7a00 	vmul.f32	s14, s0, s0
 802b852:	ee37 0aa7 	vadd.f32	s0, s15, s15
 802b856:	eec7 7a00 	vdiv.f32	s15, s14, s0
 802b85a:	ee77 7aa6 	vadd.f32	s15, s15, s13
 802b85e:	e7e3      	b.n	802b828 <__ieee754_coshf+0x18>
 802b860:	4b18      	ldr	r3, [pc, #96]	; (802b8c4 <__ieee754_coshf+0xb4>)
 802b862:	429c      	cmp	r4, r3
 802b864:	dc0a      	bgt.n	802b87c <__ieee754_coshf+0x6c>
 802b866:	f7ff f909 	bl	802aa7c <fabsf>
 802b86a:	f000 f831 	bl	802b8d0 <__ieee754_expf>
 802b86e:	eeb6 7a00 	vmov.f32	s14, #96	; 0x3f000000  0.5
 802b872:	eec7 7a00 	vdiv.f32	s15, s14, s0
 802b876:	eee0 7a07 	vfma.f32	s15, s0, s14
 802b87a:	e7d5      	b.n	802b828 <__ieee754_coshf+0x18>
 802b87c:	4b12      	ldr	r3, [pc, #72]	; (802b8c8 <__ieee754_coshf+0xb8>)
 802b87e:	429c      	cmp	r4, r3
 802b880:	dc08      	bgt.n	802b894 <__ieee754_coshf+0x84>
 802b882:	f7ff f8fb 	bl	802aa7c <fabsf>
 802b886:	f000 f823 	bl	802b8d0 <__ieee754_expf>
 802b88a:	eef6 7a00 	vmov.f32	s15, #96	; 0x3f000000  0.5
 802b88e:	ee67 7a80 	vmul.f32	s15, s15, s0
 802b892:	e7c9      	b.n	802b828 <__ieee754_coshf+0x18>
 802b894:	4b0d      	ldr	r3, [pc, #52]	; (802b8cc <__ieee754_coshf+0xbc>)
 802b896:	429c      	cmp	r4, r3
 802b898:	dc0a      	bgt.n	802b8b0 <__ieee754_coshf+0xa0>
 802b89a:	f7ff f8ef 	bl	802aa7c <fabsf>
 802b89e:	eeb6 8a00 	vmov.f32	s16, #96	; 0x3f000000  0.5
 802b8a2:	ee20 0a08 	vmul.f32	s0, s0, s16
 802b8a6:	f000 f813 	bl	802b8d0 <__ieee754_expf>
 802b8aa:	ee60 7a08 	vmul.f32	s15, s0, s16
 802b8ae:	e7ee      	b.n	802b88e <__ieee754_coshf+0x7e>
 802b8b0:	ecbd 8b02 	vpop	{d8}
 802b8b4:	2000      	movs	r0, #0
 802b8b6:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 802b8ba:	f001 bb39 	b.w	802cf30 <__math_oflowf>
 802b8be:	bf00      	nop
 802b8c0:	3eb17217 	.word	0x3eb17217
 802b8c4:	41afffff 	.word	0x41afffff
 802b8c8:	42b17217 	.word	0x42b17217
 802b8cc:	42b2d4fc 	.word	0x42b2d4fc

0802b8d0 <__ieee754_expf>:
 802b8d0:	ee10 2a10 	vmov	r2, s0
 802b8d4:	f022 4100 	bic.w	r1, r2, #2147483648	; 0x80000000
 802b8d8:	f1b1 4fff 	cmp.w	r1, #2139095040	; 0x7f800000
 802b8dc:	d902      	bls.n	802b8e4 <__ieee754_expf+0x14>
 802b8de:	ee30 0a00 	vadd.f32	s0, s0, s0
 802b8e2:	4770      	bx	lr
 802b8e4:	ea4f 73d2 	mov.w	r3, r2, lsr #31
 802b8e8:	d106      	bne.n	802b8f8 <__ieee754_expf+0x28>
 802b8ea:	eddf 7a4e 	vldr	s15, [pc, #312]	; 802ba24 <__ieee754_expf+0x154>
 802b8ee:	2b00      	cmp	r3, #0
 802b8f0:	bf18      	it	ne
 802b8f2:	eeb0 0a67 	vmovne.f32	s0, s15
 802b8f6:	4770      	bx	lr
 802b8f8:	484b      	ldr	r0, [pc, #300]	; (802ba28 <__ieee754_expf+0x158>)
 802b8fa:	4282      	cmp	r2, r0
 802b8fc:	dd02      	ble.n	802b904 <__ieee754_expf+0x34>
 802b8fe:	2000      	movs	r0, #0
 802b900:	f001 bb16 	b.w	802cf30 <__math_oflowf>
 802b904:	2a00      	cmp	r2, #0
 802b906:	da05      	bge.n	802b914 <__ieee754_expf+0x44>
 802b908:	4a48      	ldr	r2, [pc, #288]	; (802ba2c <__ieee754_expf+0x15c>)
 802b90a:	4291      	cmp	r1, r2
 802b90c:	d902      	bls.n	802b914 <__ieee754_expf+0x44>
 802b90e:	2000      	movs	r0, #0
 802b910:	f001 bb08 	b.w	802cf24 <__math_uflowf>
 802b914:	4a46      	ldr	r2, [pc, #280]	; (802ba30 <__ieee754_expf+0x160>)
 802b916:	4291      	cmp	r1, r2
 802b918:	eef7 5a00 	vmov.f32	s11, #112	; 0x3f800000  1.0
 802b91c:	d952      	bls.n	802b9c4 <__ieee754_expf+0xf4>
 802b91e:	4a45      	ldr	r2, [pc, #276]	; (802ba34 <__ieee754_expf+0x164>)
 802b920:	4291      	cmp	r1, r2
 802b922:	ea4f 0283 	mov.w	r2, r3, lsl #2
 802b926:	d834      	bhi.n	802b992 <__ieee754_expf+0xc2>
 802b928:	4943      	ldr	r1, [pc, #268]	; (802ba38 <__ieee754_expf+0x168>)
 802b92a:	4411      	add	r1, r2
 802b92c:	ed91 7a00 	vldr	s14, [r1]
 802b930:	4942      	ldr	r1, [pc, #264]	; (802ba3c <__ieee754_expf+0x16c>)
 802b932:	440a      	add	r2, r1
 802b934:	edd2 7a00 	vldr	s15, [r2]
 802b938:	ee30 7a47 	vsub.f32	s14, s0, s14
 802b93c:	f1c3 0201 	rsb	r2, r3, #1
 802b940:	1ad2      	subs	r2, r2, r3
 802b942:	ee37 0a67 	vsub.f32	s0, s14, s15
 802b946:	ee20 6a00 	vmul.f32	s12, s0, s0
 802b94a:	ed9f 5a3d 	vldr	s10, [pc, #244]	; 802ba40 <__ieee754_expf+0x170>
 802b94e:	eddf 6a3d 	vldr	s13, [pc, #244]	; 802ba44 <__ieee754_expf+0x174>
 802b952:	eee6 6a05 	vfma.f32	s13, s12, s10
 802b956:	ed9f 5a3c 	vldr	s10, [pc, #240]	; 802ba48 <__ieee754_expf+0x178>
 802b95a:	eea6 5a86 	vfma.f32	s10, s13, s12
 802b95e:	eddf 6a3b 	vldr	s13, [pc, #236]	; 802ba4c <__ieee754_expf+0x17c>
 802b962:	eee5 6a06 	vfma.f32	s13, s10, s12
 802b966:	ed9f 5a3a 	vldr	s10, [pc, #232]	; 802ba50 <__ieee754_expf+0x180>
 802b96a:	eea6 5a86 	vfma.f32	s10, s13, s12
 802b96e:	eef0 6a40 	vmov.f32	s13, s0
 802b972:	eee5 6a46 	vfms.f32	s13, s10, s12
 802b976:	eeb0 6a00 	vmov.f32	s12, #0	; 0x40000000  2.0
 802b97a:	ee20 5a26 	vmul.f32	s10, s0, s13
 802b97e:	bb92      	cbnz	r2, 802b9e6 <__ieee754_expf+0x116>
 802b980:	ee76 6ac6 	vsub.f32	s13, s13, s12
 802b984:	eec5 7a26 	vdiv.f32	s15, s10, s13
 802b988:	ee37 0ac0 	vsub.f32	s0, s15, s0
 802b98c:	ee35 0ac0 	vsub.f32	s0, s11, s0
 802b990:	4770      	bx	lr
 802b992:	4b30      	ldr	r3, [pc, #192]	; (802ba54 <__ieee754_expf+0x184>)
 802b994:	ed9f 7a30 	vldr	s14, [pc, #192]	; 802ba58 <__ieee754_expf+0x188>
 802b998:	eddf 6a30 	vldr	s13, [pc, #192]	; 802ba5c <__ieee754_expf+0x18c>
 802b99c:	4413      	add	r3, r2
 802b99e:	edd3 7a00 	vldr	s15, [r3]
 802b9a2:	eee0 7a07 	vfma.f32	s15, s0, s14
 802b9a6:	eeb0 7a40 	vmov.f32	s14, s0
 802b9aa:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 802b9ae:	ee17 2a90 	vmov	r2, s15
 802b9b2:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 802b9b6:	eea7 7ae6 	vfms.f32	s14, s15, s13
 802b9ba:	eddf 6a29 	vldr	s13, [pc, #164]	; 802ba60 <__ieee754_expf+0x190>
 802b9be:	ee67 7aa6 	vmul.f32	s15, s15, s13
 802b9c2:	e7be      	b.n	802b942 <__ieee754_expf+0x72>
 802b9c4:	f1b1 5f50 	cmp.w	r1, #872415232	; 0x34000000
 802b9c8:	d20b      	bcs.n	802b9e2 <__ieee754_expf+0x112>
 802b9ca:	eddf 6a26 	vldr	s13, [pc, #152]	; 802ba64 <__ieee754_expf+0x194>
 802b9ce:	ee70 6a26 	vadd.f32	s13, s0, s13
 802b9d2:	eef4 6ae5 	vcmpe.f32	s13, s11
 802b9d6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802b9da:	dd02      	ble.n	802b9e2 <__ieee754_expf+0x112>
 802b9dc:	ee30 0a25 	vadd.f32	s0, s0, s11
 802b9e0:	4770      	bx	lr
 802b9e2:	2200      	movs	r2, #0
 802b9e4:	e7af      	b.n	802b946 <__ieee754_expf+0x76>
 802b9e6:	ee76 6a66 	vsub.f32	s13, s12, s13
 802b9ea:	f112 0f7d 	cmn.w	r2, #125	; 0x7d
 802b9ee:	ee85 0a26 	vdiv.f32	s0, s10, s13
 802b9f2:	bfb8      	it	lt
 802b9f4:	3264      	addlt	r2, #100	; 0x64
 802b9f6:	ee77 7ac0 	vsub.f32	s15, s15, s0
 802b9fa:	ee37 0ac7 	vsub.f32	s0, s15, s14
 802b9fe:	ee75 7ac0 	vsub.f32	s15, s11, s0
 802ba02:	ee17 3a90 	vmov	r3, s15
 802ba06:	bfab      	itete	ge
 802ba08:	eb03 53c2 	addge.w	r3, r3, r2, lsl #23
 802ba0c:	eb03 53c2 	addlt.w	r3, r3, r2, lsl #23
 802ba10:	ee00 3a10 	vmovge	s0, r3
 802ba14:	eddf 7a14 	vldrlt	s15, [pc, #80]	; 802ba68 <__ieee754_expf+0x198>
 802ba18:	bfbc      	itt	lt
 802ba1a:	ee00 3a10 	vmovlt	s0, r3
 802ba1e:	ee20 0a27 	vmullt.f32	s0, s0, s15
 802ba22:	4770      	bx	lr
 802ba24:	00000000 	.word	0x00000000
 802ba28:	42b17217 	.word	0x42b17217
 802ba2c:	42cff1b5 	.word	0x42cff1b5
 802ba30:	3eb17218 	.word	0x3eb17218
 802ba34:	3f851591 	.word	0x3f851591
 802ba38:	08057dcc 	.word	0x08057dcc
 802ba3c:	08057dd4 	.word	0x08057dd4
 802ba40:	3331bb4c 	.word	0x3331bb4c
 802ba44:	b5ddea0e 	.word	0xb5ddea0e
 802ba48:	388ab355 	.word	0x388ab355
 802ba4c:	bb360b61 	.word	0xbb360b61
 802ba50:	3e2aaaab 	.word	0x3e2aaaab
 802ba54:	08057dc4 	.word	0x08057dc4
 802ba58:	3fb8aa3b 	.word	0x3fb8aa3b
 802ba5c:	3f317180 	.word	0x3f317180
 802ba60:	3717f7d1 	.word	0x3717f7d1
 802ba64:	7149f2ca 	.word	0x7149f2ca
 802ba68:	0d800000 	.word	0x0d800000

0802ba6c <__ieee754_fmodf>:
 802ba6c:	b5f0      	push	{r4, r5, r6, r7, lr}
 802ba6e:	ee10 5a90 	vmov	r5, s1
 802ba72:	f035 4400 	bics.w	r4, r5, #2147483648	; 0x80000000
 802ba76:	d009      	beq.n	802ba8c <__ieee754_fmodf+0x20>
 802ba78:	ee10 2a10 	vmov	r2, s0
 802ba7c:	f022 4300 	bic.w	r3, r2, #2147483648	; 0x80000000
 802ba80:	f1b3 4fff 	cmp.w	r3, #2139095040	; 0x7f800000
 802ba84:	da02      	bge.n	802ba8c <__ieee754_fmodf+0x20>
 802ba86:	f1b4 4fff 	cmp.w	r4, #2139095040	; 0x7f800000
 802ba8a:	dd04      	ble.n	802ba96 <__ieee754_fmodf+0x2a>
 802ba8c:	ee60 0a20 	vmul.f32	s1, s0, s1
 802ba90:	ee80 0aa0 	vdiv.f32	s0, s1, s1
 802ba94:	bdf0      	pop	{r4, r5, r6, r7, pc}
 802ba96:	42a3      	cmp	r3, r4
 802ba98:	dbfc      	blt.n	802ba94 <__ieee754_fmodf+0x28>
 802ba9a:	f002 4600 	and.w	r6, r2, #2147483648	; 0x80000000
 802ba9e:	d105      	bne.n	802baac <__ieee754_fmodf+0x40>
 802baa0:	4b32      	ldr	r3, [pc, #200]	; (802bb6c <__ieee754_fmodf+0x100>)
 802baa2:	eb03 7356 	add.w	r3, r3, r6, lsr #29
 802baa6:	ed93 0a00 	vldr	s0, [r3]
 802baaa:	e7f3      	b.n	802ba94 <__ieee754_fmodf+0x28>
 802baac:	f012 4fff 	tst.w	r2, #2139095040	; 0x7f800000
 802bab0:	d13f      	bne.n	802bb32 <__ieee754_fmodf+0xc6>
 802bab2:	0219      	lsls	r1, r3, #8
 802bab4:	f06f 007d 	mvn.w	r0, #125	; 0x7d
 802bab8:	2900      	cmp	r1, #0
 802baba:	dc37      	bgt.n	802bb2c <__ieee754_fmodf+0xc0>
 802babc:	f015 4fff 	tst.w	r5, #2139095040	; 0x7f800000
 802bac0:	d13d      	bne.n	802bb3e <__ieee754_fmodf+0xd2>
 802bac2:	0227      	lsls	r7, r4, #8
 802bac4:	f06f 017d 	mvn.w	r1, #125	; 0x7d
 802bac8:	2f00      	cmp	r7, #0
 802baca:	da35      	bge.n	802bb38 <__ieee754_fmodf+0xcc>
 802bacc:	f110 0f7e 	cmn.w	r0, #126	; 0x7e
 802bad0:	bfbb      	ittet	lt
 802bad2:	f06f 027d 	mvnlt.w	r2, #125	; 0x7d
 802bad6:	1a12      	sublt	r2, r2, r0
 802bad8:	f3c2 0316 	ubfxge	r3, r2, #0, #23
 802badc:	4093      	lsllt	r3, r2
 802bade:	bfa8      	it	ge
 802bae0:	f443 0300 	orrge.w	r3, r3, #8388608	; 0x800000
 802bae4:	f111 0f7e 	cmn.w	r1, #126	; 0x7e
 802bae8:	bfb5      	itete	lt
 802baea:	f06f 027d 	mvnlt.w	r2, #125	; 0x7d
 802baee:	f3c5 0416 	ubfxge	r4, r5, #0, #23
 802baf2:	1a52      	sublt	r2, r2, r1
 802baf4:	f444 0400 	orrge.w	r4, r4, #8388608	; 0x800000
 802baf8:	bfb8      	it	lt
 802bafa:	4094      	lsllt	r4, r2
 802bafc:	1a40      	subs	r0, r0, r1
 802bafe:	1b1a      	subs	r2, r3, r4
 802bb00:	bb00      	cbnz	r0, 802bb44 <__ieee754_fmodf+0xd8>
 802bb02:	ea13 0322 	ands.w	r3, r3, r2, asr #32
 802bb06:	bf38      	it	cc
 802bb08:	4613      	movcc	r3, r2
 802bb0a:	2b00      	cmp	r3, #0
 802bb0c:	d0c8      	beq.n	802baa0 <__ieee754_fmodf+0x34>
 802bb0e:	f5b3 0f00 	cmp.w	r3, #8388608	; 0x800000
 802bb12:	db1f      	blt.n	802bb54 <__ieee754_fmodf+0xe8>
 802bb14:	f111 0f7e 	cmn.w	r1, #126	; 0x7e
 802bb18:	db1f      	blt.n	802bb5a <__ieee754_fmodf+0xee>
 802bb1a:	f5a3 0300 	sub.w	r3, r3, #8388608	; 0x800000
 802bb1e:	317f      	adds	r1, #127	; 0x7f
 802bb20:	4333      	orrs	r3, r6
 802bb22:	ea43 53c1 	orr.w	r3, r3, r1, lsl #23
 802bb26:	ee00 3a10 	vmov	s0, r3
 802bb2a:	e7b3      	b.n	802ba94 <__ieee754_fmodf+0x28>
 802bb2c:	3801      	subs	r0, #1
 802bb2e:	0049      	lsls	r1, r1, #1
 802bb30:	e7c2      	b.n	802bab8 <__ieee754_fmodf+0x4c>
 802bb32:	15d8      	asrs	r0, r3, #23
 802bb34:	387f      	subs	r0, #127	; 0x7f
 802bb36:	e7c1      	b.n	802babc <__ieee754_fmodf+0x50>
 802bb38:	3901      	subs	r1, #1
 802bb3a:	007f      	lsls	r7, r7, #1
 802bb3c:	e7c4      	b.n	802bac8 <__ieee754_fmodf+0x5c>
 802bb3e:	15e1      	asrs	r1, r4, #23
 802bb40:	397f      	subs	r1, #127	; 0x7f
 802bb42:	e7c3      	b.n	802bacc <__ieee754_fmodf+0x60>
 802bb44:	2a00      	cmp	r2, #0
 802bb46:	da02      	bge.n	802bb4e <__ieee754_fmodf+0xe2>
 802bb48:	005b      	lsls	r3, r3, #1
 802bb4a:	3801      	subs	r0, #1
 802bb4c:	e7d7      	b.n	802bafe <__ieee754_fmodf+0x92>
 802bb4e:	d0a7      	beq.n	802baa0 <__ieee754_fmodf+0x34>
 802bb50:	0053      	lsls	r3, r2, #1
 802bb52:	e7fa      	b.n	802bb4a <__ieee754_fmodf+0xde>
 802bb54:	005b      	lsls	r3, r3, #1
 802bb56:	3901      	subs	r1, #1
 802bb58:	e7d9      	b.n	802bb0e <__ieee754_fmodf+0xa2>
 802bb5a:	f1c1 21ff 	rsb	r1, r1, #4278255360	; 0xff00ff00
 802bb5e:	f501 017f 	add.w	r1, r1, #16711680	; 0xff0000
 802bb62:	3182      	adds	r1, #130	; 0x82
 802bb64:	410b      	asrs	r3, r1
 802bb66:	4333      	orrs	r3, r6
 802bb68:	e7dd      	b.n	802bb26 <__ieee754_fmodf+0xba>
 802bb6a:	bf00      	nop
 802bb6c:	08057ddc 	.word	0x08057ddc

0802bb70 <__ieee754_logf>:
 802bb70:	ee10 3a10 	vmov	r3, s0
 802bb74:	f033 4200 	bics.w	r2, r3, #2147483648	; 0x80000000
 802bb78:	d106      	bne.n	802bb88 <__ieee754_logf+0x18>
 802bb7a:	ed9f 7a65 	vldr	s14, [pc, #404]	; 802bd10 <__ieee754_logf+0x1a0>
 802bb7e:	eddf 7a65 	vldr	s15, [pc, #404]	; 802bd14 <__ieee754_logf+0x1a4>
 802bb82:	ee87 0a27 	vdiv.f32	s0, s14, s15
 802bb86:	4770      	bx	lr
 802bb88:	2b00      	cmp	r3, #0
 802bb8a:	da02      	bge.n	802bb92 <__ieee754_logf+0x22>
 802bb8c:	ee30 7a40 	vsub.f32	s14, s0, s0
 802bb90:	e7f5      	b.n	802bb7e <__ieee754_logf+0xe>
 802bb92:	f1b3 4fff 	cmp.w	r3, #2139095040	; 0x7f800000
 802bb96:	db02      	blt.n	802bb9e <__ieee754_logf+0x2e>
 802bb98:	ee30 0a00 	vadd.f32	s0, s0, s0
 802bb9c:	4770      	bx	lr
 802bb9e:	f5b3 0f00 	cmp.w	r3, #8388608	; 0x800000
 802bba2:	bfb8      	it	lt
 802bba4:	eddf 7a5c 	vldrlt	s15, [pc, #368]	; 802bd18 <__ieee754_logf+0x1a8>
 802bba8:	485c      	ldr	r0, [pc, #368]	; (802bd1c <__ieee754_logf+0x1ac>)
 802bbaa:	bfbe      	ittt	lt
 802bbac:	ee60 7a27 	vmullt.f32	s15, s0, s15
 802bbb0:	f06f 0118 	mvnlt.w	r1, #24
 802bbb4:	ee17 3a90 	vmovlt	r3, s15
 802bbb8:	ea4f 52e3 	mov.w	r2, r3, asr #23
 802bbbc:	f3c3 0316 	ubfx	r3, r3, #0, #23
 802bbc0:	4418      	add	r0, r3
 802bbc2:	bfa8      	it	ge
 802bbc4:	2100      	movge	r1, #0
 802bbc6:	3a7f      	subs	r2, #127	; 0x7f
 802bbc8:	440a      	add	r2, r1
 802bbca:	f400 0100 	and.w	r1, r0, #8388608	; 0x800000
 802bbce:	f081 517e 	eor.w	r1, r1, #1065353216	; 0x3f800000
 802bbd2:	4319      	orrs	r1, r3
 802bbd4:	ee00 1a10 	vmov	s0, r1
 802bbd8:	4951      	ldr	r1, [pc, #324]	; (802bd20 <__ieee754_logf+0x1b0>)
 802bbda:	eb02 52d0 	add.w	r2, r2, r0, lsr #23
 802bbde:	f103 000f 	add.w	r0, r3, #15
 802bbe2:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
 802bbe6:	4001      	ands	r1, r0
 802bbe8:	ee30 0a67 	vsub.f32	s0, s0, s15
 802bbec:	bb89      	cbnz	r1, 802bc52 <__ieee754_logf+0xe2>
 802bbee:	eeb5 0a40 	vcmp.f32	s0, #0.0
 802bbf2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802bbf6:	d10f      	bne.n	802bc18 <__ieee754_logf+0xa8>
 802bbf8:	2a00      	cmp	r2, #0
 802bbfa:	f000 8085 	beq.w	802bd08 <__ieee754_logf+0x198>
 802bbfe:	ee07 2a90 	vmov	s15, r2
 802bc02:	ed9f 0a48 	vldr	s0, [pc, #288]	; 802bd24 <__ieee754_logf+0x1b4>
 802bc06:	ed9f 7a48 	vldr	s14, [pc, #288]	; 802bd28 <__ieee754_logf+0x1b8>
 802bc0a:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 802bc0e:	ee27 0a80 	vmul.f32	s0, s15, s0
 802bc12:	eea7 0a87 	vfma.f32	s0, s15, s14
 802bc16:	4770      	bx	lr
 802bc18:	eddf 6a44 	vldr	s13, [pc, #272]	; 802bd2c <__ieee754_logf+0x1bc>
 802bc1c:	eef6 7a00 	vmov.f32	s15, #96	; 0x3f000000  0.5
 802bc20:	eee0 7a66 	vfms.f32	s15, s0, s13
 802bc24:	ee20 7a00 	vmul.f32	s14, s0, s0
 802bc28:	ee27 7a27 	vmul.f32	s14, s14, s15
 802bc2c:	b912      	cbnz	r2, 802bc34 <__ieee754_logf+0xc4>
 802bc2e:	ee30 0a47 	vsub.f32	s0, s0, s14
 802bc32:	4770      	bx	lr
 802bc34:	ee07 2a90 	vmov	s15, r2
 802bc38:	eddf 6a3a 	vldr	s13, [pc, #232]	; 802bd24 <__ieee754_logf+0x1b4>
 802bc3c:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 802bc40:	eea7 7ae6 	vfms.f32	s14, s15, s13
 802bc44:	ee37 0a40 	vsub.f32	s0, s14, s0
 802bc48:	ed9f 7a37 	vldr	s14, [pc, #220]	; 802bd28 <__ieee754_logf+0x1b8>
 802bc4c:	ee97 0a87 	vfnms.f32	s0, s15, s14
 802bc50:	4770      	bx	lr
 802bc52:	eef0 7a00 	vmov.f32	s15, #0	; 0x40000000  2.0
 802bc56:	ee70 7a27 	vadd.f32	s15, s0, s15
 802bc5a:	eddf 5a35 	vldr	s11, [pc, #212]	; 802bd30 <__ieee754_logf+0x1c0>
 802bc5e:	eddf 4a35 	vldr	s9, [pc, #212]	; 802bd34 <__ieee754_logf+0x1c4>
 802bc62:	4935      	ldr	r1, [pc, #212]	; (802bd38 <__ieee754_logf+0x1c8>)
 802bc64:	ee80 6a27 	vdiv.f32	s12, s0, s15
 802bc68:	4419      	add	r1, r3
 802bc6a:	f5c3 1357 	rsb	r3, r3, #3522560	; 0x35c000
 802bc6e:	f503 7322 	add.w	r3, r3, #648	; 0x288
 802bc72:	430b      	orrs	r3, r1
 802bc74:	2b00      	cmp	r3, #0
 802bc76:	ee07 2a90 	vmov	s15, r2
 802bc7a:	ee26 5a06 	vmul.f32	s10, s12, s12
 802bc7e:	eef8 6ae7 	vcvt.f32.s32	s13, s15
 802bc82:	ee25 7a05 	vmul.f32	s14, s10, s10
 802bc86:	eddf 7a2d 	vldr	s15, [pc, #180]	; 802bd3c <__ieee754_logf+0x1cc>
 802bc8a:	eee7 7a25 	vfma.f32	s15, s14, s11
 802bc8e:	eddf 5a2c 	vldr	s11, [pc, #176]	; 802bd40 <__ieee754_logf+0x1d0>
 802bc92:	eee7 5a87 	vfma.f32	s11, s15, s14
 802bc96:	eddf 7a2b 	vldr	s15, [pc, #172]	; 802bd44 <__ieee754_logf+0x1d4>
 802bc9a:	eee7 7a24 	vfma.f32	s15, s14, s9
 802bc9e:	eddf 4a2a 	vldr	s9, [pc, #168]	; 802bd48 <__ieee754_logf+0x1d8>
 802bca2:	eee7 4a87 	vfma.f32	s9, s15, s14
 802bca6:	eddf 7a29 	vldr	s15, [pc, #164]	; 802bd4c <__ieee754_logf+0x1dc>
 802bcaa:	eee4 7a87 	vfma.f32	s15, s9, s14
 802bcae:	ee67 7a85 	vmul.f32	s15, s15, s10
 802bcb2:	eee5 7a87 	vfma.f32	s15, s11, s14
 802bcb6:	dd1c      	ble.n	802bcf2 <__ieee754_logf+0x182>
 802bcb8:	eeb6 7a00 	vmov.f32	s14, #96	; 0x3f000000  0.5
 802bcbc:	ee20 7a07 	vmul.f32	s14, s0, s14
 802bcc0:	ee27 7a00 	vmul.f32	s14, s14, s0
 802bcc4:	ee77 7a87 	vadd.f32	s15, s15, s14
 802bcc8:	ee67 7a86 	vmul.f32	s15, s15, s12
 802bccc:	b922      	cbnz	r2, 802bcd8 <__ieee754_logf+0x168>
 802bcce:	ee77 7a67 	vsub.f32	s15, s14, s15
 802bcd2:	ee30 0a67 	vsub.f32	s0, s0, s15
 802bcd6:	4770      	bx	lr
 802bcd8:	ed9f 6a12 	vldr	s12, [pc, #72]	; 802bd24 <__ieee754_logf+0x1b4>
 802bcdc:	eee6 7a86 	vfma.f32	s15, s13, s12
 802bce0:	ee77 7a67 	vsub.f32	s15, s14, s15
 802bce4:	ee37 0ac0 	vsub.f32	s0, s15, s0
 802bce8:	eddf 7a0f 	vldr	s15, [pc, #60]	; 802bd28 <__ieee754_logf+0x1b8>
 802bcec:	ee96 0aa7 	vfnms.f32	s0, s13, s15
 802bcf0:	4770      	bx	lr
 802bcf2:	ee70 7a67 	vsub.f32	s15, s0, s15
 802bcf6:	ee67 7a86 	vmul.f32	s15, s15, s12
 802bcfa:	2a00      	cmp	r2, #0
 802bcfc:	d0e9      	beq.n	802bcd2 <__ieee754_logf+0x162>
 802bcfe:	ed9f 7a09 	vldr	s14, [pc, #36]	; 802bd24 <__ieee754_logf+0x1b4>
 802bd02:	eee6 7ac7 	vfms.f32	s15, s13, s14
 802bd06:	e7ed      	b.n	802bce4 <__ieee754_logf+0x174>
 802bd08:	ed9f 0a02 	vldr	s0, [pc, #8]	; 802bd14 <__ieee754_logf+0x1a4>
 802bd0c:	4770      	bx	lr
 802bd0e:	bf00      	nop
 802bd10:	cc000000 	.word	0xcc000000
 802bd14:	00000000 	.word	0x00000000
 802bd18:	4c000000 	.word	0x4c000000
 802bd1c:	004afb20 	.word	0x004afb20
 802bd20:	007ffff0 	.word	0x007ffff0
 802bd24:	3717f7d1 	.word	0x3717f7d1
 802bd28:	3f317180 	.word	0x3f317180
 802bd2c:	3eaaaaab 	.word	0x3eaaaaab
 802bd30:	3e1cd04f 	.word	0x3e1cd04f
 802bd34:	3e178897 	.word	0x3e178897
 802bd38:	ffcf5c30 	.word	0xffcf5c30
 802bd3c:	3e638e29 	.word	0x3e638e29
 802bd40:	3ecccccd 	.word	0x3ecccccd
 802bd44:	3e3a3325 	.word	0x3e3a3325
 802bd48:	3e924925 	.word	0x3e924925
 802bd4c:	3f2aaaab 	.word	0x3f2aaaab

0802bd50 <__ieee754_log10f>:
 802bd50:	b508      	push	{r3, lr}
 802bd52:	ee10 2a10 	vmov	r2, s0
 802bd56:	f032 4300 	bics.w	r3, r2, #2147483648	; 0x80000000
 802bd5a:	ed2d 8b02 	vpush	{d8}
 802bd5e:	d108      	bne.n	802bd72 <__ieee754_log10f+0x22>
 802bd60:	ed9f 7a21 	vldr	s14, [pc, #132]	; 802bde8 <__ieee754_log10f+0x98>
 802bd64:	eddf 7a21 	vldr	s15, [pc, #132]	; 802bdec <__ieee754_log10f+0x9c>
 802bd68:	ee87 0a27 	vdiv.f32	s0, s14, s15
 802bd6c:	ecbd 8b02 	vpop	{d8}
 802bd70:	bd08      	pop	{r3, pc}
 802bd72:	2a00      	cmp	r2, #0
 802bd74:	da02      	bge.n	802bd7c <__ieee754_log10f+0x2c>
 802bd76:	ee30 7a40 	vsub.f32	s14, s0, s0
 802bd7a:	e7f3      	b.n	802bd64 <__ieee754_log10f+0x14>
 802bd7c:	f1b2 4fff 	cmp.w	r2, #2139095040	; 0x7f800000
 802bd80:	db02      	blt.n	802bd88 <__ieee754_log10f+0x38>
 802bd82:	ee30 0a00 	vadd.f32	s0, s0, s0
 802bd86:	e7f1      	b.n	802bd6c <__ieee754_log10f+0x1c>
 802bd88:	f5b2 0f00 	cmp.w	r2, #8388608	; 0x800000
 802bd8c:	bfbf      	itttt	lt
 802bd8e:	eddf 7a18 	vldrlt	s15, [pc, #96]	; 802bdf0 <__ieee754_log10f+0xa0>
 802bd92:	ee60 7a27 	vmullt.f32	s15, s0, s15
 802bd96:	f06f 0118 	mvnlt.w	r1, #24
 802bd9a:	ee17 2a90 	vmovlt	r2, s15
 802bd9e:	ea4f 53e2 	mov.w	r3, r2, asr #23
 802bda2:	bfa8      	it	ge
 802bda4:	2100      	movge	r1, #0
 802bda6:	3b7f      	subs	r3, #127	; 0x7f
 802bda8:	440b      	add	r3, r1
 802bdaa:	0fd9      	lsrs	r1, r3, #31
 802bdac:	eb03 73d3 	add.w	r3, r3, r3, lsr #31
 802bdb0:	ee07 3a90 	vmov	s15, r3
 802bdb4:	f3c2 0216 	ubfx	r2, r2, #0, #23
 802bdb8:	f1c1 037f 	rsb	r3, r1, #127	; 0x7f
 802bdbc:	ea42 53c3 	orr.w	r3, r2, r3, lsl #23
 802bdc0:	ee00 3a10 	vmov	s0, r3
 802bdc4:	eeb8 8ae7 	vcvt.f32.s32	s16, s15
 802bdc8:	f7ff fed2 	bl	802bb70 <__ieee754_logf>
 802bdcc:	eddf 7a09 	vldr	s15, [pc, #36]	; 802bdf4 <__ieee754_log10f+0xa4>
 802bdd0:	ee20 0a27 	vmul.f32	s0, s0, s15
 802bdd4:	eddf 7a08 	vldr	s15, [pc, #32]	; 802bdf8 <__ieee754_log10f+0xa8>
 802bdd8:	eea8 0a27 	vfma.f32	s0, s16, s15
 802bddc:	eddf 7a07 	vldr	s15, [pc, #28]	; 802bdfc <__ieee754_log10f+0xac>
 802bde0:	eea8 0a27 	vfma.f32	s0, s16, s15
 802bde4:	e7c2      	b.n	802bd6c <__ieee754_log10f+0x1c>
 802bde6:	bf00      	nop
 802bde8:	cc000000 	.word	0xcc000000
 802bdec:	00000000 	.word	0x00000000
 802bdf0:	4c000000 	.word	0x4c000000
 802bdf4:	3ede5bd9 	.word	0x3ede5bd9
 802bdf8:	355427db 	.word	0x355427db
 802bdfc:	3e9a2080 	.word	0x3e9a2080

0802be00 <__ieee754_powf>:
 802be00:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 802be04:	ee10 4a90 	vmov	r4, s1
 802be08:	f034 4800 	bics.w	r8, r4, #2147483648	; 0x80000000
 802be0c:	ed2d 8b02 	vpush	{d8}
 802be10:	ee10 6a10 	vmov	r6, s0
 802be14:	eeb0 8a40 	vmov.f32	s16, s0
 802be18:	eef0 8a60 	vmov.f32	s17, s1
 802be1c:	d10c      	bne.n	802be38 <__ieee754_powf+0x38>
 802be1e:	f486 0680 	eor.w	r6, r6, #4194304	; 0x400000
 802be22:	0076      	lsls	r6, r6, #1
 802be24:	f516 0f00 	cmn.w	r6, #8388608	; 0x800000
 802be28:	f240 8296 	bls.w	802c358 <__ieee754_powf+0x558>
 802be2c:	ee38 0a28 	vadd.f32	s0, s16, s17
 802be30:	ecbd 8b02 	vpop	{d8}
 802be34:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 802be38:	f026 4500 	bic.w	r5, r6, #2147483648	; 0x80000000
 802be3c:	f1b5 4fff 	cmp.w	r5, #2139095040	; 0x7f800000
 802be40:	dcf4      	bgt.n	802be2c <__ieee754_powf+0x2c>
 802be42:	f1b8 4fff 	cmp.w	r8, #2139095040	; 0x7f800000
 802be46:	dd08      	ble.n	802be5a <__ieee754_powf+0x5a>
 802be48:	f1b6 5f7e 	cmp.w	r6, #1065353216	; 0x3f800000
 802be4c:	d1ee      	bne.n	802be2c <__ieee754_powf+0x2c>
 802be4e:	f484 0480 	eor.w	r4, r4, #4194304	; 0x400000
 802be52:	0064      	lsls	r4, r4, #1
 802be54:	f514 0f00 	cmn.w	r4, #8388608	; 0x800000
 802be58:	e7e6      	b.n	802be28 <__ieee754_powf+0x28>
 802be5a:	2e00      	cmp	r6, #0
 802be5c:	da20      	bge.n	802bea0 <__ieee754_powf+0xa0>
 802be5e:	f1b8 4f97 	cmp.w	r8, #1266679808	; 0x4b800000
 802be62:	da2d      	bge.n	802bec0 <__ieee754_powf+0xc0>
 802be64:	f1b8 5f7e 	cmp.w	r8, #1065353216	; 0x3f800000
 802be68:	f2c0 827f 	blt.w	802c36a <__ieee754_powf+0x56a>
 802be6c:	ea4f 53e8 	mov.w	r3, r8, asr #23
 802be70:	f1c3 0396 	rsb	r3, r3, #150	; 0x96
 802be74:	fa48 f703 	asr.w	r7, r8, r3
 802be78:	fa07 f303 	lsl.w	r3, r7, r3
 802be7c:	4543      	cmp	r3, r8
 802be7e:	f040 8274 	bne.w	802c36a <__ieee754_powf+0x56a>
 802be82:	f007 0701 	and.w	r7, r7, #1
 802be86:	f1c7 0702 	rsb	r7, r7, #2
 802be8a:	f1b8 5f7e 	cmp.w	r8, #1065353216	; 0x3f800000
 802be8e:	d11f      	bne.n	802bed0 <__ieee754_powf+0xd0>
 802be90:	2c00      	cmp	r4, #0
 802be92:	f280 8267 	bge.w	802c364 <__ieee754_powf+0x564>
 802be96:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
 802be9a:	ee87 0a88 	vdiv.f32	s0, s15, s16
 802be9e:	e7c7      	b.n	802be30 <__ieee754_powf+0x30>
 802bea0:	2700      	movs	r7, #0
 802bea2:	f1b8 4fff 	cmp.w	r8, #2139095040	; 0x7f800000
 802bea6:	d1f0      	bne.n	802be8a <__ieee754_powf+0x8a>
 802bea8:	f1b5 5f7e 	cmp.w	r5, #1065353216	; 0x3f800000
 802beac:	f000 8254 	beq.w	802c358 <__ieee754_powf+0x558>
 802beb0:	dd08      	ble.n	802bec4 <__ieee754_powf+0xc4>
 802beb2:	ed9f 0ac2 	vldr	s0, [pc, #776]	; 802c1bc <__ieee754_powf+0x3bc>
 802beb6:	2c00      	cmp	r4, #0
 802beb8:	bfa8      	it	ge
 802beba:	eeb0 0a68 	vmovge.f32	s0, s17
 802bebe:	e7b7      	b.n	802be30 <__ieee754_powf+0x30>
 802bec0:	2702      	movs	r7, #2
 802bec2:	e7ee      	b.n	802bea2 <__ieee754_powf+0xa2>
 802bec4:	2c00      	cmp	r4, #0
 802bec6:	f280 824a 	bge.w	802c35e <__ieee754_powf+0x55e>
 802beca:	eeb1 0a68 	vneg.f32	s0, s17
 802bece:	e7af      	b.n	802be30 <__ieee754_powf+0x30>
 802bed0:	f1b4 4f80 	cmp.w	r4, #1073741824	; 0x40000000
 802bed4:	d102      	bne.n	802bedc <__ieee754_powf+0xdc>
 802bed6:	ee28 0a08 	vmul.f32	s0, s16, s16
 802beda:	e7a9      	b.n	802be30 <__ieee754_powf+0x30>
 802bedc:	f1b4 5f7c 	cmp.w	r4, #1056964608	; 0x3f000000
 802bee0:	eeb0 0a48 	vmov.f32	s0, s16
 802bee4:	d107      	bne.n	802bef6 <__ieee754_powf+0xf6>
 802bee6:	2e00      	cmp	r6, #0
 802bee8:	db05      	blt.n	802bef6 <__ieee754_powf+0xf6>
 802beea:	ecbd 8b02 	vpop	{d8}
 802beee:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
 802bef2:	f000 bbff 	b.w	802c6f4 <__ieee754_sqrtf>
 802bef6:	f7fe fdc1 	bl	802aa7c <fabsf>
 802befa:	b125      	cbz	r5, 802bf06 <__ieee754_powf+0x106>
 802befc:	f026 4340 	bic.w	r3, r6, #3221225472	; 0xc0000000
 802bf00:	f1b3 5f7e 	cmp.w	r3, #1065353216	; 0x3f800000
 802bf04:	d116      	bne.n	802bf34 <__ieee754_powf+0x134>
 802bf06:	2c00      	cmp	r4, #0
 802bf08:	bfbc      	itt	lt
 802bf0a:	eef7 7a00 	vmovlt.f32	s15, #112	; 0x3f800000  1.0
 802bf0e:	ee87 0a80 	vdivlt.f32	s0, s15, s0
 802bf12:	2e00      	cmp	r6, #0
 802bf14:	da8c      	bge.n	802be30 <__ieee754_powf+0x30>
 802bf16:	f1a5 557e 	sub.w	r5, r5, #1065353216	; 0x3f800000
 802bf1a:	ea55 0307 	orrs.w	r3, r5, r7
 802bf1e:	d104      	bne.n	802bf2a <__ieee754_powf+0x12a>
 802bf20:	ee70 7a40 	vsub.f32	s15, s0, s0
 802bf24:	ee87 0aa7 	vdiv.f32	s0, s15, s15
 802bf28:	e782      	b.n	802be30 <__ieee754_powf+0x30>
 802bf2a:	2f01      	cmp	r7, #1
 802bf2c:	d180      	bne.n	802be30 <__ieee754_powf+0x30>
 802bf2e:	eeb1 0a40 	vneg.f32	s0, s0
 802bf32:	e77d      	b.n	802be30 <__ieee754_powf+0x30>
 802bf34:	0ff0      	lsrs	r0, r6, #31
 802bf36:	3801      	subs	r0, #1
 802bf38:	ea57 0300 	orrs.w	r3, r7, r0
 802bf3c:	d104      	bne.n	802bf48 <__ieee754_powf+0x148>
 802bf3e:	ee38 8a48 	vsub.f32	s16, s16, s16
 802bf42:	ee88 0a08 	vdiv.f32	s0, s16, s16
 802bf46:	e773      	b.n	802be30 <__ieee754_powf+0x30>
 802bf48:	f1b8 4f9a 	cmp.w	r8, #1291845632	; 0x4d000000
 802bf4c:	dd74      	ble.n	802c038 <__ieee754_powf+0x238>
 802bf4e:	4b9c      	ldr	r3, [pc, #624]	; (802c1c0 <__ieee754_powf+0x3c0>)
 802bf50:	429d      	cmp	r5, r3
 802bf52:	dc08      	bgt.n	802bf66 <__ieee754_powf+0x166>
 802bf54:	2c00      	cmp	r4, #0
 802bf56:	da0b      	bge.n	802bf70 <__ieee754_powf+0x170>
 802bf58:	2000      	movs	r0, #0
 802bf5a:	ecbd 8b02 	vpop	{d8}
 802bf5e:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
 802bf62:	f000 bfe5 	b.w	802cf30 <__math_oflowf>
 802bf66:	4b97      	ldr	r3, [pc, #604]	; (802c1c4 <__ieee754_powf+0x3c4>)
 802bf68:	429d      	cmp	r5, r3
 802bf6a:	dd08      	ble.n	802bf7e <__ieee754_powf+0x17e>
 802bf6c:	2c00      	cmp	r4, #0
 802bf6e:	dcf3      	bgt.n	802bf58 <__ieee754_powf+0x158>
 802bf70:	2000      	movs	r0, #0
 802bf72:	ecbd 8b02 	vpop	{d8}
 802bf76:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
 802bf7a:	f000 bfd3 	b.w	802cf24 <__math_uflowf>
 802bf7e:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
 802bf82:	ee30 0a67 	vsub.f32	s0, s0, s15
 802bf86:	eddf 6a90 	vldr	s13, [pc, #576]	; 802c1c8 <__ieee754_powf+0x3c8>
 802bf8a:	eef5 7a00 	vmov.f32	s15, #80	; 0x3e800000  0.250
 802bf8e:	eee0 6a67 	vfms.f32	s13, s0, s15
 802bf92:	eef6 7a00 	vmov.f32	s15, #96	; 0x3f000000  0.5
 802bf96:	eee6 7ac0 	vfms.f32	s15, s13, s0
 802bf9a:	ee20 7a00 	vmul.f32	s14, s0, s0
 802bf9e:	ee67 7a27 	vmul.f32	s15, s14, s15
 802bfa2:	ed9f 7a8a 	vldr	s14, [pc, #552]	; 802c1cc <__ieee754_powf+0x3cc>
 802bfa6:	ee67 7a67 	vnmul.f32	s15, s14, s15
 802bfaa:	ed9f 7a89 	vldr	s14, [pc, #548]	; 802c1d0 <__ieee754_powf+0x3d0>
 802bfae:	eee0 7a07 	vfma.f32	s15, s0, s14
 802bfb2:	ed9f 7a88 	vldr	s14, [pc, #544]	; 802c1d4 <__ieee754_powf+0x3d4>
 802bfb6:	eef0 6a67 	vmov.f32	s13, s15
 802bfba:	eee0 6a07 	vfma.f32	s13, s0, s14
 802bfbe:	ee16 3a90 	vmov	r3, s13
 802bfc2:	f423 637f 	bic.w	r3, r3, #4080	; 0xff0
 802bfc6:	f023 030f 	bic.w	r3, r3, #15
 802bfca:	ee00 3a90 	vmov	s1, r3
 802bfce:	eee0 0a47 	vfms.f32	s1, s0, s14
 802bfd2:	ee77 7ae0 	vsub.f32	s15, s15, s1
 802bfd6:	f424 647f 	bic.w	r4, r4, #4080	; 0xff0
 802bfda:	f024 040f 	bic.w	r4, r4, #15
 802bfde:	ee07 4a10 	vmov	s14, r4
 802bfe2:	ee67 0aa8 	vmul.f32	s1, s15, s17
 802bfe6:	ee38 7ac7 	vsub.f32	s14, s17, s14
 802bfea:	ee07 3a90 	vmov	s15, r3
 802bfee:	eee7 0a27 	vfma.f32	s1, s14, s15
 802bff2:	3f01      	subs	r7, #1
 802bff4:	ea57 0200 	orrs.w	r2, r7, r0
 802bff8:	ee07 4a10 	vmov	s14, r4
 802bffc:	ee67 7a87 	vmul.f32	s15, s15, s14
 802c000:	eeb7 8a00 	vmov.f32	s16, #112	; 0x3f800000  1.0
 802c004:	ee30 7aa7 	vadd.f32	s14, s1, s15
 802c008:	eebf 0a00 	vmov.f32	s0, #240	; 0xbf800000 -1.0
 802c00c:	ee17 4a10 	vmov	r4, s14
 802c010:	bf08      	it	eq
 802c012:	eeb0 8a40 	vmoveq.f32	s16, s0
 802c016:	2c00      	cmp	r4, #0
 802c018:	f024 4300 	bic.w	r3, r4, #2147483648	; 0x80000000
 802c01c:	f340 817e 	ble.w	802c31c <__ieee754_powf+0x51c>
 802c020:	f1b3 4f86 	cmp.w	r3, #1124073472	; 0x43000000
 802c024:	f340 80f8 	ble.w	802c218 <__ieee754_powf+0x418>
 802c028:	eeb5 8ac0 	vcmpe.f32	s16, #0.0
 802c02c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802c030:	bf4c      	ite	mi
 802c032:	2001      	movmi	r0, #1
 802c034:	2000      	movpl	r0, #0
 802c036:	e790      	b.n	802bf5a <__ieee754_powf+0x15a>
 802c038:	f016 4fff 	tst.w	r6, #2139095040	; 0x7f800000
 802c03c:	bf01      	itttt	eq
 802c03e:	eddf 7a66 	vldreq	s15, [pc, #408]	; 802c1d8 <__ieee754_powf+0x3d8>
 802c042:	ee60 7a27 	vmuleq.f32	s15, s0, s15
 802c046:	f06f 0217 	mvneq.w	r2, #23
 802c04a:	ee17 5a90 	vmoveq	r5, s15
 802c04e:	ea4f 53e5 	mov.w	r3, r5, asr #23
 802c052:	bf18      	it	ne
 802c054:	2200      	movne	r2, #0
 802c056:	3b7f      	subs	r3, #127	; 0x7f
 802c058:	4413      	add	r3, r2
 802c05a:	4a60      	ldr	r2, [pc, #384]	; (802c1dc <__ieee754_powf+0x3dc>)
 802c05c:	f3c5 0516 	ubfx	r5, r5, #0, #23
 802c060:	4295      	cmp	r5, r2
 802c062:	f045 517e 	orr.w	r1, r5, #1065353216	; 0x3f800000
 802c066:	dd06      	ble.n	802c076 <__ieee754_powf+0x276>
 802c068:	4a5d      	ldr	r2, [pc, #372]	; (802c1e0 <__ieee754_powf+0x3e0>)
 802c06a:	4295      	cmp	r5, r2
 802c06c:	f340 80a4 	ble.w	802c1b8 <__ieee754_powf+0x3b8>
 802c070:	3301      	adds	r3, #1
 802c072:	f5a1 0100 	sub.w	r1, r1, #8388608	; 0x800000
 802c076:	2500      	movs	r5, #0
 802c078:	4a5a      	ldr	r2, [pc, #360]	; (802c1e4 <__ieee754_powf+0x3e4>)
 802c07a:	eb02 0285 	add.w	r2, r2, r5, lsl #2
 802c07e:	ee07 1a90 	vmov	s15, r1
 802c082:	ed92 7a00 	vldr	s14, [r2]
 802c086:	4a58      	ldr	r2, [pc, #352]	; (802c1e8 <__ieee754_powf+0x3e8>)
 802c088:	ee37 6a27 	vadd.f32	s12, s14, s15
 802c08c:	eef7 5a00 	vmov.f32	s11, #112	; 0x3f800000  1.0
 802c090:	eec5 6a86 	vdiv.f32	s13, s11, s12
 802c094:	1049      	asrs	r1, r1, #1
 802c096:	f041 5100 	orr.w	r1, r1, #536870912	; 0x20000000
 802c09a:	f501 2180 	add.w	r1, r1, #262144	; 0x40000
 802c09e:	eb01 5145 	add.w	r1, r1, r5, lsl #21
 802c0a2:	ee37 5ac7 	vsub.f32	s10, s15, s14
 802c0a6:	ee06 1a10 	vmov	s12, r1
 802c0aa:	ee65 4a26 	vmul.f32	s9, s10, s13
 802c0ae:	ee36 7a47 	vsub.f32	s14, s12, s14
 802c0b2:	ee14 6a90 	vmov	r6, s9
 802c0b6:	4016      	ands	r6, r2
 802c0b8:	ee05 6a90 	vmov	s11, r6
 802c0bc:	eea5 5ac6 	vfms.f32	s10, s11, s12
 802c0c0:	ee77 7ac7 	vsub.f32	s15, s15, s14
 802c0c4:	ed9f 7a49 	vldr	s14, [pc, #292]	; 802c1ec <__ieee754_powf+0x3ec>
 802c0c8:	eea5 5ae7 	vfms.f32	s10, s11, s15
 802c0cc:	ee64 7aa4 	vmul.f32	s15, s9, s9
 802c0d0:	ee25 6a26 	vmul.f32	s12, s10, s13
 802c0d4:	eddf 6a46 	vldr	s13, [pc, #280]	; 802c1f0 <__ieee754_powf+0x3f0>
 802c0d8:	eea7 7aa6 	vfma.f32	s14, s15, s13
 802c0dc:	eddf 6a45 	vldr	s13, [pc, #276]	; 802c1f4 <__ieee754_powf+0x3f4>
 802c0e0:	eee7 6a27 	vfma.f32	s13, s14, s15
 802c0e4:	ed9f 7a38 	vldr	s14, [pc, #224]	; 802c1c8 <__ieee754_powf+0x3c8>
 802c0e8:	eea6 7aa7 	vfma.f32	s14, s13, s15
 802c0ec:	eddf 6a42 	vldr	s13, [pc, #264]	; 802c1f8 <__ieee754_powf+0x3f8>
 802c0f0:	eee7 6a27 	vfma.f32	s13, s14, s15
 802c0f4:	ed9f 7a41 	vldr	s14, [pc, #260]	; 802c1fc <__ieee754_powf+0x3fc>
 802c0f8:	eea6 7aa7 	vfma.f32	s14, s13, s15
 802c0fc:	ee74 6aa5 	vadd.f32	s13, s9, s11
 802c100:	ee27 5aa7 	vmul.f32	s10, s15, s15
 802c104:	ee66 6a86 	vmul.f32	s13, s13, s12
 802c108:	eee5 6a07 	vfma.f32	s13, s10, s14
 802c10c:	eeb0 5a08 	vmov.f32	s10, #8	; 0x40400000  3.0
 802c110:	eef0 7a45 	vmov.f32	s15, s10
 802c114:	eee5 7aa5 	vfma.f32	s15, s11, s11
 802c118:	ee77 7aa6 	vadd.f32	s15, s15, s13
 802c11c:	ee17 1a90 	vmov	r1, s15
 802c120:	4011      	ands	r1, r2
 802c122:	ee07 1a90 	vmov	s15, r1
 802c126:	ee37 7ac5 	vsub.f32	s14, s15, s10
 802c12a:	eea5 7ae5 	vfms.f32	s14, s11, s11
 802c12e:	ee36 7ac7 	vsub.f32	s14, s13, s14
 802c132:	ee27 7a24 	vmul.f32	s14, s14, s9
 802c136:	eea6 7a27 	vfma.f32	s14, s12, s15
 802c13a:	eeb0 6a47 	vmov.f32	s12, s14
 802c13e:	eea5 6aa7 	vfma.f32	s12, s11, s15
 802c142:	ee16 1a10 	vmov	r1, s12
 802c146:	4011      	ands	r1, r2
 802c148:	ee06 1a90 	vmov	s13, r1
 802c14c:	eee5 6ae7 	vfms.f32	s13, s11, s15
 802c150:	eddf 7a2b 	vldr	s15, [pc, #172]	; 802c200 <__ieee754_powf+0x400>
 802c154:	eddf 5a2b 	vldr	s11, [pc, #172]	; 802c204 <__ieee754_powf+0x404>
 802c158:	ee37 7a66 	vsub.f32	s14, s14, s13
 802c15c:	ee06 1a10 	vmov	s12, r1
 802c160:	ee27 7a27 	vmul.f32	s14, s14, s15
 802c164:	eddf 7a28 	vldr	s15, [pc, #160]	; 802c208 <__ieee754_powf+0x408>
 802c168:	4928      	ldr	r1, [pc, #160]	; (802c20c <__ieee754_powf+0x40c>)
 802c16a:	eea6 7a27 	vfma.f32	s14, s12, s15
 802c16e:	eb01 0185 	add.w	r1, r1, r5, lsl #2
 802c172:	edd1 7a00 	vldr	s15, [r1]
 802c176:	ee37 7a27 	vadd.f32	s14, s14, s15
 802c17a:	ee07 3a90 	vmov	s15, r3
 802c17e:	4b24      	ldr	r3, [pc, #144]	; (802c210 <__ieee754_powf+0x410>)
 802c180:	eef8 6ae7 	vcvt.f32.s32	s13, s15
 802c184:	eef0 7a47 	vmov.f32	s15, s14
 802c188:	eee6 7a25 	vfma.f32	s15, s12, s11
 802c18c:	eb03 0585 	add.w	r5, r3, r5, lsl #2
 802c190:	edd5 0a00 	vldr	s1, [r5]
 802c194:	ee77 7aa0 	vadd.f32	s15, s15, s1
 802c198:	ee77 7aa6 	vadd.f32	s15, s15, s13
 802c19c:	ee17 3a90 	vmov	r3, s15
 802c1a0:	4013      	ands	r3, r2
 802c1a2:	ee07 3a90 	vmov	s15, r3
 802c1a6:	ee77 6ae6 	vsub.f32	s13, s15, s13
 802c1aa:	ee76 6ae0 	vsub.f32	s13, s13, s1
 802c1ae:	eee6 6a65 	vfms.f32	s13, s12, s11
 802c1b2:	ee77 7a66 	vsub.f32	s15, s14, s13
 802c1b6:	e70e      	b.n	802bfd6 <__ieee754_powf+0x1d6>
 802c1b8:	2501      	movs	r5, #1
 802c1ba:	e75d      	b.n	802c078 <__ieee754_powf+0x278>
 802c1bc:	00000000 	.word	0x00000000
 802c1c0:	3f7ffff3 	.word	0x3f7ffff3
 802c1c4:	3f800007 	.word	0x3f800007
 802c1c8:	3eaaaaab 	.word	0x3eaaaaab
 802c1cc:	3fb8aa3b 	.word	0x3fb8aa3b
 802c1d0:	36eca570 	.word	0x36eca570
 802c1d4:	3fb8aa00 	.word	0x3fb8aa00
 802c1d8:	4b800000 	.word	0x4b800000
 802c1dc:	001cc471 	.word	0x001cc471
 802c1e0:	005db3d6 	.word	0x005db3d6
 802c1e4:	08057de4 	.word	0x08057de4
 802c1e8:	fffff000 	.word	0xfffff000
 802c1ec:	3e6c3255 	.word	0x3e6c3255
 802c1f0:	3e53f142 	.word	0x3e53f142
 802c1f4:	3e8ba305 	.word	0x3e8ba305
 802c1f8:	3edb6db7 	.word	0x3edb6db7
 802c1fc:	3f19999a 	.word	0x3f19999a
 802c200:	3f76384f 	.word	0x3f76384f
 802c204:	3f763800 	.word	0x3f763800
 802c208:	369dc3a0 	.word	0x369dc3a0
 802c20c:	08057df4 	.word	0x08057df4
 802c210:	08057dec 	.word	0x08057dec
 802c214:	3338aa3c 	.word	0x3338aa3c
 802c218:	f040 8095 	bne.w	802c346 <__ieee754_powf+0x546>
 802c21c:	ed5f 6a03 	vldr	s13, [pc, #-12]	; 802c214 <__ieee754_powf+0x414>
 802c220:	ee37 7a67 	vsub.f32	s14, s14, s15
 802c224:	ee70 6aa6 	vadd.f32	s13, s1, s13
 802c228:	eef4 6ac7 	vcmpe.f32	s13, s14
 802c22c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802c230:	f73f aefa 	bgt.w	802c028 <__ieee754_powf+0x228>
 802c234:	15db      	asrs	r3, r3, #23
 802c236:	f1a3 007e 	sub.w	r0, r3, #126	; 0x7e
 802c23a:	f44f 0300 	mov.w	r3, #8388608	; 0x800000
 802c23e:	4103      	asrs	r3, r0
 802c240:	4423      	add	r3, r4
 802c242:	494b      	ldr	r1, [pc, #300]	; (802c370 <__ieee754_powf+0x570>)
 802c244:	f3c3 52c7 	ubfx	r2, r3, #23, #8
 802c248:	3a7f      	subs	r2, #127	; 0x7f
 802c24a:	4111      	asrs	r1, r2
 802c24c:	ea23 0101 	bic.w	r1, r3, r1
 802c250:	ee07 1a10 	vmov	s14, r1
 802c254:	f3c3 0016 	ubfx	r0, r3, #0, #23
 802c258:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
 802c25c:	f1c2 0217 	rsb	r2, r2, #23
 802c260:	4110      	asrs	r0, r2
 802c262:	2c00      	cmp	r4, #0
 802c264:	ee77 7ac7 	vsub.f32	s15, s15, s14
 802c268:	bfb8      	it	lt
 802c26a:	4240      	neglt	r0, r0
 802c26c:	ee37 7aa0 	vadd.f32	s14, s15, s1
 802c270:	ed9f 0a40 	vldr	s0, [pc, #256]	; 802c374 <__ieee754_powf+0x574>
 802c274:	eddf 6a40 	vldr	s13, [pc, #256]	; 802c378 <__ieee754_powf+0x578>
 802c278:	ee17 3a10 	vmov	r3, s14
 802c27c:	f423 637f 	bic.w	r3, r3, #4080	; 0xff0
 802c280:	f023 030f 	bic.w	r3, r3, #15
 802c284:	ee07 3a10 	vmov	s14, r3
 802c288:	ee77 7a67 	vsub.f32	s15, s14, s15
 802c28c:	ee27 0a00 	vmul.f32	s0, s14, s0
 802c290:	ee70 0ae7 	vsub.f32	s1, s1, s15
 802c294:	eddf 7a39 	vldr	s15, [pc, #228]	; 802c37c <__ieee754_powf+0x57c>
 802c298:	eea0 0aa7 	vfma.f32	s0, s1, s15
 802c29c:	eef0 7a40 	vmov.f32	s15, s0
 802c2a0:	eee7 7a26 	vfma.f32	s15, s14, s13
 802c2a4:	eeb0 6a67 	vmov.f32	s12, s15
 802c2a8:	eea7 6a66 	vfms.f32	s12, s14, s13
 802c2ac:	ee27 7aa7 	vmul.f32	s14, s15, s15
 802c2b0:	ee30 0a46 	vsub.f32	s0, s0, s12
 802c2b4:	eddf 6a32 	vldr	s13, [pc, #200]	; 802c380 <__ieee754_powf+0x580>
 802c2b8:	ed9f 6a32 	vldr	s12, [pc, #200]	; 802c384 <__ieee754_powf+0x584>
 802c2bc:	eee7 6a06 	vfma.f32	s13, s14, s12
 802c2c0:	ed9f 6a31 	vldr	s12, [pc, #196]	; 802c388 <__ieee754_powf+0x588>
 802c2c4:	eea6 6a87 	vfma.f32	s12, s13, s14
 802c2c8:	eddf 6a30 	vldr	s13, [pc, #192]	; 802c38c <__ieee754_powf+0x58c>
 802c2cc:	eee6 6a07 	vfma.f32	s13, s12, s14
 802c2d0:	ed9f 6a2f 	vldr	s12, [pc, #188]	; 802c390 <__ieee754_powf+0x590>
 802c2d4:	eea6 6a87 	vfma.f32	s12, s13, s14
 802c2d8:	eef0 6a67 	vmov.f32	s13, s15
 802c2dc:	eee6 6a47 	vfms.f32	s13, s12, s14
 802c2e0:	eeb0 7a00 	vmov.f32	s14, #0	; 0x40000000  2.0
 802c2e4:	ee27 6aa6 	vmul.f32	s12, s15, s13
 802c2e8:	ee76 6ac7 	vsub.f32	s13, s13, s14
 802c2ec:	eea7 0a80 	vfma.f32	s0, s15, s0
 802c2f0:	ee86 7a26 	vdiv.f32	s14, s12, s13
 802c2f4:	ee37 0a40 	vsub.f32	s0, s14, s0
 802c2f8:	ee70 7a67 	vsub.f32	s15, s0, s15
 802c2fc:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
 802c300:	ee30 0a67 	vsub.f32	s0, s0, s15
 802c304:	ee10 3a10 	vmov	r3, s0
 802c308:	eb03 53c0 	add.w	r3, r3, r0, lsl #23
 802c30c:	f5b3 0f00 	cmp.w	r3, #8388608	; 0x800000
 802c310:	da1f      	bge.n	802c352 <__ieee754_powf+0x552>
 802c312:	f000 ff65 	bl	802d1e0 <scalbnf>
 802c316:	ee20 0a08 	vmul.f32	s0, s0, s16
 802c31a:	e589      	b.n	802be30 <__ieee754_powf+0x30>
 802c31c:	4a1d      	ldr	r2, [pc, #116]	; (802c394 <__ieee754_powf+0x594>)
 802c31e:	4293      	cmp	r3, r2
 802c320:	dd07      	ble.n	802c332 <__ieee754_powf+0x532>
 802c322:	eeb5 8ac0 	vcmpe.f32	s16, #0.0
 802c326:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802c32a:	bf4c      	ite	mi
 802c32c:	2001      	movmi	r0, #1
 802c32e:	2000      	movpl	r0, #0
 802c330:	e61f      	b.n	802bf72 <__ieee754_powf+0x172>
 802c332:	d108      	bne.n	802c346 <__ieee754_powf+0x546>
 802c334:	ee37 7a67 	vsub.f32	s14, s14, s15
 802c338:	eeb4 7ae0 	vcmpe.f32	s14, s1
 802c33c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802c340:	f6ff af78 	blt.w	802c234 <__ieee754_powf+0x434>
 802c344:	e7ed      	b.n	802c322 <__ieee754_powf+0x522>
 802c346:	f1b3 5f7c 	cmp.w	r3, #1056964608	; 0x3f000000
 802c34a:	f73f af73 	bgt.w	802c234 <__ieee754_powf+0x434>
 802c34e:	2000      	movs	r0, #0
 802c350:	e78c      	b.n	802c26c <__ieee754_powf+0x46c>
 802c352:	ee00 3a10 	vmov	s0, r3
 802c356:	e7de      	b.n	802c316 <__ieee754_powf+0x516>
 802c358:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
 802c35c:	e568      	b.n	802be30 <__ieee754_powf+0x30>
 802c35e:	ed9f 0a0e 	vldr	s0, [pc, #56]	; 802c398 <__ieee754_powf+0x598>
 802c362:	e565      	b.n	802be30 <__ieee754_powf+0x30>
 802c364:	eeb0 0a48 	vmov.f32	s0, s16
 802c368:	e562      	b.n	802be30 <__ieee754_powf+0x30>
 802c36a:	2700      	movs	r7, #0
 802c36c:	e58d      	b.n	802be8a <__ieee754_powf+0x8a>
 802c36e:	bf00      	nop
 802c370:	007fffff 	.word	0x007fffff
 802c374:	35bfbe8c 	.word	0x35bfbe8c
 802c378:	3f317200 	.word	0x3f317200
 802c37c:	3f317218 	.word	0x3f317218
 802c380:	b5ddea0e 	.word	0xb5ddea0e
 802c384:	3331bb4c 	.word	0x3331bb4c
 802c388:	388ab355 	.word	0x388ab355
 802c38c:	bb360b61 	.word	0xbb360b61
 802c390:	3e2aaaab 	.word	0x3e2aaaab
 802c394:	43160000 	.word	0x43160000
 802c398:	00000000 	.word	0x00000000

0802c39c <__ieee754_rem_pio2f>:
 802c39c:	b5f0      	push	{r4, r5, r6, r7, lr}
 802c39e:	ee10 6a10 	vmov	r6, s0
 802c3a2:	4b8e      	ldr	r3, [pc, #568]	; (802c5dc <__ieee754_rem_pio2f+0x240>)
 802c3a4:	f026 4500 	bic.w	r5, r6, #2147483648	; 0x80000000
 802c3a8:	429d      	cmp	r5, r3
 802c3aa:	b087      	sub	sp, #28
 802c3ac:	eef0 7a40 	vmov.f32	s15, s0
 802c3b0:	4604      	mov	r4, r0
 802c3b2:	dc05      	bgt.n	802c3c0 <__ieee754_rem_pio2f+0x24>
 802c3b4:	2300      	movs	r3, #0
 802c3b6:	ed80 0a00 	vstr	s0, [r0]
 802c3ba:	6043      	str	r3, [r0, #4]
 802c3bc:	2000      	movs	r0, #0
 802c3be:	e01a      	b.n	802c3f6 <__ieee754_rem_pio2f+0x5a>
 802c3c0:	4b87      	ldr	r3, [pc, #540]	; (802c5e0 <__ieee754_rem_pio2f+0x244>)
 802c3c2:	429d      	cmp	r5, r3
 802c3c4:	dc46      	bgt.n	802c454 <__ieee754_rem_pio2f+0xb8>
 802c3c6:	2e00      	cmp	r6, #0
 802c3c8:	ed9f 0a86 	vldr	s0, [pc, #536]	; 802c5e4 <__ieee754_rem_pio2f+0x248>
 802c3cc:	4b86      	ldr	r3, [pc, #536]	; (802c5e8 <__ieee754_rem_pio2f+0x24c>)
 802c3ce:	f025 050f 	bic.w	r5, r5, #15
 802c3d2:	dd1f      	ble.n	802c414 <__ieee754_rem_pio2f+0x78>
 802c3d4:	429d      	cmp	r5, r3
 802c3d6:	ee77 7ac0 	vsub.f32	s15, s15, s0
 802c3da:	d00e      	beq.n	802c3fa <__ieee754_rem_pio2f+0x5e>
 802c3dc:	ed9f 7a83 	vldr	s14, [pc, #524]	; 802c5ec <__ieee754_rem_pio2f+0x250>
 802c3e0:	ee37 0ac7 	vsub.f32	s0, s15, s14
 802c3e4:	ee77 7ac0 	vsub.f32	s15, s15, s0
 802c3e8:	ed80 0a00 	vstr	s0, [r0]
 802c3ec:	ee77 7ac7 	vsub.f32	s15, s15, s14
 802c3f0:	2001      	movs	r0, #1
 802c3f2:	edc4 7a01 	vstr	s15, [r4, #4]
 802c3f6:	b007      	add	sp, #28
 802c3f8:	bdf0      	pop	{r4, r5, r6, r7, pc}
 802c3fa:	ed9f 0a7d 	vldr	s0, [pc, #500]	; 802c5f0 <__ieee754_rem_pio2f+0x254>
 802c3fe:	ed9f 7a7d 	vldr	s14, [pc, #500]	; 802c5f4 <__ieee754_rem_pio2f+0x258>
 802c402:	ee77 7ac0 	vsub.f32	s15, s15, s0
 802c406:	ee77 6ac7 	vsub.f32	s13, s15, s14
 802c40a:	ee77 7ae6 	vsub.f32	s15, s15, s13
 802c40e:	edc0 6a00 	vstr	s13, [r0]
 802c412:	e7eb      	b.n	802c3ec <__ieee754_rem_pio2f+0x50>
 802c414:	429d      	cmp	r5, r3
 802c416:	ee77 7a80 	vadd.f32	s15, s15, s0
 802c41a:	d00e      	beq.n	802c43a <__ieee754_rem_pio2f+0x9e>
 802c41c:	ed9f 7a73 	vldr	s14, [pc, #460]	; 802c5ec <__ieee754_rem_pio2f+0x250>
 802c420:	ee37 0a87 	vadd.f32	s0, s15, s14
 802c424:	ee77 7ac0 	vsub.f32	s15, s15, s0
 802c428:	ed80 0a00 	vstr	s0, [r0]
 802c42c:	ee77 7a87 	vadd.f32	s15, s15, s14
 802c430:	f04f 30ff 	mov.w	r0, #4294967295
 802c434:	edc4 7a01 	vstr	s15, [r4, #4]
 802c438:	e7dd      	b.n	802c3f6 <__ieee754_rem_pio2f+0x5a>
 802c43a:	ed9f 0a6d 	vldr	s0, [pc, #436]	; 802c5f0 <__ieee754_rem_pio2f+0x254>
 802c43e:	ed9f 7a6d 	vldr	s14, [pc, #436]	; 802c5f4 <__ieee754_rem_pio2f+0x258>
 802c442:	ee77 7a80 	vadd.f32	s15, s15, s0
 802c446:	ee77 6a87 	vadd.f32	s13, s15, s14
 802c44a:	ee77 7ae6 	vsub.f32	s15, s15, s13
 802c44e:	edc0 6a00 	vstr	s13, [r0]
 802c452:	e7eb      	b.n	802c42c <__ieee754_rem_pio2f+0x90>
 802c454:	4b68      	ldr	r3, [pc, #416]	; (802c5f8 <__ieee754_rem_pio2f+0x25c>)
 802c456:	429d      	cmp	r5, r3
 802c458:	dc72      	bgt.n	802c540 <__ieee754_rem_pio2f+0x1a4>
 802c45a:	f7fe fb0f 	bl	802aa7c <fabsf>
 802c45e:	ed9f 7a67 	vldr	s14, [pc, #412]	; 802c5fc <__ieee754_rem_pio2f+0x260>
 802c462:	eef6 7a00 	vmov.f32	s15, #96	; 0x3f000000  0.5
 802c466:	eee0 7a07 	vfma.f32	s15, s0, s14
 802c46a:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 802c46e:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
 802c472:	ee17 0a90 	vmov	r0, s15
 802c476:	eddf 7a5b 	vldr	s15, [pc, #364]	; 802c5e4 <__ieee754_rem_pio2f+0x248>
 802c47a:	eea7 0a67 	vfms.f32	s0, s14, s15
 802c47e:	281f      	cmp	r0, #31
 802c480:	eddf 7a5a 	vldr	s15, [pc, #360]	; 802c5ec <__ieee754_rem_pio2f+0x250>
 802c484:	ee67 7a27 	vmul.f32	s15, s14, s15
 802c488:	eeb1 6a47 	vneg.f32	s12, s14
 802c48c:	ee70 6a67 	vsub.f32	s13, s0, s15
 802c490:	ee16 2a90 	vmov	r2, s13
 802c494:	dc1c      	bgt.n	802c4d0 <__ieee754_rem_pio2f+0x134>
 802c496:	495a      	ldr	r1, [pc, #360]	; (802c600 <__ieee754_rem_pio2f+0x264>)
 802c498:	1e47      	subs	r7, r0, #1
 802c49a:	f025 03ff 	bic.w	r3, r5, #255	; 0xff
 802c49e:	f851 1027 	ldr.w	r1, [r1, r7, lsl #2]
 802c4a2:	428b      	cmp	r3, r1
 802c4a4:	d014      	beq.n	802c4d0 <__ieee754_rem_pio2f+0x134>
 802c4a6:	6022      	str	r2, [r4, #0]
 802c4a8:	ed94 7a00 	vldr	s14, [r4]
 802c4ac:	ee30 0a47 	vsub.f32	s0, s0, s14
 802c4b0:	2e00      	cmp	r6, #0
 802c4b2:	ee30 0a67 	vsub.f32	s0, s0, s15
 802c4b6:	ed84 0a01 	vstr	s0, [r4, #4]
 802c4ba:	da9c      	bge.n	802c3f6 <__ieee754_rem_pio2f+0x5a>
 802c4bc:	eeb1 7a47 	vneg.f32	s14, s14
 802c4c0:	eeb1 0a40 	vneg.f32	s0, s0
 802c4c4:	ed84 7a00 	vstr	s14, [r4]
 802c4c8:	ed84 0a01 	vstr	s0, [r4, #4]
 802c4cc:	4240      	negs	r0, r0
 802c4ce:	e792      	b.n	802c3f6 <__ieee754_rem_pio2f+0x5a>
 802c4d0:	f3c2 51c7 	ubfx	r1, r2, #23, #8
 802c4d4:	15eb      	asrs	r3, r5, #23
 802c4d6:	ebc1 55d5 	rsb	r5, r1, r5, lsr #23
 802c4da:	2d08      	cmp	r5, #8
 802c4dc:	dde3      	ble.n	802c4a6 <__ieee754_rem_pio2f+0x10a>
 802c4de:	eddf 7a44 	vldr	s15, [pc, #272]	; 802c5f0 <__ieee754_rem_pio2f+0x254>
 802c4e2:	eddf 5a44 	vldr	s11, [pc, #272]	; 802c5f4 <__ieee754_rem_pio2f+0x258>
 802c4e6:	eef0 6a40 	vmov.f32	s13, s0
 802c4ea:	eee6 6a27 	vfma.f32	s13, s12, s15
 802c4ee:	ee30 0a66 	vsub.f32	s0, s0, s13
 802c4f2:	eea6 0a27 	vfma.f32	s0, s12, s15
 802c4f6:	eef0 7a40 	vmov.f32	s15, s0
 802c4fa:	eed7 7a25 	vfnms.f32	s15, s14, s11
 802c4fe:	ee76 5ae7 	vsub.f32	s11, s13, s15
 802c502:	ee15 2a90 	vmov	r2, s11
 802c506:	f3c2 51c7 	ubfx	r1, r2, #23, #8
 802c50a:	1a5b      	subs	r3, r3, r1
 802c50c:	2b19      	cmp	r3, #25
 802c50e:	dc04      	bgt.n	802c51a <__ieee754_rem_pio2f+0x17e>
 802c510:	edc4 5a00 	vstr	s11, [r4]
 802c514:	eeb0 0a66 	vmov.f32	s0, s13
 802c518:	e7c6      	b.n	802c4a8 <__ieee754_rem_pio2f+0x10c>
 802c51a:	eddf 5a3a 	vldr	s11, [pc, #232]	; 802c604 <__ieee754_rem_pio2f+0x268>
 802c51e:	eeb0 0a66 	vmov.f32	s0, s13
 802c522:	eea6 0a25 	vfma.f32	s0, s12, s11
 802c526:	ee76 7ac0 	vsub.f32	s15, s13, s0
 802c52a:	eddf 6a37 	vldr	s13, [pc, #220]	; 802c608 <__ieee754_rem_pio2f+0x26c>
 802c52e:	eee6 7a25 	vfma.f32	s15, s12, s11
 802c532:	eed7 7a26 	vfnms.f32	s15, s14, s13
 802c536:	ee30 7a67 	vsub.f32	s14, s0, s15
 802c53a:	ed84 7a00 	vstr	s14, [r4]
 802c53e:	e7b3      	b.n	802c4a8 <__ieee754_rem_pio2f+0x10c>
 802c540:	f1b5 4fff 	cmp.w	r5, #2139095040	; 0x7f800000
 802c544:	db06      	blt.n	802c554 <__ieee754_rem_pio2f+0x1b8>
 802c546:	ee70 7a40 	vsub.f32	s15, s0, s0
 802c54a:	edc0 7a01 	vstr	s15, [r0, #4]
 802c54e:	edc0 7a00 	vstr	s15, [r0]
 802c552:	e733      	b.n	802c3bc <__ieee754_rem_pio2f+0x20>
 802c554:	15ea      	asrs	r2, r5, #23
 802c556:	3a86      	subs	r2, #134	; 0x86
 802c558:	eba5 53c2 	sub.w	r3, r5, r2, lsl #23
 802c55c:	ee07 3a90 	vmov	s15, r3
 802c560:	eebd 7ae7 	vcvt.s32.f32	s14, s15
 802c564:	eddf 6a29 	vldr	s13, [pc, #164]	; 802c60c <__ieee754_rem_pio2f+0x270>
 802c568:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
 802c56c:	ee77 7ac7 	vsub.f32	s15, s15, s14
 802c570:	ed8d 7a03 	vstr	s14, [sp, #12]
 802c574:	ee67 7aa6 	vmul.f32	s15, s15, s13
 802c578:	eebd 7ae7 	vcvt.s32.f32	s14, s15
 802c57c:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
 802c580:	ee77 7ac7 	vsub.f32	s15, s15, s14
 802c584:	ed8d 7a04 	vstr	s14, [sp, #16]
 802c588:	ee67 7aa6 	vmul.f32	s15, s15, s13
 802c58c:	eef5 7a40 	vcmp.f32	s15, #0.0
 802c590:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802c594:	edcd 7a05 	vstr	s15, [sp, #20]
 802c598:	d11e      	bne.n	802c5d8 <__ieee754_rem_pio2f+0x23c>
 802c59a:	eeb5 7a40 	vcmp.f32	s14, #0.0
 802c59e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802c5a2:	bf14      	ite	ne
 802c5a4:	2302      	movne	r3, #2
 802c5a6:	2301      	moveq	r3, #1
 802c5a8:	4919      	ldr	r1, [pc, #100]	; (802c610 <__ieee754_rem_pio2f+0x274>)
 802c5aa:	9101      	str	r1, [sp, #4]
 802c5ac:	2102      	movs	r1, #2
 802c5ae:	9100      	str	r1, [sp, #0]
 802c5b0:	a803      	add	r0, sp, #12
 802c5b2:	4621      	mov	r1, r4
 802c5b4:	f000 f902 	bl	802c7bc <__kernel_rem_pio2f>
 802c5b8:	2e00      	cmp	r6, #0
 802c5ba:	f6bf af1c 	bge.w	802c3f6 <__ieee754_rem_pio2f+0x5a>
 802c5be:	edd4 7a00 	vldr	s15, [r4]
 802c5c2:	eef1 7a67 	vneg.f32	s15, s15
 802c5c6:	edc4 7a00 	vstr	s15, [r4]
 802c5ca:	edd4 7a01 	vldr	s15, [r4, #4]
 802c5ce:	eef1 7a67 	vneg.f32	s15, s15
 802c5d2:	edc4 7a01 	vstr	s15, [r4, #4]
 802c5d6:	e779      	b.n	802c4cc <__ieee754_rem_pio2f+0x130>
 802c5d8:	2303      	movs	r3, #3
 802c5da:	e7e5      	b.n	802c5a8 <__ieee754_rem_pio2f+0x20c>
 802c5dc:	3f490fd8 	.word	0x3f490fd8
 802c5e0:	4016cbe3 	.word	0x4016cbe3
 802c5e4:	3fc90f80 	.word	0x3fc90f80
 802c5e8:	3fc90fd0 	.word	0x3fc90fd0
 802c5ec:	37354443 	.word	0x37354443
 802c5f0:	37354400 	.word	0x37354400
 802c5f4:	2e85a308 	.word	0x2e85a308
 802c5f8:	43490f80 	.word	0x43490f80
 802c5fc:	3f22f984 	.word	0x3f22f984
 802c600:	08057dfc 	.word	0x08057dfc
 802c604:	2e85a300 	.word	0x2e85a300
 802c608:	248d3132 	.word	0x248d3132
 802c60c:	43800000 	.word	0x43800000
 802c610:	08057e7c 	.word	0x08057e7c

0802c614 <__ieee754_sinhf>:
 802c614:	b510      	push	{r4, lr}
 802c616:	ee10 3a10 	vmov	r3, s0
 802c61a:	f023 4400 	bic.w	r4, r3, #2147483648	; 0x80000000
 802c61e:	f1b4 4fff 	cmp.w	r4, #2139095040	; 0x7f800000
 802c622:	ed2d 8b02 	vpush	{d8}
 802c626:	eef0 7a40 	vmov.f32	s15, s0
 802c62a:	db06      	blt.n	802c63a <__ieee754_sinhf+0x26>
 802c62c:	ee70 7a00 	vadd.f32	s15, s0, s0
 802c630:	ecbd 8b02 	vpop	{d8}
 802c634:	eeb0 0a67 	vmov.f32	s0, s15
 802c638:	bd10      	pop	{r4, pc}
 802c63a:	2b00      	cmp	r3, #0
 802c63c:	4b29      	ldr	r3, [pc, #164]	; (802c6e4 <__ieee754_sinhf+0xd0>)
 802c63e:	eef6 8a00 	vmov.f32	s17, #96	; 0x3f000000  0.5
 802c642:	eebe 8a00 	vmov.f32	s16, #224	; 0xbf000000 -0.5
 802c646:	bfa8      	it	ge
 802c648:	eeb0 8a68 	vmovge.f32	s16, s17
 802c64c:	429c      	cmp	r4, r3
 802c64e:	dc2c      	bgt.n	802c6aa <__ieee754_sinhf+0x96>
 802c650:	f1b4 5f46 	cmp.w	r4, #830472192	; 0x31800000
 802c654:	eef7 8a00 	vmov.f32	s17, #112	; 0x3f800000  1.0
 802c658:	da08      	bge.n	802c66c <__ieee754_sinhf+0x58>
 802c65a:	ed9f 7a23 	vldr	s14, [pc, #140]	; 802c6e8 <__ieee754_sinhf+0xd4>
 802c65e:	ee30 7a07 	vadd.f32	s14, s0, s14
 802c662:	eeb4 7ae8 	vcmpe.f32	s14, s17
 802c666:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802c66a:	dce1      	bgt.n	802c630 <__ieee754_sinhf+0x1c>
 802c66c:	eeb0 0a67 	vmov.f32	s0, s15
 802c670:	f7fe fa04 	bl	802aa7c <fabsf>
 802c674:	f000 fc84 	bl	802cf80 <expm1f>
 802c678:	f1b4 5f7e 	cmp.w	r4, #1065353216	; 0x3f800000
 802c67c:	da0c      	bge.n	802c698 <__ieee754_sinhf+0x84>
 802c67e:	ee60 7a00 	vmul.f32	s15, s0, s0
 802c682:	ee70 8a28 	vadd.f32	s17, s0, s17
 802c686:	ee87 7aa8 	vdiv.f32	s14, s15, s17
 802c68a:	eef0 7a00 	vmov.f32	s15, #0	; 0x40000000  2.0
 802c68e:	ee90 7a27 	vfnms.f32	s14, s0, s15
 802c692:	ee67 7a08 	vmul.f32	s15, s14, s16
 802c696:	e7cb      	b.n	802c630 <__ieee754_sinhf+0x1c>
 802c698:	ee70 8a28 	vadd.f32	s17, s0, s17
 802c69c:	ee80 7a28 	vdiv.f32	s14, s0, s17
 802c6a0:	ee77 7a00 	vadd.f32	s15, s14, s0
 802c6a4:	ee67 7a88 	vmul.f32	s15, s15, s16
 802c6a8:	e7c2      	b.n	802c630 <__ieee754_sinhf+0x1c>
 802c6aa:	4b10      	ldr	r3, [pc, #64]	; (802c6ec <__ieee754_sinhf+0xd8>)
 802c6ac:	429c      	cmp	r4, r3
 802c6ae:	dc06      	bgt.n	802c6be <__ieee754_sinhf+0xaa>
 802c6b0:	f7fe f9e4 	bl	802aa7c <fabsf>
 802c6b4:	f7ff f90c 	bl	802b8d0 <__ieee754_expf>
 802c6b8:	ee60 7a08 	vmul.f32	s15, s0, s16
 802c6bc:	e7b8      	b.n	802c630 <__ieee754_sinhf+0x1c>
 802c6be:	4b0c      	ldr	r3, [pc, #48]	; (802c6f0 <__ieee754_sinhf+0xdc>)
 802c6c0:	429c      	cmp	r4, r3
 802c6c2:	dc0a      	bgt.n	802c6da <__ieee754_sinhf+0xc6>
 802c6c4:	f7fe f9da 	bl	802aa7c <fabsf>
 802c6c8:	ee20 0a28 	vmul.f32	s0, s0, s17
 802c6cc:	f7ff f900 	bl	802b8d0 <__ieee754_expf>
 802c6d0:	ee68 7a00 	vmul.f32	s15, s16, s0
 802c6d4:	ee67 7a80 	vmul.f32	s15, s15, s0
 802c6d8:	e7aa      	b.n	802c630 <__ieee754_sinhf+0x1c>
 802c6da:	ed9f 7a03 	vldr	s14, [pc, #12]	; 802c6e8 <__ieee754_sinhf+0xd4>
 802c6de:	ee60 7a07 	vmul.f32	s15, s0, s14
 802c6e2:	e7a5      	b.n	802c630 <__ieee754_sinhf+0x1c>
 802c6e4:	41afffff 	.word	0x41afffff
 802c6e8:	7cf0bdc2 	.word	0x7cf0bdc2
 802c6ec:	42b17217 	.word	0x42b17217
 802c6f0:	42b2d4fc 	.word	0x42b2d4fc

0802c6f4 <__ieee754_sqrtf>:
 802c6f4:	eeb1 0ac0 	vsqrt.f32	s0, s0
 802c6f8:	4770      	bx	lr
	...

0802c6fc <__kernel_cosf>:
 802c6fc:	ee10 3a10 	vmov	r3, s0
 802c700:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
 802c704:	f1b3 5f48 	cmp.w	r3, #838860800	; 0x32000000
 802c708:	eeb7 6a00 	vmov.f32	s12, #112	; 0x3f800000  1.0
 802c70c:	da05      	bge.n	802c71a <__kernel_cosf+0x1e>
 802c70e:	eefd 7ac0 	vcvt.s32.f32	s15, s0
 802c712:	ee17 2a90 	vmov	r2, s15
 802c716:	2a00      	cmp	r2, #0
 802c718:	d03d      	beq.n	802c796 <__kernel_cosf+0x9a>
 802c71a:	ee60 5a00 	vmul.f32	s11, s0, s0
 802c71e:	eddf 7a1f 	vldr	s15, [pc, #124]	; 802c79c <__kernel_cosf+0xa0>
 802c722:	ed9f 7a1f 	vldr	s14, [pc, #124]	; 802c7a0 <__kernel_cosf+0xa4>
 802c726:	eddf 6a1f 	vldr	s13, [pc, #124]	; 802c7a4 <__kernel_cosf+0xa8>
 802c72a:	4a1f      	ldr	r2, [pc, #124]	; (802c7a8 <__kernel_cosf+0xac>)
 802c72c:	eea5 7aa7 	vfma.f32	s14, s11, s15
 802c730:	4293      	cmp	r3, r2
 802c732:	eddf 7a1e 	vldr	s15, [pc, #120]	; 802c7ac <__kernel_cosf+0xb0>
 802c736:	eee7 7a25 	vfma.f32	s15, s14, s11
 802c73a:	ed9f 7a1d 	vldr	s14, [pc, #116]	; 802c7b0 <__kernel_cosf+0xb4>
 802c73e:	eea7 7aa5 	vfma.f32	s14, s15, s11
 802c742:	eddf 7a1c 	vldr	s15, [pc, #112]	; 802c7b4 <__kernel_cosf+0xb8>
 802c746:	eee7 7a25 	vfma.f32	s15, s14, s11
 802c74a:	eeb0 7a66 	vmov.f32	s14, s13
 802c74e:	eea7 7aa5 	vfma.f32	s14, s15, s11
 802c752:	eef6 6a00 	vmov.f32	s13, #96	; 0x3f000000  0.5
 802c756:	ee65 7aa6 	vmul.f32	s15, s11, s13
 802c75a:	ee67 6a25 	vmul.f32	s13, s14, s11
 802c75e:	ee20 7ac0 	vnmul.f32	s14, s1, s0
 802c762:	eea5 7aa6 	vfma.f32	s14, s11, s13
 802c766:	dc04      	bgt.n	802c772 <__kernel_cosf+0x76>
 802c768:	ee37 7ac7 	vsub.f32	s14, s15, s14
 802c76c:	ee36 0a47 	vsub.f32	s0, s12, s14
 802c770:	4770      	bx	lr
 802c772:	4a11      	ldr	r2, [pc, #68]	; (802c7b8 <__kernel_cosf+0xbc>)
 802c774:	4293      	cmp	r3, r2
 802c776:	bfda      	itte	le
 802c778:	f103 437f 	addle.w	r3, r3, #4278190080	; 0xff000000
 802c77c:	ee06 3a90 	vmovle	s13, r3
 802c780:	eef5 6a02 	vmovgt.f32	s13, #82	; 0x3e900000  0.2812500
 802c784:	ee77 7ae6 	vsub.f32	s15, s15, s13
 802c788:	ee36 0a66 	vsub.f32	s0, s12, s13
 802c78c:	ee77 7ac7 	vsub.f32	s15, s15, s14
 802c790:	ee30 0a67 	vsub.f32	s0, s0, s15
 802c794:	4770      	bx	lr
 802c796:	eeb0 0a46 	vmov.f32	s0, s12
 802c79a:	4770      	bx	lr
 802c79c:	ad47d74e 	.word	0xad47d74e
 802c7a0:	310f74f6 	.word	0x310f74f6
 802c7a4:	3d2aaaab 	.word	0x3d2aaaab
 802c7a8:	3e999999 	.word	0x3e999999
 802c7ac:	b493f27c 	.word	0xb493f27c
 802c7b0:	37d00d01 	.word	0x37d00d01
 802c7b4:	bab60b61 	.word	0xbab60b61
 802c7b8:	3f480000 	.word	0x3f480000

0802c7bc <__kernel_rem_pio2f>:
 802c7bc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 802c7c0:	ed2d 8b04 	vpush	{d8-d9}
 802c7c4:	b0d9      	sub	sp, #356	; 0x164
 802c7c6:	4688      	mov	r8, r1
 802c7c8:	9002      	str	r0, [sp, #8]
 802c7ca:	49bb      	ldr	r1, [pc, #748]	; (802cab8 <__kernel_rem_pio2f+0x2fc>)
 802c7cc:	9866      	ldr	r0, [sp, #408]	; 0x198
 802c7ce:	9301      	str	r3, [sp, #4]
 802c7d0:	f851 a020 	ldr.w	sl, [r1, r0, lsl #2]
 802c7d4:	f8dd e19c 	ldr.w	lr, [sp, #412]	; 0x19c
 802c7d8:	1e59      	subs	r1, r3, #1
 802c7da:	1d13      	adds	r3, r2, #4
 802c7dc:	db27      	blt.n	802c82e <__kernel_rem_pio2f+0x72>
 802c7de:	f1b2 0b03 	subs.w	fp, r2, #3
 802c7e2:	bf48      	it	mi
 802c7e4:	f102 0b04 	addmi.w	fp, r2, #4
 802c7e8:	ea4f 00eb 	mov.w	r0, fp, asr #3
 802c7ec:	1c45      	adds	r5, r0, #1
 802c7ee:	00ec      	lsls	r4, r5, #3
 802c7f0:	1a47      	subs	r7, r0, r1
 802c7f2:	ed9f 7ab5 	vldr	s14, [pc, #724]	; 802cac8 <__kernel_rem_pio2f+0x30c>
 802c7f6:	9403      	str	r4, [sp, #12]
 802c7f8:	eba2 05c5 	sub.w	r5, r2, r5, lsl #3
 802c7fc:	eb0a 0c01 	add.w	ip, sl, r1
 802c800:	ae1c      	add	r6, sp, #112	; 0x70
 802c802:	eb0e 0987 	add.w	r9, lr, r7, lsl #2
 802c806:	2400      	movs	r4, #0
 802c808:	4564      	cmp	r4, ip
 802c80a:	dd12      	ble.n	802c832 <__kernel_rem_pio2f+0x76>
 802c80c:	9b01      	ldr	r3, [sp, #4]
 802c80e:	ac1c      	add	r4, sp, #112	; 0x70
 802c810:	eb04 0483 	add.w	r4, r4, r3, lsl #2
 802c814:	f50d 7b88 	add.w	fp, sp, #272	; 0x110
 802c818:	f04f 0c00 	mov.w	ip, #0
 802c81c:	45d4      	cmp	ip, sl
 802c81e:	dc27      	bgt.n	802c870 <__kernel_rem_pio2f+0xb4>
 802c820:	f8dd 9008 	ldr.w	r9, [sp, #8]
 802c824:	eddf 7aa8 	vldr	s15, [pc, #672]	; 802cac8 <__kernel_rem_pio2f+0x30c>
 802c828:	4627      	mov	r7, r4
 802c82a:	2600      	movs	r6, #0
 802c82c:	e016      	b.n	802c85c <__kernel_rem_pio2f+0xa0>
 802c82e:	2000      	movs	r0, #0
 802c830:	e7dc      	b.n	802c7ec <__kernel_rem_pio2f+0x30>
 802c832:	42e7      	cmn	r7, r4
 802c834:	bf5d      	ittte	pl
 802c836:	f859 3024 	ldrpl.w	r3, [r9, r4, lsl #2]
 802c83a:	ee07 3a90 	vmovpl	s15, r3
 802c83e:	eef8 7ae7 	vcvtpl.f32.s32	s15, s15
 802c842:	eef0 7a47 	vmovmi.f32	s15, s14
 802c846:	ece6 7a01 	vstmia	r6!, {s15}
 802c84a:	3401      	adds	r4, #1
 802c84c:	e7dc      	b.n	802c808 <__kernel_rem_pio2f+0x4c>
 802c84e:	ecf9 6a01 	vldmia	r9!, {s13}
 802c852:	ed97 7a00 	vldr	s14, [r7]
 802c856:	eee6 7a87 	vfma.f32	s15, s13, s14
 802c85a:	3601      	adds	r6, #1
 802c85c:	428e      	cmp	r6, r1
 802c85e:	f1a7 0704 	sub.w	r7, r7, #4
 802c862:	ddf4      	ble.n	802c84e <__kernel_rem_pio2f+0x92>
 802c864:	eceb 7a01 	vstmia	fp!, {s15}
 802c868:	f10c 0c01 	add.w	ip, ip, #1
 802c86c:	3404      	adds	r4, #4
 802c86e:	e7d5      	b.n	802c81c <__kernel_rem_pio2f+0x60>
 802c870:	ab08      	add	r3, sp, #32
 802c872:	eb03 038a 	add.w	r3, r3, sl, lsl #2
 802c876:	eddf 8a93 	vldr	s17, [pc, #588]	; 802cac4 <__kernel_rem_pio2f+0x308>
 802c87a:	ed9f 9a91 	vldr	s18, [pc, #580]	; 802cac0 <__kernel_rem_pio2f+0x304>
 802c87e:	9304      	str	r3, [sp, #16]
 802c880:	eb0e 0b80 	add.w	fp, lr, r0, lsl #2
 802c884:	4656      	mov	r6, sl
 802c886:	00b3      	lsls	r3, r6, #2
 802c888:	9305      	str	r3, [sp, #20]
 802c88a:	ab58      	add	r3, sp, #352	; 0x160
 802c88c:	eb03 0086 	add.w	r0, r3, r6, lsl #2
 802c890:	ac08      	add	r4, sp, #32
 802c892:	ab44      	add	r3, sp, #272	; 0x110
 802c894:	ed10 0a14 	vldr	s0, [r0, #-80]	; 0xffffffb0
 802c898:	46a4      	mov	ip, r4
 802c89a:	eb03 0086 	add.w	r0, r3, r6, lsl #2
 802c89e:	4637      	mov	r7, r6
 802c8a0:	2f00      	cmp	r7, #0
 802c8a2:	f1a0 0004 	sub.w	r0, r0, #4
 802c8a6:	dc4f      	bgt.n	802c948 <__kernel_rem_pio2f+0x18c>
 802c8a8:	4628      	mov	r0, r5
 802c8aa:	e9cd 1206 	strd	r1, r2, [sp, #24]
 802c8ae:	f000 fc97 	bl	802d1e0 <scalbnf>
 802c8b2:	eeb0 8a40 	vmov.f32	s16, s0
 802c8b6:	eeb4 0a00 	vmov.f32	s0, #64	; 0x3e000000  0.125
 802c8ba:	ee28 0a00 	vmul.f32	s0, s16, s0
 802c8be:	f7fe f8e5 	bl	802aa8c <floorf>
 802c8c2:	eef2 7a00 	vmov.f32	s15, #32	; 0x41000000  8.0
 802c8c6:	eea0 8a67 	vfms.f32	s16, s0, s15
 802c8ca:	2d00      	cmp	r5, #0
 802c8cc:	e9dd 1206 	ldrd	r1, r2, [sp, #24]
 802c8d0:	eefd 7ac8 	vcvt.s32.f32	s15, s16
 802c8d4:	eeb8 0ae7 	vcvt.f32.s32	s0, s15
 802c8d8:	ee17 9a90 	vmov	r9, s15
 802c8dc:	ee38 8a40 	vsub.f32	s16, s16, s0
 802c8e0:	dd44      	ble.n	802c96c <__kernel_rem_pio2f+0x1b0>
 802c8e2:	f106 3cff 	add.w	ip, r6, #4294967295
 802c8e6:	ab08      	add	r3, sp, #32
 802c8e8:	f1c5 0e08 	rsb	lr, r5, #8
 802c8ec:	f853 702c 	ldr.w	r7, [r3, ip, lsl #2]
 802c8f0:	fa47 f00e 	asr.w	r0, r7, lr
 802c8f4:	4481      	add	r9, r0
 802c8f6:	fa00 f00e 	lsl.w	r0, r0, lr
 802c8fa:	1a3f      	subs	r7, r7, r0
 802c8fc:	f1c5 0007 	rsb	r0, r5, #7
 802c900:	f843 702c 	str.w	r7, [r3, ip, lsl #2]
 802c904:	4107      	asrs	r7, r0
 802c906:	2f00      	cmp	r7, #0
 802c908:	dd3f      	ble.n	802c98a <__kernel_rem_pio2f+0x1ce>
 802c90a:	f04f 0e00 	mov.w	lr, #0
 802c90e:	f109 0901 	add.w	r9, r9, #1
 802c912:	4673      	mov	r3, lr
 802c914:	4576      	cmp	r6, lr
 802c916:	dc6b      	bgt.n	802c9f0 <__kernel_rem_pio2f+0x234>
 802c918:	2d00      	cmp	r5, #0
 802c91a:	dd04      	ble.n	802c926 <__kernel_rem_pio2f+0x16a>
 802c91c:	2d01      	cmp	r5, #1
 802c91e:	d078      	beq.n	802ca12 <__kernel_rem_pio2f+0x256>
 802c920:	2d02      	cmp	r5, #2
 802c922:	f000 8081 	beq.w	802ca28 <__kernel_rem_pio2f+0x26c>
 802c926:	2f02      	cmp	r7, #2
 802c928:	d12f      	bne.n	802c98a <__kernel_rem_pio2f+0x1ce>
 802c92a:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
 802c92e:	ee30 8a48 	vsub.f32	s16, s0, s16
 802c932:	b353      	cbz	r3, 802c98a <__kernel_rem_pio2f+0x1ce>
 802c934:	4628      	mov	r0, r5
 802c936:	e9cd 1206 	strd	r1, r2, [sp, #24]
 802c93a:	f000 fc51 	bl	802d1e0 <scalbnf>
 802c93e:	e9dd 1206 	ldrd	r1, r2, [sp, #24]
 802c942:	ee38 8a40 	vsub.f32	s16, s16, s0
 802c946:	e020      	b.n	802c98a <__kernel_rem_pio2f+0x1ce>
 802c948:	ee60 7a28 	vmul.f32	s15, s0, s17
 802c94c:	3f01      	subs	r7, #1
 802c94e:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 802c952:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 802c956:	eea7 0ac9 	vfms.f32	s0, s15, s18
 802c95a:	eebd 0ac0 	vcvt.s32.f32	s0, s0
 802c95e:	ecac 0a01 	vstmia	ip!, {s0}
 802c962:	ed90 0a00 	vldr	s0, [r0]
 802c966:	ee37 0a80 	vadd.f32	s0, s15, s0
 802c96a:	e799      	b.n	802c8a0 <__kernel_rem_pio2f+0xe4>
 802c96c:	d105      	bne.n	802c97a <__kernel_rem_pio2f+0x1be>
 802c96e:	1e70      	subs	r0, r6, #1
 802c970:	ab08      	add	r3, sp, #32
 802c972:	f853 7020 	ldr.w	r7, [r3, r0, lsl #2]
 802c976:	11ff      	asrs	r7, r7, #7
 802c978:	e7c5      	b.n	802c906 <__kernel_rem_pio2f+0x14a>
 802c97a:	eef6 7a00 	vmov.f32	s15, #96	; 0x3f000000  0.5
 802c97e:	eeb4 8ae7 	vcmpe.f32	s16, s15
 802c982:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802c986:	da31      	bge.n	802c9ec <__kernel_rem_pio2f+0x230>
 802c988:	2700      	movs	r7, #0
 802c98a:	eeb5 8a40 	vcmp.f32	s16, #0.0
 802c98e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802c992:	f040 809b 	bne.w	802cacc <__kernel_rem_pio2f+0x310>
 802c996:	1e74      	subs	r4, r6, #1
 802c998:	46a4      	mov	ip, r4
 802c99a:	2000      	movs	r0, #0
 802c99c:	45d4      	cmp	ip, sl
 802c99e:	da4a      	bge.n	802ca36 <__kernel_rem_pio2f+0x27a>
 802c9a0:	2800      	cmp	r0, #0
 802c9a2:	d07a      	beq.n	802ca9a <__kernel_rem_pio2f+0x2de>
 802c9a4:	ab08      	add	r3, sp, #32
 802c9a6:	3d08      	subs	r5, #8
 802c9a8:	f853 3024 	ldr.w	r3, [r3, r4, lsl #2]
 802c9ac:	2b00      	cmp	r3, #0
 802c9ae:	f000 8081 	beq.w	802cab4 <__kernel_rem_pio2f+0x2f8>
 802c9b2:	4628      	mov	r0, r5
 802c9b4:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
 802c9b8:	00a5      	lsls	r5, r4, #2
 802c9ba:	f000 fc11 	bl	802d1e0 <scalbnf>
 802c9be:	aa44      	add	r2, sp, #272	; 0x110
 802c9c0:	1d2b      	adds	r3, r5, #4
 802c9c2:	ed9f 7a40 	vldr	s14, [pc, #256]	; 802cac4 <__kernel_rem_pio2f+0x308>
 802c9c6:	18d1      	adds	r1, r2, r3
 802c9c8:	4622      	mov	r2, r4
 802c9ca:	2a00      	cmp	r2, #0
 802c9cc:	f280 80ae 	bge.w	802cb2c <__kernel_rem_pio2f+0x370>
 802c9d0:	4622      	mov	r2, r4
 802c9d2:	2a00      	cmp	r2, #0
 802c9d4:	f2c0 80cc 	blt.w	802cb70 <__kernel_rem_pio2f+0x3b4>
 802c9d8:	a944      	add	r1, sp, #272	; 0x110
 802c9da:	eb01 0682 	add.w	r6, r1, r2, lsl #2
 802c9de:	f8df c0dc 	ldr.w	ip, [pc, #220]	; 802cabc <__kernel_rem_pio2f+0x300>
 802c9e2:	eddf 7a39 	vldr	s15, [pc, #228]	; 802cac8 <__kernel_rem_pio2f+0x30c>
 802c9e6:	2000      	movs	r0, #0
 802c9e8:	1aa1      	subs	r1, r4, r2
 802c9ea:	e0b6      	b.n	802cb5a <__kernel_rem_pio2f+0x39e>
 802c9ec:	2702      	movs	r7, #2
 802c9ee:	e78c      	b.n	802c90a <__kernel_rem_pio2f+0x14e>
 802c9f0:	6820      	ldr	r0, [r4, #0]
 802c9f2:	b94b      	cbnz	r3, 802ca08 <__kernel_rem_pio2f+0x24c>
 802c9f4:	b118      	cbz	r0, 802c9fe <__kernel_rem_pio2f+0x242>
 802c9f6:	f5c0 7080 	rsb	r0, r0, #256	; 0x100
 802c9fa:	6020      	str	r0, [r4, #0]
 802c9fc:	2001      	movs	r0, #1
 802c9fe:	f10e 0e01 	add.w	lr, lr, #1
 802ca02:	3404      	adds	r4, #4
 802ca04:	4603      	mov	r3, r0
 802ca06:	e785      	b.n	802c914 <__kernel_rem_pio2f+0x158>
 802ca08:	f1c0 00ff 	rsb	r0, r0, #255	; 0xff
 802ca0c:	6020      	str	r0, [r4, #0]
 802ca0e:	4618      	mov	r0, r3
 802ca10:	e7f5      	b.n	802c9fe <__kernel_rem_pio2f+0x242>
 802ca12:	1e74      	subs	r4, r6, #1
 802ca14:	a808      	add	r0, sp, #32
 802ca16:	f850 0024 	ldr.w	r0, [r0, r4, lsl #2]
 802ca1a:	f000 007f 	and.w	r0, r0, #127	; 0x7f
 802ca1e:	f10d 0c20 	add.w	ip, sp, #32
 802ca22:	f84c 0024 	str.w	r0, [ip, r4, lsl #2]
 802ca26:	e77e      	b.n	802c926 <__kernel_rem_pio2f+0x16a>
 802ca28:	1e74      	subs	r4, r6, #1
 802ca2a:	a808      	add	r0, sp, #32
 802ca2c:	f850 0024 	ldr.w	r0, [r0, r4, lsl #2]
 802ca30:	f000 003f 	and.w	r0, r0, #63	; 0x3f
 802ca34:	e7f3      	b.n	802ca1e <__kernel_rem_pio2f+0x262>
 802ca36:	ab08      	add	r3, sp, #32
 802ca38:	f853 302c 	ldr.w	r3, [r3, ip, lsl #2]
 802ca3c:	f10c 3cff 	add.w	ip, ip, #4294967295
 802ca40:	4318      	orrs	r0, r3
 802ca42:	e7ab      	b.n	802c99c <__kernel_rem_pio2f+0x1e0>
 802ca44:	f10c 0c01 	add.w	ip, ip, #1
 802ca48:	f850 4d04 	ldr.w	r4, [r0, #-4]!
 802ca4c:	2c00      	cmp	r4, #0
 802ca4e:	d0f9      	beq.n	802ca44 <__kernel_rem_pio2f+0x288>
 802ca50:	9b05      	ldr	r3, [sp, #20]
 802ca52:	f503 73b0 	add.w	r3, r3, #352	; 0x160
 802ca56:	eb0d 0003 	add.w	r0, sp, r3
 802ca5a:	9b01      	ldr	r3, [sp, #4]
 802ca5c:	18f4      	adds	r4, r6, r3
 802ca5e:	ab1c      	add	r3, sp, #112	; 0x70
 802ca60:	1c77      	adds	r7, r6, #1
 802ca62:	384c      	subs	r0, #76	; 0x4c
 802ca64:	eb03 0484 	add.w	r4, r3, r4, lsl #2
 802ca68:	4466      	add	r6, ip
 802ca6a:	42be      	cmp	r6, r7
 802ca6c:	f6ff af0b 	blt.w	802c886 <__kernel_rem_pio2f+0xca>
 802ca70:	f85b 3027 	ldr.w	r3, [fp, r7, lsl #2]
 802ca74:	f8dd e008 	ldr.w	lr, [sp, #8]
 802ca78:	ee07 3a90 	vmov	s15, r3
 802ca7c:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 802ca80:	f04f 0c00 	mov.w	ip, #0
 802ca84:	ece4 7a01 	vstmia	r4!, {s15}
 802ca88:	eddf 7a0f 	vldr	s15, [pc, #60]	; 802cac8 <__kernel_rem_pio2f+0x30c>
 802ca8c:	46a1      	mov	r9, r4
 802ca8e:	458c      	cmp	ip, r1
 802ca90:	dd07      	ble.n	802caa2 <__kernel_rem_pio2f+0x2e6>
 802ca92:	ece0 7a01 	vstmia	r0!, {s15}
 802ca96:	3701      	adds	r7, #1
 802ca98:	e7e7      	b.n	802ca6a <__kernel_rem_pio2f+0x2ae>
 802ca9a:	9804      	ldr	r0, [sp, #16]
 802ca9c:	f04f 0c01 	mov.w	ip, #1
 802caa0:	e7d2      	b.n	802ca48 <__kernel_rem_pio2f+0x28c>
 802caa2:	ecfe 6a01 	vldmia	lr!, {s13}
 802caa6:	ed39 7a01 	vldmdb	r9!, {s14}
 802caaa:	f10c 0c01 	add.w	ip, ip, #1
 802caae:	eee6 7a87 	vfma.f32	s15, s13, s14
 802cab2:	e7ec      	b.n	802ca8e <__kernel_rem_pio2f+0x2d2>
 802cab4:	3c01      	subs	r4, #1
 802cab6:	e775      	b.n	802c9a4 <__kernel_rem_pio2f+0x1e8>
 802cab8:	080581c0 	.word	0x080581c0
 802cabc:	08058194 	.word	0x08058194
 802cac0:	43800000 	.word	0x43800000
 802cac4:	3b800000 	.word	0x3b800000
 802cac8:	00000000 	.word	0x00000000
 802cacc:	9b03      	ldr	r3, [sp, #12]
 802cace:	eeb0 0a48 	vmov.f32	s0, s16
 802cad2:	1a98      	subs	r0, r3, r2
 802cad4:	f000 fb84 	bl	802d1e0 <scalbnf>
 802cad8:	ed1f 7a07 	vldr	s14, [pc, #-28]	; 802cac0 <__kernel_rem_pio2f+0x304>
 802cadc:	eeb4 0ac7 	vcmpe.f32	s0, s14
 802cae0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802cae4:	db19      	blt.n	802cb1a <__kernel_rem_pio2f+0x35e>
 802cae6:	ed5f 7a09 	vldr	s15, [pc, #-36]	; 802cac4 <__kernel_rem_pio2f+0x308>
 802caea:	ee60 7a27 	vmul.f32	s15, s0, s15
 802caee:	aa08      	add	r2, sp, #32
 802caf0:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 802caf4:	1c74      	adds	r4, r6, #1
 802caf6:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 802cafa:	3508      	adds	r5, #8
 802cafc:	eea7 0ac7 	vfms.f32	s0, s15, s14
 802cb00:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 802cb04:	eebd 0ac0 	vcvt.s32.f32	s0, s0
 802cb08:	ee10 3a10 	vmov	r3, s0
 802cb0c:	f842 3026 	str.w	r3, [r2, r6, lsl #2]
 802cb10:	ee17 3a90 	vmov	r3, s15
 802cb14:	f842 3024 	str.w	r3, [r2, r4, lsl #2]
 802cb18:	e74b      	b.n	802c9b2 <__kernel_rem_pio2f+0x1f6>
 802cb1a:	eebd 0ac0 	vcvt.s32.f32	s0, s0
 802cb1e:	aa08      	add	r2, sp, #32
 802cb20:	ee10 3a10 	vmov	r3, s0
 802cb24:	4634      	mov	r4, r6
 802cb26:	f842 3026 	str.w	r3, [r2, r6, lsl #2]
 802cb2a:	e742      	b.n	802c9b2 <__kernel_rem_pio2f+0x1f6>
 802cb2c:	a808      	add	r0, sp, #32
 802cb2e:	f850 0022 	ldr.w	r0, [r0, r2, lsl #2]
 802cb32:	9001      	str	r0, [sp, #4]
 802cb34:	ee07 0a90 	vmov	s15, r0
 802cb38:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 802cb3c:	3a01      	subs	r2, #1
 802cb3e:	ee67 7a80 	vmul.f32	s15, s15, s0
 802cb42:	ee20 0a07 	vmul.f32	s0, s0, s14
 802cb46:	ed61 7a01 	vstmdb	r1!, {s15}
 802cb4a:	e73e      	b.n	802c9ca <__kernel_rem_pio2f+0x20e>
 802cb4c:	ecfc 6a01 	vldmia	ip!, {s13}
 802cb50:	ecb6 7a01 	vldmia	r6!, {s14}
 802cb54:	eee6 7a87 	vfma.f32	s15, s13, s14
 802cb58:	3001      	adds	r0, #1
 802cb5a:	4550      	cmp	r0, sl
 802cb5c:	dc01      	bgt.n	802cb62 <__kernel_rem_pio2f+0x3a6>
 802cb5e:	4288      	cmp	r0, r1
 802cb60:	ddf4      	ble.n	802cb4c <__kernel_rem_pio2f+0x390>
 802cb62:	a858      	add	r0, sp, #352	; 0x160
 802cb64:	eb00 0181 	add.w	r1, r0, r1, lsl #2
 802cb68:	ed41 7a28 	vstr	s15, [r1, #-160]	; 0xffffff60
 802cb6c:	3a01      	subs	r2, #1
 802cb6e:	e730      	b.n	802c9d2 <__kernel_rem_pio2f+0x216>
 802cb70:	9a66      	ldr	r2, [sp, #408]	; 0x198
 802cb72:	2a02      	cmp	r2, #2
 802cb74:	dc09      	bgt.n	802cb8a <__kernel_rem_pio2f+0x3ce>
 802cb76:	2a00      	cmp	r2, #0
 802cb78:	dc2a      	bgt.n	802cbd0 <__kernel_rem_pio2f+0x414>
 802cb7a:	d043      	beq.n	802cc04 <__kernel_rem_pio2f+0x448>
 802cb7c:	f009 0007 	and.w	r0, r9, #7
 802cb80:	b059      	add	sp, #356	; 0x164
 802cb82:	ecbd 8b04 	vpop	{d8-d9}
 802cb86:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 802cb8a:	9b66      	ldr	r3, [sp, #408]	; 0x198
 802cb8c:	2b03      	cmp	r3, #3
 802cb8e:	d1f5      	bne.n	802cb7c <__kernel_rem_pio2f+0x3c0>
 802cb90:	ab30      	add	r3, sp, #192	; 0xc0
 802cb92:	442b      	add	r3, r5
 802cb94:	461a      	mov	r2, r3
 802cb96:	4619      	mov	r1, r3
 802cb98:	4620      	mov	r0, r4
 802cb9a:	2800      	cmp	r0, #0
 802cb9c:	f1a1 0104 	sub.w	r1, r1, #4
 802cba0:	dc51      	bgt.n	802cc46 <__kernel_rem_pio2f+0x48a>
 802cba2:	4621      	mov	r1, r4
 802cba4:	2901      	cmp	r1, #1
 802cba6:	f1a2 0204 	sub.w	r2, r2, #4
 802cbaa:	dc5c      	bgt.n	802cc66 <__kernel_rem_pio2f+0x4aa>
 802cbac:	ed5f 7a3a 	vldr	s15, [pc, #-232]	; 802cac8 <__kernel_rem_pio2f+0x30c>
 802cbb0:	3304      	adds	r3, #4
 802cbb2:	2c01      	cmp	r4, #1
 802cbb4:	dc67      	bgt.n	802cc86 <__kernel_rem_pio2f+0x4ca>
 802cbb6:	eddd 6a30 	vldr	s13, [sp, #192]	; 0xc0
 802cbba:	ed9d 7a31 	vldr	s14, [sp, #196]	; 0xc4
 802cbbe:	2f00      	cmp	r7, #0
 802cbc0:	d167      	bne.n	802cc92 <__kernel_rem_pio2f+0x4d6>
 802cbc2:	edc8 6a00 	vstr	s13, [r8]
 802cbc6:	ed88 7a01 	vstr	s14, [r8, #4]
 802cbca:	edc8 7a02 	vstr	s15, [r8, #8]
 802cbce:	e7d5      	b.n	802cb7c <__kernel_rem_pio2f+0x3c0>
 802cbd0:	aa30      	add	r2, sp, #192	; 0xc0
 802cbd2:	ed1f 7a43 	vldr	s14, [pc, #-268]	; 802cac8 <__kernel_rem_pio2f+0x30c>
 802cbd6:	4413      	add	r3, r2
 802cbd8:	4622      	mov	r2, r4
 802cbda:	2a00      	cmp	r2, #0
 802cbdc:	da24      	bge.n	802cc28 <__kernel_rem_pio2f+0x46c>
 802cbde:	b34f      	cbz	r7, 802cc34 <__kernel_rem_pio2f+0x478>
 802cbe0:	eef1 7a47 	vneg.f32	s15, s14
 802cbe4:	edc8 7a00 	vstr	s15, [r8]
 802cbe8:	eddd 7a30 	vldr	s15, [sp, #192]	; 0xc0
 802cbec:	ee77 7ac7 	vsub.f32	s15, s15, s14
 802cbf0:	aa31      	add	r2, sp, #196	; 0xc4
 802cbf2:	2301      	movs	r3, #1
 802cbf4:	429c      	cmp	r4, r3
 802cbf6:	da20      	bge.n	802cc3a <__kernel_rem_pio2f+0x47e>
 802cbf8:	b10f      	cbz	r7, 802cbfe <__kernel_rem_pio2f+0x442>
 802cbfa:	eef1 7a67 	vneg.f32	s15, s15
 802cbfe:	edc8 7a01 	vstr	s15, [r8, #4]
 802cc02:	e7bb      	b.n	802cb7c <__kernel_rem_pio2f+0x3c0>
 802cc04:	aa30      	add	r2, sp, #192	; 0xc0
 802cc06:	ed5f 7a50 	vldr	s15, [pc, #-320]	; 802cac8 <__kernel_rem_pio2f+0x30c>
 802cc0a:	4413      	add	r3, r2
 802cc0c:	2c00      	cmp	r4, #0
 802cc0e:	da05      	bge.n	802cc1c <__kernel_rem_pio2f+0x460>
 802cc10:	b10f      	cbz	r7, 802cc16 <__kernel_rem_pio2f+0x45a>
 802cc12:	eef1 7a67 	vneg.f32	s15, s15
 802cc16:	edc8 7a00 	vstr	s15, [r8]
 802cc1a:	e7af      	b.n	802cb7c <__kernel_rem_pio2f+0x3c0>
 802cc1c:	ed33 7a01 	vldmdb	r3!, {s14}
 802cc20:	3c01      	subs	r4, #1
 802cc22:	ee77 7a87 	vadd.f32	s15, s15, s14
 802cc26:	e7f1      	b.n	802cc0c <__kernel_rem_pio2f+0x450>
 802cc28:	ed73 7a01 	vldmdb	r3!, {s15}
 802cc2c:	3a01      	subs	r2, #1
 802cc2e:	ee37 7a27 	vadd.f32	s14, s14, s15
 802cc32:	e7d2      	b.n	802cbda <__kernel_rem_pio2f+0x41e>
 802cc34:	eef0 7a47 	vmov.f32	s15, s14
 802cc38:	e7d4      	b.n	802cbe4 <__kernel_rem_pio2f+0x428>
 802cc3a:	ecb2 7a01 	vldmia	r2!, {s14}
 802cc3e:	3301      	adds	r3, #1
 802cc40:	ee77 7a87 	vadd.f32	s15, s15, s14
 802cc44:	e7d6      	b.n	802cbf4 <__kernel_rem_pio2f+0x438>
 802cc46:	edd1 7a00 	vldr	s15, [r1]
 802cc4a:	edd1 6a01 	vldr	s13, [r1, #4]
 802cc4e:	ee37 7aa6 	vadd.f32	s14, s15, s13
 802cc52:	3801      	subs	r0, #1
 802cc54:	ee77 7ac7 	vsub.f32	s15, s15, s14
 802cc58:	ed81 7a00 	vstr	s14, [r1]
 802cc5c:	ee77 7aa6 	vadd.f32	s15, s15, s13
 802cc60:	edc1 7a01 	vstr	s15, [r1, #4]
 802cc64:	e799      	b.n	802cb9a <__kernel_rem_pio2f+0x3de>
 802cc66:	edd2 7a00 	vldr	s15, [r2]
 802cc6a:	edd2 6a01 	vldr	s13, [r2, #4]
 802cc6e:	ee37 7aa6 	vadd.f32	s14, s15, s13
 802cc72:	3901      	subs	r1, #1
 802cc74:	ee77 7ac7 	vsub.f32	s15, s15, s14
 802cc78:	ed82 7a00 	vstr	s14, [r2]
 802cc7c:	ee77 7aa6 	vadd.f32	s15, s15, s13
 802cc80:	edc2 7a01 	vstr	s15, [r2, #4]
 802cc84:	e78e      	b.n	802cba4 <__kernel_rem_pio2f+0x3e8>
 802cc86:	ed33 7a01 	vldmdb	r3!, {s14}
 802cc8a:	3c01      	subs	r4, #1
 802cc8c:	ee77 7a87 	vadd.f32	s15, s15, s14
 802cc90:	e78f      	b.n	802cbb2 <__kernel_rem_pio2f+0x3f6>
 802cc92:	eef1 6a66 	vneg.f32	s13, s13
 802cc96:	eeb1 7a47 	vneg.f32	s14, s14
 802cc9a:	edc8 6a00 	vstr	s13, [r8]
 802cc9e:	ed88 7a01 	vstr	s14, [r8, #4]
 802cca2:	eef1 7a67 	vneg.f32	s15, s15
 802cca6:	e790      	b.n	802cbca <__kernel_rem_pio2f+0x40e>

0802cca8 <__kernel_sinf>:
 802cca8:	ee10 3a10 	vmov	r3, s0
 802ccac:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
 802ccb0:	f1b3 5f48 	cmp.w	r3, #838860800	; 0x32000000
 802ccb4:	da04      	bge.n	802ccc0 <__kernel_sinf+0x18>
 802ccb6:	eefd 7ac0 	vcvt.s32.f32	s15, s0
 802ccba:	ee17 3a90 	vmov	r3, s15
 802ccbe:	b35b      	cbz	r3, 802cd18 <__kernel_sinf+0x70>
 802ccc0:	ee20 7a00 	vmul.f32	s14, s0, s0
 802ccc4:	eddf 7a15 	vldr	s15, [pc, #84]	; 802cd1c <__kernel_sinf+0x74>
 802ccc8:	ed9f 6a15 	vldr	s12, [pc, #84]	; 802cd20 <__kernel_sinf+0x78>
 802cccc:	eea7 6a27 	vfma.f32	s12, s14, s15
 802ccd0:	eddf 7a14 	vldr	s15, [pc, #80]	; 802cd24 <__kernel_sinf+0x7c>
 802ccd4:	eee6 7a07 	vfma.f32	s15, s12, s14
 802ccd8:	ed9f 6a13 	vldr	s12, [pc, #76]	; 802cd28 <__kernel_sinf+0x80>
 802ccdc:	eea7 6a87 	vfma.f32	s12, s15, s14
 802cce0:	eddf 7a12 	vldr	s15, [pc, #72]	; 802cd2c <__kernel_sinf+0x84>
 802cce4:	ee60 6a07 	vmul.f32	s13, s0, s14
 802cce8:	eee6 7a07 	vfma.f32	s15, s12, s14
 802ccec:	b930      	cbnz	r0, 802ccfc <__kernel_sinf+0x54>
 802ccee:	ed9f 6a10 	vldr	s12, [pc, #64]	; 802cd30 <__kernel_sinf+0x88>
 802ccf2:	eea7 6a27 	vfma.f32	s12, s14, s15
 802ccf6:	eea6 0a26 	vfma.f32	s0, s12, s13
 802ccfa:	4770      	bx	lr
 802ccfc:	ee67 7ae6 	vnmul.f32	s15, s15, s13
 802cd00:	eeb6 6a00 	vmov.f32	s12, #96	; 0x3f000000  0.5
 802cd04:	eee0 7a86 	vfma.f32	s15, s1, s12
 802cd08:	eed7 0a87 	vfnms.f32	s1, s15, s14
 802cd0c:	eddf 7a09 	vldr	s15, [pc, #36]	; 802cd34 <__kernel_sinf+0x8c>
 802cd10:	eee6 0aa7 	vfma.f32	s1, s13, s15
 802cd14:	ee30 0a60 	vsub.f32	s0, s0, s1
 802cd18:	4770      	bx	lr
 802cd1a:	bf00      	nop
 802cd1c:	2f2ec9d3 	.word	0x2f2ec9d3
 802cd20:	b2d72f34 	.word	0xb2d72f34
 802cd24:	3638ef1b 	.word	0x3638ef1b
 802cd28:	b9500d01 	.word	0xb9500d01
 802cd2c:	3c088889 	.word	0x3c088889
 802cd30:	be2aaaab 	.word	0xbe2aaaab
 802cd34:	3e2aaaab 	.word	0x3e2aaaab

0802cd38 <__kernel_tanf>:
 802cd38:	b508      	push	{r3, lr}
 802cd3a:	ee10 3a10 	vmov	r3, s0
 802cd3e:	f023 4200 	bic.w	r2, r3, #2147483648	; 0x80000000
 802cd42:	f1b2 5f46 	cmp.w	r2, #830472192	; 0x31800000
 802cd46:	eef0 7a40 	vmov.f32	s15, s0
 802cd4a:	da17      	bge.n	802cd7c <__kernel_tanf+0x44>
 802cd4c:	eebd 7ac0 	vcvt.s32.f32	s14, s0
 802cd50:	ee17 1a10 	vmov	r1, s14
 802cd54:	bb41      	cbnz	r1, 802cda8 <__kernel_tanf+0x70>
 802cd56:	1c43      	adds	r3, r0, #1
 802cd58:	4313      	orrs	r3, r2
 802cd5a:	d108      	bne.n	802cd6e <__kernel_tanf+0x36>
 802cd5c:	f7fd fe8e 	bl	802aa7c <fabsf>
 802cd60:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
 802cd64:	eec7 7a00 	vdiv.f32	s15, s14, s0
 802cd68:	eeb0 0a67 	vmov.f32	s0, s15
 802cd6c:	bd08      	pop	{r3, pc}
 802cd6e:	2801      	cmp	r0, #1
 802cd70:	d0fa      	beq.n	802cd68 <__kernel_tanf+0x30>
 802cd72:	eebf 7a00 	vmov.f32	s14, #240	; 0xbf800000 -1.0
 802cd76:	eec7 7a00 	vdiv.f32	s15, s14, s0
 802cd7a:	e7f5      	b.n	802cd68 <__kernel_tanf+0x30>
 802cd7c:	494c      	ldr	r1, [pc, #304]	; (802ceb0 <__kernel_tanf+0x178>)
 802cd7e:	428a      	cmp	r2, r1
 802cd80:	db12      	blt.n	802cda8 <__kernel_tanf+0x70>
 802cd82:	2b00      	cmp	r3, #0
 802cd84:	bfb8      	it	lt
 802cd86:	eef1 7a40 	vneglt.f32	s15, s0
 802cd8a:	ed9f 0a4a 	vldr	s0, [pc, #296]	; 802ceb4 <__kernel_tanf+0x17c>
 802cd8e:	ee70 7a67 	vsub.f32	s15, s0, s15
 802cd92:	ed9f 0a49 	vldr	s0, [pc, #292]	; 802ceb8 <__kernel_tanf+0x180>
 802cd96:	bfb8      	it	lt
 802cd98:	eef1 0a60 	vneglt.f32	s1, s1
 802cd9c:	ee70 0a60 	vsub.f32	s1, s0, s1
 802cda0:	ee70 7aa7 	vadd.f32	s15, s1, s15
 802cda4:	eddf 0a45 	vldr	s1, [pc, #276]	; 802cebc <__kernel_tanf+0x184>
 802cda8:	eddf 5a45 	vldr	s11, [pc, #276]	; 802cec0 <__kernel_tanf+0x188>
 802cdac:	ed9f 6a45 	vldr	s12, [pc, #276]	; 802cec4 <__kernel_tanf+0x18c>
 802cdb0:	ed9f 5a45 	vldr	s10, [pc, #276]	; 802cec8 <__kernel_tanf+0x190>
 802cdb4:	493e      	ldr	r1, [pc, #248]	; (802ceb0 <__kernel_tanf+0x178>)
 802cdb6:	ee67 6aa7 	vmul.f32	s13, s15, s15
 802cdba:	428a      	cmp	r2, r1
 802cdbc:	ee26 7aa6 	vmul.f32	s14, s13, s13
 802cdc0:	eea7 6a25 	vfma.f32	s12, s14, s11
 802cdc4:	eddf 5a41 	vldr	s11, [pc, #260]	; 802cecc <__kernel_tanf+0x194>
 802cdc8:	eee6 5a07 	vfma.f32	s11, s12, s14
 802cdcc:	ed9f 6a40 	vldr	s12, [pc, #256]	; 802ced0 <__kernel_tanf+0x198>
 802cdd0:	eea5 6a87 	vfma.f32	s12, s11, s14
 802cdd4:	eddf 5a3f 	vldr	s11, [pc, #252]	; 802ced4 <__kernel_tanf+0x19c>
 802cdd8:	eee6 5a07 	vfma.f32	s11, s12, s14
 802cddc:	ed9f 6a3e 	vldr	s12, [pc, #248]	; 802ced8 <__kernel_tanf+0x1a0>
 802cde0:	eea5 6a87 	vfma.f32	s12, s11, s14
 802cde4:	eddf 5a3d 	vldr	s11, [pc, #244]	; 802cedc <__kernel_tanf+0x1a4>
 802cde8:	eee7 5a05 	vfma.f32	s11, s14, s10
 802cdec:	ed9f 5a3c 	vldr	s10, [pc, #240]	; 802cee0 <__kernel_tanf+0x1a8>
 802cdf0:	eea5 5a87 	vfma.f32	s10, s11, s14
 802cdf4:	eddf 5a3b 	vldr	s11, [pc, #236]	; 802cee4 <__kernel_tanf+0x1ac>
 802cdf8:	eee5 5a07 	vfma.f32	s11, s10, s14
 802cdfc:	ed9f 5a3a 	vldr	s10, [pc, #232]	; 802cee8 <__kernel_tanf+0x1b0>
 802ce00:	eea5 5a87 	vfma.f32	s10, s11, s14
 802ce04:	eddf 5a39 	vldr	s11, [pc, #228]	; 802ceec <__kernel_tanf+0x1b4>
 802ce08:	eee5 5a07 	vfma.f32	s11, s10, s14
 802ce0c:	eeb0 7a46 	vmov.f32	s14, s12
 802ce10:	eea5 7aa6 	vfma.f32	s14, s11, s13
 802ce14:	ee27 5aa6 	vmul.f32	s10, s15, s13
 802ce18:	eeb0 6a60 	vmov.f32	s12, s1
 802ce1c:	eea7 6a05 	vfma.f32	s12, s14, s10
 802ce20:	ed9f 7a33 	vldr	s14, [pc, #204]	; 802cef0 <__kernel_tanf+0x1b8>
 802ce24:	eee6 0a26 	vfma.f32	s1, s12, s13
 802ce28:	eee5 0a07 	vfma.f32	s1, s10, s14
 802ce2c:	ee37 7aa0 	vadd.f32	s14, s15, s1
 802ce30:	db1d      	blt.n	802ce6e <__kernel_tanf+0x136>
 802ce32:	ee06 0a90 	vmov	s13, r0
 802ce36:	eeb8 0ae6 	vcvt.f32.s32	s0, s13
 802ce3a:	ee27 6a07 	vmul.f32	s12, s14, s14
 802ce3e:	ee37 7a00 	vadd.f32	s14, s14, s0
 802ce42:	179b      	asrs	r3, r3, #30
 802ce44:	eec6 6a07 	vdiv.f32	s13, s12, s14
 802ce48:	f003 0302 	and.w	r3, r3, #2
 802ce4c:	f1c3 0301 	rsb	r3, r3, #1
 802ce50:	eeb0 7a00 	vmov.f32	s14, #0	; 0x40000000  2.0
 802ce54:	ee76 0ae0 	vsub.f32	s1, s13, s1
 802ce58:	ee77 7ae0 	vsub.f32	s15, s15, s1
 802ce5c:	eea7 0ac7 	vfms.f32	s0, s15, s14
 802ce60:	ee07 3a90 	vmov	s15, r3
 802ce64:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 802ce68:	ee67 7a80 	vmul.f32	s15, s15, s0
 802ce6c:	e77c      	b.n	802cd68 <__kernel_tanf+0x30>
 802ce6e:	2801      	cmp	r0, #1
 802ce70:	d01b      	beq.n	802ceaa <__kernel_tanf+0x172>
 802ce72:	4b20      	ldr	r3, [pc, #128]	; (802cef4 <__kernel_tanf+0x1bc>)
 802ce74:	ee17 2a10 	vmov	r2, s14
 802ce78:	401a      	ands	r2, r3
 802ce7a:	ee06 2a10 	vmov	s12, r2
 802ce7e:	ee76 7a67 	vsub.f32	s15, s12, s15
 802ce82:	ee70 0ae7 	vsub.f32	s1, s1, s15
 802ce86:	eeff 7a00 	vmov.f32	s15, #240	; 0xbf800000 -1.0
 802ce8a:	eec7 6a87 	vdiv.f32	s13, s15, s14
 802ce8e:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
 802ce92:	ee16 2a90 	vmov	r2, s13
 802ce96:	4013      	ands	r3, r2
 802ce98:	ee07 3a90 	vmov	s15, r3
 802ce9c:	eea6 7a27 	vfma.f32	s14, s12, s15
 802cea0:	eea0 7aa7 	vfma.f32	s14, s1, s15
 802cea4:	eee7 7a26 	vfma.f32	s15, s14, s13
 802cea8:	e75e      	b.n	802cd68 <__kernel_tanf+0x30>
 802ceaa:	eef0 7a47 	vmov.f32	s15, s14
 802ceae:	e75b      	b.n	802cd68 <__kernel_tanf+0x30>
 802ceb0:	3f2ca140 	.word	0x3f2ca140
 802ceb4:	3f490fda 	.word	0x3f490fda
 802ceb8:	33222168 	.word	0x33222168
 802cebc:	00000000 	.word	0x00000000
 802cec0:	b79bae5f 	.word	0xb79bae5f
 802cec4:	38a3f445 	.word	0x38a3f445
 802cec8:	37d95384 	.word	0x37d95384
 802cecc:	3a1a26c8 	.word	0x3a1a26c8
 802ced0:	3b6b6916 	.word	0x3b6b6916
 802ced4:	3cb327a4 	.word	0x3cb327a4
 802ced8:	3e088889 	.word	0x3e088889
 802cedc:	3895c07a 	.word	0x3895c07a
 802cee0:	398137b9 	.word	0x398137b9
 802cee4:	3abede48 	.word	0x3abede48
 802cee8:	3c11371f 	.word	0x3c11371f
 802ceec:	3d5d0dd1 	.word	0x3d5d0dd1
 802cef0:	3eaaaaab 	.word	0x3eaaaaab
 802cef4:	fffff000 	.word	0xfffff000

0802cef8 <with_errnof>:
 802cef8:	b513      	push	{r0, r1, r4, lr}
 802cefa:	4604      	mov	r4, r0
 802cefc:	ed8d 0a01 	vstr	s0, [sp, #4]
 802cf00:	f7fa f8fa 	bl	80270f8 <__errno>
 802cf04:	ed9d 0a01 	vldr	s0, [sp, #4]
 802cf08:	6004      	str	r4, [r0, #0]
 802cf0a:	b002      	add	sp, #8
 802cf0c:	bd10      	pop	{r4, pc}

0802cf0e <xflowf>:
 802cf0e:	b130      	cbz	r0, 802cf1e <xflowf+0x10>
 802cf10:	eef1 7a40 	vneg.f32	s15, s0
 802cf14:	ee27 0a80 	vmul.f32	s0, s15, s0
 802cf18:	2022      	movs	r0, #34	; 0x22
 802cf1a:	f7ff bfed 	b.w	802cef8 <with_errnof>
 802cf1e:	eef0 7a40 	vmov.f32	s15, s0
 802cf22:	e7f7      	b.n	802cf14 <xflowf+0x6>

0802cf24 <__math_uflowf>:
 802cf24:	ed9f 0a01 	vldr	s0, [pc, #4]	; 802cf2c <__math_uflowf+0x8>
 802cf28:	f7ff bff1 	b.w	802cf0e <xflowf>
 802cf2c:	10000000 	.word	0x10000000

0802cf30 <__math_oflowf>:
 802cf30:	ed9f 0a01 	vldr	s0, [pc, #4]	; 802cf38 <__math_oflowf+0x8>
 802cf34:	f7ff bfeb 	b.w	802cf0e <xflowf>
 802cf38:	70000000 	.word	0x70000000

0802cf3c <__math_divzerof>:
 802cf3c:	2800      	cmp	r0, #0
 802cf3e:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
 802cf42:	eeff 7a00 	vmov.f32	s15, #240	; 0xbf800000 -1.0
 802cf46:	bf08      	it	eq
 802cf48:	eef0 7a40 	vmoveq.f32	s15, s0
 802cf4c:	ed9f 0a03 	vldr	s0, [pc, #12]	; 802cf5c <__math_divzerof+0x20>
 802cf50:	2022      	movs	r0, #34	; 0x22
 802cf52:	ee87 0a80 	vdiv.f32	s0, s15, s0
 802cf56:	f7ff bfcf 	b.w	802cef8 <with_errnof>
 802cf5a:	bf00      	nop
 802cf5c:	00000000 	.word	0x00000000

0802cf60 <__math_invalidf>:
 802cf60:	eef0 7a40 	vmov.f32	s15, s0
 802cf64:	ee30 7a40 	vsub.f32	s14, s0, s0
 802cf68:	eef4 7a67 	vcmp.f32	s15, s15
 802cf6c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802cf70:	ee87 0a07 	vdiv.f32	s0, s14, s14
 802cf74:	d602      	bvs.n	802cf7c <__math_invalidf+0x1c>
 802cf76:	2021      	movs	r0, #33	; 0x21
 802cf78:	f7ff bfbe 	b.w	802cef8 <with_errnof>
 802cf7c:	4770      	bx	lr
	...

0802cf80 <expm1f>:
 802cf80:	ee10 2a10 	vmov	r2, s0
 802cf84:	497d      	ldr	r1, [pc, #500]	; (802d17c <expm1f+0x1fc>)
 802cf86:	f022 4300 	bic.w	r3, r2, #2147483648	; 0x80000000
 802cf8a:	428b      	cmp	r3, r1
 802cf8c:	d921      	bls.n	802cfd2 <expm1f+0x52>
 802cf8e:	f1b3 4fff 	cmp.w	r3, #2139095040	; 0x7f800000
 802cf92:	d902      	bls.n	802cf9a <expm1f+0x1a>
 802cf94:	ee30 0a00 	vadd.f32	s0, s0, s0
 802cf98:	4770      	bx	lr
 802cf9a:	d106      	bne.n	802cfaa <expm1f+0x2a>
 802cf9c:	2a00      	cmp	r2, #0
 802cf9e:	eeff 7a00 	vmov.f32	s15, #240	; 0xbf800000 -1.0
 802cfa2:	bfb8      	it	lt
 802cfa4:	eeb0 0a67 	vmovlt.f32	s0, s15
 802cfa8:	4770      	bx	lr
 802cfaa:	2a00      	cmp	r2, #0
 802cfac:	db05      	blt.n	802cfba <expm1f+0x3a>
 802cfae:	4974      	ldr	r1, [pc, #464]	; (802d180 <expm1f+0x200>)
 802cfb0:	428b      	cmp	r3, r1
 802cfb2:	d95c      	bls.n	802d06e <expm1f+0xee>
 802cfb4:	2000      	movs	r0, #0
 802cfb6:	f7ff bfbb 	b.w	802cf30 <__math_oflowf>
 802cfba:	eddf 7a72 	vldr	s15, [pc, #456]	; 802d184 <expm1f+0x204>
 802cfbe:	ee70 7a27 	vadd.f32	s15, s0, s15
 802cfc2:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 802cfc6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802cfca:	d550      	bpl.n	802d06e <expm1f+0xee>
 802cfcc:	eebf 0a00 	vmov.f32	s0, #240	; 0xbf800000 -1.0
 802cfd0:	4770      	bx	lr
 802cfd2:	496d      	ldr	r1, [pc, #436]	; (802d188 <expm1f+0x208>)
 802cfd4:	428b      	cmp	r3, r1
 802cfd6:	d967      	bls.n	802d0a8 <expm1f+0x128>
 802cfd8:	496c      	ldr	r1, [pc, #432]	; (802d18c <expm1f+0x20c>)
 802cfda:	428b      	cmp	r3, r1
 802cfdc:	d847      	bhi.n	802d06e <expm1f+0xee>
 802cfde:	ed9f 7a6c 	vldr	s14, [pc, #432]	; 802d190 <expm1f+0x210>
 802cfe2:	2a00      	cmp	r2, #0
 802cfe4:	bfa7      	ittee	ge
 802cfe6:	ee30 7a47 	vsubge.f32	s14, s0, s14
 802cfea:	eddf 7a6a 	vldrge	s15, [pc, #424]	; 802d194 <expm1f+0x214>
 802cfee:	eddf 7a6a 	vldrlt	s15, [pc, #424]	; 802d198 <expm1f+0x218>
 802cff2:	ee30 7a07 	vaddlt.f32	s14, s0, s14
 802cff6:	bfac      	ite	ge
 802cff8:	2301      	movge	r3, #1
 802cffa:	f04f 33ff 	movlt.w	r3, #4294967295
 802cffe:	ee37 0a67 	vsub.f32	s0, s14, s15
 802d002:	ee37 7a40 	vsub.f32	s14, s14, s0
 802d006:	ee77 7a67 	vsub.f32	s15, s14, s15
 802d00a:	eef6 5a00 	vmov.f32	s11, #96	; 0x3f000000  0.5
 802d00e:	ee20 4a25 	vmul.f32	s8, s0, s11
 802d012:	ed9f 6a62 	vldr	s12, [pc, #392]	; 802d19c <expm1f+0x21c>
 802d016:	eddf 6a62 	vldr	s13, [pc, #392]	; 802d1a0 <expm1f+0x220>
 802d01a:	ed9f 5a62 	vldr	s10, [pc, #392]	; 802d1a4 <expm1f+0x224>
 802d01e:	ee20 7a04 	vmul.f32	s14, s0, s8
 802d022:	eef0 4a08 	vmov.f32	s9, #8	; 0x40400000  3.0
 802d026:	eee7 6a06 	vfma.f32	s13, s14, s12
 802d02a:	ed9f 6a5f 	vldr	s12, [pc, #380]	; 802d1a8 <expm1f+0x228>
 802d02e:	eea6 6a87 	vfma.f32	s12, s13, s14
 802d032:	eddf 6a5e 	vldr	s13, [pc, #376]	; 802d1ac <expm1f+0x22c>
 802d036:	eee6 6a07 	vfma.f32	s13, s12, s14
 802d03a:	eeb7 6a00 	vmov.f32	s12, #112	; 0x3f800000  1.0
 802d03e:	eea6 5a87 	vfma.f32	s10, s13, s14
 802d042:	eef0 6a46 	vmov.f32	s13, s12
 802d046:	eee5 6a07 	vfma.f32	s13, s10, s14
 802d04a:	eee4 4a66 	vfms.f32	s9, s8, s13
 802d04e:	eeb1 4a08 	vmov.f32	s8, #24	; 0x40c00000  6.0
 802d052:	eea0 4a64 	vfms.f32	s8, s0, s9
 802d056:	ee36 5ae4 	vsub.f32	s10, s13, s9
 802d05a:	eec5 6a04 	vdiv.f32	s13, s10, s8
 802d05e:	ee66 6a87 	vmul.f32	s13, s13, s14
 802d062:	bb7b      	cbnz	r3, 802d0c4 <expm1f+0x144>
 802d064:	eef0 7a47 	vmov.f32	s15, s14
 802d068:	eed0 7a26 	vfnms.f32	s15, s0, s13
 802d06c:	e025      	b.n	802d0ba <expm1f+0x13a>
 802d06e:	eebe 7a00 	vmov.f32	s14, #224	; 0xbf000000 -0.5
 802d072:	2a00      	cmp	r2, #0
 802d074:	eef6 7a00 	vmov.f32	s15, #96	; 0x3f000000  0.5
 802d078:	bfb8      	it	lt
 802d07a:	eef0 7a47 	vmovlt.f32	s15, s14
 802d07e:	ed9f 7a4c 	vldr	s14, [pc, #304]	; 802d1b0 <expm1f+0x230>
 802d082:	eddf 6a43 	vldr	s13, [pc, #268]	; 802d190 <expm1f+0x210>
 802d086:	ee40 7a07 	vmla.f32	s15, s0, s14
 802d08a:	eeb0 7a40 	vmov.f32	s14, s0
 802d08e:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 802d092:	ee17 3a90 	vmov	r3, s15
 802d096:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 802d09a:	eea7 7ae6 	vfms.f32	s14, s15, s13
 802d09e:	eddf 6a3d 	vldr	s13, [pc, #244]	; 802d194 <expm1f+0x214>
 802d0a2:	ee67 7aa6 	vmul.f32	s15, s15, s13
 802d0a6:	e7aa      	b.n	802cffe <expm1f+0x7e>
 802d0a8:	f1b3 5f4c 	cmp.w	r3, #855638016	; 0x33000000
 802d0ac:	d208      	bcs.n	802d0c0 <expm1f+0x140>
 802d0ae:	eddf 7a41 	vldr	s15, [pc, #260]	; 802d1b4 <expm1f+0x234>
 802d0b2:	ee70 7a27 	vadd.f32	s15, s0, s15
 802d0b6:	ee77 7ae7 	vsub.f32	s15, s15, s15
 802d0ba:	ee30 0a67 	vsub.f32	s0, s0, s15
 802d0be:	4770      	bx	lr
 802d0c0:	2300      	movs	r3, #0
 802d0c2:	e7a2      	b.n	802d00a <expm1f+0x8a>
 802d0c4:	ee76 6ae7 	vsub.f32	s13, s13, s15
 802d0c8:	1c5a      	adds	r2, r3, #1
 802d0ca:	eed6 7a80 	vfnms.f32	s15, s13, s0
 802d0ce:	ee77 7ac7 	vsub.f32	s15, s15, s14
 802d0d2:	d106      	bne.n	802d0e2 <expm1f+0x162>
 802d0d4:	ee70 7a67 	vsub.f32	s15, s0, s15
 802d0d8:	eebe 0a00 	vmov.f32	s0, #224	; 0xbf000000 -0.5
 802d0dc:	eea7 0aa5 	vfma.f32	s0, s15, s11
 802d0e0:	4770      	bx	lr
 802d0e2:	2b01      	cmp	r3, #1
 802d0e4:	d118      	bne.n	802d118 <expm1f+0x198>
 802d0e6:	eebd 7a00 	vmov.f32	s14, #208	; 0xbe800000 -0.250
 802d0ea:	eeb4 0ac7 	vcmpe.f32	s0, s14
 802d0ee:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802d0f2:	bf5b      	ittet	pl
 802d0f4:	ee70 7a67 	vsubpl.f32	s15, s0, s15
 802d0f8:	eeb0 7a00 	vmovpl.f32	s14, #0	; 0x40000000  2.0
 802d0fc:	ee30 0a25 	vaddmi.f32	s0, s0, s11
 802d100:	eea7 6a87 	vfmapl.f32	s12, s15, s14
 802d104:	bf43      	ittte	mi
 802d106:	ee77 7ac0 	vsubmi.f32	s15, s15, s0
 802d10a:	eeb8 0a00 	vmovmi.f32	s0, #128	; 0xc0000000 -2.0
 802d10e:	ee27 0a80 	vmulmi.f32	s0, s15, s0
 802d112:	eeb0 0a46 	vmovpl.f32	s0, s12
 802d116:	4770      	bx	lr
 802d118:	1c5a      	adds	r2, r3, #1
 802d11a:	2a39      	cmp	r2, #57	; 0x39
 802d11c:	ea4f 51c3 	mov.w	r1, r3, lsl #23
 802d120:	d90b      	bls.n	802d13a <expm1f+0x1ba>
 802d122:	ee37 0ac0 	vsub.f32	s0, s15, s0
 802d126:	ee36 0a40 	vsub.f32	s0, s12, s0
 802d12a:	ee10 3a10 	vmov	r3, s0
 802d12e:	440b      	add	r3, r1
 802d130:	ee00 3a10 	vmov	s0, r3
 802d134:	ee30 0a46 	vsub.f32	s0, s0, s12
 802d138:	4770      	bx	lr
 802d13a:	2b16      	cmp	r3, #22
 802d13c:	dc11      	bgt.n	802d162 <expm1f+0x1e2>
 802d13e:	f04f 7280 	mov.w	r2, #16777216	; 0x1000000
 802d142:	fa42 f303 	asr.w	r3, r2, r3
 802d146:	f1c3 537e 	rsb	r3, r3, #1065353216	; 0x3f800000
 802d14a:	ee37 0ac0 	vsub.f32	s0, s15, s0
 802d14e:	ee07 3a90 	vmov	s15, r3
 802d152:	ee37 0ac0 	vsub.f32	s0, s15, s0
 802d156:	ee10 3a10 	vmov	r3, s0
 802d15a:	440b      	add	r3, r1
 802d15c:	ee00 3a10 	vmov	s0, r3
 802d160:	4770      	bx	lr
 802d162:	f1c3 037f 	rsb	r3, r3, #127	; 0x7f
 802d166:	05db      	lsls	r3, r3, #23
 802d168:	ee07 3a10 	vmov	s14, r3
 802d16c:	ee77 7a87 	vadd.f32	s15, s15, s14
 802d170:	ee70 7a67 	vsub.f32	s15, s0, s15
 802d174:	ee37 0a86 	vadd.f32	s0, s15, s12
 802d178:	e7ed      	b.n	802d156 <expm1f+0x1d6>
 802d17a:	bf00      	nop
 802d17c:	4195b843 	.word	0x4195b843
 802d180:	42b17217 	.word	0x42b17217
 802d184:	0da24260 	.word	0x0da24260
 802d188:	3eb17218 	.word	0x3eb17218
 802d18c:	3f851591 	.word	0x3f851591
 802d190:	3f317180 	.word	0x3f317180
 802d194:	3717f7d1 	.word	0x3717f7d1
 802d198:	b717f7d1 	.word	0xb717f7d1
 802d19c:	b457edbb 	.word	0xb457edbb
 802d1a0:	36867e54 	.word	0x36867e54
 802d1a4:	bd088889 	.word	0xbd088889
 802d1a8:	b8a670cd 	.word	0xb8a670cd
 802d1ac:	3ad00d01 	.word	0x3ad00d01
 802d1b0:	3fb8aa3b 	.word	0x3fb8aa3b
 802d1b4:	7149f2ca 	.word	0x7149f2ca

0802d1b8 <finitef>:
 802d1b8:	b082      	sub	sp, #8
 802d1ba:	ed8d 0a01 	vstr	s0, [sp, #4]
 802d1be:	9801      	ldr	r0, [sp, #4]
 802d1c0:	f020 4000 	bic.w	r0, r0, #2147483648	; 0x80000000
 802d1c4:	f1b0 4fff 	cmp.w	r0, #2139095040	; 0x7f800000
 802d1c8:	bfac      	ite	ge
 802d1ca:	2000      	movge	r0, #0
 802d1cc:	2001      	movlt	r0, #1
 802d1ce:	b002      	add	sp, #8
 802d1d0:	4770      	bx	lr
	...

0802d1d4 <nanf>:
 802d1d4:	ed9f 0a01 	vldr	s0, [pc, #4]	; 802d1dc <nanf+0x8>
 802d1d8:	4770      	bx	lr
 802d1da:	bf00      	nop
 802d1dc:	7fc00000 	.word	0x7fc00000

0802d1e0 <scalbnf>:
 802d1e0:	ee10 3a10 	vmov	r3, s0
 802d1e4:	f033 4200 	bics.w	r2, r3, #2147483648	; 0x80000000
 802d1e8:	d025      	beq.n	802d236 <scalbnf+0x56>
 802d1ea:	f1b2 4fff 	cmp.w	r2, #2139095040	; 0x7f800000
 802d1ee:	d302      	bcc.n	802d1f6 <scalbnf+0x16>
 802d1f0:	ee30 0a00 	vadd.f32	s0, s0, s0
 802d1f4:	4770      	bx	lr
 802d1f6:	f013 4fff 	tst.w	r3, #2139095040	; 0x7f800000
 802d1fa:	d122      	bne.n	802d242 <scalbnf+0x62>
 802d1fc:	4b2a      	ldr	r3, [pc, #168]	; (802d2a8 <scalbnf+0xc8>)
 802d1fe:	eddf 7a2b 	vldr	s15, [pc, #172]	; 802d2ac <scalbnf+0xcc>
 802d202:	4298      	cmp	r0, r3
 802d204:	ee20 0a27 	vmul.f32	s0, s0, s15
 802d208:	db16      	blt.n	802d238 <scalbnf+0x58>
 802d20a:	ee10 3a10 	vmov	r3, s0
 802d20e:	f3c3 52c7 	ubfx	r2, r3, #23, #8
 802d212:	3a19      	subs	r2, #25
 802d214:	4402      	add	r2, r0
 802d216:	2afe      	cmp	r2, #254	; 0xfe
 802d218:	dd15      	ble.n	802d246 <scalbnf+0x66>
 802d21a:	ee10 3a10 	vmov	r3, s0
 802d21e:	eddf 7a24 	vldr	s15, [pc, #144]	; 802d2b0 <scalbnf+0xd0>
 802d222:	eddf 6a24 	vldr	s13, [pc, #144]	; 802d2b4 <scalbnf+0xd4>
 802d226:	2b00      	cmp	r3, #0
 802d228:	eeb0 7a67 	vmov.f32	s14, s15
 802d22c:	bfb8      	it	lt
 802d22e:	eef0 7a66 	vmovlt.f32	s15, s13
 802d232:	ee27 0a27 	vmul.f32	s0, s14, s15
 802d236:	4770      	bx	lr
 802d238:	eddf 7a1f 	vldr	s15, [pc, #124]	; 802d2b8 <scalbnf+0xd8>
 802d23c:	ee20 0a27 	vmul.f32	s0, s0, s15
 802d240:	4770      	bx	lr
 802d242:	0dd2      	lsrs	r2, r2, #23
 802d244:	e7e6      	b.n	802d214 <scalbnf+0x34>
 802d246:	2a00      	cmp	r2, #0
 802d248:	dd06      	ble.n	802d258 <scalbnf+0x78>
 802d24a:	f023 43ff 	bic.w	r3, r3, #2139095040	; 0x7f800000
 802d24e:	ea43 53c2 	orr.w	r3, r3, r2, lsl #23
 802d252:	ee00 3a10 	vmov	s0, r3
 802d256:	4770      	bx	lr
 802d258:	f112 0f16 	cmn.w	r2, #22
 802d25c:	da1a      	bge.n	802d294 <scalbnf+0xb4>
 802d25e:	f24c 3350 	movw	r3, #50000	; 0xc350
 802d262:	4298      	cmp	r0, r3
 802d264:	ee10 3a10 	vmov	r3, s0
 802d268:	f003 4300 	and.w	r3, r3, #2147483648	; 0x80000000
 802d26c:	dd0a      	ble.n	802d284 <scalbnf+0xa4>
 802d26e:	ed9f 0a10 	vldr	s0, [pc, #64]	; 802d2b0 <scalbnf+0xd0>
 802d272:	ed9f 7a10 	vldr	s14, [pc, #64]	; 802d2b4 <scalbnf+0xd4>
 802d276:	eef0 7a40 	vmov.f32	s15, s0
 802d27a:	2b00      	cmp	r3, #0
 802d27c:	bf18      	it	ne
 802d27e:	eeb0 0a47 	vmovne.f32	s0, s14
 802d282:	e7db      	b.n	802d23c <scalbnf+0x5c>
 802d284:	ed9f 0a0c 	vldr	s0, [pc, #48]	; 802d2b8 <scalbnf+0xd8>
 802d288:	ed9f 7a0c 	vldr	s14, [pc, #48]	; 802d2bc <scalbnf+0xdc>
 802d28c:	eef0 7a40 	vmov.f32	s15, s0
 802d290:	2b00      	cmp	r3, #0
 802d292:	e7f3      	b.n	802d27c <scalbnf+0x9c>
 802d294:	3219      	adds	r2, #25
 802d296:	f023 43ff 	bic.w	r3, r3, #2139095040	; 0x7f800000
 802d29a:	ea43 53c2 	orr.w	r3, r3, r2, lsl #23
 802d29e:	eddf 7a08 	vldr	s15, [pc, #32]	; 802d2c0 <scalbnf+0xe0>
 802d2a2:	ee07 3a10 	vmov	s14, r3
 802d2a6:	e7c4      	b.n	802d232 <scalbnf+0x52>
 802d2a8:	ffff3cb0 	.word	0xffff3cb0
 802d2ac:	4c000000 	.word	0x4c000000
 802d2b0:	7149f2ca 	.word	0x7149f2ca
 802d2b4:	f149f2ca 	.word	0xf149f2ca
 802d2b8:	0da24260 	.word	0x0da24260
 802d2bc:	8da24260 	.word	0x8da24260
 802d2c0:	33000000 	.word	0x33000000

0802d2c4 <_init>:
 802d2c4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 802d2c6:	bf00      	nop
 802d2c8:	bcf8      	pop	{r3, r4, r5, r6, r7}
 802d2ca:	bc08      	pop	{r3}
 802d2cc:	469e      	mov	lr, r3
 802d2ce:	4770      	bx	lr

0802d2d0 <_fini>:
 802d2d0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 802d2d2:	bf00      	nop
 802d2d4:	bcf8      	pop	{r3, r4, r5, r6, r7}
 802d2d6:	bc08      	pop	{r3}
 802d2d8:	469e      	mov	lr, r3
 802d2da:	4770      	bx	lr
 802d2dc:	0000      	movs	r0, r0
	...
